<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: loaders/loaders.volume.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: loaders/loaders.volume.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** * Imports ***/
let pako = require('pako');

import LoadersBase from './loaders.base';
import ModelsSeries from '../../src/models/models.series';
import ModelsStack from '../../src/models/models.stack';
import ModelsFrame from '../../src/models/models.frame';
import ParsersDicom from '../../src/parsers/parsers.dicom';
import ParsersNifti from '../../src/parsers/parsers.nifti';
import ParsersNrrd from '../../src/parsers/parsers.nrrd';


/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/volumes
 *
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
export default class LoadersVolumes extends LoadersBase {

  parse(response) {
    // give a chance to the UI to update because after the rendering will be blocked with intensive JS
    if(this._progressBar) {
      this._progressBar.update(0, 100, 'parse');
    }

    return new Promise(
        (resolve, reject) => {
            window.setTimeout(
              () => {
                resolve(new Promise((resolve, reject) => {
                  let data = response;
                  data.gzcompressed = false;
                  data.filename = '';
                  data.extension = '';

                  // uncompress?
                  data.filename = response.url.split('/').pop();
                  data.gzcompressed = false;

                  // find extension
                  let splittedName = data.filename.split('.');
                  if(splittedName.length &lt;= 1) {
                    data.extension = '';
                  } else{
                    data.extension = data.filename.split('.').pop();
                  }

                  // unzip if extension is '.gz'
                  if (data.extension === 'gz') {
                    data.gzcompressed = true;
                    data.extension = data.filename.split('.gz').shift().split('.').pop();
                    let decompressedData = pako.inflate(data.buffer);
                    data.buffer = decompressedData.buffer;
                  }

                  let parser = this._parser(data.extension);
                  if (!parser) {
                    reject(data.filename + ' can not be parsed.');
                  }

                  // check extension
                  let volumeParser = null;
                  try {
                    volumeParser = new parser(data, 0);
                  } catch (e) {
                    window.console.log(e);
                    reject(e);
                  }

                  // create a series
                  let series = new ModelsSeries();
                  series.seriesInstanceUID = volumeParser.seriesInstanceUID();
                  series.numberOfFrames = volumeParser.numberOfFrames();
                  if (!series.numberOfFrames) {
                    series.numberOfFrames = 1;
                  }
                  series.numberOfChannels = volumeParser.numberOfChannels();
                  series.modality = volumeParser.modality();
                  // if it is a segmentation, attach extra information
                  if(series.modality === 'SEG') {
                    // colors
                    // labels
                    // etc.
                    series.segmentationType = volumeParser.segmentationType();
                    series.segmentationSegments = volumeParser.segmentationSegments();
                  }

                  // just create 1 dummy stack for now
                  let stack = new ModelsStack();
                  stack.numberOfChannels = volumeParser.numberOfChannels();
                  stack.pixelRepresentation = volumeParser.pixelRepresentation();
                  stack.pixelType = volumeParser.pixelType();
                  stack.invert = volumeParser.invert();
                  stack.spacingBetweenSlices = volumeParser.spacingBetweenSlices();
                  stack.modality = series.modality;
                  // if it is a segmentation, attach extra information
                  if(stack.modality === 'SEG') {
                    // colors
                    // labels
                    // etc.
                    stack.segmentationType = series.segmentationType;
                    stack.segmentationSegments = series.segmentationSegments;
                  }
                  series.stack.push(stack);
                  // recursive call for each frame
                  // better than for loop to be able to update dom with "progress" callback
                  setTimeout(this.parseFrame(series, stack, response.url, 0, volumeParser, resolve, reject), 0);
                }));
             }, 10);
           }
        );
  }

  parseFrame(series, stack, url, i, dataParser, resolve, reject) {
    let frame = new ModelsFrame();
    frame.sopInstanceUID = dataParser.sopInstanceUID(i);
    frame.url = url;
    frame.index = i;
    frame.rows = dataParser.rows(i);
    frame.columns = dataParser.columns(i);
    frame.numberOfChannels = stack.numberOfChannels;
    frame.pixelRepresentation = stack.pixelRepresentation;
    frame.pixelType = stack.pixelType;
    frame.pixelData = dataParser.extractPixelData(i);
    frame.pixelSpacing = dataParser.pixelSpacing(i);
    frame.spacingBetweenSlices = dataParser.spacingBetweenSlices(i);
    frame.sliceThickness = dataParser.sliceThickness(i);
    frame.imageOrientation = dataParser.imageOrientation(i);
    frame.rightHanded = dataParser.rightHanded();
    stack.rightHanded = frame.rightHanded;
    if (frame.imageOrientation === null) {
      frame.imageOrientation = [1, 0, 0, 0, 1, 0];
    }
    frame.imagePosition = dataParser.imagePosition(i);
    if (frame.imagePosition === null) {
      frame.imagePosition = [0, 0, i];
    }
    frame.dimensionIndexValues = dataParser.dimensionIndexValues(i);
    frame.bitsAllocated = dataParser.bitsAllocated(i);
    frame.instanceNumber = dataParser.instanceNumber(i);
    frame.windowCenter = dataParser.windowCenter(i);
    frame.windowWidth = dataParser.windowWidth(i);
    frame.rescaleSlope = dataParser.rescaleSlope(i);
    frame.rescaleIntercept = dataParser.rescaleIntercept(i);
    // should pass frame index for consistency...
    frame.minMax = dataParser.minMaxPixelData(frame.pixelData);

    // if series.mo
    if(series.modality === 'SEG') {
      frame.referencedSegmentNumber = dataParser.referencedSegmentNumber(i);
    }

    stack.frame.push(frame);

    // update status
    this._parsed = i + 1;
    this._totalParsed = series.numberOfFrames;
    if(this._progressBar) {
      this._progressBar.update(this._parsed, this._totalParsed, 'parse');
    }

    if (this._parsed === this._totalParsed) {
      resolve(series);
    } else {
      setTimeout(this.parseFrame(series, stack, url, this._parsed, dataParser, resolve, reject), 0);
    }
  }

  _parser(extension) {
    let parser = null;

    switch (extension.toUpperCase()) {
      case 'NII':
      case 'NII_':
        parser = ParsersNifti;
        break;
      case 'DCM':
      case 'DICOM':
      case 'IMA':
      case '':
        parser = ParsersDicom;
        break;
      case 'NRRD':
        parser = ParsersNrrd;
        break;
      default:
        window.console.log('unsupported extension: ' + extension);
        return false;
    }
    return parser;
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cameras.html">cameras</a></li><li><a href="module-cameras_orthographic.html">cameras/orthographic</a></li><li><a href="module-core.html">core</a></li><li><a href="module-core_intersections.html">core/intersections</a></li><li><a href="module-core_pack.html">core/pack</a></li><li><a href="module-core_utils.html">core/utils</a></li><li><a href="module-core_validators.html">core/validators</a></li><li><a href="module-geometries.html">geometries</a></li><li><a href="module-geometries_slice.html">geometries/slice</a></li><li><a href="module-geometries_voxel.html">geometries/voxel</a></li><li><a href="module-helpers.html">helpers</a></li><li><a href="module-helpers_border.html">helpers/border</a></li><li><a href="module-helpers_boundingbox.html">helpers/boundingbox</a></li><li><a href="module-helpers_dummy.html">helpers/dummy</a></li><li><a href="module-helpers_lut.html">helpers/lut</a></li><li><a href="module-helpers_material_mixin.html">helpers/material/mixin</a></li><li><a href="module-helpers_progressBar.html">helpers/progressBar</a></li><li><a href="module-helpers_slice.html">helpers/slice</a></li><li><a href="module-helpers_stack.html">helpers/stack</a></li><li><a href="module-helpers_volumerendering.html">helpers/volumerendering</a></li><li><a href="module-helpers_voxel.html">helpers/voxel</a></li><li><a href="module-helpers_x_interactor.html">helpers/x/interactor</a></li><li><a href="module-helpers_x_mesh.html">helpers/x/mesh</a></li><li><a href="module-helpers_x_renderer2d.html">helpers/x/renderer2d</a></li><li><a href="module-helpers_x_renderer3d.html">helpers/x/renderer3d</a></li><li><a href="module-helpers_x_volume.html">helpers/x/volume</a></li><li><a href="module-loaders.html">loaders</a></li><li><a href="module-loaders_base.html">loaders/base</a></li><li><a href="module-loaders_volumes.html">loaders/volumes</a></li><li><a href="module-models.html">models</a></li><li><a href="module-models_base.html">models/base</a></li><li><a href="module-models_frame.html">models/frame</a></li><li><a href="module-models_series.html">models/series</a></li><li><a href="module-models_stack.html">models/stack</a></li><li><a href="module-models_voxel.html">models/voxel</a></li><li><a href="module-parsers.html">parsers</a></li><li><a href="module-parsers_dicom.html">parsers/dicom</a></li><li><a href="module-parsers_nifti.html">parsers/nifti</a></li><li><a href="module-parsers_volume.html">parsers/volume</a></li><li><a href="module-shaders.html">shaders</a></li><li><a href="module-shaders_data.html">shaders/data</a></li><li><a href="module-widgets.html">widgets</a></li><li><a href="module-widgets_handle.html">widgets/handle</a></li><li><a href="module-widgets_squareProbe.html">widgets/squareProbe</a></li><li><a href="module-widgets_voxelProbe.html">widgets/voxelProbe</a></li></ul><h3>Classes</h3><ul><li><a href="module.exports.html">exports</a></li><li><a href="module-loaders_base.html">loaders/base</a></li></ul><h3>Global</h3><ul><li><a href="global.html#moduleType">moduleType</a></li><li><a href="global.html#pako">pako</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.0-dev</a> on Wed Feb 01 2017 17:54:42 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
