<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: cameras/cameras.orthographic.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: cameras/cameras.orthographic.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Intersections from '../core/core.intersections';
import Validators from '../core/core.validators';

/**
 * Orthographic camera from THREE.JS with some extra convenience
 * functionalities.
 *
 * @example
 * //
 * //
 *
 * @module cameras/orthographic
 */
export default class CamerasOrthographic extends THREE.OrthographicCamera {
  constructor(left, right, top, bottom, near, far) {
    super(left, right, top, bottom, near, far);

    this._front = null;
    this._back = null;

    this._directions = [
      new THREE.Vector3(1, 0, 0),
      new THREE.Vector3(0, 1, 0),
      new THREE.Vector3(0, 0, 1),
      ];

    this._directionsLabel = [
      'A', 'P', // TOP/BOTTOM
      'L', 'R', // LEFT/RIGHT
      'I', 'S', // FROM/TO
    ];

    this._orientation = 'default';
    this._convention = 'radio';
    this._stackOrientation = 0;

    this._right = null;
    this._up = null;
    this._direction = null;

    this._controls = null;
    this._box = null;
    this._canvas = {
      width: null,
      height: null,
    };

    this._fromFront = true;
    this._angle = 0;
  }

  /**
   * Initialize orthographic camera variables
   */
  init(xCosine, yCosine, zCosine, controls, box, canvas) {
    // DEPRECATED
    console.warn(
      `cameras.orthographic.init(...) is deprecated.
      Use .cosines, .controls, .box and .canvas instead.`);

    //
    if (!(Validators.vector3(xCosine) &amp;&amp;
      Validators.vector3(yCosine) &amp;&amp;
      Validators.vector3(zCosine) &amp;&amp;
      Validators.box(box) &amp;&amp;
      controls)) {
      window.console.log('Invalid input provided.');

      return false;
    }

    this._right = xCosine;
    this._up = this._adjustTopDirection(xCosine, yCosine);
    this._direction = new THREE.Vector3().crossVectors(this._right, this._up);
    this._controls = controls;
    this._box = box;
    this._canvas = canvas;

    let ray = {
      position: this._box.center,
      direction: this._direction,
    };

    let intersections =
      this._orderIntersections(
        Intersections.rayBox(ray, this._box),
        this._direction);
    this._front = intersections[0];
    this._back = intersections[1];

    // set default values
    this.up.set(this._up.x, this._up.y, this._up.z);
    this._updateCanvas();
    this._updatePositionAndTarget(this._front, this._back);
    this._updateMatrices();
    this._updateDirections();
  }

  update() {
    // http://www.grahamwideman.com/gw/brain/orientation/orientterms.htm
    // do magics depending on orientation and convention
    // also needs a default mode

    if (this._orientation === 'default') {
      switch (this._getMaxIndex(this._directions[2])) {

        case 0:
          this._orientation = 'sagittal';
          break;

        case 1:
          this._orientation = 'coronal';
          break;

        case 2:
          this._orientation = 'axial';
          break;

        default:
          this._orientation = 'free';
          break;
      }
    }

    if (this._orientation === 'free') {
      this._right = this._directions[0];
      this._up = this._directions[1];
      this._direction = this._directions[2];
    } else {
      let leftIndex = this.leftDirection();
      let leftDirection = this._directions[leftIndex];
      let posteriorIndex = this.posteriorDirection();
      let posteriorDirection = this._directions[posteriorIndex];
      let superiorIndex = this.superiorDirection();
      let superiorDirection = this._directions[superiorIndex];

      if (this._convention === 'radio') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards superior
              if (superiorDirection.z &lt; 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z &lt; 0) {
                superiorDirection.negate();
              }

              // looking towards posterior
              if (posteriorDirection.y &lt; 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z &lt; 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn(
                `"${this._orientation}" orientation is not valid.
                (choices: axial, coronal, sagittal)`);
              break;

          }
      } else if (this._convention === 'neuro') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards inferior
              if (superiorDirection.z > 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z &lt; 0) {
                superiorDirection.negate();
              }

              // looking towards anterior
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z &lt; 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn(
                `"${this._orientation}" orientation is not valid.
                (choices: axial, coronal, sagittal)`);
              break;
          }
      } else {
        console.warn(
          `${this._convention} is not valid (choices: radio, neuro)`);
      }
    }

    // that is what determines left/right
    let ray = {
      position: this._box.center,
      direction: this._direction,
    };

    let intersections =
      this._orderIntersections(
        Intersections.rayBox(ray, this._box),
        this._direction);
    this._front = intersections[0];
    this._back = intersections[1];

    // set default values
    this.up.set(this._up.x, this._up.y, this._up.z);
    this._updateCanvas();
    this._updatePositionAndTarget(this._front, this._back);
    this._updateMatrices();
    this._updateDirections();
  }

  leftDirection() {
    return this._findMaxIndex(this._directions, 0);
  }

  posteriorDirection() {
    return this._findMaxIndex(this._directions, 1);
  }

  superiorDirection() {
    return this._findMaxIndex(this._directions, 2);
  }

  /**
   * Invert rows in the current slice.
   * Inverting rows in 2 steps:
   *   * Flip the "up" vector
   *   * Look at the slice from the other side
   */
  invertRows() {
    // flip "up" vector
    // we flip up first because invertColumns update projectio matrices
    this.up.multiplyScalar(-1);
    this.invertColumns();

    this._updateDirections();
  }

  /**
   * Invert rows in the current slice.
   * Inverting rows in 1 step:
   *   * Look at the slice from the other side
   */
  invertColumns() {
    this.center();
    // rotate 180 degrees around the up vector...
    let oppositePosition = this._oppositePosition(this.position);

    // update posistion and target
    // clone is needed because this.position is overwritten in method
    this._updatePositionAndTarget(oppositePosition, this.position.clone());
    this._updateMatrices();
    this._fromFront = !this._fromFront;

    this._angle %= 360;
    this._angle = 360 - this._angle;

    this._updateDirections();
  }

  /**
   * Center slice in the camera FOV.
   * It also updates the controllers properly.
   * We can center a camera from the front or from the back.
   */
  center() {
    if (this._fromFront) {
      this._updatePositionAndTarget(this._front, this._back);
    } else {
      this._updatePositionAndTarget(this._back, this._front);
    }

    this._updateMatrices();
    this._updateDirections();
  }

  /**
   * Pi/2 rotation around the zCosine axis.
   * Clock-wise rotation from the user point of view.
   */
  rotate(angle=null) {
    this.center();

    let computedAngle = 90;

    let clockwise = 1;
    if (!this._fromFront) {
      clockwise = -1;
    }

    if (angle === null) {
      computedAngle *= -clockwise;
      this._angle += 90;
    } else {
      computedAngle = 360 - clockwise * (angle - this._angle);
      this._angle = angle;
    }

    this._angle %= 360;

    // Rotate the up vector around the "zCosine"
    let rotation = new THREE.Matrix4().makeRotationAxis(
      this._direction,
      computedAngle * Math.PI/180);
    this.up.applyMatrix4(rotation);

    this._updateMatrices();
    this._updateDirections();
  }

  // dimensions[0] // width
  // dimensions[1] // height
  // direction= 0 width, 1 height, 2 best
  // factor
  fitBox(direction = 0, factor=1.5) {
    //
    // if (!(dimensions &amp;&amp; dimensions.length >= 2)) {
    //   window.console.log('Invalid dimensions container.');
    //   window.console.log(dimensions);

    //   return false;
    // }

    //
    let zoom = 1;

    // update zoom
    switch (direction) {
      case 0:
        zoom = factor * this._computeZoom(this._canvas.width, this._right);
        break;
      case 1:
        zoom = factor * this._computeZoom(this._canvas.height, this._up);
        break;
      case 2:
        zoom = factor * (Math.min(
          this._computeZoom(this._canvas.width, this._right),
          this._computeZoom(this._canvas.height, this._up)
        ));
        break;
      default:
        break;
    }

    if (!zoom) {
      return false;
    }

    this.zoom = zoom;

    this.center();
  }

  _adjustTopDirection(horizontalDirection, verticalDirection) {
    const vMaxIndex = this._getMaxIndex(verticalDirection);

    // should handle vMax index === 0
    if ((vMaxIndex === 2 &amp;&amp; verticalDirection.getComponent(vMaxIndex) &lt; 0) ||
        (vMaxIndex === 1 &amp;&amp; verticalDirection.getComponent(vMaxIndex) > 0) ||
        (vMaxIndex === 0 &amp;&amp; verticalDirection.getComponent(vMaxIndex) > 0)) {
      verticalDirection.negate();
    }

   return verticalDirection;
  }

  _getMaxIndex(vector) {
    // init with X value
    let maxValue = Math.abs(vector.x);
    let index = 0;

    if (Math.abs(vector.y) > maxValue) {
      maxValue = Math.abs(vector.y);
      index = 1;
    }

    if (Math.abs(vector.z) > maxValue) {
      index = 2;
    }

    return index;
  }

  _findMaxIndex(directions, target) {
    // get index of the most superior direction
    let maxIndices = this._getMaxIndices(directions);

    for (let i = 0; i &lt; maxIndices.length; i++) {
      if (maxIndices[i] === target) {
        return i;
      }
    }
  }

  _getMaxIndices(directions) {
    let indices = [];
    indices.push(this._getMaxIndex(directions[0]));
    indices.push(this._getMaxIndex(directions[1]));
    indices.push(this._getMaxIndex(directions[2]));

    return indices;
  }

  _orderIntersections(intersections, direction) {
    const ordered =
      intersections[0].dot(direction) &lt; intersections[1].dot(direction);

    if (!ordered) {
        return [intersections[1], intersections[0]];
    }

   return intersections;
  }

  _updateCanvas() {
    let camFactor = 2;
    this.left = -this._canvas.width / camFactor;
    this.right = this._canvas.width / camFactor;
    this.top = this._canvas.height / camFactor;
    this.bottom = -this._canvas.height / camFactor;

    this._updateMatrices();
    this.controls.handleResize();
  }

  _oppositePosition(position) {
    let oppositePosition = position.clone();
    // center world postion around box center
    oppositePosition.sub(this._box.center);
    // rotate
    let rotation = new THREE.Matrix4().makeRotationAxis(
      this.up,
      Math.PI);

    oppositePosition.applyMatrix4(rotation);
    // translate back to world position
    oppositePosition.add(this._box.center);
    return oppositePosition;
  }

  _computeZoom(dimension, direction) {
    if (!(dimension &amp;&amp; dimension > 0)) {
      window.console.log('Invalid dimension provided.');
      window.console.log(dimension);
      return false;
    }

    // ray
    let ray = {
      position: this._box.center.clone(),
      direction: direction,
    };

    let intersections = Intersections.rayBox(ray, this._box);
    if (intersections.length &lt; 2) {
      window.console.log('Can not adjust the camera ( &lt; 2 intersections).');
      window.console.log(ray);
      window.console.log(this._box);
      return false;
    }

    return dimension / intersections[0].distanceTo(intersections[1]);
  }

  _updatePositionAndTarget(position, target) {
      // position
      this.position.set(position.x, position.y, position.z);

      // targets
      this.lookAt(target.x, target.y, target.z);
      this._controls.target.set(target.x, target.y, target.z);
  }

  _updateMatrices() {
    this._controls.update();
    // THEN camera
    this.updateProjectionMatrix();
    this.updateMatrixWorld();
  }

  _updateLabels() {
    this._directionsLabel = [
      this._vector2Label(this._up),
      this._vector2Label(this._up.clone().negate()),
      this._vector2Label(this._right),
      this._vector2Label(this._right.clone().negate()),
      this._vector2Label(this._direction),
      this._vector2Label(this._direction.clone().negate()),
    ];
  }

  _vector2Label(direction) {
    const index = this._getMaxIndex(direction);
    // set vector max value to 1
    const scaledDirection =
      direction.clone().divideScalar(Math.abs(direction.getComponent(index)));
    const delta = 0.2;
    let label = '';

    // loop through components of the vector
    for (let i = 0; i&lt;3; i++) {
      if (i === 0) {
        if (scaledDirection.getComponent(i) + delta >= 1) {
          label += 'L';
        } else if (scaledDirection.getComponent(i) - delta &lt;= -1) {
          label += 'R';
        }
      }

      if (i === 1) {
        if (scaledDirection.getComponent(i) + delta >= 1) {
          label += 'P';
        } else if (scaledDirection.getComponent(i) - delta &lt;= -1) {
          label += 'A';
        }
      }

      if (i === 2) {
        if (scaledDirection.getComponent(i) + delta >= 1) {
          label += 'S';
        } else if (scaledDirection.getComponent(i) - delta &lt;= -1) {
          label += 'I';
        }
      }
    }

    return label;
  }

  _updateDirections() {
    // up is correct
    this._up = this.up.clone();

    // direction
    let pLocal = new THREE.Vector3(0, 0, -1);
    let pWorld = pLocal.applyMatrix4(this.matrixWorld);
    this._direction = pWorld.sub(this.position).normalize();

    // right
    this._right = new THREE.Vector3().crossVectors(this._direction, this.up);

    // update labels accordingly
    this._updateLabels();
  }

  set controls(controls) {
    this._controls = controls;
  }

  get controls() {
    return this._controls;
  }

  set box(box) {
    this._box = box;
  }

  get box() {
    return this._box;
  }

  set canvas(canvas) {
    this._canvas = canvas;
    this._updateCanvas();
  }

  get canvas() {
    return this._canvas;
  }

  set angle(angle) {
    this.rotate(angle);
  }

  get angle() {
    return this._angle;
  }

  set directions(directions) {
    this._directions = directions;
  }

  get directions() {
    return this._directions;
  }

  set convention(convention) {
    this._convention = convention;
  }

  get convention() {
    return this._convention;
  }

  set orientation(orientation) {
    this._orientation = orientation;
  }

  get orientation() {
    return this._orientation;
  }

  set directionsLabel(directionsLabel) {
    this._directionsLabel = directionsLabel;
  }

  get directionsLabel() {
    return this._directionsLabel;
  }

  set stackOrientation(stackOrientation) {
    this._stackOrientation = stackOrientation;

    if (this._stackOrientation === 0) {
      this._orientation = 'default';
    } else {
      const maxIndex =
        this._getMaxIndex(
          this._directions[(this._stackOrientation + 2) % 3]);

      if (maxIndex === 0) {
        this._orientation = 'sagittal';
      } else if (maxIndex === 1) {
        this._orientation = 'coronal';
      } else if (maxIndex === 2) {
        this._orientation = 'axial';
      }
    }
  }

  get stackOrientation() {
    //
    if (this._orientation === 'default') {
      this._stackOrientation = 0;
    } else {
      let maxIndex = this._getMaxIndex(this._direction);

      if (maxIndex === this._getMaxIndex(this._directions[2])) {
        this._stackOrientation = 0;
      } else if (maxIndex === this._getMaxIndex(this._directions[0])) {
        this._stackOrientation = 1;
      } else if (maxIndex === this._getMaxIndex(this._directions[1])) {
        this._stackOrientation = 2;
      }
    }

    return this._stackOrientation;
  }

}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cameras.html">cameras</a></li><li><a href="module-cameras_orthographic.html">cameras/orthographic</a></li><li><a href="module-core.html">core</a></li><li><a href="module-core_intersections.html">core/intersections</a></li><li><a href="module-core_pack.html">core/pack</a></li><li><a href="module-core_utils.html">core/utils</a></li><li><a href="module-core_validators.html">core/validators</a></li><li><a href="module-geometries.html">geometries</a></li><li><a href="module-geometries_slice.html">geometries/slice</a></li><li><a href="module-geometries_voxel.html">geometries/voxel</a></li><li><a href="module-helpers.html">helpers</a></li><li><a href="module-helpers_border.html">helpers/border</a></li><li><a href="module-helpers_boundingbox.html">helpers/boundingbox</a></li><li><a href="module-helpers_dummy.html">helpers/dummy</a></li><li><a href="module-helpers_localizer.html">helpers/localizer</a></li><li><a href="module-helpers_lut.html">helpers/lut</a></li><li><a href="module-helpers_material_mixin.html">helpers/material/mixin</a></li><li><a href="module-helpers_progressBar.html">helpers/progressBar</a></li><li><a href="module-helpers_slice.html">helpers/slice</a></li><li><a href="module-helpers_stack.html">helpers/stack</a></li><li><a href="module-helpers_volumerendering.html">helpers/volumerendering</a></li><li><a href="module-helpers_x_interactor.html">helpers/x/interactor</a></li><li><a href="module-helpers_x_mesh.html">helpers/x/mesh</a></li><li><a href="module-helpers_x_renderer2d.html">helpers/x/renderer2d</a></li><li><a href="module-helpers_x_renderer3d.html">helpers/x/renderer3d</a></li><li><a href="module-helpers_x_volume.html">helpers/x/volume</a></li><li><a href="module-loaders.html">loaders</a></li><li><a href="module-loaders_base.html">loaders/base</a></li><li><a href="module-loaders_volumes.html">loaders/volumes</a></li><li><a href="module-models.html">models</a></li><li><a href="module-models_base.html">models/base</a></li><li><a href="module-models_frame.html">models/frame</a></li><li><a href="module-models_series.html">models/series</a></li><li><a href="module-models_stack.html">models/stack</a></li><li><a href="module-models_voxel.html">models/voxel</a></li><li><a href="module-parsers.html">parsers</a></li><li><a href="module-parsers_dicom.html">parsers/dicom</a></li><li><a href="module-parsers_mhd.html">parsers/mhd</a></li><li><a href="module-parsers_nifti.html">parsers/nifti</a></li><li><a href="module-parsers_volume.html">parsers/volume</a></li><li><a href="module-shaders.html">shaders</a></li><li><a href="module-shaders_data.html">shaders/data</a></li><li><a href="module-shaders_localizer_uniforms.html">shaders/localizer/uniforms</a></li><li><a href="module-widgets.html">widgets</a></li><li><a href="module-widgets_handle.html">widgets/handle</a></li><li><a href="module-widgets_voxelProbe.html">widgets/voxelProbe</a></li></ul><h3>Classes</h3><ul><li><a href="module.exports.html">exports</a></li><li><a href="module-loaders_base.html">loaders/base</a></li><li><a href="module-models_frame.html">models/frame</a></li><li><a href="module-models_series.html">models/series</a></li><li><a href="module-models_stack.html">models/stack</a></li><li><a href="module-parsers_nifti.html">parsers/nifti</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cielab2RGB">cielab2RGB</a></li><li><a href="global.html#cielab2XYZ">cielab2XYZ</a></li><li><a href="global.html#compute">compute</a></li><li><a href="global.html#functions">functions</a></li><li><a href="global.html#main">main</a></li><li><a href="global.html#PAKO">PAKO</a></li><li><a href="global.html#uniforms">uniforms</a></li><li><a href="global.html#xyz2RGB">xyz2RGB</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.0-dev</a> on Fri Jul 14 2017 13:10:04 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
