<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: models/models.stack.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: models/models.stack.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*** Imports ***/
import CorePack    from '../../src/core/core.pack';
import CoreUtils    from '../../src/core/core.utils';
import ModelsBase  from '../../src/models/models.base';

let binaryString = require( 'math-float32-to-binary-string' );


// Slicer way to handle images
// should follow it...
 // 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID &amp;&amp; this->IndexSeriesInstanceUIDs[k] >= 0 &amp;&amp; idxSeriesInstanceUID >= 0) ||
 // 898        (this->IndexContentTime[k] != idxContentTime &amp;&amp; this->IndexContentTime[k] >= 0 &amp;&amp; idxContentTime >= 0) ||
 // 899        (this->IndexTriggerTime[k] != idxTriggerTime &amp;&amp; this->IndexTriggerTime[k] >= 0 &amp;&amp; idxTriggerTime >= 0) ||
 // 900        (this->IndexEchoNumbers[k] != idxEchoNumbers &amp;&amp; this->IndexEchoNumbers[k] >= 0 &amp;&amp; idxEchoNumbers >= 0) ||
 // 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  &amp;&amp; this->IndexDiffusionGradientOrientation[k] >= 0 &amp;&amp; idxDiffusionGradientOrientation >= 0) ||
 // 902        (this->IndexSliceLocation[k] != idxSliceLocation &amp;&amp; this->IndexSliceLocation[k] >= 0 &amp;&amp; idxSliceLocation >= 0) ||
 // 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient &amp;&amp; this->IndexImageOrientationPatient[k] >= 0 &amp;&amp; idxImageOrientationPatient >= 0) )
 // 904     {
 // 905       continue;
 // 906     }

/**
 * Stack object.
 *
 * @module models/stack
 */

export default class ModelsStack extends ModelsBase{
  constructor() {
    super();

    this._uid = null;
    this._stackID = -1;

    this._frame = [];
    this._numberOfFrames = 0;

    this._rows = 0;
    this._columns = 0;
    this._numberOfChannels = 1;
    this._bitsAllocated = 8;
    this._pixelType = 0;

    this._textureSize = 4096;
    this._nbTextures = 7; // HIGH RES..
    this._rawData = [];

    this._windowCenter = 0;
    this._windowWidth = 0;

    this._rescaleSlope = 1;
    this._rescaleIntercept = 0;

    this._minMax = [65535, -32768];

    // TRANSFORMATION MATRICES

    this._ijk2LPS = null;
    this._lps2IJK = null;

    this._aabb2LPS = null;
    this._lps2AABB = null;

    //
    // IJK dimensions
    this._dimensionsIJK = null;
    this._halfDimensionsIJK = null;
    this._spacing = new THREE.Vector3(1, 1, 1);
    this._spacingBetweenSlices = 0;
    this._sliceThickness = 0;
    this._origin = null;
    this._referenceSpace = ['L', 'P', 'S'];
    this._xCosine = new THREE.Vector3(1, 0, 0);
    this._yCosine = new THREE.Vector3(0, 1, 0);
    this._zCosine = new THREE.Vector3(0, 0, 1);

    // convenience vars
    this._prepared = false;
    this._packed = false;
    this._packedPerPixel = 1;

    //
    this._modality = 'Modality not set';
    this._frameSegment = [];

    // photometricInterpretation Monochrome1 VS Monochrome2
    this._invert = false;
  }

  mergeFrames(){
    let mergedFrames = [];
    this.computeCosines();
    this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
    this._frame.sort(this._sortDistanceArraySort);

    mergedFrames.push(this._frame[0]);
    let prevIndex = 0;
    for(let i = 1; i&lt;this._frame.length; i++){
      if(mergedFrames[prevIndex]._dist === this._frame[i]._dist){

        for(let k=0; k&lt;mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; k++){
          mergedFrames[prevIndex]._pixelData[k] += this._frame[i].pixelData[k] * this._frame[i]._referencedSegmentNumber;
        }

        mergedFrames[prevIndex].minMax = CoreUtils.minMaxPixelData(mergedFrames[prevIndex]._pixelData);

      }
      else{
        mergedFrames.push( this._frame[i] );
        prevIndex++;
      }
    }

    this._frame = mergedFrames;
  }

  /**
   * Compute cosines
   * Order frames
   * computeSpacing
   * sanityCheck
   * init some vars
   * compute min/max
   * compute transformation matrices
   */
  prepare() {
    // if segmentation, merge some frames...
    if( this._modality === 'SEG'){
      console.log('do some special pre-processing');
      // store frame and do special pre-processing
      this._frameSegment = this._frame;
      this.mergeFrames();
    }

    // we need at least 1 frame
    if (this._frame &amp;&amp; this._frame.length > 0) {
      this._numberOfFrames = this._frame.length;
    } else {
      window.console.log('_frame doesn\'t contain anything....');
      window.console.log(this._frame);
      return false;
    }

    // pass parameters from frame to stack
    this._rows = this._frame[0].rows;
    this._columns = this._frame[0].columns;
    this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
    this._halfDimensionsIJK = new THREE.Vector3(
      this._dimensionsIJK.x / 2,
      this._dimensionsIJK.y / 2,
      this._dimensionsIJK.z / 2
    );
    this._spacingBetweenSlices = this._frame[0].spacingBetweenSlices;
    this._sliceThickness = this._frame[0].sliceThickness;

    // compute direction cosines
    this.computeCosines();

    // order the frames
    this.orderFrames();

    // compute/guess spacing
    this.computeSpacing();

    // set extra vars if nulls
    // happens now because if it happen before, we would think image position/orientation
    // are defined and we would use it to compute spacing.
    if (!this._frame[0].imagePosition) {
      this._frame[0].imagePosition = [0, 0, 0];
    }

    if (!this._frame[0].imageOrientation) {
      this._frame[0].imageOrientation = [1, 0, 0, 0, 1, 0];
    }

    this._origin = this._vector3FromArray(this._frame[0].imagePosition, 0);

    // compute transforms
    this.computeIJK2LPS();
    this.computeLPS2AABB();

    //this.packEchos();

    this._rescaleSlope = this._frame[0].rescaleSlope || 1;
    this._rescaleIntercept = this._frame[0].rescaleIntercept || 0;

    // rescale/slope min max
    this.computeMinMaxIntensities();
    this._minMax[0] = ModelsStack.valueRescaleSlopeIntercept(
      this._minMax[0],
      this._rescaleSlope,
      this._rescaleIntercept);
    this._minMax[1] = ModelsStack.valueRescaleSlopeIntercept(
      this._minMax[1],
      this._rescaleSlope,
      this._rescaleIntercept);

    let width = this._frame[0].windowWidth || this._minMax[1] - this._minMax[0];
    this._windowWidth = this._rescaleSlope * width + this._rescaleIntercept;

    let center = this._frame[0].windowCenter || this._minMax[0] + width / 2;
    this._windowCenter = this._rescaleSlope * center + this._rescaleIntercept;

    this._bitsAllocated = this._frame[0].bitsAllocated;

    this._prepared = true;
  }

  packEchos(){
    // 4 echo times...
    let echos = 4;
    let packedEcho = [];
    for(let i=0; i&lt; this._frame.length; i+=echos){
      let frame = this._frame[i];
      for(let k=0; k&lt;this._rows * this._columns; k++){
        for(let j=1; j&lt;echos; j++){
          frame.pixelData[k] += this._frame[i+j].pixelData[k];
        }
        frame.pixelData[k] /= echos;
      }
      packedEcho.push(frame);
    }
    this._frame = packedEcho;
    this._numberOfFrames = this._frame.length;
    this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
    this._halfDimensionsIJK = new THREE.Vector3(
      this._dimensionsIJK.x / 2,
      this._dimensionsIJK.y / 2,
      this._dimensionsIJK.z / 2
    );
  }

  // frame.cosines - returns array [x, y, z]
  computeCosines() {
    if (this._frame &amp;&amp;
      this._frame[0]) {
      let cosines = this._frame[0].cosines();
      this._xCosine = cosines[0];
      this._yCosine = cosines[1];
      this._zCosine = cosines[2];
    }
  }

  orderFrames() {
    // order the frames based on theirs dimension indices
    // first index is the most important.
    // 1,1,1,1 willl be first
    // 1,1,2,1 will be next
    // 1,1,2,3 will be next
    // 1,1,3,1 wil be next
    if (this._frame[0].dimensionIndexValues) {
      this._frame.sort(this._orderFrameOnDimensionIndicesArraySort);

    // else order with image position and orientation
    } else if (
      this._frame[0].imagePosition &amp;&amp; this._frame[0].imageOrientation &amp;&amp;
      this._frame[1] &amp;&amp;
      this._frame[1].imagePosition &amp;&amp; this._frame[1].imageOrientation &amp;&amp;
      this._frame[0].imagePosition.join() !== this._frame[1].imagePosition.join()) {
      // compute and sort by dist in this series
      this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
      this._frame.sort(this._sortDistanceArraySort);
    } else if (
      this._frame[0].instanceNumber !== null &amp;&amp;
      this._frame[1] &amp;&amp; this._frame[1].instanceNumber !== null &amp;&amp;
      this._frame[0].instanceNumber !== this._frame[1].instanceNumber) {
      this._frame.sort(this._sortInstanceNumberArraySort);
    } else if (
      this._frame[0].sopInstanceUID &amp;&amp;
      this._frame[1] &amp;&amp; this._frame[1].sopInstanceUID &amp;&amp;
      this._frame[0].sopInstanceUID !== this._frame[1].sopInstanceUID) {
      this._frame.sort(this._sortSopInstanceUIDArraySort);
    } else {
      //window.console.log(this._frame[0]);
      //window.console.log(this._frame[1]);
      // window.console.log(this._frame[0].instanceNumber !== null &amp;&amp; true);
      //window.console.log(this._frame[0].instanceNumber !== this._frame[1].instanceNumber);
      window.console.log('do not know how to order the frames...');
      // else slice location
      // image number
      // ORDERING BASED ON instance number
      // _ordering = 'instance_number';
      // first_image.sort(function(a,b){return a["instance_number"]-b["instance_number"]});
    }
  }

  computeSpacing() {
    this.xySpacing();
    this.zSpacing();
  }

  zSpacing() {

    if (this._numberOfFrames > 1) {
      if (this._spacingBetweenSlices) {
        this._spacing.z = this._spacingBetweenSlices;
      // if pixelSpacing in Z direction is already defined
      // i.e. by nifti parser
      }else if (this._frame[0].pixelSpacing &amp;&amp; this._frame[0].pixelSpacing[2]) {
        this._spacing.z = this._frame[0].pixelSpacing[2];
      }else {
        // compute and sort by dist in this series
        this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
        this._frame.sort(this._sortDistanceArraySort);

        this._spacing.z = this._frame[1].dist - this._frame[0].dist;
      }
      // } else if (this._frame[0].sliceThickness) {
      //   zSpacing = this._frame[0].sliceThickness;
    }

    // Spacing
    // can not be 0 if not matrix can not be inverted.
    if (this._spacing.z === 0) {
      this._spacing.z = 1;
    }
  }

  // FRAME CAN DO IT
  xySpacing() {
    if (this._frame &amp;&amp;
      this._frame[0]) {
      let spacingXY = this._frame[0].spacingXY();
      this._spacing.x = spacingXY[0];
      this._spacing.y = spacingXY[1];
    }
  }

  computeMinMaxIntensities() {
    // what about colors!!!!?
    for (let i = 0; i &lt; this._frame.length; i++) {
      // get min/max
      this._minMax[0] = Math.min(this._minMax[0], this._frame[i].minMax[0]);
      this._minMax[1] = Math.max(this._minMax[1], this._frame[i].minMax[1]);
    }
  }

  computeIJK2LPS() {
    this._ijk2LPS = new THREE.Matrix4();
    this._ijk2LPS.set(
      this._xCosine.x * this._spacing.x, this._yCosine.x * this._spacing.y, this._zCosine.x * this._spacing.z, this._origin.x,
      this._xCosine.y * this._spacing.x, this._yCosine.y * this._spacing.y, this._zCosine.y * this._spacing.z, this._origin.y,
      this._xCosine.z * this._spacing.x, this._yCosine.z * this._spacing.y, this._zCosine.z * this._spacing.z, this._origin.z,
      0, 0, 0, 1);

    this._lps2IJK = new THREE.Matrix4();
    this._lps2IJK.getInverse(this._ijk2LPS);

    // tmp hack
    this._ijk2RAS = new THREE.Matrix4();
    this._ijk2RAS.set(
      -this._xCosine.x * this._spacing.x, -this._yCosine.x * this._spacing.y, -this._zCosine.x * this._spacing.z, -this._origin.x,
      -this._xCosine.y * this._spacing.x, -this._yCosine.y * this._spacing.y, -this._zCosine.y * this._spacing.z, -this._origin.y,
      this._xCosine.z * this._spacing.x, this._yCosine.z * this._spacing.y, this._zCosine.z * this._spacing.z, this._origin.z,
      0, 0, 0, 1);

    this._ras2IJK = new THREE.Matrix4();
    this._ras2IJK.getInverse(this._ijk2RAS);

  }

  computeLPS2AABB() {
    this._aabb2LPS = new THREE.Matrix4();
    this._aabb2LPS.set(
        this._xCosine.x, this._yCosine.x, this._zCosine.x, this._origin.x,
        this._xCosine.y, this._yCosine.y, this._zCosine.y, this._origin.y,
        this._xCosine.z, this._yCosine.z, this._zCosine.z, this._origin.z,
        0, 0, 0, 1);

    this._lps2AABB = new THREE.Matrix4();
    this._lps2AABB.getInverse(this._aabb2LPS);
  }

  merge(stack) {
    // also make sure x/y/z cosines are a match!
    if (this._stackID === stack.stackID) {
      return this.mergeModels(this._frame, stack.frame);
    } else {
      return false;
    }
  }

  pack() {
    // Get total number of voxels
    let nbVoxels = this._dimensionsIJK.x * this._dimensionsIJK.y * this._dimensionsIJK.z;

    // Packing style
    if( this._bitsAllocated === 16 &amp;&amp; this._numberOfChannels === 1 ){

      this._packedPerPixel = 2;

    }

    // Loop through all the textures we need
    let textureDimension = this._textureSize * this._textureSize;
    let requiredTextures = Math.ceil( nbVoxels / (textureDimension * this._packedPerPixel ) );
    let voxelIndexStart = 0;
    let voxelIndexStop = this._packedPerPixel * textureDimension;
    if (voxelIndexStop > nbVoxels) {
      voxelIndexStop = nbVoxels;
    }

    for (let ii = 0; ii &lt; requiredTextures; ii++) {

      // console.log( voxelIndexStart );
      // console.log( voxelIndexStop );

      let packed = this._packTo8Bits(this._bitsAllocated, this._pixelType, this._numberOfChannels, this._frame, this._textureSize, voxelIndexStart, voxelIndexStop);
      this._textureType = packed.textureType;
      this._rawData.push(packed.data);

      voxelIndexStart += this._packedPerPixel * textureDimension;
      voxelIndexStop +=  this._packedPerPixel * textureDimension;
      if (voxelIndexStop > nbVoxels) {
        voxelIndexStop = nbVoxels;
      }
    }

    this._packed = true;
  }

  _packTo8Bits(bits, pixelType, channels, frame, textureSize, startVoxel, stopVoxel) {
    let packed = {
      textureType: null,
      data: null
    };

    let packIndex = 0;
    let frameIndex = 0;
    let inFrameIndex = 0;
    // frame can do it!
    let frameDimension = frame[0].rows * frame[0].columns;
    let data = null;

    if ( bits === 8 &amp;&amp; channels === 1 || bits === 1 ) {

      let data = new Uint8Array( textureSize * textureSize * 1 );
      for (let i = startVoxel; i &lt; stopVoxel; i++) {
        /*jshint bitwise: false*/
        frameIndex = ~~(i / frameDimension);
        inFrameIndex = i % (frameDimension);
        /*jshint bitwise: true*/

        data[packIndex] = frame[frameIndex].pixelData[inFrameIndex];
        packIndex++;

      }
      packed.textureType = THREE.LuminanceFormat;
      packed.data = data;

    } else if (bits === 16 &amp;&amp; channels === 1) {

      let data = new Uint8Array( textureSize * textureSize * 4 );
      let coordinate = 0;
      let channelOffset = 0;

      for ( let i = startVoxel; i &lt; stopVoxel; i++ ) {

        /*jshint bitwise: false*/
        frameIndex = ~~(i / frameDimension);
        inFrameIndex = i % (frameDimension);
        /*jshint bitwise: true*/

        let raw = frame[frameIndex].pixelData[inFrameIndex];
        data[4 * coordinate + 2 * channelOffset] = raw &amp; 0x00FF;
        data[4 * coordinate + 2 * channelOffset + 1] = (raw >>> 8) &amp; 0x00FF;

        packIndex++;
        coordinate = Math.floor( packIndex / 2 );
        channelOffset = packIndex % 2;

      }

      packed.textureType = THREE.RGBAFormat;
      packed.data = data;

    } else if ( bits === 32 &amp;&amp; channels === 1 &amp;&amp; pixelType === 0 ) {

      let data = new Uint8Array(textureSize * textureSize * 4 );
      for ( let i = startVoxel; i &lt; stopVoxel; i++ ) {

        /*jshint bitwise: false*/
        frameIndex = ~~(i / frameDimension);
        inFrameIndex = i % (frameDimension);
        /*jshint bitwise: true*/

        // slow!
        //let asb = VJS.core.pack.uint16ToAlphaLuminance(frame[frameIndex].pixelData[inFrameIndex]);
        let raw = frame[frameIndex].pixelData[inFrameIndex];
        data[4 * packIndex] = raw &amp; 0x000000FF;
        data[4 * packIndex + 1] = (raw >>> 8) &amp; 0x000000FF;
        data[4 * packIndex + 2] = (raw >>> 8) &amp; 0x000000FF;
        data[4 * packIndex + 3] = (raw >>> 8) &amp; 0x000000FF;

        packIndex++;

      }
      packed.textureType = THREE.RGBAFormat;
      packed.data = data;

    } else if ( bits === 32 &amp;&amp; channels === 1 &amp;&amp; pixelType === 1 ) {

      let data = new Uint8Array(textureSize * textureSize * 4);

      for ( let i = startVoxel; i &lt; stopVoxel; i++ ) {
        /*jshint bitwise: false*/
        frameIndex = ~~(i / frameDimension);
        inFrameIndex = i % (frameDimension);
        /*jshint bitwise: true*/

        // slow!
        //let asb = VJS.core.pack.uint16ToAlphaLuminance(frame[frameIndex].pixelData[inFrameIndex]);
        let raw = frame[frameIndex].pixelData[inFrameIndex];
        let bitString = binaryString(raw);
        let bitStringArray = bitString.match(/.{1,8}/g);

        data[4 * packIndex] = parseInt(bitStringArray[0], 2);
        data[4 * packIndex + 1] = parseInt(bitStringArray[1], 2);
        data[4 * packIndex + 2] = parseInt(bitStringArray[2], 2);
        data[4 * packIndex + 3] = parseInt(bitStringArray[3], 2);

        packIndex++;

      }

      packed.textureType = THREE.RGBAFormat;
      packed.data = data;
    } else if ( bits === 8 &amp;&amp; channels === 3 ) {

      let data = new Uint8Array( textureSize * textureSize * 3 );
      for ( let i = startVoxel; i &lt; stopVoxel; i++ ) {

        /*jshint bitwise: false*/
        frameIndex = ~~(i / frameDimension);
        inFrameIndex = i % (frameDimension);
        /*jshint bitwise: true*/

        data[3 * packIndex] = frame[frameIndex].pixelData[3 * inFrameIndex];
        data[3 * packIndex + 1] = frame[frameIndex].pixelData[3 * inFrameIndex + 1];
        data[3 * packIndex + 2] = frame[frameIndex].pixelData[3 * inFrameIndex + 2];
        packIndex++;

      }

      packed.textureType = THREE.RGBFormat;
      packed.data = data;
      
    }

    return packed;

  }

  static worldToData(stack, worldCoordinates) {
    let dataCoordinate = new THREE.Vector3()
      .copy(worldCoordinates)
      .applyMatrix4(stack._lps2IJK);

    // same rounding in the shaders
    dataCoordinate.addScalar(0.5).floor();

    return dataCoordinate;
  }

  worldCenter() {

    let center = this._halfDimensionsIJK.clone().addScalar( -0.5 )
      .applyMatrix4(this._ijk2LPS);
    return center;

  }

  worldBoundingBox() {

    let bbox = [
      Number.MAX_VALUE, Number.MIN_VALUE,
      Number.MAX_VALUE, Number.MIN_VALUE,
      Number.MAX_VALUE, Number.MIN_VALUE
    ];

    for ( let i = 0; i &lt;= this._dimensionsIJK.x; i += this._dimensionsIJK.x ) {
      for ( let j = 0; j &lt;= this._dimensionsIJK.y; j += this._dimensionsIJK.y ) {
        for (let k = 0; k &lt;= this._dimensionsIJK.z; k += this._dimensionsIJK.z ) {

          let world = new THREE.Vector3( i, j, k ).applyMatrix4( this._ijk2LPS );
          bbox = [
            Math.min(bbox[0], world.x), Math.max(bbox[1], world.x), // x min/max
            Math.min(bbox[2], world.y), Math.max(bbox[3], world.y),
            Math.min(bbox[4], world.z), Math.max(bbox[5], world.z)
            ];

        }

      }

    }

    return bbox;

  }

  AABBox() {

    let world0 = new THREE.Vector3().addScalar( -0.5 )
      .applyMatrix4( this._ijk2LPS )
      .applyMatrix4( this._lps2AABB );

    let world7 = this._dimensionsIJK.clone().addScalar( -0.5 )
      .applyMatrix4( this._ijk2LPS )
      .applyMatrix4( this._lps2AABB );

    let minBBox = new THREE.Vector3(
      Math.abs( world0.x - world7.x ),
      Math.abs( world0.y - world7.y ),
      Math.abs( world0.z - world7.z )
    );

    return minBBox;

  }

  centerAABBox() {

    let centerBBox = this.worldCenter();
    centerBBox.applyMatrix4( this._lps2AABB );
    return centerBBox;

  }

  static value(stack, ijkCoordinate) {

    if( ijkCoordinate.z >= 0 &amp;&amp; ijkCoordinate.z &lt; stack._frame.length ) {

      return stack._frame[ijkCoordinate.z].value(
        ijkCoordinate.x,
        ijkCoordinate.y );

    } else {

      return null;

    }

  }

  static valueRescaleSlopeIntercept( value, slope, intercept ) {

    return value * slope + intercept;

  }

  static indexInDimensions( index, dimensions ) {

    if ( index.x >= 0 &amp;&amp;
         index.y >= 0 &amp;&amp;
         index.z >= 0 &amp;&amp;
         index.x &lt; dimensions.x &amp;&amp;
         index.y &lt; dimensions.y &amp;&amp;
         index.z &lt; dimensions.z ) {

      return true;

    }

    return false;

  }

  _vector3FromArray(array, index) {
    return new THREE.Vector3(
      array[index],
      array[index + 1],
      array[index + 2]
      );
  }

  _orderFrameOnDimensionIndicesArraySort(a, b) {

    if ('dimensionIndexValues' in a &amp;&amp; Object.prototype.toString.call(a.dimensionIndexValues) === '[object Array]' &amp;&amp; 'dimensionIndexValues' in b &amp;&amp; Object.prototype.toString.call(b.dimensionIndexValues) === '[object Array]') {
      for (let i = 0; i &lt; a.dimensionIndexValues.length; i++) {
        if (parseInt(a.dimensionIndexValues[i], 10) > parseInt(b.dimensionIndexValues[i], 10)) {
          return 1;
        }
        if (parseInt(a.dimensionIndexValues[i], 10) &lt; parseInt(b.dimensionIndexValues[i], 10)) {
          return -1;
        }
      }
    } else {
      window.console.log('One of the frames doesn\'t have a dimensionIndexValues array.');
      window.console.log(a);
      window.console.log(b);
    }

    return 0;
  }

  _computeDistanceArrayMap(normal, frame) {
    frame.dist = frame.imagePosition[0] * normal.x +
      frame.imagePosition[1] * normal.y +
      frame.imagePosition[2] * normal.z;
    return frame;
  }

  _sortDistanceArraySort(a, b) {return a.dist - b.dist;}
  _sortInstanceNumberArraySort(a, b) {return a.instanceNumber - b.instanceNumber;}
  _sortSopInstanceUIDArraySort(a, b) {return a.sopInstanceUID - b.sopInstanceUID;}

  set numberOfChannels(numberOfChannels) {
    this._numberOfChannels = numberOfChannels;
  }

  get numberOfChannels() {
    return this._numberOfChannels;
  }

  set frame(frame) {
    this._frame = frame;
  }

  get frame() {
    return this._frame;
  }

  set prepared( prepared ) {

    this._prepared = prepared;

  }

  get prepared() {

    return this._prepared;

  }

  set packed( packed ) {
    this._packed = packed;
  }

  get packed() {
    return this._packed;
  }

  set packedPerPixel( packedPerPixel ) {

    this._packedPerPixel = packedPerPixel;

  }

  get packedPerPixel() {

    return this._packedPerPixel;

  }

  set dimensionsIJK(dimensionsIJK) {
    this._dimensionsIJK = dimensionsIJK;
  }

  get dimensionsIJK() {
    return this._dimensionsIJK;
  }

  set halfDimensionsIJK(halfDimensionsIJK) {
    this._halfDimensionsIJK = halfDimensionsIJK;
  }

  get halfDimensionsIJK() {
    return this._halfDimensionsIJK;
  }

  set ijk2LPS(ijk2LPS) {
    this._ijk2LPS = ijk2LPS;
  }

  get ijk2LPS() {
    return this._ijk2LPS;
  }

  set lps2IJK(lps2IJK) {
    this._lps2IJK = lps2IJK;
  }

  get lps2IJK() {
    return this._lps2IJK;
  }

  set lps2AABB(lps2AABB) {
    this._lps2AABB = lps2AABB;
  }

  get lps2AABB() {
    return this._lps2AABB;
  }

  set textureSize(textureSize) {
    this._textureSize = textureSize;
  }

  get textureSize() {
    return this._textureSize;
  }

  set textureType(textureType) {
    this._textureType = textureType;
  }

  get textureType() {
    return this._textureType;
  }

  set bitsAllocated(bitsAllocated) {
    this._bitsAllocated = bitsAllocated;
  }

  get bitsAllocated() {
    return this._bitsAllocated;
  }

  set rawData(rawData) {
    this._rawData = rawData;
  }

  get rawData() {
    return this._rawData;
  }

  get windowWidth() {
    return this._windowWidth;
  }

  set windowWidth(windowWidth) {
    this._windowWidth = windowWidth;
  }

  get windowCenter() {
    return this._windowCenter;
  }

  set windowCenter(windowCenter) {
    this._windowCenter = windowCenter;
  }

  get rescaleSlope() {
    return this._rescaleSlope;
  }

  set rescaleSlope(rescaleSlope) {
    this._rescaleSlope = rescaleSlope;
  }

  get rescaleIntercept() {
    return this._rescaleIntercept;
  }

  set rescaleIntercept(rescaleIntercept) {
    this._rescaleIntercept = rescaleIntercept;
  }

  get xCosine() {
    return this._xCosine;
  }

  set xCosine(xCosine) {
    this._xCosine = xCosine;
  }

  get yCosine() {
    return this._yCosine;
  }

  set yCosine(yCosine) {
    this._yCosine = yCosine;
  }

  get zCosine() {
    return this._zCosine;
  }

  set zCosine(zCosine) {
    this._zCosine = zCosine;
  }

  get minMax() {
    return this._minMax;
  }

  set minMax(minMax) {
    this._minMax = minMax;
  }

  get stackID() {
    return this._stackID;
  }

  set stackID(stackID) {
    this._stackID = stackID;
  }

  get pixelType() {
    return this._pixelType;
  }

  set pixelType(pixelType) {
    this._pixelType = pixelType;
  }

  set invert(invert) {
    this._invert = invert;
  }

  get invert() {
    return this._invert;
  }

  set modality(modality) {
    this._modality = modality;
  }

  get modality() {
    return this._modality;
  }

  get referenceSpace(){
    return this._referenceSpace;
  }

  set referenceSpace(referenceSpace){
    this._referenceSpace = referenceSpace;
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cameras.html">cameras</a></li><li><a href="module-cameras_orthographic.html">cameras/orthographic</a></li><li><a href="module-core.html">core</a></li><li><a href="module-core_intersections.html">core/intersections</a></li><li><a href="module-core_pack.html">core/pack</a></li><li><a href="module-core_utils.html">core/utils</a></li><li><a href="module-core_validators.html">core/validators</a></li><li><a href="module-geometries.html">geometries</a></li><li><a href="module-geometries_slice.html">geometries/slice</a></li><li><a href="module-geometries_voxel.html">geometries/voxel</a></li><li><a href="module-helpers.html">helpers</a></li><li><a href="module-helpers_border.html">helpers/border</a></li><li><a href="module-helpers_boundingbox.html">helpers/boundingbox</a></li><li><a href="module-helpers_dummy.html">helpers/dummy</a></li><li><a href="module-helpers_lut.html">helpers/lut</a></li><li><a href="module-helpers_material_mixin.html">helpers/material/mixin</a></li><li><a href="module-helpers_progressBar.html">helpers/progressBar</a></li><li><a href="module-helpers_slice.html">helpers/slice</a></li><li><a href="module-helpers_stack.html">helpers/stack</a></li><li><a href="module-helpers_volumerendering.html">helpers/volumerendering</a></li><li><a href="module-helpers_voxel.html">helpers/voxel</a></li><li><a href="module-loaders.html">loaders</a></li><li><a href="module-loaders_base.html">loaders/base</a></li><li><a href="module-loaders_volumes.html">loaders/volumes</a></li><li><a href="module-models.html">models</a></li><li><a href="module-models_base.html">models/base</a></li><li><a href="module-models_frame.html">models/frame</a></li><li><a href="module-models_series.html">models/series</a></li><li><a href="module-models_stack.html">models/stack</a></li><li><a href="module-models_voxel.html">models/voxel</a></li><li><a href="module-parsers.html">parsers</a></li><li><a href="module-parsers_dicom.html">parsers/dicom</a></li><li><a href="module-parsers_nifti.html">parsers/nifti</a></li><li><a href="module-parsers_volume.html">parsers/volume</a></li><li><a href="module-shaders.html">shaders</a></li><li><a href="module-shaders_data.html">shaders/data</a></li><li><a href="module-widgets.html">widgets</a></li><li><a href="module-widgets_handle.html">widgets/handle</a></li><li><a href="module-widgets_squareProbe.html">widgets/squareProbe</a></li><li><a href="module-widgets_voxelProbe.html">widgets/voxelProbe</a></li></ul><h3>Classes</h3><ul><li><a href="module.exports.html">exports</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.0-dev</a> on Mon Nov 21 2016 11:44:12 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
