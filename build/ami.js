(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AMI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// jshint ignore: start

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
 /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
 Copyright 2011 notmasteryet

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var ColorSpace = {Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4};
var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
    0,
    1, 8,
    16, 9, 2,
    3, 10, 17, 24,
    32, 25, 18, 11, 4,
    5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13, 6,
    7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1 = 4017;   // cos(pi/16)
  var dctSin1 = 799;   // sin(pi/16)
  var dctCos3 = 3406;   // cos(3*pi/16)
  var dctSin3 = 2276;   // sin(3*pi/16)
  var dctCos6 = 1567;   // cos(6*pi/16)
  var dctSin6 = 3784;   // sin(6*pi/16)
  var dctSqrt2 = 5793;   // sqrt(2)
  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;

    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }

    function decodeHuffman(tree) {
      var node = tree;
      var bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw "invalid huffman sequence";
      }
      return null;
    }

    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null)
          return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }

    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }

    function decodeBaseline(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[offset] = (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      component.blockData[offset] = (component.pred += diff);
    }

    function decodeDCSuccessive(component, offset) {
      component.blockData[offset] |= readBit() << successive;
    }

    var eobrun = 0;
    function decodeACFirst(component, offset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }

    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, offset) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
          case 0: // initial state
            var rs = decodeHuffman(component.huffmanTableAC);
            var s = rs & 15;
            r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1)
                throw "invalid ACn encoding";
              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }
            continue;
          case 1: // skipping r zero items
          case 2:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              r--;
              if (r === 0)
                successiveACState = successiveACState == 2 ? 3 : 0;
            }
            break;
          case 3: // set value for a zero item
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              component.blockData[offset + z] = successiveACNextValue << successive;
              successiveACState = 0;
            }
            break;
          case 4: // eob
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            }
            break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) {
      resetInterval = mcuExpected;
    }

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker <= 0xFF00) {
        throw "marker was not found";
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  }

  // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable;
    var v0, v1, v2, v3, v4, v5, v6, v7, t;
    var i;

    // dequant
    for (i = 0; i < 64; i++) {
      p[i] = component.blockData[blockBufferOffset + i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i < 8; ++i) {
      var row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 &&
        p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 &&
        p[7 + row] === 0) {
        t = (dctSqrt2 * p[0 + row] + 512) >> 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
      v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
      v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
      v5 = p[3 + row] << 4;
      v6 = p[5 + row] << 4;

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i < 8; ++i) {
      var col = i;

      // check for all-zero AC coefficients
      if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 &&
        p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 &&
        p[7 * 8 + col] === 0) {
        t = (dctSqrt2 * p[i + 0] + 8192) >> 14;
        p[0 * 8 + col] = t;
        p[1 * 8 + col] = t;
        p[2 * 8 + col] = t;
        p[3 * 8 + col] = t;
        p[4 * 8 + col] = t;
        p[5 * 8 + col] = t;
        p[6 * 8 + col] = t;
        p[7 * 8 + col] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;
      v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;
      v2 = p[2 * 8 + col];
      v3 = p[6 * 8 + col];
      v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;
      v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;
      v5 = p[3 * 8 + col];
      v6 = p[5 * 8 + col];

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 * 8 + col] = v0 + v7;
      p[7 * 8 + col] = v0 - v7;
      p[1 * 8 + col] = v1 + v6;
      p[6 * 8 + col] = v1 - v6;
      p[2 * 8 + col] = v2 + v5;
      p[5 * 8 + col] = v2 - v5;
      p[3 * 8 + col] = v3 + v4;
      p[4 * 8 + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i < 64; ++i) {
      var index = blockBufferOffset + i;
      var q = p[i];
      q = (q <= -2056 / component.bitConversion) ? 0 :
        (q >= 2024 / component.bitConversion) ? 255 / component.bitConversion :
        (q + 2056 / component.bitConversion) >> 4;
      component.blockData[index] = q;
    }
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    var computationBuffer = new Int32Array(64);

    var i, j, ll = 0;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }
    return component.blockData;
  }

  function clampToUint8(a) {
    return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;
  }

  constructor.prototype = {
    load: function load(path) {
      var handleData = (function (data) {
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);

      if (path.indexOf("data:") > -1) {
        var offset = path.indexOf("base64,") + 7;
        var data = atob(path.substring(offset));
        var arr = new Uint8Array(data.length);
        for (var i = data.length - 1; i >= 0; i--) {
          arr[i] = data.charCodeAt(i);
        }
        handleData(data);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = (function () {
          // TODO catch parse error
          var data = new Uint8Array(xhr.response);
          handleData(data);
        }).bind(this);
        xhr.send(null);
      }
    },
    parse: function parse(data) {

      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }

      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
        for (var i = 0; i < frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;

          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0, length = data.length;
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw "SOI not found";
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch (fileMarker) {
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: {major: appData[5], minor: appData[6]},
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var zz = dctZigZag[j];
                  tableData[zz] = readUint16();
                }
              } else
                throw "DQT: invalid table spec";
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            if (frame) {
              throw "Only single frame JPEGs supported";
            }
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              if (maxH < h)
                maxH = h;
              if (maxV < v)
                maxV = v;
              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationTable: quantizationTables[qId],
                quantizationTableId: qId,
                bitConversion: 255 / ((1 << frame.precision) - 1)
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength; ) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              var componentIndex = frame.componentIds[data[offset++]];
              component = frame.components[componentIndex];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;
          default:
            if (data[offset - 3] == 0xFF &&
              data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw "unknown JPEG marker " + fileMarker.toString(16);
        }
        fileMarker = readUint16();
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      switch (frame.components.length)
      {
        case 1:
          this.colorspace = ColorSpace.Grayscale;
          break;
        case 3:
          if (this.adobe)
            this.colorspace = ColorSpace.AdobeRGB;
          else
            this.colorspace = ColorSpace.RGB;
          break;
        case 4:
          this.colorspace = ColorSpace.CYMK;
          break;
        default:
          this.colorspace = ColorSpace.Unknown;
      }
      for (var i = 0; i < frame.components.length; i++) {
        var component = frame.components[i];
        if (!component.quantizationTable && component.quantizationTableId !== null)
          component.quantizationTable = quantizationTables[component.quantizationTableId];
        this.components.push({
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn,
          bitConversion: component.bitConversion
        });
      }
    },
    getData16: function getData16(width, height) {
      if (this.components.length !== 1)
        throw 'Unsupported color mode';
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint16Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++];
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }
      return data;
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++] * component.bitConversion;
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }

      // ... then transform colors, if necessary
      switch (numComponents) {
        case 1:
        case 2:
          break;
        // no color conversion for one or two compoenents

        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i    ];
              Cb = data[i + 1];
              Cr = data[i + 2];

              R = clampToUint8(Y - 179.456 + 1.402 * Cr);
              G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
              B = clampToUint8(Y - 226.816 + 1.772 * Cb);

              data[i    ] = R;
              data[i + 1] = G;
              data[i + 2] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw 'Unsupported color mode (4 components)';
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i];
              Cb = data[i + 1];
              Cr = data[i + 2];

              C = clampToUint8(434.456 - Y - 1.402 * Cr);
              M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
              Y = clampToUint8(481.816 - Y - 1.772 * Cb);

              data[i    ] = C;
              data[i + 1] = M;
              data[i + 2] = Y;
              // K is unchanged
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
      return data;
    }
  };

  return constructor;
})();

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = JpegImage;
}
},{}],2:[function(require,module,exports){
/*! image-JPEG2000 - v0.3.1 - 2015-08-26 | https://github.com/OHIF/image-JPEG2000 */
/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals ArithmeticDecoder, globalScope, log2, readUint16, readUint32,
           info, warn */

'use strict';

var JpxImage = (function JpxImageClosure() {
  // Table E.1
  var SubbandsGainLog2 = {
    'LL': 0,
    'LH': 1,
    'HL': 1,
    'HH': 2
  };
  function JpxImage() {
    this.failOnCorruptedImage = false;
  }
  JpxImage.prototype = {
    parse: function JpxImage_parse(data) {

      var head = readUint16(data, 0);
      // No box header, immediate start of codestream (SOC)
      if (head === 0xFF4F) {
        this.parseCodestream(data, 0, data.length);
        return;
      }

      var position = 0, length = data.length;
      while (position < length) {
        var headerSize = 8;
        var lbox = readUint32(data, position);
        var tbox = readUint32(data, position + 4);
        position += headerSize;
        if (lbox === 1) {
          // XLBox: read UInt64 according to spec.
          // JavaScript's int precision of 53 bit should be sufficient here.
          lbox = readUint32(data, position) * 4294967296 +
                 readUint32(data, position + 4);
          position += 8;
          headerSize += 8;
        }
        if (lbox === 0) {
          lbox = length - position + headerSize;
        }
        if (lbox < headerSize) {
          throw new Error('JPX Error: Invalid box field size');
        }
        var dataLength = lbox - headerSize;
        var jumpDataLength = true;
        switch (tbox) {
          case 0x6A703268: // 'jp2h'
            jumpDataLength = false; // parsing child boxes
            break;
          case 0x636F6C72: // 'colr'
            // Colorspaces are not used, the CS from the PDF is used.
            var method = data[position];
            var precedence = data[position + 1];
            var approximation = data[position + 2];
            if (method === 1) {
              // enumerated colorspace
              var colorspace = readUint32(data, position + 3);
              switch (colorspace) {
                case 16: // this indicates a sRGB colorspace
                case 17: // this indicates a grayscale colorspace
                case 18: // this indicates a YUV colorspace
                  break;
                default:
                  warn('Unknown colorspace ' + colorspace);
                  break;
              }
            } else if (method === 2) {
              info('ICC profile not supported');
            }
            break;
          case 0x6A703263: // 'jp2c'
            this.parseCodestream(data, position, position + dataLength);
            break;
          case 0x6A502020: // 'jP\024\024'
            if (0x0d0a870a !== readUint32(data, position)) {
              warn('Invalid JP2 signature');
            }
            break;
          // The following header types are valid but currently not used:
          case 0x6A501A1A: // 'jP\032\032'
          case 0x66747970: // 'ftyp'
          case 0x72726571: // 'rreq'
          case 0x72657320: // 'res '
          case 0x69686472: // 'ihdr'
            break;
          default:
            var headerType = String.fromCharCode((tbox >> 24) & 0xFF,
                                                 (tbox >> 16) & 0xFF,
                                                 (tbox >> 8) & 0xFF,
                                                 tbox & 0xFF);
            warn('Unsupported header type ' + tbox + ' (' + headerType + ')');
            break;
        }
        if (jumpDataLength) {
          position += dataLength;
        }
      }
    },
    parseImageProperties: function JpxImage_parseImageProperties(stream) {
      var newByte = stream.getByte();
      while (newByte >= 0) {
        var oldByte = newByte;
        newByte = stream.getByte();
        var code = (oldByte << 8) | newByte;
        // Image and tile size (SIZ)
        if (code === 0xFF51) {
          stream.skip(4);
          var Xsiz = stream.getInt32() >>> 0; // Byte 4
          var Ysiz = stream.getInt32() >>> 0; // Byte 8
          var XOsiz = stream.getInt32() >>> 0; // Byte 12
          var YOsiz = stream.getInt32() >>> 0; // Byte 16
          stream.skip(16);
          var Csiz = stream.getUint16(); // Byte 36
          this.width = Xsiz - XOsiz;
          this.height = Ysiz - YOsiz;
          this.componentsCount = Csiz;
          // Results are always returned as Uint8Arrays
          this.bitsPerComponent = 8;
          return;
        }
      }
      throw new Error('JPX Error: No size marker found in JPX stream');
    },
    parseCodestream: function JpxImage_parseCodestream(data, start, end) {
      var context = {};
      try {
        var doNotRecover = false;
        var position = start;
        while (position + 1 < end) {
          var code = readUint16(data, position);
          position += 2;

          var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
          switch (code) {
            case 0xFF4F: // Start of codestream (SOC)
              context.mainHeader = true;
              break;
            case 0xFFD9: // End of codestream (EOC)
              break;
            case 0xFF51: // Image and tile size (SIZ)
              length = readUint16(data, position);
              var siz = {};
              siz.Xsiz = readUint32(data, position + 4);
              siz.Ysiz = readUint32(data, position + 8);
              siz.XOsiz = readUint32(data, position + 12);
              siz.YOsiz = readUint32(data, position + 16);
              siz.XTsiz = readUint32(data, position + 20);
              siz.YTsiz = readUint32(data, position + 24);
              siz.XTOsiz = readUint32(data, position + 28);
              siz.YTOsiz = readUint32(data, position + 32);
              var componentsCount = readUint16(data, position + 36);
              siz.Csiz = componentsCount;
              var components = [];
              j = position + 38;
              for (var i = 0; i < componentsCount; i++) {
                var component = {
                  precision: (data[j] & 0x7F) + 1,
                  isSigned: !!(data[j] & 0x80),
                  XRsiz: data[j + 1],
                  YRsiz: data[j + 1]
                };
                calculateComponentDimensions(component, siz);
                components.push(component);
              }
              context.SIZ = siz;
              context.components = components;
              calculateTileGrids(context, components);
              context.QCC = [];
              context.COC = [];
              break;
            case 0xFF5C: // Quantization default (QCD)
              length = readUint16(data, position);
              var qcd = {};
              j = position + 2;
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcd.noQuantization = (spqcdSize === 8);
              qcd.scalarExpounded = scalarExpounded;
              qcd.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < length + position) {
                var spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcd.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCD = qcd;
              } else {
                context.currentTile.QCD = qcd;
                context.currentTile.QCC = [];
              }
              break;
            case 0xFF5D: // Quantization component (QCC)
              length = readUint16(data, position);
              var qcc = {};
              j = position + 2;
              var cqcc;
              if (context.SIZ.Csiz < 257) {
                cqcc = data[j++];
              } else {
                cqcc = readUint16(data, j);
                j += 2;
              }
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcc.noQuantization = (spqcdSize === 8);
              qcc.scalarExpounded = scalarExpounded;
              qcc.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < (length + position)) {
                spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcc.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCC[cqcc] = qcc;
              } else {
                context.currentTile.QCC[cqcc] = qcc;
              }
              break;
            case 0xFF52: // Coding style default (COD)
              length = readUint16(data, position);
              var cod = {};
              j = position + 2;
              var scod = data[j++];
              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
              cod.sopMarkerUsed = !!(scod & 2);
              cod.ephMarkerUsed = !!(scod & 4);
              cod.progressionOrder = data[j++];
              cod.layersCount = readUint16(data, j);
              j += 2;
              cod.multipleComponentTransform = data[j++];

              cod.decompositionLevelsCount = data[j++];
              cod.xcb = (data[j++] & 0xF) + 2;
              cod.ycb = (data[j++] & 0xF) + 2;
              var blockStyle = data[j++];
              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
              cod.resetContextProbabilities = !!(blockStyle & 2);
              cod.terminationOnEachCodingPass = !!(blockStyle & 4);
              cod.verticalyStripe = !!(blockStyle & 8);
              cod.predictableTermination = !!(blockStyle & 16);
              cod.segmentationSymbolUsed = !!(blockStyle & 32);
              cod.reversibleTransformation = data[j++];
              if (cod.entropyCoderWithCustomPrecincts) {
                var precinctsSizes = [];
                while (j < length + position) {
                  var precinctsSize = data[j++];
                  precinctsSizes.push({
                    PPx: precinctsSize & 0xF,
                    PPy: precinctsSize >> 4
                  });
                }
                cod.precinctsSizes = precinctsSizes;
              }
              var unsupported = [];
              if (cod.selectiveArithmeticCodingBypass) {
                unsupported.push('selectiveArithmeticCodingBypass');
              }
              if (cod.resetContextProbabilities) {
                unsupported.push('resetContextProbabilities');
              }
              if (cod.terminationOnEachCodingPass) {
                unsupported.push('terminationOnEachCodingPass');
              }
              if (cod.verticalyStripe) {
                unsupported.push('verticalyStripe');
              }
              if (cod.predictableTermination) {
                unsupported.push('predictableTermination');
              }
              if (unsupported.length > 0) {
                doNotRecover = true;
                throw new Error('JPX Error: Unsupported COD options (' +
                                unsupported.join(', ') + ')');
              }
              if (context.mainHeader) {
                context.COD = cod;
              } else {
                context.currentTile.COD = cod;
                context.currentTile.COC = [];
              }
              break;
            case 0xFF90: // Start of tile-part (SOT)
              length = readUint16(data, position);
              tile = {};
              tile.index = readUint16(data, position + 2);
              tile.length = readUint32(data, position + 4);
              tile.dataEnd = tile.length + position - 2;
              tile.partIndex = data[position + 8];
              tile.partsCount = data[position + 9];

              context.mainHeader = false;
              if (tile.partIndex === 0) {
                // reset component specific settings
                tile.COD = context.COD;
                tile.COC = context.COC.slice(0); // clone of the global COC
                tile.QCD = context.QCD;
                tile.QCC = context.QCC.slice(0); // clone of the global COC
              }
              context.currentTile = tile;
              break;
            case 0xFF93: // Start of data (SOD)
              tile = context.currentTile;
              if (tile.partIndex === 0) {
                initializeTile(context, tile.index);
                buildPackets(context);
              }

              // moving to the end of the data
              length = tile.dataEnd - position;
              parseTilePackets(context, data, position, length);
              break;
            case 0xFF55: // Tile-part lengths, main header (TLM)
            case 0xFF57: // Packet length, main header (PLM)
            case 0xFF58: // Packet length, tile-part header (PLT)
            case 0xFF64: // Comment (COM)
              length = readUint16(data, position);
              // skipping content
              break;
            case 0xFF53: // Coding style component (COC)
              throw new Error('JPX Error: Codestream code 0xFF53 (COC) is ' +
                              'not implemented');
            default:
              throw new Error('JPX Error: Unknown codestream code: ' +
                              code.toString(16));
          }
          position += length;
        }
      } catch (e) {
        if (doNotRecover || this.failOnCorruptedImage) {
          throw e;
        } else {
          warn('Trying to recover from ' + e.message);
        }
      }
      this.tiles = transformComponents(context);
      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
      this.componentsCount = context.SIZ.Csiz;
    }
  };
  function calculateComponentDimensions(component, siz) {
    // Section B.2 Component mapping
    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
    component.width = component.x1 - component.x0;
    component.height = component.y1 - component.y0;
  }
  function calculateTileGrids(context, components) {
    var siz = context.SIZ;
    // Section B.3 Division into tile and tile-components
    var tile, tiles = [];
    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
    for (var q = 0; q < numYtiles; q++) {
      for (var p = 0; p < numXtiles; p++) {
        tile = {};
        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
        tile.width = tile.tx1 - tile.tx0;
        tile.height = tile.ty1 - tile.ty0;
        tile.components = [];
        tiles.push(tile);
      }
    }
    context.tiles = tiles;

    var componentsCount = siz.Csiz;
    for (var i = 0, ii = componentsCount; i < ii; i++) {
      var component = components[i];
      for (var j = 0, jj = tiles.length; j < jj; j++) {
        var tileComponent = {};
        tile = tiles[j];
        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
        tile.components[i] = tileComponent;
      }
    }
  }
  function getBlocksDimensions(context, component, r) {
    var codOrCoc = component.codingStyleParameters;
    var result = {};
    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
      result.PPx = 15;
      result.PPy = 15;
    } else {
      result.PPx = codOrCoc.precinctsSizes[r].PPx;
      result.PPy = codOrCoc.precinctsSizes[r].PPy;
    }
    // calculate codeblock size as described in section B.7
    result.xcb_ = (r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :
                   Math.min(codOrCoc.xcb, result.PPx));
    result.ycb_ = (r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :
                   Math.min(codOrCoc.ycb, result.PPy));
    return result;
  }
  function buildPrecincts(context, resolution, dimensions) {
    // Section B.6 Division resolution to precincts
    var precinctWidth = 1 << dimensions.PPx;
    var precinctHeight = 1 << dimensions.PPy;
    // Jasper introduces codeblock groups for mapping each subband codeblocks
    // to precincts. Precinct partition divides a resolution according to width
    // and height parameters. The subband that belongs to the resolution level
    // has a different size than the level, unless it is the zero resolution.

    // From Jasper documentation: jpeg2000.pdf, section K: Tier-2 coding:
    // The precinct partitioning for a particular subband is derived from a
    // partitioning of its parent LL band (i.e., the LL band at the next higher
    // resolution level)... The LL band associated with each resolution level is
    // divided into precincts... Each of the resulting precinct regions is then
    // mapped into its child subbands (if any) at the next lower resolution
    // level. This is accomplished by using the coordinate transformation
    // (u, v) = (ceil(x/2), ceil(y/2)) where (x, y) and (u, v) are the
    // coordinates of a point in the LL band and child subband, respectively.
    var isZeroRes = resolution.resLevel === 0;
    var precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));
    var precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));
    var numprecinctswide = (resolution.trx1 > resolution.trx0 ?
      Math.ceil(resolution.trx1 / precinctWidth) -
      Math.floor(resolution.trx0 / precinctWidth) : 0);
    var numprecinctshigh = (resolution.try1 > resolution.try0 ?
      Math.ceil(resolution.try1 / precinctHeight) -
      Math.floor(resolution.try0 / precinctHeight) : 0);
    var numprecincts = numprecinctswide * numprecinctshigh;

    resolution.precinctParameters = {
      precinctWidth: precinctWidth,
      precinctHeight: precinctHeight,
      numprecinctswide: numprecinctswide,
      numprecinctshigh: numprecinctshigh,
      numprecincts: numprecincts,
      precinctWidthInSubband: precinctWidthInSubband,
      precinctHeightInSubband: precinctHeightInSubband
    };
  }
  function buildCodeblocks(context, subband, dimensions) {
    // Section B.7 Division sub-band into code-blocks
    var xcb_ = dimensions.xcb_;
    var ycb_ = dimensions.ycb_;
    var codeblockWidth = 1 << xcb_;
    var codeblockHeight = 1 << ycb_;
    var cbx0 = subband.tbx0 >> xcb_;
    var cby0 = subband.tby0 >> ycb_;
    var cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;
    var cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;
    var precinctParameters = subband.resolution.precinctParameters;
    var codeblocks = [];
    var precincts = [];
    var i, j, codeblock, precinctNumber;
    for (j = cby0; j < cby1; j++) {
      for (i = cbx0; i < cbx1; i++) {
        codeblock = {
          cbx: i,
          cby: j,
          tbx0: codeblockWidth * i,
          tby0: codeblockHeight * j,
          tbx1: codeblockWidth * (i + 1),
          tby1: codeblockHeight * (j + 1)
        };

        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);

        // Calculate precinct number for this codeblock, codeblock position
        // should be relative to its subband, use actual dimension and position
        // See comment about codeblock group width and height
        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) /
          precinctParameters.precinctWidthInSubband);
        var pj = Math.floor((codeblock.tby0_ - subband.tby0) /
          precinctParameters.precinctHeightInSubband);
        precinctNumber = pi + (pj * precinctParameters.numprecinctswide);

        codeblock.precinctNumber = precinctNumber;
        codeblock.subbandType = subband.type;
        codeblock.Lblock = 3;

        if (codeblock.tbx1_ <= codeblock.tbx0_ ||
            codeblock.tby1_ <= codeblock.tby0_) {
          continue;
        }
        codeblocks.push(codeblock);
        // building precinct for the sub-band
        var precinct = precincts[precinctNumber];
        if (precinct !== undefined) {
          if (i < precinct.cbxMin) {
            precinct.cbxMin = i;
          } else if (i > precinct.cbxMax) {
            precinct.cbxMax = i;
          }
          if (j < precinct.cbyMin) {
            precinct.cbxMin = j;
          } else if (j > precinct.cbyMax) {
            precinct.cbyMax = j;
          }
        } else {
          precincts[precinctNumber] = precinct = {
            cbxMin: i,
            cbyMin: j,
            cbxMax: i,
            cbyMax: j
          };
        }
        codeblock.precinct = precinct;
      }
    }
    subband.codeblockParameters = {
      codeblockWidth: xcb_,
      codeblockHeight: ycb_,
      numcodeblockwide: cbx1 - cbx0 + 1,
      numcodeblockhigh: cby1 - cby0 + 1
    };
    subband.codeblocks = codeblocks;
    subband.precincts = precincts;
  }
  function createPacket(resolution, precinctNumber, layerNumber) {
    var precinctCodeblocks = [];
    // Section B.10.8 Order of info in packet
    var subbands = resolution.subbands;
    // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence
    for (var i = 0, ii = subbands.length; i < ii; i++) {
      var subband = subbands[i];
      var codeblocks = subband.codeblocks;
      for (var j = 0, jj = codeblocks.length; j < jj; j++) {
        var codeblock = codeblocks[j];
        if (codeblock.precinctNumber !== precinctNumber) {
          continue;
        }
        precinctCodeblocks.push(codeblock);
      }
    }
    return {
      layerNumber: layerNumber,
      codeblocks: precinctCodeblocks
    };
  }
  function LayerResolutionComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var l = 0, r = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.1 Layer-resolution-component-position
      for (; l < layersCount; l++) {
        for (; r <= maxDecompositionLevelsCount; r++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        r = 0;
      }
    };
  }
  function ResolutionLayerComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var r = 0, l = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.2 Resolution-layer-component-position
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; l < layersCount; l++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        l = 0;
      }
    };
  }
  function ResolutionPositionComponentLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var l, r, c, p;
    var maxDecompositionLevelsCount = 0;
    for (c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        component.codingStyleParameters.decompositionLevelsCount);
    }
    var maxNumPrecinctsInLevel = new Int32Array(
      maxDecompositionLevelsCount + 1);
    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
      var maxNumPrecincts = 0;
      for (c = 0; c < componentsCount; ++c) {
        var resolutions = tile.components[c].resolutions;
        if (r < resolutions.length) {
          maxNumPrecincts = Math.max(maxNumPrecincts,
            resolutions[r].precinctParameters.numprecincts);
        }
      }
      maxNumPrecinctsInLevel[r] = maxNumPrecincts;
    }
    l = 0;
    r = 0;
    c = 0;
    p = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.3 Resolution-position-component-layer
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; p < maxNumPrecinctsInLevel[r]; p++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }
            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            if (p >= numprecincts) {
              continue;
            }
            for (; l < layersCount;) {
              var packet = createPacket(resolution, p, l);
              l++;
              return packet;
            }
            l = 0;
          }
          c = 0;
        }
        p = 0;
      }
    };
  }
  function PositionComponentResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var precinctsIterationSizes = precinctsSizes;
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.4 Position-component-resolution-layer
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            var decompositionLevelsCount =
              component.codingStyleParameters.decompositionLevelsCount;
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale =
                precinctsSizes.components[c].resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          c = 0;
        }
        px = 0;
      }
    };
  }
  function ComponentPositionResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.5 Component-position-resolution-layer
      for (; c < componentsCount; ++c) {
        var component = tile.components[c];
        var precinctsIterationSizes = precinctsSizes.components[c];
        var decompositionLevelsCount =
          component.codingStyleParameters.decompositionLevelsCount;
        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
          for (; px < precinctsIterationSizes.maxNumWide; px++) {
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsIterationSizes.resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          px = 0;
        }
        py = 0;
      }
    };
  }
  function getPrecinctIndexIfExist(
    pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
    var posX = pxIndex * precinctIterationSizes.minWidth;
    var posY = pyIndex * precinctIterationSizes.minHeight;
    if (posX % sizeInImageScale.width !== 0 ||
        posY % sizeInImageScale.height !== 0) {
      return null;
    }
    var startPrecinctRowIndex =
      (posY / sizeInImageScale.width) *
      resolution.precinctParameters.numprecinctswide;
    return (posX / sizeInImageScale.height) + startPrecinctRowIndex;
  }
  function getPrecinctSizesInImageScale(tile) {
    var componentsCount = tile.components.length;
    var minWidth = Number.MAX_VALUE;
    var minHeight = Number.MAX_VALUE;
    var maxNumWide = 0;
    var maxNumHigh = 0;
    var sizePerComponent = new Array(componentsCount);
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      var sizePerResolution = new Array(decompositionLevelsCount + 1);
      var minWidthCurrentComponent = Number.MAX_VALUE;
      var minHeightCurrentComponent = Number.MAX_VALUE;
      var maxNumWideCurrentComponent = 0;
      var maxNumHighCurrentComponent = 0;
      var scale = 1;
      for (var r = decompositionLevelsCount; r >= 0; --r) {
        var resolution = component.resolutions[r];
        var widthCurrentResolution =
          scale * resolution.precinctParameters.precinctWidth;
        var heightCurrentResolution =
          scale * resolution.precinctParameters.precinctHeight;
        minWidthCurrentComponent = Math.min(
          minWidthCurrentComponent,
          widthCurrentResolution);
        minHeightCurrentComponent = Math.min(
          minHeightCurrentComponent,
          heightCurrentResolution);
        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent,
          resolution.precinctParameters.numprecinctswide);
        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent,
          resolution.precinctParameters.numprecinctshigh);
        sizePerResolution[r] = {
          width: widthCurrentResolution,
          height: heightCurrentResolution
        };
        scale <<= 1;
      }
      minWidth = Math.min(minWidth, minWidthCurrentComponent);
      minHeight = Math.min(minHeight, minHeightCurrentComponent);
      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
      sizePerComponent[c] = {
        resolutions: sizePerResolution,
        minWidth: minWidthCurrentComponent,
        minHeight: minHeightCurrentComponent,
        maxNumWide: maxNumWideCurrentComponent,
        maxNumHigh: maxNumHighCurrentComponent
      };
    }
    return {
      components: sizePerComponent,
      minWidth: minWidth,
      minHeight: minHeight,
      maxNumWide: maxNumWide,
      maxNumHigh: maxNumHigh
    };
  }
  function buildPackets(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var componentsCount = siz.Csiz;
    // Creating resolutions and sub-bands for each component
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      // Section B.5 Resolution levels and sub-bands
      var resolutions = [];
      var subbands = [];
      for (var r = 0; r <= decompositionLevelsCount; r++) {
        var blocksDimensions = getBlocksDimensions(context, component, r);
        var resolution = {};
        var scale = 1 << (decompositionLevelsCount - r);
        resolution.trx0 = Math.ceil(component.tcx0 / scale);
        resolution.try0 = Math.ceil(component.tcy0 / scale);
        resolution.trx1 = Math.ceil(component.tcx1 / scale);
        resolution.try1 = Math.ceil(component.tcy1 / scale);
        resolution.resLevel = r;
        buildPrecincts(context, resolution, blocksDimensions);
        resolutions.push(resolution);

        var subband;
        if (r === 0) {
          // one sub-band (LL) with last decomposition
          subband = {};
          subband.type = 'LL';
          subband.tbx0 = Math.ceil(component.tcx0 / scale);
          subband.tby0 = Math.ceil(component.tcy0 / scale);
          subband.tbx1 = Math.ceil(component.tcx1 / scale);
          subband.tby1 = Math.ceil(component.tcy1 / scale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolution.subbands = [subband];
        } else {
          var bscale = 1 << (decompositionLevelsCount - r + 1);
          var resolutionSubbands = [];
          // three sub-bands (HL, LH and HH) with rest of decompositions
          subband = {};
          subband.type = 'HL';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'LH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'HH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          resolution.subbands = resolutionSubbands;
        }
      }
      component.resolutions = resolutions;
      component.subbands = subbands;
    }
    // Generate the packets sequence
    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
    switch (progressionOrder) {
      case 0:
        tile.packetsIterator =
          new LayerResolutionComponentPositionIterator(context);
        break;
      case 1:
        tile.packetsIterator =
          new ResolutionLayerComponentPositionIterator(context);
        break;
      case 2:
        tile.packetsIterator =
          new ResolutionPositionComponentLayerIterator(context);
        break;
      case 3:
        tile.packetsIterator =
          new PositionComponentResolutionLayerIterator(context);
        break;
      case 4:
        tile.packetsIterator =
          new ComponentPositionResolutionLayerIterator(context);
        break;
      default:
        throw new Error('JPX Error: Unsupported progression order ' +
                        progressionOrder);
    }
  }
  function parseTilePackets(context, data, offset, dataLength) {
    var position = 0;
    var buffer, bufferSize = 0, skipNextBit = false;
    function readBits(count) {
      while (bufferSize < count) {
        if(offset + position  >= data.length){
          throw new Error("Unexpected EOF");
        }
        var b = data[offset + position];
        position++;
        if (skipNextBit) {
          buffer = (buffer << 7) | b;
          bufferSize += 7;
          skipNextBit = false;
        } else {
          buffer = (buffer << 8) | b;
          bufferSize += 8;
        }
        if (b === 0xFF) {
          skipNextBit = true;
        }
      }
      bufferSize -= count;
      return (buffer >>> bufferSize) & ((1 << count) - 1);
    }
    function skipMarkerIfEqual(value) {
      if (data[offset + position - 1] === 0xFF &&
          data[offset + position] === value) {
        skipBytes(1);
        return true;
      } else if (data[offset + position] === 0xFF &&
                 data[offset + position + 1] === value) {
        skipBytes(2);
        return true;
      }
      return false;
    }
    function skipBytes(count) {
      position += count;
    }
    function alignToByte() {
      bufferSize = 0;
      if (skipNextBit) {
        position++;
        skipNextBit = false;
      }
    }
    function readCodingpasses() {
      if (readBits(1) === 0) {
        return 1;
      }
      if (readBits(1) === 0) {
        return 2;
      }
      var value = readBits(2);
      if (value < 3) {
        return value + 3;
      }
      value = readBits(5);
      if (value < 31) {
        return value + 6;
      }
      value = readBits(7);
      return value + 37;
    }
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var sopMarkerUsed = context.COD.sopMarkerUsed;
    var ephMarkerUsed = context.COD.ephMarkerUsed;
    var packetsIterator = tile.packetsIterator;
    while (position < dataLength) {
      try{
        alignToByte();
        if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
          // Skip also marker segment length and packet sequence ID
          skipBytes(4);
        }
        var packet = packetsIterator.nextPacket();
        if (packet === undefined) {
          //No more packets. Stream is probably truncated.
          return;
        }
        if (!readBits(1)) {
          continue;
        }
        var layerNumber = packet.layerNumber;
        var queue = [], codeblock;
        for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
          codeblock = packet.codeblocks[i];
          var precinct = codeblock.precinct;
          var codeblockColumn = codeblock.cbx - precinct.cbxMin;
          var codeblockRow = codeblock.cby - precinct.cbyMin;
          var codeblockIncluded = false;
          var firstTimeInclusion = false;
          var valueReady;
          if (codeblock['included'] !== undefined) {
            codeblockIncluded = !!readBits(1);
          } else {
            // reading inclusion tree
            precinct = codeblock.precinct;
            var inclusionTree, zeroBitPlanesTree;
            if (precinct['inclusionTree'] !== undefined) {
              inclusionTree = precinct.inclusionTree;
            } else {
              // building inclusion and zero bit-planes trees
              var width = precinct.cbxMax - precinct.cbxMin + 1;
              var height = precinct.cbyMax - precinct.cbyMin + 1;
              inclusionTree = new InclusionTree(width, height);
              zeroBitPlanesTree = new TagTree(width, height);
              precinct.inclusionTree = inclusionTree;
              precinct.zeroBitPlanesTree = zeroBitPlanesTree;
            }

            inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber);
            while (true) {
              if (position >= data.length) {
                return;
              }
              if (inclusionTree.isAboveThreshold()){
                break;
              }
              if (inclusionTree.isKnown()) {
                inclusionTree.nextLevel();
                continue;
              }
              if (readBits(1)) {
                inclusionTree.setKnown();
                if (inclusionTree.isLeaf()) {
                  codeblock.included = true;
                  codeblockIncluded = firstTimeInclusion = true;
                  break;
                } else {
                  inclusionTree.nextLevel();
                }
              } else {
                inclusionTree.incrementValue();
              }
            }
          }
          if (!codeblockIncluded) {
            continue;
          }
          if (firstTimeInclusion) {
            zeroBitPlanesTree = precinct.zeroBitPlanesTree;
            zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
            while (true) {
              if (position >= data.length) {
                return;
              }
              if (readBits(1)) {
                valueReady = !zeroBitPlanesTree.nextLevel();
                if (valueReady) {
                  break;
                }
              } else {
                zeroBitPlanesTree.incrementValue();
              }
            }
            codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
          }
          var codingpasses = readCodingpasses();
          while (readBits(1)) {
            codeblock.Lblock++;
          }
          var codingpassesLog2 = log2(codingpasses);
          // rounding down log2
          var bits = ((codingpasses < (1 << codingpassesLog2)) ?
                      codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
          var codedDataLength = readBits(bits);
          queue.push({
            codeblock: codeblock,
            codingpasses: codingpasses,
            dataLength: codedDataLength
          });
        }
        alignToByte();
        if (ephMarkerUsed) {
          skipMarkerIfEqual(0x92);
        }
        while (queue.length > 0) {
          var packetItem = queue.shift();
          codeblock = packetItem.codeblock;
          if (codeblock['data'] === undefined) {
            codeblock.data = [];
          }
          codeblock.data.push({
            data: data,
            start: offset + position,
            end: offset + position + packetItem.dataLength,
            codingpasses: packetItem.codingpasses
          });
          position += packetItem.dataLength;
        }
      } catch (e) {
        return;
      }
    }
    return position;
  }
  function copyCoefficients(coefficients, levelWidth, levelHeight, subband,
                            delta, mb, reversible, segmentationSymbolUsed) {
    var x0 = subband.tbx0;
    var y0 = subband.tby0;
    var width = subband.tbx1 - subband.tbx0;
    var codeblocks = subband.codeblocks;
    var right = subband.type.charAt(0) === 'H' ? 1 : 0;
    var bottom = subband.type.charAt(1) === 'H' ? levelWidth : 0;

    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
      var codeblock = codeblocks[i];
      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
      var blockHeight = codeblock.tby1_ - codeblock.tby0_;
      if (blockWidth === 0 || blockHeight === 0) {
        continue;
      }
      if (codeblock['data'] === undefined) {
        continue;
      }

      var bitModel, currentCodingpassType;
      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,
                              codeblock.zeroBitPlanes, mb);
      currentCodingpassType = 2; // first bit plane starts from cleanup

      // collect data
      var data = codeblock.data, totalLength = 0, codingpasses = 0;
      var j, jj, dataItem;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        totalLength += dataItem.end - dataItem.start;
        codingpasses += dataItem.codingpasses;
      }
      var encodedData = new Int16Array(totalLength);
      var position = 0;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
        encodedData.set(chunk, position);
        position += chunk.length;
      }
      // decoding the item
      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
      bitModel.setDecoder(decoder);

      for (j = 0; j < codingpasses; j++) {
        switch (currentCodingpassType) {
          case 0:
            bitModel.runSignificancePropogationPass();
            break;
          case 1:
            bitModel.runMagnitudeRefinementPass();
            break;
          case 2:
            bitModel.runCleanupPass();
            if (segmentationSymbolUsed) {
              bitModel.checkSegmentationSymbol();
            }
            break;
        }
        currentCodingpassType = (currentCodingpassType + 1) % 3;
      }

      var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;
      var sign = bitModel.coefficentsSign;
      var magnitude = bitModel.coefficentsMagnitude;
      var bitsDecoded = bitModel.bitsDecoded;
      var magnitudeCorrection = reversible ? 0 : 0.5;
      var k, n, nb;
      position = 0;
      // Do the interleaving of Section F.3.3 here, so we do not need
      // to copy later. LL level is not interleaved, just copied.
      var interleave = (subband.type !== 'LL');
      for (j = 0; j < blockHeight; j++) {
        var row = (offset / width) | 0; // row in the non-interleaved subband
        var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
        for (k = 0; k < blockWidth; k++) {
          n = magnitude[position];
          if (n !== 0) {
            n = (n + magnitudeCorrection) * delta;
            if (sign[position] !== 0) {
              n = -n;
            }
            nb = bitsDecoded[position];
            var pos = interleave ? (levelOffset + (offset << 1)) : offset;
            if (reversible && (nb >= mb)) {
              coefficients[pos] = n;
            } else {
              coefficients[pos] = n * (1 << (mb - nb));
            }
          }
          offset++;
          position++;
        }
        offset += width - blockWidth;
      }
    }
  }
  function transformTile(context, tile, c) {
    var component = tile.components[c];
    var codingStyleParameters = component.codingStyleParameters;
    var quantizationParameters = component.quantizationParameters;
    var decompositionLevelsCount =
      codingStyleParameters.decompositionLevelsCount;
    var spqcds = quantizationParameters.SPqcds;
    var scalarExpounded = quantizationParameters.scalarExpounded;
    var guardBits = quantizationParameters.guardBits;
    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
    var precision = context.components[c].precision;

    var reversible = codingStyleParameters.reversibleTransformation;
    var transform = (reversible ? new ReversibleTransform() :
                                  new IrreversibleTransform());

    var subbandCoefficients = [];
    var b = 0;
    for (var i = 0; i <= decompositionLevelsCount; i++) {
      var resolution = component.resolutions[i];

      var width = resolution.trx1 - resolution.trx0;
      var height = resolution.try1 - resolution.try0;
      // Allocate space for the whole sublevel.
      var coefficients = new Float32Array(width * height);

      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
        var mu, epsilon;
        if (!scalarExpounded) {
          // formula E-5
          mu = spqcds[0].mu;
          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
        } else {
          mu = spqcds[b].mu;
          epsilon = spqcds[b].epsilon;
          b++;
        }

        var subband = resolution.subbands[j];
        var gainLog2 = SubbandsGainLog2[subband.type];

        // calulate quantization coefficient (Section E.1.1.1)
        var delta = (reversible ? 1 :
          Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048));
        var mb = (guardBits + epsilon - 1);

        // In the first resolution level, copyCoefficients will fill the
        // whole array with coefficients. In the succeding passes,
        // copyCoefficients will consecutively fill in the values that belong
        // to the interleaved positions of the HL, LH, and HH coefficients.
        // The LL coefficients will then be interleaved in Transform.iterate().
        copyCoefficients(coefficients, width, height, subband, delta, mb,
                         reversible, segmentationSymbolUsed);
      }
      subbandCoefficients.push({
        width: width,
        height: height,
        items: coefficients
      });
    }

    var result = transform.calculate(subbandCoefficients,
                                     component.tcx0, component.tcy0);
    return {
      left: component.tcx0,
      top: component.tcy0,
      width: result.width,
      height: result.height,
      items: result.items
    };
  }
  function transformComponents(context) {
    var siz = context.SIZ;
    var components = context.components;
    var componentsCount = siz.Csiz;
    var resultImages = [];
    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
      var tile = context.tiles[i];
      var transformedTiles = [];
      var c;
      for (c = 0; c < componentsCount; c++) {
        transformedTiles[c] = transformTile(context, tile, c);
      }
      var tile0 = transformedTiles[0];
      var isSigned = components[0].isSigned;
      if (isSigned) {
        var out = new Int16Array(tile0.items.length * componentsCount);
      } else {
        var out = new Uint16Array(tile0.items.length * componentsCount);
      }
      var result = {
        left: tile0.left,
        top: tile0.top,
        width: tile0.width,
        height: tile0.height,
        items: out
      };

      // Section G.2.2 Inverse multi component transform
      var shift, offset, max, min, maxK;
      var pos = 0, j, jj, y0, y1, y2, r, g, b, k, val;
      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
        var fourComponents = componentsCount === 4;
        var y0items = transformedTiles[0].items;
        var y1items = transformedTiles[1].items;
        var y2items = transformedTiles[2].items;
        var y3items = fourComponents ? transformedTiles[3].items : null;

        // HACK: The multiple component transform formulas below assume that
        // all components have the same precision. With this in mind, we
        // compute shift and offset only once.
        shift = components[0].precision - 8;
        offset = (128 << shift) + 0.5;
        max = 255 * (1 << shift);
        maxK = max * 0.5;
        min = -maxK;

        var component0 = tile.components[0];
        var alpha01 = componentsCount - 3;
        jj = y0items.length;
        if (!component0.codingStyleParameters.reversibleTransformation) {
          // inverse irreversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            r = y0 + 1.402 * y2;
            g = y0 - 0.34413 * y1 - 0.71414 * y2;
            b = y0 + 1.772 * y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        } else {
          // inverse reversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            g = y0 - ((y2 + y1) >> 2);
            r = g + y2;
            b = g + y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        }
        if (fourComponents) {
          for (j = 0, pos = 3; j < jj; j++, pos += 4) {
            k = y3items[j];
            out[pos] = k <= min ? 0 : k >= maxK ? 255 : (k + offset) >> shift;
          }
        }
      } else { // no multi-component transform
        for (c = 0; c < componentsCount; c++) {
          if (components[c].precision === 8){
            var items = transformedTiles[c].items;
            shift = components[c].precision - 8;
            offset = (128 << shift) + 0.5;
            max = (127.5 * (1 << shift));
            min = -max;
            for (pos = c, j = 0, jj = items.length; j < jj; j++) {
              val = items[j];
              out[pos] = val <= min ? 0 :
                         val >= max ? 255 : (val + offset) >> shift;
              pos += componentsCount;
            }
          }else{
            var isSigned = components[c].isSigned;
            var items = transformedTiles[c].items;

            if(isSigned){
              for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                out[pos] = items[j];
                pos += componentsCount;
              }
            }else{
              shift = components[c].precision - 8;
              offset = (128 << shift) + 0.5;
              var precisionMax = Math.pow(2,components[c].precision)-1;
              for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                val = items[j];
                out[pos] = Math.max(Math.min((val + offset),precisionMax),0);
                pos += componentsCount;
              }
            }
          }
        }
      }
      resultImages.push(result);
    }
    return resultImages;
  }
  function initializeTile(context, tileIndex) {
    var siz = context.SIZ;
    var componentsCount = siz.Csiz;
    var tile = context.tiles[tileIndex];
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var qcdOrQcc = (context.currentTile.QCC[c] !== undefined ?
        context.currentTile.QCC[c] : context.currentTile.QCD);
      component.quantizationParameters = qcdOrQcc;
      var codOrCoc = (context.currentTile.COC[c] !== undefined  ?
        context.currentTile.COC[c] : context.currentTile.COD);
      component.codingStyleParameters = codOrCoc;
    }
    tile.codingStyleDefaultParameters = context.currentTile.COD;
  }

  // Section B.10.2 Tag trees
  var TagTree = (function TagTreeClosure() {
    function TagTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var level = {
          width: width,
          height: height,
          items: []
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    TagTree.prototype = {
      reset: function TagTree_reset(i, j) {
        var currentLevel = 0, value = 0, level;
        while (currentLevel < this.levels.length) {
          level = this.levels[currentLevel];
          var index = i + j * level.width;
          if (level.items[index] !== undefined) {
            value = level.items[index];
            break;
          }
          level.index = index;
          i >>= 1;
          j >>= 1;
          currentLevel++;
        }
        currentLevel--;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        this.currentLevel = currentLevel;
        delete this.value;
      },
      incrementValue: function TagTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index]++;
      },
      nextLevel: function TagTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        currentLevel--;
        if (currentLevel < 0) {
          this.value = value;
          return false;
        }

        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return TagTree;
  })();

  var InclusionTree = (function InclusionTreeClosure() {
    function InclusionTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var items = new Uint8Array(width * height);
        var status = new Uint8Array(width * height);
        for (var j = 0, jj = items.length; j < jj; j++) {
          items[j] = 0;
          status[j] = 0;
        }

        var level = {
          width: width,
          height: height,
          items: items,
          status: status
        };
        this.levels.push(level);

        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    InclusionTree.prototype = {
      reset: function InclusionTree_reset(i, j, stopValue) {
        this.currentStopValue = stopValue;
        var currentLevel = 0;
        while (currentLevel < this.levels.length) {
          var level = this.levels[currentLevel];
          var index = i + j * level.width;
          level.index = index;

          i >>= 1;
          j >>= 1;
          currentLevel++;
        }

        this.currentLevel = this.levels.length - 1;
        this.minValue =this.levels[this.currentLevel].items[0];
        return;
      },
      incrementValue: function InclusionTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index] = level.items[level.index] + 1;
        if(level.items[level.index] > this.minValue) {
          this.minValue = level.items[level.index];
        }
      },
      nextLevel: function InclusionTree_nextLevel() {
        var currentLevel = this.currentLevel;
        currentLevel--;
        if (currentLevel < 0) {
          return false;
        } else {
          this.currentLevel = currentLevel;
          var level = this.levels[currentLevel];
          if(level.items[level.index] < this.minValue) {
            level.items[level.index] = this.minValue;
          }else if (level.items[level.index] > this.minValue) {
            this.minValue = level.items[level.index];
          }
          return true;
        }
      },
    isLeaf: function InclusionTree_isLeaf(){
      return (this.currentLevel === 0);
    },
    isAboveThreshold: function InclusionTree_isAboveThreshold(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      return (level.items[level.index] > this.currentStopValue);
    },
    isKnown: function InclusionTree_isKnown(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      return (level.status[level.index] > 0);
    },
    setKnown: function InclusionTree_setKnown(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      level.status[level.index] = 1;
      return;
    }

    };
    return InclusionTree;
  })();

  // Section D. Coefficient bit modeling
  var BitModel = (function BitModelClosure() {
    var UNIFORM_CONTEXT = 17;
    var RUNLENGTH_CONTEXT = 18;
    // Table D-1
    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),
    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)
    var LLAndLHContextsLabel = new Uint8Array([
      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,
      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,
      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8
    ]);
    var HLContextLabel = new Uint8Array([
      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,
      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,
      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8
    ]);
    var HHContextLabel = new Uint8Array([
      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,
      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,
      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8
    ]);

    function BitModel(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;

      this.contextLabelTable = (subband === 'HH' ? HHContextLabel :
        (subband === 'HL' ? HLContextLabel : LLAndLHContextsLabel));

      var coefficientCount = width * height;

      // coefficients outside the encoding region treated as insignificant
      // add border state cells for significanceState
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) :
                                  mb > 6 ? new Uint16Array(coefficientCount) :
                                  new Uint8Array(coefficientCount);
      this.processingFlags = new Uint8Array(coefficientCount);

      var bitsDecoded = new Uint8Array(coefficientCount);
      if (zeroBitPlanes !== 0) {
        for (var i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }
      this.bitsDecoded = bitsDecoded;

      this.reset();
    }

    BitModel.prototype = {
      setDecoder: function BitModel_setDecoder(decoder) {
        this.decoder = decoder;
      },
      reset: function BitModel_reset() {
        // We have 17 contexts that are accessed via context labels,
        // plus the uniform and runlength context.
        this.contexts = new Int8Array(19);

        // Contexts are packed into 1 byte:
        // highest 7 bits carry the index, lowest bit carries mps
        this.contexts[0] = (4 << 1) | 0;
        this.contexts[UNIFORM_CONTEXT] = (46 << 1) | 0;
        this.contexts[RUNLENGTH_CONTEXT] = (3 << 1) | 0;
      },
      setNeighborsSignificance:
        function BitModel_setNeighborsSignificance(row, column, index) {
        var neighborsSignificance = this.neighborsSignificance;
        var width = this.width, height = this.height;
        var left = (column > 0);
        var right = (column + 1 < width);
        var i;

        if (row > 0) {
          i = index - width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (row + 1 < height) {
          i = index + width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (left) {
          neighborsSignificance[index - 1] += 0x01;
        }
        if (right) {
          neighborsSignificance[index + 1] += 0x01;
        }
        neighborsSignificance[index] |= 0x80;
      },
      runSignificancePropogationPass:
        function BitModel_runSignificancePropogationPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var neighborsSignificance = this.neighborsSignificance;
        var processingFlags = this.processingFlags;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processedInverseMask = ~1;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;

        for (var i0 = 0; i0 < height; i0 += 4) {
          for (var j = 0; j < width; j++) {
            var index = i0 * width + j;
            for (var i1 = 0; i1 < 4; i1++, index += width) {
              var i = i0 + i1;
              if (i >= height) {
                break;
              }
              // clear processed flag first
              processingFlags[index] &= processedInverseMask;

              if (coefficentsMagnitude[index] ||
                  !neighborsSignificance[index]) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision) {
                var sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contribution, sign0, sign1, significance1;
        var contextLabel, decoded;

        // calculate horizontal contribution
        significance1 = (column > 0 && coefficentsMagnitude[index - 1] !== 0);
        if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
          sign1 = coefficentsSign[index + 1];
          if (significance1) {
            sign0 = coefficentsSign[index - 1];
            contribution = 1 - sign1 - sign0;
          } else {
            contribution = 1 - sign1 - sign1;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign0 - sign0;
        } else {
          contribution = 0;
        }
        var horizontalContribution = 3 * contribution;

        // calculate vertical contribution and combine with the horizontal
        significance1 = (row > 0 && coefficentsMagnitude[index - width] !== 0);
        if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
          sign1 = coefficentsSign[index + width];
          if (significance1) {
            sign0 = coefficentsSign[index - width];
            contribution = 1 - sign1 - sign0 + horizontalContribution;
          } else {
            contribution = 1 - sign1 - sign1 + horizontalContribution;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign0 - sign0 + horizontalContribution;
        } else {
          contribution = horizontalContribution;
        }

        if (contribution >= 0) {
          contextLabel = 9 + contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel);
        } else {
          contextLabel = 9 - contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
        }
        return decoded;
      },
      runMagnitudeRefinementPass:
        function BitModel_runMagnitudeRefinementPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var neighborsSignificance = this.neighborsSignificance;
        var contexts = this.contexts;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var length = width * height;
        var width4 = width * 4;

        for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
          indexNext = Math.min(length, index0 + width4);
          for (var j = 0; j < width; j++) {
            for (var index = index0 + j; index < indexNext; index += width) {

              // significant but not those that have just become
              if (!coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = 16;
              if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                processingFlags[index] ^= firstMagnitudeBitMask;
                // first refinement
               var significance = neighborsSignificance[index] & 127;
               contextLabel = significance === 0 ? 15 : 14;
              }

              var bit = decoder.readBit(contexts, contextLabel);
              coefficentsMagnitude[index] =
                (coefficentsMagnitude[index] << 1) | bit;
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      runCleanupPass: function BitModel_runCleanupPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var neighborsSignificance = this.neighborsSignificance;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var oneRowDown = width;
        var twoRowsDown = width * 2;
        var threeRowsDown = width * 3;
        var iNext;
        for (var i0 = 0; i0 < height; i0 = iNext) {
          iNext = Math.min(i0 + 4, height);
          var indexBase = i0 * width;
          var checkAllEmpty = i0 + 3 < height;
          for (var j = 0; j < width; j++) {
            var index0 = indexBase + j;
            // using the property: labels[neighborsSignificance[index]] === 0
            // when neighborsSignificance[index] === 0
            var allEmpty = (checkAllEmpty &&
              processingFlags[index0] === 0 &&
              processingFlags[index0 + oneRowDown] === 0 &&
              processingFlags[index0 + twoRowsDown] === 0 &&
              processingFlags[index0 + threeRowsDown] === 0 &&
              neighborsSignificance[index0] === 0 &&
              neighborsSignificance[index0 + oneRowDown] === 0 &&
              neighborsSignificance[index0 + twoRowsDown] === 0 &&
              neighborsSignificance[index0 + threeRowsDown] === 0);
            var i1 = 0, index = index0;
            var i = i0, sign;
            if (allEmpty) {
              var hasSignificantCoefficent =
                decoder.readBit(contexts, RUNLENGTH_CONTEXT);
              if (!hasSignificantCoefficent) {
                bitsDecoded[index0]++;
                bitsDecoded[index0 + oneRowDown]++;
                bitsDecoded[index0 + twoRowsDown]++;
                bitsDecoded[index0 + threeRowsDown]++;
                continue; // next column
              }
              i1 = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                    decoder.readBit(contexts, UNIFORM_CONTEXT);
              if (i1 !== 0) {
                i = i0 + i1;
                index += i1 * width;
              }

              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;

              index = index0;
              for (var i2 = i0; i2 <= i; i2++, index += width) {
                bitsDecoded[index]++;
              }

              i1++;
            }
            for (i = i0 + i1; i < iNext; i++, index += width) {
              if (coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision === 1) {
                sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
            }
          }
        }
      },
      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
        var decoder = this.decoder;
        var contexts = this.contexts;
        var symbol = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 3) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 2) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                      decoder.readBit(contexts, UNIFORM_CONTEXT);
        if (symbol !== 0xA) {
          throw new Error('JPX Error: Invalid segmentation symbol');
        }
      }
    };

    return BitModel;
  })();

  // Section F, Discrete wavelet transformation
  var Transform = (function TransformClosure() {
    function Transform() {}

    Transform.prototype.calculate =
      function transformCalculate(subbands, u0, v0) {
      var ll = subbands[0];
      for (var i = 1, ii = subbands.length; i < ii; i++) {
        ll = this.iterate(ll, subbands[i], u0, v0);
      }
      return ll;
    };
    Transform.prototype.extend = function extend(buffer, offset, size) {
      // Section F.3.7 extending... using max extension of 4
      var i1 = offset - 1, j1 = offset + 1;
      var i2 = offset + size - 2, j2 = offset + size;
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1] = buffer[j1];
      buffer[j2] = buffer[i2];
    };
    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh,
                                                             u0, v0) {
      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;
      var width = hl_lh_hh.width;
      var height = hl_lh_hh.height;
      var items = hl_lh_hh.items;
      var i, j, k, l, u, v;

      // Interleave LL according to Section F.3.3
      for (k = 0, i = 0; i < llHeight; i++) {
        l = i * 2 * width;
        for (j = 0; j < llWidth; j++, k++, l += 2) {
          items[l] = llItems[k];
        }
      }
      // The LL band is not needed anymore.
      llItems = ll.items = null;

      var bufferPadding = 4;
      var rowBuffer = new Float32Array(width + 2 * bufferPadding);

      // Section F.3.4 HOR_SR
      if (width === 1) {
        // if width = 1, when u0 even keep items as is, when odd divide by 2
        if ((u0 & 1) !== 0) {
          for (v = 0, k = 0; v < height; v++, k += width) {
            items[k] *= 0.5;
          }
        }
      } else {
        for (v = 0, k = 0; v < height; v++, k += width) {
          rowBuffer.set(items.subarray(k, k + width), bufferPadding);

          this.extend(rowBuffer, bufferPadding, width);
          this.filter(rowBuffer, bufferPadding, width);

          items.set(
            rowBuffer.subarray(bufferPadding, bufferPadding + width),
            k);
        }
      }

      // Accesses to the items array can take long, because it may not fit into
      // CPU cache and has to be fetched from main memory. Since subsequent
      // accesses to the items array are not local when reading columns, we
      // have a cache miss every time. To reduce cache misses, get up to
      // 'numBuffers' items at a time and store them into the individual
      // buffers. The colBuffers should be small enough to fit into CPU cache.
      var numBuffers = 16;
      var colBuffers = [];
      for (i = 0; i < numBuffers; i++) {
        colBuffers.push(new Float32Array(height + 2 * bufferPadding));
      }
      var b, currentBuffer = 0;
      ll = bufferPadding + height;

      // Section F.3.5 VER_SR
      if (height === 1) {
          // if height = 1, when v0 even keep items as is, when odd divide by 2
        if ((v0 & 1) !== 0) {
          for (u = 0; u < width; u++) {
            items[u] *= 0.5;
          }
        }
      } else {
        for (u = 0; u < width; u++) {
          // if we ran out of buffers, copy several image columns at once
          if (currentBuffer === 0) {
            numBuffers = Math.min(width - u, numBuffers);
            for (k = u, l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                colBuffers[b][l] = items[k + b];
              }
            }
            currentBuffer = numBuffers;
          }

          currentBuffer--;
          var buffer = colBuffers[currentBuffer];
          this.extend(buffer, bufferPadding, height);
          this.filter(buffer, bufferPadding, height);

          // If this is last buffer in this group of buffers, flush all buffers.
          if (currentBuffer === 0) {
            k = u - numBuffers + 1;
            for (l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                items[k + b] = colBuffers[b][l];
              }
            }
          }
        }
      }

      return {
        width: width,
        height: height,
        items: items
      };
    };
    return Transform;
  })();

  // Section 3.8.2 Irreversible 9-7 filter
  var IrreversibleTransform = (function IrreversibleTransformClosure() {
    function IrreversibleTransform() {
      Transform.call(this);
    }

    IrreversibleTransform.prototype = Object.create(Transform.prototype);
    IrreversibleTransform.prototype.filter =
      function irreversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n, current, next;

      var alpha = -1.586134342059924;
      var beta = -0.052980118572961;
      var gamma = 0.882911075530934;
      var delta = 0.443506852043971;
      var K = 1.230174104914001;
      var K_ = 1 / K;

      // step 1 is combined with step 3

      // step 2
      j = offset - 3;
      for (n = len + 4; n--; j += 2) {
        x[j] *= K_;
      }

      // step 1 & 3
      j = offset - 2;
      current = delta * x[j -1];
      for (n = len + 3; n--; j += 2) {
        next = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
        if (n--) {
          j += 2;
          current = delta * x[j + 1];
          x[j] = K * x[j] - current - next;
        } else {
          break;
        }
      }

      // step 4
      j = offset - 1;
      current = gamma * x[j - 1];
      for (n = len + 2; n--; j += 2) {
        next = gamma * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = gamma * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 5
      j = offset;
      current = beta * x[j - 1];
      for (n = len + 1; n--; j += 2) {
        next = beta * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = beta * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 6
      if (len !== 0) {
        j = offset + 1;
        current = alpha * x[j - 1];
        for (n = len; n--; j += 2) {
          next = alpha * x[j + 1];
          x[j] -= current + next;
          if (n--) {
            j += 2;
            current = alpha * x[j + 1];
            x[j] -= current + next;
          } else {
            break;
          }
        }
      }
    };

    return IrreversibleTransform;
  })();

  // Section 3.8.1 Reversible 5-3 filter
  var ReversibleTransform = (function ReversibleTransformClosure() {
    function ReversibleTransform() {
      Transform.call(this);
    }

    ReversibleTransform.prototype = Object.create(Transform.prototype);
    ReversibleTransform.prototype.filter =
      function reversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n;

      for (j = offset, n = len + 1; n--; j += 2) {
        x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;
      }

      for (j = offset + 1, n = len; n--; j += 2) {
        x[j] += (x[j - 1] + x[j + 1]) >> 1;
      }
    };

    return ReversibleTransform;
  })();

  return JpxImage;
})();


/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

/* This class implements the QM Coder decoding as defined in
 *   JPEG 2000 Part I Final Committee Draft Version 1.0
 *   Annex C.3 Arithmetic decoding procedure 
 * available at http://www.jpeg.org/public/fcd15444-1.pdf
 * 
 * The arithmetic decoder is used in conjunction with context models to decode
 * JPEG2000 and JBIG2 streams.
 */
var ArithmeticDecoder = (function ArithmeticDecoderClosure() {
  // Table C-2
  var QeTable = [
    {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},
    {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},
    {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},
    {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},
    {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},
    {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},
    {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},
    {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},
    {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},
    {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},
    {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},
    {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},
    {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},
    {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},
    {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},
    {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},
    {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},
    {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},
    {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},
    {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},
    {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},
    {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},
    {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},
    {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},
    {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},
    {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},
    {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},
    {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},
    {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},
    {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},
    {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},
    {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},
    {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},
    {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},
    {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},
    {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},
    {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},
    {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},
    {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},
    {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},
    {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},
    {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},
    {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},
    {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},
    {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},
    {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},
    {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}
  ];

  // C.3.5 Initialisation of the decoder (INITDEC)
  function ArithmeticDecoder(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;

    this.chigh = data[start];
    this.clow = 0;

    this.byteIn();

    this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);
    this.clow = (this.clow << 7) & 0xFFFF;
    this.ct -= 7;
    this.a = 0x8000;
  }

  ArithmeticDecoder.prototype = {
    // C.3.4 Compressed data input (BYTEIN)
    byteIn: function ArithmeticDecoder_byteIn() {
      var data = this.data;
      var bp = this.bp;
      if (data[bp] === 0xFF) {
        var b1 = data[bp + 1];
        if (b1 > 0x8F) {
          this.clow += 0xFF00;
          this.ct = 8;
        } else {
          bp++;
          this.clow += (data[bp] << 9);
          this.ct = 7;
          this.bp = bp;
        }
      } else {
        bp++;
        this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;
        this.ct = 8;
        this.bp = bp;
      }
      if (this.clow > 0xFFFF) {
        this.chigh += (this.clow >> 16);
        this.clow &= 0xFFFF;
      }
    },
    // C.3.2 Decoding a decision (DECODE)
    readBit: function ArithmeticDecoder_readBit(contexts, pos) {
      // contexts are packed into 1 byte:
      // highest 7 bits carry cx.index, lowest bit carries cx.mps
      var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
      var qeTableIcx = QeTable[cx_index];
      var qeIcx = qeTableIcx.qe;
      var d;
      var a = this.a - qeIcx;

      if (this.chigh < qeIcx) {
        // exchangeLps
        if (a < qeIcx) {
          a = qeIcx;
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        } else {
          a = qeIcx;
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        }
      } else {
        this.chigh -= qeIcx;
        if ((a & 0x8000) !== 0) {
          this.a = a;
          return cx_mps;
        }
        // exchangeMps
        if (a < qeIcx) {
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        } else {
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        }
      }
      // C.3.3 renormD;
      do {
        if (this.ct === 0) {
          this.byteIn();
        }

        a <<= 1;
        this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);
        this.clow = (this.clow << 1) & 0xFFFF;
        this.ct--;
      } while ((a & 0x8000) === 0);
      this.a = a;

      contexts[pos] = cx_index << 1 | cx_mps;
      return d;
    }
  };

  return ArithmeticDecoder;
})();

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals Cmd, ColorSpace, Dict, MozBlobBuilder, Name, PDFJS, Ref, URL,
           Promise */

'use strict';

var globalScope = (typeof window === 'undefined') ? this : window;

var isWorker = (typeof window === 'undefined');

var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];

var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};

var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};

var AnnotationType = {
  WIDGET: 1,
  TEXT: 2,
  LINK: 3
};

var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};

var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};

// The global PDFJS object exposes the API
// In production, it will be declared outside a global wrapper
// In development, it will be declared here
if (!globalScope.PDFJS) {
  globalScope.PDFJS = {};
}

globalScope.PDFJS.pdfBug = false;

PDFJS.VERBOSITY_LEVELS = {
  errors: 0,
  warnings: 1,
  infos: 5
};

// All the possible operations for an operator list.
var OPS = PDFJS.OPS = {
  // Intentionally start from 1 so it is easy to spot bad operators that will be
  // 0's.
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};

// A notice for devs. These are good for things that are helpful to devs, such
// as warning that Workers were disabled, which is important to devs but not
// end users.
function info(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {
    console.log('Info: ' + msg);
  }
}

// Non-fatal warnings.
function warn(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {
    console.log('Warning: ' + msg);
  }
}

// Fatal errors that should trigger the fallback UI and halt execution by
// throwing an exception.
function error(msg) {
  // If multiple arguments were passed, pass them all to the log function.
  if (arguments.length > 1) {
    var logArguments = ['Error:'];
    logArguments.push.apply(logArguments, arguments);
    console.log.apply(console, logArguments);
    // Join the arguments into a single string for the lines below.
    msg = [].join.call(arguments, ' ');
  } else {
    console.log('Error: ' + msg);
  }
  console.log(backtrace());
  UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown);
  throw new Error(msg);
}

function backtrace() {
  try {
    throw new Error();
  } catch (e) {
    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
  }
}

function assert(cond, msg) {
  if (!cond) {
    error(msg);
  }
}

var UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};

var UnsupportedManager = PDFJS.UnsupportedManager =
  (function UnsupportedManagerClosure() {
  var listeners = [];
  return {
    listen: function (cb) {
      listeners.push(cb);
    },
    notify: function (featureId) {
      warn('Unsupported feature "' + featureId + '"');
      for (var i = 0, ii = listeners.length; i < ii; i++) {
        listeners[i](featureId);
      }
    }
  };
})();

// Combines two URLs. The baseUrl shall be absolute URL. If the url is an
// absolute URL, it will be returned as is.
function combineUrl(baseUrl, url) {
  if (!url) {
    return baseUrl;
  }
  if (/^[a-z][a-z0-9+\-.]*:/i.test(url)) {
    return url;
  }
  var i;
  if (url.charAt(0) === '/') {
    // absolute path
    i = baseUrl.indexOf('://');
    if (url.charAt(1) === '/') {
      ++i;
    } else {
      i = baseUrl.indexOf('/', i + 3);
    }
    return baseUrl.substring(0, i) + url;
  } else {
    // relative path
    var pathLength = baseUrl.length;
    i = baseUrl.lastIndexOf('#');
    pathLength = i >= 0 ? i : pathLength;
    i = baseUrl.lastIndexOf('?', pathLength);
    pathLength = i >= 0 ? i : pathLength;
    var prefixLength = baseUrl.lastIndexOf('/', pathLength);
    return baseUrl.substring(0, prefixLength + 1) + url;
  }
}

// Validates if URL is safe and allowed, e.g. to avoid XSS.
function isValidUrl(url, allowRelative) {
  if (!url) {
    return false;
  }
  // RFC 3986 (http://tools.ietf.org/html/rfc3986#section-3.1)
  // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
  var protocol = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(url);
  if (!protocol) {
    return allowRelative;
  }
  protocol = protocol[0].toLowerCase();
  switch (protocol) {
    case 'http':
    case 'https':
    case 'ftp':
    case 'mailto':
    case 'tel':
      return true;
    default:
      return false;
  }
}
PDFJS.isValidUrl = isValidUrl;

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, { value: value,
                                     enumerable: true,
                                     configurable: true,
                                     writable: false });
  return value;
}
PDFJS.shadow = shadow;

var PasswordResponses = PDFJS.PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};

var PasswordException = (function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }

  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;

  return PasswordException;
})();
PDFJS.PasswordException = PasswordException;

var UnknownErrorException = (function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }

  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;

  return UnknownErrorException;
})();
PDFJS.UnknownErrorException = UnknownErrorException;

var InvalidPDFException = (function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }

  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;

  return InvalidPDFException;
})();
PDFJS.InvalidPDFException = InvalidPDFException;

var MissingPDFException = (function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }

  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;

  return MissingPDFException;
})();
PDFJS.MissingPDFException = MissingPDFException;

var UnexpectedResponseException =
    (function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }

  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;

  return UnexpectedResponseException;
})();
PDFJS.UnexpectedResponseException = UnexpectedResponseException;

var NotImplementedException = (function NotImplementedExceptionClosure() {
  function NotImplementedException(msg) {
    this.message = msg;
  }

  NotImplementedException.prototype = new Error();
  NotImplementedException.prototype.name = 'NotImplementedException';
  NotImplementedException.constructor = NotImplementedException;

  return NotImplementedException;
})();

var MissingDataException = (function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }

  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;

  return MissingDataException;
})();

var XRefParseException = (function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }

  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;

  return XRefParseException;
})();


function bytesToString(bytes) {
  assert(bytes !== null && typeof bytes === 'object' &&
         bytes.length !== undefined, 'Invalid argument for bytesToString');
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  var strBuf = [];
  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join('');
}

function stringToBytes(str) {
  assert(typeof str === 'string', 'Invalid argument for stringToBytes');
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}

function string32(value) {
  return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff,
                             (value >> 8) & 0xff, value & 0xff);
}

function log2(x) {
  var n = 1, i = 0;
  while (x > n) {
    n <<= 1;
    i++;
  }
  return i;
}

function readInt8(data, start) {
  return (data[start] << 24) >> 24;
}

function readUint16(data, offset) {
  return (data[offset] << 8) | data[offset + 1];
}

function readUint32(data, offset) {
  return ((data[offset] << 24) | (data[offset + 1] << 16) |
         (data[offset + 2] << 8) | data[offset + 3]) >>> 0;
}

// Lazy test the endianness of the platform
// NOTE: This will be 'true' for simulated TypedArrays
function isLittleEndian() {
  var buffer8 = new Uint8Array(2);
  buffer8[0] = 1;
  var buffer16 = new Uint16Array(buffer8.buffer);
  return (buffer16[0] === 1);
}

Object.defineProperty(PDFJS, 'isLittleEndian', {
  configurable: true,
  get: function PDFJS_isLittleEndian() {
    return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
  }
});

//#if !(FIREFOX || MOZCENTRAL || B2G || CHROME)
//// Lazy test if the userAgant support CanvasTypedArrays
function hasCanvasTypedArrays() {
  var canvas = document.createElement('canvas');
  canvas.width = canvas.height = 1;
  var ctx = canvas.getContext('2d');
  var imageData = ctx.createImageData(1, 1);
  return (typeof imageData.data.buffer !== 'undefined');
}

Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {
  configurable: true,
  get: function PDFJS_hasCanvasTypedArrays() {
    return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());
  }
});

var Uint32ArrayView = (function Uint32ArrayViewClosure() {

  function Uint32ArrayView(buffer, length) {
    this.buffer = buffer;
    this.byteLength = buffer.length;
    this.length = length === undefined ? (this.byteLength >> 2) : length;
    ensureUint32ArrayViewProps(this.length);
  }
  Uint32ArrayView.prototype = Object.create(null);

  var uint32ArrayViewSetters = 0;
  function createUint32ArrayProp(index) {
    return {
      get: function () {
        var buffer = this.buffer, offset = index << 2;
        return (buffer[offset] | (buffer[offset + 1] << 8) |
          (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;
      },
      set: function (value) {
        var buffer = this.buffer, offset = index << 2;
        buffer[offset] = value & 255;
        buffer[offset + 1] = (value >> 8) & 255;
        buffer[offset + 2] = (value >> 16) & 255;
        buffer[offset + 3] = (value >>> 24) & 255;
      }
    };
  }

  function ensureUint32ArrayViewProps(length) {
    while (uint32ArrayViewSetters < length) {
      Object.defineProperty(Uint32ArrayView.prototype,
        uint32ArrayViewSetters,
        createUint32ArrayProp(uint32ArrayViewSetters));
      uint32ArrayViewSetters++;
    }
  }

  return Uint32ArrayView;
})();
//#else
//PDFJS.hasCanvasTypedArrays = true;
//#endif

var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];

var Util = PDFJS.Util = (function UtilClosure() {
  function Util() {}

  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];

  // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids
  // creating many intermediate strings.
  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };

  // Concatenates two transformation matrices together and returns the result.
  Util.transform = function Util_transform(m1, m2) {
    return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
    ];
  };

  // For 2d affine transforms
  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };

  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };

  // Applies the transform to the rectangle and finds the minimum axially
  // aligned bounding box.
  Util.getAxialAlignedBoundingBox =
    function Util_getAxialAlignedBoundingBox(r, m) {

    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [
      Math.min(p1[0], p2[0], p3[0], p4[0]),
      Math.min(p1[1], p2[1], p3[1], p4[1]),
      Math.max(p1[0], p2[0], p3[0], p4[0]),
      Math.max(p1[1], p2[1], p3[1], p4[1])
    ];
  };

  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d,
      (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };

  // Apply a generic 3d matrix M on a 3-vector v:
  //   | a b c |   | X |
  //   | d e f | x | Y |
  //   | g h i |   | Z |
  // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],
  // with v as [X,Y,Z]
  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [
      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
      m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
    ];
  };

  // This calculation uses Singular Value Decomposition.
  // The SVD can be represented with formula A = USV. We are interested in the
  // matrix S here because it represents the scale values.
  Util.singularValueDecompose2dScale =
    function Util_singularValueDecompose2dScale(m) {

    var transpose = [m[0], m[2], m[1], m[3]];

    // Multiply matrix m with its transpose.
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];

    // Solve the second degree polynomial to get roots.
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;

    // Scale values are the square roots of the eigenvalues.
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };

  // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)
  // For coordinate systems whose origin lies in the bottom-left, this
  // means normalization to (BL,TR) ordering. For systems with origin in the
  // top-left, this means (TL,BR) ordering.
  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0); // clone rect
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  };

  // Returns a rectangle [x1, y1, x2, y2] corresponding to the
  // intersection of rect1 and rect2. If no intersection, returns 'false'
  // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]
  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    // Order points along the axes
    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];

    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    // X: first and second points belong to different rectangles?
    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) ||
        (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {
      // Intersection must be between second and third points
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }

    // Y: first and second points belong to different rectangles?
    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) ||
        (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {
      // Intersection must be between second and third points
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }

    return result;
  };

  Util.sign = function Util_sign(num) {
    return num < 0 ? -1 : 1;
  };

  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };

  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };

  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };

  Util.getInheritableProperty = function Util_getInheritableProperty(dict,
                                                                     name) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }
    if (!dict) {
      return null;
    }
    return dict.get(name);
  };

  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };

  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);
    if (callback) {
      script.onload = function() {
        if (!loaded) {
          callback();
        }
        loaded = true;
      };
    }
    document.getElementsByTagName('head')[0].appendChild(script);
  };

  return Util;
})();

/**
 * PDF page viewport created based on scale, rotation and offset.
 * @class
 * @alias PDFJS.PageViewport
 */
var PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {
  /**
   * @constructor
   * @private
   * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.
   * @param scale {number} scale of the viewport.
   * @param rotation {number} rotations of the viewport in degrees.
   * @param offsetX {number} offset X
   * @param offsetY {number} offset Y
   * @param dontFlip {boolean} if true, axis Y will not be flipped.
   */
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;

    // creating transform to convert pdf coordinate system to the normal
    // canvas like coordinates taking in account scale and rotation
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;
    switch (rotation) {
      case 180:
        rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1;
        break;
      case 90:
        rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0;
        break;
      case 270:
        rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0;
        break;
      //case 0:
      default:
        rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1;
        break;
    }

    if (dontFlip) {
      rotateC = -rotateC; rotateD = -rotateD;
    }

    var offsetCanvasX, offsetCanvasY;
    var width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }
    // creating transform for the following operations:
    // translate(-centerX, -centerY), rotate and flip vertically,
    // scale, and translate(offsetCanvasX, offsetCanvasY)
    this.transform = [
      rotateA * scale,
      rotateB * scale,
      rotateC * scale,
      rotateD * scale,
      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,
      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY
    ];

    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }
  PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {
    /**
     * Clones viewport with additional properties.
     * @param args {Object} (optional) If specified, may contain the 'scale' or
     * 'rotation' properties to override the corresponding properties in
     * the cloned viewport.
     * @returns {PDFJS.PageViewport} Cloned viewport.
     */
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation,
                              this.offsetX, this.offsetY, args.dontFlip);
    },
    /**
     * Converts PDF point to the viewport coordinates. For examples, useful for
     * converting PDF location into canvas pixel coordinates.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the viewport coordinate space.
     * @see {@link convertToPdfPoint}
     * @see {@link convertToViewportRectangle}
     */
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    /**
     * Converts PDF rectangle to the viewport coordinates.
     * @param rect {Array} xMin, yMin, xMax and yMax coordinates.
     * @returns {Array} Contains corresponding coordinates of the rectangle
     * in the viewport coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToViewportRectangle:
      function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    /**
     * Converts viewport coordinates to the PDF location. For examples, useful
     * for converting canvas pixel location into PDF one.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the PDF coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
})();

var PDFStringTranslateTable = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014,
  0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C,
  0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160,
  0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC
];

function stringToPDFString(str) {
  var i, n = str.length, strBuf = [];
  if (str[0] === '\xFE' && str[1] === '\xFF') {
    // UTF16BE BOM
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(
        (str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }
  return strBuf.join('');
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

function isBool(v) {
  return typeof v === 'boolean';
}

function isInt(v) {
  return typeof v === 'number' && ((v | 0) === v);
}

function isNum(v) {
  return typeof v === 'number';
}

function isString(v) {
  return typeof v === 'string';
}

function isNull(v) {
  return v === null;
}

function isName(v) {
  return v instanceof Name;
}

function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}

function isDict(v, type) {
  if (!(v instanceof Dict)) {
    return false;
  }
  if (!type) {
    return true;
  }
  var dictType = v.get('Type');
  return isName(dictType) && dictType.name === type;
}

function isArray(v) {
  return v instanceof Array;
}

function isStream(v) {
  return typeof v === 'object' && v !== null && v.getBytes !== undefined;
}

function isArrayBuffer(v) {
  return typeof v === 'object' && v !== null && v.byteLength !== undefined;
}

function isRef(v) {
  return v instanceof Ref;
}

/**
 * Promise Capability object.
 *
 * @typedef {Object} PromiseCapability
 * @property {Promise} promise - A promise object.
 * @property {function} resolve - Fullfills the promise.
 * @property {function} reject - Rejects the promise.
 */

/**
 * Creates a promise capability object.
 * @alias PDFJS.createPromiseCapability
 *
 * @return {PromiseCapability} A capability object contains:
 * - a Promise, resolve and reject methods.
 */
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}

PDFJS.createPromiseCapability = createPromiseCapability;

/**
 * Polyfill for Promises:
 * The following promise implementation tries to generally implement the
 * Promise/A+ spec. Some notable differences from other promise libaries are:
 * - There currently isn't a seperate deferred and promise object.
 * - Unhandled rejections eventually show an error if they aren't handled.
 *
 * Based off of the work in:
 * https://bugzilla.mozilla.org/show_bug.cgi?id=810490
 */
(function PromiseClosure() {
  if (globalScope.Promise) {
    // Promises existing in the DOM/Worker, checking presence of all/resolve
    if (typeof globalScope.Promise.all !== 'function') {
      globalScope.Promise.all = function (iterable) {
        var count = 0, results = [], resolve, reject;
        var promise = new globalScope.Promise(function (resolve_, reject_) {
          resolve = resolve_;
          reject = reject_;
        });
        iterable.forEach(function (p, i) {
          count++;
          p.then(function (result) {
            results[i] = result;
            count--;
            if (count === 0) {
              resolve(results);
            }
          }, reject);
        });
        if (count === 0) {
          resolve(results);
        }
        return promise;
      };
    }
    if (typeof globalScope.Promise.resolve !== 'function') {
      globalScope.Promise.resolve = function (value) {
        return new globalScope.Promise(function (resolve) { resolve(value); });
      };
    }
    if (typeof globalScope.Promise.reject !== 'function') {
      globalScope.Promise.reject = function (reason) {
        return new globalScope.Promise(function (resolve, reject) {
          reject(reason);
        });
      };
    }
    if (typeof globalScope.Promise.prototype.catch !== 'function') {
      globalScope.Promise.prototype.catch = function (onReject) {
        return globalScope.Promise.prototype.then(undefined, onReject);
      };
    }
    return;
  }
//#if !MOZCENTRAL
  var STATUS_PENDING = 0;
  var STATUS_RESOLVED = 1;
  var STATUS_REJECTED = 2;

  // In an attempt to avoid silent exceptions, unhandled rejections are
  // tracked and if they aren't handled in a certain amount of time an
  // error is logged.
  var REJECTION_TIMEOUT = 500;

  var HandlerManager = {
    handlers: [],
    running: false,
    unhandledRejections: [],
    pendingRejectionCheck: false,

    scheduleHandlers: function scheduleHandlers(promise) {
      if (promise._status === STATUS_PENDING) {
        return;
      }

      this.handlers = this.handlers.concat(promise._handlers);
      promise._handlers = [];

      if (this.running) {
        return;
      }
      this.running = true;

      setTimeout(this.runHandlers.bind(this), 0);
    },

    runHandlers: function runHandlers() {
      var RUN_TIMEOUT = 1; // ms
      var timeoutAt = Date.now() + RUN_TIMEOUT;
      while (this.handlers.length > 0) {
        var handler = this.handlers.shift();

        var nextStatus = handler.thisPromise._status;
        var nextValue = handler.thisPromise._value;

        try {
          if (nextStatus === STATUS_RESOLVED) {
            if (typeof handler.onResolve === 'function') {
              nextValue = handler.onResolve(nextValue);
            }
          } else if (typeof handler.onReject === 'function') {
              nextValue = handler.onReject(nextValue);
              nextStatus = STATUS_RESOLVED;

              if (handler.thisPromise._unhandledRejection) {
                this.removeUnhandeledRejection(handler.thisPromise);
              }
          }
        } catch (ex) {
          nextStatus = STATUS_REJECTED;
          nextValue = ex;
        }

        handler.nextPromise._updateStatus(nextStatus, nextValue);
        if (Date.now() >= timeoutAt) {
          break;
        }
      }

      if (this.handlers.length > 0) {
        setTimeout(this.runHandlers.bind(this), 0);
        return;
      }

      this.running = false;
    },

    addUnhandledRejection: function addUnhandledRejection(promise) {
      this.unhandledRejections.push({
        promise: promise,
        time: Date.now()
      });
      this.scheduleRejectionCheck();
    },

    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
      promise._unhandledRejection = false;
      for (var i = 0; i < this.unhandledRejections.length; i++) {
        if (this.unhandledRejections[i].promise === promise) {
          this.unhandledRejections.splice(i);
          i--;
        }
      }
    },

    scheduleRejectionCheck: function scheduleRejectionCheck() {
      if (this.pendingRejectionCheck) {
        return;
      }
      this.pendingRejectionCheck = true;
      setTimeout(function rejectionCheck() {
        this.pendingRejectionCheck = false;
        var now = Date.now();
        for (var i = 0; i < this.unhandledRejections.length; i++) {
          if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
            var unhandled = this.unhandledRejections[i].promise._value;
            var msg = 'Unhandled rejection: ' + unhandled;
            if (unhandled.stack) {
              msg += '\n' + unhandled.stack;
            }
            warn(msg);
            this.unhandledRejections.splice(i);
            i--;
          }
        }
        if (this.unhandledRejections.length) {
          this.scheduleRejectionCheck();
        }
      }.bind(this), REJECTION_TIMEOUT);
    }
  };

  function Promise(resolver) {
    this._status = STATUS_PENDING;
    this._handlers = [];
    try {
      resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
    } catch (e) {
      this._reject(e);
    }
  }
  /**
   * Builds a promise that is resolved when all the passed in promises are
   * resolved.
   * @param {array} array of data and/or promises to wait for.
   * @return {Promise} New dependant promise.
   */
  Promise.all = function Promise_all(promises) {
    var resolveAll, rejectAll;
    var deferred = new Promise(function (resolve, reject) {
      resolveAll = resolve;
      rejectAll = reject;
    });
    var unresolved = promises.length;
    var results = [];
    if (unresolved === 0) {
      resolveAll(results);
      return deferred;
    }
    function reject(reason) {
      if (deferred._status === STATUS_REJECTED) {
        return;
      }
      results = [];
      rejectAll(reason);
    }
    for (var i = 0, ii = promises.length; i < ii; ++i) {
      var promise = promises[i];
      var resolve = (function(i) {
        return function(value) {
          if (deferred._status === STATUS_REJECTED) {
            return;
          }
          results[i] = value;
          unresolved--;
          if (unresolved === 0) {
            resolveAll(results);
          }
        };
      })(i);
      if (Promise.isPromise(promise)) {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
    return deferred;
  };

  /**
   * Checks if the value is likely a promise (has a 'then' function).
   * @return {boolean} true if value is thenable
   */
  Promise.isPromise = function Promise_isPromise(value) {
    return value && typeof value.then === 'function';
  };

  /**
   * Creates resolved promise
   * @param value resolve value
   * @returns {Promise}
   */
  Promise.resolve = function Promise_resolve(value) {
    return new Promise(function (resolve) { resolve(value); });
  };

  /**
   * Creates rejected promise
   * @param reason rejection value
   * @returns {Promise}
   */
  Promise.reject = function Promise_reject(reason) {
    return new Promise(function (resolve, reject) { reject(reason); });
  };

  Promise.prototype = {
    _status: null,
    _value: null,
    _handlers: null,
    _unhandledRejection: null,

    _updateStatus: function Promise__updateStatus(status, value) {
      if (this._status === STATUS_RESOLVED ||
          this._status === STATUS_REJECTED) {
        return;
      }

      if (status === STATUS_RESOLVED &&
          Promise.isPromise(value)) {
        value.then(this._updateStatus.bind(this, STATUS_RESOLVED),
                   this._updateStatus.bind(this, STATUS_REJECTED));
        return;
      }

      this._status = status;
      this._value = value;

      if (status === STATUS_REJECTED && this._handlers.length === 0) {
        this._unhandledRejection = true;
        HandlerManager.addUnhandledRejection(this);
      }

      HandlerManager.scheduleHandlers(this);
    },

    _resolve: function Promise_resolve(value) {
      this._updateStatus(STATUS_RESOLVED, value);
    },

    _reject: function Promise_reject(reason) {
      this._updateStatus(STATUS_REJECTED, reason);
    },

    then: function Promise_then(onResolve, onReject) {
      var nextPromise = new Promise(function (resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
      });
      this._handlers.push({
        thisPromise: this,
        onResolve: onResolve,
        onReject: onReject,
        nextPromise: nextPromise
      });
      HandlerManager.scheduleHandlers(this);
      return nextPromise;
    },

    catch: function Promise_catch(onReject) {
      return this.then(undefined, onReject);
    }
  };

  globalScope.Promise = Promise;
//#else
//throw new Error('DOM Promise is not present');
//#endif
})();

var StatTimer = (function StatTimerClosure() {
  function rpad(str, pad, length) {
    while (str.length < length) {
      str += pad;
    }
    return str;
  }
  function StatTimer() {
    this.started = {};
    this.times = [];
    this.enabled = true;
  }
  StatTimer.prototype = {
    time: function StatTimer_time(name) {
      if (!this.enabled) {
        return;
      }
      if (name in this.started) {
        warn('Timer is already running for ' + name);
      }
      this.started[name] = Date.now();
    },
    timeEnd: function StatTimer_timeEnd(name) {
      if (!this.enabled) {
        return;
      }
      if (!(name in this.started)) {
        warn('Timer has not been started for ' + name);
      }
      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      // Remove timer from started so it can be called again.
      delete this.started[name];
    },
    toString: function StatTimer_toString() {
      var i, ii;
      var times = this.times;
      var out = '';
      // Find the longest name for padding purposes.
      var longest = 0;
      for (i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];
        if (name.length > longest) {
          longest = name.length;
        }
      }
      for (i = 0, ii = times.length; i < ii; ++i) {
        var span = times[i];
        var duration = span.end - span.start;
        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
      }
      return out;
    }
  };
  return StatTimer;
})();

PDFJS.createBlob = function createBlob(data, contentType) {
  if (typeof Blob !== 'undefined') {
    return new Blob([data], { type: contentType });
  }
  // Blob builder is deprecated in FF14 and removed in FF18.
  var bb = new MozBlobBuilder();
  bb.append(data);
  return bb.getBlob(contentType);
};

PDFJS.createObjectURL = (function createObjectURLClosure() {
  // Blob/createObjectURL is not available, falling back to data schema.
  var digits =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  return function createObjectURL(data, contentType) {
    if (!PDFJS.disableCreateObjectURL &&
        typeof URL !== 'undefined' && URL.createObjectURL) {
      var blob = PDFJS.createBlob(data, contentType);
      return URL.createObjectURL(blob);
    }

    var buffer = 'data:' + contentType + ';base64,';
    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2, d2 = ((b1 & 3) << 4) | (b2 >> 4);
      var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;
      var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }
    return buffer;
  };
})();

function MessageHandler(name, comObj) {
  this.name = name;
  this.comObj = comObj;
  this.callbackIndex = 1;
  this.postMessageTransfers = true;
  var callbacksCapabilities = this.callbacksCapabilities = {};
  var ah = this.actionHandler = {};

  ah['console_log'] = [function ahConsoleLog(data) {
    console.log.apply(console, data);
  }];
  ah['console_error'] = [function ahConsoleError(data) {
    console.error.apply(console, data);
  }];
  ah['_unsupported_feature'] = [function ah_unsupportedFeature(data) {
    UnsupportedManager.notify(data);
  }];

  comObj.onmessage = function messageHandlerComObjOnMessage(event) {
    var data = event.data;
    if (data.isReply) {
      var callbackId = data.callbackId;
      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];
        if ('error' in data) {
          callback.reject(data.error);
        } else {
          callback.resolve(data.data);
        }
      } else {
        error('Cannot resolve callback ' + callbackId);
      }
    } else if (data.action in ah) {
      var action = ah[data.action];
      if (data.callbackId) {
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            error: reason
          });
        });
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      error('Unknown action from worker: ' + data.action);
    }
  };
}

MessageHandler.prototype = {
  on: function messageHandlerOn(actionName, handler, scope) {
    var ah = this.actionHandler;
    if (ah[actionName]) {
      error('There is already an actionName called "' + actionName + '"');
    }
    ah[actionName] = [handler, scope];
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers
   */
  send: function messageHandlerSend(actionName, data, transfers) {
    var message = {
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * Expects that other side will callback with the response.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.
   * @returns {Promise} Promise to be resolved with response data.
   */
  sendWithPromise:
    function messageHandlerSendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackIndex++;
    var message = {
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = createPromiseCapability();
    this.callbacksCapabilities[callbackId] = capability;
    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }
    return capability.promise;
  },
  /**
   * Sends raw message to the comObj.
   * @private
   * @param message {Object} Raw message.
   * @param transfers List of transfers/ArrayBuffers, or undefined.
   */
  postMessage: function (message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }
};

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = JpxImage;
}

function loadJpegStream(id, imageUrl, objs) {
  var img = new Image();
  img.onload = (function loadJpegStream_onloadClosure() {
    objs.resolve(id, img);
  });
  img.onerror = (function loadJpegStream_onerrorClosure() {
    objs.resolve(id, null);
    warn('Error during JPEG image loading');
  });
  img.src = imageUrl;
}
},{}],3:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":86}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){

},{}],6:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],7:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],8:[function(require,module,exports){
'use strict';


module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],9:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],10:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":6,"./adler32":7,"./crc32":9,"./messages":14,"./trees":15}],11:[function(require,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],12:[function(require,module,exports){
'use strict';


var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":6,"./adler32":7,"./crc32":9,"./inffast":11,"./inftrees":13}],13:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i = 0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":6}],14:[function(require,module,exports){
'use strict';

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],15:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":6}],16:[function(require,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],17:[function(require,module,exports){
(function (process,Buffer){
var msg = require('pako/lib/zlib/messages');
var zstream = require('pako/lib/zlib/zstream');
var zlib_deflate = require('pako/lib/zlib/deflate.js');
var zlib_inflate = require('pako/lib/zlib/inflate.js');
var constants = require('pako/lib/zlib/constants');

for (var key in constants) {
  exports[key] = constants[key];
}

// zlib modes
exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;

/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */
function Zlib(mode) {
  if (mode < exports.DEFLATE || mode > exports.UNZIP)
    throw new TypeError("Bad argument");
    
  this.mode = mode;
  this.init_done = false;
  this.write_in_progress = false;
  this.pending_close = false;
  this.windowBits = 0;
  this.level = 0;
  this.memLevel = 0;
  this.strategy = 0;
  this.dictionary = null;
}

Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
  this.windowBits = windowBits;
  this.level = level;
  this.memLevel = memLevel;
  this.strategy = strategy;
  // dictionary not supported.
  
  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
    this.windowBits += 16;
    
  if (this.mode === exports.UNZIP)
    this.windowBits += 32;
    
  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
    this.windowBits = -this.windowBits;
    
  this.strm = new zstream();
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateInit2(
        this.strm,
        this.level,
        exports.Z_DEFLATED,
        this.windowBits,
        this.memLevel,
        this.strategy
      );
      break;
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      var status  = zlib_inflate.inflateInit2(
        this.strm,
        this.windowBits
      );
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
    return;
  }
  
  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype.params = function() {
  throw new Error("deflateParams Not supported");
};

Zlib.prototype._writeCheck = function() {
  if (!this.init_done)
    throw new Error("write before init");
    
  if (this.mode === exports.NONE)
    throw new Error("already finalized");
    
  if (this.write_in_progress)
    throw new Error("write already in progress");
    
  if (this.pending_close)
    throw new Error("close is pending");
};

Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
  this._writeCheck();
  this.write_in_progress = true;
  
  var self = this;
  process.nextTick(function() {
    self.write_in_progress = false;
    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
    self.callback(res[0], res[1]);
    
    if (self.pending_close)
      self.close();
  });
  
  return this;
};

// set method for Node buffers, used by pako
function bufferSet(data, offset) {
  for (var i = 0; i < data.length; i++) {
    this[offset + i] = data[i];
  }
}

Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this._writeCheck();
  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this.write_in_progress = true;
  
  if (flush !== exports.Z_NO_FLUSH &&
      flush !== exports.Z_PARTIAL_FLUSH &&
      flush !== exports.Z_SYNC_FLUSH &&
      flush !== exports.Z_FULL_FLUSH &&
      flush !== exports.Z_FINISH &&
      flush !== exports.Z_BLOCK) {
    throw new Error("Invalid flush value");
  }
  
  if (input == null) {
    input = new Buffer(0);
    in_len = 0;
    in_off = 0;
  }
  
  if (out._set)
    out.set = out._set;
  else
    out.set = bufferSet;
  
  var strm = this.strm;
  strm.avail_in = in_len;
  strm.input = input;
  strm.next_in = in_off;
  strm.avail_out = out_len;
  strm.output = out;
  strm.next_out = out_off;
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflate(strm, flush);
      break;
    case exports.UNZIP:
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflate(strm, flush);
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
    this._error(status);
  }
  
  this.write_in_progress = false;
  return [strm.avail_in, strm.avail_out];
};

Zlib.prototype.close = function() {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }
  
  this.pending_close = false;
  
  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else {
    zlib_inflate.inflateEnd(this.strm);
  }
  
  this.mode = exports.NONE;
};

Zlib.prototype.reset = function() {
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateReset(this.strm);
      break;
    case exports.INFLATE:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflateReset(this.strm);
      break;
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
  }
};

Zlib.prototype._error = function(status) {
  this.onerror(msg[status] + ': ' + this.strm.msg, status);
  
  this.write_in_progress = false;
  if (this.pending_close)
    this.close();
};

exports.Zlib = Zlib;

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":68,"buffer":20,"pako/lib/zlib/constants":8,"pako/lib/zlib/deflate.js":10,"pako/lib/zlib/inflate.js":12,"pako/lib/zlib/messages":14,"pako/lib/zlib/zstream":16}],18:[function(require,module,exports){
(function (process,Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Transform = require('_stream_transform');

var binding = require('./binding');
var util = require('util');
var assert = require('assert').ok;

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = (16 * 1024);

binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;

binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

// expose all the zlib constants
Object.keys(binding).forEach(function(k) {
  if (k.match(/^Z/)) exports[k] = binding[k];
});

// translation table for return codes.
exports.codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

Object.keys(exports.codes).forEach(function(k) {
  exports.codes[exports.codes[k]] = k;
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function(o) {
  return new Deflate(o);
};

exports.createInflate = function(o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function(o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function(o) {
  return new InflateRaw(o);
};

exports.createGzip = function(o) {
  return new Gzip(o);
};

exports.createGunzip = function(o) {
  return new Gunzip(o);
};

exports.createUnzip = function(o) {
  return new Unzip(o);
};


// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;

  engine.on('error', onError);
  engine.on('end', onEnd);

  engine.end(buffer);
  flow();

  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf = Buffer.concat(buffers, nread);
    buffers = [];
    callback(null, buf);
    engine.close();
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string')
    buffer = new Buffer(buffer);
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('Not a string or buffer');

  var flushFlag = binding.Z_FINISH;

  return engine._processChunk(buffer, flushFlag);
}

// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}



// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}



// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}


// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}


// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.

function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush) {
    if (opts.flush !== binding.Z_NO_FLUSH &&
        opts.flush !== binding.Z_PARTIAL_FLUSH &&
        opts.flush !== binding.Z_SYNC_FLUSH &&
        opts.flush !== binding.Z_FULL_FLUSH &&
        opts.flush !== binding.Z_FINISH &&
        opts.flush !== binding.Z_BLOCK) {
      throw new Error('Invalid flush flag: ' + opts.flush);
    }
  }
  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
        opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL ||
        opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &&
        opts.strategy != exports.Z_HUFFMAN_ONLY &&
        opts.strategy != exports.Z_RLE &&
        opts.strategy != exports.Z_FIXED &&
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._binding = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._binding.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    self._binding = null;
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                     level,
                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                     strategy,
                     opts.dictionary);

  this._buffer = new Buffer(this._chunkSize);
  this._offset = 0;
  this._closed = false;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function(level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL ||
      level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED &&
      strategy != exports.Z_HUFFMAN_ONLY &&
      strategy != exports.Z_RLE &&
      strategy != exports.Z_FIXED &&
      strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function() {
      self._binding.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function() {
  return this._binding.reset();
};

// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function(callback) {
  this._transform(new Buffer(0), '', callback);
};

Zlib.prototype.flush = function(kind, callback) {
  var ws = this._writableState;

  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback)
      process.nextTick(callback);
  } else if (ws.ending) {
    if (callback)
      this.once('end', callback);
  } else if (ws.needDrain) {
    var self = this;
    this.once('drain', function() {
      self.flush(callback);
    });
  } else {
    this._flushFlag = kind;
    this.write(new Buffer(0), '', callback);
  }
};

Zlib.prototype.close = function(callback) {
  if (callback)
    process.nextTick(callback);

  if (this._closed)
    return;

  this._closed = true;

  this._binding.close();

  var self = this;
  process.nextTick(function() {
    self.emit('close');
  });
};

Zlib.prototype._transform = function(chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);

  if (!chunk === null && !Buffer.isBuffer(chunk))
    return cb(new Error('invalid input'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last)
    flushFlag = binding.Z_FINISH;
  else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  var self = this;
  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function(er) {
      error = er;
    });

    do {
      var res = this._binding.writeSync(flushFlag,
                                        chunk, // in
                                        inOff, // in_off
                                        availInBefore, // in_len
                                        this._buffer, // out
                                        this._offset, //out_off
                                        availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    var buf = Buffer.concat(buffers, nread);
    this.close();

    return buf;
  }

  var req = this._binding.write(flushFlag,
                                chunk, // in
                                inOff, // in_off
                                availInBefore, // in_len
                                this._buffer, // out
                                this._offset, //out_off
                                availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    if (self._hadError)
      return;

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = new Buffer(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      if (!async)
        return true;

      var newReq = self._binding.write(flushFlag,
                                       chunk,
                                       inOff,
                                       availInBefore,
                                       self._buffer,
                                       self._offset,
                                       self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async)
      return false;

    // finished with the chunk.
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);

}).call(this,require('_process'),require("buffer").Buffer)

},{"./binding":17,"_process":68,"_stream_transform":79,"assert":3,"buffer":20,"util":86}],19:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":20}],20:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":4,"ieee754":27,"isarray":21}],21:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],22:[function(require,module,exports){
'use strict';

// VARIABLES //

var FLOAT32_VIEW = new Float32Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT32_VIEW.buffer );

// 1 11111111 00000000000000000000000 => 4286578688 => 0xff800000 (see IEEE 754-2008)
var NINF = 0xff800000;

// Set the ArrayBuffer bit sequence:
UINT32_VIEW[ 0 ] = NINF;


// EXPORTS //

module.exports = FLOAT32_VIEW[ 0 ];

},{}],23:[function(require,module,exports){
'use strict';

// VARIABLES //

var FLOAT32_VIEW = new Float32Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT32_VIEW.buffer );

// 0 11111111 00000000000000000000000 => 2139095040 => 0x7f800000 (see IEEE 754-2008)
var PINF = 0x7f800000;

// Set the ArrayBuffer bit sequence:
UINT32_VIEW[ 0 ] = PINF;


// EXPORTS //

module.exports = FLOAT32_VIEW[ 0 ];

},{}],24:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":29}],25:[function(require,module,exports){
(function (Buffer){
/*! dicom-parser - v1.7.3 - 2016-08-18 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */
(function (root, factory) {

    // node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else {
        // Browser globals
        if(typeof cornerstone === 'undefined'){
            dicomParser = {};

            // meteor
            if (typeof Package !== 'undefined') {
                root.dicomParser = dicomParser;
            }
        }
        dicomParser = factory();
    }
}(this, function () {

/**
 * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options
 * argument is supplied and it contains the untilTag property, parsing will stop once that
 * tag is encoutered.  This can be used to parse partial byte streams.
 *
 * @param byteArray the byte array
 * @param options object to control parsing behavior (optional)
 * @returns {DataSet}
 * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the
 *         elements successfully parsed before the error.
 */
var dicomParser = (function(dicomParser) {
    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.parseDicom = function(byteArray, options) {

        if(byteArray === undefined)
        {
            throw "dicomParser.parseDicom: missing required parameter 'byteArray'";
        }

        function readTransferSyntax(metaHeaderDataSet) {
            if(metaHeaderDataSet.elements.x00020010 === undefined) {
                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';
            }
            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;
            return dicomParser.readFixedString(byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);
        }

        function isExplicit(transferSyntax) {
            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian
            {
                return false;
            }
            // all other transfer syntaxes should be explicit
            return true;
        }

        function getDataSetByteStream(transferSyntax, position) {
            if(transferSyntax === '1.2.840.10008.1.2.1.99')
            {
                // if an infalter callback is registered, use it
                if (options && options.inflater) {
                    var fullByteArrayCallback = options.inflater(byteArray, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArrayCallback, 0);
                }
                // if running on node, use the zlib library to inflate
                // http://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js
                else if (typeof module !== 'undefined' && this.module !== module) {
                    // inflate it
                    var zlib = require('zlib');
                    var deflatedBuffer = dicomParser.sharedCopy(byteArray, position, byteArray.length - position);
                    var inflatedBuffer = zlib.inflateRawSync(deflatedBuffer);

                    // create a single byte array with the full header bytes and the inflated bytes
                    var fullByteArrayBuffer = dicomParser.alloc(byteArray, inflatedBuffer.length + position);
                    byteArray.copy(fullByteArrayBuffer, 0, 0, position);
                    inflatedBuffer.copy(fullByteArrayBuffer, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArrayBuffer, 0);
                }
                // if pako is defined - use it.  This is the web browser path
                // https://github.com/nodeca/pako
                else if(typeof pako !== "undefined") {
                    // inflate it
                    var deflated = byteArray.slice(position);
                    var inflated = pako.inflateRaw(deflated);

                    // create a single byte array with the full header bytes and the inflated bytes
                    var fullByteArray = dicomParser.alloc(byteArray, inflated.length + position);
                    fullByteArray.set(byteArray.slice(0, position), 0);
                    fullByteArray.set(inflated, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArray, 0);
                }
                // throw exception since no inflater is available
                else {
                    throw 'dicomParser.parseDicom: no inflater available to handle deflate transfer syntax';
                }
            }
            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian
            {
                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, position);
            }
            else
            {
                // all other transfer syntaxes are little endian; only the pixel encoding differs
                // make a new stream so the metaheader warnings don't come along for the ride
                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, position);
            }
        }

        function mergeDataSets(metaHeaderDataSet, instanceDataSet)
        {
            for (var propertyName in metaHeaderDataSet.elements)
            {
                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))
                {
                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];
                }
            }
            if (metaHeaderDataSet.warnings !== undefined) {
                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);
            }
            return instanceDataSet;
        }

        function readDataSet(metaHeaderDataSet)
        {
            var transferSyntax = readTransferSyntax(metaHeaderDataSet);
            var explicit = isExplicit(transferSyntax);
            var dataSetByteStream = getDataSetByteStream(transferSyntax, metaHeaderDataSet.position);

            var elements = {};
            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);
            dataSet.warnings = dataSetByteStream.warnings;

            try{
                if(explicit) {
                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);
                }
                else
                {
                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);
                }
            }
            catch(e) {
                var ex = {
                    exception: e,
                    dataSet: dataSet
                };
                throw ex;
            }
            return dataSet;
        }

        // main function here
        function parseTheByteStream() {
            var metaHeaderDataSet = dicomParser.readPart10Header(byteArray, options);

            var dataSet = readDataSet(metaHeaderDataSet);

            return mergeDataSets(metaHeaderDataSet, dataSet);
        }

        // This is where we actually start parsing
        return parseTheByteStream();
    };

    return dicomParser;
})(dicomParser);

/**
 * Utility function for creating a basic offset table for JPEG transfer syntaxes
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  // Each JPEG image has an end of image marker 0xFFD9
  function isEndOfImageMarker(dataSet, position) {
    return (dataSet.byteArray[position] === 0xFF &&
    dataSet.byteArray[position + 1] === 0xD9);
  }

  function isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex) {
    var fragment = pixelDataElement.fragments[fragmentIndex];
    // Need to check the last two bytes and the last three bytes for marker since odd length
    // fragments are zero padded
    if(isEndOfImageMarker(dataSet, fragment.position + fragment.length - 2) ||
      isEndOfImageMarker(dataSet, fragment.position + fragment.length - 3)) {
      return true;
    }
    return false;
  }

  function findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragment) {
    for(var fragmentIndex=startFragment; fragmentIndex < pixelDataElement.fragments.length; fragmentIndex++) {
      if(isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex)) {
        return fragmentIndex;
      }
    }
  }

  /**
   * Creates a basic offset table by scanning fragments for JPEG start of image and end Of Image markers
   * @param {object} dataSet - the parsed dicom dataset
   * @param {object} pixelDataElement - the pixel data element
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {Array} basic offset table (array of offsets to beginning of each frame)
   */
  dicomParser.createJPEGBasicOffsetTable = function(dataSet, pixelDataElement, fragments) {
    // Validate parameters
    if(dataSet === undefined) {
      throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter dataSet';
    }
    if(pixelDataElement === undefined) {
      throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter pixelDataElement';
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.basicOffsetTable === undefined) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments.length <= 0) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(fragments && fragments.length <=0) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'fragments' must not be zero length";
    }

    // Default values
    fragments = fragments || pixelDataElement.fragments;

    var basicOffsetTable = [];

    var startFragmentIndex = 0;

    while(true) {
      // Add the offset for the start fragment
      basicOffsetTable.push(pixelDataElement.fragments[startFragmentIndex].offset);
      var endFragmentIndex = findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragmentIndex);
      if(endFragmentIndex === undefined || endFragmentIndex === pixelDataElement.fragments.length -1) {
        return basicOffsetTable;
      }
      startFragmentIndex = endFragmentIndex + 1;
    }
  };

  return dicomParser;
}(dicomParser));
var dicomParser = (function (dicomParser) {
    "use strict";

    if (dicomParser === undefined) {
        dicomParser = {};
    }

    /**
     * converts an explicit dataSet to a javascript object
     * @param dataSet
     * @param options
     */
    dicomParser.explicitDataSetToJS = function (dataSet, options) {

        if(dataSet === undefined) {
            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';
        }

        options = options || {
            omitPrivateAttibutes: true, // true if private elements should be omitted
            maxElementLength : 128      // maximum element length to try and convert to string format
        };

        var result = {

        };

        for(var tag in dataSet.elements) {
            var element = dataSet.elements[tag];

            // skip this element if it a private element and our options specify that we should
            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))
            {
                continue;
            }

            if(element.items) {
                // handle sequences
                var sequenceItems = [];
                for(var i=0; i < element.items.length; i++) {
                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));
                }
                result[tag] = sequenceItems;
            } else {
                var asString;
                asString = undefined;
                if(element.length < options.maxElementLength) {
                    asString = dicomParser.explicitElementToString(dataSet, element);
                }

                if(asString !== undefined) {
                    result[tag] = asString;
                }  else {
                    result[tag] = {
                        dataOffset: element.dataOffset,
                        length : element.length
                    };
                }
            }
        }

        return result;
    };


    return dicomParser;
}(dicomParser));
var dicomParser = (function (dicomParser) {
    "use strict";

    if (dicomParser === undefined) {
        dicomParser = {};
    }

    /**
     * Converts an explicit VR element to a string or undefined if it is not possible to convert.
     * Throws an error if an implicit element is supplied
     * @param dataSet
     * @param element
     * @returns {*}
     */
    dicomParser.explicitElementToString = function(dataSet, element)
    {
        if(dataSet === undefined || element === undefined) {
            throw 'dicomParser.explicitElementToString: missing required parameters';
        }
        if(element.vr === undefined) {
            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';
        }
        var vr = element.vr;
        var tag = element.tag;

        var textResult;

        function multiElementToString(numItems, func) {
            var result = "";
            for(var i=0; i < numItems; i++) {
                if(i !== 0) {
                    result += '/';
                }
                result += func.call(dataSet, tag, i).toString();
            }
            return result;
        }

        if(dicomParser.isStringVr(vr) === true)
        {
            textResult = dataSet.string(tag);
        }
        else if (vr == 'AT') {
            var num = dataSet.uint32(tag);
            if(num === undefined) {
                return undefined;
            }
            if (num < 0)
            {
                num = 0xFFFFFFFF + num + 1;
            }

            return 'x' + num.toString(16).toUpperCase();
        }
        else if (vr == 'US')
        {
            textResult = multiElementToString(element.length / 2, dataSet.uint16);
        }
        else if(vr === 'SS')
        {
            textResult = multiElementToString(element.length / 2, dataSet.int16);
        }
        else if (vr == 'UL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.uint32);
        }
        else if(vr === 'SL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.int32);
        }
        else if(vr == 'FD')
        {
            textResult = multiElementToString(element.length / 8, dataSet.double);
        }
        else if(vr == 'FL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.float);
        }

        return textResult;
    };
    return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  // algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month
  function daysInMonth(m, y) { // m is 0 indexed: 0-11
    switch (m) {
      case 2 :
        return (y % 4 == 0 && y % 100) || y % 400 == 0 ? 29 : 28;
      case 9 : case 4 : case 6 : case 11 :
      return 30;
      default :
        return 31
    }
  }

  function isValidDate(d, m, y) {
    // make year is a number
    if(isNaN(y)) {
      return false;
    }
    return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);
  }


  /**
   * Parses a DA formatted string into a Javascript object
   * @param {string} date a string in the DA VR format
   * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
   * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long
   */
  dicomParser.parseDA = function(date, validate)
  {
    if(date && date.length === 8)
    {
      var yyyy = parseInt(date.substring(0, 4), 10);
      var mm = parseInt(date.substring(4, 6), 10);
      var dd = parseInt(date.substring(6, 8), 10);

      if(validate) {
        if (isValidDate(dd, mm, yyyy) !== true) {
          throw "invalid DA '" + date + "'";
        }
      }
      return {
        year: yyyy,
        month: mm,
        day: dd
      };
    }
    if(validate) {
      throw "invalid DA '" + date + "'";
    }
    return undefined;
  };

  return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds
   * @param {string} time - a string in the TM VR format
   * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
   * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined
   */
  dicomParser.parseTM = function(time, validate) {

    if (time.length >= 2) // must at least have HH
    {
      // 0123456789
      // HHMMSS.FFFFFF
      var hh = parseInt(time.substring(0, 2), 10);
      var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;
      var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;
      var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;

      if(validate) {
        if((isNaN(hh)) ||
          (mm !== undefined && isNaN(mm)) ||
          (ss !== undefined && isNaN(ss)) ||
          (ffffff !== undefined && isNaN(ffffff)) ||
          (hh < 0 || hh > 23) ||
          (mm && (mm <0 || mm > 59))  ||
          (ss && (ss <0 || ss > 59))  ||
          (ffffff && (ffffff <0 || ffffff > 999999)))
        {
          throw "invalid TM '" + time + "'";
        }
      }

      return {
        hours: hh,
        minutes: mm,
        seconds: ss,
        fractionalSeconds: ffffff
      };
    }

    if(validate) {
      throw "invalid TM '" + time + "'";
    }

    return undefined;
  };

  return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    var stringVrs = {
        AE: true,
        AS: true,
        AT: false,
        CS: true,
        DA: true,
        DS: true,
        DT: true,
        FL: false,
        FD: false,
        IS: true,
        LO: true,
        LT: true,
        OB: false,
        OD: false,
        OF: false,
        OW: false,
        PN: true,
        SH: true,
        SL: false,
        SQ: false,
        SS: false,
        ST: true,
        TM: true,
        UI: true,
        UL: false,
        UN: undefined, // dunno
        UR: true,
        US: false,
        UT: true
    };

    /**
     * Tests to see if vr is a string or not.
     * @param vr
     * @returns true if string, false it not string, undefined if unknown vr or UN type
     */
    dicomParser.isStringVr = function(vr)
    {
        return stringVrs[vr];
    };

    /**
     * Tests to see if a given tag in the format xggggeeee is a private tag or not
     * @param tag
     * @returns {boolean}
     */
    dicomParser.isPrivateTag = function(tag)
    {
        var lastGroupDigit = parseInt(tag[4]);
        var groupIsOdd = (lastGroupDigit % 2) === 1;
        return groupIsOdd;
    };

    /**
     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix
     * @param personName a string in the PN VR format
     * @param index
     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data
     */
    dicomParser.parsePN = function(personName) {
        if(personName === undefined) {
            return undefined;
        }
        var stringValues = personName.split('^');
        return {
            familyName: stringValues[0],
            givenName: stringValues[1],
            middleName: stringValues[2],
            prefix: stringValues[3],
            suffix: stringValues[4]
        };
    };



    return dicomParser;
}(dicomParser));
/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    var deprecatedNoticeLogged = false;

    /**
     * Returns the pixel data for the specified frame in an encapsulated pixel data element.  If no basic offset
     * table is present, it assumes that all fragments are for one frame.  Note that this assumption/logic is not
     * valid for multi-frame instances so this function has been deprecated and will eventually be removed.  Code
     * should be updated to use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()
     *
     * @deprecated since version 1.6 - use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()
     * @param dataSet - the dataSet containing the encapsulated pixel data
     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from
     * @param frame - the zero based frame index
     * @returns {object} with the encapsulated pixel data
     */


    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)
    {
        if(!deprecatedNoticeLogged) {
            deprecatedNoticeLogged = true;
            if(console && console.log) {
                console.log("WARNING: dicomParser.readEncapsulatedPixelData() has been deprecated");
            }
        }

        if(dataSet === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'";
        }
        if(pixelDataElement === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'element'";
        }
        if(frame === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'";
        }
        if(pixelDataElement.tag !== 'x7fe00010') {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'";
        }
        if(pixelDataElement.encapsulatedPixelData !== true) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.hadUndefinedLength !== true) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.basicOffsetTable === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.fragments === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(frame < 0) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0";
        }

        // If the basic offset table is not empty, we can extract the frame
        if(pixelDataElement.basicOffsetTable.length !== 0)
        {
            return dicomParser.readEncapsulatedImageFrame(dataSet, pixelDataElement, frame);
        }
        else
        {
            // No basic offset table, assume all fragments are for one frame - NOTE that this is NOT a valid
            // assumption but is the original behavior so we are keeping it for now
            return dicomParser.readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, 0, pixelDataElement.fragments.length);
        }
    };

    return dicomParser;
}(dicomParser));

/**
 *
 * Internal helper function to allocate new byteArray buffers
 */
var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Creates a new byteArray of the same type (Uint8Array or Buffer) of the specified length.
   * @param byteArray the underlying byteArray (either Uint8Array or Buffer)
   * @param length number of bytes of the Byte Array
   * @returns {object} Uint8Array or Buffer depending on the type of byteArray
   */
  dicomParser.alloc = function(byteArray, length) {
    if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {
      return Buffer.alloc(length);
    }
    else if(byteArray instanceof Uint8Array) {
      return new Uint8Array(length);
    } else {
      throw 'dicomParser.alloc: unknown type for byteArray';
    }
  };

  return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing different types from a big-endian byte array
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.bigEndianByteArrayParser = {
        /**
         *
         * Parses an unsigned int 16 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint16: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';
            }
            return (byteArray[position] << 8) + byteArray[position + 1];
        },

        /**
         *
         * Parses a signed int 16 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt16: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';
            }
            var int16 = (byteArray[position] << 8) + byteArray[position + 1];
            // fix sign
            if (int16 & 0x8000) {
                int16 = int16 - 0xFFFF - 1;
            }
            return int16;
        },

        /**
         * Parses an unsigned int 32 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint32: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';
            }

            var uint32 = (256 * (256 * (256 * byteArray[position] +
                                              byteArray[position + 1]) +
                                              byteArray[position + 2]) +
                                              byteArray[position + 3]);

            return uint32;
        },

        /**
         * Parses a signed int 32 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt32: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';
            }

            var int32 = ((byteArray[position] << 24) +
                         (byteArray[position + 1] << 16) +
                         (byteArray[position + 2] << 8) +
                          byteArray[position + 3]);

            return int32;
        },

        /**
         * Parses 32-bit float from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 32-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readFloat: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(4);
            byteArrayForParsingFloat[3] = byteArray[position];
            byteArrayForParsingFloat[2] = byteArray[position + 1];
            byteArrayForParsingFloat[1] = byteArray[position + 2];
            byteArrayForParsingFloat[0] = byteArray[position + 3];
            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        },

        /**
         * Parses 64-bit float from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 64-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readDouble: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';
            }

            if (position + 8 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(8);
            byteArrayForParsingFloat[7] = byteArray[position];
            byteArrayForParsingFloat[6] = byteArray[position + 1];
            byteArrayForParsingFloat[5] = byteArray[position + 2];
            byteArrayForParsingFloat[4] = byteArray[position + 3];
            byteArrayForParsingFloat[3] = byteArray[position + 4];
            byteArrayForParsingFloat[2] = byteArray[position + 5];
            byteArrayForParsingFloat[1] = byteArray[position + 6];
            byteArrayForParsingFloat[0] = byteArray[position + 7];
            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions common to parsing byte arrays of any type
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads a string of 8-bit characters from an array of bytes and advances
     * the position by length bytes.  A null terminator will end the string
     * but will not effect advancement of the position.  Trailing and leading
     * spaces are preserved (not trimmed)
     * @param byteArray the byteArray to read from
     * @param position the position in the byte array to read from
     * @param length the maximum number of bytes to parse
     * @returns {string} the parsed string
     * @throws error if buffer overread would occur
     * @access private
     */
    dicomParser.readFixedString = function(byteArray, position, length)
    {
        if(length < 0)
        {
            throw 'dicomParser.readFixedString - length cannot be less than 0';
        }

        if(position + length > byteArray.length) {
            throw 'dicomParser.readFixedString: attempt to read past end of buffer';
        }

        var result = "";
        var byte;
        for(var i=0; i < length; i++)
        {
            byte = byteArray[position + i];
            if(byte === 0) {
                position +=  length;
                return result;
            }
            result += String.fromCharCode(byte);
        }

        return result;
    };


    return dicomParser;
}(dicomParser));
/**
 *
 * Internal helper class to assist with parsing. Supports reading from a byte
 * stream contained in a Uint8Array.  Example usage:
 *
 *  var byteArray = new Uint8Array(32);
 *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);
 *
 * */
var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Constructor for ByteStream objects.
     * @param byteArrayParser a parser for parsing the byte array
     * @param byteArray a Uint8Array containing the byte stream
     * @param position (optional) the position to start reading from.  0 if not specified
     * @constructor
     * @throws will throw an error if the byteArrayParser parameter is not present
     * @throws will throw an error if the byteArray parameter is not present or invalid
     * @throws will throw an error if the position parameter is not inside the byte array
     */
    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {
        if(byteArrayParser === undefined)
        {
            throw "dicomParser.ByteStream: missing required parameter 'byteArrayParser'";
        }
        if(byteArray === undefined)
        {
            throw "dicomParser.ByteStream: missing required parameter 'byteArray'";
        }
        if((byteArray instanceof Uint8Array) === false &&
          (byteArray instanceof Buffer) === false ) {
            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array or Buffer';
        }
        if(position < 0)
        {
            throw "dicomParser.ByteStream: parameter 'position' cannot be less than 0";
        }
        if(position >= byteArray.length)
        {
            throw "dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length";

        }
        this.byteArrayParser = byteArrayParser;
        this.byteArray = byteArray;
        this.position = position ? position : 0;
        this.warnings = []; // array of string warnings encountered while parsing
    };

    /**
     * Safely seeks through the byte stream.  Will throw an exception if an attempt
     * is made to seek outside of the byte array.
     * @param offset the number of bytes to add to the position
     * @throws error if seek would cause position to be outside of the byteArray
     */
    dicomParser.ByteStream.prototype.seek = function(offset)
    {
        if(this.position + offset < 0)
        {
            throw "dicomParser.ByteStream.prototype.seek: cannot seek to position < 0";
        }
        this.position += offset;
    };

    /**
     * Returns a new ByteStream object from the current position and of the requested number of bytes
     * @param numBytes the length of the byte array for the ByteStream to contain
     * @returns {dicomParser.ByteStream}
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)
    {
        if(this.position + numBytes > this.byteArray.length) {
            throw 'dicomParser.ByteStream.prototype.readByteStream: readByteStream - buffer overread';
        }
        var byteArrayView = dicomParser.sharedCopy(this.byteArray, this.position, numBytes);
        this.position += numBytes;
        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);
    };

    /**
     *
     * Parses an unsigned int 16 from a byte array and advances
     * the position by 2 bytes
     *
     * @returns {*} the parsed unsigned int 16
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readUint16 = function()
    {
        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);
        this.position += 2;
        return result;
    };

    /**
     * Parses an unsigned int 32 from a byte array and advances
     * the position by 2 bytes
     *
     * @returns {*} the parse unsigned int 32
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readUint32 = function()
    {
        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);
        this.position += 4;
        return result;
    };

    /**
     * Reads a string of 8-bit characters from an array of bytes and advances
     * the position by length bytes.  A null terminator will end the string
     * but will not effect advancement of the position.
     * @param length the maximum number of bytes to parse
     * @returns {string} the parsed string
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readFixedString = function(length)
    {
        var result = dicomParser.readFixedString(this.byteArray, this.position, length);
        this.position += length;
        return result;
    };

    return dicomParser;
}(dicomParser));
/**
 *
 * The DataSet class encapsulates a collection of DICOM Elements and provides various functions
 * to access the data in those elements
 *
 * Rules for handling padded spaces:
 * DS = Strip leading and trailing spaces
 * DT = Strip trailing spaces
 * IS = Strip leading and trailing spaces
 * PN = Strip trailing spaces
 * TM = Strip trailing spaces
 * AE = Strip leading and trailing spaces
 * CS = Strip leading and trailing spaces
 * SH = Strip leading and trailing spaces
 * LO = Strip leading and trailing spaces
 * LT = Strip trailing spaces
 * ST = Strip trailing spaces
 * UT = Strip trailing spaces
 *
 */
var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function getByteArrayParser(element, defaultParser)
    {
        return (element.parser !== undefined ? element.parser : defaultParser);
    }

    /**
     * Constructs a new DataSet given byteArray and collection of elements
     * @param byteArrayParser
     * @param byteArray
     * @param elements
     * @constructor
     */
    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)
    {
        this.byteArrayParser = byteArrayParser;
        this.byteArray = byteArray;
        this.elements = elements;
    };

    /**
     * Finds the element for tag and returns an unsigned int 16 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.uint16 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an signed int 16 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.int16 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an unsigned int 32 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.uint32 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an signed int 32 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.int32 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} float or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.float = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0
     */
    dicomParser.DataSet.prototype.double = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));
        }
        return undefined;
    };

    /**
     * Returns the number of string values for the element
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data
     */
    dicomParser.DataSet.prototype.numStringValues = function(tag)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            var numMatching = fixedString.match(/\\/g);
            if(numMatching === null)
            {
                return 1;
            }
            return numMatching.length + 1;
        }
        return undefined;
    };

    /**
     * Returns a string for the element.  If index is provided, the element is assumed to be
     * multi-valued and will return the component specified by index.  Undefined is returned
     * if there is no component with the specified index, the element does not exist or is zero length.
     *
     * Use this function for VR types of AE, CS, SH and LO
     *
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the entire string
     * @returns {*}
     */
    dicomParser.DataSet.prototype.string = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            if(index >= 0)
            {
                var values = fixedString.split('\\');
                // trim trailing spaces
                return values[index].trim();
            }
            else
            {
                // trim trailing spaces
                return fixedString.trim();
            }
        }
        return undefined;
    };

    /**
     * Returns a string with the leading spaces preserved and trailing spaces removed.
     *
     * Use this function to access data for VRs of type UT, ST and LT
     *
     * @param tag
     * @param index
     * @returns {*}
     */
    dicomParser.DataSet.prototype.text = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            if(index >= 0)
            {
                var values = fixedString.split('\\');
                return values[index].replace(/ +$/, '');
            }
            else
            {
                return fixedString.replace(/ +$/, '');
            }
        }
        return undefined;
    };

    /**
     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,
     * the first value in a multi-valued VR will be parsed if present.
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the first value
     * @returns {*} a floating point number or undefined if not present or data not long enough
     */
    dicomParser.DataSet.prototype.floatString = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            index = (index !== undefined) ? index : 0;
            var value = this.string(tag, index);
            if(value !== undefined) {
                return parseFloat(value);
            }
        }
        return undefined;
    };

    /**
     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,
     * the first value in a multi-valued VR will be parsed if present.
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the first value
     * @returns {*} an integer or undefined if not present or data not long enough
     */
    dicomParser.DataSet.prototype.intString = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0) {
            index = (index !== undefined) ? index : 0;
            var value = this.string(tag, index);
            if(value !== undefined) {
                return parseInt(value);
            }
        }
        return undefined;
    };

    //dicomParser.DataSet = DataSet;

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * reads from the byte stream until it finds the magic number for the Sequence Delimitation Item item
   * and then sets the length of the element
   * @param byteStream
   * @param element
   */
  dicomParser.findAndSetUNElementLength = function(byteStream, element)
  {
    if(byteStream === undefined)
    {
      throw "dicomParser.findAndSetUNElementLength: missing required parameter 'byteStream'";
    }

    var itemDelimitationItemLength = 8; // group, element, length
    var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;
    while(byteStream.position <= maxPosition)
    {
      var groupNumber;
      groupNumber = byteStream.readUint16();
      if(groupNumber === 0xfffe)
      {
        var elementNumber;
        elementNumber = byteStream.readUint16();
        if(elementNumber === 0xe0dd)
        {
          // NOTE: It would be better to also check for the length to be 0 as part of the check above
          // but we will just log a warning for now
          var itemDelimiterLength;
          itemDelimiterLength = byteStream.readUint32(); // the length
          if(itemDelimiterLength !== 0) {
            byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + " while reading element of undefined length with tag ' + element.tag");
          }
          element.length = byteStream.position - element.dataOffset;
          return;
        }
      }
    }

    // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer
    element.length = byteStream.byteArray.length - element.dataOffset;
    byteStream.seek(byteStream.byteArray.length - byteStream.position);
  };


  return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads an encapsulated pixel data element and adds an array of fragments to the element
     * containing the offset and length of each fragment and any offsets from the basic offset
     * table
     * @param byteStream
     * @param element
     */
    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'";
        }

        element.encapsulatedPixelData = true;
        element.basicOffsetTable = [];
        element.fragments = [];
        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);
        if(basicOffsetTableItemTag !== 'xfffee000') {
            throw "dicomParser.findEndOfEncapsulatedElement: basic offset table not found";
        }
        var basicOffsetTableItemlength = byteStream.readUint32();
        var numFragments = basicOffsetTableItemlength / 4;
        for(var i =0; i < numFragments; i++) {
            var offset = byteStream.readUint32();
            element.basicOffsetTable.push(offset);
        }
        var baseOffset = byteStream.position;

        while(byteStream.position < byteStream.byteArray.length)
        {
            var tag = dicomParser.readTag(byteStream);
            var length = byteStream.readUint32();
            if(tag === 'xfffee0dd')
            {
                byteStream.seek(length);
                element.length = byteStream.position - element.dataOffset;
                return;
            }
            else if(tag === 'xfffee000')
            {
                element.fragments.push({
                    offset: byteStream.position - baseOffset - 8,
                    position : byteStream.position,
                    length : length
                });
            }
            else {
                if(warnings) {
                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');
                }
                if(length > byteStream.byteArray.length - byteStream.position)
                {
                    // fix length
                    length = byteStream.byteArray.length - byteStream.position;
                }
                element.fragments.push({
                    offset: byteStream.position - baseOffset - 8,
                    position : byteStream.position,
                    length : length
                });
                byteStream.seek(length);
                element.length = byteStream.position - element.dataOffset;
                return;
            }

            byteStream.seek(length);
        }

        if(warnings) {
            warnings.push("pixel data element " + element.tag + " missing sequence delimiter tag xfffee0dd");
        }
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * reads from the byte stream until it finds the magic numbers for the item delimitation item
     * and then sets the length of the element
     * @param byteStream
     * @param element
     */
    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
        }

        var itemDelimitationItemLength = 8; // group, element, length
        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;
        while(byteStream.position <= maxPosition)
        {
            var groupNumber = byteStream.readUint16();
            if(groupNumber === 0xfffe)
            {
                var elementNumber = byteStream.readUint16();
                if(elementNumber === 0xe00d)
                {
                    // NOTE: It would be better to also check for the length to be 0 as part of the check above
                    // but we will just log a warning for now
                    var itemDelimiterLength = byteStream.readUint32(); // the length
                    if(itemDelimiterLength !== 0) {
                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + " while reading element of undefined length with tag ' + element.tag");
                    }
                    element.length = byteStream.position - element.dataOffset;
                    return;
                }
            }
        }

        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer
        element.length = byteStream.byteArray.length - element.dataOffset;
        byteStream.seek(byteStream.byteArray.length - byteStream.position);
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing different types from a little-endian byte array
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.littleEndianByteArrayParser = {
        /**
         *
         * Parses an unsigned int 16 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint16: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';
            }
            return byteArray[position] + (byteArray[position + 1] * 256);
        },

        /**
         *
         * Parses a signed int 16 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt16: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';
            }
            var int16 = byteArray[position] + (byteArray[position + 1] << 8);
            // fix sign
            if (int16 & 0x8000) {
                int16 = int16 - 0xFFFF - 1;
            }
            return int16;
        },


        /**
         * Parses an unsigned int 32 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint32: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';
            }

            var uint32 = (byteArray[position] +
            (byteArray[position + 1] * 256) +
            (byteArray[position + 2] * 256 * 256) +
            (byteArray[position + 3] * 256 * 256 * 256 ));

            return uint32;
        },

        /**
         * Parses a signed int 32 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt32: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';
            }

            var int32 = (byteArray[position] +
            (byteArray[position + 1] << 8) +
            (byteArray[position + 2] << 16) +
            (byteArray[position + 3] << 24));

            return int32;

        },

        /**
         * Parses 32-bit float from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 32-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readFloat: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(4);
            byteArrayForParsingFloat[0] = byteArray[position];
            byteArrayForParsingFloat[1] = byteArray[position + 1];
            byteArrayForParsingFloat[2] = byteArray[position + 2];
            byteArrayForParsingFloat[3] = byteArray[position + 3];
            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        },

        /**
         * Parses 64-bit float from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 64-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readDouble: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';
            }

            if (position + 8 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(8);
            byteArrayForParsingFloat[0] = byteArray[position];
            byteArrayForParsingFloat[1] = byteArray[position + 1];
            byteArrayForParsingFloat[2] = byteArray[position + 2];
            byteArrayForParsingFloat[3] = byteArray[position + 3];
            byteArrayForParsingFloat[4] = byteArray[position + 4];
            byteArrayForParsingFloat[5] = byteArray[position + 5];
            byteArrayForParsingFloat[6] = byteArray[position + 6];
            byteArrayForParsingFloat[7] = byteArray[position + 7];
            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing implicit and explicit DICOM data sets
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * reads an explicit data set
     * @param byteStream the byte stream to read from
     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)
     */
    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {

        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;
        options = options || {};

        if(byteStream === undefined)
        {
            throw "dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'";
        }
        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)
        {
            throw "dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'";
        }
        var elements = dataSet.elements;

        while(byteStream.position < maxPosition)
        {
            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);
            elements[element.tag] = element;
            if(element.tag === options.untilTag) {
                return;
            }
        }
        if(byteStream.position > maxPosition) {
            throw "dicomParser:parseDicomDataSetExplicit: buffer overrun";
        }
    };

    /**
     * reads an implicit data set
     * @param byteStream the byte stream to read from
     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)
     */
    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)
    {
        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;
        options = options || {};

        if(byteStream === undefined)
        {
            throw "dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'";
        }
        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)
        {
            throw "dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'";
        }

        var elements = dataSet.elements;

        while(byteStream.position < maxPosition)
        {
            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag, options.vrCallback);
            elements[element.tag] = element;
            if(element.tag === options.untilTag) {
                return;
            }
        }
    };

    return dicomParser;
}(dicomParser));

/**
 * Internal helper functions for for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function getDataLengthSizeInBytesForVR(vr)
    {
        if( vr === 'OB' ||
            vr === 'OW' ||
            vr === 'SQ' ||
            vr === 'OF' ||
            vr === 'UT' ||
            vr === 'UN')
        {
            return 4;
        }
        else
        {
            return 2;
        }
    }

    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            vr : byteStream.readFixedString(2)
            // length set below based on VR
            // dataOffset set below based on VR and size of length
        };

        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);
        if(dataLengthSizeBytes === 2)
        {
            element.length = byteStream.readUint16();
            element.dataOffset = byteStream.position;
        }
        else
        {
            byteStream.seek(2);
            element.length = byteStream.readUint32();
            element.dataOffset = byteStream.position;
        }

        if(element.length === 4294967295)
        {
            element.hadUndefinedLength = true;
        }

        if(element.tag === untilTag) {
            return element;
        }

        // if VR is SQ, parse the sequence items
        if(element.vr === 'SQ')
        {
            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);
            return element;
        }


        if(element.length === 4294967295)
        {
            if(element.tag === 'x7fe00010') {
                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);
                return element;
            }   else if(element.vr === 'UN') {
                dicomParser.findAndSetUNElementLength(byteStream, element);
                return element;
            } else {
                dicomParser.readSequenceItemsImplicit(byteStream, element);
                //dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);
                return element;
            }
        }

        byteStream.seek(element.length);
        return element;
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function isSequence(element, byteStream, vrCallback) {
        // if a data dictionary callback was provided, use that to verify that the element is a sequence.
        if (typeof vrCallback !== 'undefined') {
            return (vrCallback(element.tag) === 'SQ');
        }
        if ((byteStream.position + 4) <= byteStream.byteArray.length) {
            var nextTag = dicomParser.readTag(byteStream);
            byteStream.seek(-4);
            // Item start tag (fffe,e000) or sequence delimiter (i.e. end of sequence) tag (0fffe,e0dd)
            // These are the tags that could potentially be found directly after a sequence start tag (the delimiter
            // is found in the case of an empty sequence). This is not 100% safe because a non-sequence item
            // could have data that has these bytes, but this is how to do it without a data dictionary.
            return (nextTag === 'xfffee000') || (nextTag === 'xfffee0dd');
        }
        byteStream.warnings.push('eof encountered before finding sequence item tag or sequence delimiter tag in peeking to determine VR');
        return false;
    }

    dicomParser.readDicomElementImplicit = function(byteStream, untilTag, vrCallback)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            length: byteStream.readUint32(),
            dataOffset :  byteStream.position
        };

        if(element.length === 4294967295) {
            element.hadUndefinedLength = true;
        }

        if(element.tag === untilTag) {
            return element;
        }

        if (isSequence(element, byteStream, vrCallback)) {
            // parse the sequence
            dicomParser.readSequenceItemsImplicit(byteStream, element);
            return element;
        }

        // if element is not a sequence and has undefined length, we have to
        // scan the data for a magic number to figure out when it ends.
        if(element.hadUndefinedLength)
        {
            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);
            return element;
        }

        // non sequence element with known length, skip over the data part
        byteStream.seek(element.length);
        return element;
    };


    return dicomParser;
}(dicomParser));
/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  function findFragmentIndexWithOffset(fragments, offset) {
    for(var i=0; i < fragments.length; i++) {
      if(fragments[i].offset === offset) {
        return i;
      }
    }
  }

  function calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex) {
    // special case for last frame
    if(frameIndex === basicOffsetTable.length -1) {
      return fragments.length - startFragmentIndex;
    }

    // iterate through each fragment looking for the one matching the offset for the next frame
    var nextFrameOffset = basicOffsetTable[frameIndex + 1];
    for(var i=startFragmentIndex + 1; i < fragments.length; i++) {
      if(fragments[i].offset === nextFrameOffset) {
        return i - startFragmentIndex;
      }
    }

    throw "dicomParser.calculateNumberOfFragmentsForFrame: could not find fragment with offset matching basic offset table";
  }

  /**
   * Returns the pixel data for the specified frame in an encapsulated pixel data element that has a non
   * empty basic offset table.  Note that this function will fail if the basic offset table is empty - in that
   * case you need to determine which fragments map to which frames and read them using
   * readEncapsulatedPixelDataFromFragments().  Also see the function createJEPGBasicOffsetTable() to see
   * how a basic offset table can be created for JPEG images
   *
   * @param dataSet - the dataSet containing the encapsulated pixel data
   * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from
   * @param frameIndex - the zero based frame index
   * @param [basicOffsetTable] - optional array of starting offsets for frames
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {object} with the encapsulated pixel data
   */
  dicomParser.readEncapsulatedImageFrame = function(dataSet, pixelDataElement, frameIndex, basicOffsetTable, fragments)
  {
    // default parameters
    basicOffsetTable = basicOffsetTable || pixelDataElement.basicOffsetTable;
    fragments = fragments || pixelDataElement.fragments;

    // Validate parameters
    if(dataSet === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'dataSet'";
    }
    if(pixelDataElement === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'pixelDataElement'";
    }
    if(frameIndex === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'frameIndex'";
    }
    if(basicOffsetTable === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' does not have basicOffsetTable";
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have undefined length";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have fragments";
    }
    if(basicOffsetTable.length === 0) {
      throw "dicomParser.readEncapsulatedImageFrame: basicOffsetTable has zero entries";
    }
    if(frameIndex < 0) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be >= 0";
    }
    if(frameIndex >= basicOffsetTable.length) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be < basicOffsetTable.length";
    }

    // find starting fragment based on the offset for the frame in the basic offset table
    var offset = basicOffsetTable[frameIndex];
    var startFragmentIndex = findFragmentIndexWithOffset(fragments, offset);
    if(startFragmentIndex === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: unable to find fragment that matches basic offset table entry";
    }

    // calculate the number of fragments for this frame
    var numFragments = calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex);

    // now extract the frame from the fragments
    return dicomParser.readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments);
  };

  return dicomParser;
}(dicomParser));

/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  function calculateBufferSize(fragments, startFragment, numFragments) {
    var bufferSize = 0;
    for(var i=startFragment; i < startFragment + numFragments; i++) {
      bufferSize += fragments[i].length;
    }
    return bufferSize;
  }

  /**
   * Returns the encapsulated pixel data from the specified fragments.  Use this function when you know
   * the fragments you want to extract data from.  See
   *
   * @param dataSet - the dataSet containing the encapsulated pixel data
   * @param pixelDataElement - the pixel data element (x7fe00010) to extract the fragment data from
   * @param startFragmentIndex - zero based index of the first fragment to extract from
   * @param [numFragments] - the number of fragments to extract from, default is 1
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {object} byte array with the encapsulated pixel data
   */
  dicomParser.readEncapsulatedPixelDataFromFragments = function(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments)
  {
    // default values
    numFragments = numFragments || 1;
    fragments = fragments || pixelDataElement.fragments;

    // check parameters
    if(dataSet === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'dataSet'";
    }
    if(pixelDataElement === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'pixelDataElement'";
    }
    if(startFragmentIndex === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'startFragmentIndex'";
    }
    if(numFragments === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'numFragments'";
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.basicOffsetTable === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments.length <= 0) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(startFragmentIndex < 0) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be >= 0";
    }
    if(startFragmentIndex >= pixelDataElement.fragments.length) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be < number of fragments";
    }
    if(numFragments < 1) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'numFragments' must be > 0";
    }
    if(startFragmentIndex + numFragments > pixelDataElement.fragments.length) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragment' + 'numFragments' < number of fragments";
    }

    // create byte stream on the data for this pixel data element
    var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);

    // seek past the basic offset table (no need to parse it again since we already have)
    var basicOffsetTable = dicomParser.readSequenceItem(byteStream);
    if(basicOffsetTable.tag !== 'xfffee000')
    {
      throw "dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000";
    }
    byteStream.seek(basicOffsetTable.length);

    var fragmentZeroPosition = byteStream.position;
    var fragmentHeaderSize = 8; // tag + length

    // if there is only one fragment, return a view on this array to avoid copying
    if(numFragments === 1) {
      return dicomParser.sharedCopy(byteStream.byteArray, fragmentZeroPosition + fragments[startFragmentIndex].offset + fragmentHeaderSize, fragments[startFragmentIndex].length);
    }

    // more than one fragment, combine all of the fragments into one buffer
    var bufferSize = calculateBufferSize(fragments, startFragmentIndex, numFragments);

    var pixelData = dicomParser.alloc(byteStream.byteArray, bufferSize);

    var pixelDataIndex = 0;
    for(var i=startFragmentIndex; i < startFragmentIndex + numFragments; i++) {
      var fragmentOffset = fragmentZeroPosition + fragments[i].offset + fragmentHeaderSize;
      for(var j=0; j < fragments[i].length; j++) {
        pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];
      }
    }

    return pixelData;
  };

  return dicomParser;
}(dicomParser));

/**
 * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options
 * argument is supplied and it contains the untilTag property, parsing will stop once that
 * tag is encoutered.  This can be used to parse partial byte streams.
 *
 * @param byteArray the byte array
 * @param options object to control parsing behavior (optional)
 * @returns {DataSet}
 * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the
 *         elements successfully parsed before the error.
 */
var dicomParser = (function(dicomParser) {
  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  dicomParser.readPart10Header = function(byteArray, options) {

    if(byteArray === undefined)
    {
      throw "dicomParser.readPart10Header: missing required parameter 'byteArray'";
    }

    var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);

    function readPrefix()
    {
      littleEndianByteStream.seek(128);
      var prefix = littleEndianByteStream.readFixedString(4);
      if(prefix !== "DICM")
      {
        throw "dicomParser.readPart10Header: DICM prefix not found at location 132 - this is not a valid DICOM P10 file.";
      }
    }

    // main function here
    function readTheHeader() {
      // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)
      // so use littleEndianByteStream throughout this method regardless of the transfer syntax
      readPrefix();

      var warnings = [];
      var elements = {};
      while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {
        var position = littleEndianByteStream.position;
        var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);
        if(element.tag > 'x0002ffff') {
          littleEndianByteStream.position = position;
          break;
        }
        // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian
        // and this parser will be needed later if the meta header values are to be read.
        element.parser = dicomParser.littleEndianByteArrayParser;
        elements[element.tag] = element;
      }
      var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);
      metaHeaderDataSet.warnings = littleEndianByteStream.warnings;
      metaHeaderDataSet.position = littleEndianByteStream.position;
      return metaHeaderDataSet;
    }

    // This is where we actually start parsing
    return readTheHeader();
  };

  return dicomParser;
})(dicomParser);

/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)
    {
        var elements = {};

        while(byteStream.position < byteStream.byteArray.length)
        {
            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);
            elements[element.tag] = element;

            // we hit an item delimiter tag, return the current offset to mark
            // the end of this sequence item
            if(element.tag === 'xfffee00d')
            {
                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
            }

        }

        // eof encountered - log a warning and return what we have for the element
        warnings.push('eof encountered before finding item delimiter tag while reading sequence item of undefined length');
        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
    }

    function readSequenceItemExplicit(byteStream, warnings)
    {
        var item = dicomParser.readSequenceItem(byteStream);

        if(item.length === 4294967295)
        {
            item.hadUndefinedLength = true;
            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);
            item.length = byteStream.position - item.dataOffset;
        }
        else
        {
            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});
            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);
        }
        return item;
    }

    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)
    {
        while((byteStream.position + 4) <= byteStream.byteArray.length)
        {
          // end reading this sequence if the next tag is the sequence delimitation item
          var nextTag = dicomParser.readTag(byteStream);
          byteStream.seek(-4);
          if (nextTag === 'xfffee0dd') {
            // set the correct length
            element.length = byteStream.position - element.dataOffset;
            byteStream.seek(8);
            return element;
          }

            var item = readSequenceItemExplicit(byteStream, warnings);
            element.items.push(item);
        }
        warnings.push('eof encountered before finding sequence delimitation tag while reading sequence of undefined length');
        element.length = byteStream.position - element.dataOffset;
    }

    function readSQElementKnownLengthExplicit(byteStream, element, warnings)
    {
        var maxPosition = element.dataOffset + element.length;
        while(byteStream.position < maxPosition)
        {
            var item = readSequenceItemExplicit(byteStream, warnings);
            element.items.push(item);
        }
    }

    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'element'";
        }

        element.items = [];

        if(element.length === 4294967295)
        {
            readSQElementUndefinedLengthExplicit(byteStream, element, warnings);
        }
        else
        {
            readSQElementKnownLengthExplicit(byteStream, element, warnings);
        }
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback)
    {
        var elements = {};

        while(byteStream.position < byteStream.byteArray.length)
        {
            var element = dicomParser.readDicomElementImplicit(byteStream, undefined, vrCallback);
            elements[element.tag] = element;

            // we hit an item delimiter tag, return the current offset to mark
            // the end of this sequence item
            if(element.tag === 'xfffee00d')
            {
                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
            }
        }
        // eof encountered - log a warning and return what we have for the element
        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');
        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
    }

    function readSequenceItemImplicit(byteStream, vrCallback)
    {
        var item = dicomParser.readSequenceItem(byteStream);

        if(item.length === 4294967295)
        {
            item.hadUndefinedLength = true;
            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback);
            item.length = byteStream.position - item.dataOffset;
        }
        else
        {
            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});
            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length, {vrCallback: vrCallback});
        }
        return item;
    }

    function readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback)
    {
        while((byteStream.position + 4) <= byteStream.byteArray.length)
        {
          // end reading this sequence if the next tag is the sequence delimitation item
          var nextTag = dicomParser.readTag(byteStream);
          byteStream.seek(-4);
          if (nextTag === 'xfffee0dd') {
            // set the correct length
            element.length = byteStream.position - element.dataOffset;
            byteStream.seek(8);
            return element;
          }

          var item = readSequenceItemImplicit(byteStream, vrCallback);
          element.items.push(item);
        }
        byteStream.warnings.push('eof encountered before finding sequence delimiter in sequence of undefined length');
        element.length = byteStream.byteArray.length - element.dataOffset;
    }

    function readSQElementKnownLengthImplicit(byteStream, element, vrCallback)
    {
        var maxPosition = element.dataOffset + element.length;
        while(byteStream.position < maxPosition)
        {
            var item = readSequenceItemImplicit(byteStream, vrCallback);
            element.items.push(item);
        }
    }

    /**
     * Reads sequence items for an element in an implicit little endian byte stream
     * @param byteStream the implicit little endian byte stream
     * @param element the element to read the sequence items for
     * @param vrCallback an optional method that returns a VR string given a tag
     */
    dicomParser.readSequenceItemsImplicit = function(byteStream, element, vrCallback)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'element'";
        }

        element.items = [];

        if(element.length === 4294967295)
        {
            readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback);
        }
        else
        {
            readSQElementKnownLengthImplicit(byteStream, element, vrCallback);
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads the tag and length of a sequence item and returns them as an object with the following properties
     *  tag : string for the tag of this element in the format xggggeeee
     *  length: the number of bytes in this item or 4294967295 if undefined
     *  dataOffset: the offset into the byteStream of the data for this item
     * @param byteStream the byte
     * @returns {{tag: string, length: integer, dataOffset: integer}}
     */
    dicomParser.readSequenceItem = function(byteStream)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItem: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            length : byteStream.readUint32(),
            dataOffset :  byteStream.position
        };

        if (element.tag !== 'xfffee000') {
            var startPosition = byteStream.position;
            throw "dicomParser.readSequenceItem: item tag (FFFE,E000) not found at offset " + startPosition;
        }

        return element;
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads a tag (group number and element number) from a byteStream
     * @param byteStream the byte stream to read from
     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number
     * and eeee is the lower case hex value of the element number
     */
    dicomParser.readTag = function(byteStream)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readTag: missing required parameter 'byteStream'";
        }

        var groupNumber =  byteStream.readUint16() * 256 * 256;
        var elementNumber = byteStream.readUint16();
        var tag = "x" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);
        return tag;
    };

    return dicomParser;
}(dicomParser));
/**
 *
 * Internal helper function to create a shared copy of a byteArray
 *
 */
var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Creates a view of the underlying byteArray.  The view is of the same type as the byteArray (e.g.
   * Uint8Array or Buffer) and shares the same underlying memory (changing one changes the other)
   * @param byteArray the underlying byteArray (either Uint8Array or Buffer)
   * @param byteOffset offset into the underlying byteArray to create the view of
   * @param length number of bytes in the view
   * @returns {object} Uint8Array or Buffer depending on the type of byteArray
   */
  dicomParser.sharedCopy = function(byteArray, byteOffset, length) {
    if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {
      return byteArray.slice(byteOffset, byteOffset + length);
    }
    else if(byteArray instanceof Uint8Array) {
      return new Uint8Array(byteArray.buffer, byteArray.byteOffset + byteOffset, length);
    } else {
      throw 'dicomParser.from: unknown type for byteArray';
    }
  };

  return dicomParser;
}(dicomParser));
/**
 * Version
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  dicomParser.version = "1.7.3";

  return dicomParser;
}(dicomParser));
    return dicomParser;
}));

}).call(this,require("buffer").Buffer)

},{"buffer":20,"zlib":18}],26:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],27:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],28:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],29:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],30:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || function () {
    this.hSamp = 0; // Horizontal sampling factor
    this.quantTableSel = 0; // Quantization table destination selector
    this.vSamp = 0; // Vertical
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ComponentSpec;
}

},{}],31:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.DataStream = jpeg.lossless.DataStream || function (data, offset, length) {
    this.buffer = new DataView(data, offset, length);
    this.index = 0;
};



jpeg.lossless.DataStream.prototype.get16 = function () {
    var value = this.buffer.getUint16(this.index, false);
    this.index += 2;
    return value;
};



jpeg.lossless.DataStream.prototype.get8 = function () {
    var value = this.buffer.getUint8(this.index);
    this.index += 1;
    return value;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.DataStream;
}

},{}],32:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.Decoder = jpeg.lossless.Decoder || function (buffer, numBytes) {
    this.buffer = buffer;
    this.frame = new jpeg.lossless.FrameHeader();
    this.huffTable = new jpeg.lossless.HuffmanTable();
    this.quantTable = new jpeg.lossless.QuantizationTable();
    this.scan = new jpeg.lossless.ScanHeader();
    this.DU = jpeg.lossless.Utils.createArray(10, 4, 64); // at most 10 data units in a MCU, at most 4 data units in one component
    this.HuffTab = jpeg.lossless.Utils.createArray(4, 2, 50 * 256);
    this.IDCT_Source = [];
    this.nBlock = []; // number of blocks in the i-th Comp in a scan
    this.acTab = jpeg.lossless.Utils.createArray(10, 1); // ac HuffTab for the i-th Comp in a scan
    this.dcTab = jpeg.lossless.Utils.createArray(10, 1); // dc HuffTab for the i-th Comp in a scan
    this.qTab = jpeg.lossless.Utils.createArray(10, 1); // quantization table for the i-th Comp in a scan
    this.marker = 0;
    this.markerIndex = 0;
    this.numComp = 0;
    this.restartInterval = 0;
    this.selection = 0;
    this.xDim = 0;
    this.yDim = 0;
    this.xLoc = 0;
    this.yLoc = 0;
    this.numBytes = 0;
    this.outputData = null;
    this.restarting = false;
    this.mask = 0;

    if (typeof numBytes !== "undefined") {
        this.numBytes = numBytes;
    }
};


/*** Static Pseudo-constants ***/

jpeg.lossless.Decoder.IDCT_P = [0, 5, 40, 16, 45, 2, 7, 42, 21, 56, 8, 61, 18, 47, 1, 4, 41, 23, 58, 13, 32, 24, 37, 10, 63, 17, 44, 3, 6, 43, 20,
    57, 15, 34, 29, 48, 53, 26, 39, 9, 60, 19, 46, 22, 59, 12, 33, 31, 50, 55, 25, 36, 11, 62, 14, 35, 28, 49, 52, 27, 38, 30, 51, 54];
jpeg.lossless.Decoder.TABLE = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];
jpeg.lossless.Decoder.MAX_HUFFMAN_SUBTREE = 50;
jpeg.lossless.Decoder.MSB = 0x80000000;
jpeg.lossless.Decoder.RESTART_MARKER_BEGIN = 0xFFD0;
jpeg.lossless.Decoder.RESTART_MARKER_END = 0xFFD7;

/*** Prototype Methods ***/

jpeg.lossless.Decoder.prototype.decompress = function (buffer, offset, length) {
    return this.decode(buffer, offset, length).buffer;
};



jpeg.lossless.Decoder.prototype.decode = function (buffer, offset, length, numBytes) {
    /*jslint bitwise: true */

    var current, scanNum = 0, pred = [], i, compN, temp = [], index = [], mcuNum;

    if (typeof buffer !== "undefined") {
        this.buffer = buffer;
    }

    if (typeof numBytes !== "undefined") {
        this.numBytes = numBytes;
    }

    this.stream = new jpeg.lossless.DataStream(this.buffer, offset, length);
    this.buffer = null;

    this.xLoc = 0;
    this.yLoc = 0;
    current = this.stream.get16();

    if (current !== 0xFFD8) { // SOI
        throw new Error("Not a JPEG file");
    }

    current = this.stream.get16();

    while ((((current >> 4) !== 0x0FFC) || (current === 0xFFC4))) { // SOF 0~15
        switch (current) {
            case 0xFFC4: // DHT
                this.huffTable.read(this.stream, this.HuffTab);
                break;
            case 0xFFCC: // DAC
                throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
            case 0xFFDB:
                this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
                break;
            case 0xFFDD:
                this.restartInterval = this.readNumber();
                break;
            case 0xFFE0:
            case 0xFFE1:
            case 0xFFE2:
            case 0xFFE3:
            case 0xFFE4:
            case 0xFFE5:
            case 0xFFE6:
            case 0xFFE7:
            case 0xFFE8:
            case 0xFFE9:
            case 0xFFEA:
            case 0xFFEB:
            case 0xFFEC:
            case 0xFFED:
            case 0xFFEE:
            case 0xFFEF:
                this.readApp();
                break;
            case 0xFFFE:
                this.readComment();
                break;
            default:
                if ((current >> 8) !== 0xFF) {
                    throw new Error("ERROR: format throw new IOException! (decode)");
                }
        }

        current = this.stream.get16();
    }

    if ((current < 0xFFC0) || (current > 0xFFC7)) {
        throw new Error("ERROR: could not handle arithmetic code!");
    }

    this.frame.read(this.stream);
    current = this.stream.get16();

    do {
        while (current !== 0x0FFDA) { // SOS
            switch (current) {
                case 0xFFC4: // DHT
                    this.huffTable.read(this.stream, this.HuffTab);
                    break;
                case 0xFFCC: // DAC
                    throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
                case 0xFFDB:
                    this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
                    break;
                case 0xFFDD:
                    this.restartInterval = this.readNumber();
                    break;
                case 0xFFE0:
                case 0xFFE1:
                case 0xFFE2:
                case 0xFFE3:
                case 0xFFE4:
                case 0xFFE5:
                case 0xFFE6:
                case 0xFFE7:
                case 0xFFE8:
                case 0xFFE9:
                case 0xFFEA:
                case 0xFFEB:
                case 0xFFEC:
                case 0xFFED:
                case 0xFFEE:
                case 0xFFEF:
                    this.readApp();
                    break;
                case 0xFFFE:
                    this.readComment();
                    break;
                default:
                    if ((current >> 8) !== 0xFF) {
                        throw new Error("ERROR: format throw new IOException! (Parser.decode)");
                    }
            }

            current = this.stream.get16();
        }

        this.precision = this.frame.precision;
        this.components = this.frame.components;

        if (!this.numBytes) {
            this.numBytes = parseInt(Math.ceil(this.precision / 8));
        }

        if (this.numBytes == 1) {
            this.mask = 0xFF;
        } else {
            this.mask = 0xFFFF;
        }

        this.scan.read(this.stream);
        this.numComp = this.scan.numComp;
        this.selection = this.scan.selection;

        if (this.numBytes === 1) {
            if (this.numComp === 3) {
                this.getter = this.getValueRGB;
                this.setter = this.setValueRGB;
                this.output = this.outputRGB;
            } else {
                this.getter = this.getValue8;
                this.setter = this.setValue8;
                this.output = this.outputSingle;
            }
        } else {
            this.getter = this.getValue16;
            this.setter = this.setValue16;
            this.output = this.outputSingle;
        }

        switch (this.selection) {
            case 2:
                this.selector = this.select2;
                break;
            case 3:
                this.selector = this.select3;
                break;
            case 4:
                this.selector = this.select4;
                break;
            case 5:
                this.selector = this.select5;
                break;
            case 6:
                this.selector = this.select6;
                break;
            case 7:
                this.selector = this.select7;
                break;
            default:
                this.selector = this.select1;
                break;
        }

        this.scanComps = this.scan.components;
        this.quantTables = this.quantTable.quantTables;

        for (i = 0; i < this.numComp; i+=1) {
            compN = this.scanComps[i].scanCompSel;
            this.qTab[i] = this.quantTables[this.components[compN].quantTableSel];
            this.nBlock[i] = this.components[compN].vSamp * this.components[compN].hSamp;
            this.dcTab[i] = this.HuffTab[this.scanComps[i].dcTabSel][0];
            this.acTab[i] = this.HuffTab[this.scanComps[i].acTabSel][1];
        }

        this.xDim = this.frame.dimX;
        this.yDim = this.frame.dimY;
        this.outputData = new DataView(new ArrayBuffer(this.xDim * this.yDim * this.numBytes * this.numComp));

        scanNum+=1;

        while (true) { // Decode one scan
            temp[0] = 0;
            index[0] = 0;

            for (i = 0; i < 10; i+=1) {
                pred[i] = (1 << (this.precision - 1));
            }

            if (this.restartInterval === 0) {
                current = this.decodeUnit(pred, temp, index);

                while ((current === 0) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim))) {
                    this.output(pred);
                    current = this.decodeUnit(pred, temp, index);
                }

                break; //current=MARKER
            }

            for (mcuNum = 0; mcuNum < this.restartInterval; mcuNum+=1) {
                this.restarting = (mcuNum == 0);
                current = this.decodeUnit(pred, temp, index);
                this.output(pred);

                if (current !== 0) {
                    break;
                }
            }

            if (current === 0) {
                if (this.markerIndex !== 0) {
                    current = (0xFF00 | this.marker);
                    this.markerIndex = 0;
                } else {
                    current = this.stream.get16();
                }
            }

            if (!((current >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) &&
                (current <= jpeg.lossless.Decoder.RESTART_MARKER_END))) {
                break; //current=MARKER
            }
        }

        if ((current === 0xFFDC) && (scanNum === 1)) { //DNL
            this.readNumber();
            current = this.stream.get16();
        }
    } while ((current !== 0xFFD9) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) && (scanNum === 0));

    return this.outputData;
};



jpeg.lossless.Decoder.prototype.decodeUnit = function (prev, temp, index) {
    if (this.numComp == 1) {
        return this.decodeSingle(prev, temp, index);
    } else if (this.numComp == 3) {
        return this.decodeRGB(prev, temp, index);
    } else {
        return -1;
    }
};



jpeg.lossless.Decoder.prototype.select1 = function (compOffset) {
    return this.getPreviousX(compOffset);
};



jpeg.lossless.Decoder.prototype.select2 = function (compOffset) {
    return this.getPreviousY(compOffset);
};



jpeg.lossless.Decoder.prototype.select3 = function (compOffset) {
    return this.getPreviousXY(compOffset);
};



jpeg.lossless.Decoder.prototype.select4 = function (compOffset) {
    return (this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) - this.getPreviousXY(compOffset);
};



jpeg.lossless.Decoder.prototype.select5 = function (compOffset) {
    return this.getPreviousX(compOffset) + ((this.getPreviousY(compOffset) - this.getPreviousXY(compOffset)) >> 1);
};



jpeg.lossless.Decoder.prototype.select6 = function (compOffset) {
    return this.getPreviousY(compOffset) + ((this.getPreviousX(compOffset) - this.getPreviousXY(compOffset)) >> 1);
};



jpeg.lossless.Decoder.prototype.select7 = function (compOffset) {
    return ((this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) / 2);
};



jpeg.lossless.Decoder.prototype.decodeRGB = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, actab, dctab, qtab, ctrC, i, k, j;

    prev[0] = this.selector(0);
    prev[1] = this.selector(1);
    prev[2] = this.selector(2);

    for (ctrC = 0; ctrC < this.numComp; ctrC+=1) {
        qtab = this.qTab[ctrC];
        actab = this.acTab[ctrC];
        dctab = this.dcTab[ctrC];
        for (i = 0; i < this.nBlock[ctrC]; i+=1) {
            for (k = 0; k < this.IDCT_Source.length; k+=1) {
                this.IDCT_Source[k] = 0;
            }

            value = this.getHuffmanValue(dctab, temp, index);

            if (value >= 0xFF00) {
                return value;
            }

            prev[ctrC] = this.IDCT_Source[0] = prev[ctrC] + this.getn(index, value, temp, index);
            this.IDCT_Source[0] *= qtab[0];

            for (j = 1; j < 64; j+=1) {
                value = this.getHuffmanValue(actab, temp, index);

                if (value >= 0xFF00) {
                    return value;
                }

                j += (value >> 4);

                if ((value & 0x0F) === 0) {
                    if ((value >> 4) === 0) {
                        break;
                    }
                } else {
                    this.IDCT_Source[jpeg.lossless.Decoder.IDCT_P[j]] = this.getn(index, value & 0x0F, temp, index) * qtab[j];
                }
            }
        }
    }

    return 0;
};



jpeg.lossless.Decoder.prototype.decodeSingle = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, i, n, nRestart;

    if (this.restarting) {
        this.restarting = false;
        prev[0] = (1 << (this.frame.precision - 1));
    } else {
        prev[0] = this.selector();
    }

    for (i = 0; i < this.nBlock[0]; i+=1) {
        value = this.getHuffmanValue(this.dcTab[0], temp, index);
        if (value >= 0xFF00) {
            return value;
        }

        n = this.getn(prev, value, temp, index);
        nRestart = (n >> 8);

        if ((nRestart >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) && (nRestart <= jpeg.lossless.Decoder.RESTART_MARKER_END)) {
            return nRestart;
        }

        prev[0] += n;
    }

    return 0;
};



//	Huffman table for fast search: (HuffTab) 8-bit Look up table 2-layer search architecture, 1st-layer represent 256 node (8 bits) if codeword-length > 8
//	bits, then the entry of 1st-layer = (# of 2nd-layer table) | MSB and it is stored in the 2nd-layer Size of tables in each layer are 256.
//	HuffTab[*][*][0-256] is always the only 1st-layer table.
//
//	An entry can be: (1) (# of 2nd-layer table) | MSB , for code length > 8 in 1st-layer (2) (Code length) << 8 | HuffVal
//
//	HuffmanValue(table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                ):
//	    return: Huffman Value of table
//	            0xFF?? if it receives a MARKER
//	    Parameter:  table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                temp    temp storage for remainded bits
//	                index   index to bit of temp
//	                in      FILE pointer
//	    Effect:
//	        temp  store new remainded bits
//	        index change to new index
//	        in    change to new position
//	    NOTE:
//	      Initial by   temp=0; index=0;
//	    NOTE: (explain temp and index)
//	      temp: is always in the form at calling time or returning time
//	       |  byte 4  |  byte 3  |  byte 2  |  byte 1  |
//	       |     0    |     0    | 00000000 | 00000??? |  if not a MARKER
//	                                               ^index=3 (from 0 to 15)
//	                                               321
//	    NOTE (marker and marker_index):
//	      If get a MARKER from 'in', marker=the low-byte of the MARKER
//	        and marker_index=9
//	      If marker_index=9 then index is always > 8, or HuffmanValue()
//	        will not be called
jpeg.lossless.Decoder.prototype.getHuffmanValue = function (table, temp, index) {
    /*jslint bitwise: true */

    var code, input, mask;
    mask = 0xFFFF;

    if (index[0] < 8) {
        temp[0] <<= 8;
        input = this.stream.get8();
        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }
        temp[0] |= input;
    } else {
        index[0] -= 8;
    }

    code = table[temp[0] >> index[0]];

    if ((code & jpeg.lossless.Decoder.MSB) !== 0) {
        if (this.markerIndex !== 0) {
            this.markerIndex = 0;
            return 0xFF00 | this.marker;
        }

        temp[0] &= (mask >> (16 - index[0]));
        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }

        temp[0] |= input;
        code = table[((code & 0xFF) * 256) + (temp[0] >> index[0])];
        index[0] += 8;
    }

    index[0] += 8 - (code >> 8);

    if (index[0] < 0) {
        throw new Error("index=" + index[0] + " temp=" + temp[0] + " code=" + code + " in HuffmanValue()");
    }

    if (index[0] < this.markerIndex) {
        this.markerIndex = 0;
        return 0xFF00 | this.marker;
    }

    temp[0] &= (mask >> (16 - index[0]));
    return code & 0xFF;
};



jpeg.lossless.Decoder.prototype.getn = function (PRED, n, temp, index) {
    /*jslint bitwise: true */

    var result, one, n_one, mask, input;
    one = 1;
    n_one = -1;
    mask = 0xFFFF;

    if (n === 0) {
        return 0;
    }

    if (n === 16) {
        if (PRED[0] >= 0) {
            return -32768;
        } else {
            return 32768;
        }
    }

    index[0] -= n;

    if (index[0] >= 0) {
        if ((index[0] < this.markerIndex) && !this.isLastPixel()) { // this was corrupting the last pixel in some cases
            this.markerIndex = 0;
            return (0xFF00 | this.marker) << 8;
        }

        result = temp[0] >> index[0];
        temp[0] &= (mask >> (16 - index[0]));
    } else {
        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }

        temp[0] |= input;
        index[0] += 8;

        if (index[0] < 0) {
            if (this.markerIndex !== 0) {
                this.markerIndex = 0;
                return (0xFF00 | this.marker) << 8;
            }

            temp[0] <<= 8;
            input = this.stream.get8();

            if (input === 0xFF) {
                this.marker = this.stream.get8();
                if (this.marker !== 0) {
                    this.markerIndex = 9;
                }
            }

            temp[0] |= input;
            index[0] += 8;
        }

        if (index[0] < 0) {
            throw new Error("index=" + index[0] + " in getn()");
        }

        if (index[0] < this.markerIndex) {
            this.markerIndex = 0;
            return (0xFF00 | this.marker) << 8;
        }

        result = temp[0] >> index[0];
        temp[0] &= (mask >> (16 - index[0]));
    }

    if (result < (one << (n - 1))) {
        result += (n_one << n) + 1;
    }

    return result;
};



jpeg.lossless.Decoder.prototype.getPreviousX = function (compOffset) {
    /*jslint bitwise: true */

    if (this.xLoc > 0) {
        return this.getter((((this.yLoc * this.xDim) + this.xLoc) - 1), compOffset);
    } else if (this.yLoc > 0) {
        return this.getPreviousY(compOffset);
    } else {
        return (1 << (this.frame.precision - 1));
    }
};



jpeg.lossless.Decoder.prototype.getPreviousXY = function (compOffset) {
    /*jslint bitwise: true */

    if ((this.xLoc > 0) && (this.yLoc > 0)) {
        return this.getter(((((this.yLoc - 1) * this.xDim) + this.xLoc) - 1), compOffset);
    } else {
        return this.getPreviousY(compOffset);
    }
};



jpeg.lossless.Decoder.prototype.getPreviousY = function (compOffset) {
    /*jslint bitwise: true */

    if (this.yLoc > 0) {
        return this.getter((((this.yLoc - 1) * this.xDim) + this.xLoc), compOffset);
    } else {
        return this.getPreviousX(compOffset);
    }
};



jpeg.lossless.Decoder.prototype.isLastPixel = function () {
    return (this.xLoc === (this.xDim - 1)) && (this.yLoc === (this.yDim - 1));
};



jpeg.lossless.Decoder.prototype.outputSingle = function (PRED) {
    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
        this.setter((((this.yLoc * this.xDim) + this.xLoc)), this.mask & PRED[0]);

        this.xLoc+=1;

        if (this.xLoc >= this.xDim) {
            this.yLoc+=1;
            this.xLoc = 0;
        }
    }
};



jpeg.lossless.Decoder.prototype.outputRGB = function (PRED) {
    var offset = ((this.yLoc * this.xDim) + this.xLoc);

    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
        this.setter(offset, PRED[0], 0);
        this.setter(offset, PRED[1], 1);
        this.setter(offset, PRED[2], 2);

        this.xLoc+=1;

        if (this.xLoc >= this.xDim) {
            this.yLoc+=1;
            this.xLoc = 0;
        }
    }
};



jpeg.lossless.Decoder.prototype.setValue16 = function (index, val) {
    this.outputData.setInt16(index * 2, val, true);
};



jpeg.lossless.Decoder.prototype.getValue16 = function (index) {
    return this.outputData.getInt16(index * 2, true);
};



jpeg.lossless.Decoder.prototype.setValue8 = function (index, val) {
    this.outputData.setInt8(index, val);
};



jpeg.lossless.Decoder.prototype.getValue8 = function (index) {
    return this.outputData.getInt8(index);
};



jpeg.lossless.Decoder.prototype.setValueRGB = function (index, val, compOffset) {
    this.outputData.setUint8(index * 3 + compOffset, val);
};



jpeg.lossless.Decoder.prototype.getValueRGB = function (index, compOffset) {
    return this.outputData.getUint8(index * 3 + compOffset);
};



jpeg.lossless.Decoder.prototype.readApp = function() {
    var count = 0, length = this.stream.get16();
    count += 2;

    while (count < length) {
        this.stream.get8();
        count+=1;
    }

    return length;
};



jpeg.lossless.Decoder.prototype.readComment = function () {
    var sb = "", count = 0, length;

    length = this.stream.get16();
    count += 2;

    while (count < length) {
        sb += this.stream.get8();
        count+=1;
    }

    return sb;
};



jpeg.lossless.Decoder.prototype.readNumber = function() {
    var Ld = this.stream.get16();

    if (Ld !== 4) {
        throw new Error("ERROR: Define number format throw new IOException [Ld!=4]");
    }

    return this.stream.get16();
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Decoder;
}

},{"./data-stream.js":31,"./frame-header.js":33,"./huffman-table.js":34,"./quantization-table.js":36,"./scan-header.js":38,"./utils.js":39}],33:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);


/*** Constructor ***/
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || function () {
    this.components = []; // Components
    this.dimX = 0; // Number of samples per line
    this.dimY = 0; // Number of lines
    this.numComp = 0; // Number of component in the frame
    this.precision = 0; // Sample Precision (from the original image)
};



/*** Prototype Methods ***/

jpeg.lossless.FrameHeader.prototype.read = function (data) {
    /*jslint bitwise: true */

    var count = 0, length, i, c, temp;

    length = data.get16();
    count += 2;

    this.precision = data.get8();
    count+=1;

    this.dimY = data.get16();
    count += 2;

    this.dimX = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;
    for (i = 1; i <= this.numComp; i+=1) {
        if (count > length) {
            throw new Error("ERROR: frame format error");
        }

        c = data.get8();
        count+=1;

        if (count >= length) {
            throw new Error("ERROR: frame format error [c>=Lf]");
        }

        temp = data.get8();
        count+=1;

        if (!this.components[c]) {
            this.components[c] = new jpeg.lossless.ComponentSpec();
        }

        this.components[c].hSamp = temp >> 4;
        this.components[c].vSamp = temp & 0x0F;
        this.components[c].quantTableSel = data.get8();
        count+=1;
    }

    if (count !== length) {
        throw new Error("ERROR: frame format error [Lf!=count]");
    }

    return 1;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.FrameHeader;
}

},{"./component-spec.js":30,"./data-stream.js":31}],34:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || function () {
    this.l = jpeg.lossless.Utils.createArray(4, 2, 16);
    this.th = [];
    this.v = jpeg.lossless.Utils.createArray(4, 2, 16, 200);
    this.tc = jpeg.lossless.Utils.createArray(4, 2);

    this.tc[0][0] = 0;
    this.tc[1][0] = 0;
    this.tc[2][0] = 0;
    this.tc[3][0] = 0;
    this.tc[0][1] = 0;
    this.tc[1][1] = 0;
    this.tc[2][1] = 0;
    this.tc[3][1] = 0;
    this.th[0] = 0;
    this.th[1] = 0;
    this.th[2] = 0;
    this.th[3] = 0;
};



/*** Static Pseudo-constants ***/

jpeg.lossless.HuffmanTable.MSB = 0x80000000;


/*** Prototype Methods ***/

jpeg.lossless.HuffmanTable.prototype.read = function(data, HuffTab) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, c, i, j;

    length = data.get16();
    count += 2;

    while (count < length) {
        temp = data.get8();
        count+=1;
        t = temp & 0x0F;
        if (t > 3) {
            throw new Error("ERROR: Huffman table ID > 3");
        }

        c = temp >> 4;
        if (c > 2) {
            throw new Error("ERROR: Huffman table [Table class > 2 ]");
        }

        this.th[t] = 1;
        this.tc[t][c] = 1;

        for (i = 0; i < 16; i+=1) {
            this.l[t][c][i] = data.get8();
            count+=1;
        }

        for (i = 0; i < 16; i+=1) {
            for (j = 0; j < this.l[t][c][i]; j+=1) {
                if (count > length) {
                    throw new Error("ERROR: Huffman table format error [count>Lh]");
                }

                this.v[t][c][i][j] = data.get8();
                count+=1;
            }
        }
    }

    if (count !== length) {
        throw new Error("ERROR: Huffman table format error [count!=Lf]");
    }

    for (i = 0; i < 4; i+=1) {
        for (j = 0; j < 2; j+=1) {
            if (this.tc[i][j] !== 0) {
                this.buildHuffTable(HuffTab[i][j], this.l[i][j], this.v[i][j]);
            }
        }
    }

    return 1;
};



//	Build_HuffTab()
//	Parameter:  t       table ID
//	            c       table class ( 0 for DC, 1 for AC )
//	            L[i]    # of codewords which length is i
//	            V[i][j] Huffman Value (length=i)
//	Effect:
//	    build up HuffTab[t][c] using L and V.
jpeg.lossless.HuffmanTable.prototype.buildHuffTable = function(tab, L, V) {
    /*jslint bitwise: true */

    var currentTable, temp, k, i, j, n;
    temp = 256;
    k = 0;

    for (i = 0; i < 8; i+=1) { // i+1 is Code length
        for (j = 0; j < L[i]; j+=1) {
            for (n = 0; n < (temp >> (i + 1)); n+=1) {
                tab[k] = V[i][j] | ((i + 1) << 8);
                k+=1;
            }
        }
    }

    for (i = 1; k < 256; i+=1, k+=1) {
        tab[k] = i | jpeg.lossless.HuffmanTable.MSB;
    }

    currentTable = 1;
    k = 0;

    for (i = 8; i < 16; i+=1) { // i+1 is Code length
        for (j = 0; j < L[i]; j+=1) {
            for (n = 0; n < (temp >> (i - 7)); n+=1) {
                tab[(currentTable * 256) + k] = V[i][j] | ((i + 1) << 8);
                k+=1;
            }

            if (k >= 256) {
                if (k > 256) {
                    throw new Error("ERROR: Huffman table error(1)!");
                }

                k = 0;
                currentTable+=1;
            }
        }
    }
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.HuffmanTable;
}

},{"./data-stream.js":31,"./utils.js":39}],35:[function(require,module,exports){
/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Decoder = jpeg.lossless.Decoder || ((typeof require !== 'undefined') ? require('./decoder.js') : null);
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Exports ***/
var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg;
}

},{"./component-spec.js":30,"./data-stream.js":31,"./decoder.js":32,"./frame-header.js":33,"./huffman-table.js":34,"./quantization-table.js":36,"./scan-component.js":37,"./scan-header.js":38,"./utils.js":39}],36:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || function () {
    this.precision = []; // Quantization precision 8 or 16
    this.tq = []; // 1: this table is presented
    this.quantTables = jpeg.lossless.Utils.createArray(4, 64); // Tables

    this.tq[0] = 0;
    this.tq[1] = 0;
    this.tq[2] = 0;
    this.tq[3] = 0;
};



/*** Static Methods ***/

jpeg.lossless.QuantizationTable.enhanceQuantizationTable = function(qtab, table) {
    /*jslint bitwise: true */

    var i;

    for (i = 0; i < 8; i+=1) {
        qtab[table[(0 * 8) + i]] *= 90;
        qtab[table[(4 * 8) + i]] *= 90;
        qtab[table[(2 * 8) + i]] *= 118;
        qtab[table[(6 * 8) + i]] *= 49;
        qtab[table[(5 * 8) + i]] *= 71;
        qtab[table[(1 * 8) + i]] *= 126;
        qtab[table[(7 * 8) + i]] *= 25;
        qtab[table[(3 * 8) + i]] *= 106;
    }

    for (i = 0; i < 8; i+=1) {
        qtab[table[0 + (8 * i)]] *= 90;
        qtab[table[4 + (8 * i)]] *= 90;
        qtab[table[2 + (8 * i)]] *= 118;
        qtab[table[6 + (8 * i)]] *= 49;
        qtab[table[5 + (8 * i)]] *= 71;
        qtab[table[1 + (8 * i)]] *= 126;
        qtab[table[7 + (8 * i)]] *= 25;
        qtab[table[3 + (8 * i)]] *= 106;
    }

    for (i = 0; i < 64; i+=1) {
        qtab[i] >>= 6;
    }
};


/*** Prototype Methods ***/

jpeg.lossless.QuantizationTable.prototype.read = function (data, table) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, i;

    length = data.get16();
    count += 2;

    while (count < length) {
        temp = data.get8();
        count+=1;
        t = temp & 0x0F;

        if (t > 3) {
            throw new Error("ERROR: Quantization table ID > 3");
        }

        this.precision[t] = temp >> 4;

        if (this.precision[t] === 0) {
            this.precision[t] = 8;
        } else if (this.precision[t] === 1) {
            this.precision[t] = 16;
        } else {
            throw new Error("ERROR: Quantization table precision error");
        }

        this.tq[t] = 1;

        if (this.precision[t] === 8) {
            for (i = 0; i < 64; i+=1) {
                if (count > length) {
                    throw new Error("ERROR: Quantization table format error");
                }

                this.quantTables[t][i] = data.get8();
                count+=1;
            }

            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
        } else {
            for (i = 0; i < 64; i+=1) {
                if (count > length) {
                    throw new Error("ERROR: Quantization table format error");
                }

                this.quantTables[t][i] = data.get16();
                count += 2;
            }

            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
        }
    }

    if (count !== length) {
        throw new Error("ERROR: Quantization table error [count!=Lq]");
    }

    return 1;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.QuantizationTable;
}

},{"./data-stream.js":31,"./utils.js":39}],37:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || function () {
    this.acTabSel = 0; // AC table selector
    this.dcTabSel = 0; // DC table selector
    this.scanCompSel = 0; // Scan component selector
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanComponent;
}

},{}],38:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);


/*** Constructor ***/
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || function () {
    this.ah = 0;
    this.al = 0;
    this.numComp = 0; // Number of components in the scan
    this.selection = 0; // Start of spectral or predictor selection
    this.spectralEnd = 0; // End of spectral selection
    this.components = [];
};


/*** Prototype Methods ***/

jpeg.lossless.ScanHeader.prototype.read = function(data) {
    /*jslint bitwise: true */

    var count = 0, length, i, temp;

    length = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;

    for (i = 0; i < this.numComp; i+=1) {
        this.components[i] = new jpeg.lossless.ScanComponent();

        if (count > length) {
            throw new Error("ERROR: scan header format error");
        }

        this.components[i].scanCompSel = data.get8();
        count+=1;

        temp = data.get8();
        count+=1;

        this.components[i].dcTabSel = (temp >> 4);
        this.components[i].acTabSel = (temp & 0x0F);
    }

    this.selection = data.get8();
    count+=1;

    this.spectralEnd = data.get8();
    count+=1;

    temp = data.get8();
    this.ah = (temp >> 4);
    this.al = (temp & 0x0F);
    count+=1;

    if (count !== length) {
        throw new Error("ERROR: scan header format error [count!=Ns]");
    }

    return 1;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanHeader;
}

},{"./data-stream.js":31,"./scan-component.js":37}],39:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.Utils = jpeg.lossless.Utils || {};


/*** Static methods ***/

// http://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
jpeg.lossless.Utils.createArray = function (length) {
    var arr = new Array(length || 0),
        i = length;

    if (arguments.length > 1) {
        var args = Array.prototype.slice.call(arguments, 1);
        while(i--) arr[length-1 - i] = jpeg.lossless.Utils.createArray.apply(this, args);
    }

    return arr;
};


// http://stackoverflow.com/questions/18638900/javascript-crc32
jpeg.lossless.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};

jpeg.lossless.Utils.crc32 = function(dataView) {
    var crcTable = jpeg.lossless.Utils.crcTable || (jpeg.lossless.Utils.crcTable = jpeg.lossless.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Utils;
}

},{}],40:[function(require,module,exports){
'use strict';

/**
* FUNCTION: abs( x )
*	Computes the absolute value of `x`.
*
* @param {Number} x - input value
* @returns {Number} absolute value
*/
function abs( x ) {
	if ( x < 0 ) {
		return -x;
	}
	if ( x === 0 ) {
		return 0; // handle negative zero
	}
	return x;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{}],41:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.ceil;

},{}],42:[function(require,module,exports){
'use strict';

// MODULES //

var floor = require( 'math-floor' );


// DIV2 //

/**
* FUNCTION: div2( x )
*	Converts a nonnegative integer to a literal bit representation using the divide-by-2 algorithm.
*
* @param {Number} x - nonnegative integer
* @returns {String} bit representation
*/
function div2( x ) {
	var str = '';
	var y;

	// We repeatedly divide by 2 and check for a remainder. If a remainder exists, the number is odd and we add a '1' bit...
	while ( x > 0 ) {
		y = x / 2;
		x = floor( y );
		if ( y === x ) {
			str = '0' + str;
		} else {
			str = '1' + str;
		}
	}
	return str;
} // end FUNCTION div2()


// EXPORTS //

module.exports = div2;

},{"math-floor":45}],43:[function(require,module,exports){
'use strict';

// MODULES //

var pinf = require( 'const-pinf-float32' );
var ninf = require( 'const-ninf-float32' );
var abs = require( 'math-abs' );
var floor = require( 'math-floor' );
var rpad = require( 'utils-right-pad-string' );
var lpad = require( 'utils-left-pad-string' );
var repeat = require( 'utils-repeat-string' );
var div2 = require( './div2.js' );
var mult2 = require( './mult2.js' );


// CONSTANTS //

var BIAS = 127; // exponent bias => (2**8)/2 - 1


// BINARY STRING //

/**
* FUNCTION: binaryString( x )
*	Returns a string giving the literal bit representation of a single-precision floating-point number.
*
* @param {Number} x - input value
* @returns {String} bit representation
*/
function binaryString( x ) {
	var nbits;
	var sign;
	var str;
	var exp;
	var n;
	var f;
	var i;

	// Check for a negative value or negative zero...
	if ( x < 0 || 1/x === ninf ) {
		sign = '1';
	} else {
		sign = '0';
	}
	// Special case: +-infinity
	if ( x === pinf || x === ninf ) {
		// Based on IEEE 754-2008...
		exp = repeat( '1', 8 ); // all 1s
		str = repeat( '0', 23 ); // all 0s
		return sign + exp + str;
	}
	// Special case: NaN
	if ( x !== x ) {
		// Based on IEEE 754-2008...
		exp = repeat( '1', 8 ); // all 1s
		str = '1' + repeat( '0', 22 ); // can't be all 0s
		return sign + exp + str;
	}
	// Special case: +-0
	if ( x === 0 ) {
		// Based on IEEE 754-2008...
		exp = repeat( '0', 8 ); // all 0s
		str = repeat( '0', 23 ); // all 0s
		return sign + exp + str;
	}
	x = abs( x );

	// Isolate the integer part (digits before the decimal):
	n = floor( x );

	// Isolate the fractional part (digits after the decimal):
	f = x - n;

	// Convert the integer and fractional parts to bit strings:
	n = div2( n );
	f = mult2( f );

	// Determine the exponent needed to normalize the integer+fractional parts...
	if ( n ) {
		// Move the decimal `d` digits to the left:
		exp = n.length - 1;
	} else {
		// Find the first '1' bit...
		for ( i = 0; i < f.length; i++ ) {
			if ( f[ i ] === '1' ) {
				nbits = i + 1;
				break;
			}
		}
		// Move the decimal `d` digits to the right:
		exp = -nbits;
	}
	// Normalize the combined integer+fractional string...
	str = n + f;
	if ( exp < 0 ) {
		// Handle subnormals...
		if ( exp <= -BIAS ) {
			// Cap the number of bits removed:
			nbits = BIAS - 1;
		}
		// Remove all leading zeros and the first '1' for normal values, and, for subnormals, remove at most BIAS-1 leading bits:
		str = str.substring( nbits );
	} else {
		// Remove the leading '1' (implicit/hidden bit):
		str = str.substring( 1 );
	}
	// Convert the exponent to a bit string:
	exp = div2( exp + BIAS );
	exp = lpad( exp, 8, '0' );

	// Fill in any trailing zeros and ensure we have only 23 fraction bits:
	str = rpad( str, 23, '0' ).substring( 0, 23 );

	// Return a bit representation:
	return sign + exp + str;
} // end FUNCTION binaryString()


// EXPORTS //

module.exports = binaryString;

},{"./div2.js":42,"./mult2.js":44,"const-ninf-float32":22,"const-pinf-float32":23,"math-abs":40,"math-floor":45,"utils-left-pad-string":87,"utils-repeat-string":88,"utils-right-pad-string":89}],44:[function(require,module,exports){
'use strict';

// VARIABLES //

var MAX_ITER = 149; // 127+22 (subnormals)
var MAX_BITS = 24; // only 23 bits for fraction


// MULT2 //

/**
* FUNCTION: mult2( x )
*	Converts a fraction to a literal bit representation using the multiply-by-2 algorithm.
*
* @param {Number} x - number less than 1
* @returns {String} bit representation
*/
function mult2( x ) {
	var str;
	var y;
	var i;
	var j;

	str = '';
	if ( x === 0 ) {
		return str;
	}
	j = MAX_ITER;

	// Each time we multiply by 2 and find a ones digit, add a '1'; otherwise, add a '0'..
	for ( i = 0; i < MAX_ITER; i++ ) {
		y = x * 2;
		if ( y >= 1 ) {
			x = y - 1;
			str += '1';
			if ( j === MAX_ITER ) {
				j = i; // first '1'
			}
		} else {
			x = y;
			str += '0';
		}
		// Stop when we have no more decimals to process or in the event we found a fraction which cannot be represented in a finite number of bits...
		if ( y === 1 || i-j > MAX_BITS ) {
			break;
		}
	}
	return str;
} // end FUNCTION mult2()


// EXPORTS //

module.exports = mult2;

},{}],45:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.floor;

},{}],46:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/

/**
 * nifti
 * @type {*|{}}
 */
var nifti = nifti || {};
nifti.NIFTI1 = nifti.NIFTI1 || ((typeof require !== 'undefined') ? require('./nifti1.js') : null);
nifti.NIFTI2 = nifti.NIFTI2 || ((typeof require !== 'undefined') ? require('./nifti2.js') : null);
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);

var pako = pako || ((typeof require !== 'undefined') ? require('pako') : null);



/*** Static Methods ***/

/**
 * Returns true if this data represents a NIFTI-1 header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI1 = function (data) {
    var buf, mag1, mag2, mag3;

    buf = new DataView(data);
    mag1 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION);
    mag2 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 1);
    mag3 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 2);

    return !!((mag1 === nifti.NIFTI1.MAGIC_NUMBER[0]) && (mag2 === nifti.NIFTI1.MAGIC_NUMBER[1]) &&
        (mag3 === nifti.NIFTI1.MAGIC_NUMBER[2]));
};


/**
 * Returns true if this data represents a NIFTI-2 header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI2 = function (data) {
    var buf, mag1, mag2, mag3;

    buf = new DataView(data);
    mag1 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION);
    mag2 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 1);
    mag3 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 2);

    return !!((mag1 === nifti.NIFTI2.MAGIC_NUMBER[0]) && (mag2 === nifti.NIFTI2.MAGIC_NUMBER[1]) &&
    (mag3 === nifti.NIFTI2.MAGIC_NUMBER[2]));
};



/**
 * Returns true if this data represents a NIFTI header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI = function (data) {
    return (nifti.isNIFTI1(data) || nifti.isNIFTI2(data));
};



/**
 * Returns true if this data is GZIP compressed.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isCompressed = function (data) {
    var buf, magicCookie1, magicCookie2;

    if (data) {
        buf = new DataView(data);

        magicCookie1 = buf.getUint8(0);
        magicCookie2 = buf.getUint8(1);

        if (magicCookie1 === nifti.Utils.GUNZIP_MAGIC_COOKIE1) {
            return true;
        }

        if (magicCookie2 === nifti.Utils.GUNZIP_MAGIC_COOKIE2) {
            return true;
        }
    }

    return false;
};



/**
 * Returns decompressed data.
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.decompress = function (data) {
    return pako.inflate(data).buffer;
};



/**
 * Reads and returns the header object.
 * @param {ArrayBuffer} data
 * @returns {nifti.NIFTI1|nifti.NIFTI2|null}
 */
nifti.readHeader = function (data) {
    var header = null;

    if (nifti.isCompressed(data)) {
        data = nifti.decompress(data);
    }

    if (nifti.isNIFTI1(data)) {
        header = new nifti.NIFTI1();
    } else if (nifti.isNIFTI2(data)) {
        header = new nifti.NIFTI2();
    }

    if (header) {
        header.readHeader(data);
    } else {
        console.error("That file does not appear to be NIFTI!");
    }

    return header;
};



/**
 * Returns true if this header contains an extension.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @returns {boolean}
 */
nifti.hasExtension = function (header) {
    return (header.extensionFlag[0] != 0);
};



/**
 * Returns the image data.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readImage = function (header, data) {
    var imageOffset = header.vox_offset,
        timeDim = 1,
        statDim = 1;

    if (header.dims[4]) {
        timeDim = header.dims[4];
    }

    if (header.dims[5]) {
        statDim = header.dims[5];
    }

    var imageSize = header.dims[1] * header.dims[2] * header.dims[3] * timeDim * statDim * (header.numBitsPerVoxel / 8);
    return data.slice(imageOffset, imageOffset + imageSize);
};



/**
 * Returns the extension data (including extension header).
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readExtension = function (header, data) {
    var loc = header.getExtensionLocation(),
        size = header.extensionSize;

    return data.slice(loc, loc + size);
};



/**
 * Returns the extension data.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readExtensionData = function (header, data) {
    var loc = header.getExtensionLocation(),
        size = header.extensionSize;

    return data.slice(loc + 8, loc + size - 8);
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti;
}

},{"./nifti1.js":47,"./nifti2.js":48,"./utilities.js":49,"pako":51}],47:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);



/*** Constructor ***/

/**
 * The NIFTI1 constructor.
 * @constructor
 * @property {boolean} littleEndian
 * @property {number} dim_info
 * @property {number[]} dims - image dimensions
 * @property {number} intent_p1
 * @property {number} intent_p2
 * @property {number} intent_p3
 * @property {number} intent_code
 * @property {number} datatypeCode
 * @property {number} numBitsPerVoxel
 * @property {number} slice_start
 * @property {number} slice_end
 * @property {number} slice_code
 * @property {number[]} pixDims - voxel dimensions
 * @property {number} vox_offset
 * @property {number} scl_slope
 * @property {number} scl_inter
 * @property {number} xyzt_units
 * @property {number} cal_max
 * @property {number} cal_min
 * @property {number} slice_duration
 * @property {number} toffset
 * @property {string} description
 * @property {string} aux_file
 * @property {string} intent_name
 * @property {number} qform_code
 * @property {number} sform_code
 * @property {number} quatern_b
 * @property {number} quatern_c
 * @property {number} quatern_d
 * @property {number} quatern_x
 * @property {number} quatern_y
 * @property {number} quatern_z
 * @property {Array.<Array.<number>>} affine
 * @property {string} magic
 * @property {boolean} isHDR - if hdr/img format
 * @property {number[]} extensionFlag
 * @property {number} extensionSize
 * @property {number} extensionCode
 * @type {Function}
 */
nifti.NIFTI1 = nifti.NIFTI1 || function () {
    this.littleEndian = false;
    this.dim_info = 0;
    this.dims = [];
    this.intent_p1 = 0;
    this.intent_p2 = 0;
    this.intent_p3 = 0;
    this.intent_code = 0;
    this.datatypeCode = 0;
    this.numBitsPerVoxel = 0;
    this.slice_start = 0;
    this.slice_end = 0;
    this.slice_code = 0;
    this.pixDims = [];
    this.vox_offset = 0;
    this.scl_slope = 1;
    this.scl_inter = 0;
    this.xyzt_units = 0;
    this.cal_max = 0;
    this.cal_min = 0;
    this.slice_duration = 0;
    this.toffset = 0;
    this.description = "";
    this.aux_file = "";
    this.intent_name = "";
    this.qform_code = 0;
    this.sform_code = 0;
    this.quatern_b = 0;
    this.quatern_c = 0;
    this.quatern_d = 0;
    this.qoffset_x = 0;
    this.qoffset_y = 0;
    this.qoffset_z = 0;
    this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    this.magic = 0;
    this.isHDR = false;
    this.extensionFlag = [0, 0, 0, 0];
    this.extensionSize = 0;
    this.extensionCode = 0;
};



/*** Static Pseudo-constants ***/

// datatype codes
nifti.NIFTI1.TYPE_NONE            = 0;
nifti.NIFTI1.TYPE_BINARY          = 1;
nifti.NIFTI1.TYPE_UINT8           = 2;
nifti.NIFTI1.TYPE_INT16           = 4;
nifti.NIFTI1.TYPE_INT32           = 8;
nifti.NIFTI1.TYPE_FLOAT32        = 16;
nifti.NIFTI1.TYPE_COMPLEX64      = 32;
nifti.NIFTI1.TYPE_FLOAT64        = 64;
nifti.NIFTI1.TYPE_RGB24         = 128;
nifti.NIFTI1.TYPE_INT8          = 256;
nifti.NIFTI1.TYPE_UINT16        = 512;
nifti.NIFTI1.TYPE_UINT32        = 768;
nifti.NIFTI1.TYPE_INT64        = 1024;
nifti.NIFTI1.TYPE_UINT64       = 1280;
nifti.NIFTI1.TYPE_FLOAT128     = 1536;
nifti.NIFTI1.TYPE_COMPLEX128   = 1792;
nifti.NIFTI1.TYPE_COMPLEX256   = 2048;

// transform codes
nifti.NIFTI1.XFORM_UNKNOWN        = 0;
nifti.NIFTI1.XFORM_SCANNER_ANAT   = 1;
nifti.NIFTI1.XFORM_ALIGNED_ANAT   = 2;
nifti.NIFTI1.XFORM_TALAIRACH      = 3;
nifti.NIFTI1.XFORM_MNI_152        = 4;

// unit codes
nifti.NIFTI1.SPATIAL_UNITS_MASK = 0x07;
nifti.NIFTI1.TEMPORAL_UNITS_MASK = 0x38;
nifti.NIFTI1.UNITS_UNKNOWN        = 0;
nifti.NIFTI1.UNITS_METER          = 1;
nifti.NIFTI1.UNITS_MM             = 2;
nifti.NIFTI1.UNITS_MICRON         = 3;
nifti.NIFTI1.UNITS_SEC            = 8;
nifti.NIFTI1.UNITS_MSEC          = 16;
nifti.NIFTI1.UNITS_USEC          = 24;
nifti.NIFTI1.UNITS_HZ            = 32;
nifti.NIFTI1.UNITS_PPM           = 40;
nifti.NIFTI1.UNITS_RADS          = 48;

// nifti1 codes
nifti.NIFTI1.MAGIC_COOKIE = 348;
nifti.NIFTI1.MAGIC_NUMBER_LOCATION = 344;
nifti.NIFTI1.MAGIC_NUMBER = [0x6E, 0x2B, 0x31];  // n+1 (.nii)
nifti.NIFTI1.MAGIC_NUMBER2 = [0x6E, 0x69, 0x31];  // ni1 (.hdr/.img)
nifti.NIFTI1.EXTENSION_HEADER_SIZE = 8;


/*** Prototype Methods ***/

/**
 * Reads the header data.
 * @param {ArrayBuffer} data
 */
nifti.NIFTI1.prototype.readHeader = function (data) {
    var rawData = new DataView(data),
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian),
        ctr,
        ctrOut,
        ctrIn,
        index;

    if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {  // try as little endian
        this.littleEndian = true;
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
    }

    if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {
        throw new Error("This does not appear to be a NIFTI file!");
    }

    this.dim_info = nifti.Utils.getByteAt(rawData, 39);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 40 + (ctr * 2);
        this.dims[ctr] = nifti.Utils.getShortAt(rawData, index, this.littleEndian);
    }

    this.intent_p1 = nifti.Utils.getFloatAt(rawData, 56, this.littleEndian);
    this.intent_p2 = nifti.Utils.getFloatAt(rawData, 60, this.littleEndian);
    this.intent_p3 = nifti.Utils.getFloatAt(rawData, 64, this.littleEndian);
    this.intent_code = nifti.Utils.getShortAt(rawData, 68, this.littleEndian);

    this.datatypeCode = nifti.Utils.getShortAt(rawData, 70, this.littleEndian);
    this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 72, this.littleEndian);

    this.slice_start = nifti.Utils.getShortAt(rawData, 74, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 76 + (ctr * 4);
        this.pixDims[ctr] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
    }

    this.vox_offset = nifti.Utils.getFloatAt(rawData, 108, this.littleEndian);

    this.scl_slope = nifti.Utils.getFloatAt(rawData, 112, this.littleEndian);
    this.scl_inter = nifti.Utils.getFloatAt(rawData, 116, this.littleEndian);

    this.slice_end = nifti.Utils.getShortAt(rawData, 120, this.littleEndian);
    this.slice_code = nifti.Utils.getByteAt(rawData, 122);

    this.xyzt_units = nifti.Utils.getByteAt(rawData, 123);

    this.cal_max = nifti.Utils.getFloatAt(rawData, 124, this.littleEndian);
    this.cal_min = nifti.Utils.getFloatAt(rawData, 128, this.littleEndian);

    this.slice_duration = nifti.Utils.getFloatAt(rawData, 132, this.littleEndian);
    this.toffset = nifti.Utils.getFloatAt(rawData, 136, this.littleEndian);

    this.description = nifti.Utils.getStringAt(rawData, 148, 228);
    this.aux_file = nifti.Utils.getStringAt(rawData, 228, 252);

    this.qform_code = nifti.Utils.getShortAt(rawData, 252, this.littleEndian);
    this.sform_code = nifti.Utils.getShortAt(rawData, 254, this.littleEndian);

    this.quatern_b = nifti.Utils.getFloatAt(rawData, 256, this.littleEndian);
    this.quatern_c = nifti.Utils.getFloatAt(rawData, 260, this.littleEndian);
    this.quatern_d = nifti.Utils.getFloatAt(rawData, 264, this.littleEndian);
    this.qoffset_x = nifti.Utils.getFloatAt(rawData, 268, this.littleEndian);
    this.qoffset_y = nifti.Utils.getFloatAt(rawData, 272, this.littleEndian);
    this.qoffset_z = nifti.Utils.getFloatAt(rawData, 276, this.littleEndian);

    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 280 + (((ctrOut * 4) + ctrIn) * 4);
            this.affine[ctrOut][ctrIn] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
        }
    }

    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;

    this.intent_name = nifti.Utils.getStringAt(rawData, 328, 344);
    this.magic = nifti.Utils.getStringAt(rawData, 344, 348);

    this.isHDR = (this.magic === nifti.NIFTI1.MAGIC_NUMBER2);

    if (rawData.byteLength > nifti.NIFTI1.MAGIC_COOKIE) {
        this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 348);
        this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 348 + 1);
        this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 348 + 2);
        this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 348 + 3);

        if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
        }
    }
};


/**
 * Returns a formatted string of header fields.
 * @returns {string}
 */
nifti.NIFTI1.prototype.toFormattedString = function () {
    var fmt = nifti.Utils.formatNumber,
        string = "";

    string += ("Dim Info = " + this.dim_info + "\n");

    string += ("Image Dimensions (1-8): " +
        this.dims[0] + ", " +
        this.dims[1] + ", " +
        this.dims[2] + ", " +
        this.dims[3] + ", " +
        this.dims[4] + ", " +
        this.dims[5] + ", " +
        this.dims[6] + ", " +
        this.dims[7] + "\n");

    string += ("Intent Parameters (1-3): " +
        this.intent_p1 + ", " +
        this.intent_p2 + ", " +
        this.intent_p3) + "\n";

    string += ("Intent Code = " + this.intent_code + "\n");
    string += ("Datatype = " + this.datatypeCode +  " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n");
    string += ("Bits Per Voxel = " + this.numBitsPerVoxel + "\n");
    string += ("Slice Start = " + this.slice_start + "\n");
    string += ("Voxel Dimensions (1-8): " +
        fmt(this.pixDims[0]) + ", " +
        fmt(this.pixDims[1]) + ", " +
        fmt(this.pixDims[2]) + ", " +
        fmt(this.pixDims[3]) + ", " +
        fmt(this.pixDims[4]) + ", " +
        fmt(this.pixDims[5]) + ", " +
        fmt(this.pixDims[6]) + ", " +
        fmt(this.pixDims[7]) + "\n");

    string += ("Image Offset = " + this.vox_offset + "\n");
    string += ("Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n");
    string += ("Slice End = " + this.slice_end + "\n");
    string += ("Slice Code = " + this.slice_code + "\n");
    string += ("Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n");
    string += ("Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n");
    string += ("Slice Duration = " + this.slice_duration + "\n");
    string += ("Time Axis Shift = " + this.toffset + "\n");
    string += ("Description: \"" + this.description + "\"\n");
    string += ("Auxiliary File: \"" + this.aux_file + "\"\n");
    string += ("Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n");
    string += ("S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n");
    string += ("Quaternion Parameters:  " +
        "b = " + fmt(this.quatern_b) + "  " +
        "c = " + fmt(this.quatern_c) + "  " +
        "d = " + fmt(this.quatern_d) + "\n");

    string += ("Quaternion Offsets:  " +
        "x = " + this.qoffset_x + "  " +
        "y = " + this.qoffset_y + "  " +
        "z = " + this.qoffset_z + "\n");

    string += ("S-Form Parameters X: " +
        fmt(this.affine[0][0]) + ", " +
        fmt(this.affine[0][1]) + ", " +
        fmt(this.affine[0][2]) + ", " +
        fmt(this.affine[0][3]) + "\n");

    string += ("S-Form Parameters Y: " +
        fmt(this.affine[1][0]) + ", " +
        fmt(this.affine[1][1]) + ", " +
        fmt(this.affine[1][2]) + ", " +
        fmt(this.affine[1][3]) + "\n");

    string += ("S-Form Parameters Z: " +
        fmt(this.affine[2][0]) + ", " +
        fmt(this.affine[2][1]) + ", " +
        fmt(this.affine[2][2]) + ", " +
        fmt(this.affine[2][3]) + "\n");

    string += ("Intent Name: \"" + this.intent_name + "\"\n");

    if (this.extensionFlag[0]) {
        string += ("Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + "\n");

    }

    return string;
};


/**
 * Returns a human-readable string of datatype.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getDatatypeCodeString = function (code) {
    if (code === nifti.NIFTI1.TYPE_UINT8) {
        return "1-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT16) {
        return "2-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT32) {
        return "4-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_FLOAT32) {
        return "4-Byte Float";
    } else if (code === nifti.NIFTI1.TYPE_FLOAT64) {
        return "8-Byte Float";
    } else if (code === nifti.NIFTI1.TYPE_RGB24) {
        return "RGB";
    } else if (code === nifti.NIFTI1.TYPE_INT8) {
        return "1-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT16) {
        return "2-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT32) {
        return "4-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT64) {
        return "8-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT64) {
        return "8-Byte Unsigned Integer";
    } else {
        return "Unknown";
    }
};


/**
 * Returns a human-readable string of transform type.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getTransformCodeString = function (code) {
    if (code === nifti.NIFTI1.XFORM_SCANNER_ANAT) {
        return "Scanner";
    } else if (code === nifti.NIFTI1.XFORM_ALIGNED_ANAT) {
        return "Aligned";
    } else if (code === nifti.NIFTI1.XFORM_TALAIRACH) {
        return "Talairach";
    } else if (code === nifti.NIFTI1.XFORM_MNI_152) {
        return "MNI";
    } else {
        return "Unknown";
    }
};


/**
 * Returns a human-readable string of spatial and temporal units.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getUnitsCodeString = function (code) {
    if (code === nifti.NIFTI1.UNITS_METER) {
        return "Meters";
    } else if (code === nifti.NIFTI1.UNITS_MM) {
        return "Millimeters";
    } else if (code === nifti.NIFTI1.UNITS_MICRON) {
        return "Microns";
    } else if (code === nifti.NIFTI1.UNITS_SEC) {
        return "Seconds";
    } else if (code === nifti.NIFTI1.UNITS_MSEC) {
        return "Milliseconds";
    } else if (code === nifti.NIFTI1.UNITS_USEC) {
        return "Microseconds";
    } else if (code === nifti.NIFTI1.UNITS_HZ) {
        return "Hz";
    } else if (code === nifti.NIFTI1.UNITS_PPM) {
        return "PPM";
    } else if (code === nifti.NIFTI1.UNITS_RADS) {
        return "Rads";
    } else {
        return "Unknown";
    }
};


/**
 * Returns the qform matrix.
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI1.prototype.getQformMat = function () {
    return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x,
        this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
};



/**
 * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {number} qb
 * @param {number} qc
 * @param {number} qd
 * @param {number} qx
 * @param {number} qy
 * @param {number} qz
 * @param {number} dx
 * @param {number} dy
 * @param {number} dz
 * @param {number} qfac
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm = function (qb, qc, qd, qx, qy, qz, dx, dy, dz,
                                                qfac) {
    var R = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
        a,
        b = qb,
        c = qc,
        d = qd,
        xd,
        yd,
        zd;

    // last row is always [ 0 0 0 1 ]
    R[3][0] = R[3][1] = R[3][2] = 0.0;
    R[3][3] = 1.0;

    // compute a parameter from b,c,d
    a = 1.0 - (b * b + c * c + d * d);
    if (a < 0.0000001) {                   /* special case */

        a = 1.0 / Math.sqrt(b * b + c * c + d * d);
        b *= a;
        c *= a;
        d *= a;        /* normalize (b,c,d) vector */
        a = 0.0;                        /* a = 0 ==> 180 degree rotation */
    } else {

        a = Math.sqrt(a);                     /* angle = 2*arccos(a) */
    }

    // load rotation matrix, including scaling factors for voxel sizes
    xd = (dx > 0.0) ? dx : 1.0;       /* make sure are positive */
    yd = (dy > 0.0) ? dy : 1.0;
    zd = (dz > 0.0) ? dz : 1.0;

    if (qfac < 0.0) {
        zd = -zd;         /* left handedness? */
    }

    R[0][0] =       (a * a + b * b - c * c - d * d) * xd;
    R[0][1] = 2.0 * (b * c - a * d) * yd;
    R[0][2] = 2.0 * (b * d + a * c) * zd;
    R[1][0] = 2.0 * (b * c + a * d) * xd;
    R[1][1] =       (a * a + c * c - b * b - d * d) * yd;
    R[1][2] = 2.0 * (c * d - a * b) * zd;
    R[2][0] = 2.0 * (b * d - a * c) * xd;
    R[2][1] = 2.0 * (c * d + a * b) * yd;
    R[2][2] =       (a * a + d * d - c * c - b * b) * zd;

    // load offsets
    R[0][3] = qx;
    R[1][3] = qy;
    R[2][3] = qz;

    return R;
};



/**
 * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {Array.<Array.<number>>} R
 * @returns {string}
 */
nifti.NIFTI1.prototype.convertNiftiSFormToNEMA = function (R) {
    var xi, xj, xk, yi, yj, yk, zi, zj, zk, val, detQ, detP, i, j, k, p, q, r, ibest, jbest, kbest, pbest, qbest, rbest,
        M, vbest, Q, P, iChar, jChar, kChar, iSense, jSense, kSense;
    k = 0;

    Q = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    P = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

    //if( icod == NULL || jcod == NULL || kcod == NULL ) return ; /* bad */

    //*icod = *jcod = *kcod = 0 ; /* this.errorMessage returns, if sh*t happens */

    /* load column vectors for each (i,j,k) direction from matrix */

    /*-- i axis --*/ /*-- j axis --*/ /*-- k axis --*/

    xi = R[0][0];
    xj = R[0][1];
    xk = R[0][2];

    yi = R[1][0];
    yj = R[1][1];
    yk = R[1][2];

    zi = R[2][0];
    zj = R[2][1];
    zk = R[2][2];

    /* normalize column vectors to get unit vectors along each ijk-axis */

    /* normalize i axis */
    val = Math.sqrt(xi * xi + yi * yi + zi * zi);
    if (val === 0.0) {  /* stupid input */
        return null;
    }

    xi /= val;
    yi /= val;
    zi /= val;

    /* normalize j axis */
    val = Math.sqrt(xj * xj + yj * yj + zj * zj);
    if (val === 0.0) {  /* stupid input */
        return null;
    }

    xj /= val;
    yj /= val;
    zj /= val;

    /* orthogonalize j axis to i axis, if needed */
    val = xi * xj + yi * yj + zi * zj;    /* dot product between i and j */
    if (Math.abs(val) > 1.E-4) {
        xj -= val * xi;
        yj -= val * yi;
        zj -= val * zi;
        val = Math.sqrt(xj * xj + yj * yj + zj * zj);  /* must renormalize */
        if (val === 0.0) {              /* j was parallel to i? */
            return null;
        }
        xj /= val;
        yj /= val;
        zj /= val;
    }

    /* normalize k axis; if it is zero, make it the cross product i x j */
    val = Math.sqrt(xk * xk + yk * yk + zk * zk);
    if (val === 0.0) {
        xk = yi * zj - zi * yj;
        yk = zi * xj - zj * xi;
        zk = xi * yj - yi * xj;
    } else {
        xk /= val;
        yk /= val;
        zk /= val;
    }

    /* orthogonalize k to i */
    val = xi * xk + yi * yk + zi * zk;    /* dot product between i and k */
    if (Math.abs(val) > 1.E-4) {
        xk -= val * xi;
        yk -= val * yi;
        zk -= val * zi;
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0.0) {    /* bad */
            return null;
        }
        xk /= val;
        yk /= val;
        zk /= val;
    }

    /* orthogonalize k to j */
    val = xj * xk + yj * yk + zj * zk;    /* dot product between j and k */
    if (Math.abs(val) > 1.e-4) {
        xk -= val * xj;
        yk -= val * yj;
        zk -= val * zj;
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0.0) {     /* bad */
            return null;
        }
        xk /= val;
        yk /= val;
        zk /= val;
    }

    Q[0][0] = xi;
    Q[0][1] = xj;
    Q[0][2] = xk;
    Q[1][0] = yi;
    Q[1][1] = yj;
    Q[1][2] = yk;
    Q[2][0] = zi;
    Q[2][1] = zj;
    Q[2][2] = zk;

    /* at this point, Q is the rotation matrix from the (i,j,k) to (x,y,z) axes */

    detQ = this.nifti_mat33_determ(Q);
    if (detQ === 0.0) { /* shouldn't happen unless user is a DUFIS */
        return null;
    }

    /* Build and test all possible +1/-1 coordinate permutation matrices P;
     then find the P such that the rotation matrix M=PQ is closest to the
     identity, in the sense of M having the smallest total rotation angle. */

    /* Despite the formidable looking 6 nested loops, there are
     only 3*3*3*2*2*2 = 216 passes, which will run very quickly. */

    vbest = -666.0;
    ibest = pbest = qbest = rbest = 1;
    jbest = 2;
    kbest = 3;

    for (i = 1; i <= 3; i += 1) {     /* i = column number to use for row #1 */
        for (j = 1; j <= 3; j += 1) {    /* j = column number to use for row #2 */
            if (i !== j) {
                for (k = 1; k <= 3; k += 1) {  /* k = column number to use for row #3 */
                    if (!(i === k || j === k)) {
                        P[0][0] = P[0][1] = P[0][2] = P[1][0] = P[1][1] = P[1][2] = P[2][0] = P[2][1] = P[2][2] = 0.0;
                        for (p = -1; p <= 1; p += 2) {    /* p,q,r are -1 or +1      */
                            for (q = -1; q <= 1; q += 2) {   /* and go into rows #1,2,3 */
                                for (r = -1; r <= 1; r += 2) {
                                    P[0][i - 1] = p;
                                    P[1][j - 1] = q;
                                    P[2][k - 1] = r;
                                    detP = this.nifti_mat33_determ(P);           /* sign of permutation */
                                    if ((detP * detQ) > 0.0) {
                                        M = this.nifti_mat33_mul(P, Q);

                                        /* angle of M rotation = 2.0*acos(0.5*sqrt(1.0+trace(M)))       */
                                        /* we want largest trace(M) == smallest angle == M nearest to I */

                                        val = M[0][0] + M[1][1] + M[2][2]; /* trace */
                                        if (val > vbest) {
                                            vbest = val;
                                            ibest = i;
                                            jbest = j;
                                            kbest = k;
                                            pbest = p;
                                            qbest = q;
                                            rbest = r;
                                        }
                                    }  /* doesn't match sign of Q */
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /* At this point ibest is 1 or 2 or 3; pbest is -1 or +1; etc.

     The matrix P that corresponds is the best permutation approximation
     to Q-inverse; that is, P (approximately) takes (x,y,z) coordinates
     to the (i,j,k) axes.

     For example, the first row of P (which contains pbest in column ibest)
     determines the way the i axis points relative to the anatomical
     (x,y,z) axes.  If ibest is 2, then the i axis is along the y axis,
     which is direction P2A (if pbest > 0) or A2P (if pbest < 0).

     So, using ibest and pbest, we can assign the output code for
     the i axis.  Mutatis mutandis for the j and k axes, of course. */

    iChar = jChar = kChar = iSense = jSense = kSense = 0;

    switch (ibest * pbest) {
        case 1: /*i = NIFTI_L2R*/
            iChar = 'X';
            iSense = '+';
            break;
        case -1: /*i = NIFTI_R2L*/
            iChar = 'X';
            iSense = '-';
            break;
        case 2: /*i = NIFTI_P2A*/
            iChar = 'Y';
            iSense = '+';
            break;
        case -2: /*i = NIFTI_A2P*/
            iChar = 'Y';
            iSense = '-';
            break;
        case 3: /*i = NIFTI_I2S*/
            iChar = 'Z';
            iSense = '+';
            break;
        case -3: /*i = NIFTI_S2I*/
            iChar = 'Z';
            iSense = '-';
            break;
    }

    switch (jbest * qbest) {
        case 1: /*j = NIFTI_L2R*/
            jChar = 'X';
            jSense = '+';
            break;
        case -1: /*j = NIFTI_R2L*/
            jChar = 'X';
            jSense = '-';
            break;
        case 2: /*j = NIFTI_P2A*/
            jChar = 'Y';
            jSense = '+';
            break;
        case -2: /*j = NIFTI_A2P*/
            jChar = 'Y';
            jSense = '-';
            break;
        case 3: /*j = NIFTI_I2S*/
            jChar = 'Z';
            jSense = '+';
            break;
        case -3: /*j = NIFTI_S2I*/
            jChar = 'Z';
            jSense = '-';
            break;
    }

    switch (kbest * rbest) {
        case 1: /*k = NIFTI_L2R*/
            kChar = 'X';
            kSense = '+';
            break;
        case -1: /*k = NIFTI_R2L*/
            kChar = 'X';
            kSense = '-';
            break;
        case 2: /*k = NIFTI_P2A*/
            kChar = 'Y';
            kSense = '+';
            break;
        case -2: /*k = NIFTI_A2P*/
            kChar = 'Y';
            kSense = '-';
            break;
        case 3: /*k = NIFTI_I2S*/
            kChar = 'Z';
            kSense = '+';
            break;
        case -3: /*k = NIFTI_S2I*/
            kChar = 'Z';
            kSense = '-';
            break;
    }

    return (iChar + jChar + kChar + iSense + jSense + kSense);
};



nifti.NIFTI1.prototype.nifti_mat33_mul = function (A, B) {
    var C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
        i,
        j;

    for (i = 0; i < 3; i += 1) {
        for (j = 0; j < 3; j += 1) {
            C[i][j] =  A[i][0] * B[0][j]  + A[i][1] * B[1][j] + A[i][2] * B[2][j];
        }
    }

    return C;
};



nifti.NIFTI1.prototype.nifti_mat33_determ = function (R) {
    var r11, r12, r13, r21, r22, r23, r31, r32, r33;
    /*  INPUT MATRIX:  */
    r11 = R[0][0];
    r12 = R[0][1];
    r13 = R[0][2];
    r21 = R[1][0];
    r22 = R[1][1];
    r23 = R[1][2];
    r31 = R[2][0];
    r32 = R[2][1];
    r33 = R[2][2];

    return (r11 * r22 * r33 - r11 * r32 * r23 - r21 * r12 * r33 + r21 * r32 * r13 + r31 * r12 * r23 - r31 * r22 * r13);
};


/**
 * Returns the byte index of the extension.
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionLocation = function() {
    return nifti.NIFTI1.MAGIC_COOKIE + 4;
};


/**
 * Returns the extension size.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionSize = function(data) {
    return nifti.Utils.getIntAt(data, this.getExtensionLocation(), this.littleEndian);
};



/**
 * Returns the extension code.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionCode = function(data) {
    return nifti.Utils.getIntAt(data, this.getExtensionLocation() + 4, this.littleEndian);
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.NIFTI1;
}

},{"./utilities.js":49}],48:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);
nifti.NIFTI1 = nifti.NIFTI1 || ((typeof require !== 'undefined') ? require('./nifti1.js') : null);


/*** Constructor ***/

/**
 * The NIFTI2 constructor.
 * @constructor
 * @property {boolean} littleEndian
 * @property {number} dim_info
 * @property {number[]} dims - image dimensions
 * @property {number} intent_p1
 * @property {number} intent_p2
 * @property {number} intent_p3
 * @property {number} intent_code
 * @property {number} datatypeCode
 * @property {number} numBitsPerVoxel
 * @property {number} slice_start
 * @property {number} slice_end
 * @property {number} slice_code
 * @property {number[]} pixDims - voxel dimensions
 * @property {number} vox_offset
 * @property {number} scl_slope
 * @property {number} scl_inter
 * @property {number} xyzt_units
 * @property {number} cal_max
 * @property {number} cal_min
 * @property {number} slice_duration
 * @property {number} toffset
 * @property {string} description
 * @property {string} aux_file
 * @property {string} intent_name
 * @property {number} qform_code
 * @property {number} sform_code
 * @property {number} quatern_b
 * @property {number} quatern_c
 * @property {number} quatern_d
 * @property {number} quatern_x
 * @property {number} quatern_y
 * @property {number} quatern_z
 * @property {Array.<Array.<number>>} affine
 * @property {string} magic
 * @property {number[]} extensionFlag
 * @type {Function}
 */
nifti.NIFTI2 = nifti.NIFTI2 || function () {
    this.littleEndian = false;
    this.dim_info = 0;
    this.dims = [];
    this.intent_p1 = 0;
    this.intent_p2 = 0;
    this.intent_p3 = 0;
    this.intent_code = 0;
    this.datatypeCode = 0;
    this.numBitsPerVoxel = 0;
    this.slice_start = 0;
    this.slice_end = 0;
    this.slice_code = 0;
    this.pixDims = [];
    this.vox_offset = 0;
    this.scl_slope = 1;
    this.scl_inter = 0;
    this.xyzt_units = 0;
    this.cal_max = 0;
    this.cal_min = 0;
    this.slice_duration = 0;
    this.toffset = 0;
    this.description = "";
    this.aux_file = "";
    this.intent_name = "";
    this.qform_code = 0;
    this.sform_code = 0;
    this.quatern_b = 0;
    this.quatern_c = 0;
    this.quatern_d = 0;
    this.qoffset_x = 0;
    this.qoffset_y = 0;
    this.qoffset_z = 0;
    this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    this.magic = 0;
    this.extensionFlag = [0, 0, 0, 0];
};



/*** Static Pseudo-constants ***/

nifti.NIFTI2.MAGIC_COOKIE = 540;
nifti.NIFTI2.MAGIC_NUMBER_LOCATION = 4;
nifti.NIFTI2.MAGIC_NUMBER = [0x6E, 0x2B, 0x32, 0, 0x0D, 0x0A, 0x1A, 0x0A];  // n+2\0



/*** Prototype Methods ***/

/**
 * Reads the header data.
 * @param {ArrayBuffer} data
 */
nifti.NIFTI2.prototype.readHeader = function (data) {
    var rawData = new DataView(data),
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian),
        ctr,
        ctrOut,
        ctrIn,
        index,
        array;

    if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {  // try as little endian
        this.littleEndian = true;
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
    }

    if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {
        throw new Error("This does not appear to be a NIFTI file!");
    }

    this.datatypeCode = nifti.Utils.getShortAt(rawData, 12, this.littleEndian);
    this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 14, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 16 + (ctr * 8);
        this.dims[ctr] = nifti.Utils.getLongAt(rawData, index, this.littleEndian);
    }

    this.intent_p1 = nifti.Utils.getDoubleAt(rawData, 80, this.littleEndian);
    this.intent_p2 = nifti.Utils.getDoubleAt(rawData, 88, this.littleEndian);
    this.intent_p3 = nifti.Utils.getDoubleAt(rawData, 96, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 104 + (ctr * 8);
        this.pixDims[ctr] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
    }

    this.vox_offset = nifti.Utils.getLongAt(rawData, 168, this.littleEndian);

    this.scl_slope = nifti.Utils.getDoubleAt(rawData, 176, this.littleEndian);
    this.scl_inter = nifti.Utils.getDoubleAt(rawData, 184, this.littleEndian);

    this.cal_max = nifti.Utils.getDoubleAt(rawData, 192, this.littleEndian);
    this.cal_min = nifti.Utils.getDoubleAt(rawData, 200, this.littleEndian);

    this.slice_duration = nifti.Utils.getDoubleAt(rawData, 208, this.littleEndian);

    this.toffset = nifti.Utils.getDoubleAt(rawData, 216, this.littleEndian);

    this.slice_start = nifti.Utils.getLongAt(rawData, 224, this.littleEndian);
    this.slice_end = nifti.Utils.getLongAt(rawData, 232, this.littleEndian);

    this.description = nifti.Utils.getStringAt(rawData, 240, 240 + 80);
    this.aux_file = nifti.Utils.getStringAt(rawData, 320, 320 + 24);

    this.qform_code = nifti.Utils.getIntAt(rawData, 344, this.littleEndian);
    this.sform_code = nifti.Utils.getIntAt(rawData, 348, this.littleEndian);

    this.quatern_b = nifti.Utils.getDoubleAt(rawData, 352, this.littleEndian);
    this.quatern_c = nifti.Utils.getDoubleAt(rawData, 360, this.littleEndian);
    this.quatern_d = nifti.Utils.getDoubleAt(rawData, 368, this.littleEndian);
    this.qoffset_x = nifti.Utils.getDoubleAt(rawData, 376, this.littleEndian);
    this.qoffset_y = nifti.Utils.getDoubleAt(rawData, 384, this.littleEndian);
    this.qoffset_z = nifti.Utils.getDoubleAt(rawData, 392, this.littleEndian);

    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 400 + (((ctrOut * 4) + ctrIn) * 8);
            this.affine[ctrOut][ctrIn] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
        }
    }

    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;

    this.slice_code = nifti.Utils.getIntAt(rawData, 496, this.littleEndian);
    this.xyzt_units = nifti.Utils.getIntAt(rawData, 500, this.littleEndian);
    this.intent_code = nifti.Utils.getIntAt(rawData, 504, this.littleEndian);
    this.intent_name = nifti.Utils.getStringAt(rawData, 508, 508 + 16);

    this.dim_info = nifti.Utils.getByteAt(rawData, 524);

    if (rawData.byteLength > nifti.NIFTI2.MAGIC_COOKIE) {
        this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 540);
        this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 540 + 1);
        this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 540 + 2);
        this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 540 + 3);

        if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
        }
    }
};



/**
 * Returns a formatted string of header fields.
 * @returns {string}
 */
nifti.NIFTI2.prototype.toFormattedString = function () {
    var fmt = nifti.Utils.formatNumber,
        string = "";

    string += ("Datatype = " +  + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n");
    string += ("Bits Per Voxel = " + " = " + this.numBitsPerVoxel + "\n");
    string += ("Image Dimensions" + " (1-8): " +
        this.dims[0] + ", " +
        this.dims[1] + ", " +
        this.dims[2] + ", " +
        this.dims[3] + ", " +
        this.dims[4] + ", " +
        this.dims[5] + ", " +
        this.dims[6] + ", " +
        this.dims[7] + "\n");

    string += ("Intent Parameters (1-3): " +
        this.intent_p1 + ", " +
        this.intent_p2 + ", " +
        this.intent_p3) + "\n";

    string += ("Voxel Dimensions (1-8): " +
        fmt(this.pixDims[0]) + ", " +
        fmt(this.pixDims[1]) + ", " +
        fmt(this.pixDims[2]) + ", " +
        fmt(this.pixDims[3]) + ", " +
        fmt(this.pixDims[4]) + ", " +
        fmt(this.pixDims[5]) + ", " +
        fmt(this.pixDims[6]) + ", " +
        fmt(this.pixDims[7]) + "\n");

    string += ("Image Offset = " + this.vox_offset + "\n");
    string += ("Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n");
    string += ("Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n");
    string += ("Slice Duration = " + this.slice_duration + "\n");
    string += ("Time Axis Shift = " + this.toffset + "\n");
    string += ("Slice Start = " + this.slice_start + "\n");
    string += ("Slice End = " + this.slice_end + "\n");
    string += ("Description: \"" + this.description + "\"\n");
    string += ("Auxiliary File: \"" + this.aux_file + "\"\n");
    string += ("Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n");
    string += ("S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n");
    string += ("Quaternion Parameters:  " +
    "b = " + fmt(this.quatern_b) + "  " +
    "c = " + fmt(this.quatern_c) + "  " +
    "d = " + fmt(this.quatern_d) + "\n");

    string += ("Quaternion Offsets:  " +
    "x = " + this.qoffset_x + "  " +
    "y = " + this.qoffset_y + "  " +
    "z = " + this.qoffset_z + "\n");

    string += ("S-Form Parameters X: " +
    fmt(this.affine[0][0]) + ", " +
    fmt(this.affine[0][1]) + ", " +
    fmt(this.affine[0][2]) + ", " +
    fmt(this.affine[0][3]) + "\n");

    string += ("S-Form Parameters Y: " +
    fmt(this.affine[1][0]) + ", " +
    fmt(this.affine[1][1]) + ", " +
    fmt(this.affine[1][2]) + ", " +
    fmt(this.affine[1][3]) + "\n");

    string += ("S-Form Parameters Z: " +
    fmt(this.affine[2][0]) + ", " +
    fmt(this.affine[2][1]) + ", " +
    fmt(this.affine[2][2]) + ", " +
    fmt(this.affine[2][3]) + "\n");

    string += ("Slice Code = " + this.slice_code + "\n");
    string += ("Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n");
    string += ("Intent Code = " + this.intent_code + "\n");
    string += ("Intent Name: \"" + this.intent_name + "\"\n");

    string += ("Dim Info = " + this.dim_info + "\n");

    return string;
};



/**
 * Returns the byte index of the extension.
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionLocation = function() {
    return nifti.NIFTI2.MAGIC_COOKIE + 4;
};



/**
 * Returns the extension size.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionSize = nifti.NIFTI1.prototype.getExtensionSize;



/**
 * Returns the extension code.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionCode = nifti.NIFTI1.prototype.getExtensionCode;



/**
 * Returns a human-readable string of datatype.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getDatatypeCodeString = nifti.NIFTI1.prototype.getDatatypeCodeString;



/**
 * Returns a human-readable string of transform type.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getTransformCodeString = nifti.NIFTI1.prototype.getTransformCodeString;



/**
 * Returns a human-readable string of spatial and temporal units.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getUnitsCodeString = nifti.NIFTI1.prototype.getUnitsCodeString;



/**
 * Returns the qform matrix.
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI2.prototype.getQformMat = nifti.NIFTI1.prototype.getQformMat;



/**
 * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {number} qb
 * @param {number} qc
 * @param {number} qd
 * @param {number} qx
 * @param {number} qy
 * @param {number} qz
 * @param {number} dx
 * @param {number} dy
 * @param {number} dz
 * @param {number} qfac
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI2.prototype.convertNiftiQFormToNiftiSForm = nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm;



/**
 * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {Array.<Array.<number>>} R
 * @returns {string}
 */
nifti.NIFTI2.prototype.convertNiftiSFormToNEMA = nifti.NIFTI1.prototype.convertNiftiSFormToNEMA;



nifti.NIFTI2.prototype.nifti_mat33_mul = nifti.NIFTI1.prototype.nifti_mat33_mul;



nifti.NIFTI2.prototype.nifti_mat33_determ = nifti.NIFTI1.prototype.nifti_mat33_determ;



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.NIFTI2;
}

},{"./nifti1.js":47,"./utilities.js":49}],49:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || {};



/*** Static Pseudo-constants ***/

nifti.Utils.crcTable = null;
nifti.Utils.GUNZIP_MAGIC_COOKIE1 = 31;
nifti.Utils.GUNZIP_MAGIC_COOKIE2 = 139;



/*** Static methods ***/

nifti.Utils.getStringAt = function (data, start, end) {
    var str = "", ctr, ch;

    for (ctr = start; ctr < end; ctr += 1) {
        ch = data.getUint8(ctr);

        if (ch !== 0) {
            str += String.fromCharCode(ch);
        }
    }

    return str;
};



nifti.Utils.getByteAt = function (data, start) {
    return data.getInt8(start);
};



nifti.Utils.getShortAt = function (data, start, littleEndian) {
    return data.getInt16(start, littleEndian);
};



nifti.Utils.getIntAt = function (data, start, littleEndian) {
    return data.getInt32(start, littleEndian);
};



nifti.Utils.getFloatAt = function (data, start, littleEndian) {
    return data.getFloat32(start, littleEndian);
};



nifti.Utils.getDoubleAt = function (data, start, littleEndian) {
    return data.getFloat64(start, littleEndian);
};



nifti.Utils.getLongAt = function (data, start, littleEndian) {
    var ctr, array = [], value = 0;

    for (ctr = 0; ctr < 8; ctr += 1) {
        array[ctr] = nifti.Utils.getByteAt(data, start + ctr, littleEndian);
    }

    for (ctr = array.length - 1; ctr >= 0; ctr--) {
        value = (value * 256) + array[ctr];
    }

    return value;
};



nifti.Utils.toArrayBuffer = function (buffer) {
    var ab, view, i;

    ab = new ArrayBuffer(buffer.length);
    view = new Uint8Array(ab);
    for (i = 0; i < buffer.length; i += 1) {
        view[i] = buffer[i];
    }
    return ab;
};



nifti.Utils.isString = function (obj) {
    return (typeof obj === "string" || obj instanceof String);
};


nifti.Utils.formatNumber = function (num, shortFormat) {
    var val = 0;

    if (nifti.Utils.isString(num)) {
        val = Number(num);
    } else {
        val = num;
    }

    if (shortFormat) {
        val = val.toPrecision(5);
    } else {
        val = val.toPrecision(7);
    }

    return parseFloat(val);
};



// http://stackoverflow.com/questions/18638900/javascript-crc32
nifti.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};



nifti.Utils.crc32 = function(dataView) {
    var crcTable = nifti.Utils.crcTable || (nifti.Utils.crcTable = nifti.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.Utils;
}

},{}],50:[function(require,module,exports){
"use strict";
var assert = require('assert');

var lineSeparatorRE = /[ \f\t\v]*\r?\n/;
var NRRDMagicRE = /^NRRD\d{4}$/;
var lineRE = /^([^:]*)(:[ =])(.*)$/;
var dataFileListRE = /^LIST(?: (\d+))?$/;

// The minimal object this accepts is formed like this:
//   {data: SomeTypedArray, sizes: [...]}
// On the other hand, if data is not given it must have a form like this:
//   {buffer: SomeArrayBuffer, type: ..., endian: ..., sizes: [...]}
// Of course, if 'type' is an 8-bit type, endian is not needed, and if 'type' equals 'block', 'blockSize' should be set instead of 'endian'. In this case, no interpretation of buffer is done (at all, it is written serialized directly to the buffer).
// TODO: For now this only supports serializing "inline" files, or files for which you have already prepared the data.
module.exports.serialize = function (nrrdOrg) {
    var i, buffer, arr, totalLen = 1, nrrd = {}, prop, nativeType, nativeSize, bufferData, arrData, line, lines = [], header;
    
    // Copy nrrdOrg to nrrd to allow modifications without altering the original
    for(prop in nrrdOrg) {
        nrrd[prop] = nrrdOrg[prop];
    }
    
    // For saving files we allow inferring certain information if it is not explicitly given.
    // Also we normalize some fields to make our own lives easier.
    if (nrrd.sizes===undefined) { // 'sizes' should ALWAYS be given
        throw new Error("Sizes missing from NRRD file!");
    } else if (nrrd.dimension===undefined) {
        nrrd.dimension = nrrd.sizes.length;
    }
    if (nrrd.data instanceof Int8Array) {
        nativeType = "int8";
    } else if (nrrd.data instanceof Uint8Array) {
        nativeType = "uint8";
    } else if (nrrd.data instanceof Int16Array) {
        nativeType = "int16";
    } else if (nrrd.data instanceof Uint16Array) {
        nativeType = "uint16";
    } else if (nrrd.data instanceof Int32Array) {
        nativeType = "int32";
    } else if (nrrd.data instanceof Uint32Array) {
        nativeType = "uint32";
    //} else if (nrrd.data instanceof Int64Array) {
    //    nativeType = "int64";
    //} else if (nrrd.data instanceof Uint64Array) {
    //    nativeType = "uint64";
    } else if (nrrd.data instanceof Float32Array) {
        nativeType = "float";
    } else if (nrrd.data instanceof Float64Array) {
        nativeType = "double";
    }
    if (nrrd.type===undefined && nativeType!==undefined) {
        nrrd.type = nativeType;
    } else if (nrrd.type===undefined) {
        throw new Error("Type of data is not given and cannot be inferred!");
    } else if ((typeof nrrd.type) == "string" || nrrd.type instanceof String) {
        nrrd.type = parseNRRDType(nrrd.type);
    }
    if (nrrd.encoding===undefined) {
        nrrd.encoding = "raw";
    } else if ((typeof nrrd.encoding) == "string" || nrrd.encoding instanceof String) {
        nrrd.encoding = parseNRRDEncoding(nrrd.encoding);
    }
    if (nrrd.data && nrrd.type != 'block' && nrrd.type != 'int8' && nrrd.type != 'uint8' && nrrd.encoding != 'ascii') {
        nrrd.endian = systemEndianness;
    } else if (nrrd.type == 'block' || nrrd.type == 'int8' || nrrd.type == 'uint8' || nrrd.encoding == 'ascii') {
        nrrd.endian = undefined;
    } else if ((typeof nrrd.endian) == "string" || nrrd.endian instanceof String) {
        nrrd.endian = parseNRRDEndian(nrrd.endian);
    }
    
    // Try to infer spatial dimension
    var spaceDimension = undefined;
    if (nrrd.spaceDimension!==undefined) {
        spaceDimension = nrrd.spaceDimension;
    } else if (nrrd.space!==undefined) {
        switch(nrrd.space) {
        case "right-anterior-superior":
        case "RAS":
            spaceDimension = 3;
            break;
        case "left-anterior-superior":
        case "LAS":
            spaceDimension = 3;
            break;
        case "left-posterior-superior":
        case "LPS":
            spaceDimension = 3;
            break;
     	  case "right-anterior-superior-time":
     	  case "RAST":
     	      spaceDimension = 4;
     	      break;
        case "left-anterior-superior-time":
        case "LAST":
            spaceDimension = 4;
            break;
        case "left-posterior-superior-time":
        case "LPST":
            spaceDimension = 4;
            break;
        case "scanner-xyz":
            spaceDimension = 3;
            break;
        case "scanner-xyz-time":
            spaceDimension = 4;
            break;
        case "3D-right-handed":
            spaceDimension = 3;
            break;
        case "3D-left-handed":
            spaceDimension = 3;
            break;
        case "3D-right-handed-time":
            spaceDimension = 4;
            break;
        case "3D-left-handed-time":
            spaceDimension = 4;
            break;
        default:
            console.warn("Unrecognized space: " + nrrd.space);
        }
    }
    
    // Now check that we have a valid nrrd structure.
    checkNRRD(nrrd);

    // Determine number of elements and check that we have enough data (if possible)
    for(i=0; i<nrrd.sizes.length; i++) {
        if (nrrd.sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= nrrd.sizes[i];
    }
    if (nrrd.data) {
        if (nrrd.data.length < totalLen) {
            throw new Error("Missing data to serialize!");
        }
    } else if (nrrd.buffer) {
        if (nrrd.encoding == "raw") {
            if (nrrd.type=="block" && nrrd.blockSize!==undefined) {
                nativeSize = nrrd.blockSize;
            } else {
                nativeSize = getNRRDTypeSize(nrrd.type);
            }
            if (nrrd.buffer.byteLength < totalLen*nativeSize) {
                throw new Error("Missing data to serialize!");
            }
        }
    } else if (nrrd.dataFile) {
        // Okay, if you have your data ready, we'll just write a header.
    } else {
        throw new Error("Will not serialize an empty NRRD file!");
    }
    
    // Make sure we have the correct buffer in bufferData.
    if (nrrd.data) {
        switch(nrrd.encoding) {
        case 'raw':
            if (nrrd.type == nativeType && nrrd.endian == systemEndianness) {
                bufferData = nrrd.data.buffer.slice(nrrd.data.byteOffset, nrrd.data.byteOffset+nrrd.data.byteLength);
            } else if (nrrd.endian == systemEndianness) {
                bufferData = castTypedArray(nrrd.data, nrrd.type);
                bufferData = bufferData.buffer.slice(bufferData.byteOffset, bufferData.byteOffset+bufferData.byteLength);
            } else {
                bufferData = serializeToBuffer(nrrd.data, nrrd.type, nrrd.endian);
            }
            break;
        case 'ascii':
            if (nrrd.type == nativeType) {
                bufferData = serializeToTextBuffer(nrrd.data);
            } else {
                bufferData = serializeToTextBuffer(castTypedArray(nrrd.data, nrrd.type));
            }
            break;
        default:
            throw new Error("Unsupported NRRD encoding: " + nrrd.encoding);
        }
    } else if (nrrd.buffer) {
        bufferData = nrrd.buffer;
    }
    
    // Start header
    lines.push("NRRD0005"); // TODO: Adjust version based on features that are actually used and/or the version specified by the user (if any).
    lines.push("# Generated by nrrd-js");
    
    // Put in dimension and space dimension (the NRRD spec requires that these are present before any lists whose length depends on them)
    var firstProps = ['dimension', 'spaceDimension', 'space'];
    for(i=0; i<firstProps.length; i++) {
        prop = firstProps[i];
        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.
        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);
        if (line!==undefined) lines.push(line);
    }
    
    // Put in field specifications
    for(prop in nrrd) {
        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.
        if (firstProps.indexOf(prop)>=0) continue; // Skip the fields we already output.
        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);
        if (line!==undefined) lines.push(line);
    }
    
    // Put in keys (if any)
    if (nrrd.keys) for(prop in nrrd.keys) {
        if (prop.indexOf(":=")>=0) throw new Error("The combination ':=' is not allowed in an NRRD key!");
        lines.push(prop + ":=" + escapeValue(nrrd[prop]));
    }
    
    // Put in data file list (if any)
    if (nrrd.dataFile && nrrd.dataFile.length) {
        lines.push("data file: LIST");
        Array.prototype.push.apply(lines, nrrd.dataFile);
    } else if (nrrd.dataFile && nrrd.dataFile.files && 'subdim' in nrrd.dataFile) {
        lines.push("data file: LIST " + nrrd.dataFile.subdim);
        Array.prototype.push.apply(lines, nrrd.dataFile.files);
    }
    
    // Put in empty line and inline data (if we have inline data) and convert lines to buffer
    if (bufferData && !('dataFile' in nrrd)) {
        lines.push("");
        lines.push(""); // We actually need an extra blank line to make sure the previous is terminated.
        header = lines.join("\n");
        buffer = new ArrayBuffer(header.length + bufferData.byteLength);
        arr = new Uint8Array(buffer);
        for(i=0; i<header.length; i++) {
            arr[i] = header.charCodeAt(i);
        }
        arrData = new Uint8Array(bufferData);
        arr.set(arrData, header.length);
    } else {
        lines.push(""); // Blank line to at least terminate the last line.
        header = lines.join("\n");
        buffer = new ArrayBuffer(header.length);
        arr = new Uint8Array(buffer);
        for(i=0; i<header.length; i++) {
            arr[i] = header.charCodeAt(i);
        }
    }
    
    return buffer;
};

// This expects an ArrayBuffer.
module.exports.parse = function (buffer) {
    var i, header, dataStart, ret = {data: undefined/* parsed data */, buffer: undefined/* raw buffer holding data */, keys: {}, version: undefined},
        lines, match, match2,
        buf8 = new Uint8Array(buffer);

    // A work-around for incompatibilities between Node's Buffer and ArrayBuffer.
    if (buf8.buffer !== buffer) buffer = buf8.buffer;

    // First find the separation between the header and the data (if there is one)
    // Note that we need to deal with with LF and CRLF as possible line endings.
    // Luckily this means the line always ends with LF, so we only need to consider
    // LFLF and LFCRLF as patterns for the separating empty line.
    i=2; // It is safe to start at position 2 (in fact, we could start even later), as the file HAS to start with a magic word.
    while(i<buf8.length) {
        if (buf8[i] == 10) { // We hit an LF
            if (buf8[i-1] == 10 || (buf8[i-1] == 13 && buf8[i-2] == 10)) { // Safe because we start at position 2 and never move backwards
                dataStart = i+1;
                break;
            } else {
                i++; // Move forward just once
            }
        } else if (buf8[i] == 13) { // We hit a CR
            i++; // Move forward just once
        } else {
            i += 2; // Move forward two places, 
        }
    }
    
    // Now split up the header and data
    if (dataStart === undefined) {
        header = String.fromCharCode.apply(null, buf8);
    } else {
        header = String.fromCharCode.apply(null, buf8.subarray(0,dataStart));
        ret.buffer = buffer.slice(dataStart);
    }
    
    // Split header into lines, remove comments (and blank lines) and check magic.
    // All remaining lines except the first should be field specifications or key/value pairs.
    // TODO: This explicitly removes any whitespace at the end of lines, however, I am not sure that this is actually desired behaviour for all kinds of lines.
    lines = header.split(lineSeparatorRE);
    lines = lines.filter(function (l) { return l.length>0 && l[0] != '#'; }); // Remove comment lines
    if (!NRRDMagicRE.test(lines[0])) {
        throw new Error("File is not an NRRD file!");
    }
    ret.version = parseInt(lines[0].substring(4, 8), 10);
    if (ret.version>5) {
        console.warn("Reading an unsupported version of the NRRD format; things may go haywire.");
    }

    // Parse lines
    for(i=1; i<lines.length; i++) {
        match = lineRE.exec(lines[i]);
        if (!match) {
            console.warn("Unrecognized line in NRRD header: " + lines[i]);
            continue;
        }
        if (match[2] == ': ') { // Field specification
            match[1] = mapNRRDToJavascript(match[1]);
            if ( match[1] == 'dataFile' &&
                 (match2 = dataFileListRE.exec(match[3]))) {
                // This should be the last field specification,
                // and the rest of the lines should contain file names.
                if (match2.length == 2 && match2[1]) { // subdim specification
                    ret[match[1]] = {
                        files: lines.slice(i+1),
                        subdim: parseNRRDInteger(match2[1])
                    };
                } else {
                    ret[match[1]] = lines.slice(i+1);
                }
                lines.length = i;
            } else {
                ret[match[1]] = parseField(match[1], match[3]);
            }
        } else if (match[2] == ':=') { // Key/value pair
            ret.keys[match[1]] = unescapeValue(match[3]);
        } else {
            throw new Error("Logic error in NRRD parser."); // This should never happen (unless the NRRD syntax is extended and the regexp is updated, but this section is not, or some other programmer error).
        }
    }

    // Make sure the file satisfies the requirements of the NRRD format
    checkNRRD(ret);
    
    // "Parse" data
    if ('dataFile' in ret) {
        console.warn("No support for external data yet!");
    } else {
        switch(ret.encoding) {
        case 'raw':
            ret.data = parseNRRDRawData(ret.buffer, ret.type, ret.sizes, {
                endian: ret.endian, blockSize: ret.blockSize
            });
            break;
        case 'ascii':
            ret.data = parseNRRDTextData(ret.buffer, ret.type, ret.sizes);
            break;
        default:
            console.warn("Unsupported NRRD encoding: " + ret.encoding);
        }
    }
    
    return ret;
};

function escapeValue(val) {
    return val.replace('\\', '\\\\').replace('\n', '\\n');
}

function unescapeValue(val) {
    return val.split('\\\\').map(
        function(s) { return s.replace('\\n', '\n'); }
        ).join('\\');
}

// Serializes NRRD fields
function serializeField(prop, value, dimension, spaceDimension) {
    var line;
    var propNRRD = mapJavascriptToNRRD(prop);
    switch(prop) {
    // nrrd-js stuff: skip
    case 'data':
    case 'buffer':
    case 'keys':
    case 'version':
        break;
    // Literal (uninterpreted) fields
    case 'content':
    case 'number':
    case 'sampleUnits':
    case 'space':
        line = propNRRD + ": " + value;
        break;
    // Integers (no infinity or whatever, just a plain integer, so the default serialization is good enough)
    case 'blockSize':
    case 'lineSkip':
    case 'byteSkip':
    case 'dimension':
    case 'spaceDimension':
        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should at least contain a number!");
        line = propNRRD + ": " + value;
        break;
    // Floats (default serialization is good enough, as NaN contains nan, ignoring case, and similarly for Infinity inf)
    case 'min':
    case 'max':
    case 'oldMin':
    case 'oldMax':
        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should contain a number!");
        line = propNRRD + ": " + value;
        break;
    // Vectors
    case 'spaceOrigin':
        assert(value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": (" + value.join(",") + ")";
        break;
    // Lists of strings
    case 'labels':
    case 'units':
    case 'spaceUnits':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "string" || val instanceof String, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.map(serializeNRRDQuotedString).join(" ");
        break;
    // Lists of integers
    case 'sizes':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.join(" ");
        break;
    // Lists of floats
    case 'spacings':
    case 'thicknesses':
    case 'axisMins':
    case 'axisMaxs':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.join(" ");
        break;
    // Lists of vectors (dimension sized)
    case 'spaceDirections':
        assert(value.length !== undefined && value.length === dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (vec) {
          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");
          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });
        });
        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");
        break;
    // Lists of vectors (space dimension sized)
    case 'measurementFrame':
        assert(value.length !== undefined && value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");
        value.forEach(function (vec) {
          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");
          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });
        });
        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");
        break;
    // One-of-a-kind fields
    case 'type':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'encoding':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'endian':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'dataFile':
        if (value.length || (value.files && 'subdim' in value)) {
            // List of data files: skip for now
        } else {
            line = propNRRD + ": " + serializeNRRDDataFile(value);
        }
        break;
    case 'centers':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");
        break;
    case 'kinds':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");
        break;
    // Something unknown
    default:
        console.warn("Unrecognized NRRD field: " + prop + ", skipping.");
    }
    return line;
}

// Parses and normalizes NRRD fields, assumes the field names are already lower case.
function parseField(identifier, descriptor) {
    switch(identifier) {
    // Literal (uninterpreted) fields
    case 'content':
    case 'number':
    case 'sampleUnits':
        break;
    // Integers
    case 'dimension':
    case 'blockSize':
    case 'lineSkip':
    case 'byteSkip':
    case 'spaceDimension':
        descriptor = parseNRRDInteger(descriptor);
        break;
    // Floats
    case 'min':
    case 'max':
    case 'oldMin':
    case 'oldMax':
        descriptor = parseNRRDFloat(descriptor);
        break;
    // Vectors
    case 'spaceOrigin':
        descriptor = parseNRRDVector(descriptor);
        break;
    // Lists of strings
    case 'labels':
    case 'units':
    case 'spaceUnits':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDQuotedString);
        break;
    // Lists of integers
    case 'sizes':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDInteger);
        break;
    // Lists of floats
    case 'spacings':
    case 'thicknesses':
    case 'axisMins':
    case 'axisMaxs':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDFloat);
        break;
    // Lists of vectors
    case 'spaceDirections':
    case 'measurementFrame':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDVector);
        break;
    // One-of-a-kind fields
    case 'type':
        descriptor = parseNRRDType(descriptor);
        break;
    case 'encoding':
        descriptor = parseNRRDEncoding(descriptor);
        break;
    case 'endian':
        descriptor = parseNRRDEndian(descriptor);
        break;
    case 'dataFile':
        descriptor = parseNRRDDataFile(descriptor);
        break;
    case 'centers':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDCenter);
        break;
    case 'kinds':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDKind);
        break;
    case 'space':
        descriptor = parseNRRDSpace(descriptor);
        break;
    // Something unknown
    default:
        console.warn("Unrecognized NRRD field: " + identifier);
    }
    return descriptor;
}

// This only includes names whose lower case form is different from the Javascript form.
var mapNRRDToJavascriptStatic = {
    'block size': 'blockSize',
    'blocksize': 'blockSize',
    'old min': 'oldMin',
    'oldmin': 'oldMin',
    'old max': 'oldMax',
    'oldmax': 'oldMax',
    'data file': 'dataFile',
    'datafile': 'dataFile',
    'line skip': 'lineSkip',
    'lineskip': 'lineSkip',
    'byte skip': 'byteSkip',
    'byteskip': 'byteSkip',
    'sample units': 'sampleUnits',
    'sampleunits': 'sampleUnits',
    'axis mins': 'axisMins',
    'axis maxs': 'axisMaxs',
    'centers': 'centers', // Not different, just included so it is clear why centerings maps to centers
    'centerings': 'centers',
    'space dimension': 'spaceDimension',
    'space units': 'spaceUnits',
    'space origin': 'spaceOrigin',
    'space directions': 'spaceDirections',
    'measurement frame': 'measurementFrame'
};
var mapJavascriptToNRRDStatic = function() {
  var id, m = {};
  for(id in mapNRRDToJavascriptStatic) {
    m[mapNRRDToJavascriptStatic[id]] = id;
  }
  return m;
}();
function mapNRRDToJavascript(id) {
    // In any case, use the lower case version of the id
    id = id.toLowerCase();
    // Filter out any fields for which we have an explicit Javascript name
    if (id in mapNRRDToJavascriptStatic) return mapNRRDToJavascriptStatic[id];
    // Otherwise, just return the (lower case) id
    return id;
}
function mapJavascriptToNRRD(id) {
    // Filter out any fields for which we have an explicit NRRD name
    if (id in mapJavascriptToNRRDStatic) return mapJavascriptToNRRDStatic[id];
    // Otherwise, just return the id
    return id;
}

function parseNRRDInteger(str) {
    var val = parseInt(str, 10);
    if (Number.isNaN(val)) throw new Error("Malformed NRRD integer: " + str);
    return val;
}

function parseNRRDFloat(str) {
    str = str.toLowerCase();
    if (str.indexOf('nan')>=0) return NaN;
    if (str.indexOf('-inf')>=0) return -Infinity;
    if (str.indexOf('inf')>=0) return Infinity;
    var val = parseFloat(str);
    if (Number.isNaN(val)) throw new Error("Malformed NRRD float: " + str);
    return val;
}

function parseNRRDVector(str) {
    if (str == "none") return null;
    if (str.length<2 || str[0]!=="(" || str[str.length-1]!==")") throw new Error("Malformed NRRD vector: " + str);
    return str.slice(1, -1).split(",").map(parseNRRDFloat);
}

function parseNRRDQuotedString(str) {
    if (length<2 || str[0]!='"' || str[str.length-1]!='"') {
        throw new Error("Invalid NRRD quoted string: " + str);
    }
    return str.slice(1, -1).replace('\\"', '"');
}

function serializeNRRDQuotedString(str) {
    return '"' + str.replace('"', '\\"') + '"';
}

var whitespaceListSeparator = /[ \t]+/; // Note that this excludes other types of whitespace on purpose!
function parseNRRDWhitespaceSeparatedList(str, parseElement) {
    return str.split(whitespaceListSeparator).map(parseElement);
}

function parseNRRDType(descriptor) {
    switch(descriptor.toLowerCase()) {
    case "signed char":
    case "int8":
    case "int8_t":
        return 'int8';
    case "uchar":
    case "unsigned char":
    case "uint8":
    case "uint8_t":
        return 'uint8';
    case "short":
    case "short int":
    case "signed short":
    case "signed short int":
    case "int16":
    case "int16_t":
        return 'int16';
    case "ushort":
    case "unsigned short":
    case "unsigned short int":
    case "uint16":
    case "uint16_t":
        return 'uint16';
    case "int":
    case "signed int":
    case "int32":
    case "int32_t":
        return 'int32';
    case "uint":
    case "unsigned int":
    case "uint32":
    case "uint32_t":
        return 'uint32';
    case "longlong":
    case "long long":
    case "long long int":
    case "signed long long":
    case "signed long long int":
    case "int64":
    case "int64_t":
        return 'int64';
    case "ulonglong":
    case "unsigned long long":
    case "unsigned long long int":
    case "uint64":
    case "uint64_t":
        return 'uint64';
    case "float":
        return 'float';
    case "double":
        return 'double';
    case "block":
        return 'block';
    default:
        console.warn("Unrecognized NRRD type: " + descriptor);
        return descriptor;
    }
}

function parseNRRDEncoding(encoding) {
    switch(encoding.toLowerCase()) {
    case "raw":
        return "raw";
    case "txt":
    case "text":
    case "ascii":
        return "ascii";
    case "hex":
        return "hex";
    case "gz":
    case "gzip":
        return "gzip";
    case "bz2":
    case "bzip2":
        return "bzip2";
    default:
        console.warn("Unrecognized NRRD encoding: " + encoding);
        return encoding;
    }
}

function parseNRRDSpace(space) {
    switch(space.toLowerCase()) {
    case "right-anterior-superior":
    case "ras":
        return "right-anterior-superior";
    case "left-anterior-superior":
    case "las":
        return "left-anterior-superior";
    case "left-posterior-superior":
    case "lps":
        return "left-posterior-superior";
 	  case "right-anterior-superior-time":
 	  case "rast":
        return "right-anterior-superior-time";
    case "left-anterior-superior-time":
    case "last":
        return "left-anterior-superior-time";
    case "left-posterior-superior-time":
    case "lpst":
        return "left-posterior-superior-time";
    case "scanner-xyz":
        return "scanner-xyz";
    case "scanner-xyz-time":
        return "scanner-xyz-time";
    case "3d-right-handed":
        return "3D-right-handed";
    case "3d-left-handed":
        return "3D-left-handed";
    case "3d-right-handed-time":
        return "3D-right-handed-time";
    case "3d-left-handed-time":
        return "3D-left-handed-time";
    default:
        console.warn("Unrecognized space: " + space);
        return space;
    }
}

function parseNRRDEndian(endian) {
    switch(endian.toLowerCase()) {
    case 'little':
        return 'little';
    case 'big':
        return 'big';
    default:
        console.warn("Unrecognized NRRD endianness: " + endian);
        return endian;
    }
}

// Note that this function will never encounter the LIST data file specification format, as this is handled elsewhere.
var dataFileFormatRE = / (-?\d+) (-?\d+) (-?\d+)(?: (\d+))?$/;
function parseNRRDDataFile(dataFile) {
    var match = dataFileFormatRE.exec(dataFile);
    if (match) { // We have a format specification
        if (match.length == 5 && match[4]) { // subdim specification
            return {
                format: dataFile.substring(0, match.index),
                min: parseNRRDInteger(match[1]),
                max: parseNRRDInteger(match[2]),
                step: parseNRRDInteger(match[3]),
                subdim: parseNRRDInteger(match[4])
            };
        } else {
            return {
                format: dataFile.substring(0, match.index),
                min: parseNRRDInteger(match[1]),
                max: parseNRRDInteger(match[2]),
                step: parseNRRDInteger(match[3])
            };
        }
    } else { // Just a file
        return dataFile;
    }
}

function serializeNRRDDataFile(dataFile) {
    if ((typeof dataFile) == "string" || dataFile instanceof String) {
        return dataFile;
    } else if ('format' in dataFile && 'min' in dataFile && 'max' in dataFile && 'step' in dataFile) {
        if ('subdim' in dataFile) {
            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step + " " + dataFile.subdim;
        } else {
            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step;
        }
    } else {
        throw new Error("Unrecognized data file format!");
    }
}

function parseNRRDCenter(center) {
    switch(center.toLowerCase()) {
    case "cell":
        return "cell";
    case "node":
        return "node";
    case "???":
    case "none":
        return null;
    default:
        console.warn("Unrecognized NRRD center: " + center);
        return center;
    }
}

var NRRDKinds = {
    "domain": "domain",
    "space": "space",
    "time": "time",
    "list": "list",
    "point": "point",
    "vector": "vector",
    "covariant-vector": "covariant-vector",
    "normal": "normal",
    "stub": "stub",
    "scalar": "scalar",
    "complex": "complex",
    "2-vector": "2-vector",
    "3-color": "3-color",
    "rgb-color": "RGB-color",
    "hsv-color": "HSV-color",
    "xyz-color": "XYZ-color",
    "4-color": "4-color",
    "rgba-color": "RGBA-color",
    "3-vector": "3-vector",
    "3-gradient": "3-gradient",
    "3-normal": "3-normal",
    "4-vector": "4-vector",
    "quaternion": "quaternion",
    "2d-symmetric-matrix": "2D-symmetric-matrix",
    "2d-masked-symmetric-matrix": "2D-masked-symmetric-matrix",
    "2d-matrix": "2D-matrix",
    "2d-masked-matrix": "2D-masked-matrix",
    "3d-symmetric-matrix": "3D-symmetric-matrix",
    "3d-masked-symmetric-matrix": "3D-masked-symmetric-matrix",
    "3d-matrix": "3D-matrix",
    "3d-masked-matrix": "3D-masked-matrix",
    "???": null,
    "none": null
};
function parseNRRDKind(kind) {
    var kindLC = kind.toLowerCase();
    if (kindLC in NRRDKinds) return NRRDKinds[kindLC];
    console.warn("Unrecognized NRRD kind: " + kind);
    return kind;
}

function serializeNRRDOptional(a) {
    return a===null ? "???" : a;
}

var systemEndianness = (function() {
    var buf = new ArrayBuffer(4),
        intArr = new Uint32Array(buf),
        byteArr = new Uint8Array(buf);
    intArr[0] = 0x01020304;
    if (byteArr[0]==1 && byteArr[1]==2 && byteArr[2]==3 && byteArr[3]==4) {
        return 'big';
    } else if (byteArr[0]==4 && byteArr[1]==3 && byteArr[2]==2 && byteArr[3]==1) {
        return 'little';
    }
    console.warn("Unrecognized system endianness!");
    return undefined;
})();

function parseNRRDRawData(buffer, type, sizes, options) {
    var i, arr, view, totalLen = 1, endianFlag;
    for(i=0; i<sizes.length; i++) {
        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= sizes[i];
    }
    if (type == 'block') {
        // Don't do anything special, just return the slice containing all blocks.
        return buffer.slice(0,totalLen*options.blockSize);
    } else if (type == 'int8' || type == 'uint8' || options.endian == systemEndianness) {
        switch(type) {
        case "int8":
            checkSize(1);
            return new Int8Array(buffer.slice(0,totalLen));
        case "uint8":
            checkSize(1);
            return new Uint8Array(buffer.slice(0,totalLen));
        case "int16":
            checkSize(2);
            return new Int16Array(buffer.slice(0,totalLen*2));
        case "uint16":
            checkSize(2);
            return new Uint16Array(buffer.slice(0,totalLen*2));
        case "int32":
            checkSize(4);
            return new Int32Array(buffer.slice(0,totalLen*4));
        case "uint32":
            checkSize(4);
            return new Uint32Array(buffer.slice(0,totalLen*4));
        //case "int64":
        //    checkSize(8);
        //    return new Int64Array(buffer.slice(0,totalLen*8));
        //case "uint64":
        //    checkSize(8);
        //    return new Uint64Array(buffer.slice(0,totalLen*8));
        case "float":
            checkSize(4);
            return new Float32Array(buffer.slice(0,totalLen*4));
        case "double":
            checkSize(8);
            return new Float64Array(buffer.slice(0,totalLen*8));
        default:
            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");
            return undefined;
        }
    } else {
        switch(options.endian) {
        case 'big':
            endianFlag = false;
            break;
        case 'little':
            endianFlag = true;
            break;
        default:
            console.warn("Unsupported endianness in NRRD file: " + options.endian);
            return undefined;
        }
        view = new DataView(buffer);
        switch(type) {
        case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.
            arr = new Int8Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt8(i);
            }
            return arr;
        case "uint8":
            arr = new Uint8Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint8(i);
            }
            return arr;
        case "int16":
            arr = new Int16Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt16(i*2);
            }
            return arr;
        case "uint16":
            arr = new Uint16Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint16(i*2);
            }
            return arr;
        case "int32":
            arr = new Int32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt32(i*4);
            }
            return arr;
        case "uint32":
            arr = new Uint32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint32(i*4);
            }
            return arr;
        //case "int64":
        //    arr = new Int64Array(totalLen);
        //    for(i=0; i<totalLen; i++) {
        //        arr[i] = view.getInt64(i*8);
        //    }
        //    return arr;
        //case "uint64":
        //    arr = new Uint64Array(totalLen);
        //    for(i=0; i<totalLen; i++) {
        //        arr[i] = view.getUint64(i*8);
        //    }
        //    return arr;
        case "float":
            arr = new Float32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getFloat32(i*4);
            }
            return arr;
        case "double":
            arr = new Float64Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getFloat64(i*8);
            }
            return arr;
        default:
            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");
            return undefined;
        }
    }
    function checkSize(sizeOfType) {
        if (buffer.byteLength<totalLen*sizeOfType) throw new Error("NRRD file does not contain enough data!");
    }
}

var whitespaceDataValueListSeparatorRE = /[ \t\n\r\v\f]+/;
function parseNRRDTextData(buffer, type, sizes) {
    var i, buf8, str, strList, totalLen = 1;
    for(i=0; i<sizes.length; i++) {
        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= sizes[i];
    }
    buf8 = new Uint8Array(buffer);
    str = String.fromCharCode.apply(null, buf8);
    strList = str.split(whitespaceDataValueListSeparatorRE);
    if (strList.length<totalLen) {
        throw new Error("Not enough data in NRRD file!");
    } else if (strList.length>totalLen) {
        if (strList[0] === '') strList = strList.slice(1); // Strictly speaking the spec doesn't (explicitly) allow whitespace in front of the first number, but let's be lenient.
        strList = strList.slice(0, totalLen);
    }
    switch(type) {
    case "int8":
        return new Int8Array(strList.map(parseNRRDInteger));
    case "uint8":
        return new Uint8Array(strList.map(parseNRRDInteger));
    case "int16":
        return new Int16Array(strList.map(parseNRRDInteger));
    case "uint16":
        return new Uint16Array(strList.map(parseNRRDInteger));
    case "int32":
        return new Int32Array(strList.map(parseNRRDInteger));
    case "uint32":
        return new Uint32Array(strList.map(parseNRRDInteger));
    //case "int64":
    //    return new Int64Array(strList.map(parseNRRDInteger));
    //case "uint64":
    //    return new Uint64Array(strList.map(parseNRRDInteger));
    case "float":
        return new Float32Array(strList.map(parseNRRDFloat));
    case "double":
        return new Float64Array(strList.map(parseNRRDFloat));
    default:
        console.warn("Unsupported NRRD type: " + type + ".");
        return undefined;
    }
}

// This ALWAYS returns an integer, or throws an exception.
function getNRRDTypeSize(type) {
    switch(type) {
    case "int8":
        return 1;
    case "uint8":
        return 1;
    case "int16":
        return 2;
    case "uint16":
        return 2;
    case "int32":
        return 4;
    case "uint32":
        return 4;
    case "int64":
        return 8;
    case "uint64":
        return 8;
    case "float":
        return 4;
    case "double":
        return 8;
    default:
        throw new Error("Do not know the size of NRRD type: " + type);
    }
}

function checkNRRD(ret) {
    // Always necessary fields
    if (ret.dimension===undefined) {
        throw new Error("Dimension missing from NRRD file!");
    } else if (ret.type===undefined) {
        throw new Error("Type missing from NRRD file!");
    } else if (ret.encoding===undefined) {
        throw new Error("Encoding missing from NRRD file!");
    } else if (ret.sizes===undefined) {
        throw new Error("Sizes missing from NRRD file!");
    }
    
    // Sometimes necessary fields
    if (ret.type != 'block' && ret.type != 'int8' && ret.type != 'uint8' &&
          ret.encoding != 'ascii' && ret.endian === undefined) {
        throw new Error("Endianness missing from NRRD file!");
    } else if (ret.type == 'block' && ret.blockSize === undefined) {
        throw new Error("Missing block size in NRRD file!");
    }
    
    // Check dimension and per-axis field lengths
    if (ret.dimension === 0) {
        throw new Error("Zero-dimensional NRRD file?");
    } else if (ret.dimension != ret.sizes.length) {
        throw new Error("Length of 'sizes' is different from 'dimension' in an NRRD file!");
    } else if (ret.spacings && ret.dimension != ret.spacings.length) {
        throw new Error("Length of 'spacings' is different from 'dimension' in an NRRD file!");
    } else if (ret.thicknesses && ret.dimension != ret.thicknesses.length) {
        throw new Error("Length of 'thicknesses' is different from 'dimension' in an NRRD file!");
    } else if (ret.axisMins && ret.dimension != ret.axisMins.length) {
        throw new Error("Length of 'axis mins' is different from 'dimension' in an NRRD file!");
    } else if (ret.axisMaxs && ret.dimension != ret.axisMaxs.length) {
        throw new Error("Length of 'axis maxs' is different from 'dimension' in an NRRD file!");
    } else if (ret.centers && ret.dimension != ret.centers.length) {
        throw new Error("Length of 'centers' is different from 'dimension' in an NRRD file!");
    } else if (ret.labels && ret.dimension != ret.labels.length) {
        throw new Error("Length of 'labels' is different from 'dimension' in an NRRD file!");
    } else if (ret.units && ret.dimension != ret.units.length) {
        throw new Error("Length of 'units' is different from 'dimension' in an NRRD file!");
    } else if (ret.kinds && ret.dimension != ret.kinds.length) {
        throw new Error("Length of 'kinds' is different from 'dimension' in an NRRD file!");
    }
    
    // TODO: Check space/orientation fields.
    
    // We should either have inline data or external data
    if ((ret.data === undefined || ret.data.length === 0) && (ret.buffer === undefined || ret.buffer.byteLength === 0) && ret.dataFile === undefined) {
        throw new Error("NRRD file has neither inline or external data!");
    }
}

function castTypedArray(data, type) {
    switch(type) {
    case "int8":
        return new Int8Array(data);
    case "uint8":
        return new Uint8Array(data);
    case "int16":
        return new Int16Array(data);
    case "uint16":
        return new Uint16Array(data);
    case "int32":
        return new Int32Array(data);
    case "uint32":
        return new Uint32Array(data);
    //case "int64":
    //    return new Int64Array(data);
    //case "uint64":
    //    return new Uint64Array(data);
    case "float":
        return new Float32Array(data);
    case "double":
        return new Float64Array(data);
    default:
        throw new Error("Cannot cast to NRRD type: " + type);
    }
}

function serializeToBuffer(data, type, endian) {
    var i, endianFlag, view, nativeSize = getNRRDTypeSize(type), buffer = new ArrayBuffer(data.length*nativeSize);
    switch(endian) {
    case 'big':
        endianFlag = false;
        break;
    case 'little':
        endianFlag = true;
        break;
    default:
        console.warn("Unsupported endianness in NRRD file: " + endian);
        return undefined;
    }
    view = new DataView(buffer);
    switch(type) {
    case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.
        for(i=0; i<data.length; i++) {
            view.setInt8(i, data[i], endianFlag);
        }
        return buffer;
    case "uint8":
        for(i=0; i<data.length; i++) {
            view.setUint8(i, data[i], endianFlag);
        }
        return buffer;
    case "int16":
        for(i=0; i<data.length; i++) {
            view.setInt16(i*2, data[i], endianFlag);
        }
        return buffer;
    case "uint16":
        for(i=0; i<data.length; i++) {
            view.setUint16(i*2, data[i], endianFlag);
        }
        return buffer;
    case "int32":
        for(i=0; i<data.length; i++) {
            view.setInt32(i*4, data[i], endianFlag);
        }
        return buffer;
    case "uint32":
        for(i=0; i<data.length; i++) {
            view.setUint32(i*4, data[i], endianFlag);
        }
        return buffer;
    //case "int64":
    //    for(i=0; i<data.length; i++) {
    //        view.setInt64(i*8, data[i], endianFlag);
    //    }
    //    return buffer;
    //case "uint64":
    //    for(i=0; i<data.length; i++) {
    //        view.setUint64(i*8, data[i], endianFlag);
    //    }
    //    return buffer;
    case "float":
        for(i=0; i<data.length; i++) {
            view.setFloat32(i*4, data[i], endianFlag);
        }
        return buffer;
    case "double":
        for(i=0; i<data.length; i++) {
            view.setFloat64(i*8, data[i], endianFlag);
        }
        return buffer;
    default:
        console.warn("Cannot serialize NRRD type: " + type + ".");
        return undefined;
    }
}

function serializeToTextBuffer(data) {
    var i, strs = new Array(data.length), str, buffer, arr;
    for(i=0; i<data.length; i++) {
        strs[i] = '' + data[i];
    }
    str = strs.join(" ");
    buffer = new ArrayBuffer(str.length);
    arr = new Uint8Array(buffer);
    for(i=0; i<arr.length; i++) {
        arr[i] = str.charCodeAt(i);
    }
    return buffer;
}

},{"assert":3}],51:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":52,"./lib/inflate":53,"./lib/utils/common":54,"./lib/zlib/constants":57}],52:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":54,"./utils/strings":55,"./zlib/deflate":59,"./zlib/messages":64,"./zlib/zstream":66}],53:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":54,"./utils/strings":55,"./zlib/constants":57,"./zlib/gzheader":60,"./zlib/inflate":62,"./zlib/messages":64,"./zlib/zstream":66}],54:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],55:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":54}],56:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],57:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],58:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],59:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  s.d_buf = s.lit_bufsize >> 1;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":54,"./adler32":56,"./crc32":58,"./messages":64,"./trees":65}],60:[function(require,module,exports){
'use strict';


function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],61:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],62:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"../utils/common":54,"./adler32":56,"./crc32":58,"./inffast":61,"./inftrees":63,"dup":12}],63:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../utils/common":54,"dup":13}],64:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],65:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"../utils/common":54,"dup":15}],66:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],67:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":68}],68:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],69:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],70:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],71:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],72:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":70,"./encode":71}],73:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":74,"./_stream_writable":76,"core-util-is":24,"inherits":28,"process-nextick-args":67}],74:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":73,"./internal/streams/BufferList":77,"_process":68,"buffer":20,"buffer-shims":19,"core-util-is":24,"events":26,"inherits":28,"isarray":78,"process-nextick-args":67,"string_decoder/":80,"util":5}],75:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":73,"core-util-is":24,"inherits":28}],76:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = Buffer.isBuffer(chunk);

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":73,"_process":68,"buffer":20,"buffer-shims":19,"core-util-is":24,"events":26,"inherits":28,"process-nextick-args":67,"util-deprecate":83}],77:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
},{"buffer":20,"buffer-shims":19}],78:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],79:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":75}],80:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":20}],81:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":82,"punycode":69,"querystring":72}],82:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],83:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],84:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],85:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],86:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":85,"_process":68,"inherits":84}],87:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );
var ceil = require( 'math-ceil' );
var repeat = require( 'utils-repeat-string' );


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// LEFT PAD //

/**
* FUNCTION: lpad( str, len[, pad] )
*	Left pads a string such that the padded string has a length of at least `len`.
*
* @param {String} str - string to pad
* @param {Number} len - minimum string length
* @param {String} [pad=' '] - string used to pad
* @returns {String} padded string
*/
function lpad( str, len, pad ) {
	var n;
	var p;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( arguments.length > 2 ) {
		p = pad;
		if ( !isString( p ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a string. Value: `' + p + '`.' );
		}
		if ( p.length === 0 ) {
			throw new RangeError( 'invalid input argument. Pad string must not be an empty string.' );
		}
	} else {
		p = ' ';
	}
	if ( len > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	n = ( len - str.length ) / p.length;
	if ( n <= 0 ) {
		return str;
	}
	n = ceil( n );
	return repeat( p, n ) + str;
} // end FUNCTION lpad()


// EXPORTS //

module.exports = lpad;

},{"math-ceil":41,"utils-repeat-string":88,"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],88:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );


// NOTES //

/**
* The algorithmic trick used in the implementation is to treat string concatenation the same as binary addition (i.e., any natural number (nonnegative integer) can be expressed as a sum of powers of two).
*
* For example,
*
*  n = 10 => 1010 => 2^3 + 2^0 + 2^1 + 2^0
*
* We can produce a 10-repeat string by "adding" the results of a 8-repeat string and a 2-repeat string.
*
* The implementation is then as follows:
*  : Let `s` be the string to be repeated and `o` be an output string.
*  0) Initialize an output string `o`.
*  1) Check the least significant bit to determine if the current `s` string should be "added" to the output "total".
*     - if the bit is a one, add
*     - otherwise, move on
*  2) Double the string `s` by adding `s` to `s`.
*  3) Right-shift the bits of `n`.
*  4) Check if we have shifted off all bits.
*     - if yes, done.
*     - otherwise, move on
*  5) Repeat 1-4.
*
* The result is that, as the string is repeated, we continually check to see if the doubled string is one which we want to add to our "total".
*
* The algorithm runs in O(log_2(n)) compared to O(n).
*/


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// REPEAT //

/**
* FUNCTION: repeat( str, n )
*	Repeats a string a specified number of times and returns the concatenated result.
*
* @param {String} str - string to repeat
* @param {Number} n - number of times to repeat the string
* @returns {String}
*/
function repeat( str, n ) {
	var rpt;
	var cnt;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( n ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + n + '`.' );
	}
	if ( str.length === 0 || n === 0 ) {
		return '';
	}
	// Check that output string will not exceed the maximum string length:
	if ( str.length * n > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	rpt = '';
	cnt = n;
	for( ; ; ) {
		// If the count is odd, append the current concatenated string:
		if ( (cnt&1) === 1 ) {
			rpt += str;
		}
		// Right-shift the bits:
		cnt >>>= 1;
		if ( cnt === 0 ) {
			break;
		}
		// Double the string:
		str += str;
	}
	return rpt;
} // end FUNCTION repeat()


// EXPORTS //

module.exports = repeat;

},{"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],89:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );
var ceil = require( 'math-ceil' );
var repeat = require( 'utils-repeat-string' );


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// RIGHT PAD //

/**
* FUNCTION: rpad( str, len[, pad] )
*	Right pads a string such that the padded string has a length of at least `len`.
*
* @param {String} str - string to pad
* @param {Number} len - minimum string length
* @param {String} [pad=' '] - string used to pad
* @returns {String} padded string
*/
function rpad( str, len, pad ) {
	var n;
	var p;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( arguments.length > 2 ) {
		p = pad;
		if ( !isString( p ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a string. Value: `' + p + '`.' );
		}
		if ( p.length === 0 ) {
			throw new RangeError( 'invalid input argument. Pad string must not be an empty string.' );
		}
	} else {
		p = ' ';
	}
	if ( len > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	n = ( len - str.length ) / p.length;
	if ( n <= 0 ) {
		return str;
	}
	n = ceil( n );
	return str + repeat( p, n );
} // end FUNCTION rpad()


// EXPORTS //

module.exports = rpad;

},{"math-ceil":41,"utils-repeat-string":88,"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],90:[function(require,module,exports){
/**
*
*	VALIDATE: integer
*
*
*	DESCRIPTION:
*		- Validates if a value is an integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isNumber = require( 'validate.io-number' );


// ISINTEGER //

/**
* FUNCTION: isInteger( value )
*	Validates if a value is an integer.
*
* @param {Number} value - value to be validated
* @returns {Boolean} boolean indicating whether value is an integer
*/
function isInteger( value ) {
	return isNumber( value ) && value%1 === 0;
} // end FUNCTION isInteger()


// EXPORTS //

module.exports = isInteger;

},{"validate.io-number":92}],91:[function(require,module,exports){
/**
*
*	VALIDATE: nonnegative-integer
*
*
*	DESCRIPTION:
*		- Validates if a value is a nonnegative integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// IS NONNEGATIVE INTEGER //

/**
* FUNCTION: isNonNegativeInteger( value )
*	Validates if a value is a nonnegative integer.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a nonnegative integer
*/
function isNonNegativeInteger( value ) {
	return isInteger( value ) && value >= 0;
} // end FUNCTION isNonNegativeInteger()


// EXPORTS //

module.exports = isNonNegativeInteger;

},{"validate.io-integer":90}],92:[function(require,module,exports){
/**
*
*	VALIDATE: number
*
*
*	DESCRIPTION:
*		- Validates if a value is a number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isNumber( value )
*	Validates if a value is a number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a number
*/
function isNumber( value ) {
	return ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) && value.valueOf() === value.valueOf();
} // end FUNCTION isNumber()


// EXPORTS //

module.exports = isNumber;

},{}],93:[function(require,module,exports){
'use strict';

/**
* Tests if a value is a string primitive.
*
* @param {*} value - value to test
* @returns {Boolean} boolean indicating if a value is a string primitive
*/
function isString( value ) {
	return typeof value === 'string';
} // end FUNCTION isString()


// EXPORTS //

module.exports = isString;

},{}],94:[function(require,module,exports){
module.exports={
  "name": "ami.js",
  "version": "0.0.17-dev",
  "main": "lib/ami.js",
  "keywords": [
    "ami",
    "ami.js",
    "three.js",
    "webgl",
    "dicom",
    "nifti",
    "awesome",
    "medical",
    "imaging",
    "xtk",
    "nrrd",
    "vtk",
    "stl",
    "trk"
  ],
  "author": {
    "name": "Nicolas Rannou",
    "email": "nicolas@eunate.ch",
    "url": "https://eunate.ch"
  },
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://fnndsc.github.io/ami"
  },
  "config": {
    "threeVersion": "86",
    "amiCDN": "https://cdnjs.cloudflare.com/ajax/libs/ami.js/",
    "gaKey": "UA-39303022-3",
    "transforms": "-t [babelify --presets [ es2015 ] ]"
  },
  "dependencies": {
    "dicom-parser": "1.7.3",
    "image-JPEG2000": "OHIF/image-JPEG2000#master",
    "jpeg-lossless-decoder-js": "1.2.3",
    "math-float32-to-binary-string": "^1.0.0",
    "nifti-reader-js": "v0.5.3",
    "nrrd-js": "^0.2.1",
    "pako": "1.0.1"
  },
  "scripts": {
    "dist:prepare": "node ./scripts/$npm_package_config_mode.js --dist",
    "dist:watchAmi": "watchify -d src/ami $npm_package_config_transforms --standalone AMI -o dist/build/ami.js -v",
    "dist:watch": "watchify $npm_package_config_target -d $npm_package_config_transforms -o dist/$npm_package_config_target -v",
    "dist": "npm run dist:prepare --ami.js:mode=$npm_package_config_mode && (live-server dist --open=$npm_package_config_open & npm run dist:watch --ami.js:target=$npm_package_config_target)",
    "example": "npm run clean && node ./scripts/router.js examples ",
    "lesson": "npm run clean && mkdir dist/build && touch dist/build/ami.js && node ./scripts/router.js lessons ",
    "demo": "node ./scripts/lessons.js --demo",
    "lint": "eslint **/*.js --quiet",
    "build:examples": "npm run dist:prepare --ami.js:mode=examples && find examples -name '*.js' -print0 | xargs -0 -n1 -I{} bash -c \"echo Building {}; browserify {} -d -v $npm_package_config_transforms > dist/{} \"",
    "build:ami": "browserify src/ami.js -d -v $npm_package_config_transforms --standalone AMI > build/ami.js && uglifyjs build/ami.js -o build/ami.min.js",
    "build": "npm run clean && cp index.html dist/index.html && npm run build:examples && npm run doc",
    "build-cjs": "rimraf lib && cross-env BABEL_ENV=cjs babel ./src -d lib",
    "clean": "rimraf -rf dist/*",
    "test": "karma start",
    "doc": "jsdoc -p -r -R README.md -c jsdoc.conf -d dist/doc src",
    "ami": "npm run lint && npm run demo && npm run build:ami && npm run test",
    "deploy": "npm run build && gh-pages -d dist"
  },
  "devDependencies": {
    "babel-cli": "latest",
    "babel-plugin-add-module-exports": "^0.2.1",
    "babel-polyfill": "^6.13.0",
    "babel-preset-es2015": "^6.13.2",
    "babelify": "7.3.0",
    "browserify": "^13.1.0",
    "cross-env": "^3.2.3",
    "eslint": "latest",
    "eslint-config-google": "latest",
    "gh-pages": "latest",
    "glslify": "5.1.0",
    "jasmine-core": "latest",
    "jsdoc": "jsdoc3/jsdoc#master",
    "karma": "latest",
    "karma-browserify": "latest",
    "karma-jasmine": "latest",
    "karma-phantomjs-launcher": "1.0.4",
    "karma-sinon": "^1.0.5",
    "karma-spec-reporter": "latest",
    "live-server": "^1.1.0",
    "phantomjs-prebuilt": "2.1.14",
    "rimraf": "^2.6.1",
    "shelljs": "latest",
    "sinon": "^2.0.0",
    "uglify-js": "^2.7.3",
    "watchify": "3.7.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "browserify": {
    "transform": [
      "babelify"
    ]
  }
}

},{}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cameras = require('./cameras/cameras');

var _cameras2 = _interopRequireDefault(_cameras);

var _controls = require('./controls/controls');

var _controls2 = _interopRequireDefault(_controls);

var _core = require('./core/core');

var _core2 = _interopRequireDefault(_core);

var _geometries = require('./geometries/geometries');

var _geometries2 = _interopRequireDefault(_geometries);

var _helpers = require('./helpers/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _loaders = require('./loaders/loaders');

var _loaders2 = _interopRequireDefault(_loaders);

var _models = require('./models/models');

var _models2 = _interopRequireDefault(_models);

var _parsers = require('./parsers/parsers');

var _parsers2 = _interopRequireDefault(_parsers);

var _shaders = require('./shaders/shaders');

var _shaders2 = _interopRequireDefault(_shaders);

var _widgets = require('./widgets/widgets');

var _widgets2 = _interopRequireDefault(_widgets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pckg = require('../package.json');

exports.default = {
  Cameras: _cameras2.default,
  Controls: _controls2.default,
  Core: _core2.default,
  Geometries: _geometries2.default,
  Helpers: _helpers2.default,
  Loaders: _loaders2.default,
  Models: _models2.default,
  Parsers: _parsers2.default,
  Shaders: _shaders2.default,
  Widgets: _widgets2.default
};


window.console.log('AMI ' + pckg.version + ' ( ThreeJS ' + pckg.config.threeVersion + ')');

},{"../package.json":94,"./cameras/cameras":96,"./controls/controls":98,"./core/core":103,"./geometries/geometries":107,"./helpers/helpers":112,"./loaders/loaders":128,"./models/models":132,"./parsers/parsers":137,"./shaders/shaders":155,"./widgets/widgets":169}],96:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cameras = require('./cameras.orthographic');

var _cameras2 = _interopRequireDefault(_cameras);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module cameras
 */
exports.default = {
  Orthographic: _cameras2.default
};

},{"./cameras.orthographic":97}],97:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('../core/core.validators');

var _core4 = _interopRequireDefault(_core3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Orthographic camera from THREE.JS with some extra convenience
 * functionalities.
 *
 * @example
 * //
 * //
 *
 * @module cameras/orthographic
 */
var CamerasOrthographic = function (_THREE$OrthographicCa) {
  _inherits(CamerasOrthographic, _THREE$OrthographicCa);

  function CamerasOrthographic(left, right, top, bottom, near, far) {
    _classCallCheck(this, CamerasOrthographic);

    var _this = _possibleConstructorReturn(this, (CamerasOrthographic.__proto__ || Object.getPrototypeOf(CamerasOrthographic)).call(this, left, right, top, bottom, near, far));

    _this._front = null;
    _this._back = null;

    _this._directions = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];

    _this._directionsLabel = ['A', 'P', // TOP/BOTTOM
    'L', 'R', // LEFT/RIGHT
    'I', 'S'];

    _this._orientation = 'default';
    _this._convention = 'radio';
    _this._stackOrientation = 0;

    _this._right = null;
    _this._up = null;
    _this._direction = null;

    _this._controls = null;
    _this._box = null;
    _this._canvas = {
      width: null,
      height: null
    };

    _this._fromFront = true;
    _this._angle = 0;
    return _this;
  }

  /**
   * Initialize orthographic camera variables
   */


  _createClass(CamerasOrthographic, [{
    key: 'init',
    value: function init(xCosine, yCosine, zCosine, controls, box, canvas) {
      // DEPRECATED
      console.warn('cameras.orthographic.init(...) is deprecated.\n      Use .cosines, .controls, .box and .canvas instead.');

      //
      if (!(_core4.default.vector3(xCosine) && _core4.default.vector3(yCosine) && _core4.default.vector3(zCosine) && _core4.default.box(box) && controls)) {
        window.console.log('Invalid input provided.');

        return false;
      }

      this._right = xCosine;
      this._up = this._adjustTopDirection(xCosine, yCosine);
      this._direction = new THREE.Vector3().crossVectors(this._right, this._up);
      this._controls = controls;
      this._box = box;
      this._canvas = canvas;

      var ray = {
        position: this._box.center,
        direction: this._direction
      };

      var intersections = this._orderIntersections(_core2.default.rayBox(ray, this._box), this._direction);
      this._front = intersections[0];
      this._back = intersections[1];

      // set default values
      this.up.set(this._up.x, this._up.y, this._up.z);
      this._updateCanvas();
      this._updatePositionAndTarget(this._front, this._back);
      this._updateMatrices();
      this._updateDirections();
    }
  }, {
    key: 'update',
    value: function update() {
      // http://www.grahamwideman.com/gw/brain/orientation/orientterms.htm
      // do magics depending on orientation and convention
      // also needs a default mode

      if (this._orientation === 'default') {
        switch (this._getMaxIndex(this._directions[2])) {

          case 0:
            this._orientation = 'sagittal';
            break;

          case 1:
            this._orientation = 'coronal';
            break;

          case 2:
            this._orientation = 'axial';
            break;

          default:
            this._orientation = 'free';
            break;
        }
      }

      if (this._orientation === 'free') {
        this._right = this._directions[0];
        this._up = this._directions[1];
        this._direction = this._directions[2];
      } else {
        var leftIndex = this.leftDirection();
        var leftDirection = this._directions[leftIndex];
        var posteriorIndex = this.posteriorDirection();
        var posteriorDirection = this._directions[posteriorIndex];
        var superiorIndex = this.superiorDirection();
        var superiorDirection = this._directions[superiorIndex];

        if (this._convention === 'radio') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards superior
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards posterior
              if (posteriorDirection.y < 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn('"' + this._orientation + '" orientation is not valid.\n                (choices: axial, coronal, sagittal)');
              break;

          }
        } else if (this._convention === 'neuro') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards inferior
              if (superiorDirection.z > 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards anterior
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn('"' + this._orientation + '" orientation is not valid.\n                (choices: axial, coronal, sagittal)');
              break;
          }
        } else {
          console.warn(this._convention + ' is not valid (choices: radio, neuro)');
        }
      }

      // that is what determines left/right
      var ray = {
        position: this._box.center,
        direction: this._direction
      };

      var intersections = this._orderIntersections(_core2.default.rayBox(ray, this._box), this._direction);
      this._front = intersections[0];
      this._back = intersections[1];

      // set default values
      this.up.set(this._up.x, this._up.y, this._up.z);
      this._updateCanvas();
      this._updatePositionAndTarget(this._front, this._back);
      this._updateMatrices();
      this._updateDirections();
    }
  }, {
    key: 'leftDirection',
    value: function leftDirection() {
      return this._findMaxIndex(this._directions, 0);
    }
  }, {
    key: 'posteriorDirection',
    value: function posteriorDirection() {
      return this._findMaxIndex(this._directions, 1);
    }
  }, {
    key: 'superiorDirection',
    value: function superiorDirection() {
      return this._findMaxIndex(this._directions, 2);
    }

    /**
     * Invert rows in the current slice.
     * Inverting rows in 2 steps:
     *   * Flip the "up" vector
     *   * Look at the slice from the other side
     */

  }, {
    key: 'invertRows',
    value: function invertRows() {
      // flip "up" vector
      // we flip up first because invertColumns update projectio matrices
      this.up.multiplyScalar(-1);
      this.invertColumns();

      this._updateDirections();
    }

    /**
     * Invert rows in the current slice.
     * Inverting rows in 1 step:
     *   * Look at the slice from the other side
     */

  }, {
    key: 'invertColumns',
    value: function invertColumns() {
      this.center();
      // rotate 180 degrees around the up vector...
      var oppositePosition = this._oppositePosition(this.position);

      // update posistion and target
      // clone is needed because this.position is overwritten in method
      this._updatePositionAndTarget(oppositePosition, this.position.clone());
      this._updateMatrices();
      this._fromFront = !this._fromFront;

      this._angle %= 360;
      this._angle = 360 - this._angle;

      this._updateDirections();
    }

    /**
     * Center slice in the camera FOV.
     * It also updates the controllers properly.
     * We can center a camera from the front or from the back.
     */

  }, {
    key: 'center',
    value: function center() {
      if (this._fromFront) {
        this._updatePositionAndTarget(this._front, this._back);
      } else {
        this._updatePositionAndTarget(this._back, this._front);
      }

      this._updateMatrices();
      this._updateDirections();
    }

    /**
     * Pi/2 rotation around the zCosine axis.
     * Clock-wise rotation from the user point of view.
     */

  }, {
    key: 'rotate',
    value: function rotate() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.center();

      var computedAngle = 90;

      var clockwise = 1;
      if (!this._fromFront) {
        clockwise = -1;
      }

      if (angle === null) {
        computedAngle *= -clockwise;
        this._angle += 90;
      } else {
        computedAngle = 360 - clockwise * (angle - this._angle);
        this._angle = angle;
      }

      this._angle %= 360;

      // Rotate the up vector around the "zCosine"
      var rotation = new THREE.Matrix4().makeRotationAxis(this._direction, computedAngle * Math.PI / 180);
      this.up.applyMatrix4(rotation);

      this._updateMatrices();
      this._updateDirections();
    }

    // dimensions[0] // width
    // dimensions[1] // height
    // direction= 0 width, 1 height, 2 best
    // factor

  }, {
    key: 'fitBox',
    value: function fitBox() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.5;

      //
      // if (!(dimensions && dimensions.length >= 2)) {
      //   window.console.log('Invalid dimensions container.');
      //   window.console.log(dimensions);

      //   return false;
      // }

      //
      var zoom = 1;

      // update zoom
      switch (direction) {
        case 0:
          zoom = factor * this._computeZoom(this._canvas.width, this._right);
          break;
        case 1:
          zoom = factor * this._computeZoom(this._canvas.height, this._up);
          break;
        case 2:
          zoom = factor * Math.min(this._computeZoom(this._canvas.width, this._right), this._computeZoom(this._canvas.height, this._up));
          break;
        default:
          break;
      }

      if (!zoom) {
        return false;
      }

      this.zoom = zoom;

      this.center();
    }
  }, {
    key: '_adjustTopDirection',
    value: function _adjustTopDirection(horizontalDirection, verticalDirection) {
      var vMaxIndex = this._getMaxIndex(verticalDirection);

      // should handle vMax index === 0
      if (vMaxIndex === 2 && verticalDirection.getComponent(vMaxIndex) < 0 || vMaxIndex === 1 && verticalDirection.getComponent(vMaxIndex) > 0 || vMaxIndex === 0 && verticalDirection.getComponent(vMaxIndex) > 0) {
        verticalDirection.negate();
      }

      return verticalDirection;
    }
  }, {
    key: '_getMaxIndex',
    value: function _getMaxIndex(vector) {
      // init with X value
      var maxValue = Math.abs(vector.x);
      var index = 0;

      if (Math.abs(vector.y) > maxValue) {
        maxValue = Math.abs(vector.y);
        index = 1;
      }

      if (Math.abs(vector.z) > maxValue) {
        index = 2;
      }

      return index;
    }
  }, {
    key: '_findMaxIndex',
    value: function _findMaxIndex(directions, target) {
      // get index of the most superior direction
      var maxIndices = this._getMaxIndices(directions);

      for (var i = 0; i < maxIndices.length; i++) {
        if (maxIndices[i] === target) {
          return i;
        }
      }
    }
  }, {
    key: '_getMaxIndices',
    value: function _getMaxIndices(directions) {
      var indices = [];
      indices.push(this._getMaxIndex(directions[0]));
      indices.push(this._getMaxIndex(directions[1]));
      indices.push(this._getMaxIndex(directions[2]));

      return indices;
    }
  }, {
    key: '_orderIntersections',
    value: function _orderIntersections(intersections, direction) {
      var ordered = intersections[0].dot(direction) < intersections[1].dot(direction);

      if (!ordered) {
        return [intersections[1], intersections[0]];
      }

      return intersections;
    }
  }, {
    key: '_updateCanvas',
    value: function _updateCanvas() {
      var camFactor = 2;
      this.left = -this._canvas.width / camFactor;
      this.right = this._canvas.width / camFactor;
      this.top = this._canvas.height / camFactor;
      this.bottom = -this._canvas.height / camFactor;

      this._updateMatrices();
      this.controls.handleResize();
    }
  }, {
    key: '_oppositePosition',
    value: function _oppositePosition(position) {
      var oppositePosition = position.clone();
      // center world postion around box center
      oppositePosition.sub(this._box.center);
      // rotate
      var rotation = new THREE.Matrix4().makeRotationAxis(this.up, Math.PI);

      oppositePosition.applyMatrix4(rotation);
      // translate back to world position
      oppositePosition.add(this._box.center);
      return oppositePosition;
    }
  }, {
    key: '_computeZoom',
    value: function _computeZoom(dimension, direction) {
      if (!(dimension && dimension > 0)) {
        window.console.log('Invalid dimension provided.');
        window.console.log(dimension);
        return false;
      }

      // ray
      var ray = {
        position: this._box.center.clone(),
        direction: direction
      };

      var intersections = _core2.default.rayBox(ray, this._box);
      if (intersections.length < 2) {
        window.console.log('Can not adjust the camera ( < 2 intersections).');
        window.console.log(ray);
        window.console.log(this._box);
        return false;
      }

      return dimension / intersections[0].distanceTo(intersections[1]);
    }
  }, {
    key: '_updatePositionAndTarget',
    value: function _updatePositionAndTarget(position, target) {
      // position
      this.position.set(position.x, position.y, position.z);

      // targets
      this.lookAt(target.x, target.y, target.z);
      this._controls.target.set(target.x, target.y, target.z);
    }
  }, {
    key: '_updateMatrices',
    value: function _updateMatrices() {
      this._controls.update();
      // THEN camera
      this.updateProjectionMatrix();
      this.updateMatrixWorld();
    }
  }, {
    key: '_updateLabels',
    value: function _updateLabels() {
      this._directionsLabel = [this._vector2Label(this._up), this._vector2Label(this._up.clone().negate()), this._vector2Label(this._right), this._vector2Label(this._right.clone().negate()), this._vector2Label(this._direction), this._vector2Label(this._direction.clone().negate())];
    }
  }, {
    key: '_vector2Label',
    value: function _vector2Label(direction) {
      var index = this._getMaxIndex(direction);
      // set vector max value to 1
      var scaledDirection = direction.clone().divideScalar(Math.abs(direction.getComponent(index)));
      var delta = 0.2;
      var label = '';

      // loop through components of the vector
      for (var i = 0; i < 3; i++) {
        if (i === 0) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'L';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'R';
          }
        }

        if (i === 1) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'P';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'A';
          }
        }

        if (i === 2) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'S';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'I';
          }
        }
      }

      return label;
    }
  }, {
    key: '_updateDirections',
    value: function _updateDirections() {
      // up is correct
      this._up = this.up.clone();

      // direction
      var pLocal = new THREE.Vector3(0, 0, -1);
      var pWorld = pLocal.applyMatrix4(this.matrixWorld);
      this._direction = pWorld.sub(this.position).normalize();

      // right
      this._right = new THREE.Vector3().crossVectors(this._direction, this.up);

      // update labels accordingly
      this._updateLabels();
    }
  }, {
    key: 'controls',
    set: function set(controls) {
      this._controls = controls;
    },
    get: function get() {
      return this._controls;
    }
  }, {
    key: 'box',
    set: function set(box) {
      this._box = box;
    },
    get: function get() {
      return this._box;
    }
  }, {
    key: 'canvas',
    set: function set(canvas) {
      this._canvas = canvas;
      this._updateCanvas();
    },
    get: function get() {
      return this._canvas;
    }
  }, {
    key: 'angle',
    set: function set(angle) {
      this.rotate(angle);
    },
    get: function get() {
      return this._angle;
    }
  }, {
    key: 'directions',
    set: function set(directions) {
      this._directions = directions;
    },
    get: function get() {
      return this._directions;
    }
  }, {
    key: 'convention',
    set: function set(convention) {
      this._convention = convention;
    },
    get: function get() {
      return this._convention;
    }
  }, {
    key: 'orientation',
    set: function set(orientation) {
      this._orientation = orientation;
    },
    get: function get() {
      return this._orientation;
    }
  }, {
    key: 'directionsLabel',
    set: function set(directionsLabel) {
      this._directionsLabel = directionsLabel;
    },
    get: function get() {
      return this._directionsLabel;
    }
  }, {
    key: 'stackOrientation',
    set: function set(stackOrientation) {
      this._stackOrientation = stackOrientation;

      if (this._stackOrientation === 0) {
        this._orientation = 'default';
      } else {
        var maxIndex = this._getMaxIndex(this._directions[(this._stackOrientation + 2) % 3]);

        if (maxIndex === 0) {
          this._orientation = 'sagittal';
        } else if (maxIndex === 1) {
          this._orientation = 'coronal';
        } else if (maxIndex === 2) {
          this._orientation = 'axial';
        }
      }
    },
    get: function get() {
      //
      if (this._orientation === 'default') {
        this._stackOrientation = 0;
      } else {
        var maxIndex = this._getMaxIndex(this._direction);

        if (maxIndex === this._getMaxIndex(this._directions[2])) {
          this._stackOrientation = 0;
        } else if (maxIndex === this._getMaxIndex(this._directions[0])) {
          this._stackOrientation = 1;
        } else if (maxIndex === this._getMaxIndex(this._directions[1])) {
          this._stackOrientation = 2;
        }
      }

      return this._stackOrientation;
    }
  }]);

  return CamerasOrthographic;
}(THREE.OrthographicCamera);

exports.default = CamerasOrthographic;

},{"../core/core.intersections":102,"../core/core.validators":106}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _controls = require('./controls.trackball');

var _controls2 = _interopRequireDefault(_controls);

var _controls3 = require('./controls.trackballortho');

var _controls4 = _interopRequireDefault(_controls3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  Trackball: _controls2.default,
  TrackballOrtho: _controls4.default
};

},{"./controls.trackball":99,"./controls.trackballortho":100}],99:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Original authors from THREEJS repo
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Simone Manini / http://daron1337.github.io
 * @author Luca Antiga  / http://lantiga.github.io
 */

var Trackball = function (_THREE$EventDispatche) {
  _inherits(Trackball, _THREE$EventDispatche);

  function Trackball(object, domElement) {
    _classCallCheck(this, Trackball);

    var _this2 = _possibleConstructorReturn(this, (Trackball.__proto__ || Object.getPrototypeOf(Trackball)).call(this));

    var _this = _this2;
    var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5, CUSTOM: 99 };

    _this2.object = object;
    _this2.domElement = domElement !== undefined ? domElement : document;

    // API

    _this2.enabled = true;

    _this2.screen = { left: 0, top: 0, width: 0, height: 0 };

    _this2.rotateSpeed = 1.0;
    _this2.zoomSpeed = 1.2;
    _this2.panSpeed = 0.3;

    _this2.noRotate = false;
    _this2.noZoom = false;
    _this2.noPan = false;
    _this2.noCustom = false;

    _this2.forceState = -1;

    _this2.staticMoving = false;
    _this2.dynamicDampingFactor = 0.2;

    _this2.minDistance = 0;
    _this2.maxDistance = Infinity;

    _this2.keys = [65 /* A*/, 83 /* S*/, 68];

    // internals

    _this2.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _movePrev = new THREE.Vector2(),
        _moveCurr = new THREE.Vector2(),
        _lastAxis = new THREE.Vector3(),
        _lastAngle = 0,
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2(),
        _customStart = new THREE.Vector2(),
        _customEnd = new THREE.Vector2();

    // for reset

    _this2.target0 = _this2.target.clone();
    _this2.position0 = _this2.object.position.clone();
    _this2.up0 = _this2.object.up.clone();

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    // methods

    _this2.handleResize = function () {
      if (this.domElement === document) {
        this.screen.left = 0;
        this.screen.top = 0;
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
      } else {
        var box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
      }
    };

    _this2.handleEvent = function (event) {
      if (typeof this[event.type] == 'function') {
        this[event.type](event);
      }
    };

    var getMouseOnScreen = function () {
      var vector = new THREE.Vector2();

      return function (pageX, pageY) {
        vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

        return vector;
      };
    }();

    var getMouseOnCircle = function () {
      var vector = new THREE.Vector2();

      return function (pageX, pageY) {
        vector.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5), (_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width);

        return vector;
      };
    }();

    _this2.rotateCamera = function () {
      var axis = new THREE.Vector3(),
          quaternion = new THREE.Quaternion(),
          eyeDirection = new THREE.Vector3(),
          objectUpDirection = new THREE.Vector3(),
          objectSidewaysDirection = new THREE.Vector3(),
          moveDirection = new THREE.Vector3(),
          angle = void 0;

      return function () {
        moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
        angle = moveDirection.length();

        if (angle) {
          _eye.copy(_this.object.position).sub(_this.target);

          eyeDirection.copy(_eye).normalize();
          objectUpDirection.copy(_this.object.up).normalize();
          objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();

          objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
          objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);

          moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));

          axis.crossVectors(moveDirection, _eye).normalize();

          angle *= _this.rotateSpeed;
          quaternion.setFromAxisAngle(axis, angle);

          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);

          _lastAxis.copy(axis);
          _lastAngle = angle;
        } else if (!_this.staticMoving && _lastAngle) {
          _lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);
          _eye.copy(_this.object.position).sub(_this.target);
          quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);
        }

        _movePrev.copy(_moveCurr);
      };
    }();

    _this2.zoomCamera = function () {
      var factor = void 0;

      if (_state === STATE.TOUCH_ZOOM) {
        factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;
        _eye.multiplyScalar(factor);
      } else {
        factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

        if (factor !== 1.0 && factor > 0.0) {
          _eye.multiplyScalar(factor);

          if (_this.staticMoving) {
            _zoomStart.copy(_zoomEnd);
          } else {
            _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
          }
        }
      }
    };

    _this2.panCamera = function () {
      var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();

      return function () {
        mouseChange.copy(_panEnd).sub(_panStart);

        if (mouseChange.lengthSq()) {
          mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

          pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

          _this.object.position.add(pan);
          _this.target.add(pan);

          if (_this.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
          }
        }
      };
    }();

    _this2.checkDistances = function () {
      if (!_this.noZoom || !_this.noPan) {
        if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {
          _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));
        }

        if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {
          _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));
        }
      }
    };

    _this2.update = function () {
      _eye.subVectors(_this.object.position, _this.target);

      if (!_this.noRotate) {
        _this.rotateCamera();
      }

      if (!_this.noZoom) {
        _this.zoomCamera();
      }

      if (!_this.noPan) {
        _this.panCamera();
      }

      if (!_this.noCustom) {
        _this.custom(_customStart, _customEnd);
      }

      _this.object.position.addVectors(_this.target, _eye);

      _this.checkDistances();

      _this.object.lookAt(_this.target);

      if (lastPosition.distanceToSquared(_this.object.position) > EPS) {
        _this.dispatchEvent(changeEvent);

        lastPosition.copy(_this.object.position);
      }
    };

    _this2.reset = function () {
      _state = STATE.NONE;
      _prevState = STATE.NONE;

      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.up.copy(_this.up0);

      _eye.subVectors(_this.object.position, _this.target);

      _this.object.lookAt(_this.target);

      _this.dispatchEvent(changeEvent);

      lastPosition.copy(_this.object.position);
    };

    _this2.setState = function (targetState) {
      _this.forceState = targetState;
      _prevState = targetState;
      _state = targetState;
    };

    _this2.custom = function (customStart, customEnd) {};

    // listeners

    function keydown(event) {
      if (_this.enabled === false) return;

      window.removeEventListener('keydown', keydown);

      _prevState = _state;

      if (_state !== STATE.NONE) {
        return;
      } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
        _state = STATE.ROTATE;
      } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
        _state = STATE.ZOOM;
      } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
        _state = STATE.PAN;
      }
    }

    function keyup(event) {
      if (_this.enabled === false) return;

      _state = _prevState;

      window.addEventListener('keydown', keydown, false);
    }

    function mousedown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.NONE) {
        _state = event.button;
      }

      if (_state === STATE.ROTATE && !_this.noRotate) {
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
        _movePrev.copy(_moveCurr);
      } else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      } else if (_state === STATE.CUSTOM && !_this.noCustom) {
        _customStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _customEnd.copy(_panStart);
      }

      document.addEventListener('mousemove', mousemove, false);
      document.addEventListener('mouseup', mouseup, false);

      _this.dispatchEvent(startEvent);
    }

    function mousemove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.ROTATE && !_this.noRotate) {
        _movePrev.copy(_moveCurr);
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
      } else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.CUSTOM && !_this.noCustom) {
        _customEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }

    function mouseup(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_this.forceState === -1) {
        _state = STATE.NONE;
      }

      document.removeEventListener('mousemove', mousemove);
      document.removeEventListener('mouseup', mouseup);
      _this.dispatchEvent(endEvent);
    }

    function mousewheel(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta / 40;
      } else if (event.detail) {
        // Firefox

        delta = -event.detail / 3;
      }

      if (_state !== STATE.CUSTOM) {
        _zoomStart.y += delta * 0.01;
      } else if (_state === STATE.CUSTOM) {
        _customStart.y += delta * 0.01;
      }

      _this.dispatchEvent(startEvent);
      _this.dispatchEvent(endEvent);
    }

    function touchstart(event) {
      if (_this.enabled === false) return;

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;

          case 2:
            _state = STATE.TOUCH_ZOOM;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panStart.copy(getMouseOnScreen(x, y));
            _panEnd.copy(_panStart);
            break;

          default:
            _state = STATE.NONE;

        }
      } else {
        // { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, CUSTOM: 99 };
        switch (_state) {

          case 0:
            // 1 or 2 fingers, smae behavior
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;

          case 1:
          case 4:
            if (event.touches.length >= 2) {
              _state = STATE.TOUCH_ZOOM;
              var dx = event.touches[0].pageX - event.touches[1].pageX;
              var dy = event.touches[0].pageY - event.touches[1].pageY;
              _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
            } else {
              _state = STATE.ZOOM;
              _zoomStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
              _zoomEnd.copy(_zoomStart);
            }
            break;

          case 2:
          case 5:
            if (event.touches.length >= 2) {
              _state = STATE.TOUCH_PAN;
              var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
              _panStart.copy(getMouseOnScreen(x, y));
              _panEnd.copy(_panStart);
            } else {
              _state = STATE.PAN;
              _panStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
              _panEnd.copy(_panStart);
            }
            break;

          case 99:
            _state = STATE.CUSTOM;
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customStart.copy(getMouseOnScreen(x, y));
            _customEnd.copy(_customStart);
            break;

          default:
            _state = STATE.NONE;

        }
      }

      _this.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;

          default:
            _state = STATE.NONE;
        }
      } else {
        // { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, CUSTOM: 99 };
        switch (_state) {

          case 0:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 1:
            _zoomEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            _panEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 4:
            // 2 fingers!
            // TOUCH ZOOM
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
            break;

          case 5:
            // 2 fingers
            // TOUCH_PAN
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;

          case 99:
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customEnd.copy(getMouseOnScreen(x, y));
            break;

          default:
            _state = STATE.NONE;

        }
      }
    }

    function touchend(event) {
      if (_this.enabled === false) return;

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            _panStart.copy(_panEnd);
            break;

        }

        _state = STATE.NONE;
      } else {
        switch (_state) {

          case 0:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 1:
          case 2:
            break;

          case 4:
            // TOUCH ZOOM
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
            _state = STATE.ZOOM;
            break;

          case 5:
            // TOUCH ZOOM
            if (event.touches.length >= 2) {
              var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
              _panEnd.copy(getMouseOnScreen(x, y));
              _panStart.copy(_panEnd);
            }
            _state = STATE.PAN;
            break;

          case 99:
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customEnd.copy(getMouseOnScreen(x, y));
            _customStart.copy(_customEnd);
            break;

          default:
            _state = STATE.NONE;

        }
      }

      _this.dispatchEvent(endEvent);
    }

    _this2.domElement.addEventListener('contextmenu', function (event) {
      event.preventDefault();
    }, false);

    _this2.domElement.addEventListener('mousedown', mousedown, false);

    _this2.domElement.addEventListener('mousewheel', mousewheel, false);
    _this2.domElement.addEventListener('DOMMouseScroll', mousewheel, false); // firefox

    _this2.domElement.addEventListener('touchstart', touchstart, false);
    _this2.domElement.addEventListener('touchend', touchend, false);
    _this2.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    _this2.handleResize();

    // force an update at start
    _this2.update();
    return _this2;
  }

  return Trackball;
}(THREE.EventDispatcher);

exports.default = Trackball;

},{}],100:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Patrick Fuller / http://patrick-fuller.com
 * @author Max Smolens / https://github.com/msmolens
 */

var Trackballortho = function (_THREE$EventDispatche) {
  _inherits(Trackballortho, _THREE$EventDispatche);

  function Trackballortho(object, domElement) {
    var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { NONE: -1, ROTATE: 1, ZOOM: 2, PAN: 0, SCROLL: 4, TOUCH_ROTATE: 4, TOUCH_ZOOM_PAN: 5 };

    _classCallCheck(this, Trackballortho);

    var _this2 = _possibleConstructorReturn(this, (Trackballortho.__proto__ || Object.getPrototypeOf(Trackballortho)).call(this));

    var _this = _this2;
    var STATE = state;

    _this2.object = object;
    _this2.domElement = domElement !== undefined ? domElement : document;

    // API

    _this2.enabled = true;

    _this2.screen = { left: 0, top: 0, width: 0, height: 0 };

    _this2.radius = 0;

    _this2.zoomSpeed = 1.2;

    _this2.noZoom = false;
    _this2.noPan = false;

    _this2.staticMoving = false;
    _this2.dynamicDampingFactor = 0.2;

    _this2.keys = [65 /* A*/, 83 /* S*/, 68];

    // internals

    _this2.target = new THREE.Vector3();

    var EPS = 0.000001;

    var _changed = true;

    var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2();

    // window level fire after...

    // for reset

    _this2.target0 = _this2.target.clone();
    _this2.position0 = _this2.object.position.clone();
    _this2.up0 = _this2.object.up.clone();

    _this2.left0 = _this2.object.left;
    _this2.right0 = _this2.object.right;
    _this2.top0 = _this2.object.top;
    _this2.bottom0 = _this2.object.bottom;

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    // methods

    _this2.handleResize = function () {
      if (this.domElement === document) {
        this.screen.left = 0;
        this.screen.top = 0;
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
      } else {
        var box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
      }

      this.radius = 0.5 * Math.min(this.screen.width, this.screen.height);

      this.left0 = this.object.left;
      this.right0 = this.object.right;
      this.top0 = this.object.top;
      this.bottom0 = this.object.bottom;
    };

    _this2.handleEvent = function (event) {
      if (typeof this[event.type] == 'function') {
        this[event.type](event);
      }
    };

    var getMouseOnScreen = function () {
      var vector = new THREE.Vector2();

      return function getMouseOnScreen(pageX, pageY) {
        vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

        return vector;
      };
    }();

    _this2.zoomCamera = function () {
      if (_state === STATE.TOUCH_ZOOM_PAN) {
        var factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;

        _this.object.zoom *= factor;

        _changed = true;
      } else {
        var factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

        if (Math.abs(factor - 1.0) > EPS && factor > 0.0) {
          _this.object.zoom /= factor;

          if (_this.staticMoving) {
            _zoomStart.copy(_zoomEnd);
          } else {
            _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
          }

          _changed = true;
        }
      }
    };

    _this2.panCamera = function () {
      var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();

      return function panCamera() {
        mouseChange.copy(_panEnd).sub(_panStart);

        if (mouseChange.lengthSq()) {
          // Scale movement to keep clicked/dragged position under cursor
          var scale_x = (_this.object.right - _this.object.left) / _this.object.zoom;
          var scale_y = (_this.object.top - _this.object.bottom) / _this.object.zoom;
          mouseChange.x *= scale_x;
          mouseChange.y *= scale_y;

          pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

          _this.object.position.add(pan);
          _this.target.add(pan);

          if (_this.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
          }

          _changed = true;
        }
      };
    }();

    _this2.update = function () {
      _eye.subVectors(_this.object.position, _this.target);

      if (!_this.noZoom) {
        _this.zoomCamera();

        if (_changed) {
          _this.object.updateProjectionMatrix();
        }
      }

      if (!_this.noPan) {
        _this.panCamera();
      }

      _this.object.position.addVectors(_this.target, _eye);

      _this.object.lookAt(_this.target);

      if (_changed) {
        _this.dispatchEvent(changeEvent);

        _changed = false;
      }
    };

    _this2.reset = function () {
      _state = STATE.NONE;
      _prevState = STATE.NONE;

      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.up.copy(_this.up0);

      _eye.subVectors(_this.object.position, _this.target);

      _this.object.left = _this.left0;
      _this.object.right = _this.right0;
      _this.object.top = _this.top0;
      _this.object.bottom = _this.bottom0;

      _this.object.lookAt(_this.target);

      _this.dispatchEvent(changeEvent);

      _changed = false;
    };

    // listeners

    function keydown(event) {
      if (_this.enabled === false) return;

      window.removeEventListener('keydown', keydown);

      _prevState = _state;

      if (_state !== STATE.NONE) {
        return;
      } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
        _state = STATE.ROTATE;
      } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
        _state = STATE.ZOOM;
      } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
        _state = STATE.PAN;
      }
    }

    function keyup(event) {
      if (_this.enabled === false) return;

      _state = _prevState;

      window.addEventListener('keydown', keydown, false);
    }

    function mousedown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.NONE) {
        _state = event.button;
      }

      if (_state === STATE.ROTATE && !_this.noRotate) {} else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      }

      document.addEventListener('mousemove', mousemove, false);
      document.addEventListener('mouseup', mouseup, false);

      _this.dispatchEvent(startEvent);
    }

    function mousemove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.ROTATE && !_this.noRotate) {} else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }

    function mouseup(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      _state = STATE.NONE;

      document.removeEventListener('mousemove', mousemove);
      document.removeEventListener('mouseup', mouseup);
      _this.dispatchEvent(endEvent);
    }

    function mousewheel(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta / 40;
      } else if (event.detail) {
        // Firefox

        delta = -event.detail / 3;
      }

      // FIRE SCROLL EVENT

      _this.dispatchEvent({
        type: 'OnScroll',
        delta: delta
      });

      // _zoomStart.y += delta * 0.01;
      _this.dispatchEvent(startEvent);
      _this.dispatchEvent(endEvent);
    }

    function touchstart(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {

        case 1:
          _state = STATE.TOUCH_ROTATE;

          break;

        case 2:
          _state = STATE.TOUCH_ZOOM_PAN;
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panStart.copy(getMouseOnScreen(x, y));
          _panEnd.copy(_panStart);
          break;

        default:
          _state = STATE.NONE;

      }
      _this.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      switch (event.touches.length) {

        case 1:

          break;

        case 2:
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          break;

        default:
          _state = STATE.NONE;

      }
    }

    function touchend(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {

        case 1:

          break;

        case 2:
          _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          _panStart.copy(_panEnd);
          break;

      }

      _state = STATE.NONE;
      _this.dispatchEvent(endEvent);
    }

    function contextmenu(event) {
      event.preventDefault();
    }

    _this2.dispose = function () {
      this.domElement.removeEventListener('contextmenu', contextmenu, false);
      this.domElement.removeEventListener('mousedown', mousedown, false);
      this.domElement.removeEventListener('mousewheel', mousewheel, false);
      this.domElement.removeEventListener('MozMousePixelScroll', mousewheel, false); // firefox

      this.domElement.removeEventListener('touchstart', touchstart, false);
      this.domElement.removeEventListener('touchend', touchend, false);
      this.domElement.removeEventListener('touchmove', touchmove, false);

      document.removeEventListener('mousemove', mousemove, false);
      document.removeEventListener('mouseup', mouseup, false);

      window.removeEventListener('keydown', keydown, false);
      window.removeEventListener('keyup', keyup, false);
    };

    _this2.domElement.addEventListener('contextmenu', contextmenu, false);
    _this2.domElement.addEventListener('mousedown', mousedown, false);
    _this2.domElement.addEventListener('mousewheel', mousewheel, false);
    _this2.domElement.addEventListener('MozMousePixelScroll', mousewheel, false); // firefox

    _this2.domElement.addEventListener('touchstart', touchstart, false);
    _this2.domElement.addEventListener('touchend', touchend, false);
    _this2.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    _this2.handleResize();

    // force an update at start
    _this2.update();
    return _this2;
  }

  return Trackballortho;
}(THREE.EventDispatcher);

exports.default = Trackballortho;

},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Colors utility functions
 */
var Colors = function () {
  function Colors() {
    _classCallCheck(this, Colors);
  }

  _createClass(Colors, null, [{
    key: "cielab2XYZ",


    /**
     * Convert LAB to XYZ
     * http://www.easyrgb.com/index.php?X=MATH&H=08#text8
     *
     * @param {*} l
     * @param {*} a
     * @param {*} b
     *
     * @return {*}
     */
    value: function cielab2XYZ(l, a, b) {
      var refX = 95.047;
      var refY = 100.00;
      var refZ = 108.883;

      var y = (l + 16) / 116;
      var x = a / 500 + y;
      var z = y - b / 200;

      if (Math.pow(y, 3) > 0.008856) {
        y = Math.pow(y, 3);
      } else {
        y = (y - 16 / 116) / 7.787;
      }

      if (Math.pow(x, 3) > 0.008856) {
        x = Math.pow(x, 3);
      } else {
        x = (x - 16 / 116) / 7.787;
      }

      if (Math.pow(z, 3) > 0.008856) {
        z = Math.pow(z, 3);
      } else {
        z = (z - 16 / 116) / 7.787;
      }

      return [refX * x, refY * y, refZ * z];
    }

    /**
     * Convert XYZ to RGB space
     *
     * @param {*} x
     * @param {*} y
     * @param {*} z
     *
     * @return {*}
     */

  }, {
    key: "xyz2RGB",
    value: function xyz2RGB(x, y, z) {
      x /= 100;
      y /= 100;
      z /= 100;
      var r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      var g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      var b = x * 0.0557 + y * -0.2040 + z * 1.0570;

      if (r > 0.0031308) {
        r = 1.055 * Math.pow(r, 1 / 2.4) - 0.055;
      } else {
        r = 12.92 * r;
      }

      if (g > 0.0031308) {
        g = 1.055 * Math.pow(g, 1 / 2.4) - 0.055;
      } else {
        g = 12.92 * g;
      }

      if (b > 0.0031308) {
        b = 1.055 * Math.pow(b, 1 / 2.4) - 0.055;
      } else {
        b = 12.92 * b;
      }

      r = r * 255;
      g = g * 255;
      b = b * 255;

      return [r, g, b];
    }

    /**
     * Convert LAB to RGB
     *
     * @param {*} l
     * @param {*} a
     * @param {*} b
     *
     * @return {*}
     */

  }, {
    key: "cielab2RGB",
    value: function cielab2RGB() {
      var l = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (!(l >= 0 && l <= 100)) {
        return null;
      }

      var xyz = this.cielab2XYZ(l, a, b);
      return this.xyz2RGB.apply(this, _toConsumableArray(xyz));
    }
  }]);

  return Colors;
}();

exports.default = Colors;

},{}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('./core.utils');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('./core.validators');

var _core4 = _interopRequireDefault(_core3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Compute/test intersection between different objects.
 *
 * @module core/intersections
 */

var Intersections = function () {
  function Intersections() {
    _classCallCheck(this, Intersections);
  }

  _createClass(Intersections, null, [{
    key: 'aabbPlane',


    /**
     * Compute intersection between oriented bounding box and a plane.
     *
     * Returns intersection in plane's space.
     *
     * Should return at least 3 intersections. If not, the plane and the box do not
     * intersect.
     *
     * @param {Object} aabb - Axe Aligned Bounding Box representation.
     * @param {THREE.Vector3} aabb.halfDimensions - Half dimensions of the box.
     * @param {THREE.Vector3} aabb.center - Center of the box.
     * @param {THREE.Matrix4} aabb.toAABB - Transform to go from plane space to box space.
     * @param {Object} plane - Plane representation
     * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
     * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
     *
     * @returns {Array<THREE.Vector3>} List of all intersections in plane's space.
     * @returns {boolean} false is invalid input provided.
     *
     * @example
     * //Returns array with intersection N intersections
     * let aabb = {
     *   center: new THREE.Vector3(150, 150, 150),
     *   halfDimensions: new THREE.Vector3(50, 60, 70),
     *   toAABB: new THREE.Matrix4()
     * }
     * let plane = {
     *   position: new THREE.Vector3(110, 120, 130),
     *   direction: new THREE.Vector3(1, 0, 0)
     * }
     *
     * let intersections = CoreIntersections.aabbPlane(aabb, plane);
     * // intersections ==
     * //[ { x : 110, y : 90,  z : 80 },
     * //  { x : 110, y : 210, z : 220 },
     * //  { x : 110, y : 210, z : 80 },
     * //  { x : 110, y : 90,  z : 220 } ]
     *
     * //Returns empty array with 0 intersections
     * let aabb = {
     *
     * }
     * let plane = {
     *
     * }
     *
     * let intersections = VJS.Core.Validators.matrix4(new THREE.Vector3());
     *
     * //Returns false if invalid input?
     *
     */
    value: function aabbPlane(aabb, plane) {
      //
      // obb = { halfDimensions, orientation, center, toAABB }
      // plane = { position, direction }
      //
      //
      // LOGIC:
      //
      // Test intersection of each edge of the Oriented Bounding Box with the Plane
      //
      // ALL EDGES
      //
      //      .+-------+
      //    .' |     .'|
      //   +---+---+'  |
      //   |   |   |   |
      //   |  ,+---+---+
      //   |.'     | .'
      //   +-------+'
      //
      // SPACE ORIENTATION
      //
      //       +
      //     j |
      //       |
      //       |   i
      //   k  ,+-------+
      //    .'
      //   +
      //
      //
      // 1- Move Plane position and orientation in IJK space
      // 2- Test Edges/ IJK Plane intersections
      // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox

      var intersections = [];

      if (!(this.validateAabb(aabb) && this.validatePlane(plane))) {
        window.console.log('Invalid aabb or plane provided.');
        return false;
      }

      // invert space matrix
      var fromAABB = new THREE.Matrix4();
      fromAABB.getInverse(aabb.toAABB);

      var t1 = plane.direction.clone().applyMatrix4(aabb.toAABB);
      var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(aabb.toAABB);

      var planeAABB = this.posdir(plane.position.clone().applyMatrix4(aabb.toAABB), new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize());

      var bbox = _core2.default.bbox(aabb.center, aabb.halfDimensions);

      var orientation = new THREE.Vector3(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1));

      // 12 edges (i.e. ray)/plane intersection tests
      // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)
      //
      //       +
      //       |
      //       |
      //       |
      //      ,+---+---+
      //    .'
      //   +

      var ray = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      ray.direction = orientation.y;
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      ray.direction = orientation.z;
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE LAST CORNER
      //
      //               +
      //             .'
      //   +-------+'
      //           |
      //           |
      //           |
      //           +
      //

      var ray2 = this.posdir(new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      ray2.direction = orientation.y;
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      ray2.direction = orientation.z;
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE SECOND CORNER
      //
      //               +
      //               |
      //               |
      //               |
      //               +
      //             .'
      //           +'

      var ray3 = this.posdir(new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.y);
      this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

      ray3.direction = orientation.z;
      this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE THIRD CORNER
      //
      //      .+-------+
      //    .'
      //   +
      //
      //
      //
      //

      var ray4 = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

      ray4.direction = orientation.z;
      this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE FOURTH CORNER
      //
      //
      //
      //   +
      //   |
      //   |
      //   |
      //   +-------+

      var ray5 = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

      ray5.direction = orientation.y;
      this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

      // @todo make sure objects are unique...

      // back to original space
      intersections.map(function (element) {
        return element.applyMatrix4(fromAABB);
      });

      return intersections;
    }

    /**
     * Compute intersection between a ray and a plane.
     *
     * @memberOf this
     * @public
     *
     * @param {Object} ray - Ray representation.
     * @param {THREE.Vector3} ray.position - position of normal which describes the ray.
     * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.
     * @param {Object} plane - Plane representation
     * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
     * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
     *
     * @returns {THREE.Vector3|null} Intersection between ray and plane or null.
     */

  }, {
    key: 'rayPlane',
    value: function rayPlane(ray, plane) {
      // ray: {position, direction}
      // plane: {position, direction}

      if (ray.direction.dot(plane.direction) !== 0) {
        //
        // not parallel, move forward
        //
        // LOGIC:
        //
        // Ray equation: P = P0 + tV
        // P = <Px, Py, Pz>
        // P0 = <ray.position.x, ray.position.y, ray.position.z>
        // V = <ray.direction.x, ray.direction.y, ray.direction.z>
        //
        // Therefore:
        // Px = ray.position.x + t*ray.direction.x
        // Py = ray.position.y + t*ray.direction.y
        // Pz = ray.position.z + t*ray.direction.z
        //
        //
        //
        // Plane equation: ax + by + cz + d = 0
        // a = plane.direction.x
        // b = plane.direction.y
        // c = plane.direction.z
        // d = -( plane.direction.x*plane.position.x +
        //        plane.direction.y*plane.position.y +
        //        plane.direction.z*plane.position.z )
        //
        //
        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz
        // 2- find t
        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection
        //
        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) / (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);

        var intersection = new THREE.Vector3(ray.position.x + t * ray.direction.x, ray.position.y + t * ray.direction.y, ray.position.z + t * ray.direction.z);

        return intersection;
      }

      return null;
    }

    /**
     * Compute intersection between a ray and a box
     * @param {Object} ray
     * @param {Object} box
     * @return {Array}
     */

  }, {
    key: 'rayBox',
    value: function rayBox(ray, box) {
      // should also do the space transforms here
      // ray: {position, direction}
      // box: {halfDimensions, center}

      var intersections = [];

      var bbox = _core2.default.bbox(box.center, box.halfDimensions);

      // window.console.log(bbox);

      // X min
      var plane = this.posdir(new THREE.Vector3(bbox.min.x, box.center.y, box.center.z), new THREE.Vector3(-1, 0, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // X max
      plane = this.posdir(new THREE.Vector3(bbox.max.x, box.center.y, box.center.z), new THREE.Vector3(1, 0, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Y min
      plane = this.posdir(new THREE.Vector3(box.center.x, bbox.min.y, box.center.z), new THREE.Vector3(0, -1, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Y max
      plane = this.posdir(new THREE.Vector3(box.center.x, bbox.max.y, box.center.z), new THREE.Vector3(0, 1, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Z min
      plane = this.posdir(new THREE.Vector3(box.center.x, box.center.y, bbox.min.z), new THREE.Vector3(0, 0, -1));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Z max
      plane = this.posdir(new THREE.Vector3(box.center.x, box.center.y, bbox.max.z), new THREE.Vector3(0, 0, 1));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      return intersections;
    }

    /**
     * Intersection between ray and a plane that are in a box.
     * @param {*} ray
     * @param {*} planeAABB
     * @param {*} bbox
     * @param {*} intersections
     */

  }, {
    key: 'rayPlaneInBBox',
    value: function rayPlaneInBBox(ray, planeAABB, bbox, intersections) {
      var intersection = this.rayPlane(ray, planeAABB);
      // window.console.log(intersection);
      if (intersection && this.inBBox(intersection, bbox)) {
        if (!intersections.find(this.findIntersection(intersection))) {
          intersections.push(intersection);
        }
      }
    }

    /**
     * Find intersection in array
     * @param {*} myintersection
     */

  }, {
    key: 'findIntersection',
    value: function findIntersection(myintersection) {
      return function found(element, index, array) {
        if (myintersection.x === element.x && myintersection.y === element.y && myintersection.z === element.z) {
          return true;
        }

        return false;
      };
    }

    /**
     * Is point in box.
     * @param {Object} point
     * @param {Object} bbox
     * @return {Boolean}
     */

  }, {
    key: 'inBBox',
    value: function inBBox(point, bbox) {
      //
      var epsilon = 0.0001;
      if (point && point.x >= bbox.min.x - epsilon && point.y >= bbox.min.y - epsilon && point.z >= bbox.min.z - epsilon && point.x <= bbox.max.x + epsilon && point.y <= bbox.max.y + epsilon && point.z <= bbox.max.z + epsilon) {
        return true;
      }
      return false;
    }
  }, {
    key: 'posdir',
    value: function posdir(position, direction) {
      return { position: position, direction: direction };
    }
  }, {
    key: 'validatePlane',
    value: function validatePlane(plane) {
      //
      if (plane === null) {
        window.console.log('Invalid plane.');
        window.console.log(plane);

        return false;
      }

      if (!_core4.default.vector3(plane.position)) {
        window.console.log('Invalid plane.position.');
        window.console.log(plane.position);

        return false;
      }

      if (!_core4.default.vector3(plane.direction)) {
        window.console.log('Invalid plane.direction.');
        window.console.log(plane.direction);

        return false;
      }

      return true;
    }
  }, {
    key: 'validateAabb',
    value: function validateAabb(aabb) {
      //
      if (aabb === null) {
        window.console.log('Invalid aabb.');
        window.console.log(aabb);
        return false;
      }

      if (!_core4.default.matrix4(aabb.toAABB)) {
        window.console.log('Invalid aabb.toAABB: ');
        window.console.log(aabb.toAABB);

        return false;
      }

      if (!_core4.default.vector3(aabb.center)) {
        window.console.log('Invalid aabb.center.');
        window.console.log(aabb.center);

        return false;
      }

      if (!(_core4.default.vector3(aabb.halfDimensions) && aabb.halfDimensions.x >= 0 && aabb.halfDimensions.y >= 0 && aabb.halfDimensions.z >= 0)) {
        window.console.log('Invalid aabb.halfDimensions.');
        window.console.log(aabb.halfDimensions);

        return false;
      }

      return true;
    }
  }]);

  return Intersections;
}();

exports.default = Intersections;

},{"./core.utils":105,"./core.validators":106}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = require('./core.colors');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('./core.intersections');

var _core4 = _interopRequireDefault(_core3);

var _core5 = require('./core.pack');

var _core6 = _interopRequireDefault(_core5);

var _core7 = require('./core.validators');

var _core8 = _interopRequireDefault(_core7);

var _core9 = require('./core.utils');

var _core10 = _interopRequireDefault(_core9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module core
 */
exports.default = {
  Colors: _core2.default,
  Intersections: _core4.default,
  Utils: _core10.default,
  Validators: _core8.default
};

},{"./core.colors":101,"./core.intersections":102,"./core.pack":104,"./core.utils":105,"./core.validators":106}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Packing functions.
 *
 * @module core/pack */

var Pack = function Pack() {
  _classCallCheck(this, Pack);
};

exports.default = Pack;

},{}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('./core.validators');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var URL = require('url');

/**
 * General purpose functions.
 *
 * @module core/utils
 */
var CoreUtils = function () {
  function CoreUtils() {
    _classCallCheck(this, CoreUtils);
  }

  _createClass(CoreUtils, null, [{
    key: 'bbox',


    /**
     * Generate a bouding box object.
     * @param {THREE.Vector3} center - Center of the box.
     * @param {THREE.Vector3} halfDimensions - Half Dimensions of the box.
     * @return {Object} The bounding box object. {Object.min} is a {THREE.Vector3}
     * containing the min bounds. {Object.max} is a {THREE.Vector3} containing the
     * max bounds.
     * @return {boolean} False input NOT valid.
     * @example
     * // Returns
     * //{ min: { x : 0, y : 0,  z : 0 },
     * //  max: { x : 2, y : 4,  z : 6 }
     * //}
     * VJS.Core.Utils.bbox(
     *   new THREE.Vector3(1, 2, 3), new THREE.Vector3(1, 2, 3));
     *
     * //Returns false
     * VJS.Core.Utils.bbox(new THREE.Vector3(), new THREE.Matrix4());
     *
     */
    value: function bbox(center, halfDimensions) {
      // make sure we have valid inputs
      if (!(_core2.default.vector3(center) && _core2.default.vector3(halfDimensions))) {
        window.console.log('Invalid center or plane halfDimensions.');
        return false;
      }

      // make sure half dimensions are >= 0
      if (!(halfDimensions.x >= 0 && halfDimensions.y >= 0 && halfDimensions.z >= 0)) {
        window.console.log('halfDimensions must be >= 0.');
        window.console.log(halfDimensions);
        return false;
      }

      // min/max bound
      var min = center.clone().sub(halfDimensions);
      var max = center.clone().add(halfDimensions);

      return {
        min: min,
        max: max
      };
    }

    /**
     * Find min/max values in an array
     * @param {Array} data
     * @return {Array}
     */

  }, {
    key: 'minMax',
    value: function minMax() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = data.length;

      for (var index = 0; index < numPixels; index++) {
        var spv = data[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }

    /**
     * Check HTMLElement
     * @param {HTMLElement} obj
     * @return {boolean}
     */

  }, {
    key: 'isElement',
    value: function isElement(obj) {
      try {
        // Using W3 DOM2 (works for FF, Opera and Chrom)
        return obj instanceof HTMLElement;
      } catch (e) {
        // Browsers not supporting W3 DOM2 don't have HTMLElement and
        // an exception is thrown and we end up here. Testing some
        // properties that all elements have. (works on IE7)
        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.nodeType === 1 && _typeof(obj.style) === 'object' && _typeof(obj.ownerDocument) === 'object';
      }
    }

    /**
     * Check string
     * @param {String} str
     * @return {Boolean}
     */

  }, {
    key: 'isString',
    value: function isString(str) {
      return typeof str === 'string' || str instanceof String;
    }

    /**
     * Parse url
     * @param {*} url
     * @return {Object}
     */

  }, {
    key: 'parseUrl',
    value: function parseUrl(url) {
      //
      var data = {};
      data.filename = '';
      data.extension = '';
      data.pathname = '';
      data.query = '';

      var parsedUrl = URL.parse(url);
      data.pathname = parsedUrl.pathname;
      data.query = parsedUrl.query;

      // get file name
      data.filename = data.pathname.split('/').pop();

      // find extension
      var splittedName = data.filename.split('.');
      if (splittedName.length <= 1) {
        data.extension = 'dicom';
      } else {
        data.extension = data.filename.split('.').pop();
      }

      if (!isNaN(data.extension)) {
        data.extension = 'dicom';
      }

      if (data.query && data.query.includes('contentType=application%2Fdicom')) {
        data.extension = 'dicom';
      }

      return data;
    }

    /**
     * Compute IJK to LPS tranform.
     *
     * @param {*} xCos
     * @param {*} yCos
     * @param {*} zCos
     * @param {*} spacing
     * @param {*} origin
     * @param {*} registrationMatrix
     *
     * @return {*}
     */

  }, {
    key: 'ijk2LPS',
    value: function ijk2LPS(xCos, yCos, zCos, spacing, origin) {
      var registrationMatrix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new THREE.Matrix4();

      var ijk2LPS = new THREE.Matrix4();
      ijk2LPS.set(xCos.x * spacing.x, yCos.x * spacing.y, zCos.x * spacing.z, origin.x, xCos.y * spacing.x, yCos.y * spacing.y, zCos.y * spacing.z, origin.y, xCos.z * spacing.x, yCos.z * spacing.y, zCos.z * spacing.z, origin.z, 0, 0, 0, 1);
      ijk2LPS.premultiply(registrationMatrix);

      return ijk2LPS;
    }

    /**
     * Compute AABB to LPS transform.
     * AABB: Axe Aligned Bounding Box.
     *
     * @param {*} xCos
     * @param {*} yCos
     * @param {*} zCos
     * @param {*} origin
     *
     * @return {*}
     */

  }, {
    key: 'aabb2LPS',
    value: function aabb2LPS(xCos, yCos, zCos, origin) {
      var aabb2LPS = new THREE.Matrix4();
      aabb2LPS.set(xCos.x, yCos.x, zCos.x, origin.x, xCos.y, yCos.y, zCos.y, origin.y, xCos.z, yCos.z, zCos.z, origin.z, 0, 0, 0, 1);

      return aabb2LPS;
    }

    /**
     * Transform coordinates from world coordinate to data
     *
     * @param {*} lps2IJK
     * @param {*} worldCoordinates
     *
     * @return {*}
     */

  }, {
    key: 'worldToData',
    value: function worldToData(lps2IJK, worldCoordinates) {
      var dataCoordinate = new THREE.Vector3().copy(worldCoordinates).applyMatrix4(lps2IJK);

      // same rounding in the shaders
      dataCoordinate.addScalar(0.5).floor();

      return dataCoordinate;
    }

    /**
     * Get voxel value
     *
     * @param {*} stack
     * @param {*} coordinate
     *
     * @return {*}
     */

  }, {
    key: 'value',
    value: function value(stack, coordinate) {
      if (coordinate.z >= 0 && coordinate.z < stack._frame.length) {
        return stack._frame[coordinate.z].value(coordinate.x, coordinate.y);
      } else {
        return null;
      }
    }

    /**
     * Apply slope/intercept to a value
     *
     * @param {*} value
     * @param {*} slope
     * @param {*} intercept
     *
     * @return {*}
     */

  }, {
    key: 'rescaleSlopeIntercept',
    value: function rescaleSlopeIntercept(value, slope, intercept) {
      return value * slope + intercept;
    }
  }]);

  return CoreUtils;
}();

exports.default = CoreUtils;

},{"./core.validators":106,"url":81}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Validate basic structures.
 *
 * @example
 * //Returns true
 * VJS.Core.Validators.matrix4(new THREE.Matrix4());
 *
 * //Returns false
 * VJS.Core.Validators.matrix4(new THREE.Vector3());
 *
 * @module core/validators
 */

var Validators = function () {
  function Validators() {
    _classCallCheck(this, Validators);
  }

  _createClass(Validators, null, [{
    key: 'matrix4',


    /**
     * Validates a matrix as a THREEJS.Matrix4
     * link
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid Matrix4, false if NOT.
     */
    value: function matrix4(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('elements') && objectToTest.elements.length === 16 && typeof objectToTest.identity === 'function' && typeof objectToTest.copy === 'function' && typeof objectToTest.determinant === 'function')) {
        return false;
      }

      return true;
    }

    /**
    * Validates a vector as a THREEJS.Vector3
    * @param {Object} objectToTest - The object to be tested.
    * @return {boolean} True if valid Vector3, false if NOT.
    */

  }, {
    key: 'vector3',
    value: function vector3(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('x') && objectToTest.hasOwnProperty('y') && objectToTest.hasOwnProperty('z') && !objectToTest.hasOwnProperty('w'))) {
        return false;
      }

      return true;
    }

    /**
     * Validates a box.
     *
     * @example
     * // a box is defined as
     * let box = {
     *   center: THREE.Vector3,
     *   halfDimensions: THREE.Vector3
     * }
     *
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid box, false if NOT.
     */

  }, {
    key: 'box',
    value: function box(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('center') && this.vector3(objectToTest.center) && objectToTest.hasOwnProperty('halfDimensions') && this.vector3(objectToTest.halfDimensions) && objectToTest.halfDimensions.x >= 0 && objectToTest.halfDimensions.y >= 0 && objectToTest.halfDimensions.z >= 0)) {
        return false;
      }

      return true;
    }

    /**
     * Validates a ray.
     *
     * @example
     * // a ray is defined as
     * let ray = {
     *   postion: THREE.Vector3,
     *   direction: THREE.Vector3
     * }
     *
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid ray, false if NOT.
     */

  }, {
    key: 'ray',
    value: function ray(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('position') && this.vector3(objectToTest.position) && objectToTest.hasOwnProperty('direction') && this.vector3(objectToTest.direction))) {
        return false;
      }

      return true;
    }
  }]);

  return Validators;
}();

exports.default = Validators;

},{}],107:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _geometries = require('./geometries.slice');

var _geometries2 = _interopRequireDefault(_geometries);

var _geometries3 = require('./geometries.voxel');

var _geometries4 = _interopRequireDefault(_geometries3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module geometries
 */

exports.default = {
  Slice: _geometries2.default,
  Voxel: _geometries4.default
};

},{"./geometries.slice":108,"./geometries.voxel":109}],108:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 *
 * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}
 *
 * @module geometries/slice
 *
 * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.
 * @param {THREE.Vector3} center - Center of the box to be sliced.
 * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)
 * @param {THREE.Vector3} position - Position of the cutting plane.
 * @param {THREE.Vector3} direction - Cross direction of the cutting plane.
 *
 * @example
 * // Define box to be sliced
 * let halfDimensions = new THREE.Vector(123, 45, 67);
 * let center = new THREE.Vector3(0, 0, 0);
 * let orientation = new THREE.Vector3(
 *   new THREE.Vector3(1, 0, 0),
 *   new THREE.Vector3(0, 1, 0),
 *   new THREE.Vector3(0, 0, 1)
 * );
 *
 * // Define slice plane
 * let position = center.clone();
 * let direction = new THREE.Vector3(-0.2, 0.5, 0.3);
 *
 * // Create the slice geometry & materials
 * let sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);
 * let sliceMaterial = new THREE.MeshBasicMaterial({
 *   'side': THREE.DoubleSide,
 *   'color': 0xFF5722
 * });
 *
 *  // Create mesh and add it to the scene
 *  let slice = new THREE.Mesh(sliceGeometry, sliceMaterial);
 *  scene.add(slice);
 */

var GeometriesSlice = function (_THREE$ShapeGeometry) {
  _inherits(GeometriesSlice, _THREE$ShapeGeometry);

  function GeometriesSlice(halfDimensions, center, position, direction) {
    var toAABB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new THREE.Matrix4();

    _classCallCheck(this, GeometriesSlice);

    //
    // prepare data for the shape!
    //
    var aabb = {
      halfDimensions: halfDimensions,
      center: center,
      toAABB: toAABB
    };

    var plane = {
      position: position,
      direction: direction
    };

    // BOOM!
    var intersections = _core2.default.aabbPlane(aabb, plane);

    // can not exist before calling the constructor
    if (intersections.length < 3) {
      window.console.log('WARNING: Less than 3 intersections between AABB and Plane.');
      window.console.log('AABB');
      window.console.log(aabb);
      window.console.log('Plane');
      window.console.log(plane);
      window.console.log('exiting...');
      // or throw error?
      throw 'geometries.slice has less than 3 intersections, can not create a valid geometry.';
    }

    var orderedIntersections = GeometriesSlice.orderIntersections(intersections, direction);
    var sliceShape = GeometriesSlice.shape(orderedIntersections);

    //
    // Generate Geometry from shape
    // It does triangulation for us!
    //

    var _this = _possibleConstructorReturn(this, (GeometriesSlice.__proto__ || Object.getPrototypeOf(GeometriesSlice)).call(this, sliceShape));

    _this.type = 'SliceGeometry';

    // update real position of each vertex! (not in 2d)
    _this.vertices = orderedIntersections;
    _this.verticesNeedUpdate = true;
    return _this;
  }

  _createClass(GeometriesSlice, null, [{
    key: 'shape',
    value: function shape(points) {
      //
      // Create Shape
      //
      var shape = new THREE.Shape();
      // move to first point!
      shape.moveTo(points[0].xy.x, points[0].xy.y);

      // loop through all points!
      for (var l = 1; l < points.length; l++) {
        // project each on plane!
        shape.lineTo(points[l].xy.x, points[l].xy.y);
      }

      // close the shape!
      shape.lineTo(points[0].xy.x, points[0].xy.y);
      return shape;
    }

    /**
     *
     * Convenience function to extract center of mass from list of points.
     *
     * @private
     *
     * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.
     *
     * @returns {THREE.Vector3} Center of mass from given points.
     */

  }, {
    key: 'centerOfMass',
    value: function centerOfMass(points) {
      var centerOfMass = new THREE.Vector3(0, 0, 0);
      for (var i = 0; i < points.length; i++) {
        centerOfMass.x += points[i].x;
        centerOfMass.y += points[i].y;
        centerOfMass.z += points[i].z;
      }
      centerOfMass.divideScalar(points.length);

      return centerOfMass;
    }

    /**
     *
     * Order 3D planar points around a refence point.
     *
     * @private
     *
     * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.
     * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.
     *
     * @returns {Array<Object>} Set of object representing the ordered points.
     */

  }, {
    key: 'orderIntersections',
    value: function orderIntersections(points, direction) {
      var reference = GeometriesSlice.centerOfMass(points);
      // direction from first point to reference
      var referenceDirection = new THREE.Vector3(points[0].x - reference.x, points[0].y - reference.y, points[0].z - reference.z).normalize();

      var base = new THREE.Vector3(0, 0, 0).crossVectors(referenceDirection, direction).normalize();

      var orderedpoints = [];

      // other lines // if inter, return location + angle
      for (var j = 0; j < points.length; j++) {
        var point = new THREE.Vector3(points[j].x, points[j].y, points[j].z);
        point.direction = new THREE.Vector3(points[j].x - reference.x, points[j].y - reference.y, points[j].z - reference.z).normalize();

        var x = referenceDirection.dot(point.direction);
        var y = base.dot(point.direction);
        point.xy = { x: x, y: y };

        var theta = Math.atan2(y, x) * (180 / Math.PI);
        point.angle = theta;

        orderedpoints.push(point);
      }

      orderedpoints.sort(function (a, b) {
        return a.angle - b.angle;
      });

      var noDups = [orderedpoints[0]];
      var epsilon = 0.0001;
      for (var i = 1; i < orderedpoints.length; i++) {
        if (Math.abs(orderedpoints[i - 1].angle - orderedpoints[i].angle) > epsilon) {
          noDups.push(orderedpoints[i]);
        }
      }

      return noDups;
    }
  }]);

  return GeometriesSlice;
}(THREE.ShapeGeometry);

exports.default = GeometriesSlice;

},{"../core/core.intersections":102}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * @module geometries/voxel
 */

var GeometriesVoxel = function (_THREE$BoxGeometry) {
  _inherits(GeometriesVoxel, _THREE$BoxGeometry);

  function GeometriesVoxel(dataPosition) {
    _classCallCheck(this, GeometriesVoxel);

    var _this = _possibleConstructorReturn(this, (GeometriesVoxel.__proto__ || Object.getPrototypeOf(GeometriesVoxel)).call(this, 1, 1, 1));

    _this._location = dataPosition;

    _this.applyMatrix(new THREE.Matrix4().makeTranslation(_this._location.x, _this._location.y, _this._location.z));

    _this.verticesNeedUpdate = true;
    return _this;
  }

  _createClass(GeometriesVoxel, [{
    key: "resetVertices",
    value: function resetVertices() {
      this.vertices[0].set(0.5, 0.5, 0.5);
      this.vertices[1].set(0.5, 0.5, -0.5);
      this.vertices[2].set(0.5, -0.5, 0.5);
      this.vertices[3].set(0.5, -0.5, -0.5);
      this.vertices[4].set(-0.5, 0.5, -0.5);
      this.vertices[5].set(-0.5, 0.5, 0.5);
      this.vertices[6].set(-0.5, -0.5, -0.5);
      this.vertices[7].set(-0.5, -0.5, 0.5);
    }
  }, {
    key: "location",
    set: function set(location) {
      this._location = location;

      // update vertices from location
      this.vertices[0].set(+0.5, +0.5, +0.5);
      this.vertices[1].set(+0.5, +0.5, -0.5);
      this.vertices[2].set(+0.5, -0.5, +0.5);
      this.vertices[3].set(+0.5, -0.5, -0.5);
      this.vertices[4].set(-0.5, +0.5, -0.5);
      this.vertices[5].set(-0.5, +0.5, +0.5);
      this.vertices[6].set(-0.5, -0.5, -0.5);
      this.vertices[7].set(-0.5, -0.5, +0.5);

      this.applyMatrix(new THREE.Matrix4().makeTranslation(this._location.x, this._location.y, this._location.z));

      this.verticesNeedUpdate = true;
    },
    get: function get() {
      return this._location;
    }
  }]);

  return GeometriesVoxel;
}(THREE.BoxGeometry);

exports.default = GeometriesVoxel;

},{}],110:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** * Imports ***/

/**
 * @module helpers/border
 */
var HelpersBorder = function (_THREE$Object3D) {
  _inherits(HelpersBorder, _THREE$Object3D);

  function HelpersBorder(helpersSlice) {
    _classCallCheck(this, HelpersBorder);

    var _this = _possibleConstructorReturn(this, (HelpersBorder.__proto__ || Object.getPrototypeOf(HelpersBorder)).call(this));
    //


    _this._helpersSlice = helpersSlice;

    _this._visible = true;
    _this._color = 0xff0000;
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    _this._create();
    return _this;
  }

  _createClass(HelpersBorder, [{
    key: '_create',
    value: function _create() {
      if (!this._material) {
        this._material = new THREE.LineBasicMaterial({
          color: this._color,
          linewidth: 1
        });
      }

      //
      if (!this._helpersSlice.geometry.vertices) {
        return;
      }

      this._geometry = new THREE.Geometry();
      for (var i = 0; i < this._helpersSlice.geometry.vertices.length; i++) {
        this._geometry.vertices.push(this._helpersSlice.geometry.vertices[i]);
      }
      this._geometry.vertices.push(this._helpersSlice.geometry.vertices[0]);

      this._mesh = new THREE.Line(this._geometry, this._material);
      if (this._helpersSlice.aabbSpace === 'IJK') {
        this._mesh.applyMatrix(this._helpersSlice.stack.ijk2LPS);
      }
      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: '_update',
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._geometry.dispose();
      this._geometry = null;
      this._material.dispose();
      this._material = null;
    }
  }, {
    key: 'helpersSlice',
    set: function set(helpersSlice) {
      this._helpersSlice = helpersSlice;
      this._update();
    },
    get: function get() {
      return this._helpersSlice;
    }
  }, {
    key: 'visible',
    set: function set(visible) {
      this._visible = visible;
      if (this._mesh) {
        this._mesh.visible = this._visible;
      }
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: 'color',
    set: function set(color) {
      this._color = color;
      if (this._material) {
        this._material.color.set(this._color);
      }
    },
    get: function get() {
      return this._color;
    }
  }]);

  return HelpersBorder;
}(THREE.Object3D);

exports.default = HelpersBorder;

},{}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module helpers/boundingbox
 */

var HelpersBoundingBox = function (_THREE$Object3D) {
  _inherits(HelpersBoundingBox, _THREE$Object3D);

  function HelpersBoundingBox(stack) {
    _classCallCheck(this, HelpersBoundingBox);

    // private vars
    var _this = _possibleConstructorReturn(this, (HelpersBoundingBox.__proto__ || Object.getPrototypeOf(HelpersBoundingBox)).call(this));
    //


    _this._stack = stack;
    _this._visible = true;
    _this._color = 0xFFFFFF;
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // create object
    _this._create();
    return _this;
  }

  // getters/setters


  _createClass(HelpersBoundingBox, [{
    key: "_create",


    // private methods
    value: function _create() {
      // Convenience vars
      var dimensions = this._stack.dimensionsIJK;
      var halfDimensions = this._stack.halfDimensionsIJK;
      var offset = new THREE.Vector3(-0.5, -0.5, -0.5);

      // Geometry
      this._geometry = new THREE.BoxGeometry(dimensions.x, dimensions.y, dimensions.z);
      // position bbox in image space
      this._geometry.applyMatrix(new THREE.Matrix4().makeTranslation(halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));

      // Mesh
      var boxMesh = new THREE.Mesh(this._geometry, new THREE.MeshBasicMaterial(0xff0000));
      this._mesh = new THREE.BoxHelper(boxMesh, this._color);

      // Material
      this._material = this._mesh.material;

      // position bbox in world space
      this._mesh.applyMatrix(this._stack.ijk2LPS);
      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: "_update",
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh.material.dispose();
        this._mesh.material = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._geometry.dispose();
      this._geometry = null;
      this._material.dispose();
      this._material = null;
    }
  }, {
    key: "visible",
    set: function set(visible) {
      this._visible = visible;
      if (this._mesh) {
        this._mesh.visible = this._visible;
      }
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "color",
    set: function set(color) {
      this._color = color;
      if (this._material) {
        this._material.color.set(this._color);
      }
    },
    get: function get() {
      return this._color;
    }
  }]);

  return HelpersBoundingBox;
}(THREE.Object3D);

exports.default = HelpersBoundingBox;

},{}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpers = require('./helpers.border');

var _helpers2 = _interopRequireDefault(_helpers);

var _helpers3 = require('./helpers.boundingbox');

var _helpers4 = _interopRequireDefault(_helpers3);

var _helpers5 = require('./helpers.localizer');

var _helpers6 = _interopRequireDefault(_helpers5);

var _helpers7 = require('./helpers.lut');

var _helpers8 = _interopRequireDefault(_helpers7);

var _helpers9 = require('./helpers.progressbar');

var _helpers10 = _interopRequireDefault(_helpers9);

var _helpersProgressbar = require('./helpers.progressbar.eventbased');

var _helpersProgressbar2 = _interopRequireDefault(_helpersProgressbar);

var _helpers11 = require('./helpers.slice');

var _helpers12 = _interopRequireDefault(_helpers11);

var _helpers13 = require('./helpers.stack');

var _helpers14 = _interopRequireDefault(_helpers13);

var _helpers15 = require('./helpers.volumerendering');

var _helpers16 = _interopRequireDefault(_helpers15);

var _helpers17 = require('./x/helpers.x');

var _helpers18 = _interopRequireDefault(_helpers17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module helpers
 */

exports.default = {
  Border: _helpers2.default,
  BoundingBox: _helpers4.default,
  Localizer: _helpers6.default,
  Lut: _helpers8.default,
  ProgressBar: _helpers10.default,
  ProgressBarEventBased: _helpersProgressbar2.default,
  Slice: _helpers12.default,
  Stack: _helpers14.default,
  VolumeRendering: _helpers16.default,
  X: _helpers18.default
};

},{"./helpers.border":110,"./helpers.boundingbox":111,"./helpers.localizer":113,"./helpers.lut":114,"./helpers.progressbar":117,"./helpers.progressbar.eventbased":116,"./helpers.slice":118,"./helpers.stack":119,"./helpers.volumerendering":120,"./x/helpers.x":122}],113:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shadersLocalizer = require('../shaders/shaders.localizer.uniform');

var _shadersLocalizer2 = _interopRequireDefault(_shadersLocalizer);

var _shadersLocalizer3 = require('../shaders/shaders.localizer.vertex');

var _shadersLocalizer4 = _interopRequireDefault(_shadersLocalizer3);

var _shadersLocalizer5 = require('../shaders/shaders.localizer.fragment');

var _shadersLocalizer6 = _interopRequireDefault(_shadersLocalizer5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * @module helpers/localizer
 */

var HelpersLocalizer = function (_THREE$Object3D) {
  _inherits(HelpersLocalizer, _THREE$Object3D);

  function HelpersLocalizer(stack, geometry, referencePlane) {
    _classCallCheck(this, HelpersLocalizer);

    var _this = _possibleConstructorReturn(this, (HelpersLocalizer.__proto__ || Object.getPrototypeOf(HelpersLocalizer)).call(this));
    //


    _this._stack = stack;
    _this._referencePlane = referencePlane;
    _this._plane1 = null;
    _this._color1 = null;
    _this._plane2 = null;
    _this._color2 = null;
    _this._plane3 = null;
    _this._color3 = null;
    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._shadersFragment = _shadersLocalizer6.default;
    _this._shadersVertex = _shadersLocalizer4.default;
    _this._uniforms = _shadersLocalizer2.default.uniforms();
    _this._material = null;
    _this._geometry = geometry;

    _this._create();
    return _this;
  }

  _createClass(HelpersLocalizer, [{
    key: '_create',
    value: function _create() {
      this._prepareMaterial();
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.applyMatrix(this._stack._ijk2LPS);
      this.add(this._mesh);
    }
  }, {
    key: '_prepareMaterial',
    value: function _prepareMaterial() {
      if (!this.material) {
        // reference plane
        this._uniforms.uSlice.value = this._referencePlane;

        // localizer planes
        if (this._plane1) {
          this._uniforms.uPlane1.value = this._plane1;
          this._uniforms.uPlaneColor1.value = this._color1;
        }

        if (this._plane2) {
          this._uniforms.uPlane2.value = this._plane2;
          this._uniforms.uPlaneColor2.value = this._color2;
        }

        if (this._plane3) {
          this._uniforms.uPlane3.value = this._plane3;
          this._uniforms.uPlaneColor3.value = this._color3;
        }

        //
        this._uniforms.uCanvasWidth.value = this._canvasWidth;
        this._uniforms.uCanvasHeight.value = this._canvasHeight;

        // generate material
        var fs = new _shadersLocalizer6.default(this._uniforms);
        var vs = new _shadersLocalizer4.default();
        this._material = new THREE.ShaderMaterial({ side: THREE.DoubleSide,
          uniforms: this._uniforms,
          vertexShader: vs.compute(),
          fragmentShader: fs.compute()
        });
        this._material.transparent = true;
      }
    }
  }, {
    key: 'update',
    value: function update() {
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'geometry',
    get: function get() {
      return this._geometry;
    },
    set: function set(geometry) {
      this._geometry = geometry;

      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'referencePlane',
    get: function get() {
      return this._referencePlane;
    },
    set: function set(referencePlane) {
      this._referencePlane = referencePlane;
      this._uniforms.uSlice.value = this._referencePlane;
    }
  }, {
    key: 'plane1',
    get: function get() {
      return this._plane1;
    },
    set: function set(plane1) {
      this._plane1 = plane1;
      this._uniforms.uPlane1.value = this._plane1;
    }
  }, {
    key: 'color1',
    get: function get() {
      return this._color1;
    },
    set: function set(color1) {
      this._color1 = color1;
      this._uniforms.uPlaneColor1.value = this._color1;
    }
  }, {
    key: 'plane2',
    get: function get() {
      return this._plane2;
    },
    set: function set(plane2) {
      this._plane2 = plane2;
      this._uniforms.uPlane2.value = this._plane2;
    }
  }, {
    key: 'color2',
    get: function get() {
      return this._color2;
    },
    set: function set(color2) {
      this._color2 = color2;
      this._uniforms.uPlaneColor2.value = this._color2;
    }
  }, {
    key: 'plane3',
    get: function get() {
      return this._plane3;
    },
    set: function set(plane3) {
      this._plane3 = plane3;
      this._uniforms.uPlane3.value = this._plane3;
    }
  }, {
    key: 'color3',
    get: function get() {
      return this._color3;
    },
    set: function set(color3) {
      this._color3 = color3;
      this._uniforms.uPlaneColor3.value = this._color3;
    }
  }, {
    key: 'canvasWidth',
    get: function get() {
      return this._canvasWidth;
    },
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._uniforms.uCanvasWidth.value = this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    get: function get() {
      return this._canvasHeight;
    },
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._uniforms.uCanvasHeight.value = this._canvasHeight;
    }
  }]);

  return HelpersLocalizer;
}(THREE.Object3D);

exports.default = HelpersLocalizer;

},{"../shaders/shaders.localizer.fragment":159,"../shaders/shaders.localizer.uniform":160,"../shaders/shaders.localizer.vertex":161}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module helpers/lut
 */

var HelpersLut = function () {
  function HelpersLut(containerID) {
    var lut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
    var lutO = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';
    var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [[0, 0, 0, 0], [1, 1, 1, 1]];
    var opacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [[0, 0], [1, 1]];
    var discrete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    _classCallCheck(this, HelpersLut);

    // min/max (0-1 or real intensities)
    // show/hide
    // horizontal/vertical
    this._containerID = containerID;

    this._discrete = discrete;
    this._color = color;
    this._lut = lut;
    this._luts = _defineProperty({}, lut, color);

    this._opacity = opacity;
    this._lutO = lutO;
    this._lutsO = _defineProperty({}, lutO, opacity);

    this.initCanvas();
    this.paintCanvas();
  }

  _createClass(HelpersLut, [{
    key: 'initCanvas',
    value: function initCanvas() {
      // container
      this._canvasContainer = this.initCanvasContainer(this._containerID);
      // background
      this._canvasBg = this.createCanvas();
      this._canvasContainer.appendChild(this._canvasBg);
      // foreground
      this._canvas = this.createCanvas();
      this._canvasContainer.appendChild(this._canvas);
    }
  }, {
    key: 'initCanvasContainer',
    value: function initCanvasContainer(canvasContainerId) {
      var canvasContainer = document.getElementById(canvasContainerId);
      canvasContainer.style.width = '256 px';
      canvasContainer.style.height = '128 px';
      canvasContainer.style.border = '1px solid #F9F9F9';
      return canvasContainer;
    }
  }, {
    key: 'createCanvas',
    value: function createCanvas() {
      var canvas = document.createElement('canvas');
      canvas.height = 16;
      canvas.width = 256;
      return canvas;
    }
  }, {
    key: 'paintCanvas',
    value: function paintCanvas() {
      // setup context
      var ctx = this._canvas.getContext('2d');
      ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
      ctx.globalCompositeOperation = 'source-over';

      // apply color
      if (!this._discrete) {
        var color = ctx.createLinearGradient(0, 0, this._canvas.width, this._canvas.height);
        for (var i = 0; i < this._color.length; i++) {
          color.addColorStop(this._color[i][0], 'rgba( ' + Math.round(this._color[i][1] * 255) + ', ' + Math.round(this._color[i][2] * 255) + ', ' + Math.round(this._color[i][3] * 255) + ', 1)');
        }

        ctx.fillStyle = color;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
      } else {
        ctx.lineWidth = 2 * this._canvas.height;

        for (var _i = 0; _i < this._color.length; _i++) {
          var currentPos = this._color[_i][0];
          var nextPos = 1;
          if (_i < this._color.length - 1) {
            nextPos = this._color[_i + 1][0];
          }
          var previousPos = 0;
          if (_i > 0) {
            previousPos = this._color[_i - 1][0];
          }

          var from = previousPos + (currentPos - previousPos) / 2;
          var to = currentPos + (nextPos - currentPos) / 2;
          var _color = this._color[_i];
          var opacity = this._opacity[_i] ? this._opacity[_i][1] : 1;

          ctx.beginPath();
          ctx.strokeStyle = 'rgba( ' + Math.round(_color[1] * 255) + ', ' + Math.round(_color[2] * 255) + ', ' + Math.round(_color[3] * 255) + ', ' + opacity + ')';
          ctx.moveTo(from * this._canvas.width, 0);
          ctx.lineTo(to * this._canvas.width, 0);
          ctx.stroke();
          ctx.closePath();
        }
      }

      if (!this._discrete) {
        // if discrete, we already took care of the opacity.
        // setup context
        ctx.globalCompositeOperation = 'destination-in';

        // apply opacity
        var _opacity = ctx.createLinearGradient(0, 0, this._canvas.width, this._canvas.height);
        for (var _i2 = 0; _i2 < this._opacity.length; _i2++) {
          _opacity.addColorStop(this._opacity[_i2][0], 'rgba(255, 255, 255, ' + this._opacity[_i2][1] + ')');
        }
        ctx.fillStyle = _opacity;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
      }
    }
  }, {
    key: 'lutsAvailable',
    value: function lutsAvailable() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'color';

      var available = [];
      var luts = this._luts;

      if (type !== 'color') {
        luts = this._lutsO;
      }

      for (var i in luts) {
        available.push(i);
      }

      return available;
    }

    // add luts to class' lut (so a user can add its own as well)

  }, {
    key: 'texture',
    get: function get() {
      var texture = new THREE.Texture(this._canvas);
      texture.mapping = THREE.UVMapping;
      texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.magFilter = texture.minFilter = THREE.NearestFilter;
      texture.premultiplyAlpha = true;
      texture.needsUpdate = true;
      return texture;
    }
  }, {
    key: 'lut',
    set: function set(targetLUT) {
      this._color = this._luts[targetLUT];
      this._lut = targetLUT;

      this.paintCanvas();
    },
    get: function get() {
      return this._lut;
    }
  }, {
    key: 'luts',
    set: function set(newLuts) {
      this._luts = newLuts;
    },
    get: function get() {
      return this._luts;
    }
  }, {
    key: 'lutO',
    set: function set(targetLUTO) {
      this._opacity = this._lutsO[targetLUTO];
      this._lutO = targetLUTO;

      this.paintCanvas();
    },
    get: function get() {
      return this._lutO;
    }
  }, {
    key: 'lutsO',
    set: function set(newLutsO) {
      this._lutsO = newLutsO;
    },
    get: function get() {
      return this._lutsO;
    }
  }, {
    key: 'discrete',
    set: function set(discrete) {
      this._discrete = discrete;

      this.paintCanvas();
    },
    get: function get() {
      return this._discrete;
    }
  }], [{
    key: 'presetLuts',
    value: function presetLuts() {
      return {
        'default': [[0, 0, 0, 0], [1, 1, 1, 1]],
        'spectrum': [[0, 0, 0, 0], [0.1, 0, 0, 1], [0.33, 0, 1, 1], [0.5, 0, 1, 0], [0.66, 1, 1, 0], [0.9, 1, 0, 0], [1, 1, 1, 1]],
        'hot_and_cold': [[0, 0, 0, 1], [0.15, 0, 1, 1], [0.3, 0, 1, 0], [0.45, 0, 0, 0], [0.5, 0, 0, 0], [0.55, 0, 0, 0], [0.7, 1, 1, 0], [0.85, 1, 0, 0], [1, 1, 1, 1]],
        'gold': [[0, 0, 0, 0], [0.13, 0.19, 0.03, 0], [0.25, 0.39, 0.12, 0], [0.38, 0.59, 0.26, 0], [0.50, 0.80, 0.46, 0.08], [0.63, 0.99, 0.71, 0.21], [0.75, 0.99, 0.88, 0.34], [0.88, 0.99, 0.99, 0.48], [1, 0.90, 0.95, 0.61]],
        'red': [[0, 0.75, 0, 0], [0.5, 1, 0.5, 0], [0.95, 1, 1, 0], [1, 1, 1, 1]],
        'green': [[0, 0, 0.75, 0], [0.5, 0.5, 1, 0], [0.95, 1, 1, 0], [1, 1, 1, 1]],
        'blue': [[0, 0, 0, 1], [0.5, 0, 0.5, 1], [0.95, 0, 1, 1], [1, 1, 1, 1]],
        'walking_dead': [[0, 0.1, 1, 1], [1, 1, 1, 1]],
        'random': [[0, 0, 0, 0], [0.27, 0.18, 0.18, 0.18], [0.41, 1, 1, 1], [0.7, 1, 0, 0], [1, 1, 1, 1]]
      };
    }
  }, {
    key: 'presetLutsO',
    value: function presetLutsO() {
      return {
        'linear': [[0, 0], [1, 1]],
        'lowpass': [[0, 0.8], [0.2, 0.6], [0.3, 0.1], [1, 0]],
        'bandpass': [[0, 0], [0.4, 0.8], [0.6, 0.8], [1, 0]],
        'highpass': [[0, 0], [0.7, 0.1], [0.8, 0.6], [1, 0.8]],
        'flat': [[0, .7], [1, 1]],
        'random': [[0, 0.], [0.38, 0.], [0.55, 1.], [0.72, 1.], [1, 0.05]]
      };
    }
  }]);

  return HelpersLut;
}();

exports.default = HelpersLut;

},{}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Helpers material mixin.
 *
 * @module helpers/material/mixin
 */

var HerlpersMaterialMixin = function HerlpersMaterialMixin(superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: "_createMaterial",
      value: function _createMaterial(extraOptions) {
        // generate shaders on-demand!
        var fs = new this._shadersFragment(this._uniforms);
        var vs = new this._shadersVertex();

        // material
        var globalOptions = {
          uniforms: this._uniforms,
          vertexShader: vs.compute(),
          fragmentShader: fs.compute()
        };

        var options = Object.assign(extraOptions, globalOptions);
        this._material = new THREE.ShaderMaterial(options);
        this._material.needsUpdate = true;
      }
    }, {
      key: "_updateMaterial",
      value: function _updateMaterial() {
        // generate shaders on-demand!
        var fs = new this._shadersFragment(this._uniforms);
        var vs = new this._shadersVertex();

        this._material.vertexShader = vs.compute();
        this._material.fragmentShader = fs.compute();

        this._material.needsUpdate = true;
      }
    }, {
      key: "_prepareTexture",
      value: function _prepareTexture() {
        this._textures = [];
        for (var m = 0; m < this._stack._rawData.length; m++) {
          var tex = new THREE.DataTexture(this._stack.rawData[m], this._stack.textureSize, this._stack.textureSize, this._stack.textureType, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
          tex.needsUpdate = true;
          tex.flipY = true;
          this._textures.push(tex);
        }
      }
    }]);

    return _class;
  }(superclass);
};

exports.default = HerlpersMaterialMixin;

},{}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core/core.utils');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Event Based progressbar
 * @module helpers/progressBar
 *
 * @example
 *
 * let loader = new LoadersVolume();
 * const domContainer = document.getElementById('progressbar');
 * const pb = new HelpersProgressBarEventBased(loader, domContainer);
 */

var HelpersProgressBarEventBased = function () {
  function HelpersProgressBarEventBased(emitter, domTarget) {
    _classCallCheck(this, HelpersProgressBarEventBased);

    if (!emitter || !this._isFunction(emitter.emit)) {
      console.error('please give the this._emitter instance');
      return;
    }

    if (_core2.default.isString(domTarget)) {
      this._dom = document.getElementById(domTarget);
    } else {
      this._dom = domTarget;
    }

    if (!_core2.default.isElement(this._dom)) {
      console.error('please give the id of container dom or directly a dom instance');
      return;
    }
    this._emitter = emitter;
    this.initContainerDom();
    this.initEventListenner();
    this.loaded = 0;
    this.totalFile = 0;
  }

  _createClass(HelpersProgressBarEventBased, [{
    key: '_isFunction',
    value: function _isFunction(fn) {
      return Object.prototype.toString.call(fn) === '[object Function]';
    }
  }, {
    key: 'initEventListenner',
    value: function initEventListenner() {
      var self = this;

      this._emitter.on('load-start', function (event) {
        var totalFiles = event.totalFiles;
        self.totalFile = totalFiles;
        self._domTotalFile.innerHTML = totalFiles;
      });

      this._emitter.on('fetch-start', function (event) {
        var fetchLi = document.createElement('li');

        var fileTag = document.createElement('div');
        fileTag.innerHTML = 'file: ' + event.file;
        fileTag.style.color = '#ffffff';
        fetchLi.append(fileTag);

        fetchLi.className = 'fetch-file';
        fetchLi.id = 'file-' + event.file;
        fetchLi.style.marginBottom = '7px';
        fetchLi.style.border = '1px solid #ffffff;';
        fetchLi.style.width = '60%';
        var fetchprogress = document.createElement('div');
        fetchprogress.id = 'file-fetch-' + event.file;
        fetchprogress.style.width = '0%';
        fetchLi.append(fetchprogress);
        self._domProcessList.append(fetchLi);
      });

      this._emitter.on('fetch-progress', function (event) {
        var id = 'file-fetch-' + event.file;
        var fileFetchDom = document.getElementById(id);
        fileFetchDom.style.width = event.loaded / event.total * 100 + '%';
        fileFetchDom.style.border = '1px solid red';
      });

      this._emitter.on('fetch-success', function (event) {
        // show result
        var liParent = document.getElementById('file-' + event.file);
        var result = document.createElement('div');
        result.id = 'file-result-' + event.file;
        result.innerHTML = 'fetch-success';
        result.style.color = '#ffffff';
        liParent.append(result);
      });

      this._emitter.on('fetch-error', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-abort', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-end', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-timeout', function (event) {
        // console.log(event);
      });

      this._emitter.on('parse-start', function (event) {
        var liParent = document.getElementById('file-' + event.file);
        var parseprogress = document.createElement('div');
        parseprogress.id = 'file-parse-' + event.file;
        parseprogress.style.width = '0%';
        liParent.append(parseprogress);
      });

      this._emitter.on('parsing', function (event) {
        var id = 'file-parse-' + event.file;
        var fileParseDom = document.getElementById(id);
        fileParseDom.style.width = event.parsed / event.total * 100 + '%';
        fileParseDom.style.border = '1px solid yellow';
      });

      this._emitter.on('parse-success', function (event) {
        self.loaded += 1;
        self._domCurrentFile.innerHTML = self.loaded;
        self._domCurrentProgress.style.width = self.loaded / self.totalFile * 100 + '%';
        // show result
        var liParent = document.getElementById('file-' + event.file);
        var result = document.createElement('div');
        result.id = 'file-result-' + event.file;
        result.innerHTML = 'parse-success';
        result.style.color = '#ffffff';
        liParent.append(result);
      });
    }
  }, {
    key: 'initContainerDom',
    value: function initContainerDom() {
      var containerDom = "<div id='ami-progress-bar-container' style='background-color: rgb(33, 33, 33); color: #ffffff;'>" + "<div>" + "<label for='progress-bar' id='progress-label' style='width: 60%; border: 1px solid #ffffff; text-align: center;'>" + "<span id='current-file-index'>0</span>" + "/" + "<span id='total-file'>0</span>" + "</label>" + "<div id='progress-bar' style='width: 60%; border: 1px solid #ffffff; text-align: center;'>" + "<div id='current-progress' style='border: 1px solid red; width: 0%;'></div>" + "</div>" + "</div>" + "<ul id='process-list' style='list-style-type: none; padding: 0; overflow-y: auto;'>" +
      // "<li class='fetch-file'>" +
      // "<div id='file-fetch-xxxxxid'></div>" +
      // "<div id='file-parse-xxxxxid'></div>" +
      // "</li>" +
      "</ul>" + "</div>";
      var wrap = document.createElement('div');
      wrap.innerHTML = containerDom;
      this._dom.append(wrap);
      // dom interface
      this._domCurrentFile = document.getElementById('current-file-index');
      this._domTotalFile = document.getElementById('total-file');
      this._domProcessList = document.getElementById('process-list');
      this._domCurrentProgress = document.getElementById('current-progress');
    }
  }]);

  return HelpersProgressBarEventBased;
}();

exports.default = HelpersProgressBarEventBased;

},{"../core/core.utils":105}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module helpers/progressBar
 */

var HelpersProgressBar = function () {
  function HelpersProgressBar(container) {
    _classCallCheck(this, HelpersProgressBar);

    this._container = container;
    this._modes = {
      'load': {
        'name': 'load',
        'color': '#FFF56F'
      },
      'parse': {
        'name': 'parse',
        'color': '#2196F3'
      }
    };

    this.requestAnimationFrameID = null;

    this._mode = null;
    this._value = null;
    this._total = null;

    this.init();
  }

  _createClass(HelpersProgressBar, [{
    key: 'free',
    value: function free() {
      var progressContainers = this._container.getElementsByClassName('progress container');
      if (progressContainers.length > 0) {
        progressContainers[0].parentNode.removeChild(progressContainers[0]);
      }
      progressContainers = null;
      // stop rendering loop
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
  }, {
    key: 'init',
    value: function init() {
      var progressContainer = this._domContainer();

      for (var mode in this._modes) {
        if (this._modes.hasOwnProperty(mode)) {
          var bar = this._domBar(this._modes[mode]);
          progressContainer.appendChild(bar);
          bar = null;
        }
      }

      this._container.appendChild(progressContainer);
      progressContainer = null;

      // start rendering loop
      this.updateUI();
    }
  }, {
    key: 'update',
    value: function update(value, total, mode) {
      this._mode = mode;
      this._value = value;
      // depending on CDN, total return to XHTTPRequest can be 0.
      // In this case, we generate a random number to animate the progressbar
      if (total === 0) {
        this._total = value;
        this._value = Math.random() * value;
      } else {
        this._total = total;
      }
    }
  }, {
    key: 'updateUI',
    value: function updateUI() {
      var _this = this;

      this.requestAnimationFrameID = requestAnimationFrame(function () {
        _this.updateUI();
      });

      if (!(this._modes.hasOwnProperty(this._mode) && this._modes[this._mode].hasOwnProperty('name') && this._modes[this._mode].hasOwnProperty('color'))) {
        return false;
      }

      var message = '';
      var progress = Math.round(this._value / this._total * 100);
      var color = this._modes[this._mode].color;

      var progressBar = this._container.getElementsByClassName('progress ' + this._modes[this._mode].name);
      if (progressBar.length > 0) {
        progressBar[0].style.borderColor = color;
        progressBar[0].style.width = progress + '%';
      }
      progressBar = null;
    }
  }, {
    key: '_domContainer',
    value: function _domContainer() {
      var container = document.createElement('div');

      // class it
      container.classList.add('progress');
      container.classList.add('container');

      // style it
      container.style.width = '100%';
      container.style.height = '8px';
      container.style.position = 'absolute';
      container.style.backgroundColor = 'rgba(158, 158, 158, 0.5)';
      container.style.top = '0';
      container.style.zIndex = '1';

      return container;
    }
  }, {
    key: '_domBar',
    value: function _domBar(mode) {
      if (!(mode.hasOwnProperty('name') && mode.hasOwnProperty('color'))) {
        window.console.log('Invalid mode provided.');
        window.console.log(mode);

        return false;
      }

      var bar = document.createElement('div');

      // class it
      bar.classList.add(mode.name);
      bar.classList.add('progress');

      // style it
      bar.style.border = '2px solid ' + mode.color;
      bar.style.width = '0%';

      return bar;
    }
  }]);

  return HelpersProgressBar;
}();

exports.default = HelpersProgressBar;

},{}],118:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _geometries = require('../geometries/geometries.slice');

var _geometries2 = _interopRequireDefault(_geometries);

var _shadersData = require('../shaders/shaders.data.uniform');

var _shadersData2 = _interopRequireDefault(_shadersData);

var _shadersData3 = require('../shaders/shaders.data.vertex');

var _shadersData4 = _interopRequireDefault(_shadersData3);

var _shadersData5 = require('../shaders/shaders.data.fragment');

var _shadersData6 = _interopRequireDefault(_shadersData5);

var _helpersMaterial = require('../helpers/helpers.material.mixin');

var _helpersMaterial2 = _interopRequireDefault(_helpersMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * @module helpers/slice
 */

var HelpersSlice = function (_HelpersMaterialMixin) {
  _inherits(HelpersSlice, _HelpersMaterialMixin);

  function HelpersSlice(stack) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector3(0, 0, 0);
    var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector3(0, 0, 1);
    var aabbSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'IJK';

    _classCallCheck(this, HelpersSlice);

    // private vars
    var _this = _possibleConstructorReturn(this, (HelpersSlice.__proto__ || Object.getPrototypeOf(HelpersSlice)).call(this));
    //


    _this._stack = stack;

    // image settings
    // index only used to grab window/level and intercept/slope
    _this._invert = _this._stack.invert;

    _this._lut = 'none';
    _this._lutTexture = null;
    // if auto === true, get from index
    // else from stack which holds the default values
    _this._intensityAuto = true;
    _this._interpolation = 1; // default to trilinear interpolation
    // starts at 0
    _this._index = index;
    _this._windowWidth = null;
    _this._windowCenter = null;
    _this._rescaleSlope = null;
    _this._rescaleIntercept = null;

    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._borderColor = null;

    // Object3D settings
    // shape
    _this._planePosition = position;
    _this._planeDirection = direction;
    // change aaBBSpace changes the box dimensions
    // also changes the transform
    // there is also a switch to move back mesh to LPS space automatically
    _this._aaBBspace = aabbSpace; // or LPS -> different transforms, esp for the geometry/mesh
    _this._material = null;
    _this._textures = [];
    _this._shadersFragment = _shadersData6.default;
    _this._shadersVertex = _shadersData4.default;
    _this._uniforms = _shadersData2.default.uniforms();
    _this._geometry = null;
    _this._mesh = null;
    _this._visible = true;

    // update dimensions, center, etc.
    // depending on aaBBSpace
    _this._init();

    // update object
    _this._create();
    return _this;
  }

  // getters/setters

  _createClass(HelpersSlice, [{
    key: '_init',
    value: function _init() {
      if (!this._stack || !this._stack._prepared || !this._stack._packed) {
        return;
      }

      if (this._aaBBspace === 'IJK') {
        this._halfDimensions = this._stack.halfDimensionsIJK;
        this._center = new THREE.Vector3(this._stack.halfDimensionsIJK.x - 0.5, this._stack.halfDimensionsIJK.y - 0.5, this._stack.halfDimensionsIJK.z - 0.5);
        this._toAABB = new THREE.Matrix4();
      } else {
        // LPS
        var aaBBox = this._stack.AABBox();
        this._halfDimensions = aaBBox.clone().multiplyScalar(0.5);
        this._center = this._stack.centerAABBox();
        this._toAABB = this._stack.lps2AABB;
      }
    }

    // private methods

  }, {
    key: '_create',
    value: function _create() {
      if (!this._stack || !this._stack.prepared || !this._stack.packed) {
        return;
      }

      // Convenience vars
      try {
        this._geometry = new _geometries2.default(this._halfDimensions, this._center, this._planePosition, this._planeDirection, this._toAABB);
      } catch (e) {
        window.console.log(e);
        window.console.log('invalid slice geometry - exiting...');
        return;
      }

      if (!this._geometry.vertices) {
        return;
      }

      if (!this._material) {
        //
        this._uniforms.uTextureSize.value = this._stack.textureSize;
        this._uniforms.uDataDimensions.value = [this._stack.dimensionsIJK.x, this._stack.dimensionsIJK.y, this._stack.dimensionsIJK.z];
        this._uniforms.uWorldToData.value = this._stack.lps2IJK;
        this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
        this._uniforms.uPixelType.value = this._stack.pixelType;
        this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
        this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;
        // compute texture if material exist
        this._prepareTexture();
        this._uniforms.uTextureContainer.value = this._textures;

        this._createMaterial({
          side: THREE.DoubleSide
        });
      }

      // update intensity related stuff
      this.updateIntensitySettings();
      this.updateIntensitySettingsUniforms();

      // create the mesh!
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      if (this._aaBBspace === 'IJK') {
        this._mesh.applyMatrix(this._stack.ijk2LPS);
      }

      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: 'updateIntensitySettings',
    value: function updateIntensitySettings() {
      // if auto, get from frame index
      if (this._intensityAuto) {
        this.updateIntensitySetting('windowCenter');
        this.updateIntensitySetting('windowWidth');
        this.updateIntensitySetting('rescaleSlope');
        this.updateIntensitySetting('rescaleIntercept');
      } else {
        if (this._windowCenter === null) {
          this._windowCenter = this._stack.windowCenter;
        }

        if (this.__windowWidth === null) {
          this._windowWidth = this._stack.windowWidth;
        }

        if (this._rescaleSlope === null) {
          this._rescaleSlope = this._stack.rescaleSlope;
        }

        if (this._rescaleIntercept === null) {
          this._rescaleIntercept = this._stack.rescaleIntercept;
        }
      }
    }
  }, {
    key: 'updateIntensitySettingsUniforms',
    value: function updateIntensitySettingsUniforms() {
      // compensate for the offset to only pass > 0 values to shaders
      // models > models.stack.js : _packTo8Bits
      var offset = 0;
      if (this._stack._minMax[0] < 0) {
        offset -= this._stack._minMax[0];
      }

      // set slice window center and width
      this._uniforms.uRescaleSlopeIntercept.value = [this._rescaleSlope, this._rescaleIntercept];
      this._uniforms.uWindowCenterWidth.value = [offset + this._windowCenter, this._windowWidth];

      // invert
      this._uniforms.uInvert.value = this._invert === true ? 1 : 0;

      // interpolation
      this._uniforms.uInterpolation.value = this._interpolation;

      // lut
      if (this._lut === 'none') {
        this._uniforms.uLut.value = 0;
      } else {
        this._uniforms.uLut.value = 1;
        this._uniforms.uTextureLUT.value = this._lutTexture;
      }
    }
  }, {
    key: 'updateIntensitySetting',
    value: function updateIntensitySetting(setting) {
      if (this._stack.frame[this._index] && this._stack.frame[this._index][setting]) {
        this['_' + setting] = this._stack.frame[this._index][setting];
      } else {
        this['_' + setting] = this._stack[setting];
      }
    }
  }, {
    key: '_update',
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        // we do not want to dispose the texture!
        // this._mesh.material.dispose();
        // this._mesh.material = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      // Release memory
      for (var j = 0; j < this._textures.length; j++) {
        this._textures[j].dispose();
        this._textures[j] = null;
      }
      this._textures = null;
      this._shadersFragment = null;
      this._shadersVertex = null;

      this._uniforms = null;

      // material, geometry and mesh
      this.remove(this._mesh);
      this._mesh.geometry.dispose();
      this._mesh.geometry = null;
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._mesh = null;

      this._geometry.dispose();
      this._geometry = null;
      this._material.vertexShader = null;
      this._material.fragmentShader = null;
      this._material.uniforms = null;
      this._material.dispose();
      this._material = null;

      this._stack = null;
    }
  }, {
    key: 'cartesianEquation',
    value: function cartesianEquation() {
      // Make sure we have a geometry
      if (!this._geometry || !this._geometry.vertices || this._geometry.vertices.length < 3) {
        return new THREE.Vector4();
      }

      var vertices = this._geometry.vertices;
      var dataToWorld = this._stack.ijk2LPS;
      var p1 = new THREE.Vector3(vertices[0].x, vertices[0].y, vertices[0].z).applyMatrix4(dataToWorld);
      var p2 = new THREE.Vector3(vertices[1].x, vertices[1].y, vertices[1].z).applyMatrix4(dataToWorld);
      var p3 = new THREE.Vector3(vertices[2].x, vertices[2].y, vertices[2].z).applyMatrix4(dataToWorld);
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var normal = v1.subVectors(p3, p2).cross(v2.subVectors(p1, p2)).normalize();

      return new THREE.Vector4(normal.x, normal.y, normal.z, -normal.dot(p1));
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    },
    set: function set(stack) {
      this._stack = stack;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'invert',
    get: function get() {
      return this._invert;
    },
    set: function set(invert) {
      this._invert = invert;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'lut',
    get: function get() {
      return this._lut;
    },
    set: function set(lut) {
      this._lut = lut;
    }
  }, {
    key: 'lutTexture',
    get: function get() {
      return this._lutTexture;
    },
    set: function set(lutTexture) {
      this._lutTexture = lutTexture;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'intensityAuto',
    get: function get() {
      return this._intensityAuto;
    },
    set: function set(intensityAuto) {
      this._intensityAuto = intensityAuto;
      this.updateIntensitySettings();
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'interpolation',
    get: function get() {
      return this._interpolation;
    },
    set: function set(interpolation) {
      this._interpolation = interpolation;
      this.updateIntensitySettingsUniforms();
      this._updateMaterial();
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
      this._update();
    }
  }, {
    key: 'planePosition',
    set: function set(position) {
      this._planePosition = position;
      this._update();
    },
    get: function get() {
      return this._planePosition;
    }
  }, {
    key: 'planeDirection',
    set: function set(direction) {
      this._planeDirection = direction;
      this._update();
    },
    get: function get() {
      return this._planeDirection;
    }
  }, {
    key: 'halfDimensions',
    set: function set(halfDimensions) {
      this._halfDimensions = halfDimensions;
    },
    get: function get() {
      return this._halfDimensions;
    }
  }, {
    key: 'center',
    set: function set(center) {
      this._center = center;
    },
    get: function get() {
      return this._center;
    }
  }, {
    key: 'aabbSpace',
    set: function set(aabbSpace) {
      this._aaBBspace = aabbSpace;
      this._init();
    },
    get: function get() {
      return this._aaBBspace;
    }
  }, {
    key: 'mesh',
    set: function set(mesh) {
      this._mesh = mesh;
    },
    get: function get() {
      return this._mesh;
    }
  }, {
    key: 'geometry',
    set: function set(geometry) {
      this._geometry = geometry;
    },
    get: function get() {
      return this._geometry;
    }
  }, {
    key: 'canvasWidth',
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._uniforms.uCanvasWidth.value = this._canvasWidth;
    },
    get: function get() {
      return this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._uniforms.uCanvasHeight.value = this._canvasHeight;
    },
    get: function get() {
      return this._canvasHeight;
    }
  }, {
    key: 'borderColor',
    set: function set(borderColor) {
      this._borderColor = borderColor;
      this._uniforms.uBorderColor.value = new THREE.Color(borderColor);
    },
    get: function get() {
      return this._borderColor;
    }
  }]);

  return HelpersSlice;
}((0, _helpersMaterial2.default)(THREE.Object3D));

exports.default = HelpersSlice;

},{"../geometries/geometries.slice":108,"../helpers/helpers.material.mixin":115,"../shaders/shaders.data.fragment":152,"../shaders/shaders.data.uniform":153,"../shaders/shaders.data.vertex":154}],119:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _helpers = require('../helpers/helpers.border');

var _helpers2 = _interopRequireDefault(_helpers);

var _helpers3 = require('../helpers/helpers.boundingbox');

var _helpers4 = _interopRequireDefault(_helpers3);

var _helpers5 = require('../helpers/helpers.slice');

var _helpers6 = _interopRequireDefault(_helpers5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * Helper to easily display and interact with a stack.<br>
 *<br>
 * Defaults:<br>
 *   - orientation: 0 (acquisition direction)<br>
 *   - index: middle slice in acquisition direction<br>
 *<br>
 * Features:<br>
 *   - slice from the stack (in any direction)<br>
 *   - slice border<br>
 *   - stack bounding box<br>
 *<br>
 * Live demo at: {@link http://jsfiddle.net/gh/get/library/pure/fnndsc/ami/tree/master/lessons/01#run|Lesson 01}
 *
 * @example
 * let stack = new VJS.Models.Stack();
 * ... // prepare the stack
 *
 * let stackHelper = new VJS.Helpers.Stack(stack);
 * stackHelper.bbox.color = 0xF9F9F9;
 * stackHelper.border.color = 0xF9F9F9;
 *
 * let scene = new THREE.Scene();
 * scene.add(stackHelper);
 *
 * @extends THREE.Object3D
 *
 * @see module:helpers/border
 * @see module:helpers/boundingbox
 * @see module:helpers/slice
 *
 * @module helpers/stack
 */
var HelpersStack = function (_THREE$Object3D) {
  _inherits(HelpersStack, _THREE$Object3D);

  function HelpersStack(stack) {
    _classCallCheck(this, HelpersStack);

    var _this = _possibleConstructorReturn(this, (HelpersStack.__proto__ || Object.getPrototypeOf(HelpersStack)).call(this));
    //


    _this._stack = stack;
    _this._bBox = null;
    _this._slice = null;
    _this._border = null;
    _this._dummy = null;

    _this._orientation = 0;
    _this._index = 0;

    _this._uniforms = null;
    _this._autoWindowLevel = false;
    _this._outOfBounds = false;
    _this._orientationMaxIndex = 0;

    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._borderColor = null;

    // this._arrow = {
    //   visible: true,
    //   color: 0xFFF336,
    //   length: 20,
    //   material: null,
    //   geometry: null,
    //   mesh: null
    // };
    _this._create();
    return _this;
  }

  //
  // PUBLIC METHODS
  //

  //
  // SETTERS/GETTERS
  //

  /**
   * Get stack.
   *
   * @type {ModelsStack}
   */


  _createClass(HelpersStack, [{
    key: '_create',


    //
    // PRIVATE METHODS
    //

    /**
     * Initial setup, including stack prepare, bbox prepare, slice prepare and
     * border prepare.
     *
     * @private
     */
    value: function _create() {
      if (this._stack) {
        // prepare sthe stack internals
        this._prepareStack();

        // prepare visual objects
        this._prepareBBox();
        this._prepareSlice();
        this._prepareBorder();
        // todo: Arrow
      } else {
        window.console.log('no stack to be prepared...');
      }
    }
  }, {
    key: '_computeOrientationMaxIndex',
    value: function _computeOrientationMaxIndex() {
      var dimensionsIJK = this._stack.dimensionsIJK;
      this._orientationMaxIndex = 0;
      switch (this._orientation) {
        case 0:
          this._orientationMaxIndex = dimensionsIJK.z - 1;
          break;
        case 1:
          this._orientationMaxIndex = dimensionsIJK.x - 1;
          break;
        case 2:
          this._orientationMaxIndex = dimensionsIJK.y - 1;
          break;
        default:
          // do nothing!
          break;
      }
    }

    /**
     * Given orientation, check if index is in/out of bounds.
     *
     * @private
     */

  }, {
    key: '_isIndexOutOfBounds',
    value: function _isIndexOutOfBounds() {
      this._computeOrientationMaxIndex();
      if (this._index >= this._orientationMaxIndex || this._index < 0) {
        this._outOfBounds = true;
      } else {
        this._outOfBounds = false;
      }
    }

    /**
     * Prepare a stack for visualization. (image to world transform, frames order,
     * pack data into 8 bits textures, etc.)
     *
     * @private
     */

  }, {
    key: '_prepareStack',
    value: function _prepareStack() {
      // make sure there is something, if not throw an error
      // compute image to workd transform, order frames, etc.
      if (!this._stack.prepared) {
        this._stack.prepare();
      }
      // pack data into 8 bits rgba texture for the shader
      // this one can be slow...
      if (!this._stack.packed) {
        this._stack.pack();
      }
    }

    /**
     * Setup bounding box helper given prepared stack and add bounding box helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareBBox',
    value: function _prepareBBox() {
      this._bBox = new _helpers4.default(this._stack);
      this.add(this._bBox);
    }

    /**
     * Setup border helper given slice helper and add border helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareBorder',
    value: function _prepareBorder() {
      this._border = new _helpers2.default(this._slice);
      this.add(this._border);
    }

    /**
     * Setup slice helper given prepared stack helper and add slice helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareSlice',
    value: function _prepareSlice() {
      var halfDimensionsIJK = this._stack.halfDimensionsIJK;
      // compute initial index given orientation
      this._index = this._prepareSliceIndex(halfDimensionsIJK);
      // compute initial position given orientation and index
      var position = this._prepareSlicePosition(halfDimensionsIJK, this._index);
      // compute initial direction orientation
      var direction = this._prepareDirection(this._orientation);

      this._slice = new _helpers6.default(this._stack, this._index, position, direction);
      this.add(this._slice);
    }

    /**
     * Compute slice index depending on orientation.
     *
     * @param {THREE.Vector3} indices - Indices in each direction.
     *
     * @returns {number} Slice index according to current orientation.
     *
     * @private
     */

  }, {
    key: '_prepareSliceIndex',
    value: function _prepareSliceIndex(indices) {
      var index = 0;
      switch (this._orientation) {
        case 0:
          index = Math.floor(indices.z);
          break;
        case 1:
          index = Math.floor(indices.x);
          break;
        case 2:
          index = Math.floor(indices.y);
          break;
        default:
          // do nothing!
          break;
      }
      return index;
    }

    /**
     * Compute slice position depending on orientation.
     * Sets index in proper location of reference position.
     *
     * @param {THREE.Vector3} rPosition - Reference position.
     * @param {number} index - Current index.
     *
     * @returns {number} Slice index according to current orientation.
     *
     * @private
     */

  }, {
    key: '_prepareSlicePosition',
    value: function _prepareSlicePosition(rPosition, index) {
      var position = new THREE.Vector3(0, 0, 0);
      switch (this._orientation) {
        case 0:
          position = new THREE.Vector3(Math.floor(rPosition.x), Math.floor(rPosition.y), index);
          break;
        case 1:
          position = new THREE.Vector3(index, Math.floor(rPosition.y), Math.floor(rPosition.z));
          break;
        case 2:
          position = new THREE.Vector3(Math.floor(rPosition.x), index, Math.floor(rPosition.z));
          break;
        default:
          // do nothing!
          break;
      }
      return position;
    }

    /**
     * Compute slice direction depending on orientation.
     *
     * @param {number} orientation - Slice orientation.
     *
     * @returns {THREE.Vector3} Slice direction
     *
     * @private
     */

  }, {
    key: '_prepareDirection',
    value: function _prepareDirection(orientation) {
      var direction = new THREE.Vector3(0, 0, 1);
      switch (orientation) {
        case 0:
          direction = new THREE.Vector3(0, 0, 1);
          break;
        case 1:
          direction = new THREE.Vector3(1, 0, 0);
          break;
        case 2:
          direction = new THREE.Vector3(0, 1, 0);
          break;
        default:
          // do nothing!
          break;
      }

      return direction;
    }

    /**
     * Release the stack helper memory including the slice memory.
     *
     * @public
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this.remove(this._slice);
      this._slice.dispose();
      this._slice = null;
      this._bBox.dispose();
      this._bBox = null;
      this._border.dispose();
      this._border = null;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    }

    /**
     * Set stack.
     *
     * @type {ModelsStack}
     */
    ,
    set: function set(stack) {
      this._stack = stack;
    }

    /**
     * Get bounding box helper.
     *
     * @type {HelpersBoundingBox}
     */

  }, {
    key: 'bbox',
    get: function get() {
      return this._bBox;
    }

    /**
     * Get slice helper.
     *
     * @type {HelpersSlice}
     */

  }, {
    key: 'slice',
    get: function get() {
      return this._slice;
    }

    /**
     * Get border helper.
     *
     * @type {HelpersSlice}
     */

  }, {
    key: 'border',
    get: function get() {
      return this._border;
    }

    /**
     * Set/get current slice index.<br>
     * Sets outOfBounds flag to know if target index is in/out stack bounding box.<br>
     * <br>
     * Internally updates the sliceHelper index and position. Also updates the
     * borderHelper with the updated sliceHelper.
     *
     * @type {number}
     */

  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;

      // update the slice
      this._slice.index = index;
      var halfDimensions = this._stack.halfDimensionsIJK;
      this._slice.planePosition = this._prepareSlicePosition(halfDimensions, this._index);

      // also update the border
      this._border.helpersSlice = this._slice;

      // update ourOfBounds flag
      this._isIndexOutOfBounds();
    }

    /**
     * Set/get current slice orientation.<br>
     * Values: <br>
     *   - 0: acquisition direction (slice normal is z_cosine)<br>
     *   - 1: next direction (slice normal is x_cosine)<br>
     *   - 2: next direction (slice normal is y_cosine)<br>
     *   - n: set orientation to 0<br>
     * <br>
     * Internally updates the sliceHelper direction. Also updates the
     * borderHelper with the updated sliceHelper.
     *
     * @type {number}
     */

  }, {
    key: 'orientation',
    set: function set(orientation) {
      this._orientation = orientation;
      this._computeOrientationMaxIndex();

      this._slice.planeDirection = this._prepareDirection(this._orientation);

      // also update the border
      this._border.helpersSlice = this._slice;
    },
    get: function get() {
      return this._orientation;
    }

    /**
     * Set/get the outOfBound flag.
     *
     * @type {boolean}
     */

  }, {
    key: 'outOfBounds',
    set: function set(outOfBounds) {
      this._outOfBounds = outOfBounds;
    },
    get: function get() {
      return this._outOfBounds;
    }

    /**
     * Set/get the orientationMaxIndex flag.
     *
     * @type {boolean}
     */

  }, {
    key: 'orientationMaxIndex',
    set: function set(orientationMaxIndex) {
      this._orientationMaxIndex = orientationMaxIndex;
    },
    get: function get() {
      return this._orientationMaxIndex;
    }
  }, {
    key: 'canvasWidth',
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._slice.canvasWidth = this._canvasWidth;
    },
    get: function get() {
      return this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._slice.canvasHeight = this._canvasHeight;
    },
    get: function get() {
      return this._canvasHeight;
    }
  }, {
    key: 'borderColor',
    set: function set(borderColor) {
      this._borderColor = borderColor;
      this._border.color = borderColor;
      this._slice.borderColor = this._borderColor;
    },
    get: function get() {
      return this._borderColor;
    }
  }]);

  return HelpersStack;
}(THREE.Object3D);

exports.default = HelpersStack;

},{"../helpers/helpers.border":110,"../helpers/helpers.boundingbox":111,"../helpers/helpers.slice":118}],120:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shadersVr = require('../shaders/shaders.vr.uniform');

var _shadersVr2 = _interopRequireDefault(_shadersVr);

var _shadersVr3 = require('../shaders/shaders.vr.vertex');

var _shadersVr4 = _interopRequireDefault(_shadersVr3);

var _shadersVr5 = require('../shaders/shaders.vr.fragment');

var _shadersVr6 = _interopRequireDefault(_shadersVr5);

var _helpersMaterial = require('../helpers/helpers.material.mixin');

var _helpersMaterial2 = _interopRequireDefault(_helpersMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * @module helpers/volumerendering
 */

var HelpersVolumeRendering = function (_HelpersMaterialMixin) {
  _inherits(HelpersVolumeRendering, _HelpersMaterialMixin);

  function HelpersVolumeRendering(stack) {
    _classCallCheck(this, HelpersVolumeRendering);

    var _this = _possibleConstructorReturn(this, (HelpersVolumeRendering.__proto__ || Object.getPrototypeOf(HelpersVolumeRendering)).call(this));
    //


    _this._stack = stack;
    _this._textures = [];
    _this._shadersFragment = _shadersVr6.default;
    _this._shadersVertex = _shadersVr4.default;
    _this._uniforms = _shadersVr2.default.uniforms();
    _this._material = null;
    _this._geometry = null;

    _this._interpolation = 1; // default to trilinear interpolation

    _this._create();
    return _this;
  }

  _createClass(HelpersVolumeRendering, [{
    key: '_create',
    value: function _create() {
      this._prepareStack();
      this._prepareTexture();
      this._prepareMaterial();
      this._prepareGeometry();

      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this.add(this._mesh);
    }
  }, {
    key: '_prepareStack',
    value: function _prepareStack() {
      if (!this._stack.prepared) {
        this._stack.prepare();
      }

      if (!this._stack.packed) {
        this._stack.pack();
      }
    }
  }, {
    key: '_prepareMaterial',
    value: function _prepareMaterial() {
      // compensate for the offset to only pass > 0 values to shaders
      // models > models.stack.js : _packTo8Bits
      var offset = 0;
      if (this._stack._minMax[0] < 0) {
        offset = this._stack._minMax[0];
      }

      // uniforms
      this._uniforms = _shadersVr2.default.uniforms();
      this._uniforms.uWorldBBox.value = this._stack.worldBoundingBox();
      this._uniforms.uTextureSize.value = this._stack.textureSize;
      this._uniforms.uTextureContainer.value = this._textures;
      this._uniforms.uWorldToData.value = this._stack.lps2IJK;
      this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
      this._uniforms.uPixelType.value = this._stack.pixelType;
      this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
      this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;
      this._uniforms.uWindowCenterWidth.value = [offset + this._stack.windowCenter, this._stack.windowWidth * 0.8];
      this._uniforms.uRescaleSlopeIntercept.value = [this._stack.rescaleSlope, this._stack.rescaleIntercept];
      this._uniforms.uDataDimensions.value = [this._stack.dimensionsIJK.x, this._stack.dimensionsIJK.y, this._stack.dimensionsIJK.z];
      this._uniforms.uInterpolation.value = this._interpolation;

      this._createMaterial({
        side: THREE.FrontSide,
        transparent: true
      });
    }
  }, {
    key: '_prepareGeometry',
    value: function _prepareGeometry() {
      var worldBBox = this._stack.worldBoundingBox();
      var centerLPS = this._stack.worldCenter();

      this._geometry = new THREE.BoxGeometry(worldBBox[1] - worldBBox[0], worldBBox[3] - worldBBox[2], worldBBox[5] - worldBBox[4]);
      this._geometry.applyMatrix(new THREE.Matrix4().makeTranslation(centerLPS.x, centerLPS.y, centerLPS.z));
    }
  }, {
    key: 'uniforms',
    get: function get() {
      return this._uniforms;
    },
    set: function set(uniforms) {
      this._uniforms = uniforms;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    },
    set: function set(stack) {
      this._stack = stack;
    }
  }, {
    key: 'interpolation',
    get: function get() {
      return this._interpolation;
    },
    set: function set(interpolation) {
      this._interpolation = interpolation;
      this._uniforms.uInterpolation.value = this._interpolation;
      this._updateMaterial();
    }
  }]);

  return HelpersVolumeRendering;
}((0, _helpersMaterial2.default)(THREE.Object3D));

exports.default = HelpersVolumeRendering;

},{"../helpers/helpers.material.mixin":115,"../shaders/shaders.vr.fragment":162,"../shaders/shaders.vr.uniform":163,"../shaders/shaders.vr.vertex":164}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module helpers/x/interactor
 */
var Interactor = function () {
  function Interactor() {
    _classCallCheck(this, Interactor);
  }

  // private methods


  _createClass(Interactor, [{
    key: "_create",
    value: function _create() {}
  }, {
    key: "_update",
    value: function _update() {}
  }]);

  return Interactor;
}();

exports.default = Interactor;

},{}],122:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpersX = require('./helpers.x.interactor');

var _helpersX2 = _interopRequireDefault(_helpersX);

var _helpersX3 = require('./helpers.x.mesh');

var _helpersX4 = _interopRequireDefault(_helpersX3);

var _helpersX5 = require('./helpers.x.renderer3d');

var _helpersX6 = _interopRequireDefault(_helpersX5);

var _helpersX7 = require('./helpers.x.renderer2d');

var _helpersX8 = _interopRequireDefault(_helpersX7);

var _helpersX9 = require('./helpers.x.volume');

var _helpersX10 = _interopRequireDefault(_helpersX9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module helpers
 */

exports.default = {
  Interactor: _helpersX2.default,
  Mesh: _helpersX4.default,
  Renderer3D: _helpersX6.default,
  Renderer2D: _helpersX8.default,
  Volume: _helpersX10.default
};

},{"./helpers.x.interactor":121,"./helpers.x.mesh":123,"./helpers.x.renderer2d":124,"./helpers.x.renderer3d":125,"./helpers.x.volume":126}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module helpers/x/mesh
 */
var _class = function () {
  function _class() {
    _classCallCheck(this, _class);

    this._file = null;

    this._3jsVTK_loader = new THREE.VTKLoader();
    this._mesh = null;
    this._materialColor = 0xE91E63;
    this._RAStoLPS = null;
    this._material = new THREE.MeshLambertMaterial({
      shading: THREE.SmoothShading,
      color: this._materialColor,
      side: THREE.DoubleSide });
  }

  // accessor properties


  _createClass(_class, [{
    key: "load",


    // load function
    value: function load() {
      var _this = this;

      if (this.file) {
        return new Promise(function (resolve, reject) {
          _this._3jsVTK_loader.load(_this.file, function (geometry) {
            geometry.computeVertexNormals();
            _this._mesh = new THREE.Mesh(geometry, _this._material);
            _this._RAStoLPS = new THREE.Matrix4();
            _this._RAStoLPS.set(-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            _this._mesh.applyMatrix(_this._RAStoLPS);
            // resolve the promise and return the mesh
            resolve(_this._mesh);
          }, function () {}, function (error) {
            console.log(error);
            reject({
              message: "Couldn't load file: " + _this.file + ".",
              error: error
            });
          });
        });
      }

      return Promise.reject({ message: "File is not defined: " + this.file + "." });
    }
  }, {
    key: "file",
    get: function get() {
      return this._file;
    },
    set: function set(fname) {
      this._file = fname;
    }
  }, {
    key: "materialColor",
    get: function get() {
      return this._materialColor;
    },
    set: function set(color) {
      this._materialColor = color;
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],124:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @module helpers/x/renderer2d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _cameras = require('../../cameras/cameras.orthographic');

var _cameras2 = _interopRequireDefault(_cameras);

var _controls = require('../../controls/controls.trackballortho');

var _controls2 = _interopRequireDefault(_controls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {
  function _class() {
    var containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'r2d';
    var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

    _classCallCheck(this, _class);

    this._container = null;
    this._renderer = null;
    this._camera = null;
    this._controls = null;
    this._orientation = orientation;
    this._scene = null;
    this._object = null;

    this._initRenderer(containerId);
    this._initCamera();
    this._initScene();
    this._initControls();

    // setup event listeners
    this._onScroll = this._onScroll.bind(this);
    this._onWindowResize = this._onWindowResize.bind(this);
    this.addEventListeners();
  }

  _createClass(_class, [{
    key: 'add',
    value: function add(object) {
      this._object = object;
      this._scene.add(this._object);

      this._setupCamera(this._object.stack);
      this._orientCamera(this._object, this._orientation);

      this._object.canvasWidth = this._container.clientWidth;
      this._object.canvasHeight = this._container.clientHeight;
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._controls.addEventListener('OnScroll', this._onScroll, false);
      window.addEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._controls.removeEventListener('OnScroll', this._onScroll, false);
      window.removeEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'animate',
    value: function animate() {
      this._controls.update();
      this._renderer.render(this._scene, this._camera);

      // request new frame
      requestAnimationFrame(this.animate.bind(this));
    }

    // private methods

  }, {
    key: '_initRenderer',
    value: function _initRenderer(containerId) {
      // renderer
      this._container = document.getElementById(containerId);
      this._renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._renderer.setClearColor(0x212121, 1);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._container.appendChild(this._renderer.domElement);
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      this._camera = new _cameras2.default(this._container.clientWidth / -2, this._container.clientWidth / 2, this._container.clientHeight / 2, this._container.clientHeight / -2, 1, 1000);
    }
  }, {
    key: '_initScene',
    value: function _initScene() {
      this._scene = new THREE.Scene();
    }
  }, {
    key: '_initControls',
    value: function _initControls() {
      // controls
      this._controls = new _controls2.default(this._camera, this._container);
      this._controls.staticMoving = true;
      this._controls.noRotate = true;
      this._camera.controls = this._controls;
    }
  }, {
    key: '_setupCamera',
    value: function _setupCamera(stack) {
      // set camera
      var worldbb = stack.worldBoundingBox();
      var lpsDims = new THREE.Vector3(worldbb[1] - worldbb[0], worldbb[3] - worldbb[2], worldbb[5] - worldbb[4]);

      // box: {halfDimensions, center}
      var box = {
        center: stack.worldCenter().clone(),
        halfDimensions: new THREE.Vector3(lpsDims.x + 10, lpsDims.y + 10, lpsDims.z + 10)
      };

      // init and zoom
      var canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };

      this._camera.directions = [stack.xCosine, stack.yCosine, stack.zCosine];
      this._camera.box = box;
      this._camera.canvas = canvas;
      this._camera.update();
      this._camera.fitBox(2);
    }
  }, {
    key: '_orientCamera',
    value: function _orientCamera(target) {
      var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

      this._camera.orientation = orientation;
      this._camera.update();
      this._camera.fitBox(2);
      target.orientation = this._camera.stackOrientation;
    }
  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._camera.canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };
      this._camera.fitBox(2);
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._object.canvasWidth = this._container.clientWidth;
      this._object.canvasHeight = this._container.clientHeight;
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      if (event.delta > 0) {
        if (this._object.index >= this._object.orientationMaxIndex) {
          return false;
        }
        this._object.index += 1;
      } else {
        if (this._object.index <= 0) {
          return false;
        }
        this._object.index -= 1;
      }
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"../../cameras/cameras.orthographic":97,"../../controls/controls.trackballortho":100}],125:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @module helpers/x/renderer3d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _controls = require('../../controls/controls.trackball');

var _controls2 = _interopRequireDefault(_controls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {
  function _class() {
    var containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'r3d';

    _classCallCheck(this, _class);

    this._container = null;
    this._renderer = null;
    this._camera = null;
    this._controls = null;
    this._scene = null;

    this._initRenderer(containerId);
    this._initCamera();
    this._initScene();
    this._initControls();

    // setup event listeners
    this._onWindowResize = this._onWindowResize.bind(this);
    this.addEventListeners();
  }

  _createClass(_class, [{
    key: 'add',
    value: function add(obj) {
      this._scene.add(obj);
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      window.addEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      window.removeEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'center',
    value: function center(worldPosition) {
      // update camrea's and control's target
      this._camera.lookAt(worldPosition.x, worldPosition.y, worldPosition.z);
      this._camera.updateProjectionMatrix();
      this._controls.target.set(worldPosition.x, worldPosition.y, worldPosition.z);
    }
  }, {
    key: 'animate',
    value: function animate() {
      this._controls.update();
      this._renderer.render(this._scene, this._camera);

      // request new frame
      requestAnimationFrame(this.animate.bind(this));
    }

    // private methods

  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._camera.aspect = this._container.clientWidth / this._container.clientHeight;
      this._camera.updateProjectionMatrix();

      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
    }
  }, {
    key: '_initRenderer',
    value: function _initRenderer(containerId) {
      // renderer
      this._container = document.getElementById(containerId);
      this._renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._renderer.setClearColor(0x424242, 1);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._container.appendChild(this._renderer.domElement);
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      this._camera = new THREE.PerspectiveCamera(45, this._container.clientWidth / this._container.clientHeight, 1, 10000000);
      this._camera.position.x = 250;
      this._camera.position.y = 250;
      this._camera.position.z = 250;
    }
  }, {
    key: '_initScene',
    value: function _initScene() {
      // add some lights to the scene by default
      this._scene = new THREE.Scene();

      // ambient
      this._scene.add(new THREE.AmbientLight(0x353535));

      // directional 1
      var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(200, 200, 1000).normalize();
      this._scene.add(directionalLight);

      // directional 2
      var directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight2.position.set(-200, -200, -1000).normalize();
      this._scene.add(directionalLight2);
    }
  }, {
    key: '_initControls',
    value: function _initControls() {
      // controls
      this._controls = new _controls2.default(this._camera, this._container);
      this._controls.rotateSpeed = 1.4;
      this._controls.zoomSpeed = 1.2;
      this._controls.panSpeed = 0.8;
    }
  }, {
    key: 'container',
    set: function set(container) {
      this._container = container;
    },
    get: function get() {
      return this._container;
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"../../controls/controls.trackball":99}],126:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _helpers = require('../helpers.stack');

var _helpers2 = _interopRequireDefault(_helpers);

var _loaders = require('../../loaders/loaders.volume');

var _loaders2 = _interopRequireDefault(_loaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module helpers/x/volume
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _class = function (_THREE$Object3D) {
  _inherits(_class, _THREE$Object3D);

  function _class() {
    _classCallCheck(this, _class);

    var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));

    _this._file = null;
    _this._progressbarContainer = null;
    _this._stack = null;
    _this._centerLPS = null;
    _this._xSlice = null;
    _this._ySlice = null;
    _this._zSlice = null;
    return _this;
  }

  // accessor properties


  _createClass(_class, [{
    key: '_createSlice',


    // private methods
    value: function _createSlice(orientation) {
      if (this._stack) {
        var stackHelper = new _helpers2.default(this._stack);
        stackHelper.orientation = orientation;

        if (orientation === 0) {
          stackHelper.border.color = 0xF44336;
          this._xSlice = stackHelper;
        } else if (orientation === 1) {
          stackHelper.bbox.visible = false;
          stackHelper.border.color = 0x4CAF50;
          this._ySlice = stackHelper;
        } else {
          stackHelper.bbox.visible = false;
          stackHelper.border.color = 0x2196F3;
          this._zSlice = stackHelper;
        }

        this._centerLPS = stackHelper.stack.worldCenter();
      }
    }

    // public methods

  }, {
    key: 'load',
    value: function load() {
      var _this2 = this;

      if (this.file) {
        // instantiate the loader
        // it loads and parses the dicom image
        var loader = new _loaders2.default(this._progressbarContainer);
        return loader.load(this.file).then(function () {
          return new Promise(function (resolve, reject) {
            if (loader.data.length <= 0) {
              return reject({ message: 'No data loaded: ' + loader.data + '.' });
            }

            // create the three slices when all files have been loaded
            var series = loader.data[0].mergeSeries(loader.data)[0];
            loader.free();

            _this2._stack = series.stack[0];
            _this2._createSlice(0);
            _this2.add(_this2._xSlice);
            _this2._createSlice(1);
            _this2.add(_this2._ySlice);
            _this2._createSlice(2);
            _this2.add(_this2._zSlice);

            return resolve(_this2);
          });
        }).catch(function (error) {
          loader.free();
          window.console.log('Something went wrong loading the volume...');
          window.console.log(error);
        });
      }

      return Promise.reject({ message: 'File not defined: ' + this.file + '.' });
    }
  }, {
    key: 'file',
    get: function get() {
      return this._file;
    },
    set: function set(fname) {
      this._file = fname;
    }
  }, {
    key: 'progressbarContainer',
    set: function set(container) {
      this._progressbarContainer = container;
    }
  }, {
    key: 'centerLPS',
    get: function get() {
      return this._centerLPS;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    }
  }]);

  return _class;
}(THREE.Object3D);

exports.default = _class;

},{"../../loaders/loaders.volume":129,"../helpers.stack":119}],127:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _helpers = require('../helpers/helpers.progressbar');

var _helpers2 = _interopRequireDefault(_helpers);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** Imports **/


/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/base
 * @extends EventEmitter
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
var LoadersBase = function (_EventEmitter) {
  _inherits(LoadersBase, _EventEmitter);

  /**
   * Create a Loader.
   * @param {dom} container - The dom container of loader.
   * @param {object} ProgressBar - The progressbar of loader.
   */
  function LoadersBase() {
    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var ProgressBar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _helpers2.default;

    _classCallCheck(this, LoadersBase);

    var _this = _possibleConstructorReturn(this, (LoadersBase.__proto__ || Object.getPrototypeOf(LoadersBase)).call(this));

    _this._loaded = -1;
    _this._totalLoaded = -1;
    _this._parsed = -1;
    _this._totalParsed = -1;

    _this._data = [];

    _this._container = container;
    _this._progressBar = null;
    if (_this._container && ProgressBar) {
      _this._progressBar = new ProgressBar(_this._container);
    }
    return _this;
  }

  /**
   * free the reference.
   */


  _createClass(LoadersBase, [{
    key: 'free',
    value: function free() {
      this._container = null;
      // this._helpersProgressBar = null;

      if (this._progressBar) {
        this._progressBar.free();
        this._progressBar = null;
      }
    }

    /**
     * load the resource by url.
     * @param {string} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'fetch',
    value: function fetch(url) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open('GET', url);
        request.crossOrigin = true;
        request.responseType = 'arraybuffer';

        request.onloadstart = function (event) {
          // emit 'fetch-start' event
          _this2.emit('fetch-start', {
            file: url,
            time: new Date()
          });
        };

        request.onload = function (event) {
          if (request.status === 200) {
            _this2._loaded = event.loaded;
            _this2._totalLoaded = event.total;

            // will be removed after eventer set up
            if (_this2._progressBar) {
              _this2._progressBar.update(_this2._loaded, _this2._totalLoaded, 'load');
            }

            var buffer = request.response;
            var response = {
              url: url,
              buffer: buffer
            };

            // emit 'fetch-success' event
            _this2.emit('fetch-success', {
              file: url,
              time: new Date(),
              totalLoaded: event.total
            });

            resolve(response);
          } else {
            reject(request.statusText);
          }
        };

        request.onerror = function () {
          // emit 'fetch-error' event
          _this2.emit('fetch-error', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.onabort = function (event) {
          // emit 'fetch-start' event
          _this2.emit('fetch-abort', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.ontimeout = function () {
          // emit 'fetch-timeout' event
          _this2.emit('fetch-timeout', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.onprogress = function (event) {
          _this2._loaded = event.loaded;
          _this2._totalLoaded = event.total;
          // emit 'fetch-progress' event
          _this2.emit('fetch-progress', {
            file: url,
            total: event.total,
            loaded: event.loaded,
            time: new Date()
          });
          // will be removed after eventer set up
          if (_this2._progressBar) {
            _this2._progressBar.update(_this2._loaded, _this2._totalLoaded, 'load');
          }
        };

        request.onloadend = function (event) {
          // emit 'fetch-end' event
          _this2.emit('fetch-end', {
            file: url,
            time: new Date()
          });
          // just use onload when success and onerror when failure, etc onabort
          // reject(request.statusText);
        };

        request.send();
      });
    }

    /**
     * parse the data loaded
     * SHOULD BE implementd by detail loader.
     * @param {object} response - loaded data.
     * @return {promise} promise.
     */

  }, {
    key: 'parse',
    value: function parse(response) {
      return new Promise(function (resolve, reject) {
        resolve(response);
      });
    }

    /**
     * default load sequence group promise.
     * @param {array} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'loadSequenceGroup',
    value: function loadSequenceGroup(url) {
      var _this3 = this;

      var fetchSequence = [];

      url.forEach(function (file) {
        fetchSequence.push(_this3.fetch(file));
      });

      return Promise.all(fetchSequence).then(function (rawdata) {
        return _this3.parse(rawdata);
      }).then(function (data) {
        _this3._data.push(data);
        return data;
      }).catch(function (error) {
        window.console.log('oops... something went wrong...');
        window.console.log(error);
      });
    }

    /**
     * default load sequence promise.
     * @param {string} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'loadSequence',
    value: function loadSequence(url) {
      var _this4 = this;

      return this.fetch(url).then(function (rawdata) {
        return _this4.parse(rawdata);
      }).then(function (data) {
        _this4._data.push(data);
        return data;
      }).catch(function (error) {
        window.console.log('oops... something went wrong...');
        window.console.log(error);
      });
    }

    /**
     * load the data by url(urls)
     * @param {string|array} url - resource url.
     * @return {promise} promise
     */

  }, {
    key: 'load',
    value: function load(url) {
      var _this5 = this;

      // if we load a single file, convert it to an array
      if (!Array.isArray(url)) {
        url = [url];
      }

      // emit 'load-start' event
      this.emit('load-start', {
        files: url,
        time: new Date()
      });

      var loadSequences = [];
      url.forEach(function (file) {
        if (!Array.isArray(file)) {
          loadSequences.push(_this5.loadSequence(file));
        } else {
          loadSequences.push(_this5.loadSequenceGroup(file));
        }
      });
      return Promise.all(loadSequences);
    }

    /**
     * Set data
     * @param {array} data
     */

  }, {
    key: 'data',
    set: function set(data) {
      this._data = data;
    }

    /**
     * Get data
     * @return {array} data loaded
     */
    ,
    get: function get() {
      return this._data;
    }
  }]);

  return LoadersBase;
}(_events2.default);

exports.default = LoadersBase;

},{"../helpers/helpers.progressbar":117,"events":26}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loaders = require('./loaders.volume');

var _loaders2 = _interopRequireDefault(_loaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module loaders
 */

exports.default = {
  Volume: _loaders2.default
};

},{"./loaders.volume":129}],129:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _loaders = require('./loaders.base');

var _loaders2 = _interopRequireDefault(_loaders);

var _core = require('../core/core.utils');

var _core2 = _interopRequireDefault(_core);

var _models = require('../models/models.series');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('../models/models.stack');

var _models4 = _interopRequireDefault(_models3);

var _models5 = require('../models/models.frame');

var _models6 = _interopRequireDefault(_models5);

var _parsers = require('../parsers/parsers.dicom');

var _parsers2 = _interopRequireDefault(_parsers);

var _parsers3 = require('../parsers/parsers.mhd');

var _parsers4 = _interopRequireDefault(_parsers3);

var _parsers5 = require('../parsers/parsers.nifti');

var _parsers6 = _interopRequireDefault(_parsers5);

var _parsers7 = require('../parsers/parsers.nrrd');

var _parsers8 = _interopRequireDefault(_parsers7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** * Imports ***/
var PAKO = require('pako');

/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/volumes
 * @extends LoadersBase
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
var LoadersVolumes = function (_LoadersBase) {
  _inherits(LoadersVolumes, _LoadersBase);

  function LoadersVolumes() {
    _classCallCheck(this, LoadersVolumes);

    return _possibleConstructorReturn(this, (LoadersVolumes.__proto__ || Object.getPrototypeOf(LoadersVolumes)).apply(this, arguments));
  }

  _createClass(LoadersVolumes, [{
    key: 'parse',


    /**
     * Parse response.
     * response is formated as:
     *    {
     *      url: 'resource url',
     *      buffer: xmlresponse,
     *    }
     * @param {object} response - response
     * @return {promise} promise
     */
    value: function parse(response) {
      var _this2 = this;

      // emit 'parse-start' event
      this.emit('parse-start', {
        file: response.url,
        time: new Date()
      });
      // give a chance to the UI to update because
      // after the rendering will be blocked with intensive JS
      // will be removed after eventer set up
      if (this._progressBar) {
        this._progressBar.update(0, 100, 'parse');
      }

      return new Promise(function (resolve, reject) {
        window.setTimeout(function () {
          resolve(new Promise(function (resolve, reject) {
            var data = response;

            if (!Array.isArray(data)) {
              data = [data];
            }

            data.forEach(function (dataset) {
              _this2._preprocess(dataset);
            });

            if (data.length === 1) {
              data = data[0];
            } else {
              // if raw/mhd pair
              var mhdFile = data.filter(_this2._filterByExtension.bind(null, 'MHD'));
              var rawFile = data.filter(_this2._filterByExtension.bind(null, 'RAW'));
              if (data.length === 2 && mhdFile.length === 1 && rawFile.length === 1) {
                data.url = mhdFile[0].url;
                data.extension = mhdFile[0].extension;
                data.mhdBuffer = mhdFile[0].buffer;
                data.rawBuffer = rawFile[0].buffer;
              }
            }

            var Parser = _this2._parser(data.extension);
            if (!Parser) {
              // emit 'parse-error' event
              _this2.emit('parse-error', {
                file: response.url,
                time: new Date(),
                error: data.filename + 'can not be parsed.'
              });
              reject(data.filename + ' can not be parsed.');
            }

            // check extension
            var volumeParser = null;
            try {
              volumeParser = new Parser(data, 0);
            } catch (e) {
              window.console.log(e);
              // emit 'parse-error' event
              _this2.emit('parse-error', {
                file: response.url,
                time: new Date(),
                error: e
              });
              reject(e);
            }

            // create a series
            var series = new _models2.default();
            // global information
            series.seriesInstanceUID = volumeParser.seriesInstanceUID();
            series.transferSyntaxUID = volumeParser.transferSyntaxUID();
            series.seriesDescription = volumeParser.seriesDescription();
            series.studyDescription = volumeParser.studyDescription();
            series.numberOfFrames = volumeParser.numberOfFrames();
            if (!series.numberOfFrames) {
              series.numberOfFrames = 1;
            }
            series.numberOfChannels = volumeParser.numberOfChannels();
            series.modality = volumeParser.modality();
            // if it is a segmentation, attach extra information
            if (series.modality === 'SEG') {
              // colors
              // labels
              // etc.
              series.segmentationType = volumeParser.segmentationType();
              series.segmentationSegments = volumeParser.segmentationSegments();
            }
            // patient information
            series.patientID = volumeParser.patientID();
            series.patientName = volumeParser.patientName();
            series.patientAge = volumeParser.patientAge();
            series.patientBirthdate = volumeParser.patientBirthdate();
            series.patientSex = volumeParser.patientSex();

            // just create 1 dummy stack for now
            var stack = new _models4.default();
            stack.numberOfChannels = volumeParser.numberOfChannels();
            stack.pixelRepresentation = volumeParser.pixelRepresentation();
            stack.pixelType = volumeParser.pixelType();
            stack.invert = volumeParser.invert();
            stack.spacingBetweenSlices = volumeParser.spacingBetweenSlices();
            stack.modality = series.modality;
            // if it is a segmentation, attach extra information
            if (stack.modality === 'SEG') {
              // colors
              // labels
              // etc.
              stack.segmentationType = series.segmentationType;
              stack.segmentationSegments = series.segmentationSegments;
            }
            series.stack.push(stack);
            // recursive call for each frame
            // better than for loop to be able
            // to update dom with "progress" callback
            setTimeout(_this2.parseFrame(series, stack, response.url, 0, volumeParser, resolve, reject), 0);
          }));
        }, 10);
      });
    }

    /**
     * recursive parse frame
     * @param {ModelsSeries} series - data series
     * @param {ModelsStack} stack - data stack
     * @param {string} url - resource url
     * @param {number} i - frame index
     * @param {parser} dataParser - selected parser
     * @param {promise.resolve} resolve - promise resolve args
     * @param {promise.reject} reject - promise reject args
     */

  }, {
    key: 'parseFrame',
    value: function parseFrame(series, stack, url, i, dataParser, resolve, reject) {
      var frame = new _models6.default();
      frame.sopInstanceUID = dataParser.sopInstanceUID(i);
      frame.url = url;
      frame.index = i;
      frame.rows = dataParser.rows(i);
      frame.columns = dataParser.columns(i);
      frame.numberOfChannels = stack.numberOfChannels;
      frame.pixelRepresentation = stack.pixelRepresentation;
      frame.pixelType = stack.pixelType;
      frame.pixelData = dataParser.extractPixelData(i);
      frame.pixelSpacing = dataParser.pixelSpacing(i);
      frame.spacingBetweenSlices = dataParser.spacingBetweenSlices(i);
      frame.sliceThickness = dataParser.sliceThickness(i);
      frame.imageOrientation = dataParser.imageOrientation(i);
      frame.rightHanded = dataParser.rightHanded();
      stack.rightHanded = frame.rightHanded;
      if (frame.imageOrientation === null) {
        frame.imageOrientation = [1, 0, 0, 0, 1, 0];
      }
      frame.imagePosition = dataParser.imagePosition(i);
      if (frame.imagePosition === null) {
        frame.imagePosition = [0, 0, i];
      }
      frame.dimensionIndexValues = dataParser.dimensionIndexValues(i);
      frame.bitsAllocated = dataParser.bitsAllocated(i);
      frame.instanceNumber = dataParser.instanceNumber(i);
      frame.windowCenter = dataParser.windowCenter(i);
      frame.windowWidth = dataParser.windowWidth(i);
      frame.rescaleSlope = dataParser.rescaleSlope(i);
      frame.rescaleIntercept = dataParser.rescaleIntercept(i);
      // should pass frame index for consistency...
      frame.minMax = dataParser.minMaxPixelData(frame.pixelData);

      // if series.mo
      if (series.modality === 'SEG') {
        frame.referencedSegmentNumber = dataParser.referencedSegmentNumber(i);
      }

      stack.frame.push(frame);

      // update status
      this._parsed = i + 1;
      this._totalParsed = series.numberOfFrames;

      // will be removed after eventer set up
      if (this._progressBar) {
        this._progressBar.update(this._parsed, this._totalParsed, 'parse');
      }

      // emit 'parsing' event
      this.emit('parsing', {
        file: url,
        total: this._totalParsed,
        parsed: this._parsed,
        time: new Date()
      });

      if (this._parsed === this._totalParsed) {
        // emit 'parse-success' event
        this.emit('parse-success', {
          file: url,
          total: this._totalParsed,
          parsed: this._parsed,
          time: new Date()
        });

        resolve(series);
      } else {
        setTimeout(this.parseFrame(series, stack, url, this._parsed, dataParser, resolve, reject), 0);
      }
    }

    /**
     * Return parser given an extension
     * @param {string} extension - extension
     * @return {parser} selected parser
     */

  }, {
    key: '_parser',
    value: function _parser(extension) {
      var Parser = null;

      switch (extension.toUpperCase()) {
        case 'NII':
        case 'NII_':
          Parser = _parsers6.default;
          break;
        case 'DCM':
        case 'DICOM':
        case 'IMA':
        case '':
          Parser = _parsers2.default;
          break;
        case 'MHD':
          Parser = _parsers4.default;
          break;
        case 'NRRD':
          Parser = _parsers8.default;
          break;
        default:
          window.console.log('unsupported extension: ' + extension);
          return false;
      }
      return Parser;
    }

    /**
     * Pre-process data to be parsed (find data type and de-compress)
     * @param {*} data
     */

  }, {
    key: '_preprocess',
    value: function _preprocess(data) {
      var parsedUrl = _core2.default.parseUrl(data.url);
      // update data
      data.filename = parsedUrl.filename;
      data.extension = parsedUrl.extension;
      data.pathname = parsedUrl.pathname;
      data.query = parsedUrl.query;

      // unzip if extension is '.gz'
      if (data.extension === 'gz') {
        data.gzcompressed = true;
        data.extension = data.filename.split('.gz').shift().split('.').pop();
        var decompressedData = PAKO.inflate(data.buffer);
        data.buffer = decompressedData.buffer;
      } else {
        data.gzcompressed = false;
      }
    }

    /**
     * Filter data by extension
     * @param {*} extension
     * @param {*} item
     * @returns Boolean
     */

  }, {
    key: '_filterByExtension',
    value: function _filterByExtension(extension, item) {
      if (item.extension.toUpperCase() === extension.toUpperCase()) {
        return true;
      }
      return false;
    }
  }]);

  return LoadersVolumes;
}(_loaders2.default);

exports.default = LoadersVolumes;

},{"../core/core.utils":105,"../models/models.frame":131,"../models/models.series":133,"../models/models.stack":134,"../parsers/parsers.dicom":136,"../parsers/parsers.mhd":138,"../parsers/parsers.nifti":139,"../parsers/parsers.nrrd":140,"./loaders.base":127,"pako":51}],130:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Base object.
 *
 * @module models/base
 */

var ModelsBase = function () {
  function ModelsBase() {
    _classCallCheck(this, ModelsBase);

    this._id = -1;
  }
  /**
   * Merge 2 arrays of models.
   * Merge the target array into the reference array.
   *
   * @param {Array.<Models>} referenceArray - Array to be merge against
   * @param {Array.<Models>} targetArray - Array to be merged against reference.
   *
   * @return {boolean} True if merge was sucessful. False if something went wrong.
   */


  _createClass(ModelsBase, [{
    key: 'mergeModels',
    value: function mergeModels(referenceArray, targetArray) {
      if (!(this._validateModelArray(referenceArray) && this._validateModelArray(targetArray))) {
        window.console.log('invalid inputs provided.');
        return false;
      }

      for (var i = 0; i < targetArray.length; i++) {
        // test targetArray against existing targetArray
        for (var j = 0; j < referenceArray.length; j++) {
          if (referenceArray[j].merge(targetArray[i])) {
            // merged successfully
            break;
          } else if (j === referenceArray.length - 1) {
            // last merge was not successful
            // this is a new targetArray
            referenceArray.push(targetArray[i]);
          }
        }
      }

      return true;
    }

    /**
     * Merge model against current model.
     */

  }, {
    key: 'merge',
    value: function merge(model) {
      // make sure model is valid
      if (!this.validate(model)) {
        return false;
      }

      // they can be merged if they match
      if (this._id === model._id) {
        return true;
      }
      return false;
    }

    /**
     * Validate a model.
     *
     * @return {boolean} True if model is valid. False if not.
     */

  }, {
    key: 'validate',
    value: function validate(model) {
      if (!(model && model !== null && typeof model.merge === 'function')) {
        return false;
      }

      return true;
    }

    /**
     * Validate array of models.
     *
     * @param {Array.<Models>} modelArray - Array containing models.
     *
     * @return {boolean} True if array is valid. False if not.
     */

  }, {
    key: '_validateModelArray',
    value: function _validateModelArray(modelArray) {
      if (!(modelArray !== null && Array === modelArray.constructor)) {
        window.console.log('invalid model array provided.');
        return false;
      }

      for (var i = 0; i < modelArray.length; i++) {
        if (!(modelArray[i] && modelArray[i] !== null && typeof modelArray[i].validate === 'function' && modelArray[i].validate(modelArray[i]))) {
          return false;
        }
      }

      return true;
    }
  }]);

  return ModelsBase;
}();

exports.default = ModelsBase;

},{}],131:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * Frame object.
 *
 * @module models/frame
 */
var ModelsFrame = function (_ModelsBase) {
  _inherits(ModelsFrame, _ModelsBase);

  /**
   * Constructor
   */
  function ModelsFrame() {
    _classCallCheck(this, ModelsFrame);

    var _this = _possibleConstructorReturn(this, (ModelsFrame.__proto__ || Object.getPrototypeOf(ModelsFrame)).call(this));

    _this._sopInstanceUID = null;
    _this._url = null;
    _this._stackID = -1;
    _this._rows = 0;
    _this._columns = 0;
    _this._dimensionIndexValues = [];
    _this._imagePosition = null;
    _this._imageOrientation = null;
    _this._rightHanded = true;
    _this._sliceThickness = 1;
    _this._spacingBetweenSlices = null;
    _this._pixelRepresentation = 0;
    _this._pixelType = 0;
    _this._pixelSpacing = null;
    _this._pixelAspectRatio = null;
    _this._pixelData = null;

    _this._instanceNumber = null;
    _this._windowCenter = null;
    _this._windowWidth = null;
    _this._rescaleSlope = null;
    _this._rescaleIntercept = null;

    _this._bitsAllocated = 8;

    _this._minMax = null;
    _this._dist = null;

    _this._index = -1;

    _this._referencedSegmentNumber = -1;
    return _this;
  }

  /**
   * Validate the frame.
   *
   * @param {*} model
   *
   * @return {*}
   */


  _createClass(ModelsFrame, [{
    key: 'validate',
    value: function validate(model) {
      if (!(_get(ModelsFrame.prototype.__proto__ || Object.getPrototypeOf(ModelsFrame.prototype), 'validate', this).call(this, model) && typeof model.cosines === 'function' && typeof model.spacingXY === 'function' && model.hasOwnProperty('_sopInstanceUID') && model.hasOwnProperty('_dimensionIndexValues') && model.hasOwnProperty('_imageOrientation') && model.hasOwnProperty('_imagePosition'))) {
        return false;
      }

      return true;
    }

    /**
     * Merge current frame with provided frame.
     *
     * Frames can be merged (i.e. are identical) if following are equals:
     *  - dimensionIndexValues
     *  - imageOrientation
     *  - imagePosition
     *  - instanceNumber
     *  - sopInstanceUID
     *
     * @param {*} frame
     *
     * @return {boolean} True if frames could be merge. False if not.
     */

  }, {
    key: 'merge',
    value: function merge(frame) {
      if (!this.validate(frame)) {
        return false;
      }

      if (this._compareArrays(this._dimensionIndexValues, frame.dimensionIndexValues) && this._compareArrays(this._imageOrientation, frame.imageOrientation) && this._compareArrays(this._imagePosition, frame.imagePosition) && this._instanceNumber === frame.instanceNumber && this._sopInstanceUID === frame.sopInstanceUID) {
        return true;
      } else {
        return false;
      }
    }

    /**
     * Generate X, y and Z cosines from image orientation
     * Returns default orientation if _imageOrientation was invalid.
     *
     * @returns {array} Array[3] containing cosinesX, Y and Z.
     */

  }, {
    key: 'cosines',
    value: function cosines() {
      var cosines = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];

      if (this._imageOrientation && this._imageOrientation.length === 6) {
        var xCos = new THREE.Vector3(this._imageOrientation[0], this._imageOrientation[1], this._imageOrientation[2]);
        var yCos = new THREE.Vector3(this._imageOrientation[3], this._imageOrientation[4], this._imageOrientation[5]);

        if (xCos.length() > 0 && yCos.length() > 0) {
          cosines[0] = xCos;
          cosines[1] = yCos;
          cosines[2] = new THREE.Vector3(0, 0, 0).crossVectors(cosines[0], cosines[1]).normalize();
        }
      } else {
        window.console.log('No valid image orientation for frame');
        window.console.log(this);
        window.console.log('Returning default orientation.');
      }

      if (!this._rightHanded) {
        cosines[2].negate();
      }

      return cosines;
    }

    /**
     * Get x/y spacing of a frame.
     *
     * @return {*}
     */

  }, {
    key: 'spacingXY',
    value: function spacingXY() {
      var spacingXY = [1.0, 1.0];

      if (this.pixelSpacing) {
        spacingXY[0] = this.pixelSpacing[0];

        spacingXY[1] = this.pixelSpacing[1];
      } else if (this.pixelAspectRatio) {
        spacingXY[0] = 1.0;
        spacingXY[1] = 1.0 * this.pixelAspectRatio[1] / this.pixelAspectRatio[0];
      }

      return spacingXY;
    }

    /**
     * Get data value
     *
     * @param {*} column
     * @param {*} row
     *
     * @return {*}
     */

  }, {
    key: 'value',
    value: function value(column, row) {
      return this.pixelData[column + this._columns * row];
    }

    /**
     * Compare 2 arrays.
     *
     * 2 null arrays return true.
     * Do no perform strict type checking.
     *
     * @param {*} reference
     * @param {*} target
     *
     * @return {boolean} True if arrays are identicals. False if not.
     */

  }, {
    key: '_compareArrays',
    value: function _compareArrays(reference, target) {
      // could both be null
      if (reference === target) {
        return true;
      }

      // if not null....
      if (reference && target && reference.join() === target.join()) {
        return true;
      }

      return false;
    }
  }, {
    key: 'rows',
    get: function get() {
      return this._rows;
    },
    set: function set(rows) {
      this._rows = rows;
    }
  }, {
    key: 'columns',
    get: function get() {
      return this._columns;
    },
    set: function set(columns) {
      this._columns = columns;
    }
  }, {
    key: 'spacingBetweenSlices',
    get: function get() {
      return this._spacingBetweenSlices;
    },
    set: function set(spacingBetweenSlices) {
      this._spacingBetweenSlices = spacingBetweenSlices;
    }
  }, {
    key: 'sliceThickness',
    get: function get() {
      return this._sliceThickness;
    },
    set: function set(sliceThickness) {
      this._sliceThickness = sliceThickness;
    }
  }, {
    key: 'imagePosition',
    get: function get() {
      return this._imagePosition;
    },
    set: function set(imagePosition) {
      this._imagePosition = imagePosition;
    }
  }, {
    key: 'imageOrientation',
    get: function get() {
      return this._imageOrientation;
    },
    set: function set(imageOrientation) {
      this._imageOrientation = imageOrientation;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
    }
  }, {
    key: 'bitsAllocated',
    get: function get() {
      return this._bitsAllocated;
    },
    set: function set(bitsAllocated) {
      this._bitsAllocated = bitsAllocated;
    }
  }, {
    key: 'dist',
    get: function get() {
      return this._dist;
    },
    set: function set(dist) {
      this._dist = dist;
    }
  }, {
    key: 'pixelSpacing',
    get: function get() {
      return this._pixelSpacing;
    },
    set: function set(pixelSpacing) {
      this._pixelSpacing = pixelSpacing;
    }
  }, {
    key: 'pixelAspectRatio',
    get: function get() {
      return this._pixelAspectRatio;
    },
    set: function set(pixelAspectRatio) {
      this._pixelAspectRatio = pixelAspectRatio;
    }
  }, {
    key: 'minMax',
    get: function get() {
      return this._minMax;
    },
    set: function set(minMax) {
      this._minMax = minMax;
    }
  }, {
    key: 'dimensionIndexValues',
    get: function get() {
      return this._dimensionIndexValues;
    },
    set: function set(dimensionIndexValues) {
      this._dimensionIndexValues = dimensionIndexValues;
    }
  }, {
    key: 'instanceNumber',
    get: function get() {
      return this._instanceNumber;
    },
    set: function set(instanceNumber) {
      this._instanceNumber = instanceNumber;
    }
  }, {
    key: 'pixelData',
    get: function get() {
      return this._pixelData;
    },
    set: function set(pixelData) {
      this._pixelData = pixelData;
    }
  }, {
    key: 'sopInstanceUID',
    set: function set(sopInstanceUID) {
      this._sopInstanceUID = sopInstanceUID;
    },
    get: function get() {
      return this._sopInstanceUID;
    }
  }, {
    key: 'pixelRepresentation',
    get: function get() {
      return this._pixelRepresentation;
    },
    set: function set(pixelRepresentation) {
      this._pixelRepresentation = pixelRepresentation;
    }
  }, {
    key: 'pixelType',
    get: function get() {
      return this._pixelType;
    },
    set: function set(pixelType) {
      this._pixelType = pixelType;
    }
  }, {
    key: 'url',
    get: function get() {
      return this._url;
    },
    set: function set(url) {
      this._url = url;
    }
  }, {
    key: 'referencedSegmentNumber',
    get: function get() {
      return this._referencedSegmentNumber;
    },
    set: function set(referencedSegmentNumber) {
      this._referencedSegmentNumber = referencedSegmentNumber;
    }
  }, {
    key: 'rightHanded',
    get: function get() {
      return this._rightHanded;
    },
    set: function set(rightHanded) {
      this._rightHanded = rightHanded;
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
    }
  }]);

  return ModelsFrame;
}(_models2.default);

exports.default = ModelsFrame;

},{"../models/models.base":130}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _models = require('./models.frame');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('./models.stack');

var _models4 = _interopRequireDefault(_models3);

var _models5 = require('./models.series');

var _models6 = _interopRequireDefault(_models5);

var _models7 = require('./models.voxel');

var _models8 = _interopRequireDefault(_models7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module models
 */

exports.default = {
  Frame: _models2.default,
  Stack: _models4.default,
  Series: _models6.default,
  Voxel: _models8.default
};

},{"./models.frame":131,"./models.series":133,"./models.stack":134,"./models.voxel":135}],133:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * Series object.
 *
 * @module models/series
 */
var ModelsSeries = function (_ModelsBase) {
  _inherits(ModelsSeries, _ModelsBase);

  /**
   * Models series constructor
   */
  function ModelsSeries() {
    _classCallCheck(this, ModelsSeries);

    var _this = _possibleConstructorReturn(this, (ModelsSeries.__proto__ || Object.getPrototypeOf(ModelsSeries)).call(this));

    _this._concatenationUID = -1;
    _this._seriesInstanceUID = -1;
    _this._transferSyntaxUID = '';
    _this._seriesNumber = -1;
    _this._seriesDescription = '';
    _this._studyDescription = '';
    _this._modality = 'Modality not set';
    _this._dimensionIndexSequence = [];
    // it is used in the loader in case a dicom/nifti contains multiple frames
    // should be updated after merge or renamed
    _this._numberOfFrames = 0;
    _this._numberOfChannels = 1;

    // patient information
    _this._patientID = '';
    _this._patientName = '';
    _this._patientAge = '';
    _this._patientBirthdate = '';
    _this._patientSex = '';

    // SEGMENTATION STUFF
    _this._segmentationType = null;
    _this._segmentationSegments = [];

    // STACK
    _this._stack = [];
    return _this;
  }

  /**
   * Validate a series.
   *
   * Requirements:
   *   - mergeSeries method
   *   - _seriesInstanceUID
   *   - _numberOfFrames
   *   - _numberOfChannels
   *   _ _stack
   *
   * @param {ModelsSeries} model - Model to be validated as series.
   *
   * @return {boolean} True if series is valid. False if not.
   *
   * @override
   */


  _createClass(ModelsSeries, [{
    key: 'validate',
    value: function validate(model) {
      if (!(_get(ModelsSeries.prototype.__proto__ || Object.getPrototypeOf(ModelsSeries.prototype), 'validate', this).call(this, model) && typeof model.mergeSeries === 'function' && model.hasOwnProperty('_seriesInstanceUID') && model.hasOwnProperty('_numberOfFrames') && model.hasOwnProperty('_numberOfChannels') && model.hasOwnProperty('_stack') && typeof model._stack !== 'undefined' && Array === model._stack.constructor)) {
        return false;
      }

      return true;
    }

    /**
     * Merge current series with provided series.
     * 2 series can ONLY be merge if they have the same SeriesInstanceUID.
     *
     * Also merges the stacks inside a series.
     *
     * @param {ModelsSeries} series - Series to be merged against current series.
     *
     * @return {boolean} True if series could be merge. False if not.
     *
     * @override
     */

  }, {
    key: 'merge',
    value: function merge(series) {
      if (!this.validate(series)) {
        return false;
      }

      if (this._seriesInstanceUID === series.seriesInstanceUID) {
        return this.mergeModels(this._stack, series.stack);
      } else {
        return false;
      }
    }

    /**
     * Merge current series with provided array of series.
     * 2 series can ONLY be merge if they have the same SeriesInstanceUID.
     *
     * Also merges the stacks inside a series.
     *
     * @param {Array.<ModelsSeries>} target - Series to be merged against current series.
     *
     * @return {Array.<ModelsSeries>} Array of series properly merged.
     */

  }, {
    key: 'mergeSeries',
    value: function mergeSeries(target) {
      var seriesContainer = [this];
      this.mergeModels(seriesContainer, target);
      return seriesContainer;
    }

    /**
     * Series instance UID setter
     *
     * @param {*} seriesInstanceUID
     */

  }, {
    key: 'seriesInstanceUID',
    set: function set(seriesInstanceUID) {
      this._seriesInstanceUID = seriesInstanceUID;
    }

    /**
     * Series instace UID getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._seriesInstanceUID;
    }

    /**
     * Transfer syntax UID setter
     *
     * @param {*} transferSyntaxUID
     */

  }, {
    key: 'transferSyntaxUID',
    set: function set(transferSyntaxUID) {
      this._transferSyntaxUID = transferSyntaxUID;
    }

    /**
     * Transfer syntax UID getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._transferSyntaxUID;
    }

    /**
     * Transfer syntax UID getter
     *
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUIDLabel',
    get: function get() {
      switch (this._transferSyntaxUID) {
        case '1.2.840.10008.1.2.4.90':
          return 'JPEG 2000 Lossless';
        case '1.2.840.10008.1.2.4.91':
          return 'JPEG 2000 Lossy';
        case '1.2.840.10008.1.2.4.57':
          return 'JPEG Lossless, Nonhierarchical (Processes 14)';
        case '1.2.840.10008.1.2.4.70':
          return 'JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])';
        case '1.2.840.10008.1.2.4.50':
          return 'JPEG Baseline lossy process 1 (8 bit)';
        case '1.2.840.10008.1.2.4.51':
          return 'JPEG Baseline lossy process 2 & 4 (12 bit)';
        case '1.2.840.10008.1.2':
          return 'Implicit VR Little Endian';
        case '1.2.840.10008.1.2.1':
          return 'Explicit VR Little Endian';
        case '1.2.840.10008.1.2.2':
          return 'Explicit VR Big Endian';
        default:
          return 'Unknown transfersyntax: ' + this._transferSyntaxUID;
      }
    }

    /**
     * Study descripition setter
     *
     * @param {*} studyDescription
     */

  }, {
    key: 'studyDescription',
    set: function set(studyDescription) {
      this._studyDescription = studyDescription;
    }

    /**
     * Study description getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._studyDescription;
    }

    /**
     * Series descripition setter
     *
     * @param {*} seriesDescription
     */

  }, {
    key: 'seriesDescription',
    set: function set(seriesDescription) {
      this._seriesDescription = seriesDescription;
    }

    /**
     * Series description getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._seriesDescription;
    }

    /**
     * Patient ID setter
     *
     * @param {*} patientID
     */

  }, {
    key: 'patientID',
    set: function set(patientID) {
      this._patientID = patientID;
    }

    /**
     * Patient ID getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientID;
    }

    /**
     * Patient name setter
     *
     * @param {*} patientName
     */

  }, {
    key: 'patientName',
    set: function set(patientName) {
      this._patientName = patientName;
    }

    /**
     * Patient name getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientName;
    }

    /**
     * Patient age setter
     *
     * @param {*} patientAge
     */

  }, {
    key: 'patientAge',
    set: function set(patientAge) {
      this._patientAge = patientAge;
    }

    /**
     * Patient age getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientAge;
    }

    /**
     * Patient birthdate setter
     *
     * @param {*} patientBirthdate
     */

  }, {
    key: 'patientBirthdate',
    set: function set(patientBirthdate) {
      this._patientBirthdate = patientBirthdate;
    }

    /**
     * Patient birthdate getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientBirthdate;
    }

    /**
     * Patient sex setter
     *
     * @param {*} patientSex
     */

  }, {
    key: 'patientSex',
    set: function set(patientSex) {
      this._patientSex = patientSex;
    }

    /**
     * Patient sex getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientSex;
    }

    /**
     * Number of frames setter
     *
     * @param {*} numberOfFrames
     */

  }, {
    key: 'numberOfFrames',
    set: function set(numberOfFrames) {
      this._numberOfFrames = numberOfFrames;
    }

    /**
     * Number of frames getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._numberOfFrames;
    }

    /**
     * Number of channels setter
     *
     * @param {*} numberOfChannels
     */

  }, {
    key: 'numberOfChannels',
    set: function set(numberOfChannels) {
      this._numberOfChannels = numberOfChannels;
    }

    /**
     * Number of channels getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._numberOfChannels;
    }
  }, {
    key: 'stack',
    set: function set(stack) {
      this._stack = stack;
    },
    get: function get() {
      return this._stack;
    }
  }, {
    key: 'modality',
    set: function set(modality) {
      this._modality = modality;
    },
    get: function get() {
      return this._modality;
    }
  }, {
    key: 'segmentationType',
    set: function set(segmentationType) {
      this._segmentationType = segmentationType;
    },
    get: function get() {
      return this._segmentationType;
    }
  }, {
    key: 'segmentationSegments',
    set: function set(segmentationSegments) {
      this._segmentationSegments = segmentationSegments;
    },
    get: function get() {
      return this._segmentationSegments;
    }
  }]);

  return ModelsSeries;
}(_models2.default);

exports.default = ModelsSeries;

},{"../models/models.base":130}],134:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core/core.colors');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('../core/core.utils');

var _core4 = _interopRequireDefault(_core3);

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


var binaryString = require('math-float32-to-binary-string');

/**
 * Stack object.
 *
 * @module models/stack
 */

var ModelsStack = function (_ModelsBase) {
  _inherits(ModelsStack, _ModelsBase);

  /**
   * Models Stack constructor
   */
  function ModelsStack() {
    _classCallCheck(this, ModelsStack);

    var _this = _possibleConstructorReturn(this, (ModelsStack.__proto__ || Object.getPrototypeOf(ModelsStack)).call(this));

    _this._uid = null;
    _this._stackID = -1;

    _this._frame = [];
    _this._numberOfFrames = 0;

    _this._rows = 0;
    _this._columns = 0;
    _this._numberOfChannels = 1;
    _this._bitsAllocated = 8;
    _this._pixelType = 0;
    _this._pixelRepresentation = 0;

    _this._textureSize = 4096;
    _this._nbTextures = 7;
    _this._rawData = [];

    _this._windowCenter = 0;
    _this._windowWidth = 0;

    _this._rescaleSlope = 1;
    _this._rescaleIntercept = 0;

    _this._minMax = [65535, -32768];

    // TRANSFORMATION MATRICES
    _this._regMatrix = new THREE.Matrix4();

    _this._ijk2LPS = null;
    _this._lps2IJK = null;

    _this._aabb2LPS = null;
    _this._lps2AABB = null;

    //
    // IJK dimensions
    _this._dimensionsIJK = null;
    _this._halfDimensionsIJK = null;
    _this._spacing = new THREE.Vector3(1, 1, 1);
    _this._spacingBetweenSlices = 0;
    _this._sliceThickness = 0;
    _this._origin = null;
    _this._rightHanded = true;
    _this._xCosine = new THREE.Vector3(1, 0, 0);
    _this._yCosine = new THREE.Vector3(0, 1, 0);
    _this._zCosine = new THREE.Vector3(0, 0, 1);

    // convenience vars
    _this._prepared = false;
    _this._packed = false;
    _this._packedPerPixel = 1;

    //
    _this._modality = 'Modality not set';

    // SEGMENTATION STUFF
    _this._segmentationType = null;
    _this._segmentationSegments = [];
    _this._segmentationDefaultColor = [63, 174, 128];
    _this._frameSegment = [];
    _this._segmentationLUT = [];
    _this._segmentationLUTO = [];

    // photometricInterpretation Monochrome1 VS Monochrome2
    _this._invert = false;
    return _this;
  }

  /**
   * Prepare segmentation stack.
   * A segmentation stack can hold x frames that are at the same location
   * but segmentation specific information:
   * - Frame X contains voxels for segmentation A.
   * - Frame Y contains voxels for segmenttation B.
   * - Frame X and Y are at the same location.
   *
   * We currently merge overlaping frames into 1.
   */


  _createClass(ModelsStack, [{
    key: 'prepareSegmentation',
    value: function prepareSegmentation() {
      // store frame and do special pre-processing
      this._frameSegment = this._frame;
      var mergedFrames = [];

      // order frames
      this.computeCosines();
      this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
      this._frame.sort(this._sortDistanceArraySort);

      // merge frames
      var prevIndex = -1;
      for (var i = 0; i < this._frame.length; i++) {
        if (!mergedFrames[prevIndex] || mergedFrames[prevIndex]._dist != this._frame[i]._dist) {
          mergedFrames.push(this._frame[i]);
          prevIndex++;

          // Scale frame
          // by default each frame contains binary data about a segmentation.
          // we scale it by the referenceSegmentNumber in order to have a
          // segmentation specific voxel value rather than 0 or 1.
          // That allows us to merge frames later on.
          // If we merge frames without scaling, then we can not differenciate
          // voxels from segmentation A or B as the value is 0 or 1 in both cases.
          for (var k = 0; k < mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; k++) {
            mergedFrames[prevIndex]._pixelData[k] *= this._frame[i]._referencedSegmentNumber;
          }
        } else {
          // frame already exsits at this location.
          // merge data from this segmentation into existing frame
          for (var _k = 0; _k < mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; _k++) {
            mergedFrames[prevIndex]._pixelData[_k] += this._frame[i].pixelData[_k] * this._frame[i]._referencedSegmentNumber;
          }
        }

        mergedFrames[prevIndex].minMax = _core4.default.minMax(mergedFrames[prevIndex]._pixelData);
      }

      // get information about segments
      var dict = {};
      var max = 0;
      for (var _i = 0; _i < this._segmentationSegments.length; _i++) {
        max = Math.max(max, parseInt(this._segmentationSegments[_i].segmentNumber, 10));

        var color = this._segmentationSegments[_i].recommendedDisplayCIELab;
        if (color === null) {
          dict[this._segmentationSegments[_i].segmentNumber] = this._segmentationDefaultColor;
        } else {
          dict[this._segmentationSegments[_i].segmentNumber] = _core2.default.cielab2RGB.apply(_core2.default, _toConsumableArray(color));
        }
      }

      // generate LUTs
      for (var _i2 = 0; _i2 <= max; _i2++) {
        var index = _i2 / max;
        var opacity = _i2 ? 1 : 0;
        var rgb = [0, 0, 0];
        if (dict.hasOwnProperty(_i2.toString())) {
          rgb = dict[_i2.toString()];
        }

        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;

        this._segmentationLUT.push([index].concat(_toConsumableArray(rgb)));
        this._segmentationLUTO.push([index, opacity]);
      }

      this._frame = mergedFrames;
    }

    /**
     * Compute cosines
     * Order frames
     * computeSpacing
     * sanityCheck
     * init some vars
     * compute min/max
     * compute transformation matrices
     *
     * @return {*}
     */

  }, {
    key: 'prepare',
    value: function prepare() {
      // if segmentation, merge some frames...
      if (this._modality === 'SEG') {
        this.prepareSegmentation();
      }

      // we need at least 1 frame
      if (this._frame && this._frame.length > 0) {
        this._numberOfFrames = this._frame.length;
      } else {
        window.console.log('_frame doesn\'t contain anything....');
        window.console.log(this._frame);
        return false;
      }

      // pass parameters from frame to stack
      this._rows = this._frame[0].rows;
      this._columns = this._frame[0].columns;
      this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
      this._halfDimensionsIJK = new THREE.Vector3(this._dimensionsIJK.x / 2, this._dimensionsIJK.y / 2, this._dimensionsIJK.z / 2);
      this._spacingBetweenSlices = this._frame[0].spacingBetweenSlices;
      this._sliceThickness = this._frame[0].sliceThickness;

      // compute direction cosines
      this.computeCosines();

      // order the frames
      this.orderFrames();

      // compute/guess spacing
      this.computeSpacing();
      // set extra vars if nulls
      // do it now because before we would think image position/orientation
      // are defined and we would use it to compute spacing.
      if (!this._frame[0].imagePosition) {
        this._frame[0].imagePosition = [0, 0, 0];
      }
      if (!this._frame[0].imageOrientation) {
        this._frame[0].imageOrientation = [1, 0, 0, 0, 1, 0];
      }

      this._origin = this._arrayToVector3(this._frame[0].imagePosition, 0);

      // compute transforms
      this.computeIJK2LPS();

      this.computeLPS2AABB();
      // this.packEchos();

      this._rescaleSlope = this._frame[0].rescaleSlope || 1;
      this._rescaleIntercept = this._frame[0].rescaleIntercept || 0;

      // rescale/slope min max
      this.computeMinMaxIntensities();
      this._minMax[0] = ModelsStack.valueRescaleSlopeIntercept(this._minMax[0], this._rescaleSlope, this._rescaleIntercept);
      this._minMax[1] = ModelsStack.valueRescaleSlopeIntercept(this._minMax[1], this._rescaleSlope, this._rescaleIntercept);

      var width = this._frame[0].windowWidth || this._minMax[1] - this._minMax[0];
      this._windowWidth = this._rescaleSlope * width + this._rescaleIntercept;

      var center = this._frame[0].windowCenter || this._minMax[0] + width / 2;
      this._windowCenter = this._rescaleSlope * center + this._rescaleIntercept;

      this._bitsAllocated = this._frame[0].bitsAllocated;
      this._prepared = true;
    }
  }, {
    key: 'packEchos',
    value: function packEchos() {
      // 4 echo times...
      var echos = 4;
      var packedEcho = [];
      for (var i = 0; i < this._frame.length; i += echos) {
        var frame = this._frame[i];
        for (var k = 0; k < this._rows * this._columns; k++) {
          for (var j = 1; j < echos; j++) {
            frame.pixelData[k] += this._frame[i + j].pixelData[k];
          }
          frame.pixelData[k] /= echos;
        }
        packedEcho.push(frame);
      }
      this._frame = packedEcho;
      this._numberOfFrames = this._frame.length;
      this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
      this._halfDimensionsIJK = new THREE.Vector3(this._dimensionsIJK.x / 2, this._dimensionsIJK.y / 2, this._dimensionsIJK.z / 2);
    }

    // frame.cosines - returns array [x, y, z]

  }, {
    key: 'computeCosines',
    value: function computeCosines() {
      if (this._frame && this._frame[0]) {
        var cosines = this._frame[0].cosines();
        this._xCosine = cosines[0];
        this._yCosine = cosines[1];
        this._zCosine = cosines[2];
      }
    }
  }, {
    key: 'orderFrames',
    value: function orderFrames() {
      // order the frames based on theirs dimension indices
      // first index is the most important.
      // 1,1,1,1 willl be first
      // 1,1,2,1 will be next
      // 1,1,2,3 will be next
      // 1,1,3,1 wil be next
      if (this._frame[0].dimensionIndexValues) {
        this._frame.sort(this._orderFrameOnDimensionIndicesArraySort);

        // else order with image position and orientation
      } else if (this._frame[0].imagePosition && this._frame[0].imageOrientation && this._frame[1] && this._frame[1].imagePosition && this._frame[1].imageOrientation && this._frame[0].imagePosition.join() !== this._frame[1].imagePosition.join()) {
        // compute and sort by dist in this series
        this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
        this._frame.sort(this._sortDistanceArraySort);
      } else if (this._frame[0].instanceNumber !== null && this._frame[1] && this._frame[1].instanceNumber !== null && this._frame[0].instanceNumber !== this._frame[1].instanceNumber) {
        this._frame.sort(this._sortInstanceNumberArraySort);
      } else if (this._frame[0].sopInstanceUID && this._frame[1] && this._frame[1].sopInstanceUID && this._frame[0].sopInstanceUID !== this._frame[1].sopInstanceUID) {
        this._frame.sort(this._sortSopInstanceUIDArraySort);
      } else {
        // window.console.log(this._frame[0]);
        // window.console.log(this._frame[1]);
        // window.console.log(this._frame[0].instanceNumber !== null && true);
        // window.console.log(
        // this._frame[0].instanceNumber !== this._frame[1].instanceNumber);
        window.console.log('do not know how to order the frames...');
        // else slice location
        // image number
        // ORDERING BASED ON instance number
        // _ordering = 'instance_number';
        // first_image.sort(function(a,b){
        // return a["instance_number"]-b["instance_number"]});
      }
    }
  }, {
    key: 'computeSpacing',
    value: function computeSpacing() {
      this.xySpacing();
      this.zSpacing();
    }

    /**
     * Compute stack z spacing
     */

  }, {
    key: 'zSpacing',
    value: function zSpacing() {
      if (this._numberOfFrames > 1) {
        if (this._frame[0].pixelSpacing && this._frame[0].pixelSpacing[2]) {
          this._spacing.z = this._frame[0].pixelSpacing[2];
        } else {
          // compute and sort by dist in this series
          this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));

          // if distances are different, re-sort array
          if (this._frame[1].dist !== this._frame[0].dist) {
            this._frame.sort(this._sortDistanceArraySort);
            this._spacing.z = this._frame[1].dist - this._frame[0].dist;
          } else if (this._spacingBetweenSlices) {
            this._spacing.z = this._spacingBetweenSlices;
          } else if (this._frame[0].sliceThickness) {
            this._spacing.z = this._frame[0].sliceThickness;
          }
        }
      }

      // Spacing
      // can not be 0 if not matrix can not be inverted.
      if (this._spacing.z === 0) {
        this._spacing.z = 1;
      }
    }

    /**
     *  FRAME CAN DO IT
     */

  }, {
    key: 'xySpacing',
    value: function xySpacing() {
      if (this._frame && this._frame[0]) {
        var spacingXY = this._frame[0].spacingXY();
        this._spacing.x = spacingXY[0];
        this._spacing.y = spacingXY[1];
      }
    }

    /**
     * Find min and max intensities among all frames.
     */

  }, {
    key: 'computeMinMaxIntensities',
    value: function computeMinMaxIntensities() {
      // what about colors!!!!?
      for (var i = 0; i < this._frame.length; i++) {
        // get min/max
        this._minMax[0] = Math.min(this._minMax[0], this._frame[i].minMax[0]);
        this._minMax[1] = Math.max(this._minMax[1], this._frame[i].minMax[1]);
      }
    }

    /**
     * Compute IJK to LPS and invert transforms
     */

  }, {
    key: 'computeIJK2LPS',
    value: function computeIJK2LPS() {
      // ijk to lps
      this._ijk2LPS = _core4.default.ijk2LPS(this._xCosine, this._yCosine, this._zCosine, this._spacing, this._origin, this._regMatrix);

      // lps 2 ijk
      this._lps2IJK = new THREE.Matrix4();
      this._lps2IJK.getInverse(this._ijk2LPS);
    }

    /**
     * Compute LPS to AABB and invert transforms
     */

  }, {
    key: 'computeLPS2AABB',
    value: function computeLPS2AABB() {
      this._aabb2LPS = _core4.default.aabb2LPS(this._xCosine, this._yCosine, this._zCosine, this._origin);

      this._lps2AABB = new THREE.Matrix4();
      this._lps2AABB.getInverse(this._aabb2LPS);
    }

    /**
     * Merge stacks
     *
     * @param {*} stack
     *
     * @return {*}
     */

  }, {
    key: 'merge',
    value: function merge(stack) {
      // also make sure x/y/z cosines are a match!
      if (this._stackID === stack.stackID) {
        return this.mergeModels(this._frame, stack.frame);
      } else {
        return false;
      }
    }

    /**
     * Pack current stack pixel data into 8 bits array buffers
     */

  }, {
    key: 'pack',
    value: function pack() {
      // Get total number of voxels
      var nbVoxels = this._dimensionsIJK.x * this._dimensionsIJK.y * this._dimensionsIJK.z;

      // Packing style
      if (this._bitsAllocated === 16 && this._numberOfChannels === 1) {
        this._packedPerPixel = 2;
      }

      // Loop through all the textures we need
      var textureDimension = this._textureSize * this._textureSize;
      var requiredTextures = Math.ceil(nbVoxels / (textureDimension * this._packedPerPixel));
      var voxelIndexStart = 0;
      var voxelIndexStop = this._packedPerPixel * textureDimension;
      if (voxelIndexStop > nbVoxels) {
        voxelIndexStop = nbVoxels;
      }

      for (var ii = 0; ii < requiredTextures; ii++) {
        var packed = this._packTo8Bits(this._numberOfChannels, this._frame, this._textureSize, voxelIndexStart, voxelIndexStop);
        this._textureType = packed.textureType;
        this._rawData.push(packed.data);

        voxelIndexStart += this._packedPerPixel * textureDimension;
        voxelIndexStop += this._packedPerPixel * textureDimension;
        if (voxelIndexStop > nbVoxels) {
          voxelIndexStop = nbVoxels;
        }
      }

      this._packed = true;
    }

    /**
     * Pack frame data to 32 bits texture
     * @param {*} channels
     * @param {*} frame
     * @param {*} textureSize
     * @param {*} startVoxel
     * @param {*} stopVoxel
     */

  }, {
    key: '_packTo8Bits',
    value: function _packTo8Bits(channels, frame, textureSize, startVoxel, stopVoxel) {
      var packed = {
        textureType: null,
        data: null
      };

      var bitsAllocated = frame[0].bitsAllocated;
      var pixelType = frame[0].pixelType;

      // transform signed to unsigned for convenience
      var offset = 0;
      if (this._minMax[0] < 0) {
        offset -= this._minMax[0];
      }

      var packIndex = 0;
      var frameIndex = 0;
      var inFrameIndex = 0;
      // frame should return it!
      var frameDimension = frame[0].rows * frame[0].columns;

      if (bitsAllocated === 8 && channels === 1 || bitsAllocated === 1) {
        var data = new Uint8Array(textureSize * textureSize * 1);
        for (var i = startVoxel; i < stopVoxel; i++) {
          frameIndex = ~~(i / frameDimension);
          inFrameIndex = i % frameDimension;

          data[packIndex] = offset + frame[frameIndex].pixelData[inFrameIndex];
          packIndex++;
        }
        packed.textureType = THREE.LuminanceFormat;
        packed.data = data;
      } else if (bitsAllocated === 16 && channels === 1) {
        var _data = new Uint8Array(textureSize * textureSize * 4);
        var coordinate = 0;
        var channelOffset = 0;

        for (var _i3 = startVoxel; _i3 < stopVoxel; _i3++) {
          frameIndex = ~~(_i3 / frameDimension);
          inFrameIndex = _i3 % frameDimension;

          var raw = offset + frame[frameIndex].pixelData[inFrameIndex];
          _data[4 * coordinate + 2 * channelOffset] = raw & 0x00FF;
          _data[4 * coordinate + 2 * channelOffset + 1] = raw >>> 8 & 0x00FF;

          packIndex++;
          coordinate = Math.floor(packIndex / 2);
          channelOffset = packIndex % 2;
        }

        packed.textureType = THREE.RGBAFormat;
        packed.data = _data;
      } else if (bitsAllocated === 32 && channels === 1 && pixelType === 0) {
        var _data2 = new Uint8Array(textureSize * textureSize * 4);
        for (var _i4 = startVoxel; _i4 < stopVoxel; _i4++) {
          frameIndex = ~~(_i4 / frameDimension);
          inFrameIndex = _i4 % frameDimension;

          var _raw = offset + frame[frameIndex].pixelData[inFrameIndex];
          _data2[4 * packIndex] = _raw & 0x000000FF;
          _data2[4 * packIndex + 1] = _raw >>> 8 & 0x000000FF;
          _data2[4 * packIndex + 2] = _raw >>> 16 & 0x000000FF;
          _data2[4 * packIndex + 3] = _raw >>> 24 & 0x000000FF;

          packIndex++;
        }
        packed.textureType = THREE.RGBAFormat;
        packed.data = _data2;
      } else if (bitsAllocated === 32 && channels === 1 && pixelType === 1) {
        var _data3 = new Uint8Array(textureSize * textureSize * 4);

        for (var _i5 = startVoxel; _i5 < stopVoxel; _i5++) {
          frameIndex = ~~(_i5 / frameDimension);
          inFrameIndex = _i5 % frameDimension;

          var _raw2 = offset + frame[frameIndex].pixelData[inFrameIndex];
          var bitString = binaryString(_raw2);
          var bitStringArray = bitString.match(/.{1,8}/g);

          _data3[4 * packIndex] = parseInt(bitStringArray[0], 2);
          _data3[4 * packIndex + 1] = parseInt(bitStringArray[1], 2);
          _data3[4 * packIndex + 2] = parseInt(bitStringArray[2], 2);
          _data3[4 * packIndex + 3] = parseInt(bitStringArray[3], 2);

          packIndex++;
        }

        packed.textureType = THREE.RGBAFormat;
        packed.data = _data3;
      } else if (bitsAllocated === 8 && channels === 3) {
        var _data4 = new Uint8Array(textureSize * textureSize * 3);

        for (var _i6 = startVoxel; _i6 < stopVoxel; _i6++) {
          frameIndex = ~~(_i6 / frameDimension);
          inFrameIndex = _i6 % frameDimension;

          _data4[3 * packIndex] = frame[frameIndex].pixelData[3 * inFrameIndex];
          _data4[3 * packIndex + 1] = frame[frameIndex].pixelData[3 * inFrameIndex + 1];
          _data4[3 * packIndex + 2] = frame[frameIndex].pixelData[3 * inFrameIndex + 2];
          packIndex++;
        }

        packed.textureType = THREE.RGBFormat;
        packed.data = _data4;
      }

      return packed;
    }

    /**
     * Get the stack world center
     *
     *@return {*}
     */

  }, {
    key: 'worldCenter',
    value: function worldCenter() {
      var center = this._halfDimensionsIJK.clone().addScalar(-0.5).applyMatrix4(this._ijk2LPS);
      return center;
    }

    /**
     * Get the stack world bounding box
     * @return {*}
     */

  }, {
    key: 'worldBoundingBox',
    value: function worldBoundingBox() {
      var bbox = [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE];

      var dims = this._dimensionsIJK;

      for (var i = 0; i <= dims.x; i += dims.x) {
        for (var j = 0; j <= dims.y; j += dims.y) {
          for (var k = 0; k <= dims.z; k += dims.z) {
            var world = new THREE.Vector3(i, j, k).applyMatrix4(this._ijk2LPS);
            bbox = [Math.min(bbox[0], world.x), Math.max(bbox[1], world.x), // x min/max
            Math.min(bbox[2], world.y), Math.max(bbox[3], world.y), Math.min(bbox[4], world.z), Math.max(bbox[5], world.z)];
          }
        }
      }

      return bbox;
    }

    /**
     * Get AABB size in LPS space.
     *
     * @return {*}
     */

  }, {
    key: 'AABBox',
    value: function AABBox() {
      var world0 = new THREE.Vector3().addScalar(-0.5).applyMatrix4(this._ijk2LPS).applyMatrix4(this._lps2AABB);

      var world7 = this._dimensionsIJK.clone().addScalar(-0.5).applyMatrix4(this._ijk2LPS).applyMatrix4(this._lps2AABB);

      var minBBox = new THREE.Vector3(Math.abs(world0.x - world7.x), Math.abs(world0.y - world7.y), Math.abs(world0.z - world7.z));

      return minBBox;
    }

    /**
     * Get AABB center in LPS space
     */

  }, {
    key: 'centerAABBox',
    value: function centerAABBox() {
      var centerBBox = this.worldCenter();
      centerBBox.applyMatrix4(this._lps2AABB);
      return centerBBox;
    }
  }, {
    key: '_arrayToVector3',
    value: function _arrayToVector3(array, index) {
      return new THREE.Vector3(array[index], array[index + 1], array[index + 2]);
    }
  }, {
    key: '_orderFrameOnDimensionIndicesArraySort',
    value: function _orderFrameOnDimensionIndicesArraySort(a, b) {
      if ('dimensionIndexValues' in a && Object.prototype.toString.call(a.dimensionIndexValues) === '[object Array]' && 'dimensionIndexValues' in b && Object.prototype.toString.call(b.dimensionIndexValues) === '[object Array]') {
        for (var i = 0; i < a.dimensionIndexValues.length; i++) {
          if (parseInt(a.dimensionIndexValues[i], 10) > parseInt(b.dimensionIndexValues[i], 10)) {
            return 1;
          }
          if (parseInt(a.dimensionIndexValues[i], 10) < parseInt(b.dimensionIndexValues[i], 10)) {
            return -1;
          }
        }
      } else {
        window.console.log('One of the frames doesn\'t have a dimensionIndexValues array.');
        window.console.log(a);
        window.console.log(b);
      }

      return 0;
    }
  }, {
    key: '_computeDistanceArrayMap',
    value: function _computeDistanceArrayMap(normal, frame) {
      frame.dist = frame.imagePosition[0] * normal.x + frame.imagePosition[1] * normal.y + frame.imagePosition[2] * normal.z;
      return frame;
    }
  }, {
    key: '_sortDistanceArraySort',
    value: function _sortDistanceArraySort(a, b) {
      return a.dist - b.dist;
    }
  }, {
    key: '_sortInstanceNumberArraySort',
    value: function _sortInstanceNumberArraySort(a, b) {
      return a.instanceNumber - b.instanceNumber;
    }
  }, {
    key: '_sortSopInstanceUIDArraySort',
    value: function _sortSopInstanceUIDArraySort(a, b) {
      return a.sopInstanceUID - b.sopInstanceUID;
    }
  }, {
    key: 'numberOfChannels',
    set: function set(numberOfChannels) {
      this._numberOfChannels = numberOfChannels;
    },
    get: function get() {
      return this._numberOfChannels;
    }
  }, {
    key: 'frame',
    set: function set(frame) {
      this._frame = frame;
    },
    get: function get() {
      return this._frame;
    }
  }, {
    key: 'prepared',
    set: function set(prepared) {
      this._prepared = prepared;
    },
    get: function get() {
      return this._prepared;
    }
  }, {
    key: 'packed',
    set: function set(packed) {
      this._packed = packed;
    },
    get: function get() {
      return this._packed;
    }
  }, {
    key: 'packedPerPixel',
    set: function set(packedPerPixel) {
      this._packedPerPixel = packedPerPixel;
    },
    get: function get() {
      return this._packedPerPixel;
    }
  }, {
    key: 'dimensionsIJK',
    set: function set(dimensionsIJK) {
      this._dimensionsIJK = dimensionsIJK;
    },
    get: function get() {
      return this._dimensionsIJK;
    }
  }, {
    key: 'halfDimensionsIJK',
    set: function set(halfDimensionsIJK) {
      this._halfDimensionsIJK = halfDimensionsIJK;
    },
    get: function get() {
      return this._halfDimensionsIJK;
    }
  }, {
    key: 'regMatrix',
    set: function set(regMatrix) {
      this._regMatrix = regMatrix;
    },
    get: function get() {
      return this._regMatrix;
    }
  }, {
    key: 'ijk2LPS',
    set: function set(ijk2LPS) {
      this._ijk2LPS = ijk2LPS;
    },
    get: function get() {
      return this._ijk2LPS;
    }
  }, {
    key: 'lps2IJK',
    set: function set(lps2IJK) {
      this._lps2IJK = lps2IJK;
    },
    get: function get() {
      return this._lps2IJK;
    }
  }, {
    key: 'lps2AABB',
    set: function set(lps2AABB) {
      this._lps2AABB = lps2AABB;
    },
    get: function get() {
      return this._lps2AABB;
    }
  }, {
    key: 'textureSize',
    set: function set(textureSize) {
      this._textureSize = textureSize;
    },
    get: function get() {
      return this._textureSize;
    }
  }, {
    key: 'textureType',
    set: function set(textureType) {
      this._textureType = textureType;
    },
    get: function get() {
      return this._textureType;
    }
  }, {
    key: 'bitsAllocated',
    set: function set(bitsAllocated) {
      this._bitsAllocated = bitsAllocated;
    },
    get: function get() {
      return this._bitsAllocated;
    }
  }, {
    key: 'rawData',
    set: function set(rawData) {
      this._rawData = rawData;
    },
    get: function get() {
      return this._rawData;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
    }
  }, {
    key: 'xCosine',
    get: function get() {
      return this._xCosine;
    },
    set: function set(xCosine) {
      this._xCosine = xCosine;
    }
  }, {
    key: 'yCosine',
    get: function get() {
      return this._yCosine;
    },
    set: function set(yCosine) {
      this._yCosine = yCosine;
    }
  }, {
    key: 'zCosine',
    get: function get() {
      return this._zCosine;
    },
    set: function set(zCosine) {
      this._zCosine = zCosine;
    }
  }, {
    key: 'minMax',
    get: function get() {
      return this._minMax;
    },
    set: function set(minMax) {
      this._minMax = minMax;
    }
  }, {
    key: 'stackID',
    get: function get() {
      return this._stackID;
    },
    set: function set(stackID) {
      this._stackID = stackID;
    }
  }, {
    key: 'pixelType',
    get: function get() {
      return this._pixelType;
    },
    set: function set(pixelType) {
      this._pixelType = pixelType;
    }
  }, {
    key: 'pixelRepresentation',
    get: function get() {
      return this._pixelRepresentation;
    },
    set: function set(pixelRepresentation) {
      this._pixelRepresentation = pixelRepresentation;
    }
  }, {
    key: 'invert',
    set: function set(invert) {
      this._invert = invert;
    },
    get: function get() {
      return this._invert;
    }
  }, {
    key: 'modality',
    set: function set(modality) {
      this._modality = modality;
    },
    get: function get() {
      return this._modality;
    }
  }, {
    key: 'rightHanded',
    get: function get() {
      return this._rightHanded;
    },
    set: function set(rightHanded) {
      this._rightHanded = rightHanded;
    }
  }, {
    key: 'spacingBetweenSlices',
    get: function get() {
      return this._spacingBetweenSlices;
    },
    set: function set(spacingBetweenSlices) {
      this._spacingBetweenSlices = spacingBetweenSlices;
    }
  }, {
    key: 'segmentationSegments',
    set: function set(segmentationSegments) {
      this._segmentationSegments = segmentationSegments;
    },
    get: function get() {
      return this._segmentationSegments;
    }
  }, {
    key: 'segmentationType',
    set: function set(segmentationType) {
      this._segmentationType = segmentationType;
    },
    get: function get() {
      return this._segmentationType;
    }
  }, {
    key: 'segmentationLUT',
    set: function set(segmentationLUT) {
      this._segmentationLUT = segmentationLUT;
    },
    get: function get() {
      return this._segmentationLUT;
    }
  }, {
    key: 'segmentationLUTO',
    set: function set(segmentationLUTO) {
      this._segmentationLUTO = segmentationLUTO;
    },
    get: function get() {
      return this._segmentationLUTO;
    }

    // DEPRECATED FUNCTION

    /**
     * @deprecated for core.utils.value
     *
     * Get voxel value.
     *
     * @param {*} stack
     * @param {*} coordinate
     *
     * @return {*}
     */

  }], [{
    key: 'indexInDimensions',
    value: function indexInDimensions(index, dimensions) {
      if (index.x >= 0 && index.y >= 0 && index.z >= 0 && index.x < dimensions.x && index.y < dimensions.y && index.z < dimensions.z) {
        return true;
      }

      return false;
    }
  }, {
    key: 'value',
    value: function value(stack, coordinate) {
      console.warn('models.stack.value is deprecated.\n       Please use core.utils.value instead.');
      return _core4.default.value(stack, coordinate);
    }

    /**
     * @deprecated for core.utils.rescaleSlopeIntercept
     *
     * Apply slope/intercept to a value.
     *
     * @param {*} value
     * @param {*} slope
     * @param {*} intercept
     *
     * @return {*}
     */

  }, {
    key: 'valueRescaleSlopeIntercept',
    value: function valueRescaleSlopeIntercept(value, slope, intercept) {
      console.warn('models.stack.valueRescaleSlopeIntercept is deprecated.\n       Please use core.utils.rescaleSlopeIntercept instead.');
      return _core4.default.rescaleSlopeIntercept(value, slope, intercept);
    }

    /**
     * @deprecated for core.utils.worldToData
     *
     * Transform coordinates from world coordinate to data
     *
     * @param {*} stack
     * @param {*} worldCoordinates
     *
     * @return {*}
     */

  }, {
    key: 'worldToData',
    value: function worldToData(stack, worldCoordinates) {
      console.warn('models.stack.worldToData is deprecated.\n       Please use core.utils.worldToData instead.');

      return _core4.default.worldToData(stack._lps2IJK, worldCoordinates);
    }
  }]);

  return ModelsStack;
}(_models2.default);

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }


exports.default = ModelsStack;

},{"../core/core.colors":101,"../core/core.utils":105,"../models/models.base":130,"math-float32-to-binary-string":43}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module models/voxel
 */

var ModelsVoxel = function () {
  function ModelsVoxel() {
    _classCallCheck(this, ModelsVoxel);

    this._id = -1;
    this._worldCoordinates = null;
    this._dataCoordinates = null;
    this._screenCoordinates = null;
    this._value = null;
  }

  _createClass(ModelsVoxel, [{
    key: "worldCoordinates",
    set: function set(worldCoordinates) {
      this._worldCoordinates = worldCoordinates;
    },
    get: function get() {
      return this._worldCoordinates;
    }
  }, {
    key: "dataCoordinates",
    set: function set(dataCoordinates) {
      this._dataCoordinates = dataCoordinates;
    },
    get: function get() {
      return this._dataCoordinates;
    }
  }, {
    key: "screenCoordinates",
    set: function set(screenCoordinates) {
      this._screenCoordinates = screenCoordinates;
    },
    get: function get() {
      return this._screenCoordinates;
    }
  }, {
    key: "value",
    set: function set(value) {
      this._value = value;
    },
    get: function get() {
      return this._value;
    }
  }, {
    key: "id",
    set: function set(id) {
      this._id = id;
    },
    get: function get() {
      return this._id;
    }
  }]);

  return ModelsVoxel;
}();

exports.default = ModelsVoxel;

},{}],136:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

/** * Imports ***/


var DicomParser = require('dicom-parser');
var Jpeg = require('jpeg-lossless-decoder-js');
var JpegBaseline = require('../../external/scripts/jpeg');
var Jpx = require('../../external/scripts/jpx');

/**
 * Dicom parser is a combination of utilities to get a VJS image from dicom files.
 *scripts
 * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.
 *
 * @module parsers/dicom
 *
 * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which
 * VJS.parsers.dicom can pull the data from.
 */

var ParsersDicom = function (_ParsersVolume) {
  _inherits(ParsersDicom, _ParsersVolume);

  function ParsersDicom(data, id) {
    _classCallCheck(this, ParsersDicom);

    var _this = _possibleConstructorReturn(this, (ParsersDicom.__proto__ || Object.getPrototypeOf(ParsersDicom)).call(this));

    _this._id = id;

    _this._arrayBuffer = data.buffer;

    var byteArray = new Uint8Array(_this._arrayBuffer);

    // catch error
    // throw error if any!
    _this._dataSet = null;

    try {
      _this._dataSet = DicomParser.parseDicom(byteArray);
    } catch (e) {
      window.console.log(e);
      throw 'parsers.dicom could not parse the file';
    }
    return _this;
  }

  // image/frame specific


  _createClass(ParsersDicom, [{
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      return this._dataSet.string('x0020000e');
    }
  }, {
    key: 'studyInstanceUID',
    value: function studyInstanceUID() {
      return this._dataSet.string('x0020000d');
    }
  }, {
    key: 'modality',
    value: function modality() {
      return this._dataSet.string('x00080060');
    }
  }, {
    key: 'segmentationType',
    value: function segmentationType() {
      return this._dataSet.string('x00620001');
    }
  }, {
    key: 'segmentationSegments',
    value: function segmentationSegments() {
      var segmentationSegments = [];
      var segmentSequence = this._dataSet.elements.x00620002;

      if (!segmentSequence) {
        return segmentationSegments;
      }

      for (var i = 0; i < segmentSequence.items.length; i++) {
        var recommendedDisplayCIELab = this._recommendedDisplayCIELab(segmentSequence.items[i]);
        var segmentationCode = this._segmentationCode(segmentSequence.items[i]);
        var segmentNumber = segmentSequence.items[i].dataSet.uint16('x00620004');
        var segmentLabel = segmentSequence.items[i].dataSet.string('x00620005');
        var segmentAlgorithmType = segmentSequence.items[i].dataSet.string('x00620008');

        segmentationSegments.push({
          recommendedDisplayCIELab: recommendedDisplayCIELab,
          segmentationCodeDesignator: segmentationCode['segmentationCodeDesignator'],
          segmentationCodeValue: segmentationCode['segmentationCodeValue'],
          segmentationCodeMeaning: segmentationCode['segmentationCodeMeaning'],
          segmentNumber: segmentNumber,
          segmentLabel: segmentLabel,
          segmentAlgorithmType: segmentAlgorithmType
        });
      }

      return segmentationSegments;
    }
  }, {
    key: '_segmentationCode',
    value: function _segmentationCode(segment) {
      var segmentationCodeDesignator = 'unknown';
      var segmentationCodeValue = 'unknown';
      var segmentationCodeMeaning = 'unknown';
      var element = segment.dataSet.elements.x00082218;

      if (element && element.items && element.items.length > 0) {
        segmentationCodeDesignator = element.items[0].dataSet.string('x00080102');
        segmentationCodeValue = element.items[0].dataSet.string('x00080100');
        segmentationCodeMeaning = element.items[0].dataSet.string('x00080104');
      }

      return {
        segmentationCodeDesignator: segmentationCodeDesignator,
        segmentationCodeValue: segmentationCodeValue,
        segmentationCodeMeaning: segmentationCodeMeaning
      };
    }
  }, {
    key: '_recommendedDisplayCIELab',
    value: function _recommendedDisplayCIELab(segment) {
      if (!segment.dataSet.elements.x0062000d) {
        return null;
      }

      var offset = segment.dataSet.elements.x0062000d.dataOffset;
      var length = segment.dataSet.elements.x0062000d.length;
      var byteArray = segment.dataSet.byteArray.slice(offset, offset + length);

      // https://www.dabsoft.ch/dicom/3/C.10.7.1.1/
      var CIELabScaled = new Uint16Array(length / 2);
      for (var i = 0; i < length / 2; i++) {
        CIELabScaled[i] = (byteArray[2 * i + 1] << 8) + byteArray[2 * i];
      }

      var CIELabNormalized = [CIELabScaled[0] / 65535 * 100, CIELabScaled[1] / 65535 * 255 - 128, CIELabScaled[2] / 65535 * 255 - 128];

      return CIELabNormalized;
    }

    /**
     * SOP Instance UID
     *
     * @param {*} frameIndex
     *
     * @return {*}
     */

  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var sopInstanceUID = this._findStringEverywhere('x2005140f', 'x00080018', frameIndex);
      return sopInstanceUID;
    }

    /**
     * Transfer syntax UID
     *
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUID',
    value: function transferSyntaxUID() {
      return this._dataSet.string('x00020010');
    }

    /**
     * Study description
     *
     * @return {*}
     */

  }, {
    key: 'studyDescription',
    value: function studyDescription() {
      return this._dataSet.string('x00081030');
    }

    /**
     * Series description
     *
     * @return {*}
     */

  }, {
    key: 'seriesDescription',
    value: function seriesDescription() {
      return this._dataSet.string('x0008103e');
    }

    /**
     * Patient name
     *
     * @return {*}
     */

  }, {
    key: 'patientName',
    value: function patientName() {
      return this._dataSet.string('x00100010');
    }

    /**
     * Patient ID
     *
     * @return {*}
     */

  }, {
    key: 'patientID',
    value: function patientID() {
      return this._dataSet.string('x00100020');
    }

    /**
     * Patient birthdate
     *
     * @return {*}
     */

  }, {
    key: 'patientBirthdate',
    value: function patientBirthdate() {
      return this._dataSet.string('x00100030');
    }

    /**
     * Patient sex
     *
     * @return {*}
     */

  }, {
    key: 'patientSex',
    value: function patientSex() {
      return this._dataSet.string('x00100040');
    }

    /**
     * Patient age
     *
     * @return {*}
     */

  }, {
    key: 'patientAge',
    value: function patientAge() {
      return this._dataSet.string('x00101010');
    }

    /**
     * Photometric interpretation
     *
     * @return {*}
     */

  }, {
    key: 'photometricInterpretation',
    value: function photometricInterpretation() {
      return this._dataSet.string('x00280004');
    }
  }, {
    key: 'planarConfiguration',
    value: function planarConfiguration() {
      var planarConfiguration = this._dataSet.uint16('x00280006');

      if (typeof planarConfiguration === 'undefined') {
        planarConfiguration = null;
      }

      return planarConfiguration;
    }
  }, {
    key: 'samplesPerPixel',
    value: function samplesPerPixel() {
      return this._dataSet.uint16('x00280002');
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      var numberOfFrames = this._dataSet.intString('x00280008');

      // need something smarter!
      if (typeof numberOfFrames === 'undefined') {
        numberOfFrames = null;
      }

      return numberOfFrames;
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;
      var photometricInterpretation = this.photometricInterpretation();

      if (!(photometricInterpretation !== 'RGB' && photometricInterpretation !== 'PALETTE COLOR' && photometricInterpretation !== 'YBR_FULL' && photometricInterpretation !== 'YBR_FULL_422' && photometricInterpretation !== 'YBR_PARTIAL_422' && photometricInterpretation !== 'YBR_PARTIAL_420' && photometricInterpretation !== 'YBR_RCT')) {
        numberOfChannels = 3;
      }

      // make sure we return a number! (not a string!)
      return numberOfChannels;
    }
  }, {
    key: 'invert',
    value: function invert() {
      var photometricInterpretation = this.photometricInterpretation();

      return photometricInterpretation === 'MONOCHROME1' ? true : false;
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var imageOrientation = this._findStringEverywhere('x00209116', 'x00200037', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      if (imageOrientation) {
        // make sure we return a number! (not a string!)
        // might not need to split (floatString + index)
        imageOrientation = imageOrientation.split('\\').map(Number);
      }

      return imageOrientation;
    }
  }, {
    key: 'referencedSegmentNumber',
    value: function referencedSegmentNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var referencedSegmentNumber = -1;
      var referencedSegmentNumberElement = this._findInGroupSequence('x52009230', 'x0062000a', frameIndex);

      if (referencedSegmentNumberElement !== null) {
        referencedSegmentNumber = referencedSegmentNumberElement.uint16('x0062000b');
      }

      return referencedSegmentNumber;
    }
  }, {
    key: 'pixelAspectRatio',
    value: function pixelAspectRatio() {
      var pixelAspectRatio = [this._dataSet.intString('x00280034', 0), this._dataSet.intString('x00280034', 1)];

      // need something smarter!
      if (typeof pixelAspectRatio[0] === 'undefined') {
        pixelAspectRatio = null;
      }

      // make sure we return a number! (not a string!)
      return pixelAspectRatio;
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var imagePosition = this._findStringEverywhere('x00209113', 'x00200032', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      if (imagePosition) {
        // make sure we return a number! (not a string!)
        imagePosition = imagePosition.split('\\').map(Number);
      }

      return imagePosition;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var instanceNumber = null;
      // first look for frame!
      // per frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        if (perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x2005140f) {
          var planeOrientationSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;
          instanceNumber = planeOrientationSequence.intString('x00200013');
        } else {
          instanceNumber = this._dataSet.intString('x00200013');

          if (typeof instanceNumber === 'undefined') {
            instanceNumber = null;
          }
        }
      } else {
        // should we default to undefined??
        // default orientation
        instanceNumber = this._dataSet.intString('x00200013');

        if (typeof instanceNumber === 'undefined') {
          instanceNumber = null;
        }
      }

      return instanceNumber;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var pixelSpacing = this._findStringEverywhere('x00289110', 'x00280030', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      // should we default to undefined??
      if (pixelSpacing) {
        // make sure we return array of numbers! (not strings!)
        pixelSpacing = pixelSpacing.split('\\').map(Number);
      }

      return pixelSpacing;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var rows = this._dataSet.uint16('x00280010');

      if (typeof rows === 'undefined') {
        rows = null;
        // print warning at least...
      }

      return rows;
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var columns = this._dataSet.uint16('x00280011');

      if (typeof columns === 'undefined') {
        columns = null;
        // print warning at least...
      }

      return columns;
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 integer, 1 float
      // dicom only support integers
      return 0;
    }
  }, {
    key: 'pixelRepresentation',
    value: function pixelRepresentation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var pixelRepresentation = this._dataSet.uint16('x00280103');
      return pixelRepresentation;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var bitsAllocated = this._dataSet.uint16('x00280100');
      return bitsAllocated;
    }
  }, {
    key: 'highBit',
    value: function highBit() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var highBit = this._dataSet.uint16('x00280102');
      return highBit;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289145', 'x00281052', frameIndex);
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289145', 'x00281053', frameIndex);
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289132', 'x00281050', frameIndex);
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289132', 'x00281051', frameIndex);
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289110', 'x00180050', frameIndex);
    }
  }, {
    key: 'spacingBetweenSlices',
    value: function spacingBetweenSlices() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var spacing = this._dataSet.intString('x00180088');

      if (typeof spacing === 'undefined') {
        spacing = null;
      }

      return spacing;
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var dimensionIndexValues = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        var frameContentSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111;
        if (frameContentSequence !== undefined && frameContentSequence !== null) {
          frameContentSequence = frameContentSequence.items[0].dataSet;
          var dimensionIndexValuesElt = frameContentSequence.elements.x00209157;
          if (dimensionIndexValuesElt !== undefined && dimensionIndexValuesElt !== null) {
            // /4 because UL
            var nbValues = dimensionIndexValuesElt.length / 4;
            dimensionIndexValues = [];

            for (var i = 0; i < nbValues; i++) {
              dimensionIndexValues.push(frameContentSequence.uint32('x00209157', i));
            }
          }
        }
      }

      return dimensionIndexValues;
    }
  }, {
    key: 'inStackPositionNumber',
    value: function inStackPositionNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var inStackPositionNumber = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        // NOT A PHILIPS TRICK!
        var philipsPrivateSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;
        inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');
      } else {
        inStackPositionNumber = null;
      }

      console.log('instack position ' + inStackPositionNumber);

      return inStackPositionNumber;
    }
  }, {
    key: 'stackID',
    value: function stackID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var stackID = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        // NOT A PHILIPS TRICK!
        var philipsPrivateSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;
        stackID = philipsPrivateSequence.intString('x00209056');
      } else {
        stackID = null;
      }

      return stackID;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // decompress
      var decompressedData = this._decodePixelData(frameIndex);

      var numberOfChannels = this.numberOfChannels();

      if (numberOfChannels > 1) {
        return this._convertColorSpace(decompressedData);
      } else {
        return decompressedData;
      }
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;

      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }

    //
    // private methods
    //

  }, {
    key: '_findInGroupSequence',
    value: function _findInGroupSequence(sequence, subsequence, index) {
      var functionalGroupSequence = this._dataSet.elements[sequence];

      if (typeof functionalGroupSequence !== 'undefined') {
        var inSequence = functionalGroupSequence.items[index].dataSet.elements[subsequence];

        if (typeof inSequence !== 'undefined') {
          return inSequence.items[0].dataSet;
        }
      }

      return null;
    }
  }, {
    key: '_findStringInGroupSequence',
    value: function _findStringInGroupSequence(sequence, subsequence, tag, index) {
      // index = 0 if shared!!!
      var dataSet = this._findInGroupSequence(sequence, subsequence, index);

      if (dataSet !== null) {
        return dataSet.string(tag);
      }

      return null;
    }
  }, {
    key: '_findStringInFrameGroupSequence',
    value: function _findStringInFrameGroupSequence(subsequence, tag, index) {
      return this._findStringInGroupSequence('x52009229', subsequence, tag, 0) || this._findStringInGroupSequence('x52009230', subsequence, tag, index);
    }
  }, {
    key: '_findStringEverywhere',
    value: function _findStringEverywhere(subsequence, tag, index) {
      var targetString = this._findStringInFrameGroupSequence(subsequence, tag, index);

      if (targetString === null) {
        targetString = this._dataSet.string(tag);
      }

      if (typeof targetString === 'undefined') {
        targetString = null;
      }

      return targetString;
    }
  }, {
    key: '_findFloatStringInGroupSequence',
    value: function _findFloatStringInGroupSequence(sequence, subsequence, tag, index) {
      var dataInGroupSequence = this._dataSet.floatString(tag);

      // try to get it from enhanced MR images
      // per-frame functionnal group
      if (typeof dataInGroupSequence === 'undefined') {
        dataInGroupSequence = this._findInGroupSequence(sequence, subsequence, index);

        if (dataInGroupSequence !== null) {
          return dataInGroupSequence.floatString(tag);
        } else {
          return null;
        }
      }

      return dataInGroupSequence;
    }
  }, {
    key: '_findFloatStringInFrameGroupSequence',
    value: function _findFloatStringInFrameGroupSequence(subsequence, tag, index) {
      return this._findFloatStringInGroupSequence('x52009229', subsequence, tag, 0) || this._findFloatStringInGroupSequence('x52009230', subsequence, tag, index);
    }
  }, {
    key: '_decodePixelData',
    value: function _decodePixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // if compressed..?
      var transferSyntaxUID = this.transferSyntaxUID();

      // find compression scheme
      if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||
      // JPEG 2000 Lossless
      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {
        // JPEG 2000 Lossy
        return this._decodeJ2K(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.4.57' ||
      // JPEG Lossless, Nonhierarchical (Processes 14)
      transferSyntaxUID === '1.2.840.10008.1.2.4.70') {
        // JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])
        return this._decodeJPEGLossless(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.4.50' ||
      // JPEG Baseline lossy process 1 (8 bit)
      transferSyntaxUID === '1.2.840.10008.1.2.4.51') {
        // JPEG Baseline lossy process 2 & 4 (12 bit)
        return this._decodeJPEGBaseline(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2' ||
      // Implicit VR Little Endian
      transferSyntaxUID === '1.2.840.10008.1.2.1') {
        // Explicit VR Little Endian
        return this._decodeUncompressed(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.2') {
        // Explicit VR Big Endian
        var frame = this._decodeUncompressed(frameIndex);
        // and sawp it!
        return this._swapFrame(frame);
      } else {
        throw {
          error: 'no decoder for transfer syntax ' + transferSyntaxUID
        };
      }
    }
  }, {
    key: '_decodeJ2K',
    value: function _decodeJ2K() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      // let pixelDataElement = this._dataSet.elements.x7fe00010;
      // let pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);
      var jpxImage = new Jpx();
      // https://github.com/OHIF/image-JPEG2000/issues/6
      // It currently returns either Int16 or Uint16 based on whether the codestream is signed or not.
      jpxImage.parse(encodedPixelData);

      // let j2kWidth = jpxImage.width;
      // let j2kHeight = jpxImage.height;

      var componentsCount = jpxImage.componentsCount;
      if (componentsCount !== 1) {
        throw 'JPEG2000 decoder returned a componentCount of ${componentsCount}, when 1 is expected';
      }
      var tileCount = jpxImage.tiles.length;

      if (tileCount !== 1) {
        throw 'JPEG2000 decoder returned a tileCount of ${tileCount}, when 1 is expected';
      }

      var tileComponents = jpxImage.tiles[0];
      var pixelData = tileComponents.items;

      // window.console.log(j2kWidth, j2kHeight);

      return pixelData;
    }

    // from cornerstone

  }, {
    key: '_decodeJPEGLossless',
    value: function _decodeJPEGLossless() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      var pixelRepresentation = this.pixelRepresentation(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var byteOutput = bitsAllocated <= 8 ? 1 : 2;
      var decoder = new Jpeg.lossless.Decoder();
      var decompressedData = decoder.decode(encodedPixelData.buffer, encodedPixelData.byteOffset, encodedPixelData.length, byteOutput);

      if (pixelRepresentation === 0) {
        if (byteOutput === 2) {
          return new Uint16Array(decompressedData.buffer);
        } else {
          // untested!
          return new Uint8Array(decompressedData.buffer);
        }
      } else {
        return new Int16Array(decompressedData.buffer);
      }
    }
  }, {
    key: '_decodeJPEGBaseline',
    value: function _decodeJPEGBaseline() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      var rows = this.rows(frameIndex);
      var columns = this.columns(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var jpegBaseline = new JpegBaseline();
      jpegBaseline.parse(encodedPixelData);

      if (bitsAllocated === 8) {
        return jpegBaseline.getData(columns, rows);
      } else if (bitsAllocated === 16) {
        return jpegBaseline.getData16(columns, rows);
      }
    }
  }, {
    key: '_decodeUncompressed',
    value: function _decodeUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var pixelRepresentation = this.pixelRepresentation(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var pixelDataElement = this._dataSet.elements.x7fe00010;
      var pixelDataOffset = pixelDataElement.dataOffset;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      var frameOffset = 0;
      var buffer = this._dataSet.byteArray.buffer;

      if (pixelRepresentation === 0 && bitsAllocated === 8) {
        // unsigned 8 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 16) {
        // unsigned 16 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 1 && bitsAllocated === 16) {
        // signed 16 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 32) {
        // unsigned 32 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 4;
        return new Uint32Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 1) {
        var newBuffer = new ArrayBuffer(numPixels);
        var newArray = new Uint8Array(newBuffer);

        frameOffset = pixelDataOffset + frameIndex * numPixels;
        var index = 0;

        var bitStart = frameIndex * numPixels;
        var bitEnd = frameIndex * numPixels + numPixels;

        var byteStart = Math.floor(bitStart / 8);
        var bitStartOffset = bitStart - byteStart * 8;
        var byteEnd = Math.ceil(bitEnd / 8);

        var targetBuffer = new Uint8Array(buffer, pixelDataOffset);

        for (var i = byteStart; i <= byteEnd; i++) {
          while (bitStartOffset < 8) {
            switch (bitStartOffset) {
              case 0:
                newArray[index] = targetBuffer[i] & 0x0001;
                break;
              case 1:
                newArray[index] = targetBuffer[i] >>> 1 & 0x0001;
                break;
              case 2:
                newArray[index] = targetBuffer[i] >>> 2 & 0x0001;
                break;
              case 3:
                newArray[index] = targetBuffer[i] >>> 3 & 0x0001;
                break;
              case 4:
                newArray[index] = targetBuffer[i] >>> 4 & 0x0001;
                break;
              case 5:
                newArray[index] = targetBuffer[i] >>> 5 & 0x0001;
                break;
              case 6:
                newArray[index] = targetBuffer[i] >>> 6 & 0x0001;
                break;
              case 7:
                newArray[index] = targetBuffer[i] >>> 7 & 0x0001;
                break;
              default:
                break;
            }

            bitStartOffset++;
            index++;
            // if return..
            if (index >= numPixels) {
              return newArray;
            }
          }
          bitStartOffset = 0;
        }
      }
    }
  }, {
    key: '_convertColorSpace',
    value: function _convertColorSpace(uncompressedData) {
      var rgbData = null;
      var photometricInterpretation = this.photometricInterpretation();
      var planarConfiguration = this.planarConfiguration();

      if (photometricInterpretation === 'RGB' && planarConfiguration === 0) {
        // ALL GOOD, ALREADY ORDERED
        // planar or non planar planarConfiguration
        rgbData = uncompressedData;
      } else if (photometricInterpretation === 'RGB' && planarConfiguration === 1) {
        if (uncompressedData instanceof Int8Array) {
          rgbData = new Int8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint8Array) {
          rgbData = new Uint8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Int16Array) {
          rgbData = new Int16Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint16Array) {
          rgbData = new Uint16Array(uncompressedData.length);
        } else {
          throw 'unsuported typed array: ${uncompressedData}';
        }

        var numPixels = uncompressedData.length / 3;
        var rgbaIndex = 0;
        var rIndex = 0;
        var gIndex = numPixels;
        var bIndex = numPixels * 2;
        for (var i = 0; i < numPixels; i++) {
          rgbData[rgbaIndex++] = uncompressedData[rIndex++]; // red
          rgbData[rgbaIndex++] = uncompressedData[gIndex++]; // green
          rgbData[rgbaIndex++] = uncompressedData[bIndex++]; // blue
        }
      } else if (photometricInterpretation === 'YBR_FULL') {
        if (uncompressedData instanceof Int8Array) {
          rgbData = new Int8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint8Array) {
          rgbData = new Uint8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Int16Array) {
          rgbData = new Int16Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint16Array) {
          rgbData = new Uint16Array(uncompressedData.length);
        } else {
          throw 'unsuported typed array: ${uncompressedData}';
        }

        // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js
        var nPixels = uncompressedData.length / 3;
        var ybrIndex = 0;
        var _rgbaIndex = 0;
        for (var _i = 0; _i < nPixels; _i++) {
          var y = uncompressedData[ybrIndex++];
          var cb = uncompressedData[ybrIndex++];
          var cr = uncompressedData[ybrIndex++];
          rgbData[_rgbaIndex++] = y + 1.40200 * (cr - 128); // red
          rgbData[_rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green
          rgbData[_rgbaIndex++] = y + 1.77200 * (cb - 128); // blue
          // rgbData[rgbaIndex++] = 255; //alpha
        }
      } else {
        throw 'photometric interpolation not supported: ${photometricInterpretation}';
      }

      return rgbData;
    }

    /**
     * Swap bytes in frame.
     */

  }, {
    key: '_swapFrame',
    value: function _swapFrame(frame) {
      // swap bytes ( if 8bits (1byte), nothing to swap)
      var bitsAllocated = this.bitsAllocated();

      if (bitsAllocated === 16) {
        for (var i = 0; i < frame.length; i++) {
          frame[i] = this._swap16(frame[i]);
        }
      } else if (bitsAllocated === 32) {
        for (var _i2 = 0; _i2 < frame.length; _i2++) {
          frame[_i2] = this._swap32(frame[_i2]);
        }
      }

      return frame;
    }
  }]);

  return ParsersDicom;
}(_parsers2.default);

// VJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {
//   // try to access frame of reference UID through its DICOM tag
//   let seriesNumber = imageJqueryDom.find('[tag="00200052"] Value').text();

//   // if not available, assume we only have 1 frame
//   if (seriesNumber === '') {
//     seriesNumber = 1;
//   }
//   return seriesNumber;
// };

//
// ENDIAN NESS NOT TAKEN CARE OF
// http://stackoverflow.com/questions/5320439/how-do-i-swap-endian-ness-byte-order-of-a-letiable-in-javascript
// http://www.barre.nom.fr/medical/samples/
//
//


exports.default = ParsersDicom;

},{"../../external/scripts/jpeg":1,"../../external/scripts/jpx":2,"./parsers.volume":141,"dicom-parser":25,"jpeg-lossless-decoder-js":35}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parsers = require('./parsers.dicom');

var _parsers2 = _interopRequireDefault(_parsers);

var _parsers3 = require('./parsers.nifti');

var _parsers4 = _interopRequireDefault(_parsers3);

var _parsers5 = require('./parsers.nrrd');

var _parsers6 = _interopRequireDefault(_parsers5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module parsers
 */

exports.default = {
  Dicom: _parsers2.default,
  Nifti: _parsers4.default,
  Nrrd: _parsers6.default
};

},{"./parsers.dicom":136,"./parsers.nifti":139,"./parsers.nrrd":140}],138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * @module parsers/mhd
 */
var ParsersMHD = function (_ParsersVolume) {
  _inherits(ParsersMHD, _ParsersVolume);

  function ParsersMHD(data, id) {
    _classCallCheck(this, ParsersMHD);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersMHD.__proto__ || Object.getPrototypeOf(ParsersMHD)).call(this));

    _this._id = id;
    _this._url = data.url;
    _this._header = {};
    _this._buffer = null;

    try {
      // parse header (mhd) data
      var lines = new TextDecoder().decode(data.mhdBuffer).split('\n');
      lines.forEach(function (line) {
        var keyvalue = line.split('=');
        if (keyvalue.length === 2) {
          _this._header[keyvalue[0].trim()] = keyvalue[1].trim();
        }
      });

      _this._header.DimSize = _this._header.DimSize.split(' ');
      _this._header.ElementSpacing = _this._header.ElementSpacing.split(' ');
      _this._header.TransformMatrix = _this._header.TransformMatrix.split(' ');
      _this._header.Offset = _this._header.Offset.split(' ');
      //
      _this._buffer = data.rawBuffer;
    } catch (error) {
      window.console.log('ooops... :(');
    }
    return _this;
  }

  _createClass(ParsersMHD, [{
    key: 'rightHanded',
    value: function rightHanded() {
      var anatomicalOrientation = this._header.AnatomicalOrientation;
      if (anatomicalOrientation === 'RAS' || anatomicalOrientation === 'RPI' || anatomicalOrientation === 'LPS' || anatomicalOrientation === 'LAI') {
        this._rightHanded = true;
      } else {
        this._rightHanded = false;
      }

      return this._rightHanded;
    }
  }, {
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return parseInt(this._header.DimSize[2], 10);
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return parseInt(this._header.DimSize[1], 10);
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return parseInt(this._header.DimSize[0], 10);
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 - int
      // 1 - float
      return 0;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var bitsAllocated = 1;

      if (this._header.ElementType === 'MET_UCHAR' || this._header.ElementType === 'MET_CHAR') {
        bitsAllocated = 8;
      } else if (this._header.ElementType === 'MET_USHORT' || this._header.ElementType === 'MET_SHORT') {
        bitsAllocated = 16;
      } else if (this._header.ElementType === 'MET_UFLOAT' || this._header.ElementType === 'MET_FLOAT') {
        bitsAllocated = 32;
      }

      return bitsAllocated;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var x = parseFloat(this._header.ElementSpacing[0], 10);
      var y = parseFloat(this._header.ElementSpacing[1], 10);
      var z = parseFloat(this._header.ElementSpacing[2], 10);
      return [x, y, z];
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var invertX = this._header.AnatomicalOrientation.match(/L/) ? -1 : 1;
      var invertY = this._header.AnatomicalOrientation.match(/P/) ? -1 : 1;

      var x = new THREE.Vector3(parseFloat(this._header.TransformMatrix[0]) * invertX, parseFloat(this._header.TransformMatrix[1]) * invertY, parseFloat(this._header.TransformMatrix[2]));
      x.normalize();

      var y = new THREE.Vector3(parseFloat(this._header.TransformMatrix[3]) * invertX, parseFloat(this._header.TransformMatrix[4]) * invertY, parseFloat(this._header.TransformMatrix[5]));
      y.normalize();

      return [x.x, x.y, x.z, y.x, y.y, y.z];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [parseFloat(this._header.Offset[0]), parseFloat(this._header.Offset[1]), parseFloat(this._header.Offset[2])];
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var buffer = this._buffer;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      if (!this.rightHanded()) {
        frameIndex = this.numberOfFrames() - 1 - frameIndex;
      }
      var frameOffset = frameIndex * numPixels;

      if (this._header.ElementType === 'MET_CHAR') {
        frameOffset = frameOffset;
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_UCHAR') {
        frameOffset = frameOffset;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_SHORT') {
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_USHORT') {
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_FLOAT') {
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      }
    }
  }]);

  return ParsersMHD;
}(_parsers2.default);

exports.default = ParsersMHD;

},{"./parsers.volume":141}],139:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // use nifti-js and just parse header.???

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

// http://brainder.org/2012/09/23/the-nifti-file-format/

/** * Imports ***/


var NiftiReader = require('nifti-reader-js');
/**
 * @module parsers/nifti
 */

var ParsersNifti = function (_ParsersVolume) {
  _inherits(ParsersNifti, _ParsersVolume);

  function ParsersNifti(data, id) {
    _classCallCheck(this, ParsersNifti);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersNifti.__proto__ || Object.getPrototypeOf(ParsersNifti)).call(this));

    _this._id = id;
    _this._arrayBuffer = data.buffer;
    _this._url = data.url;
    _this._dataSet = null;
    _this._niftiHeader = null;
    _this._niftiImage = null;
    _this._ordered = true;
    _this._orderedData = null;

    //
    _this._qfac = 1.0;

    if (NiftiReader.isNIFTI(_this._arrayBuffer)) {
      _this._dataSet = NiftiReader.readHeader(_this._arrayBuffer);
      _this._niftiImage = NiftiReader.readImage(_this._dataSet, _this._arrayBuffer);
    } else {
      throw 'parsers.nifti could not parse the file';
    }
    return _this;
  }

  _createClass(ParsersNifti, [{
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return this._dataSet.dims[3];
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;

      // can dims[0] >= 5 and not multi channels with RGB datatypecode?

      if (this._dataSet.dims[0] >= 5) {
        numberOfChannels = this._dataSet.dims[5];
        this._ordered = false;
      } else if (this._dataSet.datatypeCode === 128) {
        numberOfChannels = 3;
      } else if (this._dataSet.datatypeCode === 2304) {
        numberOfChannels = 4;
      }

      return numberOfChannels;
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.dims[2];
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.dims[1];
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // papaya.volume.nifti.NIFTI_TYPE_UINT8           = 2;
      // papaya.volume.nifti.NIFTI_TYPE_INT16           = 4;
      // papaya.volume.nifti.NIFTI_TYPE_INT32           = 8;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT32        = 16;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX64      = 32;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT64        = 64;
      // papaya.volume.nifti.NIFTI_TYPE_RGB24         = 128;
      // papaya.volume.nifti.NIFTI_TYPE_INT8          = 256;
      // papaya.volume.nifti.NIFTI_TYPE_UINT16        = 512;
      // papaya.volume.nifti.NIFTI_TYPE_UINT32        = 768;
      // papaya.volume.nifti.NIFTI_TYPE_INT64        = 1024;
      // papaya.volume.nifti.NIFTI_TYPE_UINT64       = 1280;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT128     = 1536;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX128   = 1792;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX256   = 2048;

      // 0 integer, 1 float

      var pixelType = 0;
      if (this._dataSet.datatypeCode === 16 || this._dataSet.datatypeCode === 64 || this._dataSet.datatypeCode === 1536) {
        pixelType = 1;
      }
      return pixelType;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.numBitsPerVoxel;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [this._dataSet.pixDims[1], this._dataSet.pixDims[2], this._dataSet.pixDims[3]];
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      // should be a string...
      return null; // this._dataSet.pixDims[3].toString();
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // window.console.log(this._dataSet);
      // http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
      // http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c
      if (this._dataSet.qform_code > 0) {
        // https://github.com/Kitware/ITK/blob/master/Modules/IO/NIFTI/src/itkNiftiImageIO.cxx
        var a = 0.0;
        var b = this._dataSet.quatern_b;
        var c = this._dataSet.quatern_c;
        var d = this._dataSet.quatern_d;
        // compute a
        a = 1.0 - (b * b + c * c + d * d);
        if (a < 0.0000001) {
          /* special case */

          a = 1.0 / Math.sqrt(b * b + c * c + d * d);
          b *= a;c *= a;d *= a; /* normalize (b,c,d) vector */
          a = 0.0; /* a = 0 ==> 180 degree rotation */
        } else {
          a = Math.sqrt(a); /* angle = 2*arccos(a) */
        }

        if (this._dataSet.pixDims[0] < 0.0) {
          this._rightHanded = false;
        }

        return [-(a * a + b * b - c * c - d * d), -2 * (b * c + a * d), 2 * (b * d - a * c), -2 * (b * c - a * d), -(a * a + c * c - b * b - d * d), 2 * (c * d + a * b)];
      } else if (this._dataSet.sform_code > 0) {
        console.log('sform > 0');

        var sx = this._dataSet.srow_x;
        var sy = this._dataSet.srow_y;
        var sz = this._dataSet.srow_z;
        // fill IJKToRAS
        // goog.vec.Mat4.setRowValues(IJKToRAS, 0, sx[0], sx[1], sx[2], sx[3]);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 1, sy[0], sy[1], sy[2], sy[3]);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 2, sz[0], sz[1], sz[2], sz[3]);
      } else if (this._dataSet.qform_code === 0) {
        console.log('qform === 0');

        // fill IJKToRAS
        // goog.vec.Mat4.setRowValues(IJKToRAS, 0, MRI.pixdim[1], 0, 0, 0);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 1, 0, MRI.pixdim[2], 0, 0);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 2, 0, 0, MRI.pixdim[3], 0);
      }
      return [1, 0, 0, 0, 1, 0];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // qoffset is RAS
      return [-this._dataSet.qoffset_x, -this._dataSet.qoffset_y, this._dataSet.qoffset_z];
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.scl_slope;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.scl_intercept;
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
      // let buffer = this._dataSet.imageData;
      // if (this._dataSet.compressed) {
      // let buffer = this._dataSet.rawData[0];
      // try {
      //   let data = pako.inflate(new Uint8Array(buffer));
      //   buffer = data.buffer;
      // } catch (err) {
      //   console.log(err);
      // }

      // window.console.log(buffer);
      // }

      // is it compressed?
      // yes/no

      //     try {
      //   var result = pako.inflate(compressed);
      // } catch (err) {
      //   console.log(err);
      // }

      // window.console.log(this);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // papaya.volume.nifti.NIFTI_TYPE_UINT8           = 2;
      // papaya.volume.nifti.NIFTI_TYPE_INT16           = 4;
      // papaya.volume.nifti.NIFTI_TYPE_INT32           = 8;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT32        = 16;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX64      = 32;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT64        = 64;
      // papaya.volume.nifti.NIFTI_TYPE_RGB24         = 128;
      // papaya.volume.nifti.NIFTI_TYPE_INT8          = 256;
      // papaya.volume.nifti.NIFTI_TYPE_UINT16        = 512;
      // papaya.volume.nifti.NIFTI_TYPE_UINT32        = 768;
      // papaya.volume.nifti.NIFTI_TYPE_INT64        = 1024;
      // papaya.volume.nifti.NIFTI_TYPE_UINT64       = 1280;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT128     = 1536;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX128   = 1792;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX256   = 2048;

      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      // if( !this.rightHanded() ){
      //   frameIndex = this.numberOfFrames() - 1 - frameIndex;
      // }
      var frameOffset = frameIndex * numPixels;
      var buffer = this._niftiImage;

      // use bits allocated && pixel reprensentation too
      if (!this._ordered && this._orderedData === null) {
        // order then
        this._reorderData();
      }

      if (this._orderedData !== null) {
        // just a slice...
        return this._orderedData.slice(frameOffset, frameOffset + numPixels);
      } else if (this._dataSet.datatypeCode === 2) {
        // unsigned int 8 bit
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 256) {
        // signed int 8 bit
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 512) {
        // unsigned int 16 bit
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 4) {
        // signed int 16 bit
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 8) {
        // signed int 32 bit
        frameOffset = frameOffset * 4;
        return new Int32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 16) {
        // signed float 32 bit
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      } else {
        console.log('Unknown data type: datatypeCode : ' + this._dataSet.datatypeCode);
      }
    }
  }, {
    key: '_reorderData',
    value: function _reorderData() {
      window.console.log('re-order');
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows() * this.columns() * numberOfChannels;
      var buffer = this._niftiImage;

      var totalNumPixels = numPixels * this.numberOfFrames();
      var tmp = null;
      this._orderedData = null;

      if (this._dataSet.datatypeCode === 2) {
        // unsigned 8 bit
        tmp = new Uint8Array(buffer, 0, totalNumPixels);
        this._orderedData = new Uint8Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 256) {
        // signed 8 bit
        tmp = new Int8Array(buffer, 0, totalNumPixels);
        this._orderedData = new Int8Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 512) {
        tmp = new Uint16Array(buffer, 0, totalNumPixels);
        this._orderedData = new Uint16Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 4) {
        tmp = new Int16Array(buffer, 0, totalNumPixels);
        this._orderedData = new Int16Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 16) {
        tmp = new Float32Array(buffer, 0, totalNumPixels);
        this._orderedData = new Float32Array(tmp.length);
      }

      // re-order pixels...
      var numPixels2 = tmp.length / 3;
      var rgbaIndex = 0;
      var rIndex = 0;
      var gIndex = numPixels2;
      var bIndex = numPixels2 * 2;

      for (var i = 0; i < numPixels2; i++) {
        this._orderedData[rgbaIndex++] = tmp[rIndex++]; // red
        this._orderedData[rgbaIndex++] = tmp[gIndex++]; // green
        this._orderedData[rgbaIndex++] = tmp[bIndex++]; // blue
      }

      this._ordered = true;
    }
  }]);

  return ParsersNifti;
}(_parsers2.default);

exports.default = ParsersNifti;

},{"./parsers.volume":141,"nifti-reader-js":46}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // use nifti-js and just parse header.???

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

// http://brainder.org/2012/09/23/the-nifti-file-format/

/** * Imports ***/


var pako = require('pako');
var NrrdReader = require('nrrd-js');
/**
 * @module parsers/nifti
 */

var ParsersNifti = function (_ParsersVolume) {
  _inherits(ParsersNifti, _ParsersVolume);

  function ParsersNifti(data, id) {
    _classCallCheck(this, ParsersNifti);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersNifti.__proto__ || Object.getPrototypeOf(ParsersNifti)).call(this));

    _this._id = id;
    _this._arrayBuffer = data.buffer;
    _this._url = data.url;
    _this._dataSet = null;
    _this._unpackedData = null;

    try {
      _this._dataSet = NrrdReader.parse(_this._arrayBuffer);
      console.log(_this._dataSet);
    } catch (error) {
      window.console.log('ooops... :(');
    }

    window.console.log(_this._dataSet);
    return _this;
  }

  _createClass(ParsersNifti, [{
    key: 'rightHanded',
    value: function rightHanded() {
      if (this._dataSet.space.match(/^right-anterior-superior/) || this._dataSet.space.match(/^left-posterior-superior/)) {
        this._rightHanded = true;
      } else {
        this._rightHanded = false;
      }

      return this._rightHanded;
    }
  }, {
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return this._dataSet.sizes[2];
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;
      return numberOfChannels;
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.sizes[1];
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.sizes[0];
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 - int
      // 1 - float
      var pixelType = 0;
      if (this._dataSet.type === 'float') {
        pixelType = 1;
      }
      return pixelType;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var bitsAllocated = 1;

      if (this._dataSet.type === 'int8' || this._dataSet.type === 'uint8' || this._dataSet.type === 'char') {
        bitsAllocated = 8;
      } else if (this._dataSet.type === 'int16' || this._dataSet.type === 'uint16' || this._dataSet.type === 'short') {
        bitsAllocated = 16;
      } else if (this._dataSet.type === 'int32' || this._dataSet.type === 'uint32' || this._dataSet.type === 'float') {
        bitsAllocated = 32;
      }

      return bitsAllocated;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var x = new THREE.Vector3(this._dataSet.spaceDirections[0][0], this._dataSet.spaceDirections[0][1], this._dataSet.spaceDirections[0][2]);

      var y = new THREE.Vector3(this._dataSet.spaceDirections[1][0], this._dataSet.spaceDirections[1][1], this._dataSet.spaceDirections[1][2]);

      var z = new THREE.Vector3(this._dataSet.spaceDirections[2][0], this._dataSet.spaceDirections[2][1], this._dataSet.spaceDirections[2][2]);

      return [x.length(), y.length(), z.length()];
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      // should be a string...
      return null; // this._dataSet.pixDims[3].toString();
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var invertX = this._dataSet.space.match(/right/) ? -1 : 1;
      var invertY = this._dataSet.space.match(/anterior/) ? -1 : 1;

      var x = new THREE.Vector3(this._dataSet.spaceDirections[0][0] * invertX, this._dataSet.spaceDirections[0][1] * invertY, this._dataSet.spaceDirections[0][2]);
      x.normalize();

      var y = new THREE.Vector3(this._dataSet.spaceDirections[1][0] * invertX, this._dataSet.spaceDirections[1][1] * invertY, this._dataSet.spaceDirections[1][2]);
      y.normalize();

      return [x.x, x.y, x.z, y.x, y.y, y.z];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [this._dataSet.spaceOrigin[0], this._dataSet.spaceOrigin[1], this._dataSet.spaceOrigin[2]];
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 1; // this._dataSet.scl_slope;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 0; // this._dataSet.scl_intercept;
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var buffer = this._dataSet.buffer;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      if (!this.rightHanded()) {
        frameIndex = this.numberOfFrames() - 1 - frameIndex;
      }
      var frameOffset = frameIndex * numPixels;

      // unpack data if needed
      if (this._unpackedData === null && this._dataSet.encoding === 'gzip') {
        var unpackedData = pako.inflate(this._dataSet.buffer);
        this._unpackedData = unpackedData.buffer;
        buffer = this._unpackedData;
      } else if (this._dataSet.encoding === 'gzip') {
        buffer = this._unpackedData;
      }

      if (this._dataSet.type === 'int8' || this._dataSet.type === 'char') {
        frameOffset = frameOffset;
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint8') {
        frameOffset = frameOffset;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'int16' || this._dataSet.type === 'short') {
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint16') {
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'int32') {
        frameOffset = frameOffset * 4;
        return new Int32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint32') {
        frameOffset = frameOffset * 4;
        return new Uint32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'float') {
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      }
    }
  }]);

  return ParsersNifti;
}(_parsers2.default);

exports.default = ParsersNifti;

},{"./parsers.volume":141,"nrrd-js":50,"pako":51}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module parsers/volume
 */
var ParsersVolume = function () {
  function ParsersVolume() {
    _classCallCheck(this, ParsersVolume);

    this._rightHanded = true;
  }

  _createClass(ParsersVolume, [{
    key: 'pixelRepresentation',
    value: function pixelRepresentation() {
      return 0;
    }
  }, {
    key: 'modality',
    value: function modality() {
      return 'unknown';
    }
  }, {
    key: 'segmentationType',
    value: function segmentationType() {
      return 'unknown';
    }
  }, {
    key: 'segmentationSegments',
    value: function segmentationSegments() {
      return [];
    }
  }, {
    key: 'referencedSegmentNumber',
    value: function referencedSegmentNumber(frameIndex) {
      return -1;
    }
  }, {
    key: 'rightHanded',
    value: function rightHanded() {
      return this._rightHanded;
    }
  }, {
    key: 'spacingBetweenSlices',
    value: function spacingBetweenSlices() {
      return null;
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      return 1;
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      return null;
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 1;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 0;
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {}

    // http://stackoverflow.com/questions/5320439/how-do-i-swap-endian-ness-byte-order-of-a-variable-in-javascript

  }, {
    key: '_swap16',
    value: function _swap16(val) {
      return (val & 0xFF) << 8 | val >> 8 & 0xFF;
    }
  }, {
    key: '_swap32',
    value: function _swap32(val) {
      return (val & 0xFF) << 24 | (val & 0xFF00) << 8 | val >> 8 & 0xFF00 | val >> 24 & 0xFF;
    }
  }, {
    key: 'invert',
    value: function invert() {
      return false;
    }

    /**
     * Get the transfer syntax UID.
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUID',
    value: function transferSyntaxUID() {
      return 'no value provided';
    }

    /**
     * Get the study desciption.
     * @return {*}
     */

  }, {
    key: 'studyDescription',
    value: function studyDescription() {
      return 'no value provided';
    }

    /**
     * Get the series desciption.
     * @return {*}
     */

  }, {
    key: 'seriesDescription',
    value: function seriesDescription() {
      return 'no value provided';
    }

    /**
     * Get the patient ID.
     * @return {*}
     */

  }, {
    key: 'patientID',
    value: function patientID() {
      return 'no value provided';
    }

    /**
     * Get the patient name.
     * @return {*}
     */

  }, {
    key: 'patientName',
    value: function patientName() {
      return 'no value provided';
    }

    /**
     * Get the patient age.
     * @return {*}
     */

  }, {
    key: 'patientAge',
    value: function patientAge() {
      return 'no value provided';
    }

    /**
     * Get the patient birthdate.
     * @return {*}
     */

  }, {
    key: 'patientBirthdate',
    value: function patientBirthdate() {
      return 'no value provided';
    }

    /**
     * Get the patient sex.
     * @return {*}
     */

  }, {
    key: 'patientSex',
    value: function patientSex() {
      return 'no value provided';
    }
  }]);

  return ParsersVolume;
}();

exports.default = ParsersVolume;

},{}],142:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IntersectBox = function (_ShadersBase) {
  _inherits(IntersectBox, _ShadersBase);

  function IntersectBox() {
    _classCallCheck(this, IntersectBox);

    var _this = _possibleConstructorReturn(this, (IntersectBox.__proto__ || Object.getPrototypeOf(IntersectBox)).call(this));

    _this.name = 'intersectBox';

    // default properties names
    _this._rayOrigin = 'rayOrigin';
    _this._rayDirection = 'rayDirection';
    _this._aabbMin = 'aabbMin';
    _this._aabbMax = 'aabbMax';
    _this._tNear = 'tNear';
    _this._tFar = 'tFar';
    _this._intersect = 'intersect';
    return _this;
  }

  _createClass(IntersectBox, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var rayOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._rayOrigin;
      var rayDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._rayDirection;
      var aabbMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._aabbMin;
      var aabbMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._aabbMax;
      var tNear = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this._tNear;
      var tFar = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._tFar;
      var intersect = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this._intersect;

      this._base = baseFragment;
      return this.compute(rayOrigin, rayDirection, aabbMin, aabbMax, tNear, tFar, intersect);
    }
  }, {
    key: 'compute',
    value: function compute(rayOrigin, rayDirection, aabbMin, aabbMax, tNear, tFar, intersect) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + rayOrigin + ', ' + rayDirection + ', ' + aabbMin + ', ' + aabbMax + ', ' + tNear + ', ' + tFar + ', ' + intersect + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(vec3 rayOrigin, vec3 rayDirection, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar, out bool intersect){\n  // compute intersection of ray with all six bbox planes\n  vec3 invRay = vec3(1.) / rayDirection;\n  vec3 tBot = invRay * (boxMin - rayOrigin);\n  vec3 tTop = invRay * (boxMax - rayOrigin);\n  // re-order intersections to find smallest and largest on each axis\n  vec3 tMin = min(tTop, tBot);\n  vec3 tMax = max(tTop, tBot);\n  // find the largest tMin and the smallest tMax\n  float largest_tMin = max(max(tMin.x, tMin.y), max(tMin.x, tMin.z));\n  float smallest_tMax = min(min(tMax.x, tMax.y), min(tMax.x, tMax.z));\n  tNear = largest_tMin;\n  tFar = smallest_tMax;\n  intersect = smallest_tMax > largest_tMin;\n}\n\n    ';
    }
  }]);

  return IntersectBox;
}(_shaders2.default);

exports.default = new IntersectBox();

},{"../shaders.base":148}],143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Texture3d = function (_ShadersBase) {
  _inherits(Texture3d, _ShadersBase);

  function Texture3d() {
    _classCallCheck(this, Texture3d);

    var _this = _possibleConstructorReturn(this, (Texture3d.__proto__ || Object.getPrototypeOf(Texture3d)).call(this));

    _this.name = 'texture3d';

    // default properties names
    _this._dataCoordinates = 'dataCoordinates';
    _this._dataValue = 'dataValue';
    _this._offset = 'offset';
    return _this;
  }

  _createClass(Texture3d, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var dataCoordinates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._dataCoordinates;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;
      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._offset;

      this._base = baseFragment;
      return this.compute(dataCoordinates, dataValue, offset);
    }
  }, {
    key: 'compute',
    value: function compute(dataCoordinates, dataValue, offset) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + dataCoordinates + ', ' + dataValue + ', ' + offset + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in ivec3 dataCoordinates, out vec4 dataValue, out int offset){\n    \n  int index = dataCoordinates.x\n            + dataCoordinates.y * uDataDimensions.x\n            + dataCoordinates.z * uDataDimensions.y * uDataDimensions.x;\n  int indexP = int(index/uPackedPerPixel);\n  offset = index - 2*indexP;\n\n  // Map data index to right sampler2D texture\n  int voxelsPerTexture = uTextureSize*uTextureSize;\n  int textureIndex = int(floor(float(indexP) / float(voxelsPerTexture)));\n  // modulo seems incorrect sometimes...\n  // int inTextureIndex = int(mod(float(index), float(textureSize*textureSize)));\n  int inTextureIndex = indexP - voxelsPerTexture*textureIndex;\n\n  // Get row and column in the texture\n  int colIndex = int(mod(float(inTextureIndex), float(uTextureSize)));\n  int rowIndex = int(floor(float(inTextureIndex)/float(uTextureSize)));\n\n  // Map row and column to uv\n  vec2 uv = vec2(0,0);\n  uv.x = (0.5 + float(colIndex)) / float(uTextureSize);\n  uv.y = 1. - (0.5 + float(rowIndex)) / float(uTextureSize);\n\n  //\n  if(textureIndex == 0){ dataValue = texture2D(uTextureContainer[0], uv); }\n  else if(textureIndex == 1){dataValue = texture2D(uTextureContainer[1], uv);}\n  else if(textureIndex == 2){ dataValue = texture2D(uTextureContainer[2], uv); }\n  else if(textureIndex == 3){ dataValue = texture2D(uTextureContainer[3], uv); }\n  else if(textureIndex == 4){ dataValue = texture2D(uTextureContainer[4], uv); }\n  else if(textureIndex == 5){ dataValue = texture2D(uTextureContainer[5], uv); }\n  else if(textureIndex == 6){ dataValue = texture2D(uTextureContainer[6], uv); }\n\n}\n    ';
    }
  }]);

  return Texture3d;
}(_shaders2.default);

exports.default = new Texture3d();

},{"../shaders.base":148}],144:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Unpack = function (_ShadersBase) {
  _inherits(Unpack, _ShadersBase);

  function Unpack() {
    _classCallCheck(this, Unpack);

    var _this = _possibleConstructorReturn(this, (Unpack.__proto__ || Object.getPrototypeOf(Unpack)).call(this));

    _this.name = 'unpack';

    // default properties names
    _this._packedData = 'packedData';
    _this._offset = 'offset';
    _this._unpackedData = 'unpackedData';

    _this._base._uniforms = {
      uNumberOfChannels: {
        value: 1
      },
      uBitsAllocated: {
        value: 16
      },
      uPixelType: {
        value: 0
      }
    };
    return _this;
  }

  _createClass(Unpack, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var packedData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._packedData;
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._offset;
      var unpackedData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._unpackedData;

      this._base = baseFragment;
      return this.compute(packedData, offset, unpackedData);
    }
  }, {
    key: 'compute',
    value: function compute(packedData, offset, unpackedData) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + packedData + ', ' + offset + ', ' + unpackedData + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      // fun stuff
      var content = '';
      if (this._base._uniforms.uNumberOfChannels.value === 1) {
        switch (this._base._uniforms.uBitsAllocated.value) {

          case 1:
          case 8:
            content = this.upack8();
            break;

          case 16:
            content = this.upack16();
            break;

          case 32:
            content = this.upack32();
            break;

          default:
            content = this.upackDefault();
            break;

        }
      } else {
        content = this.upackIdentity();
      }

      this._definition = '\nvoid ' + this._name + '(in vec4 packedData, in int offset, out vec4 unpackedData){\n\n' + content + '\n\n}  \n    ';
    }
  }, {
    key: 'upack8',
    value: function upack8() {
      this._base._functions['uInt8'] = this.uInt8();

      return '\nuInt8(\n  packedData.r,\n  unpackedData.x);\n    ';
    }
  }, {
    key: 'upack16',
    value: function upack16() {
      this._base._functions['uInt16'] = this.uInt16();

      return '\nuInt16(\n  packedData.r * float( 1 - offset) + packedData.b * float(offset),\n  packedData.g * float( 1 - offset) + packedData.a * float(offset),\n  unpackedData.x);\n    ';
    }
  }, {
    key: 'upack32',
    value: function upack32() {
      if (this._base._uniforms.uPixelType.value === 0) {
        this._base._functions['uInt32'] = this.uInt32();

        return '\nuInt32(\n  packedData.r,\n  packedData.g,\n  packedData.b,\n  packedData.a,\n  unpackedData.x);\n      ';
      } else {
        this._base._functions['uFloat32'] = this.uFloat32();

        return '\nuFloat32(\n  packedData.r,\n  packedData.g,\n  packedData.b,\n  packedData.a,\n  unpackedData.x);\n      ';
      }
    }
  }, {
    key: 'upackIdentity',
    value: function upackIdentity() {
      return '\n\nunpackedData = packedData;\n\n      ';
    }
  }, {
    key: 'uInt8',
    value: function uInt8() {
      return '\nvoid uInt8(in float r, out float value){\n  value = r * 256.;\n}\n    ';
    }
  }, {
    key: 'uInt16',
    value: function uInt16() {
      return '\nvoid uInt16(in float r, in float a, out float value){\n  value = r * 256. + a * 65536.;\n}\n    ';
    }
  }, {
    key: 'uInt32',
    value: function uInt32() {
      return '\nvoid uInt32(in float r, in float g, in float b, in float a, out float value){\n  value = r * 256. + g * 65536. + b * 16777216. + a * 4294967296.;\n}\n    ';
    }
  }, {
    key: 'uFloat32',
    value: function uFloat32() {
      return '\nvoid uFloat32(in float r, in float g, in float b, in float a, out float value){\n\n  // create arrays containing bits for rgba values\n  // value between 0 and 255\n  value = r * 255.;\n  int bytemeR[8];\n  bytemeR[0] = int(floor(value / 128.));\n  value -= float(bytemeR[0] * 128);\n  bytemeR[1] = int(floor(value / 64.));\n  value -= float(bytemeR[1] * 64);\n  bytemeR[2] = int(floor(value / 32.));\n  value -= float(bytemeR[2] * 32);\n  bytemeR[3] = int(floor(value / 16.));\n  value -= float(bytemeR[3] * 16);\n  bytemeR[4] = int(floor(value / 8.));\n  value -= float(bytemeR[4] * 8);\n  bytemeR[5] = int(floor(value / 4.));\n  value -= float(bytemeR[5] * 4);\n  bytemeR[6] = int(floor(value / 2.));\n  value -= float(bytemeR[6] * 2);\n  bytemeR[7] = int(floor(value));\n\n  value = g * 255.;\n  int bytemeG[8];\n  bytemeG[0] = int(floor(value / 128.));\n  value -= float(bytemeG[0] * 128);\n  bytemeG[1] = int(floor(value / 64.));\n  value -= float(bytemeG[1] * 64);\n  bytemeG[2] = int(floor(value / 32.));\n  value -= float(bytemeG[2] * 32);\n  bytemeG[3] = int(floor(value / 16.));\n  value -= float(bytemeG[3] * 16);\n  bytemeG[4] = int(floor(value / 8.));\n  value -= float(bytemeG[4] * 8);\n  bytemeG[5] = int(floor(value / 4.));\n  value -= float(bytemeG[5] * 4);\n  bytemeG[6] = int(floor(value / 2.));\n  value -= float(bytemeG[6] * 2);\n  bytemeG[7] = int(floor(value));\n\n  value = b * 255.;\n  int bytemeB[8];\n  bytemeB[0] = int(floor(value / 128.));\n  value -= float(bytemeB[0] * 128);\n  bytemeB[1] = int(floor(value / 64.));\n  value -= float(bytemeB[1] * 64);\n  bytemeB[2] = int(floor(value / 32.));\n  value -= float(bytemeB[2] * 32);\n  bytemeB[3] = int(floor(value / 16.));\n  value -= float(bytemeB[3] * 16);\n  bytemeB[4] = int(floor(value / 8.));\n  value -= float(bytemeB[4] * 8);\n  bytemeB[5] = int(floor(value / 4.));\n  value -= float(bytemeB[5] * 4);\n  bytemeB[6] = int(floor(value / 2.));\n  value -= float(bytemeB[6] * 2);\n  bytemeB[7] = int(floor(value));\n\n  value = a * 255.;\n  int bytemeA[8];\n  bytemeA[0] = int(floor(value / 128.));\n  value -= float(bytemeA[0] * 128);\n  bytemeA[1] = int(floor(value / 64.));\n  value -= float(bytemeA[1] * 64);\n  bytemeA[2] = int(floor(value / 32.));\n  value -= float(bytemeA[2] * 32);\n  bytemeA[3] = int(floor(value / 16.));\n  value -= float(bytemeA[3] * 16);\n  bytemeA[4] = int(floor(value / 8.));\n  value -= float(bytemeA[4] * 8);\n  bytemeA[5] = int(floor(value / 4.));\n  value -= float(bytemeA[5] * 4);\n  bytemeA[6] = int(floor(value / 2.));\n  value -= float(bytemeA[6] * 2);\n  bytemeA[7] = int(floor(value));\n\n  // compute float32 value from bit arrays\n\n  // sign\n  int issigned = 1 - 2 * bytemeR[0];\n  //   issigned = int(pow(-1., float(bytemeR[0])));\n\n  // exponent\n  int exponent = 0;\n\n  exponent += bytemeR[1] * int(pow(2., 7.));\n  exponent += bytemeR[2] * int(pow(2., 6.));\n  exponent += bytemeR[3] * int(pow(2., 5.));\n  exponent += bytemeR[4] * int(pow(2., 4.));\n  exponent += bytemeR[5] * int(pow(2., 3.));\n  exponent += bytemeR[6] * int(pow(2., 2.));\n  exponent += bytemeR[7] * int(pow(2., 1.));\n\n  exponent += bytemeG[0];\n\n\n  // fraction\n  float fraction = 0.;\n\n  fraction = float(bytemeG[1]) * pow(2., -1.);\n  fraction += float(bytemeG[2]) * pow(2., -2.);\n  fraction += float(bytemeG[3]) * pow(2., -3.);\n  fraction += float(bytemeG[4]) * pow(2., -4.);\n  fraction += float(bytemeG[5]) * pow(2., -5.);\n  fraction += float(bytemeG[6]) * pow(2., -6.);\n  fraction += float(bytemeG[7]) * pow(2., -7.);\n\n  fraction += float(bytemeB[0]) * pow(2., -8.);\n  fraction += float(bytemeB[1]) * pow(2., -9.);\n  fraction += float(bytemeB[2]) * pow(2., -10.);\n  fraction += float(bytemeB[3]) * pow(2., -11.);\n  fraction += float(bytemeB[4]) * pow(2., -12.);\n  fraction += float(bytemeB[5]) * pow(2., -13.);\n  fraction += float(bytemeB[6]) * pow(2., -14.);\n  fraction += float(bytemeB[7]) * pow(2., -15.);\n\n  fraction += float(bytemeA[0]) * pow(2., -16.);\n  fraction += float(bytemeA[1]) * pow(2., -17.);\n  fraction += float(bytemeA[2]) * pow(2., -18.);\n  fraction += float(bytemeA[3]) * pow(2., -19.);\n  fraction += float(bytemeA[4]) * pow(2., -20.);\n  fraction += float(bytemeA[5]) * pow(2., -21.);\n  fraction += float(bytemeA[6]) * pow(2., -22.);\n  fraction += float(bytemeA[7]) * pow(2., -23.);\n\n  value = float(issigned) * pow( 2., float(exponent - 127)) * (1. + fraction);\n}\n    ';
    }
  }]);

  return Unpack;
}(_shaders2.default);

exports.default = new Unpack();

},{"../shaders.base":148}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersHelpers = require('../helpers/shaders.helpers.unpack');

var _shadersHelpers2 = _interopRequireDefault(_shadersHelpers);

var _shadersHelpers3 = require('../helpers/shaders.helpers.texture3d');

var _shadersHelpers4 = _interopRequireDefault(_shadersHelpers3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InterpolationIdentity = function (_ShadersBase) {
  _inherits(InterpolationIdentity, _ShadersBase);

  function InterpolationIdentity() {
    _classCallCheck(this, InterpolationIdentity);

    var _this = _possibleConstructorReturn(this, (InterpolationIdentity.__proto__ || Object.getPrototypeOf(InterpolationIdentity)).call(this));

    _this.name = 'interpolationIdentity';

    // default properties names
    _this._currentVoxel = 'currentVoxel';
    _this._dataValue = 'dataValue';
    return _this;
  }

  _createClass(InterpolationIdentity, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var currentVoxel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._currentVoxel;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;

      this._base = baseFragment;
      return this.compute(currentVoxel, dataValue);
    }
  }, {
    key: 'compute',
    value: function compute(currentVoxel, dataValue) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + currentVoxel + ', ' + dataValue + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in vec3 currentVoxel, out vec4 dataValue){\n  // lower bound\n  vec3 rcurrentVoxel = vec3(floor(currentVoxel.x + 0.5 ), floor(currentVoxel.y + 0.5 ), floor(currentVoxel.z + 0.5 ));\n  ivec3 voxel = ivec3(int(rcurrentVoxel.x), int(rcurrentVoxel.y), int(rcurrentVoxel.z));\n\n  vec4 tmp = vec4(0., 0., 0., 0.);\n  int offset = 0;\n\n  ' + _shadersHelpers4.default.api(this._base, 'voxel', 'tmp', 'offset') + '\n  ' + _shadersHelpers2.default.api(this._base, 'tmp', 'offset', 'dataValue') + '\n}\n    ';
    }
  }]);

  return InterpolationIdentity;
}(_shaders2.default);

exports.default = new InterpolationIdentity();

},{"../helpers/shaders.helpers.texture3d":143,"../helpers/shaders.helpers.unpack":144,"../shaders.base":148}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shadersInterpolation = require('./shaders.interpolation.identity');

var _shadersInterpolation2 = _interopRequireDefault(_shadersInterpolation);

var _shadersInterpolation3 = require('./shaders.interpolation.trilinear');

var _shadersInterpolation4 = _interopRequireDefault(_shadersInterpolation3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function shadersInterpolation(baseFragment, currentVoxel, dataValue, gradient) {
  switch (baseFragment._uniforms.uInterpolation.value) {

    case 0:
      // no interpolation
      return _shadersInterpolation2.default.api(baseFragment, currentVoxel, dataValue);

    case 1:
      // trilinear interpolation
      return _shadersInterpolation4.default.api(baseFragment, currentVoxel, dataValue, gradient);

    default:
      return _shadersInterpolation2.default.api(baseFragment, currentVoxel, dataValue);

  }
}

exports.default = shadersInterpolation;

},{"./shaders.interpolation.identity":145,"./shaders.interpolation.trilinear":147}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersInterpolation = require('./shaders.interpolation.identity');

var _shadersInterpolation2 = _interopRequireDefault(_shadersInterpolation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InterpolationTrilinear = function (_ShadersBase) {
  _inherits(InterpolationTrilinear, _ShadersBase);

  function InterpolationTrilinear() {
    _classCallCheck(this, InterpolationTrilinear);

    var _this = _possibleConstructorReturn(this, (InterpolationTrilinear.__proto__ || Object.getPrototypeOf(InterpolationTrilinear)).call(this));

    _this.name = 'interpolationTrilinear';

    // default properties names
    _this._currentVoxel = 'currentVoxel';
    _this._dataValue = 'dataValue';
    _this._gradient = 'gradient';
    return _this;
  }

  _createClass(InterpolationTrilinear, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var currentVoxel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._currentVoxel;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;
      var gradient = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._gradient;

      this._base = baseFragment;
      return this.compute(currentVoxel, dataValue, gradient);
    }
  }, {
    key: 'compute',
    value: function compute(currentVoxel, dataValue, gradient) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + currentVoxel + ', ' + dataValue + ', ' + gradient + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in vec3 currentVoxel, out vec4 dataValue, out vec3 gradient){\n\n  // https://en.wikipedia.org/wiki/Trilinear_interpolation\n  vec3 lower_bound = vec3(floor(currentVoxel.x), floor(currentVoxel.y), floor(currentVoxel.z));\n  if(lower_bound.x < 0.){\n    lower_bound.x = 0.;\n  }\n  if(lower_bound.y < 0.){\n    lower_bound.y = 0.;\n  }\n  if(lower_bound.z < 0.){\n    lower_bound.z = 0.;\n  }\n  \n  vec3 higher_bound = lower_bound + vec3(1);\n\n  float xd = ( currentVoxel.x - lower_bound.x ) / ( higher_bound.x - lower_bound.x );\n  float yd = ( currentVoxel.y - lower_bound.y ) / ( higher_bound.y - lower_bound.y );\n  float zd = ( currentVoxel.z - lower_bound.z ) / ( higher_bound.z - lower_bound.z );\n\n  //\n  // c00\n  //\n\n  //\n\n  vec4 v000 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c000 = vec3(lower_bound.x, lower_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c000', 'v000') + '\n  vec3 g000 = v000.r * vec3(-1., -1., -1.);\n\n  //\n\n  vec4 v100 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c100 = vec3(higher_bound.x, lower_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c100', 'v100') + '\n  vec3 g100 = v100.r * vec3(1., -1., -1.);\n\n  vec4 c00 = v000 * ( 1.0 - xd ) + v100 * xd;\n\n  //\n  // c01\n  //\n  vec4 v001 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c001 = vec3(lower_bound.x, lower_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c001', 'v001') + '\n  vec3 g001 = v001.r * vec3(-1., -1., 1.);\n\n  vec4 v101 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c101 = vec3(higher_bound.x, lower_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c101', 'v101') + '\n  vec3 g101 = v101.r * vec3(1., -1., 1.);\n\n  vec4 c01 = v001 * ( 1.0 - xd ) + v101 * xd;\n\n  //\n  // c10\n  //\n  vec4 v010 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c010 = vec3(lower_bound.x, higher_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c010', 'v010') + '\n  vec3 g010 = v010.r * vec3(-1., 1., -1.);\n\n  vec4 v110 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c110 = vec3(higher_bound.x, higher_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c110', 'v110') + '\n  vec3 g110 = v110.r * vec3(1., 1., -1.);\n\n  vec4 c10 = v010 * ( 1.0 - xd ) + v110 * xd;\n\n  //\n  // c11\n  //\n  vec4 v011 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c011 = vec3(lower_bound.x, higher_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c011', 'v011') + '\n  vec3 g011 = v011.r * vec3(-1., 1., 1.);\n\n  vec4 v111 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c111 = vec3(higher_bound.x, higher_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c111', 'v111') + '\n  vec3 g111 = v111.r * vec3(1., 1., 1.);\n\n  vec4 c11 = v011 * ( 1.0 - xd ) + v111 * xd;\n\n  // c0 and c1\n  vec4 c0 = c00 * ( 1.0 - yd) + c10 * yd;\n  vec4 c1 = c01 * ( 1.0 - yd) + c11 * yd;\n\n  // c\n  vec4 c = c0 * ( 1.0 - zd) + c1 * zd;\n  dataValue = c;\n\n  // compute gradient\n  gradient = g000 + g100 + g010 + g110 + g011 + g111 + g110 + g011;\n  // gradientMagnitude = length(gradient);\n  // // https://en.wikipedia.org/wiki/Normal_(geometry)#Transforming_normals\n  // vec3 localNormal = (-1. / gradientMagnitude) * gradient;\n  // normal = normalize(normalPixelToPatient' + this.id + ' * localNormal);\n  //normal = gradient;\n\n}\n    ';
    }
  }]);

  return InterpolationTrilinear;
}(_shaders2.default);

exports.default = new InterpolationTrilinear();

},{"../shaders.base":148,"./shaders.interpolation.identity":145}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersBase = function () {
  function ShadersBase() {
    _classCallCheck(this, ShadersBase);

    this._name = 'shadersBase';
    this._base = {
      _functions: {},
      _uniforms: {}
    };
    this._definition = '';
  }

  _createClass(ShadersBase, [{
    key: 'name',
    get: function get() {
      return this._name;
    },
    set: function set(name) {
      this._name = name;
    }
  }]);

  return ShadersBase;
}();

exports.default = ShadersBase;

},{}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\n\n    float luma (vec3 rgb) {\n\treturn (rgb.r + rgb.g + rgb.b)/3.0;\n}\n\nconst float T = 0.04;\nconst float M = 1.0;\nconst float L = 0.002;\n\nvoid main(void) {\n\n  vec2 texCoord = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n\n  float borderWidth = uWidth; // in px\n  float step_u = borderWidth * 1.0 / uCanvasWidth;\n  float step_v = borderWidth * 1.0 / uCanvasHeight;\n  vec4 centerPixel = texture2D(uTextureFilled, texCoord);\n\n  vec4 rightPixel  = texture2D(uTextureFilled, texCoord + vec2(step_u, 0.0));\n  vec4 bottomPixel = texture2D(uTextureFilled, texCoord + vec2(0.0, step_v));\n\n  // now manually compute the derivatives\n  float _dFdX = length(rightPixel - centerPixel) / step_u;\n  float _dFdY = length(bottomPixel - centerPixel) / step_v;\n\n  // gl_FragColor.r = _dFdX;\n  // gl_FragColor.g = _dFdY;\n  gl_FragColor.r = max(max(centerPixel.r, rightPixel.r), bottomPixel.r);\n  gl_FragColor.g = max(max(centerPixel.g, rightPixel.g), bottomPixel.g);\n  gl_FragColor.b = max(max(centerPixel.b, rightPixel.b), bottomPixel.b);\n  gl_FragColor.a = max(_dFdX, _dFdY);\n\n  return;\n  float h = 1./uCanvasHeight;\n  float w = 1./uCanvasWidth;\n  vec4 n[9];\n  n[0] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, -h));\n  n[1] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(0.0, -h));\n  n[2] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(  w, -h));\n  n[3] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, 0.0));\n  n[4] = texture2D(uTextureFilled, vProjectedTextCoords);\n  n[5] = texture2D(uTextureFilled, texCoord + vec2(  w, 0.0));\n  n[6] = texture2D(uTextureFilled, texCoord + vec2( -w, h));\n  n[7] = texture2D(uTextureFilled, texCoord + vec2(0.0, h));\n  n[8] = texture2D(uTextureFilled, texCoord + vec2(  w, h));\n  vec4 sobel_horizEdge = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_vertEdge  = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec3 sobel = sqrt((sobel_horizEdge.rgb * sobel_horizEdge.rgb) + (sobel_vertEdge.rgb * sobel_vertEdge.rgb));\n  gl_FragColor = vec4( sobel, max(max(sobel.r, sobel.g), sobel.b) );\n\n\n  return;\n\n  gl_FragColor.r = (texCoord + vec2(0.0, step_v)).r;\n  gl_FragColor.g = (texCoord + vec2(step_u, 0.0)).g;\n  gl_FragColor = centerPixel;\n  gl_FragColor.r = texCoord.x;\n  // gl_FragColor.g = (texCoord + vec2(0.0, step_v)).x;\n  gl_FragColor.b = (texCoord + vec2(step_u, 0.0)).x;\n  gl_FragColor.rg = (texCoord + vec2(0.0, step_v));\n  gl_FragColor.b = 0.;\n  return;\n  vec2 texCoordSlope = fwidth(texCoord);\n  vec4 color2 = texture2D(uTextureFilled, vProjectedTextCoords);\n  // dfdx that vProjectedTextCoords\n  float l = luma (color2.rgb) ;\n    float luminance = dot(color2.rgb,vec3(0.2126, 0.7152, 0.0722));\n\n  \tfloat q0 = fwidth (luminance);\n    if(q0 > 0.01){\n      q0 = 1.0;\n    }\n\tfloat q1 = abs (dFdx (l)); \n\tfloat q2 = abs (dFdy (l));\n\n  \tvec4 ct = vec4 (1.0, 1.0, 1.0, 0.0);\n\tvec4 c0 = mix (ct, vec4 (1.0, 0.0, 0.0, 1.0), \n\t\tsmoothstep (T * (1.0 - M), T * (1.0 + M), q0));\n\ngl_FragColor.r = fwidth(color2.r);//abs(dFdx(color2.b));//texCoord;//color2.rgb;\ngl_FragColor.g = fwidth(color2.g);\ngl_FragColor.b = fwidth(color2.b);\ngl_FragColor.a = 1.;\n// gl_FragColor.a = q0;\n// gl_FragColor = color2;\n//return;\n\n\n  //The back position is the world space position stored in the texture.\n  vec4 color = texture2D(uTextureFilled, texCoord);\n  float lColor = length(color.rgb);\n  float maxColor = length(color.rgb);//max(max(color.r, color.g), color.b);\n  // if(maxColor > 0.1){\n  //   maxColor = 1.0;\n  // }\n\n\n\n  // gl_FragColor = color;//vec4(color.r, color.g, color.b, 1);\n  // return;\n  // float tmpxx  = abs(dFdx(lColor));\n  // float tmpxy  = abs(dFdy(lColor));\n  // float tmpx = max(tmpxx,tmpxy);\n\n  // float tmpyx  = abs(dFdx(color.y));\n  // float tmpyy  = abs(dFdy(color.y));\n  // float tmpy = max(tmpyx,tmpyy);\n\n  // float tmpzx  = abs(dFdx(color.z));\n  // float tmpzy  = abs(dFdy(color.z));\n  // float tmpz = max(tmpzx,tmpzy);\n\n  // float tmpmax = max(max(tmpx, tmpy), tmpz);\n  // if(tmpmax > 0.01){\n  //   tmpmax = 1.0;\n  // }\n  // gl_FragColor.r = tmpx;//smoothstep(tmpx-5., tmpx+5., lColor);\n  // gl_FragColor.g = tmpx;\n  // gl_FragColor.b = tmpx;\n\n  // vec4 color2 = texture2D(uTextureFilled, vec2(texcX, texcY));\n\n  // gl_FragColor.r = color.r - texcX;\n  // gl_FragColor.g = color.g - texcY;\n  // gl_FragColor.b = color.b - color2.b;\n  // gl_FragColor.a = 1.;\n\n  // float threshold = 0.7;\n  // float afwidth = length(vec2(dFdx(maxColor), dFdy(maxColor)));\n  // gl_FragColor.a = afwidth;\n  // float opacity =\n  //   smoothstep(afwidth - threshold, afwidth + threshold, maxColor);\n\n  // gl_FragColor.a = maxColor;\n\n// float aaf = fwidth(maxColor);\n// float alpha = smoothstep(.01, .8, aaf);\n// gl_FragColor = vec4(color.rgb, alpha);\n\n  // float h = 1./uCanvasHeight;\n  // float w = 1./uCanvasWidth;\n  // vec4 n[9];\n  // n[0] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, -h));\n  // n[1] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(0.0, -h));\n  // n[2] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(  w, -h));\n  // n[3] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, 0.0));\n  // n[4] = texture2D(uTextureFilled, vProjectedTextCoords);\n  // n[5] = texture2D(uTextureFilled, texCoord + vec2(  w, 0.0));\n  // n[6] = texture2D(uTextureFilled, texCoord + vec2( -w, h));\n  // n[7] = texture2D(uTextureFilled, texCoord + vec2(0.0, h));\n  // n[8] = texture2D(uTextureFilled, texCoord + vec2(  w, h));\n  // vec4 sobel_horizEdge = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  // vec4 sobel_vertEdge  = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  // vec3 sobel = sqrt((sobel_horizEdge.rgb * sobel_horizEdge.rgb) + (sobel_vertEdge.rgb * sobel_vertEdge.rgb));\n  // gl_FragColor = vec4( n[1].rgb, 1.0 );\n  // gl_FragColor.r = 1.0;\n\n  return;\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\nvarying vec4      vProjectedCoords;\nvarying vec2      vProjectedTextCoords;\nvarying mat4      vProjectionViewMatrix;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uWidth': {
          type: 'f',
          value: 1.,
          typeGLSL: 'float'
        },
        'uTextureFilled': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying vec4 vProjectedCoords;\nvarying mat4 vProjectionViewMatrix;\nvarying vec2 vProjectedTextCoords;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectionViewMatrix = projectionMatrix * viewMatrix;\n  vProjectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  vProjectedTextCoords = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid main(void) {\n\n  // draw border if slice is cropped\n  // float uBorderDashLength = 10.;\n\n  if( uCanvasWidth > 0. &&\n      ((gl_FragCoord.x > uBorderMargin && (gl_FragCoord.x - uBorderMargin) < uBorderWidth) ||\n       (gl_FragCoord.x < (uCanvasWidth - uBorderMargin) && (gl_FragCoord.x + uBorderMargin) > (uCanvasWidth - uBorderWidth) ))){\n    float valueY = mod(gl_FragCoord.y, 2. * uBorderDashLength);\n    if( valueY < uBorderDashLength && gl_FragCoord.y > uBorderMargin && gl_FragCoord.y < (uCanvasHeight - uBorderMargin) ){\n      gl_FragColor = vec4(uBorderColor, 1.);\n      return;\n    }\n  }\n\n  if( uCanvasHeight > 0. &&\n      ((gl_FragCoord.y > uBorderMargin && (gl_FragCoord.y - uBorderMargin) < uBorderWidth) ||\n       (gl_FragCoord.y < (uCanvasHeight - uBorderMargin) && (gl_FragCoord.y + uBorderMargin) > (uCanvasHeight - uBorderWidth) ))){\n    float valueX = mod(gl_FragCoord.x, 2. * uBorderDashLength);\n    if( valueX < uBorderDashLength && gl_FragCoord.x > uBorderMargin && gl_FragCoord.x < (uCanvasWidth - uBorderMargin) ){\n      gl_FragColor = vec4(uBorderColor, 1.);\n      return;\n    }\n  }\n\n  // get texture coordinates of current pixel\n  vec4 dataCoordinates = uWorldToData * vPos;\n  vec3 currentVoxel = vec3(dataCoordinates.x, dataCoordinates.y, dataCoordinates.z);\n  vec4 dataValue = vec4(0., 0., 0., 0.);\n  vec3 gradient = vec3(0., 0., 0.);\n  ' + (0, _shaders2.default)(this, 'currentVoxel', 'dataValue', 'gradient') + '\n\n  // how do we deal wil more than 1 channel?\n  if(uNumberOfChannels == 1){\n    float intensity = dataValue.r;\n\n    // rescale/slope\n    intensity = intensity*uRescaleSlopeIntercept[0] + uRescaleSlopeIntercept[1];\n\n    float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\n    float windowMax = uWindowCenterWidth[0] + uWindowCenterWidth[1] * 0.5;\n    intensity = ( intensity - windowMin ) / uWindowCenterWidth[1];\n\n    dataValue.r = dataValue.g = dataValue.b = intensity;\n    dataValue.a = 1.0;\n  }\n\n  // Apply LUT table...\n  //\n  if(uLut == 1){\n    // should opacity be grabbed there?\n    dataValue = texture2D( uTextureLUT, vec2( dataValue.r , 1.0) );\n  }\n\n  if(uInvert == 1){\n    dataValue = vec4(1.) - dataValue;\n    // how do we deal with that and opacity?\n    dataValue.a = 1.;\n  }\n\n  gl_FragColor = dataValue;\n\n    // if on edge, draw line\n  // float xPos = gl_FragCoord.x/512.;\n  // float yPos = gl_FragCoord.y/512.;\n  // if( xPos < 0.05 || xPos > .95 || yPos < 0.05 || yPos > .95){\n  //   gl_FragColor = vec4(xPos, yPos, 0., 1.);//dataValue;\n  //   //return;\n  // }\n\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{"./interpolation/shaders.interpolation":146}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',

    /**
     * Shaders data uniforms
     */
    value: function uniforms() {
      return {
        'uTextureSize': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureContainer': {
          type: 'tv',
          value: [],
          typeGLSL: 'sampler2D',
          length: 7
        },
        'uDataDimensions': {
          type: 'iv',
          value: [0, 0, 0],
          typeGLSL: 'ivec3'
        },
        'uWorldToData': {
          type: 'm4',
          value: new THREE.Matrix4(),
          typeGLSL: 'mat4'
        },
        'uWindowCenterWidth': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uRescaleSlopeIntercept': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uNumberOfChannels': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uBitsAllocated': {
          type: 'i',
          value: 8,
          typeGLSL: 'int'
        },
        'uInvert': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uLut': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureLUT': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uPixelType': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uPackedPerPixel': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uInterpolation': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uBorderColor': {
          type: 'v3',
          value: [1.0, 0.0, 0.5],
          typeGLSL: 'vec3'
        },
        'uBorderWidth': {
          type: 'f',
          value: 2.,
          typeGLSL: 'float'
        },
        'uBorderMargin': {
          type: 'f',
          value: 2.,
          typeGLSL: 'float'
        },
        'uBorderDashLength': {
          type: 'f',
          value: 10.,
          typeGLSL: 'float'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shadersContour = require('./shaders.contour.uniform');

var _shadersContour2 = _interopRequireDefault(_shadersContour);

var _shadersContour3 = require('./shaders.contour.fragment');

var _shadersContour4 = _interopRequireDefault(_shadersContour3);

var _shadersContour5 = require('./shaders.contour.vertex');

var _shadersContour6 = _interopRequireDefault(_shadersContour5);

var _shadersData = require('./shaders.data.uniform');

var _shadersData2 = _interopRequireDefault(_shadersData);

var _shadersData3 = require('./shaders.data.fragment');

var _shadersData4 = _interopRequireDefault(_shadersData3);

var _shadersData5 = require('./shaders.data.vertex');

var _shadersData6 = _interopRequireDefault(_shadersData5);

var _shadersVr = require('./shaders.vr.uniform');

var _shadersVr2 = _interopRequireDefault(_shadersVr);

var _shadersVr3 = require('./shaders.vr.fragment');

var _shadersVr4 = _interopRequireDefault(_shadersVr3);

var _shadersVr5 = require('./shaders.vr.vertex');

var _shadersVr6 = _interopRequireDefault(_shadersVr5);

var _shadersLayer = require('./shaders.layer.uniform');

var _shadersLayer2 = _interopRequireDefault(_shadersLayer);

var _shadersLayer3 = require('./shaders.layer.fragment');

var _shadersLayer4 = _interopRequireDefault(_shadersLayer3);

var _shadersLayer5 = require('./shaders.layer.vertex');

var _shadersLayer6 = _interopRequireDefault(_shadersLayer5);

var _shadersLocalizer = require('./shaders.localizer.uniform');

var _shadersLocalizer2 = _interopRequireDefault(_shadersLocalizer);

var _shadersLocalizer3 = require('./shaders.localizer.fragment');

var _shadersLocalizer4 = _interopRequireDefault(_shadersLocalizer3);

var _shadersLocalizer5 = require('./shaders.localizer.vertex');

var _shadersLocalizer6 = _interopRequireDefault(_shadersLocalizer5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module shaders
 */

exports.default = {
  ContourUniform: _shadersContour2.default,
  ContourFragment: _shadersContour4.default,
  ContourVertex: _shadersContour6.default,

  DataUniform: _shadersData2.default,
  DataFragment: _shadersData4.default,
  DataVertex: _shadersData6.default,

  VRUniform: _shadersVr2.default,
  VRFragment: _shadersVr4.default,
  VRVertex: _shadersVr6.default,

  LayerUniform: _shadersLayer2.default,
  LayerFragment: _shadersLayer4.default,
  LayerVertex: _shadersLayer6.default,

  LocalizerUniform: _shadersLocalizer2.default,
  LocalizerFragment: _shadersLocalizer4.default,
  LocalizerVertex: _shadersLocalizer6.default
};

},{"./shaders.contour.fragment":149,"./shaders.contour.uniform":150,"./shaders.contour.vertex":151,"./shaders.data.fragment":152,"./shaders.data.uniform":153,"./shaders.data.vertex":154,"./shaders.layer.fragment":156,"./shaders.layer.uniform":157,"./shaders.layer.vertex":158,"./shaders.localizer.fragment":159,"./shaders.localizer.uniform":160,"./shaders.localizer.vertex":161,"./shaders.vr.fragment":162,"./shaders.vr.uniform":163,"./shaders.vr.vertex":164}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid main(void) {\n\n  vec2 texc = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n\n  // just silence warning for\n  vec4 dummy = vPos;\n\n  //The back position is the world space position stored in the texture.\n  vec4 baseColor0 = texture2D(uTextureBackTest0, texc);\n  vec4 baseColor1 = texture2D(uTextureBackTest1, texc);\n\n  if( uTrackMouse == 1 ){\n\n      if( vProjectedCoords.x < uMouse.x ){\n\n        gl_FragColor = baseColor0;\n\n      }\n      else{\n\n        gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );\n\n      }\n\n  }\n  else{\n\n    if( uType1 == 0 ){\n\n      //merge an image into\n      gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );\n\n    }\n    else{\n\n      float opacity = baseColor1.a;\n      gl_FragColor = mix( baseColor0, baseColor1, opacity * uOpacity1 );\n\n    }\n\n  }\n\n  return;\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\nvarying vec4      vProjectedCoords;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uTextureBackTest0': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uTextureBackTest1': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uOpacity0': {
          type: 'f',
          value: 1.0,
          typeGLSL: 'float'
        },
        'uOpacity1': {
          type: 'f',
          value: 1.0,
          typeGLSL: 'float'
        },
        'uType0': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uType1': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uTrackMouse': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uMouse': {
          type: 'v2',
          value: new THREE.Vector2(),
          typeGLSL: 'vec2'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying vec4 vProjectedCoords;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Localizer fragment shader
 */
var _class = function () {

  /**
   * 
   */
  function _class(uniforms) {
    _classCallCheck(this, _class);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  /**
   * 
   */


  _createClass(_class, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }

    /**
     * 
     */

  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }

    /**
     * 
     */

  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid intersectionProjection(\n  in vec4 plane,\n  in vec4 slice,\n  out vec3 intersectionProjection){\n\n      vec3 intersectionDirection = normalize(cross(plane.xyz, slice.xyz));\n      vec3 intersectionPoint = \n        cross(intersectionDirection,slice.xyz) * plane.w +\n        cross(plane.xyz, intersectionDirection) * slice.w;\n\n      intersectionProjection =\n        intersectionPoint.xyz +\n        (dot(vPos.xyz - intersectionPoint, intersectionDirection)\n          * intersectionDirection);\n\n}\n\nvoid main(void) {\n      vec4 c1 = vec4(0., 0., 0., 0.);\n      vec4 c2 = vec4(0., 0., 0., 0.);\n      vec4 c3 = vec4(0., 0., 0., 0.);\n\n      // localizer #1\n      // must be normalized!\n      if(length(uPlane1.xyz) > 0.5) {\n        vec3 projection1 = vec3(1.);\n        intersectionProjection(\n          uPlane1,\n          uSlice,\n          projection1\n        );\n\n        vec4 projInter1 = (vProjectionViewMatrix * vec4(projection1, 1.));\n        vec3 ndc1 = projInter1.xyz / projInter1.w;\n        vec2 screenSpace1 = (ndc1.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d1 = distance(gl_FragCoord.xy, screenSpace1.xy);\n        c1 = vec4(uPlaneColor1, 1. - smoothstep(.5, .7, d1));\n      }\n\n      // localizer #2\n      if(length(uPlane2.xyz) > 0.5) {\n        vec3 projection2 = vec3(1.);\n        intersectionProjection(\n          uPlane2,\n          uSlice,\n          projection2\n        );\n\n        vec4 projInter2 = (vProjectionViewMatrix * vec4(projection2, 1.));\n        vec3 ndc2 = projInter2.xyz / projInter2.w;\n        vec2 screenSpace2 = (ndc2.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d2 = distance(gl_FragCoord.xy, screenSpace2.xy);\n        c2 = vec4(uPlaneColor2, 1. - smoothstep(.5, .7, d2));\n      }\n\n      // localizer #3\n      if(length(uPlane3.xyz) > 0.5) {\n        vec3 projection3 = vec3(1.);\n        intersectionProjection(\n          uPlane3,\n          uSlice,\n          projection3\n        );\n\n        vec4 projInter3 = (vProjectionViewMatrix * vec4(projection3, 1.));\n        vec3 ndc3 = projInter3.xyz / projInter3.w;\n        vec2 screenSpace3 = (ndc3.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d3 = distance(gl_FragCoord.xy, screenSpace3.xy);\n        c3 = vec4(uPlaneColor3, 1. - smoothstep(.5, .7, d3));\n      }\n\n      vec3 colorMix = c1.xyz*c1.w + c2.xyz*c2.w + c3.xyz*c3.w;\n      gl_FragColor = vec4(colorMix, max(max(c1.w, c2.w),c3.w));\n}\n   ';
    }

    /**
     * 
     */

  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4 vPos;\nvarying mat4 vProjectionViewMatrix;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"./interpolation/shaders.interpolation":146}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/localizer/uniforms
 */

var _class = function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  _createClass(_class, null, [{
    key: 'uniforms',

    /**
     * Shaders data uniforms
     */
    value: function uniforms() {
      return {
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uSlice': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlane1': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor1': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        },
        'uPlane2': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor2': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        },
        'uPlane3': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor3': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        }

      };
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 
 */
var _class = function () {
    /**
     * 
     */
    function _class() {
        _classCallCheck(this, _class);
    }

    /**
     * 
     */


    _createClass(_class, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying mat4 vProjectionViewMatrix;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectionViewMatrix = projectionMatrix * viewMatrix;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return _class;
}();

exports.default = _class;

},{}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersHelpers = require('./helpers/shaders.helpers.intersectBox');

var _shadersHelpers2 = _interopRequireDefault(_shadersHelpers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid getIntensity(in vec3 dataCoordinates, out float intensity, out vec3 gradient){\n\n  vec4 dataValue = vec4(0., 0., 0., 0.);\n  ' + (0, _shaders2.default)(this, 'dataCoordinates', 'dataValue', 'gradient') + '\n\n  intensity = dataValue.r;\n\n  // rescale/slope\n  intensity = intensity*uRescaleSlopeIntercept[0] + uRescaleSlopeIntercept[1];\n  // window level\n  float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\n  intensity = ( intensity - windowMin ) / uWindowCenterWidth[1];\n}\n\nvoid main(void) {\n  const int maxSteps = 1024;\n\n  // the ray\n  vec3 rayOrigin = cameraPosition;\n  vec3 rayDirection = normalize(vPos.xyz - rayOrigin);\n\n  // the Axe-Aligned B-Box\n  vec3 AABBMin = vec3(uWorldBBox[0], uWorldBBox[2], uWorldBBox[4]);\n  vec3 AABBMax = vec3(uWorldBBox[1], uWorldBBox[3], uWorldBBox[5]);\n\n  // Intersection ray/bbox\n  float tNear, tFar;\n  bool intersect = false;\n  ' + _shadersHelpers2.default.api(this, 'rayOrigin', 'rayDirection', 'AABBMin', 'AABBMax', 'tNear', 'tFar', 'intersect') + '\n  if (tNear < 0.0) tNear = 0.0;\n\n  // init the ray marching\n  float tCurrent = tNear;\n  float tStep = (tFar - tNear) / float(uSteps);\n  vec4 accumulatedColor = vec4(0.0);\n  float accumulatedAlpha = 0.0;\n\n  for(int rayStep = 0; rayStep < maxSteps; rayStep++){\n    vec3 currentPosition = rayOrigin + rayDirection * tCurrent;\n    // some non-linear FUN\n    // some occlusion issue to be fixed\n    vec3 transformedPosition = currentPosition; //transformPoint(currentPosition, uAmplitude, uFrequence);\n    // world to data coordinates\n    // rounding trick\n    // first center of first voxel in data space is CENTERED on (0,0,0)\n    vec4 dataCoordinatesRaw = uWorldToData * vec4(transformedPosition, 1.0);\n    vec3 currentVoxel = vec3(dataCoordinatesRaw.x, dataCoordinatesRaw.y, dataCoordinatesRaw.z);\n    float intensity = 0.0;\n    vec3 gradient = vec3(0., 0., 0.);\n    getIntensity(currentVoxel, intensity, gradient);\n\n    vec4 colorSample;\n    float alphaSample;\n    if(uLut == 1){\n      vec4 colorFromLUT = texture2D( uTextureLUT, vec2( intensity, 1.0) );\n      // 256 colors\n      colorSample = colorFromLUT;\n      alphaSample = colorFromLUT.a;\n    }\n    else{\n      alphaSample = intensity;\n      colorSample.r = colorSample.g = colorSample.b = intensity * alphaSample;\n    }\n\n    alphaSample = alphaSample * uAlphaCorrection;\n    alphaSample *= (1.0 - accumulatedAlpha);\n\n    accumulatedColor += alphaSample * colorSample;\n    accumulatedAlpha += alphaSample;\n\n    tCurrent += tStep;\n\n    if(tCurrent > tFar || accumulatedAlpha >= 1.0 ) break;\n  }\n\n  gl_FragColor = vec4(accumulatedColor.xyz, accumulatedAlpha);\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{"./helpers/shaders.helpers.intersectBox":142,"./interpolation/shaders.interpolation":146}],163:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uTextureSize': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureContainer': {
          type: 'tv',
          value: [],
          typeGLSL: 'sampler2D',
          length: 7
        },
        'uDataDimensions': {
          type: 'iv',
          value: [0, 0, 0],
          typeGLSL: 'ivec3'
        },
        'uWorldToData': {
          type: 'm4',
          value: new THREE.Matrix4(),
          typeGLSL: 'mat4'
        },
        'uWindowCenterWidth': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uRescaleSlopeIntercept': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uNumberOfChannels': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uBitsAllocated': {
          type: 'i',
          value: 8,
          typeGLSL: 'int'
        },
        'uInvert': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uLut': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureLUT': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uPixelType': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uPackedPerPixel': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uInterpolation': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uWorldBBox': {
          type: 'fv1',
          value: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'float',
          length: 6
        },
        'uSteps': {
          type: 'i',
          value: 256,
          typeGLSL: 'int'
        },
        'uAlphaCorrection': {
          type: 'f',
          value: 0.5,
          typeGLSL: 'float'
        },
        'uFrequence': {
          type: 'f',
          value: 0.0,
          typeGLSL: 'float'
        },
        'uAmplitude': {
          type: 'f',
          value: 0.0,
          typeGLSL: 'float'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsAnnotation = function (_WidgetsBase) {
    _inherits(WidgetsAnnotation, _WidgetsBase);

    function WidgetsAnnotation(targetMesh, controls, camera, container) {
        _classCallCheck(this, WidgetsAnnotation);

        var _this = _possibleConstructorReturn(this, (WidgetsAnnotation.__proto__ || Object.getPrototypeOf(WidgetsAnnotation)).call(this));

        _this._targetMesh = targetMesh;
        _this._controls = controls;
        _this._camera = camera;
        _this._container = container;

        _this._active = true;

        _this._worldPosition = new THREE.Vector3();
        if (_this._targetMesh !== null) {
            _this._worldPosition = _this._targetMesh.position;
        }

        // mesh stuff
        _this._material = null;
        _this._geometry = null;
        _this._mesh = null;

        // dom stuff
        _this._line = null;
        _this._label = null;
        _this._cone = null;
        _this._labeltext = null;

        //booleans
        _this._alreadycreated = null; //bool that turns true when the user enter the name of the label
        _this._movinglabel = null; //bool that turns true when the label is moving with the mouse
        _this._labelmoved = false; //bool that turns true once the label is moved by the user (at least once)

        _this._labelhovered = false;
        _this._domHovered = false;
        _this._hovered = true;

        //var
        _this._labelpositionx = null; //position of label (top left corner)
        _this._labelpositiony = null; //position of label (top left corner)
        _this._differencemousecenterlabelx = 0; //difference between mouse position in the label and position of label (top left corner)
        _this._differencemousecenterlabely = 0; //difference between mouse position in the label and position of label (top left corner)

        // add handles
        _this._handles = [];

        self = _this;

        // first handle
        var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        firstHandle.worldPosition = _this._worldPosition;
        firstHandle.hovered = true;
        _this.add(firstHandle);

        _this._handles.push(firstHandle);

        var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        secondHandle.worldPosition = _this._worldPosition;
        secondHandle.hovered = true;
        // active and tracking might be redundant
        secondHandle.active = true;
        secondHandle.tracking = true;
        _this.add(secondHandle);

        _this._handles.push(secondHandle);

        // Create annotation

        _this.create();

        _this.onMove = _this.onMove.bind(_this);
        _this.onHoverlabel = _this.onHoverlabel.bind(_this);
        _this.notonHoverlabel = _this.notonHoverlabel.bind(_this);
        _this.changelabeltext = _this.changelabeltext.bind(_this);
        _this.movelabel = _this.movelabel.bind(_this);
        _this.notmovelabel = _this.notmovelabel.bind(_this);

        _this.addEventListeners();

        return _this;
    }

    _createClass(WidgetsAnnotation, [{
        key: 'addEventListeners',
        value: function addEventListeners() {
            this._label.addEventListener('mouseenter', this.onHoverlabel);
            this._label.addEventListener('mouseleave', this.notonHoverlabel);
            this._label.addEventListener('dblclick', this.changelabeltext);
            this._label.addEventListener('mousedown', this.movelabel);
            this._container.addEventListener('mouseup', this.notmovelabel);

            this._container.addEventListener('mousewheel', this.onMove);
            this._container.addEventListener('DOMMouseScroll', this.onMove);
        }
    }, {
        key: 'movelabel',
        value: function movelabel() {
            //function called when mousedown
            if (this._labelhovered = true) {
                //if label hobered we will move the label
                this._movinglabel = true;
                this._labelmoved = true;
                var mousey = -(-event.clientY + this._container.offsetHeight);
                var mousex = event.clientX;
                //calculate differencemousecenterlabel (difference between ref position of the label (top-left corner) and mouse position in the label)
                this._differencemousecenterlabelx = Math.abs(Math.abs(mousex) - Math.abs(this._labelpositionx));
                this._differencemousecenterlabely = Math.abs(Math.abs(mousey) - Math.abs(this._labelpositiony));
            }
        }
    }, {
        key: 'notmovelabel',
        value: function notmovelabel() {
            //this function is called when mouseup
            this._movinglabel = false;
            this._handles[0]._controls.enabled = true; //move the camera when mousedown and mousedown again
            this._handles[1]._controls.enabled = true;
            this._differencemousecenterlabelx = 0; //restart the value of differencemousecenterlabel. Necessary?
            this._differencemousecenterlabely = 0;
        }
    }, {
        key: 'onHoverlabel',
        value: function onHoverlabel() {
            //this function is called when mouse enters the label with "mouseenter" event
            this._labelhovered = true;
        }
    }, {
        key: 'notonHoverlabel',
        value: function notonHoverlabel() {
            //this function is called when mouse leaves the label with "mouseleave" event
            this._labelhovered = false;
        }
    }, {
        key: 'onMove',
        value: function onMove(evt) {

            if (this._movinglabel == true) {
                this._handles[0]._controls.enabled = false;
                this._handles[1]._controls.enabled = false;
            }

            this._dragged = true;

            this._handles[0].onMove(evt);
            this._handles[1].onMove(evt);

            this._hovered = this._handles[0].hovered || this._handles[1].hovered || this._labelhovered;

            this.update();
        }
    }, {
        key: 'onStart',
        value: function onStart(evt) {

            this._dragged = false;

            this._handles[0].onStart(evt);
            this._handles[1].onStart(evt);

            this._active = this._handles[0].active || this._handles[1].active;

            this.update();
        }
    }, {
        key: 'setlabeltext',
        value: function setlabeltext() {
            this._labeltext = prompt("Please enter the name of the label", ""); //this function is called when the user creates a new arrow
            if (typeof this._labeltext == 'string') {
                //avoid error
                if (this._labeltext.length > 0) {
                    this._label.innerHTML = this._labeltext;
                    this._label.style.display = ''; //in css an empty string is used to revert display=none. Show the label once we know the content
                    this._dashline.style.display = ''; //in css an empty string is used to revert display=none. Show the label once we know the content
                } else {
                    this._label.innerHTML = this._labeltext;
                    this._label.style.display = 'none'; //hide the label
                    this._dashline.style.display = 'none'; //hide the label
                }
            }
        }
    }, {
        key: 'changelabeltext',
        value: function changelabeltext() {
            //this function is called when the user does double click in the label
            this._labeltext = prompt("Please enter new name of the label", this._label.innerHTML);
            if (typeof this._labeltext == 'string') {
                //avoid error
                if (this._labeltext.length > 0) {
                    this._label.innerHTML = this._labeltext;
                    this._label.style.display = ''; //in css an empty string is used to revert display=none. Show the label
                    this._dashline.style.display = ''; //in css an empty string is used to revert display=none. Show the label
                } else {
                    // if the length is 0 the user pressed Cancel
                    this._label.innerHTML = this._labeltext;
                    this._label.style.display = 'none'; //hide the label
                    this._dashline.style.display = 'none'; //hide the label
                }
            }
        }
    }, {
        key: 'onEnd',
        value: function onEnd(evt) {
            // First Handle
            this._handles[0].onEnd(evt);

            // Second Handle
            if (this._dragged || !this._handles[1].tracking) {
                this._handles[1].tracking = false;
                this._handles[1].onEnd(evt);
            } else {
                this._handles[1].tracking = false;
            }

            if (self._alreadycreated != true) {
                this.setlabeltext();
                self._alreadycreated = true;
            }

            // State of annotation widget
            this._active = this._handles[0].active || this._handles[1].active;
            this.update();
        }
    }, {
        key: 'create',
        value: function create() {
            this.createMesh();
            this.createDOM();
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateColor();

            // mesh stuff
            this.updateMeshColor();
            this.updateMeshPosition();

            // DOM stuff
            this.updateDOMPosition();
            this.updateDOMColor();
        }
    }, {
        key: 'createMesh',
        value: function createMesh() {
            // geometry
            this._geometry = new THREE.Geometry();
            this._geometry.vertices.push(this._handles[0].worldPosition);
            this._geometry.vertices.push(this._handles[1].worldPosition);

            // material
            this._material = new THREE.LineBasicMaterial();
            this.updateMeshColor();

            // mesh
            this._meshline = new THREE.Line(this._geometry, this._material);
            this._meshline.visible = true;

            // add it!
            this.add(this._meshline);

            //create cone and add it
            this._conegeometry = new THREE.CylinderGeometry(0, 2, 10);
            this._conegeometry.translate(0, -5, 0);
            this._conegeometry.rotateX(-Math.PI / 2);
            this._cone = new THREE.Mesh(this._conegeometry, this._material);
            this._cone.visible = true;
            this.add(this._cone);
        }
    }, {
        key: 'updateMeshColor',
        value: function updateMeshColor() {
            if (this._material) {
                this._material.color.set(this._color);
            }
        }
    }, {
        key: 'updateMeshPosition',
        value: function updateMeshPosition() {
            if (this._geometry) {
                this._geometry.verticesNeedUpdate = true;
            }
        }
    }, {
        key: 'createDOM',
        value: function createDOM() {
            // add line!
            this._line = document.createElement('div');
            this._line.setAttribute('class', 'widgets handle line');
            this._line.style.position = 'absolute';
            this._line.style.transformOrigin = '0 100%';
            this._line.style.marginTop = '-1px';
            this._line.style.height = '2px'; //2
            this._line.style.width = '3px'; //3
            this._container.appendChild(this._line);

            // add dash line
            this._dashline = document.createElement('div');
            this._dashline.setAttribute('class', 'widgets handle dashline');
            this._dashline.style.position = 'absolute';
            this._dashline.style.border = 'none';
            this._dashline.style.borderTop = '2.5px dashed #F9F9F9';
            this._dashline.style.transformOrigin = '0 100%';
            this._dashline.style.height = '1px';
            this._dashline.style.width = '50%';
            this._dashline.style.display = 'none';
            this._container.appendChild(this._dashline);

            // add label!
            this._label = document.createElement('div');
            this._label.setAttribute('id', this.uuid);
            this._label.setAttribute('class', 'widgets handle label');
            this._label.style.border = '2px solid #F9F9F9';
            this._label.style.backgroundColor = '#F9F9F9';
            // this._label.style.opacity = '0.5';
            this._label.style.color = '#353535';
            this._label.style.padding = '4px';
            this._label.style.position = 'absolute';
            this._label.style.transformOrigin = '0 100%';
            this._label.innerHTML = 'Hello, world!';
            this._label.style.display = 'none';
            this._container.appendChild(this._label);

            this.updateDOMColor();
        }
    }, {
        key: 'updateDOMPosition',
        value: function updateDOMPosition() {

            console.log('function updateDOMPosition');
            // update annotation lines and text!
            var x1 = this._handles[0].screenPosition.x;
            var y1 = this._handles[0].screenPosition.y;
            var x2 = this._handles[1].screenPosition.x;
            var y2 = this._handles[1].screenPosition.y;

            var x0 = x1 + (x2 - x1) / 2;
            var y0 = y1 + (y2 - y1) / 2;

            var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

            var posY = y1 - this._container.offsetHeight;

            // update line
            var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            this._line.style.transform = transform;
            this._line.style.width = length + 'px';

            // update label position
            var mousex = 0;
            var mousey = 0;

            var posY0 = void 0;

            posY0 = y0 - this._container.offsetHeight - this._label.offsetHeight / 2;
            x0 -= this._label.offsetWidth / 2;

            var x;
            var y;

            if (this._labelmoved == false) {
                //if the user hasnt moved the label, the position is defined by the position of the arrow
                var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
                this._label.style.transform = transform2;
                this._labelpositionx = Math.round(x0);
                this._labelpositiony = Math.round(posY0);
            }

            if (this._movinglabel) {
                //if the user has moved the label, the position is defined by the mouse
                mousex = event.clientX;
                mousey = -(-event.clientY + this._container.offsetHeight);
                this._label.style.transform = 'translate3D(' + (mousex - this._differencemousecenterlabelx) + 'px,' + (mousey - this._differencemousecenterlabely) + 'px, 0)';
                //we use differencemousecenterlabel to check the difference between the position of the mouse in the label and the reference position of the label (top-left corner)
                this._labelpositionx = mousex - this._differencemousecenterlabelx;
                this._labelpositiony = mousey - this._differencemousecenterlabely;
            }

            //update cone
            var w0 = this._handles[0].worldPosition;
            var w1 = this._handles[1].worldPosition;

            //position and rotation of cone
            this._cone.position.set(w1.x, w1.y, w1.z);
            this._cone.lookAt(w0);

            // update dash line

            //calculate the place in the label: center of the label
            x1 = this._handles[0].screenPosition.x;
            y1 = this._handles[0].screenPosition.y;
            x2 = this._labelpositionx;
            y2 = this._labelpositiony + this._container.offsetHeight; //revert the operation in 'mousey' to get the previous eventY

            //get the size of the label so we can place the dashed line in the center of it
            var labelheight = this._label.offsetHeight;
            var labelwidth = this._label.offsetWidth;

            var centerlabelx = 0;
            var centerlabely = 0;

            if (isFinite(labelwidth) && isFinite(labelheight)) {
                //if the extraction has been succesfull, we calculate the center of the label with total size
                centerlabelx = labelwidth / 2;
                centerlabely = labelheight / 2;
            }

            x2 += centerlabelx;
            y2 += centerlabely;

            //calculate the place in the arrow: closest part of the line to place the dashed line
            var x1_tail = this._handles[0].screenPosition.x; //first position: tail of arrow
            var y1_tail = this._handles[0].screenPosition.y;
            var x1_body = (this._handles[0].screenPosition.x + this._handles[1].screenPosition.x) / 2; //second position: center of arrow
            var y1_body = (this._handles[0].screenPosition.y + this._handles[1].screenPosition.y) / 2;
            var x1_nose = this._handles[1].screenPosition.x; //third position: peak of arrow
            var y1_nose = this._handles[1].screenPosition.y;

            //calculate all the lengths to the label, so we can choose the min
            var lengthtaillabel = Math.sqrt((x1_tail - x2) * (x1_tail - x2) + (y1_tail - y2) * (y1_tail - y2));
            var lengthbodylabel = Math.sqrt((x1_body - x2) * (x1_body - x2) + (y1_body - y2) * (y1_body - y2));
            var lengthnoselabel = Math.sqrt((x1_nose - x2) * (x1_nose - x2) + (y1_nose - y2) * (y1_nose - y2));

            var lengths = [lengthtaillabel, lengthbodylabel, lengthnoselabel];
            var minlength = Math.min(lengthtaillabel, lengthbodylabel, lengthnoselabel);
            var minlengthindex = lengths.indexOf(minlength);

            if (minlengthindex == 0) {
                x1 = x1_tail;
                y1 = y1_tail;
            }
            if (minlengthindex == 1) {
                x1 = x1_body;
                y1 = y1_body;
            }
            if (minlengthindex == 2) {
                x1 = x1_nose;
                y1 = y1_nose;
            }

            // Once we found the closest point to the label, we create the dashed line from that point
            var lengthdashline = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angledashline = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

            var posYdashline = y1 - this._container.offsetHeight;

            // update dashed line
            var transformdashline = 'translate3D(' + x1 + 'px,' + posYdashline + 'px, 0)';
            transformdashline += ' rotate(' + angledashline + 'deg)';

            this._dashline.style.transform = transformdashline;
            this._dashline.style.width = lengthdashline + 'px';
        }
    }, {
        key: 'updateDOMColor',
        value: function updateDOMColor() {
            this._line.style.backgroundColor = '' + this._color;
            this._dashline.style.borderTop = '2.5px dashed ' + ('' + this._color);
            this._label.style.borderColor = '' + this._color;
        }
    }, {
        key: 'hideDOM',
        value: function hideDOM() {
            this._line.style.display = 'none';
            this._dashline.style.display = 'none';
            this._label.style.display = 'none';
        }
    }, {
        key: 'showDOM',
        value: function showDOM() {
            this._line.style.display = '';
            this._dashline.style.display = '';
            this._label.style.display = '';
        }
    }, {
        key: 'hideMesh',
        value: function hideMesh() {
            this.visible = false;
        }
    }, {
        key: 'showMesh',
        value: function showMesh() {
            this.visible = true;
        }
    }, {
        key: 'show',
        value: function show() {
            this.showDOM();
            this.showMesh();
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.hideDOM();
            this.hideMesh();
        }
    }, {
        key: 'worldPosition',
        get: function get() {
            return this._worldPosition;
        },
        set: function set(worldPosition) {
            this._worldPosition = worldPosition;
            this._handles[0].worldPosition = this._worldPosition;
            this._handles[1].worldPosition = this._worldPosition;

            this.update();
        }
    }]);

    return WidgetsAnnotation;
}(_widgets2.default);

exports.default = WidgetsAnnotation;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],166:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 */
var WidgetsBase = function (_THREE$Object3D) {
  _inherits(WidgetsBase, _THREE$Object3D);

  function WidgetsBase(container) {
    _classCallCheck(this, WidgetsBase);

    // is widget enabled?
    var _this = _possibleConstructorReturn(this, (WidgetsBase.__proto__ || Object.getPrototypeOf(WidgetsBase)).call(this));
    // init THREE Object 3D


    _this._enabled = true;

    // STATE, ENUM might be better
    _this._selected = false;
    _this._hovered = false;
    _this._active = false;
    // thos._state = 'SELECTED';

    _this._colors = {
      default: '#00B0FF',
      active: '#FFEB3B',
      hover: '#F50057',
      select: '#76FF03'
    };
    _this._color = _this._colors.default;

    _this._dragged = false;
    // can not call it visible because it conflicts with THREE.Object3D
    _this._displayed = true;

    _this._container = container;
    return _this;
  }

  _createClass(WidgetsBase, [{
    key: 'initOffsets',
    value: function initOffsets() {
      var box = this._container.getBoundingClientRect();

      var body = document.body;
      var docEl = document.documentElement;

      var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
      var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;

      var clientTop = docEl.clientTop || body.clientTop || 0;
      var clientLeft = docEl.clientLeft || body.clientLeft || 0;

      var top = box.top + scrollTop - clientTop;
      var left = box.left + scrollLeft - clientLeft;

      this._offsets = {
        top: Math.round(top),
        left: Math.round(left)
      };
    }
  }, {
    key: 'offsetChanged',
    value: function offsetChanged() {
      this.initOffsets();
      this.update();
    }
  }, {
    key: 'getMouseOffsets',
    value: function getMouseOffsets(event, container) {
      return {
        x: (event.clientX - this._offsets.left) / container.offsetWidth * 2 - 1,
        y: -((event.clientY - this._offsets.top) / container.offsetHeight) * 2 + 1,
        screenX: event.clientX - this._offsets.left,
        screenY: event.clientY - this._offsets.top
      };
    }
  }, {
    key: 'update',
    value: function update() {
      // to be overloaded
      window.console.log('update() should be overloaded!');
    }
  }, {
    key: 'free',
    value: function free() {
      this._container = null;
    }
  }, {
    key: 'updateColor',
    value: function updateColor() {
      if (this._active) {
        this._color = this._colors.active;
      } else if (this._hovered) {
        this._color = this._colors.hover;
      } else if (this._selected) {
        this._color = this._colors.select;
      } else {
        this._color = this._colors.default;
      }
    }
  }, {
    key: 'enabled',
    get: function get() {
      return this._enabled;
    },
    set: function set(enabled) {
      this._enabled = enabled;
      this.update();
    }
  }, {
    key: 'selected',
    get: function get() {
      return this._selected;
    },
    set: function set(selected) {
      this._selected = selected;
      this.update();
    }
  }, {
    key: 'hovered',
    get: function get() {
      return this._hovered;
    },
    set: function set(hovered) {
      this._hovered = hovered;
      this.update();
    }
  }, {
    key: 'dragged',
    get: function get() {
      return this._dragged;
    },
    set: function set(dragged) {
      this._dragged = dragged;
      this.update();
    }
  }, {
    key: 'displayed',
    get: function get() {
      return this._displayed;
    },
    set: function set(displayed) {
      this._displayed = displayed;
      this.update();
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    },
    set: function set(active) {
      this._active = active;
      this.update();
    }
  }, {
    key: 'color',
    get: function get() {
      return this._color;
    },
    set: function set(color) {
      this._color = color;
      this.update();
    }
  }]);

  return WidgetsBase;
}(THREE.Object3D);

exports.default = WidgetsBase;

},{}],167:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
        value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsBiRuler = function (_WidgetsBase) {
        _inherits(WidgetsBiRuler, _WidgetsBase);

        function WidgetsBiRuler(targetMesh, controls, camera, container) {
                _classCallCheck(this, WidgetsBiRuler);

                var _this = _possibleConstructorReturn(this, (WidgetsBiRuler.__proto__ || Object.getPrototypeOf(WidgetsBiRuler)).call(this));

                _this._targetMesh = targetMesh;
                _this._controls = controls;
                _this._camera = camera;
                _this._container = container;

                _this._active = true;
                _this._initOrtho = false;

                _this._worldPosition = new THREE.Vector3();
                if (_this._targetMesh !== null) {
                        _this._worldPosition = _this._targetMesh.position;
                }

                // mesh stuff
                _this._material = null;
                _this._geometry = null;
                _this._mesh = null;

                // dom stuff
                _this._line = null;
                _this._distance = null;

                // add handles
                _this._handles = [];

                // first handle
                var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
                firstHandle.worldPosition = _this._worldPosition;
                firstHandle.hovered = true;
                _this.add(firstHandle);

                _this._handles.push(firstHandle);

                var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
                secondHandle.worldPosition = _this._worldPosition;
                secondHandle.hovered = true;
                // active and tracking might be redundant
                secondHandle.active = true;
                secondHandle.tracking = true;
                _this.add(secondHandle);

                _this._handles.push(secondHandle);

                // third handle
                var thirdHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
                thirdHandle.worldPosition = _this._worldPosition;
                thirdHandle.hovered = true;
                _this.add(thirdHandle);

                _this._handles.push(thirdHandle);

                // fourth handle
                var fourthHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
                fourthHandle.worldPosition = _this._worldPosition;
                fourthHandle.hovered = true;
                _this.add(fourthHandle);

                _this._handles.push(fourthHandle);

                // Create ruler
                _this.create();

                _this.onMove = _this.onMove.bind(_this);
                _this.addEventListeners();

                _this._orientation = null;
                _this._slice = null;
                return _this;
        }

        _createClass(WidgetsBiRuler, [{
                key: 'addEventListeners',
                value: function addEventListeners() {
                        this._container.addEventListener('mousewheel', this.onMove);
                        this._container.addEventListener('DOMMouseScroll', this.onMove);
                }
        }, {
                key: 'onMove',
                value: function onMove(evt) {
                        this._dragged = true;

                        this._handles[0].onMove(evt);
                        this._handles[1].onMove(evt);
                        this._handles[2].onMove(evt);
                        this._handles[3].onMove(evt);

                        this._hovered = this._handles[0].hovered || this._handles[1].hovered || this._handles[2].hovered || this._handles[3].hovered;

                        this.update();
                }
        }, {
                key: 'onStart',
                value: function onStart(evt) {
                        this._dragged = false;

                        this._handles[0].onStart(evt);
                        this._handles[1].onStart(evt);
                        this._handles[2].onStart(evt);
                        this._handles[3].onStart(evt);

                        this._active = this._handles[0].active || this._handles[1].active || this._handles[2].active || this._handles[3].active;
                        this.update();
                }
        }, {
                key: 'onEnd',
                value: function onEnd(evt) {
                        // First Handle
                        this._handles[0].onEnd(evt);
                        this._handles[2].onEnd(evt);
                        this._handles[3].onEnd(evt);

                        window.console.log(this);

                        // Second Handle
                        if (this._dragged || !this._handles[1].tracking) {
                                this._handles[1].tracking = false;
                                this._handles[1].onEnd(evt);
                        } else {
                                this._handles[1].tracking = false;
                        }

                        // State of ruler widget
                        this._active = this._handles[0].active || this._handles[1].active || this._handles[2].active || this._handles[3].active;
                        this.update();
                }
        }, {
                key: 'create',
                value: function create() {
                        this.createMesh();
                        this.createDOM();
                }
        }, {
                key: 'hideDOM',
                value: function hideDOM() {
                        this._line.style.display = 'none';
                        this._distance.style.display = 'none';
                        this._line2.style.display = 'none';
                        this._distance2.style.display = 'none';

                        for (var index in this._handles) {
                                this._handles[index].hideDOM();
                        }

                        this._dashline.style.display = 'none';
                }
        }, {
                key: 'showDOM',
                value: function showDOM() {
                        this._line.style.display = '';
                        this._distance.style.display = '';
                        this._line2.style.display = '';
                        this._distance2.style.display = '';

                        for (var index in this._handles) {
                                this._handles[index].showDOM();
                        }

                        this._dashline.style.display = '';
                }
        }, {
                key: 'hideMesh',
                value: function hideMesh() {
                        this._mesh.visible = false;
                        this._mesh2.visible = false;
                        this._handles[0].visible = false;
                        this._handles[1].visible = false;
                        this._handles[2].visible = false;
                        this._handles[3].visible = false;
                }
        }, {
                key: 'showMesh',
                value: function showMesh() {
                        this._mesh.visible = true;
                        this._mesh2.visible = true;
                        this._handles[0].visible = true;
                        this._handles[1].visible = true;
                        this._handles[2].visible = true;
                        this._handles[3].visible = true;
                }
        }, {
                key: 'show',
                value: function show() {
                        this.showDOM();
                        this.showMesh();
                }
        }, {
                key: 'hide',
                value: function hide() {
                        this.hideDOM();
                        this.hideMesh();
                }
        }, {
                key: 'update',
                value: function update() {
                        this.updateColor();

                        // mesh stuff
                        this.updateMeshColor();
                        this.updateMeshPosition();

                        // DOM stuff
                        this.updateDOMPosition();
                        this.updateDOMColor();
                }
        }, {
                key: 'createMesh',
                value: function createMesh() {
                        // geometry
                        this._geometry = new THREE.Geometry();
                        this._geometry.vertices.push(this._handles[0].worldPosition);
                        this._geometry.vertices.push(this._handles[1].worldPosition);

                        // geometry
                        this._geometry2 = new THREE.Geometry();
                        this._geometry2.vertices.push(this._handles[2].worldPosition);
                        this._geometry2.vertices.push(this._handles[3].worldPosition);

                        // material
                        this._material = new THREE.LineBasicMaterial();
                        this._material2 = new THREE.LineBasicMaterial();
                        this.updateMeshColor();

                        // mesh
                        this._mesh = new THREE.Line(this._geometry, this._material);
                        this._mesh.visible = true;
                        this._mesh2 = new THREE.Line(this._geometry2, this._material2);
                        this._mesh2.visible = true;

                        // add it!
                        this.add(this._mesh);
                        this.add(this._mesh2);
                }
        }, {
                key: 'updateMeshColor',
                value: function updateMeshColor() {
                        if (this._material) {
                                this._material.color.set(this._color);
                        }
                        if (this._material2) {
                                this._material2.color.set(this._color);
                        }
                }
        }, {
                key: 'updateMeshPosition',
                value: function updateMeshPosition() {
                        if (this._geometry) {
                                this._geometry.verticesNeedUpdate = true;
                        }
                        if (this._geometry2) {
                                this._geometry2.verticesNeedUpdate = true;
                        }
                }
        }, {
                key: 'createDOM',
                value: function createDOM() {
                        // add line!
                        this._line = document.createElement('div');
                        this._line.setAttribute('class', 'widgets handle line');
                        this._line.style.position = 'absolute';
                        this._line.style.transformOrigin = '0 100%';
                        this._line.style.marginTop = '-1px';
                        this._line.style.height = '2px';
                        this._line.style.width = '3px';
                        this._container.appendChild(this._line);

                        // add distance!
                        this._distance = document.createElement('div');
                        this._distance.setAttribute('class', 'widgets handle distance');
                        this._distance.style.border = '2px solid';
                        this._distance.style.backgroundColor = '#F9F9F9';
                        // this._distance.style.opacity = '0.5';
                        this._distance.style.color = '#353535';
                        this._distance.style.padding = '4px';
                        this._distance.style.position = 'absolute';
                        this._distance.style.transformOrigin = '0 100%';
                        this._distance.innerHTML = 'Hello, world!';
                        this._container.appendChild(this._distance);

                        // add line!
                        this._line2 = document.createElement('div');
                        this._line2.setAttribute('class', 'widgets handle line');
                        this._line2.style.position = 'absolute';
                        this._line2.style.transformOrigin = '0 100%';
                        this._line2.style.marginTop = '-1px';
                        this._line2.style.height = '2px';
                        this._line2.style.width = '3px';
                        this._container.appendChild(this._line2);

                        // add distance!
                        this._distance2 = document.createElement('div');
                        this._distance2.setAttribute('class', 'widgets handle distance');
                        this._distance.style.border = '2px solid';
                        this._distance.style.backgroundColor = '#F9F9F9';
                        // this._distance2.style.opacity = '0.5';
                        this._distance2.style.color = '#353535';
                        this._distance2.style.padding = '4px';
                        this._distance2.style.position = 'absolute';
                        this._distance2.style.transformOrigin = '0 100%';
                        this._distance2.innerHTML = 'Hello, world!';
                        this._container.appendChild(this._distance2);

                        // add dash line
                        this._dashline = document.createElement('div');
                        this._dashline.setAttribute('class', 'widgets handle dashline');
                        this._dashline.style.position = 'absolute';
                        this._dashline.style.border = 'none';
                        this._dashline.style.borderTop = '2.5px dashed #F9F9F9';
                        this._dashline.style.transformOrigin = '0 100%';
                        this._dashline.style.height = '1px';
                        this._dashline.style.width = '50%';
                        this._container.appendChild(this._dashline);

                        this.updateDOMColor();
                }
        }, {
                key: 'updateDOMPosition',
                value: function updateDOMPosition() {
                        // update rulers lines and text!
                        var x1 = this._handles[0].screenPosition.x;
                        var y1 = this._handles[0].screenPosition.y;
                        var x2 = this._handles[1].screenPosition.x;
                        var y2 = this._handles[1].screenPosition.y;

                        //let x0 = x1 + (x2 - x1)/2;
                        //let y0 = y1 + (y2 - y1)/2;
                        var x0 = x2;
                        var y0 = y2;

                        if (y1 >= y2) {
                                y0 = y2 - 30;
                        } else {
                                y0 = y2 + 30;
                        }

                        var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                        var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                        var posY = y1 - this._container.offsetHeight;

                        // update line
                        var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
                        transform += ' rotate(' + angle + 'deg)';

                        this._line.style.transform = transform;
                        this._line.style.width = length;

                        // update distance
                        var w0 = this._handles[0].worldPosition;
                        var w1 = this._handles[1].worldPosition;

                        this._distance.innerHTML = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2) + ' mm';
                        this._distanceValue = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2);
                        var posY0 = y0 - this._container.offsetHeight - this._distance.offsetHeight / 2;
                        x0 -= this._distance.offsetWidth / 2;

                        var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
                        this._distance.style.transform = transform2;

                        // update rulers lines 2 and text!
                        var x3 = this._handles[2].screenPosition.x;
                        var y3 = this._handles[2].screenPosition.y;
                        var x4 = this._handles[3].screenPosition.x;
                        var y4 = this._handles[3].screenPosition.y;

                        //let x0 = x1 + (x2 - x1)/2;
                        //let y0 = y1 + (y2 - y1)/2;
                        var x02 = x4;
                        var y02 = y4;

                        if (y3 >= y4) {
                                y02 = y4 - 30;
                        } else {
                                y02 = y4 + 30;
                        }

                        length = Math.sqrt((x3 - x4) * (x3 - x4) + (y3 - y4) * (y3 - y4));
                        angle = Math.atan2(y4 - y3, x4 - x3) * 180 / Math.PI;

                        posY = y3 - this._container.offsetHeight;

                        // update line
                        transform = 'translate3D(' + x3 + 'px,' + posY + 'px, 0)';
                        transform += ' rotate(' + angle + 'deg)';

                        this._line2.style.transform = transform;
                        this._line2.style.width = length;

                        // update distance
                        var w02 = this._handles[2].worldPosition;
                        var w12 = this._handles[3].worldPosition;

                        this._distance2.innerHTML = Math.sqrt((w02.x - w12.x) * (w02.x - w12.x) + (w02.y - w12.y) * (w02.y - w12.y) + (w02.z - w12.z) * (w02.z - w12.z)).toFixed(2) + ' mm';
                        this._distance2Value = Math.sqrt((w02.x - w12.x) * (w02.x - w12.x) + (w02.y - w12.y) * (w02.y - w12.y) + (w02.z - w12.z) * (w02.z - w12.z)).toFixed(2);
                        var posY02 = y02 - this._container.offsetHeight - this._distance2.offsetHeight / 2;
                        x02 -= this._distance2.offsetWidth / 2;

                        transform2 = 'translate3D(' + Math.round(x02) + 'px,' + Math.round(posY02) + 'px, 0)';
                        this._distance2.style.transform = transform2;

                        // update dash line

                        var l1center = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.5);
                        var l2center = this.getPointInBetweenByPerc(this._handles[2].worldPosition, this._handles[3].worldPosition, 0.5);

                        var screen1 = this._handles[0].worldToScreen(l1center, this._camera, this._container);
                        var screen2 = this._handles[0].worldToScreen(l2center, this._camera, this._container);

                        x1 = screen1.x;
                        y1 = screen1.y;
                        x2 = screen2.x;
                        y2 = screen2.y;

                        length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                        angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                        posY = y1 - this._container.offsetHeight;

                        // update line
                        transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
                        transform += ' rotate(' + angle + 'deg)';

                        this._dashline.style.transform = transform;
                        this._dashline.style.width = length;
                }
        }, {
                key: 'updateDOMColor',
                value: function updateDOMColor() {
                        this._line.style.backgroundColor = '' + this._color;
                        this._distance.style.borderColor = '' + this._color;

                        this._line2.style.backgroundColor = '' + this._color;
                        this._distance2.style.borderColor = '' + this._color;
                }
        }, {
                key: 'getPointInBetweenByPerc',
                value: function getPointInBetweenByPerc(pointA, pointB, percentage) {

                        var dir = pointB.clone().sub(pointA);
                        var len = dir.length();
                        dir = dir.normalize().multiplyScalar(len * percentage);
                        return pointA.clone().add(dir);
                }
        }, {
                key: 'initOrtho',
                value: function initOrtho() {
                        this._initOrtho = true;

                        var pcenter = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.5);
                        this._handles[2].worldPosition = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.25);
                        this._handles[3].worldPosition = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.75);

                        this._handles[2].worldPosition.x = pcenter.x - Math.sqrt((pcenter.y - this._handles[2].worldPosition.y) * (pcenter.y - this._handles[2].worldPosition.y));
                        this._handles[2].worldPosition.y = pcenter.y + Math.sqrt((pcenter.x - this._handles[2].worldPosition.x) * (pcenter.x - this._handles[2].worldPosition.x));

                        this._handles[3].worldPosition.x = pcenter.x + Math.sqrt((pcenter.y - this._handles[2].worldPosition.y) * (pcenter.y - this._handles[2].worldPosition.y));
                        this._handles[3].worldPosition.y = pcenter.y - Math.sqrt((pcenter.x - this._handles[2].worldPosition.x) * (pcenter.x - this._handles[2].worldPosition.x));
                }
        }, {
                key: 'worldPosition',
                get: function get() {
                        return this._worldPosition;
                },
                set: function set(worldPosition) {
                        this._worldPosition = worldPosition;
                        this._handles[0].worldPosition = this._worldPosition;
                        this._handles[1].worldPosition = this._worldPosition;
                        this._handles[2].worldPosition = this._worldPosition;
                        this._handles[3].worldPosition = this._worldPosition;

                        this.update();
                }
        }, {
                key: 'shotestDistance',
                get: function get() {
                        return this._distanceValue < this._distance2Value ? this._distanceValue : this._distance2Value;
                }
        }, {
                key: 'longestDistance',
                get: function get() {
                        return this._distanceValue > this._distance2Value ? this._distanceValue : this._distance2Value;
                }
        }]);

        return WidgetsBiRuler;
}(_widgets2.default);

exports.default = WidgetsBiRuler;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],168:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsHandle = function (_WidgetsBase) {
  _inherits(WidgetsHandle, _WidgetsBase);

  function WidgetsHandle(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsHandle);

    var _this = _possibleConstructorReturn(this, (WidgetsHandle.__proto__ || Object.getPrototypeOf(WidgetsHandle)).call(this, container));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    // if no target mesh, use plane for FREE dragging.
    _this._plane = {
      position: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };
    _this._offset = new THREE.Vector3();
    _this._raycaster = new THREE.Raycaster();

    _this._tracking = false;

    _this._mouse = new THREE.Vector2();
    _this._lastEvent = null;

    // world (LPS) position of this handle
    _this._worldPosition = new THREE.Vector3();

    // screen position of this handle
    _this._screenPosition = new THREE.Vector2();

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;
    _this._meshDisplayed = true;
    _this._meshHovered = false;
    _this._meshStyle = 'sphere'; // cube, etc.

    // dom stuff
    _this._dom = null;
    _this._domDisplayed = true;
    _this._domHovered = false;
    _this._domStyle = 'circle'; // square, triangle

    if (_this._targetMesh !== null) {
      _this._worldPosition.copy(_this._targetMesh.position);
    }

    _this._screenPosition = _this.worldToScreen(_this._worldPosition, _this._camera, _this._container);

    // create handle
    _this.create();
    _this.initOffsets();

    // event listeners
    _this.onMove = _this.onMove.bind(_this);
    _this.onHover = _this.onHover.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsHandle, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._dom.addEventListener('mouseenter', this.onHover);
      this._dom.addEventListener('mouseleave', this.onHover);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._dom.removeEventListener('mouseenter', this.onHover);
      this._dom.removeEventListener('mouseleave', this.onHover);

      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      console.log(evt);
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);
      console.log(this._mouse);

      // update raycaster
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._hovered) {
        this._active = true;
        this._controls.enabled = false;

        if (this._targetMesh) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._offset.copy(intersectsTarget[0].point).sub(this._worldPosition);
          }
        } else {
          this._plane.position.copy(this._worldPosition);
          this._plane.direction.copy(this._camera.getWorldDirection());
          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._offset.copy(intersection).sub(this._plane.position);
          }
        }

        this.update();
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      // stay active and keep controls disabled
      if (this._tracking === true) {
        return;
      }

      // unselect if go up without moving
      if (!this._dragged && this._active) {
        // change state if was not dragging
        this._selected = !this._selected;
      }

      this._active = false;
      this._dragged = false;
      this._controls.enabled = true;

      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }

    /**
     *
     *
     */

  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      // set ray.position to satisfy CoreIntersections::rayPlane API
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._active) {
        this._dragged = true;

        if (this._targetMesh !== null) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._worldPosition.copy(intersectsTarget[0].point.sub(this._offset));
          }
        } else {
          if (this._plane.direction.length() === 0) {
            // free mode!this._targetMesh
            this._plane.position.copy(this._worldPosition);
            this._plane.direction.copy(this._camera.getWorldDirection());
          }

          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._worldPosition.copy(intersection.sub(this._offset));
          }
        }
      } else {
        this.onHover(null);
      }

      this.update();
    }
  }, {
    key: 'onHover',
    value: function onHover(evt) {
      if (evt) {
        this._lastEvent = evt;
        evt.preventDefault();
        this.hoverDom(evt);
      }

      this.hoverMesh();

      this._hovered = this._meshHovered || this._domHovered;
      this._container.style.cursor = this._hovered ? 'pointer' : 'default';
    }
  }, {
    key: 'update',
    value: function update() {
      // general update
      this.updateColor();

      // update screen position of handle
      this._screenPosition = this.worldToScreen(this._worldPosition, this._camera, this._container);

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMColor();
      this.updateDOMPosition();
    }

    //

  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._mesh) {
        this._mesh.position.x = this._worldPosition.x;
        this._mesh.position.y = this._worldPosition.y;
        this._mesh.position.z = this._worldPosition.z;
      }
    }
  }, {
    key: 'hoverMesh',
    value: function hoverMesh() {
      // check raycast intersection, do we want to hover on mesh or just css?
      var intersectsHandle = this._raycaster.intersectObject(this._mesh);
      this._meshHovered = intersectsHandle.length > 0;
    }
  }, {
    key: 'hoverDom',
    value: function hoverDom(evt) {
      this._domHovered = evt.type === 'mouseenter';
    }
  }, {
    key: 'worldToScreen',
    value: function worldToScreen(worldCoordinate, camera, canvas) {
      var screenCoordinates = worldCoordinate.clone();
      screenCoordinates.project(camera);

      screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);
      screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);
      screenCoordinates.z = 0;

      return screenCoordinates;
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.SphereGeometry(1, 16, 16);

      // material
      this._material = new THREE.MeshBasicMaterial({
        wireframe: true,
        wireframeLinewidth: 2
      });

      // mesh
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.position.x = this._worldPosition.x;
      this._mesh.position.y = this._worldPosition.y;
      this._mesh.position.z = this._worldPosition.z;
      this._mesh.visible = true;

      this.updateMeshColor();

      // add it!
      this.add(this._mesh);
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // dom
      this._dom = document.createElement('div');
      this._dom.setAttribute('id', this.uuid);
      this._dom.setAttribute('class', 'AMI Widget Handle');
      this._dom.style.border = '2px solid';
      this._dom.style.backgroundColor = '#F9F9F9';
      this._dom.style.color = '#F9F9F9';
      this._dom.style.position = 'absolute';
      this._dom.style.width = '12px';
      this._dom.style.height = '12px';
      this._dom.style.margin = '-6px';
      this._dom.style.borderRadius = '50%';
      this._dom.style.transformOrigin = '0 100%';

      var posY = this._screenPosition.y - this._container.offsetHeight;
      this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';

      this.updateDOMColor();

      // add it!
      this._container.appendChild(this._dom);
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      if (this._dom) {
        var posY = this._screenPosition.y - this._container.offsetHeight;
        this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';
      }
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._dom.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      // threejs stuff

      // dom
      this._container.removeChild(this._dom);
      // event
      this.removeEventListeners();

      _get(WidgetsHandle.prototype.__proto__ || Object.getPrototypeOf(WidgetsHandle.prototype), 'free', this).call(this);
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._dom.style.display = 'none';
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._dom.style.display = '';
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'worldPosition',
    set: function set(worldPosition) {
      this._worldPosition.copy(worldPosition);

      this.update();
    },
    get: function get() {
      return this._worldPosition;
    }
  }, {
    key: 'screenPosition',
    set: function set(screenPosition) {
      this._screenPosition = screenPosition;
    },
    get: function get() {
      return this._screenPosition;
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    },
    set: function set(active) {
      this._active = active;
      // this._tracking = this._active;
      this._controls.enabled = !this._active;

      this.update();
    }
  }, {
    key: 'tracking',
    get: function get() {
      return this._tracking;
    },
    set: function set(tracking) {
      this._tracking = tracking;
      this.update();
    }
  }]);

  return WidgetsHandle;
}(_widgets2.default);

exports.default = WidgetsHandle;

},{"../core/core.intersections":102,"../widgets/widgets.base":166}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _widgets = require('./widgets.annotation');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('./widgets.biruler');

var _widgets4 = _interopRequireDefault(_widgets3);

var _widgets5 = require('./widgets.handle');

var _widgets6 = _interopRequireDefault(_widgets5);

var _widgets7 = require('./widgets.roi');

var _widgets8 = _interopRequireDefault(_widgets7);

var _widgets9 = require('./widgets.ruler');

var _widgets10 = _interopRequireDefault(_widgets9);

var _widgets11 = require('./widgets.voxelProbe');

var _widgets12 = _interopRequireDefault(_widgets11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module widgets
 */

exports.default = {
  Annotation: _widgets2.default,
  BiRuler: _widgets4.default,
  Handle: _widgets6.default,
  Roi: _widgets8.default,
  Ruler: _widgets10.default,
  VoxelProbe: _widgets12.default
};

},{"./widgets.annotation":165,"./widgets.biruler":167,"./widgets.handle":168,"./widgets.roi":170,"./widgets.ruler":171,"./widgets.voxelProbe":172}],170:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsRoi = function (_WidgetsBase) {
    _inherits(WidgetsRoi, _WidgetsBase);

    function WidgetsRoi(targetMesh, controls, camera, container) {
        _classCallCheck(this, WidgetsRoi);

        var _this = _possibleConstructorReturn(this, (WidgetsRoi.__proto__ || Object.getPrototypeOf(WidgetsRoi)).call(this));

        _this._targetMesh = targetMesh;
        _this._controls = controls;
        _this._camera = camera;
        _this._container = container;

        _this._active = true;
        _this._init = false;

        _this._worldPosition = new THREE.Vector3();
        if (_this._targetMesh !== null) {
            _this._worldPosition = _this._targetMesh.position;
        }

        // mesh stuff
        _this._material = null;
        _this._geometry = null;
        _this._mesh = null;

        // dom stuff
        _this._lines = [];
        _this._area = null;

        // add handles
        _this._handles = [];

        // first handle
        var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        firstHandle.worldPosition = _this._worldPosition;
        firstHandle.hovered = true;
        _this.add(firstHandle);

        _this._handles.push(firstHandle);

        // Create ruler
        _this.create();

        _this.onMove = _this.onMove.bind(_this);
        _this.addEventListeners();

        _this._orientation = null;
        _this._slice = null;
        return _this;
    }

    _createClass(WidgetsRoi, [{
        key: 'addEventListeners',
        value: function addEventListeners() {
            this._container.addEventListener('mousewheel', this.onMove);
            this._container.addEventListener('DOMMouseScroll', this.onMove);
        }
    }, {
        key: 'onMove',
        value: function onMove(evt) {
            this._dragged = true;
            var numHandles = this._handles.length;

            if (this.active && !this._init) {
                var lastHandle = this._handles[numHandles - 1];
                lastHandle.hovered = false;
                lastHandle.active = false;
                lastHandle.tracking = false;

                var nextHandle = new _widgets4.default(this._targetMesh, this._controls, this._camera, this._container);
                nextHandle.worldPosition = this._worldPosition;
                nextHandle.hovered = true;
                nextHandle.active = true;
                nextHandle.tracking = true;
                this.add(nextHandle);

                this._handles.push(nextHandle);

                var newLine = document.createElement('div');
                newLine.setAttribute('class', 'widgets handle line');
                newLine.style.position = 'absolute';
                newLine.style.transformOrigin = '0 100%';
                newLine.style.marginTop = '-1px';
                newLine.style.height = '2px';
                newLine.style.width = '3px';
                newLine.style.backgroundColor = '#F9F9F9';

                this._lines.push(newLine);
                this._container.appendChild(newLine);
            }

            var hovered = false;

            for (var index in this._handles) {
                this._handles[index].onMove(evt);
                hovered = hovered || this._handles[index].hovered;
            }

            this._hovered = hovered;

            if (this.active && numHandles > 2) {
                this.pushPopHandle();
            }

            this.update();
        }
    }, {
        key: 'onStart',
        value: function onStart(evt) {
            this._dragged = false;

            var active = false;

            for (var index in this._handles) {
                this._handles[index].onStart(evt);
                active = active || this._handles[index].active;
            }

            this._active = active;
            this.update();
        }
    }, {
        key: 'onEnd',
        value: function onEnd(evt) {
            // First Handle
            var active = false;
            for (var index in this._handles.slice(0, this._handles.length - 2)) {
                this._handles[index].onEnd(evt);
                active = active || this._handles[index].active;
            }

            // Second Handle
            if (this._dragged || !this._handles[this._handles.length - 1].tracking) {
                this._handles[this._handles.length - 1].tracking = false;
                this._handles[this._handles.length - 1].onEnd(evt);
            } else {
                this._handles[this._handles.length - 1].tracking = false;
            }

            active = active || this._handles[this._handles.length - 1].active;
            // State of ruler widget
            this._active = active;

            if (this._lines.length < this._handles.length) {
                var newLine = document.createElement('div');
                newLine.setAttribute('class', 'widgets handle line');
                newLine.style.position = 'absolute';
                newLine.style.transformOrigin = '0 100%';
                newLine.style.marginTop = '-1px';
                newLine.style.height = '2px';
                newLine.style.width = '3px';
                newLine.style.backgroundColor = '#F9F9F9';

                this._lines.push(newLine);
                this._container.appendChild(newLine);
            }

            this._init = true;
            this.updateMesh();
            this.update();
        }
    }, {
        key: 'create',
        value: function create() {
            this.createDOM();
        }
    }, {
        key: 'hideDOM',
        value: function hideDOM() {
            for (var index in this._handles) {
                this._handles[index].hideDOM();
            }

            for (var _index in this._lines) {
                this._lines[_index].style.display = 'none';
            }
        }
    }, {
        key: 'showDOM',
        value: function showDOM() {
            for (var index in this._handles) {
                this._handles[index].showDOM();
            }

            for (var _index2 in this._lines) {
                this._lines[_index2].style.display = '';
            }
        }
    }, {
        key: 'hideMesh',
        value: function hideMesh() {
            this.visible = false;
        }
    }, {
        key: 'showMesh',
        value: function showMesh() {
            this.visible = true;
        }
    }, {
        key: 'show',
        value: function show() {
            this.showDOM();
            this.showMesh();
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.hideDOM();
            this.hideMesh();
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateColor();

            for (var index in this._handles) {
                this._handles[index].update();
            }

            // mesh stuff
            this.updateMeshColor();
            this.updateMeshPosition();

            // DOM stuff
            this.updateDOMPosition();
            this.updateDOMColor();
        }
    }, {
        key: 'updateMesh',
        value: function updateMesh() {
            // geometry
            this._geometry = new THREE.Geometry();
            for (var index in this._handles) {
                this._geometry.vertices.push(this._handles[index].worldPosition);
            }

            // material
            this._material = new THREE.LineBasicMaterial();
            this.updateMeshColor();

            // mesh
            this._mesh = new THREE.Line(this._geometry, this._material);
            this._mesh.visible = true;

            // add it!
            this.add(this._mesh);
        }
    }, {
        key: 'updateMeshColor',
        value: function updateMeshColor() {
            if (this._material) {
                this._material.color.set(this._color);
            }
        }
    }, {
        key: 'updateMeshPosition',
        value: function updateMeshPosition() {
            if (this._geometry) {
                this._geometry.verticesNeedUpdate = true;
            }
        }
    }, {
        key: 'createDOM',
        value: function createDOM() {
            // add line!
            this._line = document.createElement('div');
            this._line.setAttribute('class', 'widgets handle line');
            this._line.style.position = 'absolute';
            this._line.style.transformOrigin = '0 100%';
            this._line.style.marginTop = '-1px';
            this._line.style.height = '2px';
            this._line.style.width = '3px';
            this._container.appendChild(this._line);

            this.updateDOMColor();
        }
    }, {
        key: 'isPointOnLine',
        value: function isPointOnLine(pointA, pointB, pointToCheck) {
            var c = new THREE.Vector3();
            c.crossVectors(pointA.clone().sub(pointToCheck), pointB.clone().sub(pointToCheck));
            return !c.length();
        }
    }, {
        key: 'pushPopHandle',
        value: function pushPopHandle() {
            var handle0 = this._handles[this._handles.length - 3];
            var handle1 = this._handles[this._handles.length - 2];
            var newhandle = this._handles[this._handles.length - 1];

            var isOnLine = this.isPointOnLine(handle0.worldPosition, handle1.worldPosition, newhandle.worldPosition);

            if (isOnLine) {
                handle1._dom.style.display = 'none';
                this.remove(handle1);

                this._handles[this._handles.length - 2] = newhandle;
                this._handles.pop();

                var tempLine = this._lines.pop();
                tempLine.style.display = 'none';
                this._container.removeChild(tempLine);
            }

            return isOnLine;
        }
    }, {
        key: 'updateLineDOM',
        value: function updateLineDOM(lineIndex, handle0Index, handle1Index) {
            // update rulers lines and text!
            var x1 = this._handles[handle0Index].screenPosition.x;
            var y1 = this._handles[handle0Index].screenPosition.y;
            var x2 = this._handles[handle1Index].screenPosition.x;
            var y2 = this._handles[handle1Index].screenPosition.y;

            var x0 = x2;
            var y0 = y2;

            if (y1 >= y2) {
                y0 = y2 - 30;
            } else {
                y0 = y2 + 30;
            }

            var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            var posY = y1 - this._container.offsetHeight;

            // update line
            var transform = 'translate3D(' + x1 + 'px, ' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            //this._lines[lineIndex].style.display = '';
            this._lines[lineIndex].style.transform = transform;
            this._lines[lineIndex].style.width = length + 'px';
        }
    }, {
        key: 'updateDOMPosition',
        value: function updateDOMPosition() {
            if (this._handles.length >= 2) {
                for (var index in this._lines) {
                    this.updateLineDOM(index, index, parseInt(index) + 1 == this._handles.length ? 0 : parseInt(index) + 1);
                }
            }
        }
    }, {
        key: 'updateDOMColor',
        value: function updateDOMColor() {
            if (this._handles.length >= 2) {
                for (var index in this._lines) {
                    this._lines[index].style.backgroundColor = '' + this._color;
                }
            }
        }
    }, {
        key: 'getPointInBetweenByPerc',
        value: function getPointInBetweenByPerc(pointA, pointB, percentage) {

            var dir = pointB.clone().sub(pointA);
            var len = dir.length();
            dir = dir.normalize().multiplyScalar(len * percentage);
            return pointA.clone().add(dir);
        }
    }, {
        key: 'worldPosition',
        get: function get() {
            return this._worldPosition;
        },
        set: function set(worldPosition) {
            this._worldPosition = worldPosition;

            for (var index in this._handles) {
                this._handles[index]._worldPosition = this._worldPosition;
            }

            this.update();
        }
    }]);

    return WidgetsRoi;
}(_widgets2.default);

exports.default = WidgetsRoi;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsRuler = function (_WidgetsBase) {
  _inherits(WidgetsRuler, _WidgetsBase);

  function WidgetsRuler(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsRuler);

    var _this = _possibleConstructorReturn(this, (WidgetsRuler.__proto__ || Object.getPrototypeOf(WidgetsRuler)).call(this, container));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    _this._active = true;
    _this._lastEvent = null;

    _this._worldPosition = new THREE.Vector3();
    if (_this._targetMesh !== null) {
      _this._worldPosition = _this._targetMesh.position;
    }

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // dom stuff
    _this._line = null;
    _this._distance = null;

    // add handles
    _this._handles = [];

    // first handle
    var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    firstHandle.worldPosition = _this._worldPosition;
    firstHandle.hovered = true;
    _this.add(firstHandle);

    _this._handles.push(firstHandle);

    var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    secondHandle.worldPosition = _this._worldPosition;
    secondHandle.hovered = true;
    // active and tracking might be redundant
    secondHandle.active = true;
    secondHandle.tracking = true;
    _this.add(secondHandle);

    _this._handles.push(secondHandle);

    // Create ruler
    _this.create();
    _this.initOffsets();

    _this.onMove = _this.onMove.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsRuler, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      this._dragged = true;

      this._handles[0].onMove(evt);
      this._handles[1].onMove(evt);

      this._hovered = this._handles[0].hovered || this._handles[1].hovered;
      this.update();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      this._lastEvent = evt;
      this._dragged = false;

      this._handles[0].onStart(evt);
      this._handles[1].onStart(evt);

      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      // First Handle
      this._handles[0].onEnd(evt);

      // window.console.log(this);

      // Second Handle
      if (this._dragged || !this._handles[1].tracking) {
        this._handles[1].tracking = false;
        this._handles[1].onEnd(evt);
      } else {
        this._handles[1].tracking = false;
      }

      // State of ruler widget
      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._line.style.display = 'none';
      this._distance.style.display = 'none';
      for (var index in this._handles) {
        this._handles[index].hideDOM();
      }
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._line.style.display = '';
      this._distance.style.display = '';
      for (var index in this._handles) {
        this._handles[index].showDOM();
      }
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'update',
    value: function update() {
      this.updateColor();

      // update handles
      this._handles[0].update();
      this._handles[1].update();

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMColor();
      this.updateDOMPosition();
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.Geometry();
      this._geometry.vertices.push(this._handles[0].worldPosition);
      this._geometry.vertices.push(this._handles[1].worldPosition);

      // material
      this._material = new THREE.LineBasicMaterial();
      this.updateMeshColor();

      // mesh
      this._mesh = new THREE.Line(this._geometry, this._material);
      this._mesh.visible = true;

      // add it!
      this.add(this._mesh);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._geometry) {
        this._geometry.verticesNeedUpdate = true;
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // add line!
      this._line = document.createElement('div');
      this._line.setAttribute('id', this.uuid);
      this._line.setAttribute('class', 'AMI Widget Ruler');
      this._line.style.position = 'absolute';
      this._line.style.transformOrigin = '0 100%';
      this._line.style.marginTop = '-1px';
      this._line.style.height = '2px';
      this._line.style.width = '3px';
      this._container.appendChild(this._line);

      // add distance!
      this._distance = document.createElement('div');
      this._distance.setAttribute('class', 'widgets handle distance');
      this._distance.style.border = '2px solid';
      this._distance.style.backgroundColor = '#F9F9F9';
      // this._distance.style.opacity = '0.5';
      this._distance.style.color = '#353535';
      this._distance.style.padding = '4px';
      this._distance.style.position = 'absolute';
      this._distance.style.transformOrigin = '0 100%';
      this._distance.innerHTML = 'Hello, world!';
      this._container.appendChild(this._distance);

      this.updateDOMColor();
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      // update rulers lines and text!
      var x1 = this._handles[0].screenPosition.x;
      var y1 = this._handles[0].screenPosition.y;
      var x2 = this._handles[1].screenPosition.x;
      var y2 = this._handles[1].screenPosition.y;

      var x0 = x1 + (x2 - x1) / 2;
      var y0 = y1 + (y2 - y1) / 2;

      var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

      var posY = y1 - this._container.offsetHeight;

      // update line
      var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
      transform += ' rotate(' + angle + 'deg)';

      this._line.style.transform = transform;
      this._line.style.width = length + 'px';

      // update distance
      var w0 = this._handles[0].worldPosition;
      var w1 = this._handles[1].worldPosition;

      this._distance.innerHTML = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2) + ' mm';
      var posY0 = y0 - this._container.offsetHeight - this._distance.offsetHeight / 2;
      x0 -= this._distance.offsetWidth / 2;

      var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
      this._distance.style.transform = transform2;
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._line.style.backgroundColor = '' + this._color;
      this._distance.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._handles.forEach(function (h) {
        h.free();
      });

      this._handles = [];

      this._container.removeChild(this._line);
      this._container.removeChild(this._distance);

      this.remove(this._mesh);

      _get(WidgetsRuler.prototype.__proto__ || Object.getPrototypeOf(WidgetsRuler.prototype), 'free', this).call(this);
    }
  }, {
    key: 'worldPosition',
    get: function get() {
      return this._worldPosition;
    },
    set: function set(worldPosition) {
      this._worldPosition = worldPosition;
      this._handles[0].worldPosition = this._worldPosition;
      this._handles[1].worldPosition = this._worldPosition;

      this.update();
    }
  }]);

  return WidgetsRuler;
}(_widgets2.default);

exports.default = WidgetsRuler;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],172:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _geometries = require('../geometries/geometries.voxel');

var _geometries2 = _interopRequireDefault(_geometries);

var _models = require('../models/models.stack');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('../models/models.voxel');

var _models4 = _interopRequireDefault(_models3);

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/voxelProbe
 */

var WidgetsVoxelProbe = function (_WidgetsBase) {
  _inherits(WidgetsVoxelProbe, _WidgetsBase);

  function WidgetsVoxelProbe(stack, targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsVoxelProbe);

    var _this = _possibleConstructorReturn(this, (WidgetsVoxelProbe.__proto__ || Object.getPrototypeOf(WidgetsVoxelProbe)).call(this, container));

    _this._stack = stack;

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    // if no target mesh, use plane for FREE dragging.
    _this._plane = {
      position: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };

    _this._offset = new THREE.Vector3();
    _this._raycaster = new THREE.Raycaster();

    _this._tracking = false;

    _this._mouse = new THREE.Vector2();
    _this._lastEvent = null;

    // world (LPS) position of the center
    _this._worldPosition = new THREE.Vector3();

    // screen position of the center
    _this._screenPosition = new THREE.Vector2();

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;
    _this._meshDisplayed = true;
    _this._meshHovered = false;
    _this._meshStyle = 'sphere'; // cube, etc.

    // dom stuff
    _this._dom = null;
    _this._domDisplayed = true;
    _this._domHovered = false;
    _this._domStyle = 'circle'; // square, triangle

    if (_this._targetMesh !== null) {
      _this._worldPosition.copy(_this._targetMesh.position);
    }

    _this._screenPosition = _this.worldToScreen(_this._worldPosition, _this._camera, _this._container);

    // create handle
    _this.create();
    _this.initOffsets();

    // event listeners
    _this.onMove = _this.onMove.bind(_this);
    _this.onHover = _this.onHover.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsVoxelProbe, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._dom.addEventListener('mouseenter', this.onHover);
      this._dom.addEventListener('mouseleave', this.onHover);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._dom.removeEventListener('mouseenter', this.onHover);
      this._dom.removeEventListener('mouseleave', this.onHover);

      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._hovered) {
        this._active = true;
        this._controls.enabled = false;

        if (this._targetMesh) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._offset.copy(intersectsTarget[0].point).sub(this._worldPosition);
          }
        } else {
          this._plane.position.copy(this._worldPosition);
          this._plane.direction.copy(this._camera.getWorldDirection());
          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._offset.copy(intersection).sub(this._plane.position);
          }
        }

        this.update();
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      // stay active and keep controls disabled
      if (this._tracking === true) {
        return;
      }

      // unselect if go up without moving
      if (!this._dragged && this._active) {
        // change state if was not dragging
        this._selected = !this._selected;
      }

      this._active = false;
      this._dragged = false;
      this._controls.enabled = true;

      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      // set ray.position to satisfy CoreIntersections::rayPlane API
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._active) {
        this._dragged = true;

        if (this._targetMesh !== null) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._worldPosition.copy(intersectsTarget[0].point.sub(this._offset));
          }
        } else {
          if (this._plane.direction.length() === 0) {
            // free mode!this._targetMesh
            this._plane.position.copy(this._worldPosition);
            this._plane.direction.copy(this._camera.getWorldDirection());
          }

          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._worldPosition.copy(intersection.sub(this._offset));
          }
        }
      } else {
        this.onHover(null);
      }

      this.update();
    }
  }, {
    key: 'onHover',
    value: function onHover(evt) {
      if (evt) {
        this._lastEvent = evt;
        evt.preventDefault();
        this.hoverDom(evt);
      }

      this.hoverMesh();

      this._hovered = this._meshHovered || this._domHovered;
      this._container.style.cursor = this._hovered ? 'pointer' : 'default';
    }
  }, {
    key: 'hoverMesh',
    value: function hoverMesh() {
      // check raycast intersection, do we want to hover on mesh or just css?
      var intersectsHandle = this._raycaster.intersectObject(this._mesh);
      this._meshHovered = intersectsHandle.length > 0;
    }
  }, {
    key: 'hoverDom',
    value: function hoverDom(evt) {
      this._domHovered = evt.type === 'mouseenter';
    }
  }, {
    key: 'worldToScreen',
    value: function worldToScreen(worldCoordinate, camera, canvas) {
      var screenCoordinates = worldCoordinate.clone();
      screenCoordinates.project(camera);

      screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);
      screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);
      screenCoordinates.z = 0;

      return screenCoordinates;
    }
  }, {
    key: 'create',
    value: function create() {
      this.createVoxel();
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'createVoxel',
    value: function createVoxel() {
      this._voxel = new _models4.default();
      this._voxel.id = this.id;
      this._voxel.worldCoordinates = this._worldCoordinates;
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      var dataCoordinates = _models2.default.worldToData(this._stack, this._worldPosition);

      this._geometry = new _geometries2.default(dataCoordinates);
      this._material = new THREE.MeshBasicMaterial({
        wireframe: true,
        wireframeLinewidth: 1
      });
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.applyMatrix(this._stack.ijk2LPS);
      this._mesh.visible = true;

      this.updateMeshColor();

      this.add(this._mesh);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // dom
      this._dom = document.createElement('div');
      this._dom.setAttribute('id', this.uuid);
      this._dom.setAttribute('class', 'AMI Widget VoxelProbe');
      this._dom.style.border = '2px solid #000';
      this._dom.style.backgroundColor = 'rgb(249, 249, 249)';
      this._dom.style.color = '#212121';
      this._dom.style.position = 'absolute';
      this._dom.style.transformOrigin = '0px 100% 0px';

      // measurenents
      var measurementsContainer = document.createElement('div');
      // LPS
      var lpsContainer = document.createElement('div');
      lpsContainer.setAttribute('id', 'lpsPosition');
      measurementsContainer.appendChild(lpsContainer);
      // IJK
      var ijkContainer = document.createElement('div');
      ijkContainer.setAttribute('id', 'ijkPosition');
      measurementsContainer.appendChild(ijkContainer);
      // Value
      var valueContainer = document.createElement('div');
      valueContainer.setAttribute('id', 'value');
      measurementsContainer.appendChild(valueContainer);

      this.updateDOMColor();
      this._dom.appendChild(measurementsContainer);

      // add it!
      this._container.appendChild(this._dom);
    }
  }, {
    key: 'updateDOMContent',
    value: function updateDOMContent() {
      var rasContainer = this._dom.querySelector('#lpsPosition');
      rasContainer.innerHTML = 'LPS: \n      ' + this._voxel.worldCoordinates.x.toFixed(2) + ' :\n      ' + this._voxel.worldCoordinates.y.toFixed(2) + ' :\n      ' + this._voxel.worldCoordinates.z.toFixed(2);

      var ijkContainer = this._dom.querySelector('#ijkPosition');
      ijkContainer.innerHTML = 'IJK: \n      ' + this._voxel.dataCoordinates.x + ' :\n      ' + this._voxel.dataCoordinates.y + ' :\n      ' + this._voxel.dataCoordinates.z;

      var valueContainer = this._dom.querySelector('#value');
      valueContainer.innerHTML = 'Value: ' + this._voxel.value;
    }
  }, {
    key: 'update',
    value: function update() {
      // general update
      this.updateColor();
      this._screenPosition = this.worldToScreen(this._worldPosition, this._camera, this._container);

      // set data coordinates && value
      this.updateVoxel(this._worldPosition);

      // update mesh position
      this.updateMeshColor();
      if (this._mesh && this._mesh.geometry) {
        this._mesh.geometry.location = this._voxel.dataCoordinates;
        this._mesh.updateMatrix();
      }

      // update dom
      this.updateDOMContent();
      this.updateDOMColor();
      this.updateDOMPosition();
    }
  }, {
    key: 'updateVoxel',
    value: function updateVoxel(worldCoordinates) {
      // update world coordinates
      this._voxel.worldCoordinates = worldCoordinates;

      // update data coordinates
      this._voxel.dataCoordinates = _models2.default.worldToData(this._stack, this._voxel.worldCoordinates);

      // update value
      var value = _models2.default.value(this._stack, this._voxel.dataCoordinates);

      this._voxel.value = _models2.default.valueRescaleSlopeIntercept(value, this._stack.rescaleSlope, this._stack.rescaleIntercept);
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      if (this._dom) {
        var posY = this._screenPosition.y - this._container.offsetHeight;
        this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';
      }
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._dom.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      this._container.removeEventListener('mouseup', this.onMouseUpHandler, false);
      this._container.removeEventListener('mousemove', this.onMouseMoveHandler, false);

      this._container.removeEventListener('mousewheel', this.onMouseMoveHandler, false);
      this._container.removeEventListener('DOMMouseScroll', this.onMouseMoveHandler, false);

      this._voxel.removeTest();
      this.remove(this._voxel);
      this._voxel = null;

      _get(WidgetsVoxelProbe.prototype.__proto__ || Object.getPrototypeOf(WidgetsVoxelProbe.prototype), 'free', this).call(this);
    }
  }, {
    key: 'hoverVoxel',
    value: function hoverVoxel(mouseScreenCoordinates, currentDataCoordinates) {
      // update distance mouse/this._voxel
      var dx = mouseScreenCoordinates.screenX - this._voxel.voxel.screenCoordinates.x;
      var dy = mouseScreenCoordinates.screenY - this._voxel.voxel.screenCoordinates.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      this._voxel.distance = distance;
      if (distance >= 0 && distance < 10) {
        this._hover = true;
      } else {
        this._hover = false;
      }
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._dom.style.display = 'none';
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._dom.style.display = '';
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'worldPosition',
    set: function set(worldPosition) {
      this._worldPosition.copy(worldPosition);
      this.update();
    }
  }, {
    key: 'defaultColor',
    set: function set(defaultColor) {
      this._defaultColor = defaultColor;
      this.update();
    },
    get: function get() {
      return this._defaultColor;
    }
  }, {
    key: 'activeColor',
    set: function set(activeColor) {
      this._activeColor = activeColor;
      this.update();
    },
    get: function get() {
      return this._activeColor;
    }
  }, {
    key: 'hoverColor',
    set: function set(hoverColor) {
      this._hoverColor = hoverColor;
      this.update();
    },
    get: function get() {
      return this._hoverColor;
    }
  }, {
    key: 'selectedColor',
    set: function set(selectedColor) {
      this._selectedColor = selectedColor;
      this.update();
    },
    get: function get() {
      return this._selectedColor;
    }
  }, {
    key: 'showVoxel',
    set: function set(showVoxel) {
      this._showVoxel = showVoxel;
      this.update();
    },
    get: function get() {
      return this._showVoxel;
    }
  }, {
    key: 'showDomSVG',
    set: function set(showDomSVG) {
      this._showDomSVG = showDomSVG;
      this.update();
    },
    get: function get() {
      return this._showDomSVG;
    }
  }, {
    key: 'showDomMeasurements',
    set: function set(showDomMeasurements) {
      this._showDomMeasurements = showDomMeasurements;
      this.update();
    },
    get: function get() {
      return this._showDomMeasurements;
    }
  }]);

  return WidgetsVoxelProbe;
}(_widgets2.default);

exports.default = WidgetsVoxelProbe;

},{"../core/core.intersections":102,"../geometries/geometries.voxel":109,"../models/models.stack":134,"../models/models.voxel":135,"../widgets/widgets.base":166}]},{},[95])(95)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleHRlcm5hbC9zY3JpcHRzL2pwZWcuanMiLCJleHRlcm5hbC9zY3JpcHRzL2pweC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL3NyYy9iaW5kaW5nLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLXNoaW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29uc3QtbmluZi1mbG9hdDMyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb25zdC1waW5mLWZsb2F0MzIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kaWNvbS1wYXJzZXIvZGlzdC9kaWNvbVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9jb21wb25lbnQtc3BlYy5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2RhdGEtc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2ZyYW1lLWhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2h1ZmZtYW4tdGFibGUuanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvcXVhbnRpemF0aW9uLXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvc2Nhbi1jb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9zY2FuLWhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21hdGgtYWJzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWNlaWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nL2xpYi9kaXYyLmpzIiwibm9kZV9tb2R1bGVzL21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWZsb2F0MzItdG8tYmluYXJ5LXN0cmluZy9saWIvbXVsdDIuanMiLCJub2RlX21vZHVsZXMvbWF0aC1mbG9vci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmlmdGktcmVhZGVyLWpzL3NyYy9uaWZ0aS5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL25pZnRpMS5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL25pZnRpMi5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9ucnJkLWpzL25ycmQuanMiLCJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGlscy1sZWZ0LXBhZC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWxzLXJlcGVhdC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWxzLXJpZ2h0LXBhZC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLWludGVnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW5vbm5lZ2F0aXZlLWludGVnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW51bWJlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tc3RyaW5nLXByaW1pdGl2ZS9saWIvaW5kZXguanMiLCJwYWNrYWdlLmpzb24iLCJzcmNcXGFtaS5qcyIsInNyY1xcY2FtZXJhc1xcY2FtZXJhcy5qcyIsInNyY1xcY2FtZXJhc1xcY2FtZXJhcy5vcnRob2dyYXBoaWMuanMiLCJzcmNcXGNvbnRyb2xzXFxjb250cm9scy5qcyIsInNyY1xcY29udHJvbHNcXGNvbnRyb2xzLnRyYWNrYmFsbC5qcyIsInNyY1xcY29udHJvbHNcXGNvbnRyb2xzLnRyYWNrYmFsbG9ydGhvLmpzIiwic3JjXFxjb3JlXFxjb3JlLmNvbG9ycy5qcyIsInNyY1xcY29yZVxcY29yZS5pbnRlcnNlY3Rpb25zLmpzIiwic3JjXFxjb3JlXFxjb3JlLmpzIiwic3JjXFxjb3JlXFxjb3JlLnBhY2suanMiLCJzcmNcXGNvcmVcXGNvcmUudXRpbHMuanMiLCJzcmNcXGNvcmVcXGNvcmUudmFsaWRhdG9ycy5qcyIsInNyY1xcZ2VvbWV0cmllc1xcZ2VvbWV0cmllcy5qcyIsInNyY1xcZ2VvbWV0cmllc1xcZ2VvbWV0cmllcy5zbGljZS5qcyIsInNyY1xcZ2VvbWV0cmllc1xcZ2VvbWV0cmllcy52b3hlbC5qcyIsInNyY1xcaGVscGVyc1xcaGVscGVycy5ib3JkZXIuanMiLCJzcmNcXGhlbHBlcnNcXGhlbHBlcnMuYm91bmRpbmdib3guanMiLCJzcmNcXGhlbHBlcnNcXGhlbHBlcnMuanMiLCJzcmNcXGhlbHBlcnNcXGhlbHBlcnMubG9jYWxpemVyLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLmx1dC5qcyIsInNyY1xcaGVscGVyc1xcaGVscGVycy5tYXRlcmlhbC5taXhpbi5qcyIsInNyY1xcaGVscGVyc1xcaGVscGVycy5wcm9ncmVzc2Jhci5ldmVudGJhc2VkLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLnByb2dyZXNzYmFyLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLnNsaWNlLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLnN0YWNrLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLnZvbHVtZXJlbmRlcmluZy5qcyIsInNyY1xcaGVscGVyc1xceFxcaGVscGVycy54LmludGVyYWN0b3IuanMiLCJzcmNcXGhlbHBlcnNcXHhcXGhlbHBlcnMueC5qcyIsInNyY1xcaGVscGVyc1xceFxcaGVscGVycy54Lm1lc2guanMiLCJzcmNcXGhlbHBlcnNcXHhcXGhlbHBlcnMueC5yZW5kZXJlcjJkLmpzIiwic3JjXFxoZWxwZXJzXFx4XFxoZWxwZXJzLngucmVuZGVyZXIzZC5qcyIsInNyY1xcaGVscGVyc1xceFxcaGVscGVycy54LnZvbHVtZS5qcyIsInNyY1xcbG9hZGVyc1xcbG9hZGVycy5iYXNlLmpzIiwic3JjXFxsb2FkZXJzXFxsb2FkZXJzLmpzIiwic3JjXFxsb2FkZXJzXFxsb2FkZXJzLnZvbHVtZS5qcyIsInNyY1xcbW9kZWxzXFxtb2RlbHMuYmFzZS5qcyIsInNyY1xcbW9kZWxzXFxtb2RlbHMuZnJhbWUuanMiLCJzcmNcXG1vZGVsc1xcbW9kZWxzLmpzIiwic3JjXFxtb2RlbHNcXG1vZGVscy5zZXJpZXMuanMiLCJzcmNcXG1vZGVsc1xcbW9kZWxzLnN0YWNrLmpzIiwic3JjXFxtb2RlbHNcXG1vZGVscy52b3hlbC5qcyIsInNyY1xccGFyc2Vyc1xccGFyc2Vycy5kaWNvbS5qcyIsInNyY1xccGFyc2Vyc1xccGFyc2Vycy5qcyIsInNyY1xccGFyc2Vyc1xccGFyc2Vycy5taGQuanMiLCJzcmNcXHBhcnNlcnNcXHBhcnNlcnMubmlmdGkuanMiLCJzcmNcXHBhcnNlcnNcXHBhcnNlcnMubnJyZC5qcyIsInNyY1xccGFyc2Vyc1xccGFyc2Vycy52b2x1bWUuanMiLCJzcmNcXHNoYWRlcnNcXGhlbHBlcnNcXHNoYWRlcnMuaGVscGVycy5pbnRlcnNlY3RCb3guanMiLCJzcmNcXHNoYWRlcnNcXGhlbHBlcnNcXHNoYWRlcnMuaGVscGVycy50ZXh0dXJlM2QuanMiLCJzcmNcXHNoYWRlcnNcXGhlbHBlcnNcXHNoYWRlcnMuaGVscGVycy51bnBhY2suanMiLCJzcmNcXHNoYWRlcnNcXGludGVycG9sYXRpb25cXHNoYWRlcnMuaW50ZXJwb2xhdGlvbi5pZGVudGl0eS5qcyIsInNyY1xcc2hhZGVyc1xcaW50ZXJwb2xhdGlvblxcc2hhZGVycy5pbnRlcnBvbGF0aW9uLmpzIiwic3JjXFxzaGFkZXJzXFxpbnRlcnBvbGF0aW9uXFxzaGFkZXJzLmludGVycG9sYXRpb24udHJpbGluZWFyLmpzIiwic3JjXFxzaGFkZXJzXFxzaGFkZXJzLmJhc2UuanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuY29udG91ci5mcmFnbWVudC5qcyIsInNyY1xcc2hhZGVyc1xcc2hhZGVycy5jb250b3VyLnVuaWZvcm0uanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuY29udG91ci52ZXJ0ZXguanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuZGF0YS5mcmFnbWVudC5qcyIsInNyY1xcc2hhZGVyc1xcc2hhZGVycy5kYXRhLnVuaWZvcm0uanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuZGF0YS52ZXJ0ZXguanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMubGF5ZXIuZnJhZ21lbnQuanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMubGF5ZXIudW5pZm9ybS5qcyIsInNyY1xcc2hhZGVyc1xcc2hhZGVycy5sYXllci52ZXJ0ZXguanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMubG9jYWxpemVyLmZyYWdtZW50LmpzIiwic3JjXFxzaGFkZXJzXFxzaGFkZXJzLmxvY2FsaXplci51bmlmb3JtLmpzIiwic3JjXFxzaGFkZXJzXFxzaGFkZXJzLmxvY2FsaXplci52ZXJ0ZXguanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMudnIuZnJhZ21lbnQuanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMudnIudW5pZm9ybS5qcyIsInNyY1xcc2hhZGVyc1xcc2hhZGVycy52ci52ZXJ0ZXguanMiLCJzcmNcXHdpZGdldHNcXHdpZGdldHMuYW5ub3RhdGlvbi5qcyIsInNyY1xcd2lkZ2V0c1xcd2lkZ2V0cy5iYXNlLmpzIiwic3JjXFx3aWRnZXRzXFx3aWRnZXRzLmJpcnVsZXIuanMiLCJzcmNcXHdpZGdldHNcXHdpZGdldHMuaGFuZGxlLmpzIiwic3JjXFx3aWRnZXRzXFx3aWRnZXRzLmpzIiwic3JjXFx3aWRnZXRzXFx3aWRnZXRzLnJvaS5qcyIsInNyY1xcd2lkZ2V0c1xcd2lkZ2V0cy5ydWxlci5qcyIsInNyY1xcd2lkZ2V0c1xcd2lkZ2V0cy52b3hlbFByb2JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy96REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzd2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5dENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzU2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtB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O3dCQUVpQjtBQUNoQixhQUFPLEtBQUssWUFBWjtBQUNEOzs7c0JBRWMsVSxFQUFZO0FBQ3pCLFdBQUssV0FBTCxHQUFtQixVQUFuQjtBQUNBLFdBQUssTUFBTDtBQUNELEs7d0JBRWdCO0FBQ2YsYUFBTyxLQUFLLFdBQVo7QUFDRDs7O3NCQUVpQixhLEVBQWU7QUFDL0IsV0FBSyxjQUFMLEdBQXNCLGFBQXRCO0FBQ0EsV0FBSyxNQUFMO0FBQ0QsSzt3QkFFbUI7QUFDbEIsYUFBTyxLQUFLLGNBQVo7QUFDRDs7O3NCQUVhLFMsRUFBVztBQUN2QixXQUFLLFVBQUwsR0FBa0IsU0FBbEI7QUFDQSxXQUFLLE1BQUw7QUFDRCxLO3dCQUVlO0FBQ2QsYUFBTyxLQUFLLFVBQVo7QUFDRDs7O3NCQUVjLFUsRUFBWTtBQUN6QixXQUFLLFdBQUwsR0FBbUIsVUFBbkI7QUFDQSxXQUFLLE1BQUw7QUFDRCxLO3dCQUVnQjtBQUNmLGFBQU8sS0FBSyxXQUFaO0FBQ0Q7OztzQkFFdUIsbUIsRUFBcUI7QUFDM0MsV0FBSyxvQkFBTCxHQUE0QixtQkFBNUI7QUFDQSxXQUFLLE1BQUw7QUFDRCxLO3dCQUV5QjtBQUN4QixhQUFPLEtBQUssb0JBQVo7QUFDRDs7Ozs7O2tCQW5ka0IsaUIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8ganNoaW50IGlnbm9yZTogc3RhcnRcclxuXHJcbi8qIC0qLSBNb2RlOiBKYXZhOyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotIC9cclxuIC8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cclxuLypcclxuIENvcHlyaWdodCAyMDExIG5vdG1hc3RlcnlldFxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8vIC0gVGhlIEpQRUcgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIElUVSBDQ0lUVCBSZWNvbW1lbmRhdGlvbiBULjgxXHJcbi8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9pdHUtdDgxLnBkZilcclxuLy8gLSBUaGUgSkZJRiBzcGVjaWZpY2F0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgSlBFRyBGaWxlIEludGVyY2hhbmdlIEZvcm1hdFxyXG4vLyAgICh3d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvamZpZjMucGRmKVxyXG4vLyAtIFRoZSBBZG9iZSBBcHBsaWNhdGlvbi1TcGVjaWZpYyBKUEVHIG1hcmtlcnMgaW4gdGhlIFN1cHBvcnRpbmcgdGhlIERDVCBGaWx0ZXJzXHJcbi8vICAgaW4gUG9zdFNjcmlwdCBMZXZlbCAyLCBUZWNobmljYWwgTm90ZSAjNTExNlxyXG4vLyAgIChwYXJ0bmVycy5hZG9iZS5jb20vcHVibGljL2RldmVsb3Blci9lbi9wcy9zZGsvNTExNi5EQ1RfRmlsdGVyLnBkZilcclxuXHJcbnZhciBDb2xvclNwYWNlID0ge1Vua293bjogMCwgR3JheXNjYWxlOiAxLCBBZG9iZVJHQjogMiwgUkdCOiAzLCBDWU1LOiA0fTtcclxudmFyIEpwZWdJbWFnZSA9IChmdW5jdGlvbiBqcGVnSW1hZ2UoKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgdmFyIGRjdFppZ1phZyA9IG5ldyBJbnQzMkFycmF5KFtcclxuICAgIDAsXHJcbiAgICAxLCA4LFxyXG4gICAgMTYsIDksIDIsXHJcbiAgICAzLCAxMCwgMTcsIDI0LFxyXG4gICAgMzIsIDI1LCAxOCwgMTEsIDQsXHJcbiAgICA1LCAxMiwgMTksIDI2LCAzMywgNDAsXHJcbiAgICA0OCwgNDEsIDM0LCAyNywgMjAsIDEzLCA2LFxyXG4gICAgNywgMTQsIDIxLCAyOCwgMzUsIDQyLCA0OSwgNTYsXHJcbiAgICA1NywgNTAsIDQzLCAzNiwgMjksIDIyLCAxNSxcclxuICAgIDIzLCAzMCwgMzcsIDQ0LCA1MSwgNTgsXHJcbiAgICA1OSwgNTIsIDQ1LCAzOCwgMzEsXHJcbiAgICAzOSwgNDYsIDUzLCA2MCxcclxuICAgIDYxLCA1NCwgNDcsXHJcbiAgICA1NSwgNjIsXHJcbiAgICA2M1xyXG4gIF0pO1xyXG5cclxuICB2YXIgZGN0Q29zMSA9IDQwMTc7ICAgLy8gY29zKHBpLzE2KVxyXG4gIHZhciBkY3RTaW4xID0gNzk5OyAgIC8vIHNpbihwaS8xNilcclxuICB2YXIgZGN0Q29zMyA9IDM0MDY7ICAgLy8gY29zKDMqcGkvMTYpXHJcbiAgdmFyIGRjdFNpbjMgPSAyMjc2OyAgIC8vIHNpbigzKnBpLzE2KVxyXG4gIHZhciBkY3RDb3M2ID0gMTU2NzsgICAvLyBjb3MoNipwaS8xNilcclxuICB2YXIgZGN0U2luNiA9IDM3ODQ7ICAgLy8gc2luKDYqcGkvMTYpXHJcbiAgdmFyIGRjdFNxcnQyID0gNTc5MzsgICAvLyBzcXJ0KDIpXHJcbiAgdmFyIGRjdFNxcnQxZDIgPSAyODk2OyAgLy8gc3FydCgyKSAvIDJcclxuXHJcbiAgZnVuY3Rpb24gY29uc3RydWN0b3IoKSB7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgdmFsdWVzKSB7XHJcbiAgICB2YXIgayA9IDAsIGNvZGUgPSBbXSwgaSwgaiwgbGVuZ3RoID0gMTY7XHJcbiAgICB3aGlsZSAobGVuZ3RoID4gMCAmJiAhY29kZUxlbmd0aHNbbGVuZ3RoIC0gMV0pXHJcbiAgICAgIGxlbmd0aC0tO1xyXG4gICAgY29kZS5wdXNoKHtjaGlsZHJlbjogW10sIGluZGV4OiAwfSk7XHJcbiAgICB2YXIgcCA9IGNvZGVbMF0sIHE7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgZm9yIChqID0gMDsgaiA8IGNvZGVMZW5ndGhzW2ldOyBqKyspIHtcclxuICAgICAgICBwID0gY29kZS5wb3AoKTtcclxuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gdmFsdWVzW2tdO1xyXG4gICAgICAgIHdoaWxlIChwLmluZGV4ID4gMCkge1xyXG4gICAgICAgICAgcCA9IGNvZGUucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHAuaW5kZXgrKztcclxuICAgICAgICBjb2RlLnB1c2gocCk7XHJcbiAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDw9IGkpIHtcclxuICAgICAgICAgIGNvZGUucHVzaChxID0ge2NoaWxkcmVuOiBbXSwgaW5kZXg6IDB9KTtcclxuICAgICAgICAgIHAuY2hpbGRyZW5bcC5pbmRleF0gPSBxLmNoaWxkcmVuO1xyXG4gICAgICAgICAgcCA9IHE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGsrKztcclxuICAgICAgfVxyXG4gICAgICBpZiAoaSArIDEgPCBsZW5ndGgpIHtcclxuICAgICAgICAvLyBwIGhlcmUgcG9pbnRzIHRvIGxhc3QgY29kZVxyXG4gICAgICAgIGNvZGUucHVzaChxID0ge2NoaWxkcmVuOiBbXSwgaW5kZXg6IDB9KTtcclxuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcclxuICAgICAgICBwID0gcTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvZGVbMF0uY2hpbGRyZW47XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIHJvdywgY29sKSB7XHJcbiAgICByZXR1cm4gNjQgKiAoKGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lICsgMSkgKiByb3cgKyBjb2wpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICBmcmFtZSwgY29tcG9uZW50cywgcmVzZXRJbnRlcnZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgIHNwZWN0cmFsU3RhcnQsIHNwZWN0cmFsRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZVByZXYsIHN1Y2Nlc3NpdmUpIHtcclxuICAgIHZhciBwcmVjaXNpb24gPSBmcmFtZS5wcmVjaXNpb247XHJcbiAgICB2YXIgc2FtcGxlc1BlckxpbmUgPSBmcmFtZS5zYW1wbGVzUGVyTGluZTtcclxuICAgIHZhciBzY2FuTGluZXMgPSBmcmFtZS5zY2FuTGluZXM7XHJcbiAgICB2YXIgbWN1c1BlckxpbmUgPSBmcmFtZS5tY3VzUGVyTGluZTtcclxuICAgIHZhciBwcm9ncmVzc2l2ZSA9IGZyYW1lLnByb2dyZXNzaXZlO1xyXG4gICAgdmFyIG1heEggPSBmcmFtZS5tYXhILCBtYXhWID0gZnJhbWUubWF4VjtcclxuXHJcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQsIGJpdHNEYXRhID0gMCwgYml0c0NvdW50ID0gMDtcclxuXHJcbiAgICBmdW5jdGlvbiByZWFkQml0KCkge1xyXG4gICAgICBpZiAoYml0c0NvdW50ID4gMCkge1xyXG4gICAgICAgIGJpdHNDb3VudC0tO1xyXG4gICAgICAgIHJldHVybiAoYml0c0RhdGEgPj4gYml0c0NvdW50KSAmIDE7XHJcbiAgICAgIH1cclxuICAgICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgaWYgKGJpdHNEYXRhID09IDB4RkYpIHtcclxuICAgICAgICB2YXIgbmV4dEJ5dGUgPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICBpZiAobmV4dEJ5dGUpIHtcclxuICAgICAgICAgIHRocm93IFwidW5leHBlY3RlZCBtYXJrZXI6IFwiICsgKChiaXRzRGF0YSA8PCA4KSB8IG5leHRCeXRlKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVuc3R1ZmYgMFxyXG4gICAgICB9XHJcbiAgICAgIGJpdHNDb3VudCA9IDc7XHJcbiAgICAgIHJldHVybiBiaXRzRGF0YSA+Pj4gNztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNvZGVIdWZmbWFuKHRyZWUpIHtcclxuICAgICAgdmFyIG5vZGUgPSB0cmVlO1xyXG4gICAgICB2YXIgYml0O1xyXG4gICAgICB3aGlsZSAoKGJpdCA9IHJlYWRCaXQoKSkgIT09IG51bGwpIHtcclxuICAgICAgICBub2RlID0gbm9kZVtiaXRdO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgdGhyb3cgXCJpbnZhbGlkIGh1ZmZtYW4gc2VxdWVuY2VcIjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWNlaXZlKGxlbmd0aCkge1xyXG4gICAgICB2YXIgbiA9IDA7XHJcbiAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIGJpdCA9IHJlYWRCaXQoKTtcclxuICAgICAgICBpZiAoYml0ID09PSBudWxsKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIG4gPSAobiA8PCAxKSB8IGJpdDtcclxuICAgICAgICBsZW5ndGgtLTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWNlaXZlQW5kRXh0ZW5kKGxlbmd0aCkge1xyXG4gICAgICB2YXIgbiA9IHJlY2VpdmUobGVuZ3RoKTtcclxuICAgICAgaWYgKG4gPj0gMSA8PCAobGVuZ3RoIC0gMSkpXHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgIHJldHVybiBuICsgKC0xIDw8IGxlbmd0aCkgKyAxO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGNvbXBvbmVudCwgb2Zmc2V0KSB7XHJcbiAgICAgIHZhciB0ID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlREMpO1xyXG4gICAgICB2YXIgZGlmZiA9IHQgPT09IDAgPyAwIDogcmVjZWl2ZUFuZEV4dGVuZCh0KTtcclxuICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXRdID0gKGNvbXBvbmVudC5wcmVkICs9IGRpZmYpO1xyXG4gICAgICB2YXIgayA9IDE7XHJcbiAgICAgIHdoaWxlIChrIDwgNjQpIHtcclxuICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XHJcbiAgICAgICAgdmFyIHMgPSBycyAmIDE1LCByID0gcnMgPj4gNDtcclxuICAgICAgICBpZiAocyA9PT0gMCkge1xyXG4gICAgICAgICAgaWYgKHIgPCAxNSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBrICs9IDE2O1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGsgKz0gcjtcclxuICAgICAgICB2YXIgeiA9IGRjdFppZ1phZ1trXTtcclxuICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcclxuICAgICAgICBrKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNvZGVEQ0ZpcnN0KGNvbXBvbmVudCwgb2Zmc2V0KSB7XHJcbiAgICAgIHZhciB0ID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlREMpO1xyXG4gICAgICB2YXIgZGlmZiA9IHQgPT09IDAgPyAwIDogKHJlY2VpdmVBbmRFeHRlbmQodCkgPDwgc3VjY2Vzc2l2ZSk7XHJcbiAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0XSA9IChjb21wb25lbnQucHJlZCArPSBkaWZmKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNvZGVEQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCBvZmZzZXQpIHtcclxuICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXRdIHw9IHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlb2JydW4gPSAwO1xyXG4gICAgZnVuY3Rpb24gZGVjb2RlQUNGaXJzdChjb21wb25lbnQsIG9mZnNldCkge1xyXG4gICAgICBpZiAoZW9icnVuID4gMCkge1xyXG4gICAgICAgIGVvYnJ1bi0tO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgayA9IHNwZWN0cmFsU3RhcnQsIGUgPSBzcGVjdHJhbEVuZDtcclxuICAgICAgd2hpbGUgKGsgPD0gZSkge1xyXG4gICAgICAgIHZhciBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcclxuICAgICAgICB2YXIgcyA9IHJzICYgMTUsIHIgPSBycyA+PiA0O1xyXG4gICAgICAgIGlmIChzID09PSAwKSB7XHJcbiAgICAgICAgICBpZiAociA8IDE1KSB7XHJcbiAgICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKSAtIDE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgayArPSAxNjtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrICs9IHI7XHJcbiAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XHJcbiAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSA9IHJlY2VpdmVBbmRFeHRlbmQocykgKiAoMSA8PCBzdWNjZXNzaXZlKTtcclxuICAgICAgICBrKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwLCBzdWNjZXNzaXZlQUNOZXh0VmFsdWU7XHJcbiAgICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCBvZmZzZXQpIHtcclxuICAgICAgdmFyIGsgPSBzcGVjdHJhbFN0YXJ0LCBlID0gc3BlY3RyYWxFbmQsIHIgPSAwO1xyXG4gICAgICB3aGlsZSAoayA8PSBlKSB7XHJcbiAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XHJcbiAgICAgICAgc3dpdGNoIChzdWNjZXNzaXZlQUNTdGF0ZSkge1xyXG4gICAgICAgICAgY2FzZSAwOiAvLyBpbml0aWFsIHN0YXRlXHJcbiAgICAgICAgICAgIHZhciBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcclxuICAgICAgICAgICAgdmFyIHMgPSBycyAmIDE1O1xyXG4gICAgICAgICAgICByID0gcnMgPj4gNDtcclxuICAgICAgICAgICAgaWYgKHMgPT09IDApIHtcclxuICAgICAgICAgICAgICBpZiAociA8IDE1KSB7XHJcbiAgICAgICAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcik7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDQ7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHIgPSAxNjtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKHMgIT09IDEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcImludmFsaWQgQUNuIGVuY29kaW5nXCI7XHJcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcclxuICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IHIgPyAyIDogMztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIGNhc2UgMTogLy8gc2tpcHBpbmcgciB6ZXJvIGl0ZW1zXHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdKSB7XHJcbiAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHItLTtcclxuICAgICAgICAgICAgICBpZiAociA9PT0gMClcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gc3VjY2Vzc2l2ZUFDU3RhdGUgPT0gMiA/IDMgOiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAzOiAvLyBzZXQgdmFsdWUgZm9yIGEgemVybyBpdGVtXHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdKSB7XHJcbiAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gPSBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPDwgc3VjY2Vzc2l2ZTtcclxuICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDQ6IC8vIGVvYlxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSkge1xyXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaysrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdWNjZXNzaXZlQUNTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgIGVvYnJ1bi0tO1xyXG4gICAgICAgIGlmIChlb2JydW4gPT09IDApXHJcbiAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGUsIG1jdSwgcm93LCBjb2wpIHtcclxuICAgICAgdmFyIG1jdVJvdyA9IChtY3UgLyBtY3VzUGVyTGluZSkgfCAwO1xyXG4gICAgICB2YXIgbWN1Q29sID0gbWN1ICUgbWN1c1BlckxpbmU7XHJcbiAgICAgIHZhciBibG9ja1JvdyA9IG1jdVJvdyAqIGNvbXBvbmVudC52ICsgcm93O1xyXG4gICAgICB2YXIgYmxvY2tDb2wgPSBtY3VDb2wgKiBjb21wb25lbnQuaCArIGNvbDtcclxuICAgICAgdmFyIG9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcclxuICAgICAgZGVjb2RlKGNvbXBvbmVudCwgb2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZSwgbWN1KSB7XHJcbiAgICAgIHZhciBibG9ja1JvdyA9IChtY3UgLyBjb21wb25lbnQuYmxvY2tzUGVyTGluZSkgfCAwO1xyXG4gICAgICB2YXIgYmxvY2tDb2wgPSBtY3UgJSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcclxuICAgICAgdmFyIG9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcclxuICAgICAgZGVjb2RlKGNvbXBvbmVudCwgb2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29tcG9uZW50c0xlbmd0aCA9IGNvbXBvbmVudHMubGVuZ3RoO1xyXG4gICAgdmFyIGNvbXBvbmVudCwgaSwgaiwgaywgbjtcclxuICAgIHZhciBkZWNvZGVGbjtcclxuICAgIGlmIChwcm9ncmVzc2l2ZSkge1xyXG4gICAgICBpZiAoc3BlY3RyYWxTdGFydCA9PT0gMClcclxuICAgICAgICBkZWNvZGVGbiA9IHN1Y2Nlc3NpdmVQcmV2ID09PSAwID8gZGVjb2RlRENGaXJzdCA6IGRlY29kZURDU3VjY2Vzc2l2ZTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVBQ0ZpcnN0IDogZGVjb2RlQUNTdWNjZXNzaXZlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGVjb2RlRm4gPSBkZWNvZGVCYXNlbGluZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWN1ID0gMCwgbWFya2VyO1xyXG4gICAgdmFyIG1jdUV4cGVjdGVkO1xyXG4gICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT0gMSkge1xyXG4gICAgICBtY3VFeHBlY3RlZCA9IGNvbXBvbmVudHNbMF0uYmxvY2tzUGVyTGluZSAqIGNvbXBvbmVudHNbMF0uYmxvY2tzUGVyQ29sdW1uO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWN1RXhwZWN0ZWQgPSBtY3VzUGVyTGluZSAqIGZyYW1lLm1jdXNQZXJDb2x1bW47XHJcbiAgICB9XHJcbiAgICBpZiAoIXJlc2V0SW50ZXJ2YWwpIHtcclxuICAgICAgcmVzZXRJbnRlcnZhbCA9IG1jdUV4cGVjdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBoLCB2O1xyXG4gICAgd2hpbGUgKG1jdSA8IG1jdUV4cGVjdGVkKSB7XHJcbiAgICAgIC8vIHJlc2V0IGludGVydmFsIHN0dWZmXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGVvYnJ1biA9IDA7XHJcblxyXG4gICAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1swXTtcclxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgcmVzZXRJbnRlcnZhbDsgbisrKSB7XHJcbiAgICAgICAgICBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZuLCBtY3UpO1xyXG4gICAgICAgICAgbWN1Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCByZXNldEludGVydmFsOyBuKyspIHtcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcclxuICAgICAgICAgICAgaCA9IGNvbXBvbmVudC5oO1xyXG4gICAgICAgICAgICB2ID0gY29tcG9uZW50LnY7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2OyBqKyspIHtcclxuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1LCBqLCBrKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG1jdSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmluZCBtYXJrZXJcclxuICAgICAgYml0c0NvdW50ID0gMDtcclxuICAgICAgbWFya2VyID0gKGRhdGFbb2Zmc2V0XSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMV07XHJcbiAgICAgIGlmIChtYXJrZXIgPD0gMHhGRjAwKSB7XHJcbiAgICAgICAgdGhyb3cgXCJtYXJrZXIgd2FzIG5vdCBmb3VuZFwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobWFya2VyID49IDB4RkZEMCAmJiBtYXJrZXIgPD0gMHhGRkQ3KSB7IC8vIFJTVHhcclxuICAgICAgICBvZmZzZXQgKz0gMjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydE9mZnNldDtcclxuICB9XHJcblxyXG4gIC8vIEEgcG9ydCBvZiBwb3BwbGVyJ3MgSURDVCBtZXRob2Qgd2hpY2ggaW4gdHVybiBpcyB0YWtlbiBmcm9tOlxyXG4gIC8vICAgQ2hyaXN0b3BoIExvZWZmbGVyLCBBZHJpYWFuIExpZ3RlbmJlcmcsIEdlb3JnZSBTLiBNb3NjaHl0eixcclxuICAvLyAgIFwiUHJhY3RpY2FsIEZhc3QgMS1EIERDVCBBbGdvcml0aG1zIHdpdGggMTEgTXVsdGlwbGljYXRpb25zXCIsXHJcbiAgLy8gICBJRUVFIEludGwuIENvbmYuIG9uIEFjb3VzdGljcywgU3BlZWNoICYgU2lnbmFsIFByb2Nlc3NpbmcsIDE5ODksXHJcbiAgLy8gICA5ODgtOTkxLlxyXG4gIGZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZShjb21wb25lbnQsIGJsb2NrQnVmZmVyT2Zmc2V0LCBwKSB7XHJcbiAgICB2YXIgcXQgPSBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGU7XHJcbiAgICB2YXIgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB0O1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgLy8gZGVxdWFudFxyXG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcclxuICAgICAgcFtpXSA9IGNvbXBvbmVudC5ibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBpXSAqIHF0W2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGludmVyc2UgRENUIG9uIHJvd3NcclxuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcclxuICAgICAgdmFyIHJvdyA9IDggKiBpO1xyXG5cclxuICAgICAgLy8gY2hlY2sgZm9yIGFsbC16ZXJvIEFDIGNvZWZmaWNpZW50c1xyXG4gICAgICBpZiAocFsxICsgcm93XSA9PT0gMCAmJiBwWzIgKyByb3ddID09PSAwICYmIHBbMyArIHJvd10gPT09IDAgJiZcclxuICAgICAgICBwWzQgKyByb3ddID09PSAwICYmIHBbNSArIHJvd10gPT09IDAgJiYgcFs2ICsgcm93XSA9PT0gMCAmJlxyXG4gICAgICAgIHBbNyArIHJvd10gPT09IDApIHtcclxuICAgICAgICB0ID0gKGRjdFNxcnQyICogcFswICsgcm93XSArIDUxMikgPj4gMTA7XHJcbiAgICAgICAgcFswICsgcm93XSA9IHQ7XHJcbiAgICAgICAgcFsxICsgcm93XSA9IHQ7XHJcbiAgICAgICAgcFsyICsgcm93XSA9IHQ7XHJcbiAgICAgICAgcFszICsgcm93XSA9IHQ7XHJcbiAgICAgICAgcFs0ICsgcm93XSA9IHQ7XHJcbiAgICAgICAgcFs1ICsgcm93XSA9IHQ7XHJcbiAgICAgICAgcFs2ICsgcm93XSA9IHQ7XHJcbiAgICAgICAgcFs3ICsgcm93XSA9IHQ7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHN0YWdlIDRcclxuICAgICAgdjAgPSAoZGN0U3FydDIgKiBwWzAgKyByb3ddICsgMTI4KSA+PiA4O1xyXG4gICAgICB2MSA9IChkY3RTcXJ0MiAqIHBbNCArIHJvd10gKyAxMjgpID4+IDg7XHJcbiAgICAgIHYyID0gcFsyICsgcm93XTtcclxuICAgICAgdjMgPSBwWzYgKyByb3ddO1xyXG4gICAgICB2NCA9IChkY3RTcXJ0MWQyICogKHBbMSArIHJvd10gLSBwWzcgKyByb3ddKSArIDEyOCkgPj4gODtcclxuICAgICAgdjcgPSAoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddICsgcFs3ICsgcm93XSkgKyAxMjgpID4+IDg7XHJcbiAgICAgIHY1ID0gcFszICsgcm93XSA8PCA0O1xyXG4gICAgICB2NiA9IHBbNSArIHJvd10gPDwgNDtcclxuXHJcbiAgICAgIC8vIHN0YWdlIDNcclxuICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcclxuICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XHJcbiAgICAgIHYxID0gdDtcclxuICAgICAgdCA9ICh2MiAqIGRjdFNpbjYgKyB2MyAqIGRjdENvczYgKyAxMjgpID4+IDg7XHJcbiAgICAgIHYyID0gKHYyICogZGN0Q29zNiAtIHYzICogZGN0U2luNiArIDEyOCkgPj4gODtcclxuICAgICAgdjMgPSB0O1xyXG4gICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xyXG4gICAgICB2NCA9ICh2NCArIHY2ICsgMSkgPj4gMTtcclxuICAgICAgdjYgPSB0O1xyXG4gICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xyXG4gICAgICB2NSA9ICh2NyAtIHY1ICsgMSkgPj4gMTtcclxuICAgICAgdjcgPSB0O1xyXG5cclxuICAgICAgLy8gc3RhZ2UgMlxyXG4gICAgICB0ID0gKHYwIC0gdjMgKyAxKSA+PiAxO1xyXG4gICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcclxuICAgICAgdjMgPSB0O1xyXG4gICAgICB0ID0gKHYxIC0gdjIgKyAxKSA+PiAxO1xyXG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcclxuICAgICAgdjIgPSB0O1xyXG4gICAgICB0ID0gKHY0ICogZGN0U2luMyArIHY3ICogZGN0Q29zMyArIDIwNDgpID4+IDEyO1xyXG4gICAgICB2NCA9ICh2NCAqIGRjdENvczMgLSB2NyAqIGRjdFNpbjMgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjcgPSB0O1xyXG4gICAgICB0ID0gKHY1ICogZGN0U2luMSArIHY2ICogZGN0Q29zMSArIDIwNDgpID4+IDEyO1xyXG4gICAgICB2NSA9ICh2NSAqIGRjdENvczEgLSB2NiAqIGRjdFNpbjEgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjYgPSB0O1xyXG5cclxuICAgICAgLy8gc3RhZ2UgMVxyXG4gICAgICBwWzAgKyByb3ddID0gdjAgKyB2NztcclxuICAgICAgcFs3ICsgcm93XSA9IHYwIC0gdjc7XHJcbiAgICAgIHBbMSArIHJvd10gPSB2MSArIHY2O1xyXG4gICAgICBwWzYgKyByb3ddID0gdjEgLSB2NjtcclxuICAgICAgcFsyICsgcm93XSA9IHYyICsgdjU7XHJcbiAgICAgIHBbNSArIHJvd10gPSB2MiAtIHY1O1xyXG4gICAgICBwWzMgKyByb3ddID0gdjMgKyB2NDtcclxuICAgICAgcFs0ICsgcm93XSA9IHYzIC0gdjQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW52ZXJzZSBEQ1Qgb24gY29sdW1uc1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xyXG4gICAgICB2YXIgY29sID0gaTtcclxuXHJcbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcclxuICAgICAgaWYgKHBbMSAqIDggKyBjb2xdID09PSAwICYmIHBbMiAqIDggKyBjb2xdID09PSAwICYmIHBbMyAqIDggKyBjb2xdID09PSAwICYmXHJcbiAgICAgICAgcFs0ICogOCArIGNvbF0gPT09IDAgJiYgcFs1ICogOCArIGNvbF0gPT09IDAgJiYgcFs2ICogOCArIGNvbF0gPT09IDAgJiZcclxuICAgICAgICBwWzcgKiA4ICsgY29sXSA9PT0gMCkge1xyXG4gICAgICAgIHQgPSAoZGN0U3FydDIgKiBwW2kgKyAwXSArIDgxOTIpID4+IDE0O1xyXG4gICAgICAgIHBbMCAqIDggKyBjb2xdID0gdDtcclxuICAgICAgICBwWzEgKiA4ICsgY29sXSA9IHQ7XHJcbiAgICAgICAgcFsyICogOCArIGNvbF0gPSB0O1xyXG4gICAgICAgIHBbMyAqIDggKyBjb2xdID0gdDtcclxuICAgICAgICBwWzQgKiA4ICsgY29sXSA9IHQ7XHJcbiAgICAgICAgcFs1ICogOCArIGNvbF0gPSB0O1xyXG4gICAgICAgIHBbNiAqIDggKyBjb2xdID0gdDtcclxuICAgICAgICBwWzcgKiA4ICsgY29sXSA9IHQ7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHN0YWdlIDRcclxuICAgICAgdjAgPSAoZGN0U3FydDIgKiBwWzAgKiA4ICsgY29sXSArIDIwNDgpID4+IDEyO1xyXG4gICAgICB2MSA9IChkY3RTcXJ0MiAqIHBbNCAqIDggKyBjb2xdICsgMjA0OCkgPj4gMTI7XHJcbiAgICAgIHYyID0gcFsyICogOCArIGNvbF07XHJcbiAgICAgIHYzID0gcFs2ICogOCArIGNvbF07XHJcbiAgICAgIHY0ID0gKGRjdFNxcnQxZDIgKiAocFsxICogOCArIGNvbF0gLSBwWzcgKiA4ICsgY29sXSkgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjcgPSAoZGN0U3FydDFkMiAqIChwWzEgKiA4ICsgY29sXSArIHBbNyAqIDggKyBjb2xdKSArIDIwNDgpID4+IDEyO1xyXG4gICAgICB2NSA9IHBbMyAqIDggKyBjb2xdO1xyXG4gICAgICB2NiA9IHBbNSAqIDggKyBjb2xdO1xyXG5cclxuICAgICAgLy8gc3RhZ2UgM1xyXG4gICAgICB0ID0gKHYwIC0gdjEgKyAxKSA+PiAxO1xyXG4gICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTtcclxuICAgICAgdjEgPSB0O1xyXG4gICAgICB0ID0gKHYyICogZGN0U2luNiArIHYzICogZGN0Q29zNiArIDIwNDgpID4+IDEyO1xyXG4gICAgICB2MiA9ICh2MiAqIGRjdENvczYgLSB2MyAqIGRjdFNpbjYgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjMgPSB0O1xyXG4gICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xyXG4gICAgICB2NCA9ICh2NCArIHY2ICsgMSkgPj4gMTtcclxuICAgICAgdjYgPSB0O1xyXG4gICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xyXG4gICAgICB2NSA9ICh2NyAtIHY1ICsgMSkgPj4gMTtcclxuICAgICAgdjcgPSB0O1xyXG5cclxuICAgICAgLy8gc3RhZ2UgMlxyXG4gICAgICB0ID0gKHYwIC0gdjMgKyAxKSA+PiAxO1xyXG4gICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcclxuICAgICAgdjMgPSB0O1xyXG4gICAgICB0ID0gKHYxIC0gdjIgKyAxKSA+PiAxO1xyXG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcclxuICAgICAgdjIgPSB0O1xyXG4gICAgICB0ID0gKHY0ICogZGN0U2luMyArIHY3ICogZGN0Q29zMyArIDIwNDgpID4+IDEyO1xyXG4gICAgICB2NCA9ICh2NCAqIGRjdENvczMgLSB2NyAqIGRjdFNpbjMgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjcgPSB0O1xyXG4gICAgICB0ID0gKHY1ICogZGN0U2luMSArIHY2ICogZGN0Q29zMSArIDIwNDgpID4+IDEyO1xyXG4gICAgICB2NSA9ICh2NSAqIGRjdENvczEgLSB2NiAqIGRjdFNpbjEgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjYgPSB0O1xyXG5cclxuICAgICAgLy8gc3RhZ2UgMVxyXG4gICAgICBwWzAgKiA4ICsgY29sXSA9IHYwICsgdjc7XHJcbiAgICAgIHBbNyAqIDggKyBjb2xdID0gdjAgLSB2NztcclxuICAgICAgcFsxICogOCArIGNvbF0gPSB2MSArIHY2O1xyXG4gICAgICBwWzYgKiA4ICsgY29sXSA9IHYxIC0gdjY7XHJcbiAgICAgIHBbMiAqIDggKyBjb2xdID0gdjIgKyB2NTtcclxuICAgICAgcFs1ICogOCArIGNvbF0gPSB2MiAtIHY1O1xyXG4gICAgICBwWzMgKiA4ICsgY29sXSA9IHYzICsgdjQ7XHJcbiAgICAgIHBbNCAqIDggKyBjb2xdID0gdjMgLSB2NDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb252ZXJ0IHRvIDgtYml0IGludGVnZXJzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7ICsraSkge1xyXG4gICAgICB2YXIgaW5kZXggPSBibG9ja0J1ZmZlck9mZnNldCArIGk7XHJcbiAgICAgIHZhciBxID0gcFtpXTtcclxuICAgICAgcSA9IChxIDw9IC0yMDU2IC8gY29tcG9uZW50LmJpdENvbnZlcnNpb24pID8gMCA6XHJcbiAgICAgICAgKHEgPj0gMjAyNCAvIGNvbXBvbmVudC5iaXRDb252ZXJzaW9uKSA/IDI1NSAvIGNvbXBvbmVudC5iaXRDb252ZXJzaW9uIDpcclxuICAgICAgICAocSArIDIwNTYgLyBjb21wb25lbnQuYml0Q29udmVyc2lvbikgPj4gNDtcclxuICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtpbmRleF0gPSBxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpIHtcclxuICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgdmFyIGJsb2Nrc1BlckxpbmUgPSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcclxuICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uO1xyXG4gICAgdmFyIHNhbXBsZXNQZXJMaW5lID0gYmxvY2tzUGVyTGluZSA8PCAzO1xyXG4gICAgdmFyIGNvbXB1dGF0aW9uQnVmZmVyID0gbmV3IEludDMyQXJyYXkoNjQpO1xyXG5cclxuICAgIHZhciBpLCBqLCBsbCA9IDA7XHJcbiAgICBmb3IgKHZhciBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XHJcbiAgICAgIGZvciAodmFyIGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcclxuICAgICAgICBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LCBvZmZzZXQsIGNvbXB1dGF0aW9uQnVmZmVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBvbmVudC5ibG9ja0RhdGE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbGFtcFRvVWludDgoYSkge1xyXG4gICAgcmV0dXJuIGEgPD0gMCA/IDAgOiBhID49IDI1NSA/IDI1NSA6IGEgfCAwO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0ge1xyXG4gICAgbG9hZDogZnVuY3Rpb24gbG9hZChwYXRoKSB7XHJcbiAgICAgIHZhciBoYW5kbGVEYXRhID0gKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZShkYXRhKTtcclxuICAgICAgICBpZiAodGhpcy5vbmxvYWQpXHJcbiAgICAgICAgICB0aGlzLm9ubG9hZCgpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgaWYgKHBhdGguaW5kZXhPZihcImRhdGE6XCIpID4gLTEpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gcGF0aC5pbmRleE9mKFwiYmFzZTY0LFwiKSArIDc7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBhdG9iKHBhdGguc3Vic3RyaW5nKG9mZnNldCkpO1xyXG4gICAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFuZGxlRGF0YShkYXRhKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICB4aHIub25sb2FkID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIC8vIFRPRE8gY2F0Y2ggcGFyc2UgZXJyb3JcclxuICAgICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcclxuICAgICAgICAgIGhhbmRsZURhdGEoZGF0YSk7XHJcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcclxuICAgICAgICB4aHIuc2VuZChudWxsKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShkYXRhKSB7XHJcblxyXG4gICAgICBmdW5jdGlvbiByZWFkVWludDE2KCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xyXG4gICAgICAgIG9mZnNldCArPSAyO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gcmVhZERhdGFCbG9jaygpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gcmVhZFVpbnQxNigpO1xyXG4gICAgICAgIHZhciBhcnJheSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGggLSAyKTtcclxuICAgICAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpIHtcclxuICAgICAgICB2YXIgbWN1c1BlckxpbmUgPSBNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4IC8gZnJhbWUubWF4SCk7XHJcbiAgICAgICAgdmFyIG1jdXNQZXJDb2x1bW4gPSBNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCAvIGZyYW1lLm1heFYpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUuY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tpXTtcclxuICAgICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDgpICogY29tcG9uZW50LmggLyBmcmFtZS5tYXhIKTtcclxuICAgICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDgpICogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWKTtcclxuICAgICAgICAgIHZhciBibG9ja3NQZXJMaW5lRm9yTWN1ID0gbWN1c1BlckxpbmUgKiBjb21wb25lbnQuaDtcclxuICAgICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW5Gb3JNY3UgPSBtY3VzUGVyQ29sdW1uICogY29tcG9uZW50LnY7XHJcblxyXG4gICAgICAgICAgdmFyIGJsb2Nrc0J1ZmZlclNpemUgPSA2NCAqIGJsb2Nrc1BlckNvbHVtbkZvck1jdSAqIChibG9ja3NQZXJMaW5lRm9yTWN1ICsgMSk7XHJcbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhID0gbmV3IEludDE2QXJyYXkoYmxvY2tzQnVmZmVyU2l6ZSk7XHJcbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmU7XHJcbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uID0gYmxvY2tzUGVyQ29sdW1uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmcmFtZS5tY3VzUGVyTGluZSA9IG1jdXNQZXJMaW5lO1xyXG4gICAgICAgIGZyYW1lLm1jdXNQZXJDb2x1bW4gPSBtY3VzUGVyQ29sdW1uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgIHZhciBqZmlmID0gbnVsbDtcclxuICAgICAgdmFyIGFkb2JlID0gbnVsbDtcclxuICAgICAgdmFyIHBpeGVscyA9IG51bGw7XHJcbiAgICAgIHZhciBmcmFtZSwgcmVzZXRJbnRlcnZhbDtcclxuICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlcyA9IFtdO1xyXG4gICAgICB2YXIgaHVmZm1hblRhYmxlc0FDID0gW10sIGh1ZmZtYW5UYWJsZXNEQyA9IFtdO1xyXG4gICAgICB2YXIgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcclxuICAgICAgaWYgKGZpbGVNYXJrZXIgIT0gMHhGRkQ4KSB7IC8vIFNPSSAoU3RhcnQgb2YgSW1hZ2UpXHJcbiAgICAgICAgdGhyb3cgXCJTT0kgbm90IGZvdW5kXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XHJcbiAgICAgIHdoaWxlIChmaWxlTWFya2VyICE9IDB4RkZEOSkgeyAvLyBFT0kgKEVuZCBvZiBpbWFnZSlcclxuICAgICAgICB2YXIgaSwgaiwgbDtcclxuICAgICAgICBzd2l0Y2ggKGZpbGVNYXJrZXIpIHtcclxuICAgICAgICAgIGNhc2UgMHhGRkUwOiAvLyBBUFAwIChBcHBsaWNhdGlvbiBTcGVjaWZpYylcclxuICAgICAgICAgIGNhc2UgMHhGRkUxOiAvLyBBUFAxXHJcbiAgICAgICAgICBjYXNlIDB4RkZFMjogLy8gQVBQMlxyXG4gICAgICAgICAgY2FzZSAweEZGRTM6IC8vIEFQUDNcclxuICAgICAgICAgIGNhc2UgMHhGRkU0OiAvLyBBUFA0XHJcbiAgICAgICAgICBjYXNlIDB4RkZFNTogLy8gQVBQNVxyXG4gICAgICAgICAgY2FzZSAweEZGRTY6IC8vIEFQUDZcclxuICAgICAgICAgIGNhc2UgMHhGRkU3OiAvLyBBUFA3XHJcbiAgICAgICAgICBjYXNlIDB4RkZFODogLy8gQVBQOFxyXG4gICAgICAgICAgY2FzZSAweEZGRTk6IC8vIEFQUDlcclxuICAgICAgICAgIGNhc2UgMHhGRkVBOiAvLyBBUFAxMFxyXG4gICAgICAgICAgY2FzZSAweEZGRUI6IC8vIEFQUDExXHJcbiAgICAgICAgICBjYXNlIDB4RkZFQzogLy8gQVBQMTJcclxuICAgICAgICAgIGNhc2UgMHhGRkVEOiAvLyBBUFAxM1xyXG4gICAgICAgICAgY2FzZSAweEZGRUU6IC8vIEFQUDE0XHJcbiAgICAgICAgICBjYXNlIDB4RkZFRjogLy8gQVBQMTVcclxuICAgICAgICAgIGNhc2UgMHhGRkZFOiAvLyBDT00gKENvbW1lbnQpXHJcbiAgICAgICAgICAgIHZhciBhcHBEYXRhID0gcmVhZERhdGFCbG9jaygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFMCkge1xyXG4gICAgICAgICAgICAgIGlmIChhcHBEYXRhWzBdID09PSAweDRBICYmIGFwcERhdGFbMV0gPT09IDB4NDYgJiYgYXBwRGF0YVsyXSA9PT0gMHg0OSAmJlxyXG4gICAgICAgICAgICAgICAgYXBwRGF0YVszXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzRdID09PSAwKSB7IC8vICdKRklGXFx4MDAnXHJcbiAgICAgICAgICAgICAgICBqZmlmID0ge1xyXG4gICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB7bWFqb3I6IGFwcERhdGFbNV0sIG1pbm9yOiBhcHBEYXRhWzZdfSxcclxuICAgICAgICAgICAgICAgICAgZGVuc2l0eVVuaXRzOiBhcHBEYXRhWzddLFxyXG4gICAgICAgICAgICAgICAgICB4RGVuc2l0eTogKGFwcERhdGFbOF0gPDwgOCkgfCBhcHBEYXRhWzldLFxyXG4gICAgICAgICAgICAgICAgICB5RGVuc2l0eTogKGFwcERhdGFbMTBdIDw8IDgpIHwgYXBwRGF0YVsxMV0sXHJcbiAgICAgICAgICAgICAgICAgIHRodW1iV2lkdGg6IGFwcERhdGFbMTJdLFxyXG4gICAgICAgICAgICAgICAgICB0aHVtYkhlaWdodDogYXBwRGF0YVsxM10sXHJcbiAgICAgICAgICAgICAgICAgIHRodW1iRGF0YTogYXBwRGF0YS5zdWJhcnJheSgxNCwgMTQgKyAzICogYXBwRGF0YVsxMl0gKiBhcHBEYXRhWzEzXSlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE8gQVBQMSAtIEV4aWZcclxuICAgICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFRSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcHBEYXRhWzBdID09PSAweDQxICYmIGFwcERhdGFbMV0gPT09IDB4NjQgJiYgYXBwRGF0YVsyXSA9PT0gMHg2RiAmJlxyXG4gICAgICAgICAgICAgICAgYXBwRGF0YVszXSA9PT0gMHg2MiAmJiBhcHBEYXRhWzRdID09PSAweDY1ICYmIGFwcERhdGFbNV0gPT09IDApIHsgLy8gJ0Fkb2JlXFx4MDAnXHJcbiAgICAgICAgICAgICAgICBhZG9iZSA9IHtcclxuICAgICAgICAgICAgICAgICAgdmVyc2lvbjogYXBwRGF0YVs2XSxcclxuICAgICAgICAgICAgICAgICAgZmxhZ3MwOiAoYXBwRGF0YVs3XSA8PCA4KSB8IGFwcERhdGFbOF0sXHJcbiAgICAgICAgICAgICAgICAgIGZsYWdzMTogKGFwcERhdGFbOV0gPDwgOCkgfCBhcHBEYXRhWzEwXSxcclxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQ29kZTogYXBwRGF0YVsxMV1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMHhGRkRCOiAvLyBEUVQgKERlZmluZSBRdWFudGl6YXRpb24gVGFibGVzKVxyXG4gICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xyXG4gICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjtcclxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHF1YW50aXphdGlvblRhYmxlc0VuZCkge1xyXG4gICAgICAgICAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICAgICAgICB2YXIgdGFibGVEYXRhID0gbmV3IEludDMyQXJyYXkoNjQpO1xyXG4gICAgICAgICAgICAgIGlmICgocXVhbnRpemF0aW9uVGFibGVTcGVjID4+IDQpID09PSAwKSB7IC8vIDggYml0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDY0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdbal07XHJcbiAgICAgICAgICAgICAgICAgIHRhYmxlRGF0YVt6XSA9IGRhdGFbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMSkgeyAvLzE2IGJpdFxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDY0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHp6ID0gZGN0WmlnWmFnW2pdO1xyXG4gICAgICAgICAgICAgICAgICB0YWJsZURhdGFbenpdID0gcmVhZFVpbnQxNigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEUVQ6IGludmFsaWQgdGFibGUgc3BlY1wiO1xyXG4gICAgICAgICAgICAgIHF1YW50aXphdGlvblRhYmxlc1txdWFudGl6YXRpb25UYWJsZVNwZWMgJiAxNV0gPSB0YWJsZURhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAweEZGQzA6IC8vIFNPRjAgKFN0YXJ0IG9mIEZyYW1lLCBCYXNlbGluZSBEQ1QpXHJcbiAgICAgICAgICBjYXNlIDB4RkZDMTogLy8gU09GMSAoU3RhcnQgb2YgRnJhbWUsIEV4dGVuZGVkIERDVClcclxuICAgICAgICAgIGNhc2UgMHhGRkMyOiAvLyBTT0YyIChTdGFydCBvZiBGcmFtZSwgUHJvZ3Jlc3NpdmUgRENUKVxyXG4gICAgICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBcIk9ubHkgc2luZ2xlIGZyYW1lIEpQRUdzIHN1cHBvcnRlZFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxyXG4gICAgICAgICAgICBmcmFtZSA9IHt9O1xyXG4gICAgICAgICAgICBmcmFtZS5leHRlbmRlZCA9IChmaWxlTWFya2VyID09PSAweEZGQzEpO1xyXG4gICAgICAgICAgICBmcmFtZS5wcm9ncmVzc2l2ZSA9IChmaWxlTWFya2VyID09PSAweEZGQzIpO1xyXG4gICAgICAgICAgICBmcmFtZS5wcmVjaXNpb24gPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICAgICAgZnJhbWUuc2NhbkxpbmVzID0gcmVhZFVpbnQxNigpO1xyXG4gICAgICAgICAgICBmcmFtZS5zYW1wbGVzUGVyTGluZSA9IHJlYWRVaW50MTYoKTtcclxuICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBmcmFtZS5jb21wb25lbnRJZHMgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IGRhdGFbb2Zmc2V0KytdLCBjb21wb25lbnRJZDtcclxuICAgICAgICAgICAgdmFyIG1heEggPSAwLCBtYXhWID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgY29tcG9uZW50SWQgPSBkYXRhW29mZnNldF07XHJcbiAgICAgICAgICAgICAgdmFyIGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7XHJcbiAgICAgICAgICAgICAgdmFyIHYgPSBkYXRhW29mZnNldCArIDFdICYgMTU7XHJcbiAgICAgICAgICAgICAgaWYgKG1heEggPCBoKVxyXG4gICAgICAgICAgICAgICAgbWF4SCA9IGg7XHJcbiAgICAgICAgICAgICAgaWYgKG1heFYgPCB2KVxyXG4gICAgICAgICAgICAgICAgbWF4ViA9IHY7XHJcbiAgICAgICAgICAgICAgdmFyIHFJZCA9IGRhdGFbb2Zmc2V0ICsgMl07XHJcbiAgICAgICAgICAgICAgbCA9IGZyYW1lLmNvbXBvbmVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBoOiBoLFxyXG4gICAgICAgICAgICAgICAgdjogdixcclxuICAgICAgICAgICAgICAgIHF1YW50aXphdGlvblRhYmxlOiBxdWFudGl6YXRpb25UYWJsZXNbcUlkXSxcclxuICAgICAgICAgICAgICAgIHF1YW50aXphdGlvblRhYmxlSWQ6IHFJZCxcclxuICAgICAgICAgICAgICAgIGJpdENvbnZlcnNpb246IDI1NSAvICgoMSA8PCBmcmFtZS5wcmVjaXNpb24pIC0gMSlcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBmcmFtZS5jb21wb25lbnRJZHNbY29tcG9uZW50SWRdID0gbCAtIDE7XHJcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnJhbWUubWF4SCA9IG1heEg7XHJcbiAgICAgICAgICAgIGZyYW1lLm1heFYgPSBtYXhWO1xyXG4gICAgICAgICAgICBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMHhGRkM0OiAvLyBESFQgKERlZmluZSBIdWZmbWFuIFRhYmxlcylcclxuICAgICAgICAgICAgdmFyIGh1ZmZtYW5MZW5ndGggPSByZWFkVWludDE2KCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDI7IGkgPCBodWZmbWFuTGVuZ3RoOyApIHtcclxuICAgICAgICAgICAgICB2YXIgaHVmZm1hblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICAgIHZhciBjb2RlTGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDE2KTtcclxuICAgICAgICAgICAgICB2YXIgY29kZUxlbmd0aFN1bSA9IDA7XHJcbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyssIG9mZnNldCsrKVxyXG4gICAgICAgICAgICAgICAgY29kZUxlbmd0aFN1bSArPSAoY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF0pO1xyXG4gICAgICAgICAgICAgIHZhciBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7XHJcbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvZGVMZW5ndGhTdW07IGorKywgb2Zmc2V0KyspXHJcbiAgICAgICAgICAgICAgICBodWZmbWFuVmFsdWVzW2pdID0gZGF0YVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgIGkgKz0gMTcgKyBjb2RlTGVuZ3RoU3VtO1xyXG5cclxuICAgICAgICAgICAgICAoKGh1ZmZtYW5UYWJsZVNwZWMgPj4gNCkgPT09IDAgP1xyXG4gICAgICAgICAgICAgICAgaHVmZm1hblRhYmxlc0RDIDogaHVmZm1hblRhYmxlc0FDKVtodWZmbWFuVGFibGVTcGVjICYgMTVdID1cclxuICAgICAgICAgICAgICAgIGJ1aWxkSHVmZm1hblRhYmxlKGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDB4RkZERDogLy8gRFJJIChEZWZpbmUgUmVzdGFydCBJbnRlcnZhbClcclxuICAgICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoXHJcbiAgICAgICAgICAgIHJlc2V0SW50ZXJ2YWwgPSByZWFkVWludDE2KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMHhGRkRBOiAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pXHJcbiAgICAgICAgICAgIHZhciBzY2FuTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzQ291bnQgPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXSwgY29tcG9uZW50O1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0b3JzQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRJbmRleCA9IGZyYW1lLmNvbXBvbmVudElkc1tkYXRhW29mZnNldCsrXV07XHJcbiAgICAgICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tjb21wb25lbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgdmFyIHRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyA9IGh1ZmZtYW5UYWJsZXNEQ1t0YWJsZVNwZWMgPj4gNF07XHJcbiAgICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDID0gaHVmZm1hblRhYmxlc0FDW3RhYmxlU3BlYyAmIDE1XTtcclxuICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3BlY3RyYWxTdGFydCA9IGRhdGFbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICB2YXIgc3BlY3RyYWxFbmQgPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uID0gZGF0YVtvZmZzZXQrK107XHJcbiAgICAgICAgICAgIHZhciBwcm9jZXNzZWQgPSBkZWNvZGVTY2FuKGRhdGEsIG9mZnNldCxcclxuICAgICAgICAgICAgICBmcmFtZSwgY29tcG9uZW50cywgcmVzZXRJbnRlcnZhbCxcclxuICAgICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCxcclxuICAgICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA+PiA0LCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1KTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHByb2Nlc3NlZDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgLSAzXSA9PSAweEZGICYmXHJcbiAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgLSAyXSA+PSAweEMwICYmIGRhdGFbb2Zmc2V0IC0gMl0gPD0gMHhGRSkge1xyXG4gICAgICAgICAgICAgIC8vIGNvdWxkIGJlIGluY29ycmVjdCBlbmNvZGluZyAtLSBsYXN0IDB4RkYgYnl0ZSBvZiB0aGUgcHJldmlvdXNcclxuICAgICAgICAgICAgICAvLyBibG9jayB3YXMgZWF0ZW4gYnkgdGhlIGVuY29kZXJcclxuICAgICAgICAgICAgICBvZmZzZXQgLT0gMztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBcInVua25vd24gSlBFRyBtYXJrZXIgXCIgKyBmaWxlTWFya2VyLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy53aWR0aCA9IGZyYW1lLnNhbXBsZXNQZXJMaW5lO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IGZyYW1lLnNjYW5MaW5lcztcclxuICAgICAgdGhpcy5qZmlmID0gamZpZjtcclxuICAgICAgdGhpcy5hZG9iZSA9IGFkb2JlO1xyXG4gICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcclxuICAgICAgc3dpdGNoIChmcmFtZS5jb21wb25lbnRzLmxlbmd0aClcclxuICAgICAge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuR3JheXNjYWxlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgaWYgKHRoaXMuYWRvYmUpXHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuQWRvYmVSR0I7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuUkdCO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgdGhpcy5jb2xvcnNwYWNlID0gQ29sb3JTcGFjZS5DWU1LO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuVW5rbm93bjtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tpXTtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZSAmJiBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGVJZCAhPT0gbnVsbClcclxuICAgICAgICAgIGNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZSA9IHF1YW50aXphdGlvblRhYmxlc1tjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGVJZF07XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goe1xyXG4gICAgICAgICAgb3V0cHV0OiBidWlsZENvbXBvbmVudERhdGEoZnJhbWUsIGNvbXBvbmVudCksXHJcbiAgICAgICAgICBzY2FsZVg6IGNvbXBvbmVudC5oIC8gZnJhbWUubWF4SCxcclxuICAgICAgICAgIHNjYWxlWTogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWLFxyXG4gICAgICAgICAgYmxvY2tzUGVyTGluZTogY29tcG9uZW50LmJsb2Nrc1BlckxpbmUsXHJcbiAgICAgICAgICBibG9ja3NQZXJDb2x1bW46IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW4sXHJcbiAgICAgICAgICBiaXRDb252ZXJzaW9uOiBjb21wb25lbnQuYml0Q29udmVyc2lvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0RGF0YTE2OiBmdW5jdGlvbiBnZXREYXRhMTYod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICBpZiAodGhpcy5jb21wb25lbnRzLmxlbmd0aCAhPT0gMSlcclxuICAgICAgICB0aHJvdyAnVW5zdXBwb3J0ZWQgY29sb3IgbW9kZSc7XHJcbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLndpZHRoIC8gd2lkdGgsIHNjYWxlWSA9IHRoaXMuaGVpZ2h0IC8gaGVpZ2h0O1xyXG5cclxuICAgICAgdmFyIGNvbXBvbmVudCwgY29tcG9uZW50U2NhbGVYLCBjb21wb25lbnRTY2FsZVk7XHJcbiAgICAgIHZhciB4LCB5LCBpO1xyXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgdmFyIG51bUNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xyXG4gICAgICB2YXIgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogbnVtQ29tcG9uZW50cztcclxuICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDE2QXJyYXkoZGF0YUxlbmd0aCk7XHJcbiAgICAgIHZhciBjb21wb25lbnRMaW5lO1xyXG5cclxuICAgICAgLy8gbGluZURhdGEgaXMgcmV1c2VkIGZvciBhbGwgY29tcG9uZW50cy4gQXNzdW1lIGZpcnN0IGNvbXBvbmVudCBpc1xyXG4gICAgICAvLyB0aGUgYmlnZ2VzdFxyXG4gICAgICB2YXIgbGluZURhdGEgPSBuZXcgVWludDE2QXJyYXkoKHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lIDw8IDMpICpcclxuICAgICAgdGhpcy5jb21wb25lbnRzWzBdLmJsb2Nrc1BlckNvbHVtbiAqIDgpO1xyXG5cclxuICAgICAgLy8gRmlyc3QgY29uc3RydWN0IGltYWdlIGRhdGEgLi4uXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Db21wb25lbnRzOyBpKyspIHtcclxuICAgICAgICBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNbaV07XHJcbiAgICAgICAgdmFyIGJsb2Nrc1BlckxpbmUgPSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcclxuICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbjtcclxuICAgICAgICB2YXIgc2FtcGxlc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lIDw8IDM7XHJcblxyXG4gICAgICAgIHZhciBqLCBrLCBsbCA9IDA7XHJcbiAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGJsb2NrUm93ID0gMDsgYmxvY2tSb3cgPCBibG9ja3NQZXJDb2x1bW47IGJsb2NrUm93KyspIHtcclxuICAgICAgICAgIHZhciBzY2FuTGluZSA9IGJsb2NrUm93IDw8IDM7XHJcbiAgICAgICAgICBmb3IgKHZhciBibG9ja0NvbCA9IDA7IGJsb2NrQ29sIDwgYmxvY2tzUGVyTGluZTsgYmxvY2tDb2wrKykge1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0ID0gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCBibG9ja1JvdywgYmxvY2tDb2wpO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMCwgc2FtcGxlID0gYmxvY2tDb2wgPDwgMztcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDg7IGorKykge1xyXG4gICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gKHNjYW5MaW5lICsgaikgKiBzYW1wbGVzUGVyTGluZTtcclxuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgODsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lRGF0YVtsaW5lT2Zmc2V0ICsgc2FtcGxlICsga10gPVxyXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQub3V0cHV0W2J1ZmZlck9mZnNldCArIG9mZnNldCsrXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbXBvbmVudFNjYWxlWCA9IGNvbXBvbmVudC5zY2FsZVggKiBzY2FsZVg7XHJcbiAgICAgICAgY29tcG9uZW50U2NhbGVZID0gY29tcG9uZW50LnNjYWxlWSAqIHNjYWxlWTtcclxuICAgICAgICBvZmZzZXQgPSBpO1xyXG5cclxuICAgICAgICB2YXIgY3gsIGN5O1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGN5ID0gMCB8ICh5ICogY29tcG9uZW50U2NhbGVZKTtcclxuICAgICAgICAgICAgY3ggPSAwIHwgKHggKiBjb21wb25lbnRTY2FsZVgpO1xyXG4gICAgICAgICAgICBpbmRleCA9IGN5ICogc2FtcGxlc1BlckxpbmUgKyBjeDtcclxuICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gbGluZURhdGFbaW5kZXhdO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gbnVtQ29tcG9uZW50cztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24gZ2V0RGF0YSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLndpZHRoIC8gd2lkdGgsIHNjYWxlWSA9IHRoaXMuaGVpZ2h0IC8gaGVpZ2h0O1xyXG5cclxuICAgICAgdmFyIGNvbXBvbmVudCwgY29tcG9uZW50U2NhbGVYLCBjb21wb25lbnRTY2FsZVk7XHJcbiAgICAgIHZhciB4LCB5LCBpO1xyXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgdmFyIFksIENiLCBDciwgSywgQywgTSwgWWUsIFIsIEcsIEI7XHJcbiAgICAgIHZhciBjb2xvclRyYW5zZm9ybTtcclxuICAgICAgdmFyIG51bUNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xyXG4gICAgICB2YXIgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogbnVtQ29tcG9uZW50cztcclxuICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcclxuICAgICAgdmFyIGNvbXBvbmVudExpbmU7XHJcblxyXG4gICAgICAvLyBsaW5lRGF0YSBpcyByZXVzZWQgZm9yIGFsbCBjb21wb25lbnRzLiBBc3N1bWUgZmlyc3QgY29tcG9uZW50IGlzXHJcbiAgICAgIC8vIHRoZSBiaWdnZXN0XHJcbiAgICAgIHZhciBsaW5lRGF0YSA9IG5ldyBVaW50OEFycmF5KCh0aGlzLmNvbXBvbmVudHNbMF0uYmxvY2tzUGVyTGluZSA8PCAzKSAqXHJcbiAgICAgIHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW4gKiA4KTtcclxuXHJcbiAgICAgIC8vIEZpcnN0IGNvbnN0cnVjdCBpbWFnZSBkYXRhIC4uLlxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ29tcG9uZW50czsgaSsrKSB7XHJcbiAgICAgICAgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2ldO1xyXG4gICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XHJcbiAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbiA9IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW47XHJcbiAgICAgICAgdmFyIHNhbXBsZXNQZXJMaW5lID0gYmxvY2tzUGVyTGluZSA8PCAzO1xyXG5cclxuICAgICAgICB2YXIgaiwgaywgbGwgPSAwO1xyXG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XHJcbiAgICAgICAgICB2YXIgc2NhbkxpbmUgPSBibG9ja1JvdyA8PCAzO1xyXG4gICAgICAgICAgZm9yICh2YXIgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDAsIHNhbXBsZSA9IGJsb2NrQ29sIDw8IDM7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA4OyBqKyspIHtcclxuICAgICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IChzY2FuTGluZSArIGopICogc2FtcGxlc1BlckxpbmU7XHJcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgbGluZURhdGFbbGluZU9mZnNldCArIHNhbXBsZSArIGtdID1cclxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm91dHB1dFtidWZmZXJPZmZzZXQgKyBvZmZzZXQrK10gKiBjb21wb25lbnQuYml0Q29udmVyc2lvbjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbXBvbmVudFNjYWxlWCA9IGNvbXBvbmVudC5zY2FsZVggKiBzY2FsZVg7XHJcbiAgICAgICAgY29tcG9uZW50U2NhbGVZID0gY29tcG9uZW50LnNjYWxlWSAqIHNjYWxlWTtcclxuICAgICAgICBvZmZzZXQgPSBpO1xyXG5cclxuICAgICAgICB2YXIgY3gsIGN5O1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGN5ID0gMCB8ICh5ICogY29tcG9uZW50U2NhbGVZKTtcclxuICAgICAgICAgICAgY3ggPSAwIHwgKHggKiBjb21wb25lbnRTY2FsZVgpO1xyXG4gICAgICAgICAgICBpbmRleCA9IGN5ICogc2FtcGxlc1BlckxpbmUgKyBjeDtcclxuICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gbGluZURhdGFbaW5kZXhdO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gbnVtQ29tcG9uZW50cztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC4uLiB0aGVuIHRyYW5zZm9ybSBjb2xvcnMsIGlmIG5lY2Vzc2FyeVxyXG4gICAgICBzd2l0Y2ggKG51bUNvbXBvbmVudHMpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gbm8gY29sb3IgY29udmVyc2lvbiBmb3Igb25lIG9yIHR3byBjb21wb2VuZW50c1xyXG5cclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB0cmFuc2Zvcm0gZm9yIHRocmVlIGNvbXBvbmVudHMgaXMgdHJ1ZVxyXG4gICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSB0cnVlO1xyXG4gICAgICAgICAgLy8gVGhlIGFkb2JlIHRyYW5zZm9ybSBtYXJrZXIgb3ZlcnJpZGVzIGFueSBwcmV2aW91cyBzZXR0aW5nXHJcbiAgICAgICAgICBpZiAodGhpcy5hZG9iZSAmJiB0aGlzLmFkb2JlLnRyYW5zZm9ybUNvZGUpXHJcbiAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcclxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbG9yVHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSAhIXRoaXMuY29sb3JUcmFuc2Zvcm07XHJcblxyXG4gICAgICAgICAgaWYgKGNvbG9yVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpICs9IG51bUNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgICBZID0gZGF0YVtpICAgIF07XHJcbiAgICAgICAgICAgICAgQ2IgPSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgICBDciA9IGRhdGFbaSArIDJdO1xyXG5cclxuICAgICAgICAgICAgICBSID0gY2xhbXBUb1VpbnQ4KFkgLSAxNzkuNDU2ICsgMS40MDIgKiBDcik7XHJcbiAgICAgICAgICAgICAgRyA9IGNsYW1wVG9VaW50OChZICsgMTM1LjQ1OSAtIDAuMzQ0ICogQ2IgLSAwLjcxNCAqIENyKTtcclxuICAgICAgICAgICAgICBCID0gY2xhbXBUb1VpbnQ4KFkgLSAyMjYuODE2ICsgMS43NzIgKiBDYik7XHJcblxyXG4gICAgICAgICAgICAgIGRhdGFbaSAgICBdID0gUjtcclxuICAgICAgICAgICAgICBkYXRhW2kgKyAxXSA9IEc7XHJcbiAgICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBCO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICBpZiAoIXRoaXMuYWRvYmUpXHJcbiAgICAgICAgICAgIHRocm93ICdVbnN1cHBvcnRlZCBjb2xvciBtb2RlICg0IGNvbXBvbmVudHMpJztcclxuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHRyYW5zZm9ybSBmb3IgZm91ciBjb21wb25lbnRzIGlzIGZhbHNlXHJcbiAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9IGZhbHNlO1xyXG4gICAgICAgICAgLy8gVGhlIGFkb2JlIHRyYW5zZm9ybSBtYXJrZXIgb3ZlcnJpZGVzIGFueSBwcmV2aW91cyBzZXR0aW5nXHJcbiAgICAgICAgICBpZiAodGhpcy5hZG9iZSAmJiB0aGlzLmFkb2JlLnRyYW5zZm9ybUNvZGUpXHJcbiAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcclxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbG9yVHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSAhIXRoaXMuY29sb3JUcmFuc2Zvcm07XHJcblxyXG4gICAgICAgICAgaWYgKGNvbG9yVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpICs9IG51bUNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgICBZID0gZGF0YVtpXTtcclxuICAgICAgICAgICAgICBDYiA9IGRhdGFbaSArIDFdO1xyXG4gICAgICAgICAgICAgIENyID0gZGF0YVtpICsgMl07XHJcblxyXG4gICAgICAgICAgICAgIEMgPSBjbGFtcFRvVWludDgoNDM0LjQ1NiAtIFkgLSAxLjQwMiAqIENyKTtcclxuICAgICAgICAgICAgICBNID0gY2xhbXBUb1VpbnQ4KDExOS41NDEgLSBZICsgMC4zNDQgKiBDYiArIDAuNzE0ICogQ3IpO1xyXG4gICAgICAgICAgICAgIFkgPSBjbGFtcFRvVWludDgoNDgxLjgxNiAtIFkgLSAxLjc3MiAqIENiKTtcclxuXHJcbiAgICAgICAgICAgICAgZGF0YVtpICAgIF0gPSBDO1xyXG4gICAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTTtcclxuICAgICAgICAgICAgICBkYXRhW2kgKyAyXSA9IFk7XHJcbiAgICAgICAgICAgICAgLy8gSyBpcyB1bmNoYW5nZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93ICdVbnN1cHBvcnRlZCBjb2xvciBtb2RlJztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gY29uc3RydWN0b3I7XHJcbn0pKCk7XHJcblxyXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XHJcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEpwZWdJbWFnZTtcclxufSIsIi8qISBpbWFnZS1KUEVHMjAwMCAtIHYwLjMuMSAtIDIwMTUtMDgtMjYgfCBodHRwczovL2dpdGh1Yi5jb20vT0hJRi9pbWFnZS1KUEVHMjAwMCAqL1xyXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xyXG4vKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXHJcbi8qIENvcHlyaWdodCAyMDEyIE1vemlsbGEgRm91bmRhdGlvblxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qIGdsb2JhbHMgQXJpdGhtZXRpY0RlY29kZXIsIGdsb2JhbFNjb3BlLCBsb2cyLCByZWFkVWludDE2LCByZWFkVWludDMyLFxyXG4gICAgICAgICAgIGluZm8sIHdhcm4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBKcHhJbWFnZSA9IChmdW5jdGlvbiBKcHhJbWFnZUNsb3N1cmUoKSB7XHJcbiAgLy8gVGFibGUgRS4xXHJcbiAgdmFyIFN1YmJhbmRzR2FpbkxvZzIgPSB7XHJcbiAgICAnTEwnOiAwLFxyXG4gICAgJ0xIJzogMSxcclxuICAgICdITCc6IDEsXHJcbiAgICAnSEgnOiAyXHJcbiAgfTtcclxuICBmdW5jdGlvbiBKcHhJbWFnZSgpIHtcclxuICAgIHRoaXMuZmFpbE9uQ29ycnVwdGVkSW1hZ2UgPSBmYWxzZTtcclxuICB9XHJcbiAgSnB4SW1hZ2UucHJvdG90eXBlID0ge1xyXG4gICAgcGFyc2U6IGZ1bmN0aW9uIEpweEltYWdlX3BhcnNlKGRhdGEpIHtcclxuXHJcbiAgICAgIHZhciBoZWFkID0gcmVhZFVpbnQxNihkYXRhLCAwKTtcclxuICAgICAgLy8gTm8gYm94IGhlYWRlciwgaW1tZWRpYXRlIHN0YXJ0IG9mIGNvZGVzdHJlYW0gKFNPQylcclxuICAgICAgaWYgKGhlYWQgPT09IDB4RkY0Rikge1xyXG4gICAgICAgIHRoaXMucGFyc2VDb2Rlc3RyZWFtKGRhdGEsIDAsIGRhdGEubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgaGVhZGVyU2l6ZSA9IDg7XHJcbiAgICAgICAgdmFyIGxib3ggPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgdGJveCA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyA0KTtcclxuICAgICAgICBwb3NpdGlvbiArPSBoZWFkZXJTaXplO1xyXG4gICAgICAgIGlmIChsYm94ID09PSAxKSB7XHJcbiAgICAgICAgICAvLyBYTEJveDogcmVhZCBVSW50NjQgYWNjb3JkaW5nIHRvIHNwZWMuXHJcbiAgICAgICAgICAvLyBKYXZhU2NyaXB0J3MgaW50IHByZWNpc2lvbiBvZiA1MyBiaXQgc2hvdWxkIGJlIHN1ZmZpY2llbnQgaGVyZS5cclxuICAgICAgICAgIGxib3ggPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uKSAqIDQyOTQ5NjcyOTYgK1xyXG4gICAgICAgICAgICAgICAgIHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyA0KTtcclxuICAgICAgICAgIHBvc2l0aW9uICs9IDg7XHJcbiAgICAgICAgICBoZWFkZXJTaXplICs9IDg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYm94ID09PSAwKSB7XHJcbiAgICAgICAgICBsYm94ID0gbGVuZ3RoIC0gcG9zaXRpb24gKyBoZWFkZXJTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGJveCA8IGhlYWRlclNpemUpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBJbnZhbGlkIGJveCBmaWVsZCBzaXplJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gbGJveCAtIGhlYWRlclNpemU7XHJcbiAgICAgICAgdmFyIGp1bXBEYXRhTGVuZ3RoID0gdHJ1ZTtcclxuICAgICAgICBzd2l0Y2ggKHRib3gpIHtcclxuICAgICAgICAgIGNhc2UgMHg2QTcwMzI2ODogLy8gJ2pwMmgnXHJcbiAgICAgICAgICAgIGp1bXBEYXRhTGVuZ3RoID0gZmFsc2U7IC8vIHBhcnNpbmcgY2hpbGQgYm94ZXNcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDB4NjM2RjZDNzI6IC8vICdjb2xyJ1xyXG4gICAgICAgICAgICAvLyBDb2xvcnNwYWNlcyBhcmUgbm90IHVzZWQsIHRoZSBDUyBmcm9tIHRoZSBQREYgaXMgdXNlZC5cclxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGRhdGFbcG9zaXRpb25dO1xyXG4gICAgICAgICAgICB2YXIgcHJlY2VkZW5jZSA9IGRhdGFbcG9zaXRpb24gKyAxXTtcclxuICAgICAgICAgICAgdmFyIGFwcHJveGltYXRpb24gPSBkYXRhW3Bvc2l0aW9uICsgMl07XHJcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IDEpIHtcclxuICAgICAgICAgICAgICAvLyBlbnVtZXJhdGVkIGNvbG9yc3BhY2VcclxuICAgICAgICAgICAgICB2YXIgY29sb3JzcGFjZSA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAzKTtcclxuICAgICAgICAgICAgICBzd2l0Y2ggKGNvbG9yc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTY6IC8vIHRoaXMgaW5kaWNhdGVzIGEgc1JHQiBjb2xvcnNwYWNlXHJcbiAgICAgICAgICAgICAgICBjYXNlIDE3OiAvLyB0aGlzIGluZGljYXRlcyBhIGdyYXlzY2FsZSBjb2xvcnNwYWNlXHJcbiAgICAgICAgICAgICAgICBjYXNlIDE4OiAvLyB0aGlzIGluZGljYXRlcyBhIFlVViBjb2xvcnNwYWNlXHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgd2FybignVW5rbm93biBjb2xvcnNwYWNlICcgKyBjb2xvcnNwYWNlKTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gMikge1xyXG4gICAgICAgICAgICAgIGluZm8oJ0lDQyBwcm9maWxlIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMHg2QTcwMzI2MzogLy8gJ2pwMmMnXHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VDb2Rlc3RyZWFtKGRhdGEsIHBvc2l0aW9uLCBwb3NpdGlvbiArIGRhdGFMZW5ndGgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMHg2QTUwMjAyMDogLy8gJ2pQXFwwMjRcXDAyNCdcclxuICAgICAgICAgICAgaWYgKDB4MGQwYTg3MGEgIT09IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgd2FybignSW52YWxpZCBKUDIgc2lnbmF0dXJlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGhlYWRlciB0eXBlcyBhcmUgdmFsaWQgYnV0IGN1cnJlbnRseSBub3QgdXNlZDpcclxuICAgICAgICAgIGNhc2UgMHg2QTUwMUExQTogLy8gJ2pQXFwwMzJcXDAzMidcclxuICAgICAgICAgIGNhc2UgMHg2Njc0Nzk3MDogLy8gJ2Z0eXAnXHJcbiAgICAgICAgICBjYXNlIDB4NzI3MjY1NzE6IC8vICdycmVxJ1xyXG4gICAgICAgICAgY2FzZSAweDcyNjU3MzIwOiAvLyAncmVzICdcclxuICAgICAgICAgIGNhc2UgMHg2OTY4NjQ3MjogLy8gJ2loZHInXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdmFyIGhlYWRlclR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh0Ym94ID4+IDI0KSAmIDB4RkYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGJveCA+PiAxNikgJiAweEZGLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRib3ggPj4gOCkgJiAweEZGLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJveCAmIDB4RkYpO1xyXG4gICAgICAgICAgICB3YXJuKCdVbnN1cHBvcnRlZCBoZWFkZXIgdHlwZSAnICsgdGJveCArICcgKCcgKyBoZWFkZXJUeXBlICsgJyknKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdW1wRGF0YUxlbmd0aCkge1xyXG4gICAgICAgICAgcG9zaXRpb24gKz0gZGF0YUxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwYXJzZUltYWdlUHJvcGVydGllczogZnVuY3Rpb24gSnB4SW1hZ2VfcGFyc2VJbWFnZVByb3BlcnRpZXMoc3RyZWFtKSB7XHJcbiAgICAgIHZhciBuZXdCeXRlID0gc3RyZWFtLmdldEJ5dGUoKTtcclxuICAgICAgd2hpbGUgKG5ld0J5dGUgPj0gMCkge1xyXG4gICAgICAgIHZhciBvbGRCeXRlID0gbmV3Qnl0ZTtcclxuICAgICAgICBuZXdCeXRlID0gc3RyZWFtLmdldEJ5dGUoKTtcclxuICAgICAgICB2YXIgY29kZSA9IChvbGRCeXRlIDw8IDgpIHwgbmV3Qnl0ZTtcclxuICAgICAgICAvLyBJbWFnZSBhbmQgdGlsZSBzaXplIChTSVopXHJcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4RkY1MSkge1xyXG4gICAgICAgICAgc3RyZWFtLnNraXAoNCk7XHJcbiAgICAgICAgICB2YXIgWHNpeiA9IHN0cmVhbS5nZXRJbnQzMigpID4+PiAwOyAvLyBCeXRlIDRcclxuICAgICAgICAgIHZhciBZc2l6ID0gc3RyZWFtLmdldEludDMyKCkgPj4+IDA7IC8vIEJ5dGUgOFxyXG4gICAgICAgICAgdmFyIFhPc2l6ID0gc3RyZWFtLmdldEludDMyKCkgPj4+IDA7IC8vIEJ5dGUgMTJcclxuICAgICAgICAgIHZhciBZT3NpeiA9IHN0cmVhbS5nZXRJbnQzMigpID4+PiAwOyAvLyBCeXRlIDE2XHJcbiAgICAgICAgICBzdHJlYW0uc2tpcCgxNik7XHJcbiAgICAgICAgICB2YXIgQ3NpeiA9IHN0cmVhbS5nZXRVaW50MTYoKTsgLy8gQnl0ZSAzNlxyXG4gICAgICAgICAgdGhpcy53aWR0aCA9IFhzaXogLSBYT3NpejtcclxuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gWXNpeiAtIFlPc2l6O1xyXG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzQ291bnQgPSBDc2l6O1xyXG4gICAgICAgICAgLy8gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkIGFzIFVpbnQ4QXJyYXlzXHJcbiAgICAgICAgICB0aGlzLmJpdHNQZXJDb21wb25lbnQgPSA4O1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogTm8gc2l6ZSBtYXJrZXIgZm91bmQgaW4gSlBYIHN0cmVhbScpO1xyXG4gICAgfSxcclxuICAgIHBhcnNlQ29kZXN0cmVhbTogZnVuY3Rpb24gSnB4SW1hZ2VfcGFyc2VDb2Rlc3RyZWFtKGRhdGEsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgZG9Ob3RSZWNvdmVyID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gc3RhcnQ7XHJcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uICsgMSA8IGVuZCkge1xyXG4gICAgICAgICAgdmFyIGNvZGUgPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcclxuICAgICAgICAgIHBvc2l0aW9uICs9IDI7XHJcblxyXG4gICAgICAgICAgdmFyIGxlbmd0aCA9IDAsIGosIHNxY2QsIHNwcWNkcywgc3BxY2RTaXplLCBzY2FsYXJFeHBvdW5kZWQsIHRpbGU7XHJcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAweEZGNEY6IC8vIFN0YXJ0IG9mIGNvZGVzdHJlYW0gKFNPQylcclxuICAgICAgICAgICAgICBjb250ZXh0Lm1haW5IZWFkZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDB4RkZEOTogLy8gRW5kIG9mIGNvZGVzdHJlYW0gKEVPQylcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEZGNTE6IC8vIEltYWdlIGFuZCB0aWxlIHNpemUgKFNJWilcclxuICAgICAgICAgICAgICBsZW5ndGggPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICB2YXIgc2l6ID0ge307XHJcbiAgICAgICAgICAgICAgc2l6LlhzaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgNCk7XHJcbiAgICAgICAgICAgICAgc2l6LllzaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgOCk7XHJcbiAgICAgICAgICAgICAgc2l6LlhPc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDEyKTtcclxuICAgICAgICAgICAgICBzaXouWU9zaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMTYpO1xyXG4gICAgICAgICAgICAgIHNpei5YVHNpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAyMCk7XHJcbiAgICAgICAgICAgICAgc2l6LllUc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDI0KTtcclxuICAgICAgICAgICAgICBzaXouWFRPc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDI4KTtcclxuICAgICAgICAgICAgICBzaXouWVRPc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDMyKTtcclxuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbiArIDM2KTtcclxuICAgICAgICAgICAgICBzaXouQ3NpeiA9IGNvbXBvbmVudHNDb3VudDtcclxuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgIGogPSBwb3NpdGlvbiArIDM4O1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgIHByZWNpc2lvbjogKGRhdGFbal0gJiAweDdGKSArIDEsXHJcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkOiAhIShkYXRhW2pdICYgMHg4MCksXHJcbiAgICAgICAgICAgICAgICAgIFhSc2l6OiBkYXRhW2ogKyAxXSxcclxuICAgICAgICAgICAgICAgICAgWVJzaXo6IGRhdGFbaiArIDFdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlQ29tcG9uZW50RGltZW5zaW9ucyhjb21wb25lbnQsIHNpeik7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29udGV4dC5TSVogPSBzaXo7XHJcbiAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuICAgICAgICAgICAgICBjYWxjdWxhdGVUaWxlR3JpZHMoY29udGV4dCwgY29tcG9uZW50cyk7XHJcbiAgICAgICAgICAgICAgY29udGV4dC5RQ0MgPSBbXTtcclxuICAgICAgICAgICAgICBjb250ZXh0LkNPQyA9IFtdO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDB4RkY1QzogLy8gUXVhbnRpemF0aW9uIGRlZmF1bHQgKFFDRClcclxuICAgICAgICAgICAgICBsZW5ndGggPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICB2YXIgcWNkID0ge307XHJcbiAgICAgICAgICAgICAgaiA9IHBvc2l0aW9uICsgMjtcclxuICAgICAgICAgICAgICBzcWNkID0gZGF0YVtqKytdO1xyXG4gICAgICAgICAgICAgIHN3aXRjaCAoc3FjZCAmIDB4MUYpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgc3BxY2RTaXplID0gODtcclxuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDE2O1xyXG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDE2O1xyXG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBJbnZhbGlkIFNRY2QgdmFsdWUgJyArIHNxY2QpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBxY2Qubm9RdWFudGl6YXRpb24gPSAoc3BxY2RTaXplID09PSA4KTtcclxuICAgICAgICAgICAgICBxY2Quc2NhbGFyRXhwb3VuZGVkID0gc2NhbGFyRXhwb3VuZGVkO1xyXG4gICAgICAgICAgICAgIHFjZC5ndWFyZEJpdHMgPSBzcWNkID4+IDU7XHJcbiAgICAgICAgICAgICAgc3BxY2RzID0gW107XHJcbiAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW5ndGggKyBwb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwcWNkID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BxY2RTaXplID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkLmVwc2lsb24gPSBkYXRhW2orK10gPj4gMztcclxuICAgICAgICAgICAgICAgICAgc3BxY2QubXUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgc3BxY2QuZXBzaWxvbiA9IGRhdGFbal0gPj4gMztcclxuICAgICAgICAgICAgICAgICAgc3BxY2QubXUgPSAoKGRhdGFbal0gJiAweDcpIDw8IDgpIHwgZGF0YVtqICsgMV07XHJcbiAgICAgICAgICAgICAgICAgIGogKz0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNwcWNkcy5wdXNoKHNwcWNkKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcWNkLlNQcWNkcyA9IHNwcWNkcztcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dC5tYWluSGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LlFDRCA9IHFjZDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5RQ0QgPSBxY2Q7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLlFDQyA9IFtdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEZGNUQ6IC8vIFF1YW50aXphdGlvbiBjb21wb25lbnQgKFFDQylcclxuICAgICAgICAgICAgICBsZW5ndGggPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICB2YXIgcWNjID0ge307XHJcbiAgICAgICAgICAgICAgaiA9IHBvc2l0aW9uICsgMjtcclxuICAgICAgICAgICAgICB2YXIgY3FjYztcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dC5TSVouQ3NpeiA8IDI1Nykge1xyXG4gICAgICAgICAgICAgICAgY3FjYyA9IGRhdGFbaisrXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3FjYyA9IHJlYWRVaW50MTYoZGF0YSwgaik7XHJcbiAgICAgICAgICAgICAgICBqICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHNxY2QgPSBkYXRhW2orK107XHJcbiAgICAgICAgICAgICAgc3dpdGNoIChzcWNkICYgMHgxRikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICBzcHFjZFNpemUgPSA4O1xyXG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgc3BxY2RTaXplID0gMTY7XHJcbiAgICAgICAgICAgICAgICAgIHNjYWxhckV4cG91bmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgc3BxY2RTaXplID0gMTY7XHJcbiAgICAgICAgICAgICAgICAgIHNjYWxhckV4cG91bmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IEludmFsaWQgU1FjZCB2YWx1ZSAnICsgc3FjZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHFjYy5ub1F1YW50aXphdGlvbiA9IChzcHFjZFNpemUgPT09IDgpO1xyXG4gICAgICAgICAgICAgIHFjYy5zY2FsYXJFeHBvdW5kZWQgPSBzY2FsYXJFeHBvdW5kZWQ7XHJcbiAgICAgICAgICAgICAgcWNjLmd1YXJkQml0cyA9IHNxY2QgPj4gNTtcclxuICAgICAgICAgICAgICBzcHFjZHMgPSBbXTtcclxuICAgICAgICAgICAgICB3aGlsZSAoaiA8IChsZW5ndGggKyBwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHNwcWNkID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BxY2RTaXplID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkLmVwc2lsb24gPSBkYXRhW2orK10gPj4gMztcclxuICAgICAgICAgICAgICAgICAgc3BxY2QubXUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgc3BxY2QuZXBzaWxvbiA9IGRhdGFbal0gPj4gMztcclxuICAgICAgICAgICAgICAgICAgc3BxY2QubXUgPSAoKGRhdGFbal0gJiAweDcpIDw8IDgpIHwgZGF0YVtqICsgMV07XHJcbiAgICAgICAgICAgICAgICAgIGogKz0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNwcWNkcy5wdXNoKHNwcWNkKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcWNjLlNQcWNkcyA9IHNwcWNkcztcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dC5tYWluSGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LlFDQ1tjcWNjXSA9IHFjYztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5RQ0NbY3FjY10gPSBxY2M7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDB4RkY1MjogLy8gQ29kaW5nIHN0eWxlIGRlZmF1bHQgKENPRClcclxuICAgICAgICAgICAgICBsZW5ndGggPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICB2YXIgY29kID0ge307XHJcbiAgICAgICAgICAgICAgaiA9IHBvc2l0aW9uICsgMjtcclxuICAgICAgICAgICAgICB2YXIgc2NvZCA9IGRhdGFbaisrXTtcclxuICAgICAgICAgICAgICBjb2QuZW50cm9weUNvZGVyV2l0aEN1c3RvbVByZWNpbmN0cyA9ICEhKHNjb2QgJiAxKTtcclxuICAgICAgICAgICAgICBjb2Quc29wTWFya2VyVXNlZCA9ICEhKHNjb2QgJiAyKTtcclxuICAgICAgICAgICAgICBjb2QuZXBoTWFya2VyVXNlZCA9ICEhKHNjb2QgJiA0KTtcclxuICAgICAgICAgICAgICBjb2QucHJvZ3Jlc3Npb25PcmRlciA9IGRhdGFbaisrXTtcclxuICAgICAgICAgICAgICBjb2QubGF5ZXJzQ291bnQgPSByZWFkVWludDE2KGRhdGEsIGopO1xyXG4gICAgICAgICAgICAgIGogKz0gMjtcclxuICAgICAgICAgICAgICBjb2QubXVsdGlwbGVDb21wb25lbnRUcmFuc2Zvcm0gPSBkYXRhW2orK107XHJcblxyXG4gICAgICAgICAgICAgIGNvZC5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSBkYXRhW2orK107XHJcbiAgICAgICAgICAgICAgY29kLnhjYiA9IChkYXRhW2orK10gJiAweEYpICsgMjtcclxuICAgICAgICAgICAgICBjb2QueWNiID0gKGRhdGFbaisrXSAmIDB4RikgKyAyO1xyXG4gICAgICAgICAgICAgIHZhciBibG9ja1N0eWxlID0gZGF0YVtqKytdO1xyXG4gICAgICAgICAgICAgIGNvZC5zZWxlY3RpdmVBcml0aG1ldGljQ29kaW5nQnlwYXNzID0gISEoYmxvY2tTdHlsZSAmIDEpO1xyXG4gICAgICAgICAgICAgIGNvZC5yZXNldENvbnRleHRQcm9iYWJpbGl0aWVzID0gISEoYmxvY2tTdHlsZSAmIDIpO1xyXG4gICAgICAgICAgICAgIGNvZC50ZXJtaW5hdGlvbk9uRWFjaENvZGluZ1Bhc3MgPSAhIShibG9ja1N0eWxlICYgNCk7XHJcbiAgICAgICAgICAgICAgY29kLnZlcnRpY2FseVN0cmlwZSA9ICEhKGJsb2NrU3R5bGUgJiA4KTtcclxuICAgICAgICAgICAgICBjb2QucHJlZGljdGFibGVUZXJtaW5hdGlvbiA9ICEhKGJsb2NrU3R5bGUgJiAxNik7XHJcbiAgICAgICAgICAgICAgY29kLnNlZ21lbnRhdGlvblN5bWJvbFVzZWQgPSAhIShibG9ja1N0eWxlICYgMzIpO1xyXG4gICAgICAgICAgICAgIGNvZC5yZXZlcnNpYmxlVHJhbnNmb3JtYXRpb24gPSBkYXRhW2orK107XHJcbiAgICAgICAgICAgICAgaWYgKGNvZC5lbnRyb3B5Q29kZXJXaXRoQ3VzdG9tUHJlY2luY3RzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlY2luY3RzU2l6ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuZ3RoICsgcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHByZWNpbmN0c1NpemUgPSBkYXRhW2orK107XHJcbiAgICAgICAgICAgICAgICAgIHByZWNpbmN0c1NpemVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIFBQeDogcHJlY2luY3RzU2l6ZSAmIDB4RixcclxuICAgICAgICAgICAgICAgICAgICBQUHk6IHByZWNpbmN0c1NpemUgPj4gNFxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvZC5wcmVjaW5jdHNTaXplcyA9IHByZWNpbmN0c1NpemVzO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWQgPSBbXTtcclxuICAgICAgICAgICAgICBpZiAoY29kLnNlbGVjdGl2ZUFyaXRobWV0aWNDb2RpbmdCeXBhc3MpIHtcclxuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkLnB1c2goJ3NlbGVjdGl2ZUFyaXRobWV0aWNDb2RpbmdCeXBhc3MnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGNvZC5yZXNldENvbnRleHRQcm9iYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKCdyZXNldENvbnRleHRQcm9iYWJpbGl0aWVzJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChjb2QudGVybWluYXRpb25PbkVhY2hDb2RpbmdQYXNzKSB7XHJcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKCd0ZXJtaW5hdGlvbk9uRWFjaENvZGluZ1Bhc3MnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGNvZC52ZXJ0aWNhbHlTdHJpcGUpIHtcclxuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkLnB1c2goJ3ZlcnRpY2FseVN0cmlwZScpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoY29kLnByZWRpY3RhYmxlVGVybWluYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkLnB1c2goJ3ByZWRpY3RhYmxlVGVybWluYXRpb24nKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHVuc3VwcG9ydGVkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGRvTm90UmVjb3ZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogVW5zdXBwb3J0ZWQgQ09EIG9wdGlvbnMgKCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkLmpvaW4oJywgJykgKyAnKScpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoY29udGV4dC5tYWluSGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LkNPRCA9IGNvZDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5DT0QgPSBjb2Q7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLkNPQyA9IFtdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEZGOTA6IC8vIFN0YXJ0IG9mIHRpbGUtcGFydCAoU09UKVxyXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgIHRpbGUgPSB7fTtcclxuICAgICAgICAgICAgICB0aWxlLmluZGV4ID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbiArIDIpO1xyXG4gICAgICAgICAgICAgIHRpbGUubGVuZ3RoID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDQpO1xyXG4gICAgICAgICAgICAgIHRpbGUuZGF0YUVuZCA9IHRpbGUubGVuZ3RoICsgcG9zaXRpb24gLSAyO1xyXG4gICAgICAgICAgICAgIHRpbGUucGFydEluZGV4ID0gZGF0YVtwb3NpdGlvbiArIDhdO1xyXG4gICAgICAgICAgICAgIHRpbGUucGFydHNDb3VudCA9IGRhdGFbcG9zaXRpb24gKyA5XTtcclxuXHJcbiAgICAgICAgICAgICAgY29udGV4dC5tYWluSGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgaWYgKHRpbGUucGFydEluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBjb21wb25lbnQgc3BlY2lmaWMgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIHRpbGUuQ09EID0gY29udGV4dC5DT0Q7XHJcbiAgICAgICAgICAgICAgICB0aWxlLkNPQyA9IGNvbnRleHQuQ09DLnNsaWNlKDApOyAvLyBjbG9uZSBvZiB0aGUgZ2xvYmFsIENPQ1xyXG4gICAgICAgICAgICAgICAgdGlsZS5RQ0QgPSBjb250ZXh0LlFDRDtcclxuICAgICAgICAgICAgICAgIHRpbGUuUUNDID0gY29udGV4dC5RQ0Muc2xpY2UoMCk7IC8vIGNsb25lIG9mIHRoZSBnbG9iYWwgQ09DXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbGUgPSB0aWxlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDB4RkY5MzogLy8gU3RhcnQgb2YgZGF0YSAoU09EKVxyXG4gICAgICAgICAgICAgIHRpbGUgPSBjb250ZXh0LmN1cnJlbnRUaWxlO1xyXG4gICAgICAgICAgICAgIGlmICh0aWxlLnBhcnRJbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZVRpbGUoY29udGV4dCwgdGlsZS5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBidWlsZFBhY2tldHMoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBtb3ZpbmcgdG8gdGhlIGVuZCBvZiB0aGUgZGF0YVxyXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHRpbGUuZGF0YUVuZCAtIHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgIHBhcnNlVGlsZVBhY2tldHMoY29udGV4dCwgZGF0YSwgcG9zaXRpb24sIGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMHhGRjU1OiAvLyBUaWxlLXBhcnQgbGVuZ3RocywgbWFpbiBoZWFkZXIgKFRMTSlcclxuICAgICAgICAgICAgY2FzZSAweEZGNTc6IC8vIFBhY2tldCBsZW5ndGgsIG1haW4gaGVhZGVyIChQTE0pXHJcbiAgICAgICAgICAgIGNhc2UgMHhGRjU4OiAvLyBQYWNrZXQgbGVuZ3RoLCB0aWxlLXBhcnQgaGVhZGVyIChQTFQpXHJcbiAgICAgICAgICAgIGNhc2UgMHhGRjY0OiAvLyBDb21tZW50IChDT00pXHJcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgLy8gc2tpcHBpbmcgY29udGVudFxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDB4RkY1MzogLy8gQ29kaW5nIHN0eWxlIGNvbXBvbmVudCAoQ09DKVxyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBDb2Rlc3RyZWFtIGNvZGUgMHhGRjUzIChDT0MpIGlzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IFVua25vd24gY29kZXN0cmVhbSBjb2RlOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZS50b1N0cmluZygxNikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcG9zaXRpb24gKz0gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChkb05vdFJlY292ZXIgfHwgdGhpcy5mYWlsT25Db3JydXB0ZWRJbWFnZSkge1xyXG4gICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgd2FybignVHJ5aW5nIHRvIHJlY292ZXIgZnJvbSAnICsgZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50aWxlcyA9IHRyYW5zZm9ybUNvbXBvbmVudHMoY29udGV4dCk7XHJcbiAgICAgIHRoaXMud2lkdGggPSBjb250ZXh0LlNJWi5Yc2l6IC0gY29udGV4dC5TSVouWE9zaXo7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY29udGV4dC5TSVouWXNpeiAtIGNvbnRleHQuU0laLllPc2l6O1xyXG4gICAgICB0aGlzLmNvbXBvbmVudHNDb3VudCA9IGNvbnRleHQuU0laLkNzaXo7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmdW5jdGlvbiBjYWxjdWxhdGVDb21wb25lbnREaW1lbnNpb25zKGNvbXBvbmVudCwgc2l6KSB7XHJcbiAgICAvLyBTZWN0aW9uIEIuMiBDb21wb25lbnQgbWFwcGluZ1xyXG4gICAgY29tcG9uZW50LngwID0gTWF0aC5jZWlsKHNpei5YT3NpeiAvIGNvbXBvbmVudC5YUnNpeik7XHJcbiAgICBjb21wb25lbnQueDEgPSBNYXRoLmNlaWwoc2l6LlhzaXogLyBjb21wb25lbnQuWFJzaXopO1xyXG4gICAgY29tcG9uZW50LnkwID0gTWF0aC5jZWlsKHNpei5ZT3NpeiAvIGNvbXBvbmVudC5ZUnNpeik7XHJcbiAgICBjb21wb25lbnQueTEgPSBNYXRoLmNlaWwoc2l6LllzaXogLyBjb21wb25lbnQuWVJzaXopO1xyXG4gICAgY29tcG9uZW50LndpZHRoID0gY29tcG9uZW50LngxIC0gY29tcG9uZW50LngwO1xyXG4gICAgY29tcG9uZW50LmhlaWdodCA9IGNvbXBvbmVudC55MSAtIGNvbXBvbmVudC55MDtcclxuICB9XHJcbiAgZnVuY3Rpb24gY2FsY3VsYXRlVGlsZUdyaWRzKGNvbnRleHQsIGNvbXBvbmVudHMpIHtcclxuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcclxuICAgIC8vIFNlY3Rpb24gQi4zIERpdmlzaW9uIGludG8gdGlsZSBhbmQgdGlsZS1jb21wb25lbnRzXHJcbiAgICB2YXIgdGlsZSwgdGlsZXMgPSBbXTtcclxuICAgIHZhciBudW1YdGlsZXMgPSBNYXRoLmNlaWwoKHNpei5Yc2l6IC0gc2l6LlhUT3NpeikgLyBzaXouWFRzaXopO1xyXG4gICAgdmFyIG51bVl0aWxlcyA9IE1hdGguY2VpbCgoc2l6LllzaXogLSBzaXouWVRPc2l6KSAvIHNpei5ZVHNpeik7XHJcbiAgICBmb3IgKHZhciBxID0gMDsgcSA8IG51bVl0aWxlczsgcSsrKSB7XHJcbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgbnVtWHRpbGVzOyBwKyspIHtcclxuICAgICAgICB0aWxlID0ge307XHJcbiAgICAgICAgdGlsZS50eDAgPSBNYXRoLm1heChzaXouWFRPc2l6ICsgcCAqIHNpei5YVHNpeiwgc2l6LlhPc2l6KTtcclxuICAgICAgICB0aWxlLnR5MCA9IE1hdGgubWF4KHNpei5ZVE9zaXogKyBxICogc2l6LllUc2l6LCBzaXouWU9zaXopO1xyXG4gICAgICAgIHRpbGUudHgxID0gTWF0aC5taW4oc2l6LlhUT3NpeiArIChwICsgMSkgKiBzaXouWFRzaXosIHNpei5Yc2l6KTtcclxuICAgICAgICB0aWxlLnR5MSA9IE1hdGgubWluKHNpei5ZVE9zaXogKyAocSArIDEpICogc2l6LllUc2l6LCBzaXouWXNpeik7XHJcbiAgICAgICAgdGlsZS53aWR0aCA9IHRpbGUudHgxIC0gdGlsZS50eDA7XHJcbiAgICAgICAgdGlsZS5oZWlnaHQgPSB0aWxlLnR5MSAtIHRpbGUudHkwO1xyXG4gICAgICAgIHRpbGUuY29tcG9uZW50cyA9IFtdO1xyXG4gICAgICAgIHRpbGVzLnB1c2godGlsZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnRleHQudGlsZXMgPSB0aWxlcztcclxuXHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb21wb25lbnRzQ291bnQ7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xyXG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSB0aWxlcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XHJcbiAgICAgICAgdmFyIHRpbGVDb21wb25lbnQgPSB7fTtcclxuICAgICAgICB0aWxlID0gdGlsZXNbal07XHJcbiAgICAgICAgdGlsZUNvbXBvbmVudC50Y3gwID0gTWF0aC5jZWlsKHRpbGUudHgwIC8gY29tcG9uZW50LlhSc2l6KTtcclxuICAgICAgICB0aWxlQ29tcG9uZW50LnRjeTAgPSBNYXRoLmNlaWwodGlsZS50eTAgLyBjb21wb25lbnQuWVJzaXopO1xyXG4gICAgICAgIHRpbGVDb21wb25lbnQudGN4MSA9IE1hdGguY2VpbCh0aWxlLnR4MSAvIGNvbXBvbmVudC5YUnNpeik7XHJcbiAgICAgICAgdGlsZUNvbXBvbmVudC50Y3kxID0gTWF0aC5jZWlsKHRpbGUudHkxIC8gY29tcG9uZW50LllSc2l6KTtcclxuICAgICAgICB0aWxlQ29tcG9uZW50LndpZHRoID0gdGlsZUNvbXBvbmVudC50Y3gxIC0gdGlsZUNvbXBvbmVudC50Y3gwO1xyXG4gICAgICAgIHRpbGVDb21wb25lbnQuaGVpZ2h0ID0gdGlsZUNvbXBvbmVudC50Y3kxIC0gdGlsZUNvbXBvbmVudC50Y3kwO1xyXG4gICAgICAgIHRpbGUuY29tcG9uZW50c1tpXSA9IHRpbGVDb21wb25lbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gZ2V0QmxvY2tzRGltZW5zaW9ucyhjb250ZXh0LCBjb21wb25lbnQsIHIpIHtcclxuICAgIHZhciBjb2RPckNvYyA9IGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnM7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAoIWNvZE9yQ29jLmVudHJvcHlDb2RlcldpdGhDdXN0b21QcmVjaW5jdHMpIHtcclxuICAgICAgcmVzdWx0LlBQeCA9IDE1O1xyXG4gICAgICByZXN1bHQuUFB5ID0gMTU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQuUFB4ID0gY29kT3JDb2MucHJlY2luY3RzU2l6ZXNbcl0uUFB4O1xyXG4gICAgICByZXN1bHQuUFB5ID0gY29kT3JDb2MucHJlY2luY3RzU2l6ZXNbcl0uUFB5O1xyXG4gICAgfVxyXG4gICAgLy8gY2FsY3VsYXRlIGNvZGVibG9jayBzaXplIGFzIGRlc2NyaWJlZCBpbiBzZWN0aW9uIEIuN1xyXG4gICAgcmVzdWx0LnhjYl8gPSAociA+IDAgPyBNYXRoLm1pbihjb2RPckNvYy54Y2IsIHJlc3VsdC5QUHggLSAxKSA6XHJcbiAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihjb2RPckNvYy54Y2IsIHJlc3VsdC5QUHgpKTtcclxuICAgIHJlc3VsdC55Y2JfID0gKHIgPiAwID8gTWF0aC5taW4oY29kT3JDb2MueWNiLCByZXN1bHQuUFB5IC0gMSkgOlxyXG4gICAgICAgICAgICAgICAgICAgTWF0aC5taW4oY29kT3JDb2MueWNiLCByZXN1bHQuUFB5KSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBmdW5jdGlvbiBidWlsZFByZWNpbmN0cyhjb250ZXh0LCByZXNvbHV0aW9uLCBkaW1lbnNpb25zKSB7XHJcbiAgICAvLyBTZWN0aW9uIEIuNiBEaXZpc2lvbiByZXNvbHV0aW9uIHRvIHByZWNpbmN0c1xyXG4gICAgdmFyIHByZWNpbmN0V2lkdGggPSAxIDw8IGRpbWVuc2lvbnMuUFB4O1xyXG4gICAgdmFyIHByZWNpbmN0SGVpZ2h0ID0gMSA8PCBkaW1lbnNpb25zLlBQeTtcclxuICAgIC8vIEphc3BlciBpbnRyb2R1Y2VzIGNvZGVibG9jayBncm91cHMgZm9yIG1hcHBpbmcgZWFjaCBzdWJiYW5kIGNvZGVibG9ja3NcclxuICAgIC8vIHRvIHByZWNpbmN0cy4gUHJlY2luY3QgcGFydGl0aW9uIGRpdmlkZXMgYSByZXNvbHV0aW9uIGFjY29yZGluZyB0byB3aWR0aFxyXG4gICAgLy8gYW5kIGhlaWdodCBwYXJhbWV0ZXJzLiBUaGUgc3ViYmFuZCB0aGF0IGJlbG9uZ3MgdG8gdGhlIHJlc29sdXRpb24gbGV2ZWxcclxuICAgIC8vIGhhcyBhIGRpZmZlcmVudCBzaXplIHRoYW4gdGhlIGxldmVsLCB1bmxlc3MgaXQgaXMgdGhlIHplcm8gcmVzb2x1dGlvbi5cclxuXHJcbiAgICAvLyBGcm9tIEphc3BlciBkb2N1bWVudGF0aW9uOiBqcGVnMjAwMC5wZGYsIHNlY3Rpb24gSzogVGllci0yIGNvZGluZzpcclxuICAgIC8vIFRoZSBwcmVjaW5jdCBwYXJ0aXRpb25pbmcgZm9yIGEgcGFydGljdWxhciBzdWJiYW5kIGlzIGRlcml2ZWQgZnJvbSBhXHJcbiAgICAvLyBwYXJ0aXRpb25pbmcgb2YgaXRzIHBhcmVudCBMTCBiYW5kIChpLmUuLCB0aGUgTEwgYmFuZCBhdCB0aGUgbmV4dCBoaWdoZXJcclxuICAgIC8vIHJlc29sdXRpb24gbGV2ZWwpLi4uIFRoZSBMTCBiYW5kIGFzc29jaWF0ZWQgd2l0aCBlYWNoIHJlc29sdXRpb24gbGV2ZWwgaXNcclxuICAgIC8vIGRpdmlkZWQgaW50byBwcmVjaW5jdHMuLi4gRWFjaCBvZiB0aGUgcmVzdWx0aW5nIHByZWNpbmN0IHJlZ2lvbnMgaXMgdGhlblxyXG4gICAgLy8gbWFwcGVkIGludG8gaXRzIGNoaWxkIHN1YmJhbmRzIChpZiBhbnkpIGF0IHRoZSBuZXh0IGxvd2VyIHJlc29sdXRpb25cclxuICAgIC8vIGxldmVsLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSB1c2luZyB0aGUgY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgLy8gKHUsIHYpID0gKGNlaWwoeC8yKSwgY2VpbCh5LzIpKSB3aGVyZSAoeCwgeSkgYW5kICh1LCB2KSBhcmUgdGhlXHJcbiAgICAvLyBjb29yZGluYXRlcyBvZiBhIHBvaW50IGluIHRoZSBMTCBiYW5kIGFuZCBjaGlsZCBzdWJiYW5kLCByZXNwZWN0aXZlbHkuXHJcbiAgICB2YXIgaXNaZXJvUmVzID0gcmVzb2x1dGlvbi5yZXNMZXZlbCA9PT0gMDtcclxuICAgIHZhciBwcmVjaW5jdFdpZHRoSW5TdWJiYW5kID0gMSA8PCAoZGltZW5zaW9ucy5QUHggKyAoaXNaZXJvUmVzID8gMCA6IC0xKSk7XHJcbiAgICB2YXIgcHJlY2luY3RIZWlnaHRJblN1YmJhbmQgPSAxIDw8IChkaW1lbnNpb25zLlBQeSArIChpc1plcm9SZXMgPyAwIDogLTEpKTtcclxuICAgIHZhciBudW1wcmVjaW5jdHN3aWRlID0gKHJlc29sdXRpb24udHJ4MSA+IHJlc29sdXRpb24udHJ4MCA/XHJcbiAgICAgIE1hdGguY2VpbChyZXNvbHV0aW9uLnRyeDEgLyBwcmVjaW5jdFdpZHRoKSAtXHJcbiAgICAgIE1hdGguZmxvb3IocmVzb2x1dGlvbi50cngwIC8gcHJlY2luY3RXaWR0aCkgOiAwKTtcclxuICAgIHZhciBudW1wcmVjaW5jdHNoaWdoID0gKHJlc29sdXRpb24udHJ5MSA+IHJlc29sdXRpb24udHJ5MCA/XHJcbiAgICAgIE1hdGguY2VpbChyZXNvbHV0aW9uLnRyeTEgLyBwcmVjaW5jdEhlaWdodCkgLVxyXG4gICAgICBNYXRoLmZsb29yKHJlc29sdXRpb24udHJ5MCAvIHByZWNpbmN0SGVpZ2h0KSA6IDApO1xyXG4gICAgdmFyIG51bXByZWNpbmN0cyA9IG51bXByZWNpbmN0c3dpZGUgKiBudW1wcmVjaW5jdHNoaWdoO1xyXG5cclxuICAgIHJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzID0ge1xyXG4gICAgICBwcmVjaW5jdFdpZHRoOiBwcmVjaW5jdFdpZHRoLFxyXG4gICAgICBwcmVjaW5jdEhlaWdodDogcHJlY2luY3RIZWlnaHQsXHJcbiAgICAgIG51bXByZWNpbmN0c3dpZGU6IG51bXByZWNpbmN0c3dpZGUsXHJcbiAgICAgIG51bXByZWNpbmN0c2hpZ2g6IG51bXByZWNpbmN0c2hpZ2gsXHJcbiAgICAgIG51bXByZWNpbmN0czogbnVtcHJlY2luY3RzLFxyXG4gICAgICBwcmVjaW5jdFdpZHRoSW5TdWJiYW5kOiBwcmVjaW5jdFdpZHRoSW5TdWJiYW5kLFxyXG4gICAgICBwcmVjaW5jdEhlaWdodEluU3ViYmFuZDogcHJlY2luY3RIZWlnaHRJblN1YmJhbmRcclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBkaW1lbnNpb25zKSB7XHJcbiAgICAvLyBTZWN0aW9uIEIuNyBEaXZpc2lvbiBzdWItYmFuZCBpbnRvIGNvZGUtYmxvY2tzXHJcbiAgICB2YXIgeGNiXyA9IGRpbWVuc2lvbnMueGNiXztcclxuICAgIHZhciB5Y2JfID0gZGltZW5zaW9ucy55Y2JfO1xyXG4gICAgdmFyIGNvZGVibG9ja1dpZHRoID0gMSA8PCB4Y2JfO1xyXG4gICAgdmFyIGNvZGVibG9ja0hlaWdodCA9IDEgPDwgeWNiXztcclxuICAgIHZhciBjYngwID0gc3ViYmFuZC50YngwID4+IHhjYl87XHJcbiAgICB2YXIgY2J5MCA9IHN1YmJhbmQudGJ5MCA+PiB5Y2JfO1xyXG4gICAgdmFyIGNieDEgPSAoc3ViYmFuZC50YngxICsgY29kZWJsb2NrV2lkdGggLSAxKSA+PiB4Y2JfO1xyXG4gICAgdmFyIGNieTEgPSAoc3ViYmFuZC50YnkxICsgY29kZWJsb2NrSGVpZ2h0IC0gMSkgPj4geWNiXztcclxuICAgIHZhciBwcmVjaW5jdFBhcmFtZXRlcnMgPSBzdWJiYW5kLnJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzO1xyXG4gICAgdmFyIGNvZGVibG9ja3MgPSBbXTtcclxuICAgIHZhciBwcmVjaW5jdHMgPSBbXTtcclxuICAgIHZhciBpLCBqLCBjb2RlYmxvY2ssIHByZWNpbmN0TnVtYmVyO1xyXG4gICAgZm9yIChqID0gY2J5MDsgaiA8IGNieTE7IGorKykge1xyXG4gICAgICBmb3IgKGkgPSBjYngwOyBpIDwgY2J4MTsgaSsrKSB7XHJcbiAgICAgICAgY29kZWJsb2NrID0ge1xyXG4gICAgICAgICAgY2J4OiBpLFxyXG4gICAgICAgICAgY2J5OiBqLFxyXG4gICAgICAgICAgdGJ4MDogY29kZWJsb2NrV2lkdGggKiBpLFxyXG4gICAgICAgICAgdGJ5MDogY29kZWJsb2NrSGVpZ2h0ICogaixcclxuICAgICAgICAgIHRieDE6IGNvZGVibG9ja1dpZHRoICogKGkgKyAxKSxcclxuICAgICAgICAgIHRieTE6IGNvZGVibG9ja0hlaWdodCAqIChqICsgMSlcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb2RlYmxvY2sudGJ4MF8gPSBNYXRoLm1heChzdWJiYW5kLnRieDAsIGNvZGVibG9jay50YngwKTtcclxuICAgICAgICBjb2RlYmxvY2sudGJ5MF8gPSBNYXRoLm1heChzdWJiYW5kLnRieTAsIGNvZGVibG9jay50YnkwKTtcclxuICAgICAgICBjb2RlYmxvY2sudGJ4MV8gPSBNYXRoLm1pbihzdWJiYW5kLnRieDEsIGNvZGVibG9jay50YngxKTtcclxuICAgICAgICBjb2RlYmxvY2sudGJ5MV8gPSBNYXRoLm1pbihzdWJiYW5kLnRieTEsIGNvZGVibG9jay50YnkxKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNpbmN0IG51bWJlciBmb3IgdGhpcyBjb2RlYmxvY2ssIGNvZGVibG9jayBwb3NpdGlvblxyXG4gICAgICAgIC8vIHNob3VsZCBiZSByZWxhdGl2ZSB0byBpdHMgc3ViYmFuZCwgdXNlIGFjdHVhbCBkaW1lbnNpb24gYW5kIHBvc2l0aW9uXHJcbiAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdXQgY29kZWJsb2NrIGdyb3VwIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgICAgICB2YXIgcGkgPSBNYXRoLmZsb29yKChjb2RlYmxvY2sudGJ4MF8gLSBzdWJiYW5kLnRieDApIC9cclxuICAgICAgICAgIHByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdFdpZHRoSW5TdWJiYW5kKTtcclxuICAgICAgICB2YXIgcGogPSBNYXRoLmZsb29yKChjb2RlYmxvY2sudGJ5MF8gLSBzdWJiYW5kLnRieTApIC9cclxuICAgICAgICAgIHByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdEhlaWdodEluU3ViYmFuZCk7XHJcbiAgICAgICAgcHJlY2luY3ROdW1iZXIgPSBwaSArIChwaiAqIHByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHN3aWRlKTtcclxuXHJcbiAgICAgICAgY29kZWJsb2NrLnByZWNpbmN0TnVtYmVyID0gcHJlY2luY3ROdW1iZXI7XHJcbiAgICAgICAgY29kZWJsb2NrLnN1YmJhbmRUeXBlID0gc3ViYmFuZC50eXBlO1xyXG4gICAgICAgIGNvZGVibG9jay5MYmxvY2sgPSAzO1xyXG5cclxuICAgICAgICBpZiAoY29kZWJsb2NrLnRieDFfIDw9IGNvZGVibG9jay50YngwXyB8fFxyXG4gICAgICAgICAgICBjb2RlYmxvY2sudGJ5MV8gPD0gY29kZWJsb2NrLnRieTBfKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29kZWJsb2Nrcy5wdXNoKGNvZGVibG9jayk7XHJcbiAgICAgICAgLy8gYnVpbGRpbmcgcHJlY2luY3QgZm9yIHRoZSBzdWItYmFuZFxyXG4gICAgICAgIHZhciBwcmVjaW5jdCA9IHByZWNpbmN0c1twcmVjaW5jdE51bWJlcl07XHJcbiAgICAgICAgaWYgKHByZWNpbmN0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGlmIChpIDwgcHJlY2luY3QuY2J4TWluKSB7XHJcbiAgICAgICAgICAgIHByZWNpbmN0LmNieE1pbiA9IGk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPiBwcmVjaW5jdC5jYnhNYXgpIHtcclxuICAgICAgICAgICAgcHJlY2luY3QuY2J4TWF4ID0gaTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChqIDwgcHJlY2luY3QuY2J5TWluKSB7XHJcbiAgICAgICAgICAgIHByZWNpbmN0LmNieE1pbiA9IGo7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGogPiBwcmVjaW5jdC5jYnlNYXgpIHtcclxuICAgICAgICAgICAgcHJlY2luY3QuY2J5TWF4ID0gajtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJlY2luY3RzW3ByZWNpbmN0TnVtYmVyXSA9IHByZWNpbmN0ID0ge1xyXG4gICAgICAgICAgICBjYnhNaW46IGksXHJcbiAgICAgICAgICAgIGNieU1pbjogaixcclxuICAgICAgICAgICAgY2J4TWF4OiBpLFxyXG4gICAgICAgICAgICBjYnlNYXg6IGpcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvZGVibG9jay5wcmVjaW5jdCA9IHByZWNpbmN0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzdWJiYW5kLmNvZGVibG9ja1BhcmFtZXRlcnMgPSB7XHJcbiAgICAgIGNvZGVibG9ja1dpZHRoOiB4Y2JfLFxyXG4gICAgICBjb2RlYmxvY2tIZWlnaHQ6IHljYl8sXHJcbiAgICAgIG51bWNvZGVibG9ja3dpZGU6IGNieDEgLSBjYngwICsgMSxcclxuICAgICAgbnVtY29kZWJsb2NraGlnaDogY2J5MSAtIGNieTAgKyAxXHJcbiAgICB9O1xyXG4gICAgc3ViYmFuZC5jb2RlYmxvY2tzID0gY29kZWJsb2NrcztcclxuICAgIHN1YmJhbmQucHJlY2luY3RzID0gcHJlY2luY3RzO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgcHJlY2luY3ROdW1iZXIsIGxheWVyTnVtYmVyKSB7XHJcbiAgICB2YXIgcHJlY2luY3RDb2RlYmxvY2tzID0gW107XHJcbiAgICAvLyBTZWN0aW9uIEIuMTAuOCBPcmRlciBvZiBpbmZvIGluIHBhY2tldFxyXG4gICAgdmFyIHN1YmJhbmRzID0gcmVzb2x1dGlvbi5zdWJiYW5kcztcclxuICAgIC8vIHN1Yi1iYW5kcyBhbHJlYWR5IG9yZGVyZWQgaW4gJ0xMJywgJ0hMJywgJ0xIJywgYW5kICdISCcgc2VxdWVuY2VcclxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHN1YmJhbmRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgdmFyIHN1YmJhbmQgPSBzdWJiYW5kc1tpXTtcclxuICAgICAgdmFyIGNvZGVibG9ja3MgPSBzdWJiYW5kLmNvZGVibG9ja3M7XHJcbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGNvZGVibG9ja3MubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgIHZhciBjb2RlYmxvY2sgPSBjb2RlYmxvY2tzW2pdO1xyXG4gICAgICAgIGlmIChjb2RlYmxvY2sucHJlY2luY3ROdW1iZXIgIT09IHByZWNpbmN0TnVtYmVyKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJlY2luY3RDb2RlYmxvY2tzLnB1c2goY29kZWJsb2NrKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGF5ZXJOdW1iZXI6IGxheWVyTnVtYmVyLFxyXG4gICAgICBjb2RlYmxvY2tzOiBwcmVjaW5jdENvZGVibG9ja3NcclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIExheWVyUmVzb2x1dGlvbkNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoY29udGV4dCkge1xyXG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xyXG4gICAgdmFyIHRpbGVJbmRleCA9IGNvbnRleHQuY3VycmVudFRpbGUuaW5kZXg7XHJcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcclxuICAgIHZhciBsYXllcnNDb3VudCA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5sYXllcnNDb3VudDtcclxuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcclxuICAgIHZhciBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSAwO1xyXG4gICAgZm9yICh2YXIgcSA9IDA7IHEgPCBjb21wb25lbnRzQ291bnQ7IHErKykge1xyXG4gICAgICBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSBNYXRoLm1heChtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQsXHJcbiAgICAgICAgdGlsZS5jb21wb25lbnRzW3FdLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsID0gMCwgciA9IDAsIGkgPSAwLCBrID0gMDtcclxuXHJcbiAgICB0aGlzLm5leHRQYWNrZXQgPSBmdW5jdGlvbiBKcHhJbWFnZV9uZXh0UGFja2V0KCkge1xyXG4gICAgICAvLyBTZWN0aW9uIEIuMTIuMS4xIExheWVyLXJlc29sdXRpb24tY29tcG9uZW50LXBvc2l0aW9uXHJcbiAgICAgIGZvciAoOyBsIDwgbGF5ZXJzQ291bnQ7IGwrKykge1xyXG4gICAgICAgIGZvciAoOyByIDw9IG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbaV07XHJcbiAgICAgICAgICAgIGlmIChyID4gY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XHJcbiAgICAgICAgICAgIHZhciBudW1wcmVjaW5jdHMgPSByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHM7XHJcbiAgICAgICAgICAgIGZvciAoOyBrIDwgbnVtcHJlY2luY3RzOykge1xyXG4gICAgICAgICAgICAgIHZhciBwYWNrZXQgPSBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgaywgbCk7XHJcbiAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgayA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgciA9IDA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIFJlc29sdXRpb25MYXllckNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoY29udGV4dCkge1xyXG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xyXG4gICAgdmFyIHRpbGVJbmRleCA9IGNvbnRleHQuY3VycmVudFRpbGUuaW5kZXg7XHJcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcclxuICAgIHZhciBsYXllcnNDb3VudCA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5sYXllcnNDb3VudDtcclxuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcclxuICAgIHZhciBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSAwO1xyXG4gICAgZm9yICh2YXIgcSA9IDA7IHEgPCBjb21wb25lbnRzQ291bnQ7IHErKykge1xyXG4gICAgICBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSBNYXRoLm1heChtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQsXHJcbiAgICAgICAgdGlsZS5jb21wb25lbnRzW3FdLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByID0gMCwgbCA9IDAsIGkgPSAwLCBrID0gMDtcclxuXHJcbiAgICB0aGlzLm5leHRQYWNrZXQgPSBmdW5jdGlvbiBKcHhJbWFnZV9uZXh0UGFja2V0KCkge1xyXG4gICAgICAvLyBTZWN0aW9uIEIuMTIuMS4yIFJlc29sdXRpb24tbGF5ZXItY29tcG9uZW50LXBvc2l0aW9uXHJcbiAgICAgIGZvciAoOyByIDw9IG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XHJcbiAgICAgICAgZm9yICg7IGwgPCBsYXllcnNDb3VudDsgbCsrKSB7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbaV07XHJcbiAgICAgICAgICAgIGlmIChyID4gY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XHJcbiAgICAgICAgICAgIHZhciBudW1wcmVjaW5jdHMgPSByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHM7XHJcbiAgICAgICAgICAgIGZvciAoOyBrIDwgbnVtcHJlY2luY3RzOykge1xyXG4gICAgICAgICAgICAgIHZhciBwYWNrZXQgPSBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgaywgbCk7XHJcbiAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgayA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbCA9IDA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIFJlc29sdXRpb25Qb3NpdGlvbkNvbXBvbmVudExheWVySXRlcmF0b3IoY29udGV4dCkge1xyXG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xyXG4gICAgdmFyIHRpbGVJbmRleCA9IGNvbnRleHQuY3VycmVudFRpbGUuaW5kZXg7XHJcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcclxuICAgIHZhciBsYXllcnNDb3VudCA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5sYXllcnNDb3VudDtcclxuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcclxuICAgIHZhciBsLCByLCBjLCBwO1xyXG4gICAgdmFyIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IDA7XHJcbiAgICBmb3IgKGMgPSAwOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcclxuICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcclxuICAgICAgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gTWF0aC5tYXgobWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50LFxyXG4gICAgICAgIGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KTtcclxuICAgIH1cclxuICAgIHZhciBtYXhOdW1QcmVjaW5jdHNJbkxldmVsID0gbmV3IEludDMyQXJyYXkoXHJcbiAgICAgIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCArIDEpO1xyXG4gICAgZm9yIChyID0gMDsgciA8PSBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7ICsrcikge1xyXG4gICAgICB2YXIgbWF4TnVtUHJlY2luY3RzID0gMDtcclxuICAgICAgZm9yIChjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgKytjKSB7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb25zID0gdGlsZS5jb21wb25lbnRzW2NdLnJlc29sdXRpb25zO1xyXG4gICAgICAgIGlmIChyIDwgcmVzb2x1dGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBtYXhOdW1QcmVjaW5jdHMgPSBNYXRoLm1heChtYXhOdW1QcmVjaW5jdHMsXHJcbiAgICAgICAgICAgIHJlc29sdXRpb25zW3JdLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBtYXhOdW1QcmVjaW5jdHNJbkxldmVsW3JdID0gbWF4TnVtUHJlY2luY3RzO1xyXG4gICAgfVxyXG4gICAgbCA9IDA7XHJcbiAgICByID0gMDtcclxuICAgIGMgPSAwO1xyXG4gICAgcCA9IDA7XHJcblxyXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcclxuICAgICAgLy8gU2VjdGlvbiBCLjEyLjEuMyBSZXNvbHV0aW9uLXBvc2l0aW9uLWNvbXBvbmVudC1sYXllclxyXG4gICAgICBmb3IgKDsgciA8PSBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xyXG4gICAgICAgIGZvciAoOyBwIDwgbWF4TnVtUHJlY2luY3RzSW5MZXZlbFtyXTsgcCsrKSB7XHJcbiAgICAgICAgICBmb3IgKDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XHJcbiAgICAgICAgICAgIGlmIChyID4gY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvbXBvbmVudC5yZXNvbHV0aW9uc1tyXTtcclxuICAgICAgICAgICAgdmFyIG51bXByZWNpbmN0cyA9IHJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzLm51bXByZWNpbmN0cztcclxuICAgICAgICAgICAgaWYgKHAgPj0gbnVtcHJlY2luY3RzKSB7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICg7IGwgPCBsYXllcnNDb3VudDspIHtcclxuICAgICAgICAgICAgICB2YXIgcGFja2V0ID0gY3JlYXRlUGFja2V0KHJlc29sdXRpb24sIHAsIGwpO1xyXG4gICAgICAgICAgICAgIGwrKztcclxuICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGwgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHAgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBQb3NpdGlvbkNvbXBvbmVudFJlc29sdXRpb25MYXllckl0ZXJhdG9yKGNvbnRleHQpIHtcclxuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcclxuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xyXG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XHJcbiAgICB2YXIgbGF5ZXJzQ291bnQgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQ7XHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XHJcbiAgICB2YXIgcHJlY2luY3RzU2l6ZXMgPSBnZXRQcmVjaW5jdFNpemVzSW5JbWFnZVNjYWxlKHRpbGUpO1xyXG4gICAgdmFyIHByZWNpbmN0c0l0ZXJhdGlvblNpemVzID0gcHJlY2luY3RzU2l6ZXM7XHJcbiAgICB2YXIgbCA9IDAsIHIgPSAwLCBjID0gMCwgcHggPSAwLCBweSA9IDA7XHJcblxyXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcclxuICAgICAgLy8gU2VjdGlvbiBCLjEyLjEuNCBQb3NpdGlvbi1jb21wb25lbnQtcmVzb2x1dGlvbi1sYXllclxyXG4gICAgICBmb3IgKDsgcHkgPCBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5tYXhOdW1IaWdoOyBweSsrKSB7XHJcbiAgICAgICAgZm9yICg7IHB4IDwgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMubWF4TnVtV2lkZTsgcHgrKykge1xyXG4gICAgICAgICAgZm9yICg7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xyXG4gICAgICAgICAgICB2YXIgZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID1cclxuICAgICAgICAgICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtcclxuICAgICAgICAgICAgZm9yICg7IHIgPD0gZGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyByKyspIHtcclxuICAgICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvbXBvbmVudC5yZXNvbHV0aW9uc1tyXTtcclxuICAgICAgICAgICAgICB2YXIgc2l6ZUluSW1hZ2VTY2FsZSA9XHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdHNTaXplcy5jb21wb25lbnRzW2NdLnJlc29sdXRpb25zW3JdO1xyXG4gICAgICAgICAgICAgIHZhciBrID0gZ2V0UHJlY2luY3RJbmRleElmRXhpc3QoXHJcbiAgICAgICAgICAgICAgICBweCxcclxuICAgICAgICAgICAgICAgIHB5LFxyXG4gICAgICAgICAgICAgICAgc2l6ZUluSW1hZ2VTY2FsZSxcclxuICAgICAgICAgICAgICAgIHByZWNpbmN0c0l0ZXJhdGlvblNpemVzLFxyXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgaWYgKGsgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBmb3IgKDsgbCA8IGxheWVyc0NvdW50Oykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhY2tldCA9IGNyZWF0ZVBhY2tldChyZXNvbHV0aW9uLCBrLCBsKTtcclxuICAgICAgICAgICAgICAgIGwrKztcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHIgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB4ID0gMDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gQ29tcG9uZW50UG9zaXRpb25SZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihjb250ZXh0KSB7XHJcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XHJcbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcclxuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xyXG4gICAgdmFyIGxheWVyc0NvdW50ID0gdGlsZS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLmxheWVyc0NvdW50O1xyXG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xyXG4gICAgdmFyIHByZWNpbmN0c1NpemVzID0gZ2V0UHJlY2luY3RTaXplc0luSW1hZ2VTY2FsZSh0aWxlKTtcclxuICAgIHZhciBsID0gMCwgciA9IDAsIGMgPSAwLCBweCA9IDAsIHB5ID0gMDtcclxuXHJcbiAgICB0aGlzLm5leHRQYWNrZXQgPSBmdW5jdGlvbiBKcHhJbWFnZV9uZXh0UGFja2V0KCkge1xyXG4gICAgICAvLyBTZWN0aW9uIEIuMTIuMS41IENvbXBvbmVudC1wb3NpdGlvbi1yZXNvbHV0aW9uLWxheWVyXHJcbiAgICAgIGZvciAoOyBjIDwgY29tcG9uZW50c0NvdW50OyArK2MpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xyXG4gICAgICAgIHZhciBwcmVjaW5jdHNJdGVyYXRpb25TaXplcyA9IHByZWNpbmN0c1NpemVzLmNvbXBvbmVudHNbY107XHJcbiAgICAgICAgdmFyIGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9XHJcbiAgICAgICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtcclxuICAgICAgICBmb3IgKDsgcHkgPCBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5tYXhOdW1IaWdoOyBweSsrKSB7XHJcbiAgICAgICAgICBmb3IgKDsgcHggPCBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5tYXhOdW1XaWRlOyBweCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAoOyByIDw9IGRlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XHJcbiAgICAgICAgICAgICAgdmFyIHNpemVJbkltYWdlU2NhbGUgPSBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5yZXNvbHV0aW9uc1tyXTtcclxuICAgICAgICAgICAgICB2YXIgayA9IGdldFByZWNpbmN0SW5kZXhJZkV4aXN0KFxyXG4gICAgICAgICAgICAgICAgcHgsXHJcbiAgICAgICAgICAgICAgICBweSxcclxuICAgICAgICAgICAgICAgIHNpemVJbkltYWdlU2NhbGUsXHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdHNJdGVyYXRpb25TaXplcyxcclxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24pO1xyXG4gICAgICAgICAgICAgIGlmIChrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZm9yICg7IGwgPCBsYXllcnNDb3VudDspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYWNrZXQgPSBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgaywgbCk7XHJcbiAgICAgICAgICAgICAgICBsKys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHB4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHkgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRQcmVjaW5jdEluZGV4SWZFeGlzdChcclxuICAgIHB4SW5kZXgsIHB5SW5kZXgsIHNpemVJbkltYWdlU2NhbGUsIHByZWNpbmN0SXRlcmF0aW9uU2l6ZXMsIHJlc29sdXRpb24pIHtcclxuICAgIHZhciBwb3NYID0gcHhJbmRleCAqIHByZWNpbmN0SXRlcmF0aW9uU2l6ZXMubWluV2lkdGg7XHJcbiAgICB2YXIgcG9zWSA9IHB5SW5kZXggKiBwcmVjaW5jdEl0ZXJhdGlvblNpemVzLm1pbkhlaWdodDtcclxuICAgIGlmIChwb3NYICUgc2l6ZUluSW1hZ2VTY2FsZS53aWR0aCAhPT0gMCB8fFxyXG4gICAgICAgIHBvc1kgJSBzaXplSW5JbWFnZVNjYWxlLmhlaWdodCAhPT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBzdGFydFByZWNpbmN0Um93SW5kZXggPVxyXG4gICAgICAocG9zWSAvIHNpemVJbkltYWdlU2NhbGUud2lkdGgpICpcclxuICAgICAgcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3Rzd2lkZTtcclxuICAgIHJldHVybiAocG9zWCAvIHNpemVJbkltYWdlU2NhbGUuaGVpZ2h0KSArIHN0YXJ0UHJlY2luY3RSb3dJbmRleDtcclxuICB9XHJcbiAgZnVuY3Rpb24gZ2V0UHJlY2luY3RTaXplc0luSW1hZ2VTY2FsZSh0aWxlKSB7XHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gdGlsZS5jb21wb25lbnRzLmxlbmd0aDtcclxuICAgIHZhciBtaW5XaWR0aCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICB2YXIgbWluSGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIHZhciBtYXhOdW1XaWRlID0gMDtcclxuICAgIHZhciBtYXhOdW1IaWdoID0gMDtcclxuICAgIHZhciBzaXplUGVyQ29tcG9uZW50ID0gbmV3IEFycmF5KGNvbXBvbmVudHNDb3VudCk7XHJcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XHJcbiAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XHJcbiAgICAgIHZhciBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPVxyXG4gICAgICAgIGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50O1xyXG4gICAgICB2YXIgc2l6ZVBlclJlc29sdXRpb24gPSBuZXcgQXJyYXkoZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ICsgMSk7XHJcbiAgICAgIHZhciBtaW5XaWR0aEN1cnJlbnRDb21wb25lbnQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICB2YXIgbWluSGVpZ2h0Q3VycmVudENvbXBvbmVudCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgIHZhciBtYXhOdW1XaWRlQ3VycmVudENvbXBvbmVudCA9IDA7XHJcbiAgICAgIHZhciBtYXhOdW1IaWdoQ3VycmVudENvbXBvbmVudCA9IDA7XHJcbiAgICAgIHZhciBzY2FsZSA9IDE7XHJcbiAgICAgIGZvciAodmFyIHIgPSBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIgPj0gMDsgLS1yKSB7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XHJcbiAgICAgICAgdmFyIHdpZHRoQ3VycmVudFJlc29sdXRpb24gPVxyXG4gICAgICAgICAgc2NhbGUgKiByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdFdpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHRDdXJyZW50UmVzb2x1dGlvbiA9XHJcbiAgICAgICAgICBzY2FsZSAqIHJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzLnByZWNpbmN0SGVpZ2h0O1xyXG4gICAgICAgIG1pbldpZHRoQ3VycmVudENvbXBvbmVudCA9IE1hdGgubWluKFxyXG4gICAgICAgICAgbWluV2lkdGhDdXJyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgd2lkdGhDdXJyZW50UmVzb2x1dGlvbik7XHJcbiAgICAgICAgbWluSGVpZ2h0Q3VycmVudENvbXBvbmVudCA9IE1hdGgubWluKFxyXG4gICAgICAgICAgbWluSGVpZ2h0Q3VycmVudENvbXBvbmVudCxcclxuICAgICAgICAgIGhlaWdodEN1cnJlbnRSZXNvbHV0aW9uKTtcclxuICAgICAgICBtYXhOdW1XaWRlQ3VycmVudENvbXBvbmVudCA9IE1hdGgubWF4KG1heE51bVdpZGVDdXJyZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3Rzd2lkZSk7XHJcbiAgICAgICAgbWF4TnVtSGlnaEN1cnJlbnRDb21wb25lbnQgPSBNYXRoLm1heChtYXhOdW1IaWdoQ3VycmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzLm51bXByZWNpbmN0c2hpZ2gpO1xyXG4gICAgICAgIHNpemVQZXJSZXNvbHV0aW9uW3JdID0ge1xyXG4gICAgICAgICAgd2lkdGg6IHdpZHRoQ3VycmVudFJlc29sdXRpb24sXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodEN1cnJlbnRSZXNvbHV0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzY2FsZSA8PD0gMTtcclxuICAgICAgfVxyXG4gICAgICBtaW5XaWR0aCA9IE1hdGgubWluKG1pbldpZHRoLCBtaW5XaWR0aEN1cnJlbnRDb21wb25lbnQpO1xyXG4gICAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihtaW5IZWlnaHQsIG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQpO1xyXG4gICAgICBtYXhOdW1XaWRlID0gTWF0aC5tYXgobWF4TnVtV2lkZSwgbWF4TnVtV2lkZUN1cnJlbnRDb21wb25lbnQpO1xyXG4gICAgICBtYXhOdW1IaWdoID0gTWF0aC5tYXgobWF4TnVtSGlnaCwgbWF4TnVtSGlnaEN1cnJlbnRDb21wb25lbnQpO1xyXG4gICAgICBzaXplUGVyQ29tcG9uZW50W2NdID0ge1xyXG4gICAgICAgIHJlc29sdXRpb25zOiBzaXplUGVyUmVzb2x1dGlvbixcclxuICAgICAgICBtaW5XaWR0aDogbWluV2lkdGhDdXJyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIG1pbkhlaWdodDogbWluSGVpZ2h0Q3VycmVudENvbXBvbmVudCxcclxuICAgICAgICBtYXhOdW1XaWRlOiBtYXhOdW1XaWRlQ3VycmVudENvbXBvbmVudCxcclxuICAgICAgICBtYXhOdW1IaWdoOiBtYXhOdW1IaWdoQ3VycmVudENvbXBvbmVudFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29tcG9uZW50czogc2l6ZVBlckNvbXBvbmVudCxcclxuICAgICAgbWluV2lkdGg6IG1pbldpZHRoLFxyXG4gICAgICBtaW5IZWlnaHQ6IG1pbkhlaWdodCxcclxuICAgICAgbWF4TnVtV2lkZTogbWF4TnVtV2lkZSxcclxuICAgICAgbWF4TnVtSGlnaDogbWF4TnVtSGlnaFxyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYnVpbGRQYWNrZXRzKGNvbnRleHQpIHtcclxuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcclxuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xyXG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XHJcbiAgICAvLyBDcmVhdGluZyByZXNvbHV0aW9ucyBhbmQgc3ViLWJhbmRzIGZvciBlYWNoIGNvbXBvbmVudFxyXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xyXG4gICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xyXG4gICAgICB2YXIgZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID1cclxuICAgICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtcclxuICAgICAgLy8gU2VjdGlvbiBCLjUgUmVzb2x1dGlvbiBsZXZlbHMgYW5kIHN1Yi1iYW5kc1xyXG4gICAgICB2YXIgcmVzb2x1dGlvbnMgPSBbXTtcclxuICAgICAgdmFyIHN1YmJhbmRzID0gW107XHJcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDw9IGRlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XHJcbiAgICAgICAgdmFyIGJsb2Nrc0RpbWVuc2lvbnMgPSBnZXRCbG9ja3NEaW1lbnNpb25zKGNvbnRleHQsIGNvbXBvbmVudCwgcik7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB7fTtcclxuICAgICAgICB2YXIgc2NhbGUgPSAxIDw8IChkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgLSByKTtcclxuICAgICAgICByZXNvbHV0aW9uLnRyeDAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDAgLyBzY2FsZSk7XHJcbiAgICAgICAgcmVzb2x1dGlvbi50cnkwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kwIC8gc2NhbGUpO1xyXG4gICAgICAgIHJlc29sdXRpb24udHJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIHNjYWxlKTtcclxuICAgICAgICByZXNvbHV0aW9uLnRyeTEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTEgLyBzY2FsZSk7XHJcbiAgICAgICAgcmVzb2x1dGlvbi5yZXNMZXZlbCA9IHI7XHJcbiAgICAgICAgYnVpbGRQcmVjaW5jdHMoY29udGV4dCwgcmVzb2x1dGlvbiwgYmxvY2tzRGltZW5zaW9ucyk7XHJcbiAgICAgICAgcmVzb2x1dGlvbnMucHVzaChyZXNvbHV0aW9uKTtcclxuXHJcbiAgICAgICAgdmFyIHN1YmJhbmQ7XHJcbiAgICAgICAgaWYgKHIgPT09IDApIHtcclxuICAgICAgICAgIC8vIG9uZSBzdWItYmFuZCAoTEwpIHdpdGggbGFzdCBkZWNvbXBvc2l0aW9uXHJcbiAgICAgICAgICBzdWJiYW5kID0ge307XHJcbiAgICAgICAgICBzdWJiYW5kLnR5cGUgPSAnTEwnO1xyXG4gICAgICAgICAgc3ViYmFuZC50YngwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gwIC8gc2NhbGUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YnkwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kwIC8gc2NhbGUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YngxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gxIC8gc2NhbGUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YnkxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kxIC8gc2NhbGUpO1xyXG4gICAgICAgICAgc3ViYmFuZC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgICAgICAgIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBibG9ja3NEaW1lbnNpb25zKTtcclxuICAgICAgICAgIHN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XHJcbiAgICAgICAgICByZXNvbHV0aW9uLnN1YmJhbmRzID0gW3N1YmJhbmRdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgYnNjYWxlID0gMSA8PCAoZGVjb21wb3NpdGlvbkxldmVsc0NvdW50IC0gciArIDEpO1xyXG4gICAgICAgICAgdmFyIHJlc29sdXRpb25TdWJiYW5kcyA9IFtdO1xyXG4gICAgICAgICAgLy8gdGhyZWUgc3ViLWJhbmRzIChITCwgTEggYW5kIEhIKSB3aXRoIHJlc3Qgb2YgZGVjb21wb3NpdGlvbnNcclxuICAgICAgICAgIHN1YmJhbmQgPSB7fTtcclxuICAgICAgICAgIHN1YmJhbmQudHlwZSA9ICdITCc7XHJcbiAgICAgICAgICBzdWJiYW5kLnRieDAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDAgLyBic2NhbGUgLSAwLjUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YnkwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kwIC8gYnNjYWxlKTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIGJzY2FsZSAtIDAuNSk7XHJcbiAgICAgICAgICBzdWJiYW5kLnRieTEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTEgLyBic2NhbGUpO1xyXG4gICAgICAgICAgc3ViYmFuZC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgICAgICAgIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBibG9ja3NEaW1lbnNpb25zKTtcclxuICAgICAgICAgIHN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XHJcbiAgICAgICAgICByZXNvbHV0aW9uU3ViYmFuZHMucHVzaChzdWJiYW5kKTtcclxuXHJcbiAgICAgICAgICBzdWJiYW5kID0ge307XHJcbiAgICAgICAgICBzdWJiYW5kLnR5cGUgPSAnTEgnO1xyXG4gICAgICAgICAgc3ViYmFuZC50YngwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gwIC8gYnNjYWxlKTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ5MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MCAvIGJzY2FsZSAtIDAuNSk7XHJcbiAgICAgICAgICBzdWJiYW5kLnRieDEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDEgLyBic2NhbGUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YnkxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kxIC8gYnNjYWxlIC0gMC41KTtcclxuICAgICAgICAgIHN1YmJhbmQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XHJcbiAgICAgICAgICBidWlsZENvZGVibG9ja3MoY29udGV4dCwgc3ViYmFuZCwgYmxvY2tzRGltZW5zaW9ucyk7XHJcbiAgICAgICAgICBzdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xyXG4gICAgICAgICAgcmVzb2x1dGlvblN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XHJcblxyXG4gICAgICAgICAgc3ViYmFuZCA9IHt9O1xyXG4gICAgICAgICAgc3ViYmFuZC50eXBlID0gJ0hIJztcclxuICAgICAgICAgIHN1YmJhbmQudGJ4MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MCAvIGJzY2FsZSAtIDAuNSk7XHJcbiAgICAgICAgICBzdWJiYW5kLnRieTAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTAgLyBic2NhbGUgLSAwLjUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YngxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gxIC8gYnNjYWxlIC0gMC41KTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ5MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MSAvIGJzY2FsZSAtIDAuNSk7XHJcbiAgICAgICAgICBzdWJiYW5kLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgYnVpbGRDb2RlYmxvY2tzKGNvbnRleHQsIHN1YmJhbmQsIGJsb2Nrc0RpbWVuc2lvbnMpO1xyXG4gICAgICAgICAgc3ViYmFuZHMucHVzaChzdWJiYW5kKTtcclxuICAgICAgICAgIHJlc29sdXRpb25TdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xyXG5cclxuICAgICAgICAgIHJlc29sdXRpb24uc3ViYmFuZHMgPSByZXNvbHV0aW9uU3ViYmFuZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbXBvbmVudC5yZXNvbHV0aW9ucyA9IHJlc29sdXRpb25zO1xyXG4gICAgICBjb21wb25lbnQuc3ViYmFuZHMgPSBzdWJiYW5kcztcclxuICAgIH1cclxuICAgIC8vIEdlbmVyYXRlIHRoZSBwYWNrZXRzIHNlcXVlbmNlXHJcbiAgICB2YXIgcHJvZ3Jlc3Npb25PcmRlciA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5wcm9ncmVzc2lvbk9yZGVyO1xyXG4gICAgc3dpdGNoIChwcm9ncmVzc2lvbk9yZGVyKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XHJcbiAgICAgICAgICBuZXcgTGF5ZXJSZXNvbHV0aW9uQ29tcG9uZW50UG9zaXRpb25JdGVyYXRvcihjb250ZXh0KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHRpbGUucGFja2V0c0l0ZXJhdG9yID1cclxuICAgICAgICAgIG5ldyBSZXNvbHV0aW9uTGF5ZXJDb21wb25lbnRQb3NpdGlvbkl0ZXJhdG9yKGNvbnRleHQpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgdGlsZS5wYWNrZXRzSXRlcmF0b3IgPVxyXG4gICAgICAgICAgbmV3IFJlc29sdXRpb25Qb3NpdGlvbkNvbXBvbmVudExheWVySXRlcmF0b3IoY29udGV4dCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XHJcbiAgICAgICAgICBuZXcgUG9zaXRpb25Db21wb25lbnRSZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihjb250ZXh0KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA0OlxyXG4gICAgICAgIHRpbGUucGFja2V0c0l0ZXJhdG9yID1cclxuICAgICAgICAgIG5ldyBDb21wb25lbnRQb3NpdGlvblJlc29sdXRpb25MYXllckl0ZXJhdG9yKGNvbnRleHQpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBVbnN1cHBvcnRlZCBwcm9ncmVzc2lvbiBvcmRlciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3Npb25PcmRlcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlVGlsZVBhY2tldHMoY29udGV4dCwgZGF0YSwgb2Zmc2V0LCBkYXRhTGVuZ3RoKSB7XHJcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xyXG4gICAgdmFyIGJ1ZmZlciwgYnVmZmVyU2l6ZSA9IDAsIHNraXBOZXh0Qml0ID0gZmFsc2U7XHJcbiAgICBmdW5jdGlvbiByZWFkQml0cyhjb3VudCkge1xyXG4gICAgICB3aGlsZSAoYnVmZmVyU2l6ZSA8IGNvdW50KSB7XHJcbiAgICAgICAgaWYob2Zmc2V0ICsgcG9zaXRpb24gID49IGRhdGEubGVuZ3RoKXtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgRU9GXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYiA9IGRhdGFbb2Zmc2V0ICsgcG9zaXRpb25dO1xyXG4gICAgICAgIHBvc2l0aW9uKys7XHJcbiAgICAgICAgaWYgKHNraXBOZXh0Qml0KSB7XHJcbiAgICAgICAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDcpIHwgYjtcclxuICAgICAgICAgIGJ1ZmZlclNpemUgKz0gNztcclxuICAgICAgICAgIHNraXBOZXh0Qml0ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBiO1xyXG4gICAgICAgICAgYnVmZmVyU2l6ZSArPSA4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYiA9PT0gMHhGRikge1xyXG4gICAgICAgICAgc2tpcE5leHRCaXQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBidWZmZXJTaXplIC09IGNvdW50O1xyXG4gICAgICByZXR1cm4gKGJ1ZmZlciA+Pj4gYnVmZmVyU2l6ZSkgJiAoKDEgPDwgY291bnQpIC0gMSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBza2lwTWFya2VySWZFcXVhbCh2YWx1ZSkge1xyXG4gICAgICBpZiAoZGF0YVtvZmZzZXQgKyBwb3NpdGlvbiAtIDFdID09PSAweEZGICYmXHJcbiAgICAgICAgICBkYXRhW29mZnNldCArIHBvc2l0aW9uXSA9PT0gdmFsdWUpIHtcclxuICAgICAgICBza2lwQnl0ZXMoMSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZGF0YVtvZmZzZXQgKyBwb3NpdGlvbl0gPT09IDB4RkYgJiZcclxuICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIHBvc2l0aW9uICsgMV0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgc2tpcEJ5dGVzKDIpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNraXBCeXRlcyhjb3VudCkge1xyXG4gICAgICBwb3NpdGlvbiArPSBjb3VudDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFsaWduVG9CeXRlKCkge1xyXG4gICAgICBidWZmZXJTaXplID0gMDtcclxuICAgICAgaWYgKHNraXBOZXh0Qml0KSB7XHJcbiAgICAgICAgcG9zaXRpb24rKztcclxuICAgICAgICBza2lwTmV4dEJpdCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWFkQ29kaW5ncGFzc2VzKCkge1xyXG4gICAgICBpZiAocmVhZEJpdHMoMSkgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVhZEJpdHMoMSkgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gMjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdmFsdWUgPSByZWFkQml0cygyKTtcclxuICAgICAgaWYgKHZhbHVlIDwgMykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSArIDM7XHJcbiAgICAgIH1cclxuICAgICAgdmFsdWUgPSByZWFkQml0cyg1KTtcclxuICAgICAgaWYgKHZhbHVlIDwgMzEpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgKyA2O1xyXG4gICAgICB9XHJcbiAgICAgIHZhbHVlID0gcmVhZEJpdHMoNyk7XHJcbiAgICAgIHJldHVybiB2YWx1ZSArIDM3O1xyXG4gICAgfVxyXG4gICAgdmFyIHRpbGVJbmRleCA9IGNvbnRleHQuY3VycmVudFRpbGUuaW5kZXg7XHJcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcclxuICAgIHZhciBzb3BNYXJrZXJVc2VkID0gY29udGV4dC5DT0Quc29wTWFya2VyVXNlZDtcclxuICAgIHZhciBlcGhNYXJrZXJVc2VkID0gY29udGV4dC5DT0QuZXBoTWFya2VyVXNlZDtcclxuICAgIHZhciBwYWNrZXRzSXRlcmF0b3IgPSB0aWxlLnBhY2tldHNJdGVyYXRvcjtcclxuICAgIHdoaWxlIChwb3NpdGlvbiA8IGRhdGFMZW5ndGgpIHtcclxuICAgICAgdHJ5e1xyXG4gICAgICAgIGFsaWduVG9CeXRlKCk7XHJcbiAgICAgICAgaWYgKHNvcE1hcmtlclVzZWQgJiYgc2tpcE1hcmtlcklmRXF1YWwoMHg5MSkpIHtcclxuICAgICAgICAgIC8vIFNraXAgYWxzbyBtYXJrZXIgc2VnbWVudCBsZW5ndGggYW5kIHBhY2tldCBzZXF1ZW5jZSBJRFxyXG4gICAgICAgICAgc2tpcEJ5dGVzKDQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFja2V0ID0gcGFja2V0c0l0ZXJhdG9yLm5leHRQYWNrZXQoKTtcclxuICAgICAgICBpZiAocGFja2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIC8vTm8gbW9yZSBwYWNrZXRzLiBTdHJlYW0gaXMgcHJvYmFibHkgdHJ1bmNhdGVkLlxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJlYWRCaXRzKDEpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxheWVyTnVtYmVyID0gcGFja2V0LmxheWVyTnVtYmVyO1xyXG4gICAgICAgIHZhciBxdWV1ZSA9IFtdLCBjb2RlYmxvY2s7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFja2V0LmNvZGVibG9ja3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgY29kZWJsb2NrID0gcGFja2V0LmNvZGVibG9ja3NbaV07XHJcbiAgICAgICAgICB2YXIgcHJlY2luY3QgPSBjb2RlYmxvY2sucHJlY2luY3Q7XHJcbiAgICAgICAgICB2YXIgY29kZWJsb2NrQ29sdW1uID0gY29kZWJsb2NrLmNieCAtIHByZWNpbmN0LmNieE1pbjtcclxuICAgICAgICAgIHZhciBjb2RlYmxvY2tSb3cgPSBjb2RlYmxvY2suY2J5IC0gcHJlY2luY3QuY2J5TWluO1xyXG4gICAgICAgICAgdmFyIGNvZGVibG9ja0luY2x1ZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICB2YXIgZmlyc3RUaW1lSW5jbHVzaW9uID0gZmFsc2U7XHJcbiAgICAgICAgICB2YXIgdmFsdWVSZWFkeTtcclxuICAgICAgICAgIGlmIChjb2RlYmxvY2tbJ2luY2x1ZGVkJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb2RlYmxvY2tJbmNsdWRlZCA9ICEhcmVhZEJpdHMoMSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByZWFkaW5nIGluY2x1c2lvbiB0cmVlXHJcbiAgICAgICAgICAgIHByZWNpbmN0ID0gY29kZWJsb2NrLnByZWNpbmN0O1xyXG4gICAgICAgICAgICB2YXIgaW5jbHVzaW9uVHJlZSwgemVyb0JpdFBsYW5lc1RyZWU7XHJcbiAgICAgICAgICAgIGlmIChwcmVjaW5jdFsnaW5jbHVzaW9uVHJlZSddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlID0gcHJlY2luY3QuaW5jbHVzaW9uVHJlZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBidWlsZGluZyBpbmNsdXNpb24gYW5kIHplcm8gYml0LXBsYW5lcyB0cmVlc1xyXG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IHByZWNpbmN0LmNieE1heCAtIHByZWNpbmN0LmNieE1pbiArIDE7XHJcbiAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHByZWNpbmN0LmNieU1heCAtIHByZWNpbmN0LmNieU1pbiArIDE7XHJcbiAgICAgICAgICAgICAgaW5jbHVzaW9uVHJlZSA9IG5ldyBJbmNsdXNpb25UcmVlKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgIHplcm9CaXRQbGFuZXNUcmVlID0gbmV3IFRhZ1RyZWUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgcHJlY2luY3QuaW5jbHVzaW9uVHJlZSA9IGluY2x1c2lvblRyZWU7XHJcbiAgICAgICAgICAgICAgcHJlY2luY3QuemVyb0JpdFBsYW5lc1RyZWUgPSB6ZXJvQml0UGxhbmVzVHJlZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW5jbHVzaW9uVHJlZS5yZXNldChjb2RlYmxvY2tDb2x1bW4sIGNvZGVibG9ja1JvdywgbGF5ZXJOdW1iZXIpO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uVHJlZS5pc0Fib3ZlVGhyZXNob2xkKCkpe1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChpbmNsdXNpb25UcmVlLmlzS25vd24oKSkge1xyXG4gICAgICAgICAgICAgICAgaW5jbHVzaW9uVHJlZS5uZXh0TGV2ZWwoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAocmVhZEJpdHMoMSkpIHtcclxuICAgICAgICAgICAgICAgIGluY2x1c2lvblRyZWUuc2V0S25vd24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmNsdXNpb25UcmVlLmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvZGVibG9jay5pbmNsdWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGNvZGVibG9ja0luY2x1ZGVkID0gZmlyc3RUaW1lSW5jbHVzaW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlLm5leHRMZXZlbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlLmluY3JlbWVudFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWNvZGVibG9ja0luY2x1ZGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGZpcnN0VGltZUluY2x1c2lvbikge1xyXG4gICAgICAgICAgICB6ZXJvQml0UGxhbmVzVHJlZSA9IHByZWNpbmN0Lnplcm9CaXRQbGFuZXNUcmVlO1xyXG4gICAgICAgICAgICB6ZXJvQml0UGxhbmVzVHJlZS5yZXNldChjb2RlYmxvY2tDb2x1bW4sIGNvZGVibG9ja1Jvdyk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID49IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChyZWFkQml0cygxKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVSZWFkeSA9ICF6ZXJvQml0UGxhbmVzVHJlZS5uZXh0TGV2ZWwoKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB6ZXJvQml0UGxhbmVzVHJlZS5pbmNyZW1lbnRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb2RlYmxvY2suemVyb0JpdFBsYW5lcyA9IHplcm9CaXRQbGFuZXNUcmVlLnZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGNvZGluZ3Bhc3NlcyA9IHJlYWRDb2RpbmdwYXNzZXMoKTtcclxuICAgICAgICAgIHdoaWxlIChyZWFkQml0cygxKSkge1xyXG4gICAgICAgICAgICBjb2RlYmxvY2suTGJsb2NrKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgY29kaW5ncGFzc2VzTG9nMiA9IGxvZzIoY29kaW5ncGFzc2VzKTtcclxuICAgICAgICAgIC8vIHJvdW5kaW5nIGRvd24gbG9nMlxyXG4gICAgICAgICAgdmFyIGJpdHMgPSAoKGNvZGluZ3Bhc3NlcyA8ICgxIDw8IGNvZGluZ3Bhc3Nlc0xvZzIpKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb2RpbmdwYXNzZXNMb2cyIC0gMSA6IGNvZGluZ3Bhc3Nlc0xvZzIpICsgY29kZWJsb2NrLkxibG9jaztcclxuICAgICAgICAgIHZhciBjb2RlZERhdGFMZW5ndGggPSByZWFkQml0cyhiaXRzKTtcclxuICAgICAgICAgIHF1ZXVlLnB1c2goe1xyXG4gICAgICAgICAgICBjb2RlYmxvY2s6IGNvZGVibG9jayxcclxuICAgICAgICAgICAgY29kaW5ncGFzc2VzOiBjb2RpbmdwYXNzZXMsXHJcbiAgICAgICAgICAgIGRhdGFMZW5ndGg6IGNvZGVkRGF0YUxlbmd0aFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFsaWduVG9CeXRlKCk7XHJcbiAgICAgICAgaWYgKGVwaE1hcmtlclVzZWQpIHtcclxuICAgICAgICAgIHNraXBNYXJrZXJJZkVxdWFsKDB4OTIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdmFyIHBhY2tldEl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgY29kZWJsb2NrID0gcGFja2V0SXRlbS5jb2RlYmxvY2s7XHJcbiAgICAgICAgICBpZiAoY29kZWJsb2NrWydkYXRhJ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb2RlYmxvY2suZGF0YSA9IFtdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29kZWJsb2NrLmRhdGEucHVzaCh7XHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgIHN0YXJ0OiBvZmZzZXQgKyBwb3NpdGlvbixcclxuICAgICAgICAgICAgZW5kOiBvZmZzZXQgKyBwb3NpdGlvbiArIHBhY2tldEl0ZW0uZGF0YUxlbmd0aCxcclxuICAgICAgICAgICAgY29kaW5ncGFzc2VzOiBwYWNrZXRJdGVtLmNvZGluZ3Bhc3Nlc1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBwb3NpdGlvbiArPSBwYWNrZXRJdGVtLmRhdGFMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNvcHlDb2VmZmljaWVudHMoY29lZmZpY2llbnRzLCBsZXZlbFdpZHRoLCBsZXZlbEhlaWdodCwgc3ViYmFuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhLCBtYiwgcmV2ZXJzaWJsZSwgc2VnbWVudGF0aW9uU3ltYm9sVXNlZCkge1xyXG4gICAgdmFyIHgwID0gc3ViYmFuZC50YngwO1xyXG4gICAgdmFyIHkwID0gc3ViYmFuZC50YnkwO1xyXG4gICAgdmFyIHdpZHRoID0gc3ViYmFuZC50YngxIC0gc3ViYmFuZC50YngwO1xyXG4gICAgdmFyIGNvZGVibG9ja3MgPSBzdWJiYW5kLmNvZGVibG9ja3M7XHJcbiAgICB2YXIgcmlnaHQgPSBzdWJiYW5kLnR5cGUuY2hhckF0KDApID09PSAnSCcgPyAxIDogMDtcclxuICAgIHZhciBib3R0b20gPSBzdWJiYW5kLnR5cGUuY2hhckF0KDEpID09PSAnSCcgPyBsZXZlbFdpZHRoIDogMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb2RlYmxvY2tzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgdmFyIGNvZGVibG9jayA9IGNvZGVibG9ja3NbaV07XHJcbiAgICAgIHZhciBibG9ja1dpZHRoID0gY29kZWJsb2NrLnRieDFfIC0gY29kZWJsb2NrLnRieDBfO1xyXG4gICAgICB2YXIgYmxvY2tIZWlnaHQgPSBjb2RlYmxvY2sudGJ5MV8gLSBjb2RlYmxvY2sudGJ5MF87XHJcbiAgICAgIGlmIChibG9ja1dpZHRoID09PSAwIHx8IGJsb2NrSGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvZGVibG9ja1snZGF0YSddID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGJpdE1vZGVsLCBjdXJyZW50Q29kaW5ncGFzc1R5cGU7XHJcbiAgICAgIGJpdE1vZGVsID0gbmV3IEJpdE1vZGVsKGJsb2NrV2lkdGgsIGJsb2NrSGVpZ2h0LCBjb2RlYmxvY2suc3ViYmFuZFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVibG9jay56ZXJvQml0UGxhbmVzLCBtYik7XHJcbiAgICAgIGN1cnJlbnRDb2RpbmdwYXNzVHlwZSA9IDI7IC8vIGZpcnN0IGJpdCBwbGFuZSBzdGFydHMgZnJvbSBjbGVhbnVwXHJcblxyXG4gICAgICAvLyBjb2xsZWN0IGRhdGFcclxuICAgICAgdmFyIGRhdGEgPSBjb2RlYmxvY2suZGF0YSwgdG90YWxMZW5ndGggPSAwLCBjb2RpbmdwYXNzZXMgPSAwO1xyXG4gICAgICB2YXIgaiwgamosIGRhdGFJdGVtO1xyXG4gICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgIGRhdGFJdGVtID0gZGF0YVtqXTtcclxuICAgICAgICB0b3RhbExlbmd0aCArPSBkYXRhSXRlbS5lbmQgLSBkYXRhSXRlbS5zdGFydDtcclxuICAgICAgICBjb2RpbmdwYXNzZXMgKz0gZGF0YUl0ZW0uY29kaW5ncGFzc2VzO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBlbmNvZGVkRGF0YSA9IG5ldyBJbnQxNkFycmF5KHRvdGFsTGVuZ3RoKTtcclxuICAgICAgdmFyIHBvc2l0aW9uID0gMDtcclxuICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcclxuICAgICAgICBkYXRhSXRlbSA9IGRhdGFbal07XHJcbiAgICAgICAgdmFyIGNodW5rID0gZGF0YUl0ZW0uZGF0YS5zdWJhcnJheShkYXRhSXRlbS5zdGFydCwgZGF0YUl0ZW0uZW5kKTtcclxuICAgICAgICBlbmNvZGVkRGF0YS5zZXQoY2h1bmssIHBvc2l0aW9uKTtcclxuICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZGVjb2RpbmcgdGhlIGl0ZW1cclxuICAgICAgdmFyIGRlY29kZXIgPSBuZXcgQXJpdGhtZXRpY0RlY29kZXIoZW5jb2RlZERhdGEsIDAsIHRvdGFsTGVuZ3RoKTtcclxuICAgICAgYml0TW9kZWwuc2V0RGVjb2RlcihkZWNvZGVyKTtcclxuXHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RpbmdwYXNzZXM7IGorKykge1xyXG4gICAgICAgIHN3aXRjaCAoY3VycmVudENvZGluZ3Bhc3NUeXBlKSB7XHJcbiAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIGJpdE1vZGVsLnJ1blNpZ25pZmljYW5jZVByb3BvZ2F0aW9uUGFzcygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgYml0TW9kZWwucnVuTWFnbml0dWRlUmVmaW5lbWVudFBhc3MoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIGJpdE1vZGVsLnJ1bkNsZWFudXBQYXNzKCk7XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50YXRpb25TeW1ib2xVc2VkKSB7XHJcbiAgICAgICAgICAgICAgYml0TW9kZWwuY2hlY2tTZWdtZW50YXRpb25TeW1ib2woKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudENvZGluZ3Bhc3NUeXBlID0gKGN1cnJlbnRDb2RpbmdwYXNzVHlwZSArIDEpICUgMztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG9mZnNldCA9IChjb2RlYmxvY2sudGJ4MF8gLSB4MCkgKyAoY29kZWJsb2NrLnRieTBfIC0geTApICogd2lkdGg7XHJcbiAgICAgIHZhciBzaWduID0gYml0TW9kZWwuY29lZmZpY2VudHNTaWduO1xyXG4gICAgICB2YXIgbWFnbml0dWRlID0gYml0TW9kZWwuY29lZmZpY2VudHNNYWduaXR1ZGU7XHJcbiAgICAgIHZhciBiaXRzRGVjb2RlZCA9IGJpdE1vZGVsLmJpdHNEZWNvZGVkO1xyXG4gICAgICB2YXIgbWFnbml0dWRlQ29ycmVjdGlvbiA9IHJldmVyc2libGUgPyAwIDogMC41O1xyXG4gICAgICB2YXIgaywgbiwgbmI7XHJcbiAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgLy8gRG8gdGhlIGludGVybGVhdmluZyBvZiBTZWN0aW9uIEYuMy4zIGhlcmUsIHNvIHdlIGRvIG5vdCBuZWVkXHJcbiAgICAgIC8vIHRvIGNvcHkgbGF0ZXIuIExMIGxldmVsIGlzIG5vdCBpbnRlcmxlYXZlZCwganVzdCBjb3BpZWQuXHJcbiAgICAgIHZhciBpbnRlcmxlYXZlID0gKHN1YmJhbmQudHlwZSAhPT0gJ0xMJyk7XHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCBibG9ja0hlaWdodDsgaisrKSB7XHJcbiAgICAgICAgdmFyIHJvdyA9IChvZmZzZXQgLyB3aWR0aCkgfCAwOyAvLyByb3cgaW4gdGhlIG5vbi1pbnRlcmxlYXZlZCBzdWJiYW5kXHJcbiAgICAgICAgdmFyIGxldmVsT2Zmc2V0ID0gMiAqIHJvdyAqIChsZXZlbFdpZHRoIC0gd2lkdGgpICsgcmlnaHQgKyBib3R0b207XHJcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGJsb2NrV2lkdGg7IGsrKykge1xyXG4gICAgICAgICAgbiA9IG1hZ25pdHVkZVtwb3NpdGlvbl07XHJcbiAgICAgICAgICBpZiAobiAhPT0gMCkge1xyXG4gICAgICAgICAgICBuID0gKG4gKyBtYWduaXR1ZGVDb3JyZWN0aW9uKSAqIGRlbHRhO1xyXG4gICAgICAgICAgICBpZiAoc2lnbltwb3NpdGlvbl0gIT09IDApIHtcclxuICAgICAgICAgICAgICBuID0gLW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmIgPSBiaXRzRGVjb2RlZFtwb3NpdGlvbl07XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBpbnRlcmxlYXZlID8gKGxldmVsT2Zmc2V0ICsgKG9mZnNldCA8PCAxKSkgOiBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChyZXZlcnNpYmxlICYmIChuYiA+PSBtYikpIHtcclxuICAgICAgICAgICAgICBjb2VmZmljaWVudHNbcG9zXSA9IG47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29lZmZpY2llbnRzW3Bvc10gPSBuICogKDEgPDwgKG1iIC0gbmIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb2Zmc2V0Kys7XHJcbiAgICAgICAgICBwb3NpdGlvbisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gd2lkdGggLSBibG9ja1dpZHRoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVRpbGUoY29udGV4dCwgdGlsZSwgYykge1xyXG4gICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcclxuICAgIHZhciBjb2RpbmdTdHlsZVBhcmFtZXRlcnMgPSBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzO1xyXG4gICAgdmFyIHF1YW50aXphdGlvblBhcmFtZXRlcnMgPSBjb21wb25lbnQucXVhbnRpemF0aW9uUGFyYW1ldGVycztcclxuICAgIHZhciBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPVxyXG4gICAgICBjb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50O1xyXG4gICAgdmFyIHNwcWNkcyA9IHF1YW50aXphdGlvblBhcmFtZXRlcnMuU1BxY2RzO1xyXG4gICAgdmFyIHNjYWxhckV4cG91bmRlZCA9IHF1YW50aXphdGlvblBhcmFtZXRlcnMuc2NhbGFyRXhwb3VuZGVkO1xyXG4gICAgdmFyIGd1YXJkQml0cyA9IHF1YW50aXphdGlvblBhcmFtZXRlcnMuZ3VhcmRCaXRzO1xyXG4gICAgdmFyIHNlZ21lbnRhdGlvblN5bWJvbFVzZWQgPSBjb2RpbmdTdHlsZVBhcmFtZXRlcnMuc2VnbWVudGF0aW9uU3ltYm9sVXNlZDtcclxuICAgIHZhciBwcmVjaXNpb24gPSBjb250ZXh0LmNvbXBvbmVudHNbY10ucHJlY2lzaW9uO1xyXG5cclxuICAgIHZhciByZXZlcnNpYmxlID0gY29kaW5nU3R5bGVQYXJhbWV0ZXJzLnJldmVyc2libGVUcmFuc2Zvcm1hdGlvbjtcclxuICAgIHZhciB0cmFuc2Zvcm0gPSAocmV2ZXJzaWJsZSA/IG5ldyBSZXZlcnNpYmxlVHJhbnNmb3JtKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IElycmV2ZXJzaWJsZVRyYW5zZm9ybSgpKTtcclxuXHJcbiAgICB2YXIgc3ViYmFuZENvZWZmaWNpZW50cyA9IFtdO1xyXG4gICAgdmFyIGIgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyBpKyspIHtcclxuICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbaV07XHJcblxyXG4gICAgICB2YXIgd2lkdGggPSByZXNvbHV0aW9uLnRyeDEgLSByZXNvbHV0aW9uLnRyeDA7XHJcbiAgICAgIHZhciBoZWlnaHQgPSByZXNvbHV0aW9uLnRyeTEgLSByZXNvbHV0aW9uLnRyeTA7XHJcbiAgICAgIC8vIEFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2hvbGUgc3VibGV2ZWwuXHJcbiAgICAgIHZhciBjb2VmZmljaWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0KTtcclxuXHJcbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJlc29sdXRpb24uc3ViYmFuZHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgIHZhciBtdSwgZXBzaWxvbjtcclxuICAgICAgICBpZiAoIXNjYWxhckV4cG91bmRlZCkge1xyXG4gICAgICAgICAgLy8gZm9ybXVsYSBFLTVcclxuICAgICAgICAgIG11ID0gc3BxY2RzWzBdLm11O1xyXG4gICAgICAgICAgZXBzaWxvbiA9IHNwcWNkc1swXS5lcHNpbG9uICsgKGkgPiAwID8gMSAtIGkgOiAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbXUgPSBzcHFjZHNbYl0ubXU7XHJcbiAgICAgICAgICBlcHNpbG9uID0gc3BxY2RzW2JdLmVwc2lsb247XHJcbiAgICAgICAgICBiKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3ViYmFuZCA9IHJlc29sdXRpb24uc3ViYmFuZHNbal07XHJcbiAgICAgICAgdmFyIGdhaW5Mb2cyID0gU3ViYmFuZHNHYWluTG9nMltzdWJiYW5kLnR5cGVdO1xyXG5cclxuICAgICAgICAvLyBjYWx1bGF0ZSBxdWFudGl6YXRpb24gY29lZmZpY2llbnQgKFNlY3Rpb24gRS4xLjEuMSlcclxuICAgICAgICB2YXIgZGVsdGEgPSAocmV2ZXJzaWJsZSA/IDEgOlxyXG4gICAgICAgICAgTWF0aC5wb3coMiwgcHJlY2lzaW9uICsgZ2FpbkxvZzIgLSBlcHNpbG9uKSAqICgxICsgbXUgLyAyMDQ4KSk7XHJcbiAgICAgICAgdmFyIG1iID0gKGd1YXJkQml0cyArIGVwc2lsb24gLSAxKTtcclxuXHJcbiAgICAgICAgLy8gSW4gdGhlIGZpcnN0IHJlc29sdXRpb24gbGV2ZWwsIGNvcHlDb2VmZmljaWVudHMgd2lsbCBmaWxsIHRoZVxyXG4gICAgICAgIC8vIHdob2xlIGFycmF5IHdpdGggY29lZmZpY2llbnRzLiBJbiB0aGUgc3VjY2VkaW5nIHBhc3NlcyxcclxuICAgICAgICAvLyBjb3B5Q29lZmZpY2llbnRzIHdpbGwgY29uc2VjdXRpdmVseSBmaWxsIGluIHRoZSB2YWx1ZXMgdGhhdCBiZWxvbmdcclxuICAgICAgICAvLyB0byB0aGUgaW50ZXJsZWF2ZWQgcG9zaXRpb25zIG9mIHRoZSBITCwgTEgsIGFuZCBISCBjb2VmZmljaWVudHMuXHJcbiAgICAgICAgLy8gVGhlIExMIGNvZWZmaWNpZW50cyB3aWxsIHRoZW4gYmUgaW50ZXJsZWF2ZWQgaW4gVHJhbnNmb3JtLml0ZXJhdGUoKS5cclxuICAgICAgICBjb3B5Q29lZmZpY2llbnRzKGNvZWZmaWNpZW50cywgd2lkdGgsIGhlaWdodCwgc3ViYmFuZCwgZGVsdGEsIG1iLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzaWJsZSwgc2VnbWVudGF0aW9uU3ltYm9sVXNlZCk7XHJcbiAgICAgIH1cclxuICAgICAgc3ViYmFuZENvZWZmaWNpZW50cy5wdXNoKHtcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgaXRlbXM6IGNvZWZmaWNpZW50c1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtLmNhbGN1bGF0ZShzdWJiYW5kQ29lZmZpY2llbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnRjeDAsIGNvbXBvbmVudC50Y3kwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxlZnQ6IGNvbXBvbmVudC50Y3gwLFxyXG4gICAgICB0b3A6IGNvbXBvbmVudC50Y3kwLFxyXG4gICAgICB3aWR0aDogcmVzdWx0LndpZHRoLFxyXG4gICAgICBoZWlnaHQ6IHJlc3VsdC5oZWlnaHQsXHJcbiAgICAgIGl0ZW1zOiByZXN1bHQuaXRlbXNcclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUNvbXBvbmVudHMoY29udGV4dCkge1xyXG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xyXG4gICAgdmFyIGNvbXBvbmVudHMgPSBjb250ZXh0LmNvbXBvbmVudHM7XHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XHJcbiAgICB2YXIgcmVzdWx0SW1hZ2VzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb250ZXh0LnRpbGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW2ldO1xyXG4gICAgICB2YXIgdHJhbnNmb3JtZWRUaWxlcyA9IFtdO1xyXG4gICAgICB2YXIgYztcclxuICAgICAgZm9yIChjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtZWRUaWxlc1tjXSA9IHRyYW5zZm9ybVRpbGUoY29udGV4dCwgdGlsZSwgYyk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHRpbGUwID0gdHJhbnNmb3JtZWRUaWxlc1swXTtcclxuICAgICAgdmFyIGlzU2lnbmVkID0gY29tcG9uZW50c1swXS5pc1NpZ25lZDtcclxuICAgICAgaWYgKGlzU2lnbmVkKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IG5ldyBJbnQxNkFycmF5KHRpbGUwLml0ZW1zLmxlbmd0aCAqIGNvbXBvbmVudHNDb3VudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50MTZBcnJheSh0aWxlMC5pdGVtcy5sZW5ndGggKiBjb21wb25lbnRzQ291bnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgbGVmdDogdGlsZTAubGVmdCxcclxuICAgICAgICB0b3A6IHRpbGUwLnRvcCxcclxuICAgICAgICB3aWR0aDogdGlsZTAud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiB0aWxlMC5oZWlnaHQsXHJcbiAgICAgICAgaXRlbXM6IG91dFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gU2VjdGlvbiBHLjIuMiBJbnZlcnNlIG11bHRpIGNvbXBvbmVudCB0cmFuc2Zvcm1cclxuICAgICAgdmFyIHNoaWZ0LCBvZmZzZXQsIG1heCwgbWluLCBtYXhLO1xyXG4gICAgICB2YXIgcG9zID0gMCwgaiwgamosIHkwLCB5MSwgeTIsIHIsIGcsIGIsIGssIHZhbDtcclxuICAgICAgaWYgKHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5tdWx0aXBsZUNvbXBvbmVudFRyYW5zZm9ybSkge1xyXG4gICAgICAgIHZhciBmb3VyQ29tcG9uZW50cyA9IGNvbXBvbmVudHNDb3VudCA9PT0gNDtcclxuICAgICAgICB2YXIgeTBpdGVtcyA9IHRyYW5zZm9ybWVkVGlsZXNbMF0uaXRlbXM7XHJcbiAgICAgICAgdmFyIHkxaXRlbXMgPSB0cmFuc2Zvcm1lZFRpbGVzWzFdLml0ZW1zO1xyXG4gICAgICAgIHZhciB5Mml0ZW1zID0gdHJhbnNmb3JtZWRUaWxlc1syXS5pdGVtcztcclxuICAgICAgICB2YXIgeTNpdGVtcyA9IGZvdXJDb21wb25lbnRzID8gdHJhbnNmb3JtZWRUaWxlc1szXS5pdGVtcyA6IG51bGw7XHJcblxyXG4gICAgICAgIC8vIEhBQ0s6IFRoZSBtdWx0aXBsZSBjb21wb25lbnQgdHJhbnNmb3JtIGZvcm11bGFzIGJlbG93IGFzc3VtZSB0aGF0XHJcbiAgICAgICAgLy8gYWxsIGNvbXBvbmVudHMgaGF2ZSB0aGUgc2FtZSBwcmVjaXNpb24uIFdpdGggdGhpcyBpbiBtaW5kLCB3ZVxyXG4gICAgICAgIC8vIGNvbXB1dGUgc2hpZnQgYW5kIG9mZnNldCBvbmx5IG9uY2UuXHJcbiAgICAgICAgc2hpZnQgPSBjb21wb25lbnRzWzBdLnByZWNpc2lvbiAtIDg7XHJcbiAgICAgICAgb2Zmc2V0ID0gKDEyOCA8PCBzaGlmdCkgKyAwLjU7XHJcbiAgICAgICAgbWF4ID0gMjU1ICogKDEgPDwgc2hpZnQpO1xyXG4gICAgICAgIG1heEsgPSBtYXggKiAwLjU7XHJcbiAgICAgICAgbWluID0gLW1heEs7XHJcblxyXG4gICAgICAgIHZhciBjb21wb25lbnQwID0gdGlsZS5jb21wb25lbnRzWzBdO1xyXG4gICAgICAgIHZhciBhbHBoYTAxID0gY29tcG9uZW50c0NvdW50IC0gMztcclxuICAgICAgICBqaiA9IHkwaXRlbXMubGVuZ3RoO1xyXG4gICAgICAgIGlmICghY29tcG9uZW50MC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMucmV2ZXJzaWJsZVRyYW5zZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgICAvLyBpbnZlcnNlIGlycmV2ZXJzaWJsZSBtdWx0aXBsZSBjb21wb25lbnQgdHJhbnNmb3JtXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgamo7IGorKywgcG9zICs9IGFscGhhMDEpIHtcclxuICAgICAgICAgICAgeTAgPSB5MGl0ZW1zW2pdICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICB5MSA9IHkxaXRlbXNbal07XHJcbiAgICAgICAgICAgIHkyID0geTJpdGVtc1tqXTtcclxuICAgICAgICAgICAgciA9IHkwICsgMS40MDIgKiB5MjtcclxuICAgICAgICAgICAgZyA9IHkwIC0gMC4zNDQxMyAqIHkxIC0gMC43MTQxNCAqIHkyO1xyXG4gICAgICAgICAgICBiID0geTAgKyAxLjc3MiAqIHkxO1xyXG4gICAgICAgICAgICBvdXRbcG9zKytdID0gciA8PSAwID8gMCA6IHIgPj0gbWF4ID8gMjU1IDogciA+PiBzaGlmdDtcclxuICAgICAgICAgICAgb3V0W3BvcysrXSA9IGcgPD0gMCA/IDAgOiBnID49IG1heCA/IDI1NSA6IGcgPj4gc2hpZnQ7XHJcbiAgICAgICAgICAgIG91dFtwb3MrK10gPSBiIDw9IDAgPyAwIDogYiA+PSBtYXggPyAyNTUgOiBiID4+IHNoaWZ0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBpbnZlcnNlIHJldmVyc2libGUgbXVsdGlwbGUgY29tcG9uZW50IHRyYW5zZm9ybVxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpqOyBqKyssIHBvcyArPSBhbHBoYTAxKSB7XHJcbiAgICAgICAgICAgIHkwID0geTBpdGVtc1tqXSArIG9mZnNldDtcclxuICAgICAgICAgICAgeTEgPSB5MWl0ZW1zW2pdO1xyXG4gICAgICAgICAgICB5MiA9IHkyaXRlbXNbal07XHJcbiAgICAgICAgICAgIGcgPSB5MCAtICgoeTIgKyB5MSkgPj4gMik7XHJcbiAgICAgICAgICAgIHIgPSBnICsgeTI7XHJcbiAgICAgICAgICAgIGIgPSBnICsgeTE7XHJcbiAgICAgICAgICAgIG91dFtwb3MrK10gPSByIDw9IDAgPyAwIDogciA+PSBtYXggPyAyNTUgOiByID4+IHNoaWZ0O1xyXG4gICAgICAgICAgICBvdXRbcG9zKytdID0gZyA8PSAwID8gMCA6IGcgPj0gbWF4ID8gMjU1IDogZyA+PiBzaGlmdDtcclxuICAgICAgICAgICAgb3V0W3BvcysrXSA9IGIgPD0gMCA/IDAgOiBiID49IG1heCA/IDI1NSA6IGIgPj4gc2hpZnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VyQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgZm9yIChqID0gMCwgcG9zID0gMzsgaiA8IGpqOyBqKyssIHBvcyArPSA0KSB7XHJcbiAgICAgICAgICAgIGsgPSB5M2l0ZW1zW2pdO1xyXG4gICAgICAgICAgICBvdXRbcG9zXSA9IGsgPD0gbWluID8gMCA6IGsgPj0gbWF4SyA/IDI1NSA6IChrICsgb2Zmc2V0KSA+PiBzaGlmdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7IC8vIG5vIG11bHRpLWNvbXBvbmVudCB0cmFuc2Zvcm1cclxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcclxuICAgICAgICAgIGlmIChjb21wb25lbnRzW2NdLnByZWNpc2lvbiA9PT0gOCl7XHJcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRyYW5zZm9ybWVkVGlsZXNbY10uaXRlbXM7XHJcbiAgICAgICAgICAgIHNoaWZ0ID0gY29tcG9uZW50c1tjXS5wcmVjaXNpb24gLSA4O1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAoMTI4IDw8IHNoaWZ0KSArIDAuNTtcclxuICAgICAgICAgICAgbWF4ID0gKDEyNy41ICogKDEgPDwgc2hpZnQpKTtcclxuICAgICAgICAgICAgbWluID0gLW1heDtcclxuICAgICAgICAgICAgZm9yIChwb3MgPSBjLCBqID0gMCwgamogPSBpdGVtcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XHJcbiAgICAgICAgICAgICAgdmFsID0gaXRlbXNbal07XHJcbiAgICAgICAgICAgICAgb3V0W3Bvc10gPSB2YWwgPD0gbWluID8gMCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPj0gbWF4ID8gMjU1IDogKHZhbCArIG9mZnNldCkgPj4gc2hpZnQ7XHJcbiAgICAgICAgICAgICAgcG9zICs9IGNvbXBvbmVudHNDb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHZhciBpc1NpZ25lZCA9IGNvbXBvbmVudHNbY10uaXNTaWduZWQ7XHJcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRyYW5zZm9ybWVkVGlsZXNbY10uaXRlbXM7XHJcblxyXG4gICAgICAgICAgICBpZihpc1NpZ25lZCl7XHJcbiAgICAgICAgICAgICAgZm9yIChwb3MgPSBjLCBqID0gMCwgamogPSBpdGVtcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRbcG9zXSA9IGl0ZW1zW2pdO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IGNvbXBvbmVudHNDb3VudDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgIHNoaWZ0ID0gY29tcG9uZW50c1tjXS5wcmVjaXNpb24gLSA4O1xyXG4gICAgICAgICAgICAgIG9mZnNldCA9ICgxMjggPDwgc2hpZnQpICsgMC41O1xyXG4gICAgICAgICAgICAgIHZhciBwcmVjaXNpb25NYXggPSBNYXRoLnBvdygyLGNvbXBvbmVudHNbY10ucHJlY2lzaW9uKS0xO1xyXG4gICAgICAgICAgICAgIGZvciAocG9zID0gYywgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gaXRlbXNbal07XHJcbiAgICAgICAgICAgICAgICBvdXRbcG9zXSA9IE1hdGgubWF4KE1hdGgubWluKCh2YWwgKyBvZmZzZXQpLHByZWNpc2lvbk1heCksMCk7XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gY29tcG9uZW50c0NvdW50O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXN1bHRJbWFnZXMucHVzaChyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdEltYWdlcztcclxuICB9XHJcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVRpbGUoY29udGV4dCwgdGlsZUluZGV4KSB7XHJcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XHJcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcclxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcclxuICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcclxuICAgICAgdmFyIHFjZE9yUWNjID0gKGNvbnRleHQuY3VycmVudFRpbGUuUUNDW2NdICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbGUuUUNDW2NdIDogY29udGV4dC5jdXJyZW50VGlsZS5RQ0QpO1xyXG4gICAgICBjb21wb25lbnQucXVhbnRpemF0aW9uUGFyYW1ldGVycyA9IHFjZE9yUWNjO1xyXG4gICAgICB2YXIgY29kT3JDb2MgPSAoY29udGV4dC5jdXJyZW50VGlsZS5DT0NbY10gIT09IHVuZGVmaW5lZCAgP1xyXG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbGUuQ09DW2NdIDogY29udGV4dC5jdXJyZW50VGlsZS5DT0QpO1xyXG4gICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzID0gY29kT3JDb2M7XHJcbiAgICB9XHJcbiAgICB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMgPSBjb250ZXh0LmN1cnJlbnRUaWxlLkNPRDtcclxuICB9XHJcblxyXG4gIC8vIFNlY3Rpb24gQi4xMC4yIFRhZyB0cmVlc1xyXG4gIHZhciBUYWdUcmVlID0gKGZ1bmN0aW9uIFRhZ1RyZWVDbG9zdXJlKCkge1xyXG4gICAgZnVuY3Rpb24gVGFnVHJlZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIHZhciBsZXZlbHNMZW5ndGggPSBsb2cyKE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKSArIDE7XHJcbiAgICAgIHRoaXMubGV2ZWxzID0gW107XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgbGV2ZWwgPSB7XHJcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgIGl0ZW1zOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sZXZlbHMucHVzaChsZXZlbCk7XHJcbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGggLyAyKTtcclxuICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFRhZ1RyZWUucHJvdG90eXBlID0ge1xyXG4gICAgICByZXNldDogZnVuY3Rpb24gVGFnVHJlZV9yZXNldChpLCBqKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IDAsIHZhbHVlID0gMCwgbGV2ZWw7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRMZXZlbCA8IHRoaXMubGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xyXG4gICAgICAgICAgdmFyIGluZGV4ID0gaSArIGogKiBsZXZlbC53aWR0aDtcclxuICAgICAgICAgIGlmIChsZXZlbC5pdGVtc1tpbmRleF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGxldmVsLml0ZW1zW2luZGV4XTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsZXZlbC5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgaSA+Pj0gMTtcclxuICAgICAgICAgIGogPj49IDE7XHJcbiAgICAgICAgICBjdXJyZW50TGV2ZWwrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudExldmVsLS07XHJcbiAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xyXG4gICAgICAgIGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudExldmVsID0gY3VycmVudExldmVsO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlO1xyXG4gICAgICB9LFxyXG4gICAgICBpbmNyZW1lbnRWYWx1ZTogZnVuY3Rpb24gVGFnVHJlZV9pbmNyZW1lbnRWYWx1ZSgpIHtcclxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRMZXZlbF07XHJcbiAgICAgICAgbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdKys7XHJcbiAgICAgIH0sXHJcbiAgICAgIG5leHRMZXZlbDogZnVuY3Rpb24gVGFnVHJlZV9uZXh0TGV2ZWwoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xyXG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW2N1cnJlbnRMZXZlbF07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdO1xyXG4gICAgICAgIGN1cnJlbnRMZXZlbC0tO1xyXG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPCAwKSB7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbDtcclxuICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWxzW2N1cnJlbnRMZXZlbF07XHJcbiAgICAgICAgbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gVGFnVHJlZTtcclxuICB9KSgpO1xyXG5cclxuICB2YXIgSW5jbHVzaW9uVHJlZSA9IChmdW5jdGlvbiBJbmNsdXNpb25UcmVlQ2xvc3VyZSgpIHtcclxuICAgIGZ1bmN0aW9uIEluY2x1c2lvblRyZWUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICB2YXIgbGV2ZWxzTGVuZ3RoID0gbG9nMihNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSkgKyAxO1xyXG4gICAgICB0aGlzLmxldmVscyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xyXG4gICAgICAgIHZhciBzdGF0dXMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgICAgaXRlbXNbal0gPSAwO1xyXG4gICAgICAgICAgc3RhdHVzW2pdID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsZXZlbCA9IHtcclxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgaXRlbXM6IGl0ZW1zLFxyXG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubGV2ZWxzLnB1c2gobGV2ZWwpO1xyXG5cclxuICAgICAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAvIDIpO1xyXG4gICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgLyAyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgSW5jbHVzaW9uVHJlZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiBJbmNsdXNpb25UcmVlX3Jlc2V0KGksIGosIHN0b3BWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0b3BWYWx1ZSA9IHN0b3BWYWx1ZTtcclxuICAgICAgICB2YXIgY3VycmVudExldmVsID0gMDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudExldmVsIDwgdGhpcy5sZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xyXG4gICAgICAgICAgdmFyIGluZGV4ID0gaSArIGogKiBsZXZlbC53aWR0aDtcclxuICAgICAgICAgIGxldmVsLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgICAgICAgaSA+Pj0gMTtcclxuICAgICAgICAgIGogPj49IDE7XHJcbiAgICAgICAgICBjdXJyZW50TGV2ZWwrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudExldmVsID0gdGhpcy5sZXZlbHMubGVuZ3RoIC0gMTtcclxuICAgICAgICB0aGlzLm1pblZhbHVlID10aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRMZXZlbF0uaXRlbXNbMF07XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9LFxyXG4gICAgICBpbmNyZW1lbnRWYWx1ZTogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9pbmNyZW1lbnRWYWx1ZSgpIHtcclxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRMZXZlbF07XHJcbiAgICAgICAgbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdID0gbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdICsgMTtcclxuICAgICAgICBpZihsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPiB0aGlzLm1pblZhbHVlKSB7XHJcbiAgICAgICAgICB0aGlzLm1pblZhbHVlID0gbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgbmV4dExldmVsOiBmdW5jdGlvbiBJbmNsdXNpb25UcmVlX25leHRMZXZlbCgpIHtcclxuICAgICAgICB2YXIgY3VycmVudExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XHJcbiAgICAgICAgY3VycmVudExldmVsLS07XHJcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA8IDApIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWw7XHJcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xyXG4gICAgICAgICAgaWYobGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdIDwgdGhpcy5taW5WYWx1ZSkge1xyXG4gICAgICAgICAgICBsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPSB0aGlzLm1pblZhbHVlO1xyXG4gICAgICAgICAgfWVsc2UgaWYgKGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA+IHRoaXMubWluVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5taW5WYWx1ZSA9IGxldmVsLml0ZW1zW2xldmVsLmluZGV4XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIGlzTGVhZjogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9pc0xlYWYoKXtcclxuICAgICAgcmV0dXJuICh0aGlzLmN1cnJlbnRMZXZlbCA9PT0gMCk7XHJcbiAgICB9LFxyXG4gICAgaXNBYm92ZVRocmVzaG9sZDogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9pc0Fib3ZlVGhyZXNob2xkKCl7XHJcbiAgICAgIHZhciBsZXZlbGluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWw7XHJcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW2xldmVsaW5kZXhdO1xyXG4gICAgICByZXR1cm4gKGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA+IHRoaXMuY3VycmVudFN0b3BWYWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgaXNLbm93bjogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9pc0tub3duKCl7XHJcbiAgICAgIHZhciBsZXZlbGluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWw7XHJcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW2xldmVsaW5kZXhdO1xyXG4gICAgICByZXR1cm4gKGxldmVsLnN0YXR1c1tsZXZlbC5pbmRleF0gPiAwKTtcclxuICAgIH0sXHJcbiAgICBzZXRLbm93bjogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9zZXRLbm93bigpe1xyXG4gICAgICB2YXIgbGV2ZWxpbmRleCA9IHRoaXMuY3VycmVudExldmVsO1xyXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tsZXZlbGluZGV4XTtcclxuICAgICAgbGV2ZWwuc3RhdHVzW2xldmVsLmluZGV4XSA9IDE7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluY2x1c2lvblRyZWU7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gU2VjdGlvbiBELiBDb2VmZmljaWVudCBiaXQgbW9kZWxpbmdcclxuICB2YXIgQml0TW9kZWwgPSAoZnVuY3Rpb24gQml0TW9kZWxDbG9zdXJlKCkge1xyXG4gICAgdmFyIFVOSUZPUk1fQ09OVEVYVCA9IDE3O1xyXG4gICAgdmFyIFJVTkxFTkdUSF9DT05URVhUID0gMTg7XHJcbiAgICAvLyBUYWJsZSBELTFcclxuICAgIC8vIFRoZSBpbmRleCBpcyBiaW5hcnkgcHJlc2VudGF0aW9uOiAwZGRkdnZoaCwgZGRkIC0gc3VtIG9mIERpICgwLi40KSxcclxuICAgIC8vIHZ2IC0gc3VtIG9mIFZpICgwLi4yKSwgYW5kIGhoIC0gc3VtIG9mIEhpICgwLi4yKVxyXG4gICAgdmFyIExMQW5kTEhDb250ZXh0c0xhYmVsID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAwLCA1LCA4LCAwLCAzLCA3LCA4LCAwLCA0LCA3LCA4LCAwLCAwLCAwLCAwLCAwLCAxLCA2LCA4LCAwLCAzLCA3LCA4LCAwLCA0LFxyXG4gICAgICA3LCA4LCAwLCAwLCAwLCAwLCAwLCAyLCA2LCA4LCAwLCAzLCA3LCA4LCAwLCA0LCA3LCA4LCAwLCAwLCAwLCAwLCAwLCAyLCA2LFxyXG4gICAgICA4LCAwLCAzLCA3LCA4LCAwLCA0LCA3LCA4LCAwLCAwLCAwLCAwLCAwLCAyLCA2LCA4LCAwLCAzLCA3LCA4LCAwLCA0LCA3LCA4XHJcbiAgICBdKTtcclxuICAgIHZhciBITENvbnRleHRMYWJlbCA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMCwgMywgNCwgMCwgNSwgNywgNywgMCwgOCwgOCwgOCwgMCwgMCwgMCwgMCwgMCwgMSwgMywgNCwgMCwgNiwgNywgNywgMCwgOCxcclxuICAgICAgOCwgOCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgNCwgMCwgNiwgNywgNywgMCwgOCwgOCwgOCwgMCwgMCwgMCwgMCwgMCwgMiwgMyxcclxuICAgICAgNCwgMCwgNiwgNywgNywgMCwgOCwgOCwgOCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgNCwgMCwgNiwgNywgNywgMCwgOCwgOCwgOFxyXG4gICAgXSk7XHJcbiAgICB2YXIgSEhDb250ZXh0TGFiZWwgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDAsIDEsIDIsIDAsIDEsIDIsIDIsIDAsIDIsIDIsIDIsIDAsIDAsIDAsIDAsIDAsIDMsIDQsIDUsIDAsIDQsIDUsIDUsIDAsIDUsXHJcbiAgICAgIDUsIDUsIDAsIDAsIDAsIDAsIDAsIDYsIDcsIDcsIDAsIDcsIDcsIDcsIDAsIDcsIDcsIDcsIDAsIDAsIDAsIDAsIDAsIDgsIDgsXHJcbiAgICAgIDgsIDAsIDgsIDgsIDgsIDAsIDgsIDgsIDgsIDAsIDAsIDAsIDAsIDAsIDgsIDgsIDgsIDAsIDgsIDgsIDgsIDAsIDgsIDgsIDhcclxuICAgIF0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIEJpdE1vZGVsKHdpZHRoLCBoZWlnaHQsIHN1YmJhbmQsIHplcm9CaXRQbGFuZXMsIG1iKSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICB0aGlzLmNvbnRleHRMYWJlbFRhYmxlID0gKHN1YmJhbmQgPT09ICdISCcgPyBISENvbnRleHRMYWJlbCA6XHJcbiAgICAgICAgKHN1YmJhbmQgPT09ICdITCcgPyBITENvbnRleHRMYWJlbCA6IExMQW5kTEhDb250ZXh0c0xhYmVsKSk7XHJcblxyXG4gICAgICB2YXIgY29lZmZpY2llbnRDb3VudCA9IHdpZHRoICogaGVpZ2h0O1xyXG5cclxuICAgICAgLy8gY29lZmZpY2llbnRzIG91dHNpZGUgdGhlIGVuY29kaW5nIHJlZ2lvbiB0cmVhdGVkIGFzIGluc2lnbmlmaWNhbnRcclxuICAgICAgLy8gYWRkIGJvcmRlciBzdGF0ZSBjZWxscyBmb3Igc2lnbmlmaWNhbmNlU3RhdGVcclxuICAgICAgdGhpcy5uZWlnaGJvcnNTaWduaWZpY2FuY2UgPSBuZXcgVWludDhBcnJheShjb2VmZmljaWVudENvdW50KTtcclxuICAgICAgdGhpcy5jb2VmZmljZW50c1NpZ24gPSBuZXcgVWludDhBcnJheShjb2VmZmljaWVudENvdW50KTtcclxuICAgICAgdGhpcy5jb2VmZmljZW50c01hZ25pdHVkZSA9IG1iID4gMTQgPyBuZXcgVWludDMyQXJyYXkoY29lZmZpY2llbnRDb3VudCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWIgPiA2ID8gbmV3IFVpbnQxNkFycmF5KGNvZWZmaWNpZW50Q291bnQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGNvZWZmaWNpZW50Q291bnQpO1xyXG4gICAgICB0aGlzLnByb2Nlc3NpbmdGbGFncyA9IG5ldyBVaW50OEFycmF5KGNvZWZmaWNpZW50Q291bnQpO1xyXG5cclxuICAgICAgdmFyIGJpdHNEZWNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoY29lZmZpY2llbnRDb3VudCk7XHJcbiAgICAgIGlmICh6ZXJvQml0UGxhbmVzICE9PSAwKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2VmZmljaWVudENvdW50OyBpKyspIHtcclxuICAgICAgICAgIGJpdHNEZWNvZGVkW2ldID0gemVyb0JpdFBsYW5lcztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5iaXRzRGVjb2RlZCA9IGJpdHNEZWNvZGVkO1xyXG5cclxuICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpdE1vZGVsLnByb3RvdHlwZSA9IHtcclxuICAgICAgc2V0RGVjb2RlcjogZnVuY3Rpb24gQml0TW9kZWxfc2V0RGVjb2RlcihkZWNvZGVyKSB7XHJcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gZGVjb2RlcjtcclxuICAgICAgfSxcclxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIEJpdE1vZGVsX3Jlc2V0KCkge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgMTcgY29udGV4dHMgdGhhdCBhcmUgYWNjZXNzZWQgdmlhIGNvbnRleHQgbGFiZWxzLFxyXG4gICAgICAgIC8vIHBsdXMgdGhlIHVuaWZvcm0gYW5kIHJ1bmxlbmd0aCBjb250ZXh0LlxyXG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBuZXcgSW50OEFycmF5KDE5KTtcclxuXHJcbiAgICAgICAgLy8gQ29udGV4dHMgYXJlIHBhY2tlZCBpbnRvIDEgYnl0ZTpcclxuICAgICAgICAvLyBoaWdoZXN0IDcgYml0cyBjYXJyeSB0aGUgaW5kZXgsIGxvd2VzdCBiaXQgY2FycmllcyBtcHNcclxuICAgICAgICB0aGlzLmNvbnRleHRzWzBdID0gKDQgPDwgMSkgfCAwO1xyXG4gICAgICAgIHRoaXMuY29udGV4dHNbVU5JRk9STV9DT05URVhUXSA9ICg0NiA8PCAxKSB8IDA7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0c1tSVU5MRU5HVEhfQ09OVEVYVF0gPSAoMyA8PCAxKSB8IDA7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldE5laWdoYm9yc1NpZ25pZmljYW5jZTpcclxuICAgICAgICBmdW5jdGlvbiBCaXRNb2RlbF9zZXROZWlnaGJvcnNTaWduaWZpY2FuY2Uocm93LCBjb2x1bW4sIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIG5laWdoYm9yc1NpZ25pZmljYW5jZSA9IHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBsZWZ0ID0gKGNvbHVtbiA+IDApO1xyXG4gICAgICAgIHZhciByaWdodCA9IChjb2x1bW4gKyAxIDwgd2lkdGgpO1xyXG4gICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICBpZiAocm93ID4gMCkge1xyXG4gICAgICAgICAgaSA9IGluZGV4IC0gd2lkdGg7XHJcbiAgICAgICAgICBpZiAobGVmdCkge1xyXG4gICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaSAtIDFdICs9IDB4MTA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocmlnaHQpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2kgKyAxXSArPSAweDEwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2ldICs9IDB4MDQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocm93ICsgMSA8IGhlaWdodCkge1xyXG4gICAgICAgICAgaSA9IGluZGV4ICsgd2lkdGg7XHJcbiAgICAgICAgICBpZiAobGVmdCkge1xyXG4gICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaSAtIDFdICs9IDB4MTA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocmlnaHQpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2kgKyAxXSArPSAweDEwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2ldICs9IDB4MDQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobGVmdCkge1xyXG4gICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4IC0gMV0gKz0gMHgwMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJpZ2h0KSB7XHJcbiAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXggKyAxXSArPSAweDAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdIHw9IDB4ODA7XHJcbiAgICAgIH0sXHJcbiAgICAgIHJ1blNpZ25pZmljYW5jZVByb3BvZ2F0aW9uUGFzczpcclxuICAgICAgICBmdW5jdGlvbiBCaXRNb2RlbF9ydW5TaWduaWZpY2FuY2VQcm9wb2dhdGlvblBhc3MoKSB7XHJcbiAgICAgICAgdmFyIGRlY29kZXIgPSB0aGlzLmRlY29kZXI7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGNvZWZmaWNlbnRzTWFnbml0dWRlID0gdGhpcy5jb2VmZmljZW50c01hZ25pdHVkZTtcclxuICAgICAgICB2YXIgY29lZmZpY2VudHNTaWduID0gdGhpcy5jb2VmZmljZW50c1NpZ247XHJcbiAgICAgICAgdmFyIG5laWdoYm9yc1NpZ25pZmljYW5jZSA9IHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlO1xyXG4gICAgICAgIHZhciBwcm9jZXNzaW5nRmxhZ3MgPSB0aGlzLnByb2Nlc3NpbmdGbGFncztcclxuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xyXG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmNvbnRleHRMYWJlbFRhYmxlO1xyXG4gICAgICAgIHZhciBiaXRzRGVjb2RlZCA9IHRoaXMuYml0c0RlY29kZWQ7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NlZEludmVyc2VNYXNrID0gfjE7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NlZE1hc2sgPSAxO1xyXG4gICAgICAgIHZhciBmaXJzdE1hZ25pdHVkZUJpdE1hc2sgPSAyO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpMCA9IDA7IGkwIDwgaGVpZ2h0OyBpMCArPSA0KSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaTAgKiB3aWR0aCArIGo7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkxID0gMDsgaTEgPCA0OyBpMSsrLCBpbmRleCArPSB3aWR0aCkge1xyXG4gICAgICAgICAgICAgIHZhciBpID0gaTAgKyBpMTtcclxuICAgICAgICAgICAgICBpZiAoaSA+PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAvLyBjbGVhciBwcm9jZXNzZWQgZmxhZyBmaXJzdFxyXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gJj0gcHJvY2Vzc2VkSW52ZXJzZU1hc2s7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gfHxcclxuICAgICAgICAgICAgICAgICAgIW5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHRMYWJlbCA9IGxhYmVsc1tuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdXTtcclxuICAgICAgICAgICAgICB2YXIgZGVjaXNpb24gPSBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIGNvbnRleHRMYWJlbCk7XHJcbiAgICAgICAgICAgICAgaWYgKGRlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHRoaXMuZGVjb2RlU2lnbkJpdChpLCBqLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb2VmZmljZW50c1NpZ25baW5kZXhdID0gc2lnbjtcclxuICAgICAgICAgICAgICAgIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5laWdoYm9yc1NpZ25pZmljYW5jZShpLCBqLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIHw9IGZpcnN0TWFnbml0dWRlQml0TWFzaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXhdKys7XHJcbiAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSB8PSBwcm9jZXNzZWRNYXNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBkZWNvZGVTaWduQml0OiBmdW5jdGlvbiBCaXRNb2RlbF9kZWNvZGVTaWduQml0KHJvdywgY29sdW1uLCBpbmRleCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjb2VmZmljZW50c01hZ25pdHVkZSA9IHRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGU7XHJcbiAgICAgICAgdmFyIGNvZWZmaWNlbnRzU2lnbiA9IHRoaXMuY29lZmZpY2VudHNTaWduO1xyXG4gICAgICAgIHZhciBjb250cmlidXRpb24sIHNpZ24wLCBzaWduMSwgc2lnbmlmaWNhbmNlMTtcclxuICAgICAgICB2YXIgY29udGV4dExhYmVsLCBkZWNvZGVkO1xyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgaG9yaXpvbnRhbCBjb250cmlidXRpb25cclxuICAgICAgICBzaWduaWZpY2FuY2UxID0gKGNvbHVtbiA+IDAgJiYgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXggLSAxXSAhPT0gMCk7XHJcbiAgICAgICAgaWYgKGNvbHVtbiArIDEgPCB3aWR0aCAmJiBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleCArIDFdICE9PSAwKSB7XHJcbiAgICAgICAgICBzaWduMSA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCArIDFdO1xyXG4gICAgICAgICAgaWYgKHNpZ25pZmljYW5jZTEpIHtcclxuICAgICAgICAgICAgc2lnbjAgPSBjb2VmZmljZW50c1NpZ25baW5kZXggLSAxXTtcclxuICAgICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24xIC0gc2lnbjA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250cmlidXRpb24gPSAxIC0gc2lnbjEgLSBzaWduMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHNpZ25pZmljYW5jZTEpIHtcclxuICAgICAgICAgIHNpZ24wID0gY29lZmZpY2VudHNTaWduW2luZGV4IC0gMV07XHJcbiAgICAgICAgICBjb250cmlidXRpb24gPSAxIC0gc2lnbjAgLSBzaWduMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29udHJpYnV0aW9uID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxDb250cmlidXRpb24gPSAzICogY29udHJpYnV0aW9uO1xyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgdmVydGljYWwgY29udHJpYnV0aW9uIGFuZCBjb21iaW5lIHdpdGggdGhlIGhvcml6b250YWxcclxuICAgICAgICBzaWduaWZpY2FuY2UxID0gKHJvdyA+IDAgJiYgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXggLSB3aWR0aF0gIT09IDApO1xyXG4gICAgICAgIGlmIChyb3cgKyAxIDwgaGVpZ2h0ICYmIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4ICsgd2lkdGhdICE9PSAwKSB7XHJcbiAgICAgICAgICBzaWduMSA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCArIHdpZHRoXTtcclxuICAgICAgICAgIGlmIChzaWduaWZpY2FuY2UxKSB7XHJcbiAgICAgICAgICAgIHNpZ24wID0gY29lZmZpY2VudHNTaWduW2luZGV4IC0gd2lkdGhdO1xyXG4gICAgICAgICAgICBjb250cmlidXRpb24gPSAxIC0gc2lnbjEgLSBzaWduMCArIGhvcml6b250YWxDb250cmlidXRpb247XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250cmlidXRpb24gPSAxIC0gc2lnbjEgLSBzaWduMSArIGhvcml6b250YWxDb250cmlidXRpb247XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChzaWduaWZpY2FuY2UxKSB7XHJcbiAgICAgICAgICBzaWduMCA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCAtIHdpZHRoXTtcclxuICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDEgLSBzaWduMCAtIHNpZ24wICsgaG9yaXpvbnRhbENvbnRyaWJ1dGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29udHJpYnV0aW9uID0gaG9yaXpvbnRhbENvbnRyaWJ1dGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb250cmlidXRpb24gPj0gMCkge1xyXG4gICAgICAgICAgY29udGV4dExhYmVsID0gOSArIGNvbnRyaWJ1dGlvbjtcclxuICAgICAgICAgIGRlY29kZWQgPSB0aGlzLmRlY29kZXIucmVhZEJpdCh0aGlzLmNvbnRleHRzLCBjb250ZXh0TGFiZWwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb250ZXh0TGFiZWwgPSA5IC0gY29udHJpYnV0aW9uO1xyXG4gICAgICAgICAgZGVjb2RlZCA9IHRoaXMuZGVjb2Rlci5yZWFkQml0KHRoaXMuY29udGV4dHMsIGNvbnRleHRMYWJlbCkgXiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVjb2RlZDtcclxuICAgICAgfSxcclxuICAgICAgcnVuTWFnbml0dWRlUmVmaW5lbWVudFBhc3M6XHJcbiAgICAgICAgZnVuY3Rpb24gQml0TW9kZWxfcnVuTWFnbml0dWRlUmVmaW5lbWVudFBhc3MoKSB7XHJcbiAgICAgICAgdmFyIGRlY29kZXIgPSB0aGlzLmRlY29kZXI7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGNvZWZmaWNlbnRzTWFnbml0dWRlID0gdGhpcy5jb2VmZmljZW50c01hZ25pdHVkZTtcclxuICAgICAgICB2YXIgbmVpZ2hib3JzU2lnbmlmaWNhbmNlID0gdGhpcy5uZWlnaGJvcnNTaWduaWZpY2FuY2U7XHJcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcclxuICAgICAgICB2YXIgYml0c0RlY29kZWQgPSB0aGlzLmJpdHNEZWNvZGVkO1xyXG4gICAgICAgIHZhciBwcm9jZXNzaW5nRmxhZ3MgPSB0aGlzLnByb2Nlc3NpbmdGbGFncztcclxuICAgICAgICB2YXIgcHJvY2Vzc2VkTWFzayA9IDE7XHJcbiAgICAgICAgdmFyIGZpcnN0TWFnbml0dWRlQml0TWFzayA9IDI7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0O1xyXG4gICAgICAgIHZhciB3aWR0aDQgPSB3aWR0aCAqIDQ7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGluZGV4MCA9IDAsIGluZGV4TmV4dDsgaW5kZXgwIDwgbGVuZ3RoOyBpbmRleDAgPSBpbmRleE5leHQpIHtcclxuICAgICAgICAgIGluZGV4TmV4dCA9IE1hdGgubWluKGxlbmd0aCwgaW5kZXgwICsgd2lkdGg0KTtcclxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IGluZGV4MCArIGo7IGluZGV4IDwgaW5kZXhOZXh0OyBpbmRleCArPSB3aWR0aCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBzaWduaWZpY2FudCBidXQgbm90IHRob3NlIHRoYXQgaGF2ZSBqdXN0IGJlY29tZVxyXG4gICAgICAgICAgICAgIGlmICghY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdIHx8XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSAmIHByb2Nlc3NlZE1hc2spICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSAxNjtcclxuICAgICAgICAgICAgICBpZiAoKHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gJiBmaXJzdE1hZ25pdHVkZUJpdE1hc2spICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIF49IGZpcnN0TWFnbml0dWRlQml0TWFzaztcclxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IHJlZmluZW1lbnRcclxuICAgICAgICAgICAgICAgdmFyIHNpZ25pZmljYW5jZSA9IG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF0gJiAxMjc7XHJcbiAgICAgICAgICAgICAgIGNvbnRleHRMYWJlbCA9IHNpZ25pZmljYW5jZSA9PT0gMCA/IDE1IDogMTQ7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgYml0ID0gZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBjb250ZXh0TGFiZWwpO1xyXG4gICAgICAgICAgICAgIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSA9XHJcbiAgICAgICAgICAgICAgICAoY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdIDw8IDEpIHwgYml0O1xyXG4gICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4XSsrO1xyXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gfD0gcHJvY2Vzc2VkTWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgcnVuQ2xlYW51cFBhc3M6IGZ1bmN0aW9uIEJpdE1vZGVsX3J1bkNsZWFudXBQYXNzKCkge1xyXG4gICAgICAgIHZhciBkZWNvZGVyID0gdGhpcy5kZWNvZGVyO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBuZWlnaGJvcnNTaWduaWZpY2FuY2UgPSB0aGlzLm5laWdoYm9yc1NpZ25pZmljYW5jZTtcclxuICAgICAgICB2YXIgY29lZmZpY2VudHNNYWduaXR1ZGUgPSB0aGlzLmNvZWZmaWNlbnRzTWFnbml0dWRlO1xyXG4gICAgICAgIHZhciBjb2VmZmljZW50c1NpZ24gPSB0aGlzLmNvZWZmaWNlbnRzU2lnbjtcclxuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xyXG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmNvbnRleHRMYWJlbFRhYmxlO1xyXG4gICAgICAgIHZhciBiaXRzRGVjb2RlZCA9IHRoaXMuYml0c0RlY29kZWQ7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NpbmdGbGFncyA9IHRoaXMucHJvY2Vzc2luZ0ZsYWdzO1xyXG4gICAgICAgIHZhciBwcm9jZXNzZWRNYXNrID0gMTtcclxuICAgICAgICB2YXIgZmlyc3RNYWduaXR1ZGVCaXRNYXNrID0gMjtcclxuICAgICAgICB2YXIgb25lUm93RG93biA9IHdpZHRoO1xyXG4gICAgICAgIHZhciB0d29Sb3dzRG93biA9IHdpZHRoICogMjtcclxuICAgICAgICB2YXIgdGhyZWVSb3dzRG93biA9IHdpZHRoICogMztcclxuICAgICAgICB2YXIgaU5leHQ7XHJcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwOyBpMCA8IGhlaWdodDsgaTAgPSBpTmV4dCkge1xyXG4gICAgICAgICAgaU5leHQgPSBNYXRoLm1pbihpMCArIDQsIGhlaWdodCk7XHJcbiAgICAgICAgICB2YXIgaW5kZXhCYXNlID0gaTAgKiB3aWR0aDtcclxuICAgICAgICAgIHZhciBjaGVja0FsbEVtcHR5ID0gaTAgKyAzIDwgaGVpZ2h0O1xyXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleDAgPSBpbmRleEJhc2UgKyBqO1xyXG4gICAgICAgICAgICAvLyB1c2luZyB0aGUgcHJvcGVydHk6IGxhYmVsc1tuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdXSA9PT0gMFxyXG4gICAgICAgICAgICAvLyB3aGVuIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF0gPT09IDBcclxuICAgICAgICAgICAgdmFyIGFsbEVtcHR5ID0gKGNoZWNrQWxsRW1wdHkgJiZcclxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXgwXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleDAgKyBvbmVSb3dEb3duXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleDAgKyB0d29Sb3dzRG93bl0gPT09IDAgJiZcclxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXgwICsgdGhyZWVSb3dzRG93bl0gPT09IDAgJiZcclxuICAgICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXgwXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleDAgKyBvbmVSb3dEb3duXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleDAgKyB0d29Sb3dzRG93bl0gPT09IDAgJiZcclxuICAgICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXgwICsgdGhyZWVSb3dzRG93bl0gPT09IDApO1xyXG4gICAgICAgICAgICB2YXIgaTEgPSAwLCBpbmRleCA9IGluZGV4MDtcclxuICAgICAgICAgICAgdmFyIGkgPSBpMCwgc2lnbjtcclxuICAgICAgICAgICAgaWYgKGFsbEVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgdmFyIGhhc1NpZ25pZmljYW50Q29lZmZpY2VudCA9XHJcbiAgICAgICAgICAgICAgICBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFJVTkxFTkdUSF9DT05URVhUKTtcclxuICAgICAgICAgICAgICBpZiAoIWhhc1NpZ25pZmljYW50Q29lZmZpY2VudCkge1xyXG4gICAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXgwXSsrO1xyXG4gICAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXgwICsgb25lUm93RG93bl0rKztcclxuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4MCArIHR3b1Jvd3NEb3duXSsrO1xyXG4gICAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXgwICsgdGhyZWVSb3dzRG93bl0rKztcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBuZXh0IGNvbHVtblxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpMSA9IChkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFVOSUZPUk1fQ09OVEVYVCkgPDwgMSkgfFxyXG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgVU5JRk9STV9DT05URVhUKTtcclxuICAgICAgICAgICAgICBpZiAoaTEgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGkgPSBpMCArIGkxO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gaTEgKiB3aWR0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHNpZ24gPSB0aGlzLmRlY29kZVNpZ25CaXQoaSwgaiwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgIGNvZWZmaWNlbnRzU2lnbltpbmRleF0gPSBzaWduO1xyXG4gICAgICAgICAgICAgIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSA9IDE7XHJcbiAgICAgICAgICAgICAgdGhpcy5zZXROZWlnaGJvcnNTaWduaWZpY2FuY2UoaSwgaiwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gfD0gZmlyc3RNYWduaXR1ZGVCaXRNYXNrO1xyXG5cclxuICAgICAgICAgICAgICBpbmRleCA9IGluZGV4MDtcclxuICAgICAgICAgICAgICBmb3IgKHZhciBpMiA9IGkwOyBpMiA8PSBpOyBpMisrLCBpbmRleCArPSB3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXhdKys7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpMSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IGkwICsgaTE7IGkgPCBpTmV4dDsgaSsrLCBpbmRleCArPSB3aWR0aCkge1xyXG4gICAgICAgICAgICAgIGlmIChjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gfHxcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdICYgcHJvY2Vzc2VkTWFzaykgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHRMYWJlbCA9IGxhYmVsc1tuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdXTtcclxuICAgICAgICAgICAgICB2YXIgZGVjaXNpb24gPSBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIGNvbnRleHRMYWJlbCk7XHJcbiAgICAgICAgICAgICAgaWYgKGRlY2lzaW9uID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzaWduID0gdGhpcy5kZWNvZGVTaWduQml0KGksIGosIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvZWZmaWNlbnRzU2lnbltpbmRleF0gPSBzaWduO1xyXG4gICAgICAgICAgICAgICAgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlKGksIGosIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gfD0gZmlyc3RNYWduaXR1ZGVCaXRNYXNrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleF0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgY2hlY2tTZWdtZW50YXRpb25TeW1ib2w6IGZ1bmN0aW9uIEJpdE1vZGVsX2NoZWNrU2VnbWVudGF0aW9uU3ltYm9sKCkge1xyXG4gICAgICAgIHZhciBkZWNvZGVyID0gdGhpcy5kZWNvZGVyO1xyXG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XHJcbiAgICAgICAgdmFyIHN5bWJvbCA9IChkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFVOSUZPUk1fQ09OVEVYVCkgPDwgMykgfFxyXG4gICAgICAgICAgICAgICAgICAgICAoZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBVTklGT1JNX0NPTlRFWFQpIDw8IDIpIHxcclxuICAgICAgICAgICAgICAgICAgICAgKGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgVU5JRk9STV9DT05URVhUKSA8PCAxKSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFVOSUZPUk1fQ09OVEVYVCk7XHJcbiAgICAgICAgaWYgKHN5bWJvbCAhPT0gMHhBKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogSW52YWxpZCBzZWdtZW50YXRpb24gc3ltYm9sJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBCaXRNb2RlbDtcclxuICB9KSgpO1xyXG5cclxuICAvLyBTZWN0aW9uIEYsIERpc2NyZXRlIHdhdmVsZXQgdHJhbnNmb3JtYXRpb25cclxuICB2YXIgVHJhbnNmb3JtID0gKGZ1bmN0aW9uIFRyYW5zZm9ybUNsb3N1cmUoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm0oKSB7fVxyXG5cclxuICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuY2FsY3VsYXRlID1cclxuICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtQ2FsY3VsYXRlKHN1YmJhbmRzLCB1MCwgdjApIHtcclxuICAgICAgdmFyIGxsID0gc3ViYmFuZHNbMF07XHJcbiAgICAgIGZvciAodmFyIGkgPSAxLCBpaSA9IHN1YmJhbmRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBsbCA9IHRoaXMuaXRlcmF0ZShsbCwgc3ViYmFuZHNbaV0sIHUwLCB2MCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxsO1xyXG4gICAgfTtcclxuICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSB7XHJcbiAgICAgIC8vIFNlY3Rpb24gRi4zLjcgZXh0ZW5kaW5nLi4uIHVzaW5nIG1heCBleHRlbnNpb24gb2YgNFxyXG4gICAgICB2YXIgaTEgPSBvZmZzZXQgLSAxLCBqMSA9IG9mZnNldCArIDE7XHJcbiAgICAgIHZhciBpMiA9IG9mZnNldCArIHNpemUgLSAyLCBqMiA9IG9mZnNldCArIHNpemU7XHJcbiAgICAgIGJ1ZmZlcltpMS0tXSA9IGJ1ZmZlcltqMSsrXTtcclxuICAgICAgYnVmZmVyW2oyKytdID0gYnVmZmVyW2kyLS1dO1xyXG4gICAgICBidWZmZXJbaTEtLV0gPSBidWZmZXJbajErK107XHJcbiAgICAgIGJ1ZmZlcltqMisrXSA9IGJ1ZmZlcltpMi0tXTtcclxuICAgICAgYnVmZmVyW2kxLS1dID0gYnVmZmVyW2oxKytdO1xyXG4gICAgICBidWZmZXJbajIrK10gPSBidWZmZXJbaTItLV07XHJcbiAgICAgIGJ1ZmZlcltpMV0gPSBidWZmZXJbajFdO1xyXG4gICAgICBidWZmZXJbajJdID0gYnVmZmVyW2kyXTtcclxuICAgIH07XHJcbiAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiBUcmFuc2Zvcm1faXRlcmF0ZShsbCwgaGxfbGhfaGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MCwgdjApIHtcclxuICAgICAgdmFyIGxsV2lkdGggPSBsbC53aWR0aCwgbGxIZWlnaHQgPSBsbC5oZWlnaHQsIGxsSXRlbXMgPSBsbC5pdGVtcztcclxuICAgICAgdmFyIHdpZHRoID0gaGxfbGhfaGgud2lkdGg7XHJcbiAgICAgIHZhciBoZWlnaHQgPSBobF9saF9oaC5oZWlnaHQ7XHJcbiAgICAgIHZhciBpdGVtcyA9IGhsX2xoX2hoLml0ZW1zO1xyXG4gICAgICB2YXIgaSwgaiwgaywgbCwgdSwgdjtcclxuXHJcbiAgICAgIC8vIEludGVybGVhdmUgTEwgYWNjb3JkaW5nIHRvIFNlY3Rpb24gRi4zLjNcclxuICAgICAgZm9yIChrID0gMCwgaSA9IDA7IGkgPCBsbEhlaWdodDsgaSsrKSB7XHJcbiAgICAgICAgbCA9IGkgKiAyICogd2lkdGg7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxsV2lkdGg7IGorKywgaysrLCBsICs9IDIpIHtcclxuICAgICAgICAgIGl0ZW1zW2xdID0gbGxJdGVtc1trXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gVGhlIExMIGJhbmQgaXMgbm90IG5lZWRlZCBhbnltb3JlLlxyXG4gICAgICBsbEl0ZW1zID0gbGwuaXRlbXMgPSBudWxsO1xyXG5cclxuICAgICAgdmFyIGJ1ZmZlclBhZGRpbmcgPSA0O1xyXG4gICAgICB2YXIgcm93QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCArIDIgKiBidWZmZXJQYWRkaW5nKTtcclxuXHJcbiAgICAgIC8vIFNlY3Rpb24gRi4zLjQgSE9SX1NSXHJcbiAgICAgIGlmICh3aWR0aCA9PT0gMSkge1xyXG4gICAgICAgIC8vIGlmIHdpZHRoID0gMSwgd2hlbiB1MCBldmVuIGtlZXAgaXRlbXMgYXMgaXMsIHdoZW4gb2RkIGRpdmlkZSBieSAyXHJcbiAgICAgICAgaWYgKCh1MCAmIDEpICE9PSAwKSB7XHJcbiAgICAgICAgICBmb3IgKHYgPSAwLCBrID0gMDsgdiA8IGhlaWdodDsgdisrLCBrICs9IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIGl0ZW1zW2tdICo9IDAuNTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICh2ID0gMCwgayA9IDA7IHYgPCBoZWlnaHQ7IHYrKywgayArPSB3aWR0aCkge1xyXG4gICAgICAgICAgcm93QnVmZmVyLnNldChpdGVtcy5zdWJhcnJheShrLCBrICsgd2lkdGgpLCBidWZmZXJQYWRkaW5nKTtcclxuXHJcbiAgICAgICAgICB0aGlzLmV4dGVuZChyb3dCdWZmZXIsIGJ1ZmZlclBhZGRpbmcsIHdpZHRoKTtcclxuICAgICAgICAgIHRoaXMuZmlsdGVyKHJvd0J1ZmZlciwgYnVmZmVyUGFkZGluZywgd2lkdGgpO1xyXG5cclxuICAgICAgICAgIGl0ZW1zLnNldChcclxuICAgICAgICAgICAgcm93QnVmZmVyLnN1YmFycmF5KGJ1ZmZlclBhZGRpbmcsIGJ1ZmZlclBhZGRpbmcgKyB3aWR0aCksXHJcbiAgICAgICAgICAgIGspO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWNjZXNzZXMgdG8gdGhlIGl0ZW1zIGFycmF5IGNhbiB0YWtlIGxvbmcsIGJlY2F1c2UgaXQgbWF5IG5vdCBmaXQgaW50b1xyXG4gICAgICAvLyBDUFUgY2FjaGUgYW5kIGhhcyB0byBiZSBmZXRjaGVkIGZyb20gbWFpbiBtZW1vcnkuIFNpbmNlIHN1YnNlcXVlbnRcclxuICAgICAgLy8gYWNjZXNzZXMgdG8gdGhlIGl0ZW1zIGFycmF5IGFyZSBub3QgbG9jYWwgd2hlbiByZWFkaW5nIGNvbHVtbnMsIHdlXHJcbiAgICAgIC8vIGhhdmUgYSBjYWNoZSBtaXNzIGV2ZXJ5IHRpbWUuIFRvIHJlZHVjZSBjYWNoZSBtaXNzZXMsIGdldCB1cCB0b1xyXG4gICAgICAvLyAnbnVtQnVmZmVycycgaXRlbXMgYXQgYSB0aW1lIGFuZCBzdG9yZSB0aGVtIGludG8gdGhlIGluZGl2aWR1YWxcclxuICAgICAgLy8gYnVmZmVycy4gVGhlIGNvbEJ1ZmZlcnMgc2hvdWxkIGJlIHNtYWxsIGVub3VnaCB0byBmaXQgaW50byBDUFUgY2FjaGUuXHJcbiAgICAgIHZhciBudW1CdWZmZXJzID0gMTY7XHJcbiAgICAgIHZhciBjb2xCdWZmZXJzID0gW107XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1CdWZmZXJzOyBpKyspIHtcclxuICAgICAgICBjb2xCdWZmZXJzLnB1c2gobmV3IEZsb2F0MzJBcnJheShoZWlnaHQgKyAyICogYnVmZmVyUGFkZGluZykpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBiLCBjdXJyZW50QnVmZmVyID0gMDtcclxuICAgICAgbGwgPSBidWZmZXJQYWRkaW5nICsgaGVpZ2h0O1xyXG5cclxuICAgICAgLy8gU2VjdGlvbiBGLjMuNSBWRVJfU1JcclxuICAgICAgaWYgKGhlaWdodCA9PT0gMSkge1xyXG4gICAgICAgICAgLy8gaWYgaGVpZ2h0ID0gMSwgd2hlbiB2MCBldmVuIGtlZXAgaXRlbXMgYXMgaXMsIHdoZW4gb2RkIGRpdmlkZSBieSAyXHJcbiAgICAgICAgaWYgKCh2MCAmIDEpICE9PSAwKSB7XHJcbiAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xyXG4gICAgICAgICAgICBpdGVtc1t1XSAqPSAwLjU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAodSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XHJcbiAgICAgICAgICAvLyBpZiB3ZSByYW4gb3V0IG9mIGJ1ZmZlcnMsIGNvcHkgc2V2ZXJhbCBpbWFnZSBjb2x1bW5zIGF0IG9uY2VcclxuICAgICAgICAgIGlmIChjdXJyZW50QnVmZmVyID09PSAwKSB7XHJcbiAgICAgICAgICAgIG51bUJ1ZmZlcnMgPSBNYXRoLm1pbih3aWR0aCAtIHUsIG51bUJ1ZmZlcnMpO1xyXG4gICAgICAgICAgICBmb3IgKGsgPSB1LCBsID0gYnVmZmVyUGFkZGluZzsgbCA8IGxsOyBrICs9IHdpZHRoLCBsKyspIHtcclxuICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgbnVtQnVmZmVyczsgYisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xCdWZmZXJzW2JdW2xdID0gaXRlbXNbayArIGJdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50QnVmZmVyID0gbnVtQnVmZmVycztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjdXJyZW50QnVmZmVyLS07XHJcbiAgICAgICAgICB2YXIgYnVmZmVyID0gY29sQnVmZmVyc1tjdXJyZW50QnVmZmVyXTtcclxuICAgICAgICAgIHRoaXMuZXh0ZW5kKGJ1ZmZlciwgYnVmZmVyUGFkZGluZywgaGVpZ2h0KTtcclxuICAgICAgICAgIHRoaXMuZmlsdGVyKGJ1ZmZlciwgYnVmZmVyUGFkZGluZywgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIGxhc3QgYnVmZmVyIGluIHRoaXMgZ3JvdXAgb2YgYnVmZmVycywgZmx1c2ggYWxsIGJ1ZmZlcnMuXHJcbiAgICAgICAgICBpZiAoY3VycmVudEJ1ZmZlciA9PT0gMCkge1xyXG4gICAgICAgICAgICBrID0gdSAtIG51bUJ1ZmZlcnMgKyAxO1xyXG4gICAgICAgICAgICBmb3IgKGwgPSBidWZmZXJQYWRkaW5nOyBsIDwgbGw7IGsgKz0gd2lkdGgsIGwrKykge1xyXG4gICAgICAgICAgICAgIGZvciAoYiA9IDA7IGIgPCBudW1CdWZmZXJzOyBiKyspIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1zW2sgKyBiXSA9IGNvbEJ1ZmZlcnNbYl1bbF07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICBpdGVtczogaXRlbXNcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVHJhbnNmb3JtO1xyXG4gIH0pKCk7XHJcblxyXG4gIC8vIFNlY3Rpb24gMy44LjIgSXJyZXZlcnNpYmxlIDktNyBmaWx0ZXJcclxuICB2YXIgSXJyZXZlcnNpYmxlVHJhbnNmb3JtID0gKGZ1bmN0aW9uIElycmV2ZXJzaWJsZVRyYW5zZm9ybUNsb3N1cmUoKSB7XHJcbiAgICBmdW5jdGlvbiBJcnJldmVyc2libGVUcmFuc2Zvcm0oKSB7XHJcbiAgICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIElycmV2ZXJzaWJsZVRyYW5zZm9ybS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpO1xyXG4gICAgSXJyZXZlcnNpYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5maWx0ZXIgPVxyXG4gICAgICBmdW5jdGlvbiBpcnJldmVyc2libGVUcmFuc2Zvcm1GaWx0ZXIoeCwgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgdmFyIGxlbiA9IGxlbmd0aCA+PiAxO1xyXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xyXG4gICAgICB2YXIgaiwgbiwgY3VycmVudCwgbmV4dDtcclxuXHJcbiAgICAgIHZhciBhbHBoYSA9IC0xLjU4NjEzNDM0MjA1OTkyNDtcclxuICAgICAgdmFyIGJldGEgPSAtMC4wNTI5ODAxMTg1NzI5NjE7XHJcbiAgICAgIHZhciBnYW1tYSA9IDAuODgyOTExMDc1NTMwOTM0O1xyXG4gICAgICB2YXIgZGVsdGEgPSAwLjQ0MzUwNjg1MjA0Mzk3MTtcclxuICAgICAgdmFyIEsgPSAxLjIzMDE3NDEwNDkxNDAwMTtcclxuICAgICAgdmFyIEtfID0gMSAvIEs7XHJcblxyXG4gICAgICAvLyBzdGVwIDEgaXMgY29tYmluZWQgd2l0aCBzdGVwIDNcclxuXHJcbiAgICAgIC8vIHN0ZXAgMlxyXG4gICAgICBqID0gb2Zmc2V0IC0gMztcclxuICAgICAgZm9yIChuID0gbGVuICsgNDsgbi0tOyBqICs9IDIpIHtcclxuICAgICAgICB4W2pdICo9IEtfO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzdGVwIDEgJiAzXHJcbiAgICAgIGogPSBvZmZzZXQgLSAyO1xyXG4gICAgICBjdXJyZW50ID0gZGVsdGEgKiB4W2ogLTFdO1xyXG4gICAgICBmb3IgKG4gPSBsZW4gKyAzOyBuLS07IGogKz0gMikge1xyXG4gICAgICAgIG5leHQgPSBkZWx0YSAqIHhbaiArIDFdO1xyXG4gICAgICAgIHhbal0gPSBLICogeFtqXSAtIGN1cnJlbnQgLSBuZXh0O1xyXG4gICAgICAgIGlmIChuLS0pIHtcclxuICAgICAgICAgIGogKz0gMjtcclxuICAgICAgICAgIGN1cnJlbnQgPSBkZWx0YSAqIHhbaiArIDFdO1xyXG4gICAgICAgICAgeFtqXSA9IEsgKiB4W2pdIC0gY3VycmVudCAtIG5leHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3RlcCA0XHJcbiAgICAgIGogPSBvZmZzZXQgLSAxO1xyXG4gICAgICBjdXJyZW50ID0gZ2FtbWEgKiB4W2ogLSAxXTtcclxuICAgICAgZm9yIChuID0gbGVuICsgMjsgbi0tOyBqICs9IDIpIHtcclxuICAgICAgICBuZXh0ID0gZ2FtbWEgKiB4W2ogKyAxXTtcclxuICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xyXG4gICAgICAgIGlmIChuLS0pIHtcclxuICAgICAgICAgIGogKz0gMjtcclxuICAgICAgICAgIGN1cnJlbnQgPSBnYW1tYSAqIHhbaiArIDFdO1xyXG4gICAgICAgICAgeFtqXSAtPSBjdXJyZW50ICsgbmV4dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzdGVwIDVcclxuICAgICAgaiA9IG9mZnNldDtcclxuICAgICAgY3VycmVudCA9IGJldGEgKiB4W2ogLSAxXTtcclxuICAgICAgZm9yIChuID0gbGVuICsgMTsgbi0tOyBqICs9IDIpIHtcclxuICAgICAgICBuZXh0ID0gYmV0YSAqIHhbaiArIDFdO1xyXG4gICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XHJcbiAgICAgICAgaWYgKG4tLSkge1xyXG4gICAgICAgICAgaiArPSAyO1xyXG4gICAgICAgICAgY3VycmVudCA9IGJldGEgKiB4W2ogKyAxXTtcclxuICAgICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3RlcCA2XHJcbiAgICAgIGlmIChsZW4gIT09IDApIHtcclxuICAgICAgICBqID0gb2Zmc2V0ICsgMTtcclxuICAgICAgICBjdXJyZW50ID0gYWxwaGEgKiB4W2ogLSAxXTtcclxuICAgICAgICBmb3IgKG4gPSBsZW47IG4tLTsgaiArPSAyKSB7XHJcbiAgICAgICAgICBuZXh0ID0gYWxwaGEgKiB4W2ogKyAxXTtcclxuICAgICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XHJcbiAgICAgICAgICBpZiAobi0tKSB7XHJcbiAgICAgICAgICAgIGogKz0gMjtcclxuICAgICAgICAgICAgY3VycmVudCA9IGFscGhhICogeFtqICsgMV07XHJcbiAgICAgICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIElycmV2ZXJzaWJsZVRyYW5zZm9ybTtcclxuICB9KSgpO1xyXG5cclxuICAvLyBTZWN0aW9uIDMuOC4xIFJldmVyc2libGUgNS0zIGZpbHRlclxyXG4gIHZhciBSZXZlcnNpYmxlVHJhbnNmb3JtID0gKGZ1bmN0aW9uIFJldmVyc2libGVUcmFuc2Zvcm1DbG9zdXJlKCkge1xyXG4gICAgZnVuY3Rpb24gUmV2ZXJzaWJsZVRyYW5zZm9ybSgpIHtcclxuICAgICAgVHJhbnNmb3JtLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgUmV2ZXJzaWJsZVRyYW5zZm9ybS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpO1xyXG4gICAgUmV2ZXJzaWJsZVRyYW5zZm9ybS5wcm90b3R5cGUuZmlsdGVyID1cclxuICAgICAgZnVuY3Rpb24gcmV2ZXJzaWJsZVRyYW5zZm9ybUZpbHRlcih4LCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICB2YXIgbGVuID0gbGVuZ3RoID4+IDE7XHJcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XHJcbiAgICAgIHZhciBqLCBuO1xyXG5cclxuICAgICAgZm9yIChqID0gb2Zmc2V0LCBuID0gbGVuICsgMTsgbi0tOyBqICs9IDIpIHtcclxuICAgICAgICB4W2pdIC09ICh4W2ogLSAxXSArIHhbaiArIDFdICsgMikgPj4gMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChqID0gb2Zmc2V0ICsgMSwgbiA9IGxlbjsgbi0tOyBqICs9IDIpIHtcclxuICAgICAgICB4W2pdICs9ICh4W2ogLSAxXSArIHhbaiArIDFdKSA+PiAxO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBSZXZlcnNpYmxlVHJhbnNmb3JtO1xyXG4gIH0pKCk7XHJcblxyXG4gIHJldHVybiBKcHhJbWFnZTtcclxufSkoKTtcclxuXHJcblxyXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xyXG4vKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXHJcbi8qIENvcHlyaWdodCAyMDEyIE1vemlsbGEgRm91bmRhdGlvblxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIFFNIENvZGVyIGRlY29kaW5nIGFzIGRlZmluZWQgaW5cclxuICogICBKUEVHIDIwMDAgUGFydCBJIEZpbmFsIENvbW1pdHRlZSBEcmFmdCBWZXJzaW9uIDEuMFxyXG4gKiAgIEFubmV4IEMuMyBBcml0aG1ldGljIGRlY29kaW5nIHByb2NlZHVyZSBcclxuICogYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuanBlZy5vcmcvcHVibGljL2ZjZDE1NDQ0LTEucGRmXHJcbiAqIFxyXG4gKiBUaGUgYXJpdGhtZXRpYyBkZWNvZGVyIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBjb250ZXh0IG1vZGVscyB0byBkZWNvZGVcclxuICogSlBFRzIwMDAgYW5kIEpCSUcyIHN0cmVhbXMuXHJcbiAqL1xyXG52YXIgQXJpdGhtZXRpY0RlY29kZXIgPSAoZnVuY3Rpb24gQXJpdGhtZXRpY0RlY29kZXJDbG9zdXJlKCkge1xyXG4gIC8vIFRhYmxlIEMtMlxyXG4gIHZhciBRZVRhYmxlID0gW1xyXG4gICAge3FlOiAweDU2MDEsIG5tcHM6IDEsIG5scHM6IDEsIHN3aXRjaEZsYWc6IDF9LFxyXG4gICAge3FlOiAweDM0MDEsIG5tcHM6IDIsIG5scHM6IDYsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDE4MDEsIG5tcHM6IDMsIG5scHM6IDksIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDBBQzEsIG5tcHM6IDQsIG5scHM6IDEyLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwNTIxLCBubXBzOiA1LCBubHBzOiAyOSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDIyMSwgbm1wczogMzgsIG5scHM6IDMzLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHg1NjAxLCBubXBzOiA3LCBubHBzOiA2LCBzd2l0Y2hGbGFnOiAxfSxcclxuICAgIHtxZTogMHg1NDAxLCBubXBzOiA4LCBubHBzOiAxNCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4NDgwMSwgbm1wczogOSwgbmxwczogMTQsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDM4MDEsIG5tcHM6IDEwLCBubHBzOiAxNCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MzAwMSwgbm1wczogMTEsIG5scHM6IDE3LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgyNDAxLCBubXBzOiAxMiwgbmxwczogMTgsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDFDMDEsIG5tcHM6IDEzLCBubHBzOiAyMCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MTYwMSwgbm1wczogMjksIG5scHM6IDIxLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHg1NjAxLCBubXBzOiAxNSwgbmxwczogMTQsIHN3aXRjaEZsYWc6IDF9LFxyXG4gICAge3FlOiAweDU0MDEsIG5tcHM6IDE2LCBubHBzOiAxNCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4NTEwMSwgbm1wczogMTcsIG5scHM6IDE1LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHg0ODAxLCBubXBzOiAxOCwgbmxwczogMTYsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDM4MDEsIG5tcHM6IDE5LCBubHBzOiAxNywgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MzQwMSwgbm1wczogMjAsIG5scHM6IDE4LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgzMDAxLCBubXBzOiAyMSwgbmxwczogMTksIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDI4MDEsIG5tcHM6IDIyLCBubHBzOiAxOSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MjQwMSwgbm1wczogMjMsIG5scHM6IDIwLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgyMjAxLCBubXBzOiAyNCwgbmxwczogMjEsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDFDMDEsIG5tcHM6IDI1LCBubHBzOiAyMiwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MTgwMSwgbm1wczogMjYsIG5scHM6IDIzLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgxNjAxLCBubXBzOiAyNywgbmxwczogMjQsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDE0MDEsIG5tcHM6IDI4LCBubHBzOiAyNSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MTIwMSwgbm1wczogMjksIG5scHM6IDI2LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgxMTAxLCBubXBzOiAzMCwgbmxwczogMjcsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDBBQzEsIG5tcHM6IDMxLCBubHBzOiAyOCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDlDMSwgbm1wczogMzIsIG5scHM6IDI5LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwOEExLCBubXBzOiAzMywgbmxwczogMzAsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDA1MjEsIG5tcHM6IDM0LCBubHBzOiAzMSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDQ0MSwgbm1wczogMzUsIG5scHM6IDMyLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwMkExLCBubXBzOiAzNiwgbmxwczogMzMsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDAyMjEsIG5tcHM6IDM3LCBubHBzOiAzNCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDE0MSwgbm1wczogMzgsIG5scHM6IDM1LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwMTExLCBubXBzOiAzOSwgbmxwczogMzYsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDAwODUsIG5tcHM6IDQwLCBubHBzOiAzNywgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDA0OSwgbm1wczogNDEsIG5scHM6IDM4LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwMDI1LCBubXBzOiA0MiwgbmxwczogMzksIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDAwMTUsIG5tcHM6IDQzLCBubHBzOiA0MCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDAwOSwgbm1wczogNDQsIG5scHM6IDQxLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwMDA1LCBubXBzOiA0NSwgbmxwczogNDIsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDAwMDEsIG5tcHM6IDQ1LCBubHBzOiA0Mywgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4NTYwMSwgbm1wczogNDYsIG5scHM6IDQ2LCBzd2l0Y2hGbGFnOiAwfVxyXG4gIF07XHJcblxyXG4gIC8vIEMuMy41IEluaXRpYWxpc2F0aW9uIG9mIHRoZSBkZWNvZGVyIChJTklUREVDKVxyXG4gIGZ1bmN0aW9uIEFyaXRobWV0aWNEZWNvZGVyKGRhdGEsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmJwID0gc3RhcnQ7XHJcbiAgICB0aGlzLmRhdGFFbmQgPSBlbmQ7XHJcblxyXG4gICAgdGhpcy5jaGlnaCA9IGRhdGFbc3RhcnRdO1xyXG4gICAgdGhpcy5jbG93ID0gMDtcclxuXHJcbiAgICB0aGlzLmJ5dGVJbigpO1xyXG5cclxuICAgIHRoaXMuY2hpZ2ggPSAoKHRoaXMuY2hpZ2ggPDwgNykgJiAweEZGRkYpIHwgKCh0aGlzLmNsb3cgPj4gOSkgJiAweDdGKTtcclxuICAgIHRoaXMuY2xvdyA9ICh0aGlzLmNsb3cgPDwgNykgJiAweEZGRkY7XHJcbiAgICB0aGlzLmN0IC09IDc7XHJcbiAgICB0aGlzLmEgPSAweDgwMDA7XHJcbiAgfVxyXG5cclxuICBBcml0aG1ldGljRGVjb2Rlci5wcm90b3R5cGUgPSB7XHJcbiAgICAvLyBDLjMuNCBDb21wcmVzc2VkIGRhdGEgaW5wdXQgKEJZVEVJTilcclxuICAgIGJ5dGVJbjogZnVuY3Rpb24gQXJpdGhtZXRpY0RlY29kZXJfYnl0ZUluKCkge1xyXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgdmFyIGJwID0gdGhpcy5icDtcclxuICAgICAgaWYgKGRhdGFbYnBdID09PSAweEZGKSB7XHJcbiAgICAgICAgdmFyIGIxID0gZGF0YVticCArIDFdO1xyXG4gICAgICAgIGlmIChiMSA+IDB4OEYpIHtcclxuICAgICAgICAgIHRoaXMuY2xvdyArPSAweEZGMDA7XHJcbiAgICAgICAgICB0aGlzLmN0ID0gODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYnArKztcclxuICAgICAgICAgIHRoaXMuY2xvdyArPSAoZGF0YVticF0gPDwgOSk7XHJcbiAgICAgICAgICB0aGlzLmN0ID0gNztcclxuICAgICAgICAgIHRoaXMuYnAgPSBicDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnArKztcclxuICAgICAgICB0aGlzLmNsb3cgKz0gYnAgPCB0aGlzLmRhdGFFbmQgPyAoZGF0YVticF0gPDwgOCkgOiAweEZGMDA7XHJcbiAgICAgICAgdGhpcy5jdCA9IDg7XHJcbiAgICAgICAgdGhpcy5icCA9IGJwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmNsb3cgPiAweEZGRkYpIHtcclxuICAgICAgICB0aGlzLmNoaWdoICs9ICh0aGlzLmNsb3cgPj4gMTYpO1xyXG4gICAgICAgIHRoaXMuY2xvdyAmPSAweEZGRkY7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBDLjMuMiBEZWNvZGluZyBhIGRlY2lzaW9uIChERUNPREUpXHJcbiAgICByZWFkQml0OiBmdW5jdGlvbiBBcml0aG1ldGljRGVjb2Rlcl9yZWFkQml0KGNvbnRleHRzLCBwb3MpIHtcclxuICAgICAgLy8gY29udGV4dHMgYXJlIHBhY2tlZCBpbnRvIDEgYnl0ZTpcclxuICAgICAgLy8gaGlnaGVzdCA3IGJpdHMgY2FycnkgY3guaW5kZXgsIGxvd2VzdCBiaXQgY2FycmllcyBjeC5tcHNcclxuICAgICAgdmFyIGN4X2luZGV4ID0gY29udGV4dHNbcG9zXSA+PiAxLCBjeF9tcHMgPSBjb250ZXh0c1twb3NdICYgMTtcclxuICAgICAgdmFyIHFlVGFibGVJY3ggPSBRZVRhYmxlW2N4X2luZGV4XTtcclxuICAgICAgdmFyIHFlSWN4ID0gcWVUYWJsZUljeC5xZTtcclxuICAgICAgdmFyIGQ7XHJcbiAgICAgIHZhciBhID0gdGhpcy5hIC0gcWVJY3g7XHJcblxyXG4gICAgICBpZiAodGhpcy5jaGlnaCA8IHFlSWN4KSB7XHJcbiAgICAgICAgLy8gZXhjaGFuZ2VMcHNcclxuICAgICAgICBpZiAoYSA8IHFlSWN4KSB7XHJcbiAgICAgICAgICBhID0gcWVJY3g7XHJcbiAgICAgICAgICBkID0gY3hfbXBzO1xyXG4gICAgICAgICAgY3hfaW5kZXggPSBxZVRhYmxlSWN4Lm5tcHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSBxZUljeDtcclxuICAgICAgICAgIGQgPSAxIF4gY3hfbXBzO1xyXG4gICAgICAgICAgaWYgKHFlVGFibGVJY3guc3dpdGNoRmxhZyA9PT0gMSkge1xyXG4gICAgICAgICAgICBjeF9tcHMgPSBkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3hfaW5kZXggPSBxZVRhYmxlSWN4Lm5scHM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY2hpZ2ggLT0gcWVJY3g7XHJcbiAgICAgICAgaWYgKChhICYgMHg4MDAwKSAhPT0gMCkge1xyXG4gICAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICAgIHJldHVybiBjeF9tcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4Y2hhbmdlTXBzXHJcbiAgICAgICAgaWYgKGEgPCBxZUljeCkge1xyXG4gICAgICAgICAgZCA9IDEgXiBjeF9tcHM7XHJcbiAgICAgICAgICBpZiAocWVUYWJsZUljeC5zd2l0Y2hGbGFnID09PSAxKSB7XHJcbiAgICAgICAgICAgIGN4X21wcyA9IGQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjeF9pbmRleCA9IHFlVGFibGVJY3gubmxwcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZCA9IGN4X21wcztcclxuICAgICAgICAgIGN4X2luZGV4ID0gcWVUYWJsZUljeC5ubXBzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBDLjMuMyByZW5vcm1EO1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3QgPT09IDApIHtcclxuICAgICAgICAgIHRoaXMuYnl0ZUluKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhIDw8PSAxO1xyXG4gICAgICAgIHRoaXMuY2hpZ2ggPSAoKHRoaXMuY2hpZ2ggPDwgMSkgJiAweEZGRkYpIHwgKCh0aGlzLmNsb3cgPj4gMTUpICYgMSk7XHJcbiAgICAgICAgdGhpcy5jbG93ID0gKHRoaXMuY2xvdyA8PCAxKSAmIDB4RkZGRjtcclxuICAgICAgICB0aGlzLmN0LS07XHJcbiAgICAgIH0gd2hpbGUgKChhICYgMHg4MDAwKSA9PT0gMCk7XHJcbiAgICAgIHRoaXMuYSA9IGE7XHJcblxyXG4gICAgICBjb250ZXh0c1twb3NdID0gY3hfaW5kZXggPDwgMSB8IGN4X21wcztcclxuICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEFyaXRobWV0aWNEZWNvZGVyO1xyXG59KSgpO1xyXG5cclxuLyogLSotIE1vZGU6IEphdmE7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gKi9cclxuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xyXG4vKiBDb3B5cmlnaHQgMjAxMiBNb3ppbGxhIEZvdW5kYXRpb25cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiBnbG9iYWxzIENtZCwgQ29sb3JTcGFjZSwgRGljdCwgTW96QmxvYkJ1aWxkZXIsIE5hbWUsIFBERkpTLCBSZWYsIFVSTCxcclxuICAgICAgICAgICBQcm9taXNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZ2xvYmFsU2NvcGUgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcyA6IHdpbmRvdztcclxuXHJcbnZhciBpc1dvcmtlciA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyk7XHJcblxyXG52YXIgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcclxuXHJcbnZhciBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcclxuICBGSUxMOiAwLFxyXG4gIFNUUk9LRTogMSxcclxuICBGSUxMX1NUUk9LRTogMixcclxuICBJTlZJU0lCTEU6IDMsXHJcbiAgRklMTF9BRERfVE9fUEFUSDogNCxcclxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXHJcbiAgRklMTF9TVFJPS0VfQUREX1RPX1BBVEg6IDYsXHJcbiAgQUREX1RPX1BBVEg6IDcsXHJcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcclxuICBBRERfVE9fUEFUSF9GTEFHOiA0XHJcbn07XHJcblxyXG52YXIgSW1hZ2VLaW5kID0ge1xyXG4gIEdSQVlTQ0FMRV8xQlBQOiAxLFxyXG4gIFJHQl8yNEJQUDogMixcclxuICBSR0JBXzMyQlBQOiAzXHJcbn07XHJcblxyXG52YXIgQW5ub3RhdGlvblR5cGUgPSB7XHJcbiAgV0lER0VUOiAxLFxyXG4gIFRFWFQ6IDIsXHJcbiAgTElOSzogM1xyXG59O1xyXG5cclxudmFyIFN0cmVhbVR5cGUgPSB7XHJcbiAgVU5LTk9XTjogMCxcclxuICBGTEFURTogMSxcclxuICBMWlc6IDIsXHJcbiAgRENUOiAzLFxyXG4gIEpQWDogNCxcclxuICBKQklHOiA1LFxyXG4gIEE4NTogNixcclxuICBBSFg6IDcsXHJcbiAgQ0NGOiA4LFxyXG4gIFJMOiA5XHJcbn07XHJcblxyXG52YXIgRm9udFR5cGUgPSB7XHJcbiAgVU5LTk9XTjogMCxcclxuICBUWVBFMTogMSxcclxuICBUWVBFMUM6IDIsXHJcbiAgQ0lERk9OVFRZUEUwOiAzLFxyXG4gIENJREZPTlRUWVBFMEM6IDQsXHJcbiAgVFJVRVRZUEU6IDUsXHJcbiAgQ0lERk9OVFRZUEUyOiA2LFxyXG4gIFRZUEUzOiA3LFxyXG4gIE9QRU5UWVBFOiA4LFxyXG4gIFRZUEUwOiA5LFxyXG4gIE1NVFlQRTE6IDEwXHJcbn07XHJcblxyXG4vLyBUaGUgZ2xvYmFsIFBERkpTIG9iamVjdCBleHBvc2VzIHRoZSBBUElcclxuLy8gSW4gcHJvZHVjdGlvbiwgaXQgd2lsbCBiZSBkZWNsYXJlZCBvdXRzaWRlIGEgZ2xvYmFsIHdyYXBwZXJcclxuLy8gSW4gZGV2ZWxvcG1lbnQsIGl0IHdpbGwgYmUgZGVjbGFyZWQgaGVyZVxyXG5pZiAoIWdsb2JhbFNjb3BlLlBERkpTKSB7XHJcbiAgZ2xvYmFsU2NvcGUuUERGSlMgPSB7fTtcclxufVxyXG5cclxuZ2xvYmFsU2NvcGUuUERGSlMucGRmQnVnID0gZmFsc2U7XHJcblxyXG5QREZKUy5WRVJCT1NJVFlfTEVWRUxTID0ge1xyXG4gIGVycm9yczogMCxcclxuICB3YXJuaW5nczogMSxcclxuICBpbmZvczogNVxyXG59O1xyXG5cclxuLy8gQWxsIHRoZSBwb3NzaWJsZSBvcGVyYXRpb25zIGZvciBhbiBvcGVyYXRvciBsaXN0LlxyXG52YXIgT1BTID0gUERGSlMuT1BTID0ge1xyXG4gIC8vIEludGVudGlvbmFsbHkgc3RhcnQgZnJvbSAxIHNvIGl0IGlzIGVhc3kgdG8gc3BvdCBiYWQgb3BlcmF0b3JzIHRoYXQgd2lsbCBiZVxyXG4gIC8vIDAncy5cclxuICBkZXBlbmRlbmN5OiAxLFxyXG4gIHNldExpbmVXaWR0aDogMixcclxuICBzZXRMaW5lQ2FwOiAzLFxyXG4gIHNldExpbmVKb2luOiA0LFxyXG4gIHNldE1pdGVyTGltaXQ6IDUsXHJcbiAgc2V0RGFzaDogNixcclxuICBzZXRSZW5kZXJpbmdJbnRlbnQ6IDcsXHJcbiAgc2V0RmxhdG5lc3M6IDgsXHJcbiAgc2V0R1N0YXRlOiA5LFxyXG4gIHNhdmU6IDEwLFxyXG4gIHJlc3RvcmU6IDExLFxyXG4gIHRyYW5zZm9ybTogMTIsXHJcbiAgbW92ZVRvOiAxMyxcclxuICBsaW5lVG86IDE0LFxyXG4gIGN1cnZlVG86IDE1LFxyXG4gIGN1cnZlVG8yOiAxNixcclxuICBjdXJ2ZVRvMzogMTcsXHJcbiAgY2xvc2VQYXRoOiAxOCxcclxuICByZWN0YW5nbGU6IDE5LFxyXG4gIHN0cm9rZTogMjAsXHJcbiAgY2xvc2VTdHJva2U6IDIxLFxyXG4gIGZpbGw6IDIyLFxyXG4gIGVvRmlsbDogMjMsXHJcbiAgZmlsbFN0cm9rZTogMjQsXHJcbiAgZW9GaWxsU3Ryb2tlOiAyNSxcclxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxyXG4gIGNsb3NlRU9GaWxsU3Ryb2tlOiAyNyxcclxuICBlbmRQYXRoOiAyOCxcclxuICBjbGlwOiAyOSxcclxuICBlb0NsaXA6IDMwLFxyXG4gIGJlZ2luVGV4dDogMzEsXHJcbiAgZW5kVGV4dDogMzIsXHJcbiAgc2V0Q2hhclNwYWNpbmc6IDMzLFxyXG4gIHNldFdvcmRTcGFjaW5nOiAzNCxcclxuICBzZXRIU2NhbGU6IDM1LFxyXG4gIHNldExlYWRpbmc6IDM2LFxyXG4gIHNldEZvbnQ6IDM3LFxyXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcclxuICBzZXRUZXh0UmlzZTogMzksXHJcbiAgbW92ZVRleHQ6IDQwLFxyXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXHJcbiAgc2V0VGV4dE1hdHJpeDogNDIsXHJcbiAgbmV4dExpbmU6IDQzLFxyXG4gIHNob3dUZXh0OiA0NCxcclxuICBzaG93U3BhY2VkVGV4dDogNDUsXHJcbiAgbmV4dExpbmVTaG93VGV4dDogNDYsXHJcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxyXG4gIHNldENoYXJXaWR0aDogNDgsXHJcbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzOiA0OSxcclxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcclxuICBzZXRGaWxsQ29sb3JTcGFjZTogNTEsXHJcbiAgc2V0U3Ryb2tlQ29sb3I6IDUyLFxyXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXHJcbiAgc2V0RmlsbENvbG9yOiA1NCxcclxuICBzZXRGaWxsQ29sb3JOOiA1NSxcclxuICBzZXRTdHJva2VHcmF5OiA1NixcclxuICBzZXRGaWxsR3JheTogNTcsXHJcbiAgc2V0U3Ryb2tlUkdCQ29sb3I6IDU4LFxyXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXHJcbiAgc2V0U3Ryb2tlQ01ZS0NvbG9yOiA2MCxcclxuICBzZXRGaWxsQ01ZS0NvbG9yOiA2MSxcclxuICBzaGFkaW5nRmlsbDogNjIsXHJcbiAgYmVnaW5JbmxpbmVJbWFnZTogNjMsXHJcbiAgYmVnaW5JbWFnZURhdGE6IDY0LFxyXG4gIGVuZElubGluZUltYWdlOiA2NSxcclxuICBwYWludFhPYmplY3Q6IDY2LFxyXG4gIG1hcmtQb2ludDogNjcsXHJcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxyXG4gIGJlZ2luTWFya2VkQ29udGVudDogNjksXHJcbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHM6IDcwLFxyXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxyXG4gIGJlZ2luQ29tcGF0OiA3MixcclxuICBlbmRDb21wYXQ6IDczLFxyXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXHJcbiAgcGFpbnRGb3JtWE9iamVjdEVuZDogNzUsXHJcbiAgYmVnaW5Hcm91cDogNzYsXHJcbiAgZW5kR3JvdXA6IDc3LFxyXG4gIGJlZ2luQW5ub3RhdGlvbnM6IDc4LFxyXG4gIGVuZEFubm90YXRpb25zOiA3OSxcclxuICBiZWdpbkFubm90YXRpb246IDgwLFxyXG4gIGVuZEFubm90YXRpb246IDgxLFxyXG4gIHBhaW50SnBlZ1hPYmplY3Q6IDgyLFxyXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdDogODMsXHJcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxyXG4gIHBhaW50SW1hZ2VYT2JqZWN0OiA4NSxcclxuICBwYWludElubGluZUltYWdlWE9iamVjdDogODYsXHJcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXHJcbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQ6IDg4LFxyXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdDogODksXHJcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcclxuICBjb25zdHJ1Y3RQYXRoOiA5MVxyXG59O1xyXG5cclxuLy8gQSBub3RpY2UgZm9yIGRldnMuIFRoZXNlIGFyZSBnb29kIGZvciB0aGluZ3MgdGhhdCBhcmUgaGVscGZ1bCB0byBkZXZzLCBzdWNoXHJcbi8vIGFzIHdhcm5pbmcgdGhhdCBXb3JrZXJzIHdlcmUgZGlzYWJsZWQsIHdoaWNoIGlzIGltcG9ydGFudCB0byBkZXZzIGJ1dCBub3RcclxuLy8gZW5kIHVzZXJzLlxyXG5mdW5jdGlvbiBpbmZvKG1zZykge1xyXG4gIGlmIChQREZKUy52ZXJib3NpdHkgPj0gUERGSlMuVkVSQk9TSVRZX0xFVkVMUy5pbmZvcykge1xyXG4gICAgY29uc29sZS5sb2coJ0luZm86ICcgKyBtc2cpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gTm9uLWZhdGFsIHdhcm5pbmdzLlxyXG5mdW5jdGlvbiB3YXJuKG1zZykge1xyXG4gIGlmIChQREZKUy52ZXJib3NpdHkgPj0gUERGSlMuVkVSQk9TSVRZX0xFVkVMUy53YXJuaW5ncykge1xyXG4gICAgY29uc29sZS5sb2coJ1dhcm5pbmc6ICcgKyBtc2cpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRmF0YWwgZXJyb3JzIHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGZhbGxiYWNrIFVJIGFuZCBoYWx0IGV4ZWN1dGlvbiBieVxyXG4vLyB0aHJvd2luZyBhbiBleGNlcHRpb24uXHJcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xyXG4gIC8vIElmIG11bHRpcGxlIGFyZ3VtZW50cyB3ZXJlIHBhc3NlZCwgcGFzcyB0aGVtIGFsbCB0byB0aGUgbG9nIGZ1bmN0aW9uLlxyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgdmFyIGxvZ0FyZ3VtZW50cyA9IFsnRXJyb3I6J107XHJcbiAgICBsb2dBcmd1bWVudHMucHVzaC5hcHBseShsb2dBcmd1bWVudHMsIGFyZ3VtZW50cyk7XHJcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBsb2dBcmd1bWVudHMpO1xyXG4gICAgLy8gSm9pbiB0aGUgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgc3RyaW5nIGZvciB0aGUgbGluZXMgYmVsb3cuXHJcbiAgICBtc2cgPSBbXS5qb2luLmNhbGwoYXJndW1lbnRzLCAnICcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLmxvZygnRXJyb3I6ICcgKyBtc2cpO1xyXG4gIH1cclxuICBjb25zb2xlLmxvZyhiYWNrdHJhY2UoKSk7XHJcbiAgVW5zdXBwb3J0ZWRNYW5hZ2VyLm5vdGlmeShVTlNVUFBPUlRFRF9GRUFUVVJFUy51bmtub3duKTtcclxuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYmFja3RyYWNlKCkge1xyXG4gIHRyeSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZS5zdGFjayA/IGUuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDIpLmpvaW4oJ1xcbicpIDogJyc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XHJcbiAgaWYgKCFjb25kKSB7XHJcbiAgICBlcnJvcihtc2cpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIFVOU1VQUE9SVEVEX0ZFQVRVUkVTID0gUERGSlMuVU5TVVBQT1JURURfRkVBVFVSRVMgPSB7XHJcbiAgdW5rbm93bjogJ3Vua25vd24nLFxyXG4gIGZvcm1zOiAnZm9ybXMnLFxyXG4gIGphdmFTY3JpcHQ6ICdqYXZhU2NyaXB0JyxcclxuICBzbWFzazogJ3NtYXNrJyxcclxuICBzaGFkaW5nUGF0dGVybjogJ3NoYWRpbmdQYXR0ZXJuJyxcclxuICBmb250OiAnZm9udCdcclxufTtcclxuXHJcbnZhciBVbnN1cHBvcnRlZE1hbmFnZXIgPSBQREZKUy5VbnN1cHBvcnRlZE1hbmFnZXIgPVxyXG4gIChmdW5jdGlvbiBVbnN1cHBvcnRlZE1hbmFnZXJDbG9zdXJlKCkge1xyXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcclxuICByZXR1cm4ge1xyXG4gICAgbGlzdGVuOiBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgbGlzdGVuZXJzLnB1c2goY2IpO1xyXG4gICAgfSxcclxuICAgIG5vdGlmeTogZnVuY3Rpb24gKGZlYXR1cmVJZCkge1xyXG4gICAgICB3YXJuKCdVbnN1cHBvcnRlZCBmZWF0dXJlIFwiJyArIGZlYXR1cmVJZCArICdcIicpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgIGxpc3RlbmVyc1tpXShmZWF0dXJlSWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbi8vIENvbWJpbmVzIHR3byBVUkxzLiBUaGUgYmFzZVVybCBzaGFsbCBiZSBhYnNvbHV0ZSBVUkwuIElmIHRoZSB1cmwgaXMgYW5cclxuLy8gYWJzb2x1dGUgVVJMLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGlzLlxyXG5mdW5jdGlvbiBjb21iaW5lVXJsKGJhc2VVcmwsIHVybCkge1xyXG4gIGlmICghdXJsKSB7XHJcbiAgICByZXR1cm4gYmFzZVVybDtcclxuICB9XHJcbiAgaWYgKC9eW2Etel1bYS16MC05K1xcLS5dKjovaS50ZXN0KHVybCkpIHtcclxuICAgIHJldHVybiB1cmw7XHJcbiAgfVxyXG4gIHZhciBpO1xyXG4gIGlmICh1cmwuY2hhckF0KDApID09PSAnLycpIHtcclxuICAgIC8vIGFic29sdXRlIHBhdGhcclxuICAgIGkgPSBiYXNlVXJsLmluZGV4T2YoJzovLycpO1xyXG4gICAgaWYgKHVybC5jaGFyQXQoMSkgPT09ICcvJykge1xyXG4gICAgICArK2k7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpID0gYmFzZVVybC5pbmRleE9mKCcvJywgaSArIDMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJhc2VVcmwuc3Vic3RyaW5nKDAsIGkpICsgdXJsO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyByZWxhdGl2ZSBwYXRoXHJcbiAgICB2YXIgcGF0aExlbmd0aCA9IGJhc2VVcmwubGVuZ3RoO1xyXG4gICAgaSA9IGJhc2VVcmwubGFzdEluZGV4T2YoJyMnKTtcclxuICAgIHBhdGhMZW5ndGggPSBpID49IDAgPyBpIDogcGF0aExlbmd0aDtcclxuICAgIGkgPSBiYXNlVXJsLmxhc3RJbmRleE9mKCc/JywgcGF0aExlbmd0aCk7XHJcbiAgICBwYXRoTGVuZ3RoID0gaSA+PSAwID8gaSA6IHBhdGhMZW5ndGg7XHJcbiAgICB2YXIgcHJlZml4TGVuZ3RoID0gYmFzZVVybC5sYXN0SW5kZXhPZignLycsIHBhdGhMZW5ndGgpO1xyXG4gICAgcmV0dXJuIGJhc2VVcmwuc3Vic3RyaW5nKDAsIHByZWZpeExlbmd0aCArIDEpICsgdXJsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVmFsaWRhdGVzIGlmIFVSTCBpcyBzYWZlIGFuZCBhbGxvd2VkLCBlLmcuIHRvIGF2b2lkIFhTUy5cclxuZnVuY3Rpb24gaXNWYWxpZFVybCh1cmwsIGFsbG93UmVsYXRpdmUpIHtcclxuICBpZiAoIXVybCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvLyBSRkMgMzk4NiAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMSlcclxuICAvLyBzY2hlbWUgPSBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcclxuICB2YXIgcHJvdG9jb2wgPSAvXlthLXpdW2EtejAtOStcXC0uXSooPz06KS9pLmV4ZWModXJsKTtcclxuICBpZiAoIXByb3RvY29sKSB7XHJcbiAgICByZXR1cm4gYWxsb3dSZWxhdGl2ZTtcclxuICB9XHJcbiAgcHJvdG9jb2wgPSBwcm90b2NvbFswXS50b0xvd2VyQ2FzZSgpO1xyXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcclxuICAgIGNhc2UgJ2h0dHAnOlxyXG4gICAgY2FzZSAnaHR0cHMnOlxyXG4gICAgY2FzZSAnZnRwJzpcclxuICAgIGNhc2UgJ21haWx0byc6XHJcbiAgICBjYXNlICd0ZWwnOlxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuUERGSlMuaXNWYWxpZFVybCA9IGlzVmFsaWRVcmw7XHJcblxyXG5mdW5jdGlvbiBzaGFkb3cob2JqLCBwcm9wLCB2YWx1ZSkge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHsgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSB9KTtcclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuUERGSlMuc2hhZG93ID0gc2hhZG93O1xyXG5cclxudmFyIFBhc3N3b3JkUmVzcG9uc2VzID0gUERGSlMuUGFzc3dvcmRSZXNwb25zZXMgPSB7XHJcbiAgTkVFRF9QQVNTV09SRDogMSxcclxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcclxufTtcclxuXHJcbnZhciBQYXNzd29yZEV4Y2VwdGlvbiA9IChmdW5jdGlvbiBQYXNzd29yZEV4Y2VwdGlvbkNsb3N1cmUoKSB7XHJcbiAgZnVuY3Rpb24gUGFzc3dvcmRFeGNlcHRpb24obXNnLCBjb2RlKSB7XHJcbiAgICB0aGlzLm5hbWUgPSAnUGFzc3dvcmRFeGNlcHRpb24nO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xyXG4gICAgdGhpcy5jb2RlID0gY29kZTtcclxuICB9XHJcblxyXG4gIFBhc3N3b3JkRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG4gIFBhc3N3b3JkRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gUGFzc3dvcmRFeGNlcHRpb247XHJcblxyXG4gIHJldHVybiBQYXNzd29yZEV4Y2VwdGlvbjtcclxufSkoKTtcclxuUERGSlMuUGFzc3dvcmRFeGNlcHRpb24gPSBQYXNzd29yZEV4Y2VwdGlvbjtcclxuXHJcbnZhciBVbmtub3duRXJyb3JFeGNlcHRpb24gPSAoZnVuY3Rpb24gVW5rbm93bkVycm9yRXhjZXB0aW9uQ2xvc3VyZSgpIHtcclxuICBmdW5jdGlvbiBVbmtub3duRXJyb3JFeGNlcHRpb24obXNnLCBkZXRhaWxzKSB7XHJcbiAgICB0aGlzLm5hbWUgPSAnVW5rbm93bkVycm9yRXhjZXB0aW9uJztcclxuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcclxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XHJcbiAgfVxyXG5cclxuICBVbmtub3duRXJyb3JFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcbiAgVW5rbm93bkVycm9yRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gVW5rbm93bkVycm9yRXhjZXB0aW9uO1xyXG5cclxuICByZXR1cm4gVW5rbm93bkVycm9yRXhjZXB0aW9uO1xyXG59KSgpO1xyXG5QREZKUy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBVbmtub3duRXJyb3JFeGNlcHRpb247XHJcblxyXG52YXIgSW52YWxpZFBERkV4Y2VwdGlvbiA9IChmdW5jdGlvbiBJbnZhbGlkUERGRXhjZXB0aW9uQ2xvc3VyZSgpIHtcclxuICBmdW5jdGlvbiBJbnZhbGlkUERGRXhjZXB0aW9uKG1zZykge1xyXG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRQREZFeGNlcHRpb24nO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xyXG4gIH1cclxuXHJcbiAgSW52YWxpZFBERkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuICBJbnZhbGlkUERGRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gSW52YWxpZFBERkV4Y2VwdGlvbjtcclxuXHJcbiAgcmV0dXJuIEludmFsaWRQREZFeGNlcHRpb247XHJcbn0pKCk7XHJcblBERkpTLkludmFsaWRQREZFeGNlcHRpb24gPSBJbnZhbGlkUERGRXhjZXB0aW9uO1xyXG5cclxudmFyIE1pc3NpbmdQREZFeGNlcHRpb24gPSAoZnVuY3Rpb24gTWlzc2luZ1BERkV4Y2VwdGlvbkNsb3N1cmUoKSB7XHJcbiAgZnVuY3Rpb24gTWlzc2luZ1BERkV4Y2VwdGlvbihtc2cpIHtcclxuICAgIHRoaXMubmFtZSA9ICdNaXNzaW5nUERGRXhjZXB0aW9uJztcclxuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcclxuICB9XHJcblxyXG4gIE1pc3NpbmdQREZFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcbiAgTWlzc2luZ1BERkV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IE1pc3NpbmdQREZFeGNlcHRpb247XHJcblxyXG4gIHJldHVybiBNaXNzaW5nUERGRXhjZXB0aW9uO1xyXG59KSgpO1xyXG5QREZKUy5NaXNzaW5nUERGRXhjZXB0aW9uID0gTWlzc2luZ1BERkV4Y2VwdGlvbjtcclxuXHJcbnZhciBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPVxyXG4gICAgKGZ1bmN0aW9uIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XHJcbiAgZnVuY3Rpb24gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKG1zZywgc3RhdHVzKSB7XHJcbiAgICB0aGlzLm5hbWUgPSAnVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uJztcclxuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcclxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xyXG4gIH1cclxuXHJcbiAgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG4gIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcclxuXHJcbiAgcmV0dXJuIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcclxufSkoKTtcclxuUERGSlMuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xyXG5cclxudmFyIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uQ2xvc3VyZSgpIHtcclxuICBmdW5jdGlvbiBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbihtc2cpIHtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcclxuICB9XHJcblxyXG4gIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG4gIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ05vdEltcGxlbWVudGVkRXhjZXB0aW9uJztcclxuICBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IE5vdEltcGxlbWVudGVkRXhjZXB0aW9uO1xyXG5cclxuICByZXR1cm4gTm90SW1wbGVtZW50ZWRFeGNlcHRpb247XHJcbn0pKCk7XHJcblxyXG52YXIgTWlzc2luZ0RhdGFFeGNlcHRpb24gPSAoZnVuY3Rpb24gTWlzc2luZ0RhdGFFeGNlcHRpb25DbG9zdXJlKCkge1xyXG4gIGZ1bmN0aW9uIE1pc3NpbmdEYXRhRXhjZXB0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgIHRoaXMuYmVnaW4gPSBiZWdpbjtcclxuICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gJ01pc3NpbmcgZGF0YSBbJyArIGJlZ2luICsgJywgJyArIGVuZCArICcpJztcclxuICB9XHJcblxyXG4gIE1pc3NpbmdEYXRhRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG4gIE1pc3NpbmdEYXRhRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ01pc3NpbmdEYXRhRXhjZXB0aW9uJztcclxuICBNaXNzaW5nRGF0YUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IE1pc3NpbmdEYXRhRXhjZXB0aW9uO1xyXG5cclxuICByZXR1cm4gTWlzc2luZ0RhdGFFeGNlcHRpb247XHJcbn0pKCk7XHJcblxyXG52YXIgWFJlZlBhcnNlRXhjZXB0aW9uID0gKGZ1bmN0aW9uIFhSZWZQYXJzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XHJcbiAgZnVuY3Rpb24gWFJlZlBhcnNlRXhjZXB0aW9uKG1zZykge1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xyXG4gIH1cclxuXHJcbiAgWFJlZlBhcnNlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG4gIFhSZWZQYXJzZUV4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdYUmVmUGFyc2VFeGNlcHRpb24nO1xyXG4gIFhSZWZQYXJzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IFhSZWZQYXJzZUV4Y2VwdGlvbjtcclxuXHJcbiAgcmV0dXJuIFhSZWZQYXJzZUV4Y2VwdGlvbjtcclxufSkoKTtcclxuXHJcblxyXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XHJcbiAgYXNzZXJ0KGJ5dGVzICE9PSBudWxsICYmIHR5cGVvZiBieXRlcyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgYnl0ZXMubGVuZ3RoICE9PSB1bmRlZmluZWQsICdJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nJyk7XHJcbiAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcclxuICB2YXIgTUFYX0FSR1VNRU5UX0NPVU5UID0gODE5MjtcclxuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XHJcbiAgfVxyXG4gIHZhciBzdHJCdWYgPSBbXTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcclxuICAgIHZhciBjaHVua0VuZCA9IE1hdGgubWluKGkgKyBNQVhfQVJHVU1FTlRfQ09VTlQsIGxlbmd0aCk7XHJcbiAgICB2YXIgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBjaHVua0VuZCk7XHJcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XHJcbiAgfVxyXG4gIHJldHVybiBzdHJCdWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XHJcbiAgYXNzZXJ0KHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBhcmd1bWVudCBmb3Igc3RyaW5nVG9CeXRlcycpO1xyXG4gIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoO1xyXG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XHJcbiAgfVxyXG4gIHJldHVybiBieXRlcztcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcclxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgodmFsdWUgPj4gMjQpICYgMHhmZiwgKHZhbHVlID4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlID4+IDgpICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9nMih4KSB7XHJcbiAgdmFyIG4gPSAxLCBpID0gMDtcclxuICB3aGlsZSAoeCA+IG4pIHtcclxuICAgIG4gPDw9IDE7XHJcbiAgICBpKys7XHJcbiAgfVxyXG4gIHJldHVybiBpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkSW50OChkYXRhLCBzdGFydCkge1xyXG4gIHJldHVybiAoZGF0YVtzdGFydF0gPDwgMjQpID4+IDI0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludDE2KGRhdGEsIG9mZnNldCkge1xyXG4gIHJldHVybiAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpIHtcclxuICByZXR1cm4gKChkYXRhW29mZnNldF0gPDwgMjQpIHwgKGRhdGFbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcclxuICAgICAgICAgKGRhdGFbb2Zmc2V0ICsgMl0gPDwgOCkgfCBkYXRhW29mZnNldCArIDNdKSA+Pj4gMDtcclxufVxyXG5cclxuLy8gTGF6eSB0ZXN0IHRoZSBlbmRpYW5uZXNzIG9mIHRoZSBwbGF0Zm9ybVxyXG4vLyBOT1RFOiBUaGlzIHdpbGwgYmUgJ3RydWUnIGZvciBzaW11bGF0ZWQgVHlwZWRBcnJheXNcclxuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XHJcbiAgdmFyIGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSgyKTtcclxuICBidWZmZXI4WzBdID0gMTtcclxuICB2YXIgYnVmZmVyMTYgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyOC5idWZmZXIpO1xyXG4gIHJldHVybiAoYnVmZmVyMTZbMF0gPT09IDEpO1xyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUERGSlMsICdpc0xpdHRsZUVuZGlhbicsIHtcclxuICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBQREZKU19pc0xpdHRsZUVuZGlhbigpIHtcclxuICAgIHJldHVybiBzaGFkb3coUERGSlMsICdpc0xpdHRsZUVuZGlhbicsIGlzTGl0dGxlRW5kaWFuKCkpO1xyXG4gIH1cclxufSk7XHJcblxyXG4vLyNpZiAhKEZJUkVGT1ggfHwgTU9aQ0VOVFJBTCB8fCBCMkcgfHwgQ0hST01FKVxyXG4vLy8vIExhenkgdGVzdCBpZiB0aGUgdXNlckFnYW50IHN1cHBvcnQgQ2FudmFzVHlwZWRBcnJheXNcclxuZnVuY3Rpb24gaGFzQ2FudmFzVHlwZWRBcnJheXMoKSB7XHJcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xyXG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICB2YXIgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKTtcclxuICByZXR1cm4gKHR5cGVvZiBpbWFnZURhdGEuZGF0YS5idWZmZXIgIT09ICd1bmRlZmluZWQnKTtcclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBERkpTLCAnaGFzQ2FudmFzVHlwZWRBcnJheXMnLCB7XHJcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gUERGSlNfaGFzQ2FudmFzVHlwZWRBcnJheXMoKSB7XHJcbiAgICByZXR1cm4gc2hhZG93KFBERkpTLCAnaGFzQ2FudmFzVHlwZWRBcnJheXMnLCBoYXNDYW52YXNUeXBlZEFycmF5cygpKTtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIFVpbnQzMkFycmF5VmlldyA9IChmdW5jdGlvbiBVaW50MzJBcnJheVZpZXdDbG9zdXJlKCkge1xyXG5cclxuICBmdW5jdGlvbiBVaW50MzJBcnJheVZpZXcoYnVmZmVyLCBsZW5ndGgpIHtcclxuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcclxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyAodGhpcy5ieXRlTGVuZ3RoID4+IDIpIDogbGVuZ3RoO1xyXG4gICAgZW5zdXJlVWludDMyQXJyYXlWaWV3UHJvcHModGhpcy5sZW5ndGgpO1xyXG4gIH1cclxuICBVaW50MzJBcnJheVZpZXcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgdmFyIHVpbnQzMkFycmF5Vmlld1NldHRlcnMgPSAwO1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZVVpbnQzMkFycmF5UHJvcChpbmRleCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLCBvZmZzZXQgPSBpbmRleCA8PCAyO1xyXG4gICAgICAgIHJldHVybiAoYnVmZmVyW29mZnNldF0gfCAoYnVmZmVyW29mZnNldCArIDFdIDw8IDgpIHxcclxuICAgICAgICAgIChidWZmZXJbb2Zmc2V0ICsgMl0gPDwgMTYpIHwgKGJ1ZmZlcltvZmZzZXQgKyAzXSA8PCAyNCkpID4+PiAwO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlciwgb2Zmc2V0ID0gaW5kZXggPDwgMjtcclxuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlICYgMjU1O1xyXG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+PiA4KSAmIDI1NTtcclxuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4gMTYpICYgMjU1O1xyXG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMjU1O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW5zdXJlVWludDMyQXJyYXlWaWV3UHJvcHMobGVuZ3RoKSB7XHJcbiAgICB3aGlsZSAodWludDMyQXJyYXlWaWV3U2V0dGVycyA8IGxlbmd0aCkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDMyQXJyYXlWaWV3LnByb3RvdHlwZSxcclxuICAgICAgICB1aW50MzJBcnJheVZpZXdTZXR0ZXJzLFxyXG4gICAgICAgIGNyZWF0ZVVpbnQzMkFycmF5UHJvcCh1aW50MzJBcnJheVZpZXdTZXR0ZXJzKSk7XHJcbiAgICAgIHVpbnQzMkFycmF5Vmlld1NldHRlcnMrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBVaW50MzJBcnJheVZpZXc7XHJcbn0pKCk7XHJcbi8vI2Vsc2VcclxuLy9QREZKUy5oYXNDYW52YXNUeXBlZEFycmF5cyA9IHRydWU7XHJcbi8vI2VuZGlmXHJcblxyXG52YXIgSURFTlRJVFlfTUFUUklYID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xyXG5cclxudmFyIFV0aWwgPSBQREZKUy5VdGlsID0gKGZ1bmN0aW9uIFV0aWxDbG9zdXJlKCkge1xyXG4gIGZ1bmN0aW9uIFV0aWwoKSB7fVxyXG5cclxuICB2YXIgcmdiQnVmID0gWydyZ2IoJywgMCwgJywnLCAwLCAnLCcsIDAsICcpJ107XHJcblxyXG4gIC8vIG1ha2VDc3NSZ2IoKSBjYW4gYmUgY2FsbGVkIHRob3VzYW5kcyBvZiB0aW1lcy4gVXNpbmcgfHJnYkJ1ZnwgYXZvaWRzXHJcbiAgLy8gY3JlYXRpbmcgbWFueSBpbnRlcm1lZGlhdGUgc3RyaW5ncy5cclxuICBVdGlsLm1ha2VDc3NSZ2IgPSBmdW5jdGlvbiBVdGlsX21ha2VDc3NSZ2IociwgZywgYikge1xyXG4gICAgcmdiQnVmWzFdID0gcjtcclxuICAgIHJnYkJ1ZlszXSA9IGc7XHJcbiAgICByZ2JCdWZbNV0gPSBiO1xyXG4gICAgcmV0dXJuIHJnYkJ1Zi5qb2luKCcnKTtcclxuICB9O1xyXG5cclxuICAvLyBDb25jYXRlbmF0ZXMgdHdvIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIHRvZ2V0aGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAgVXRpbC50cmFuc2Zvcm0gPSBmdW5jdGlvbiBVdGlsX3RyYW5zZm9ybShtMSwgbTIpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdLFxyXG4gICAgICBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXSxcclxuICAgICAgbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM10sXHJcbiAgICAgIG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdLFxyXG4gICAgICBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdLFxyXG4gICAgICBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdXHJcbiAgICBdO1xyXG4gIH07XHJcblxyXG4gIC8vIEZvciAyZCBhZmZpbmUgdHJhbnNmb3Jtc1xyXG4gIFV0aWwuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiBVdGlsX2FwcGx5VHJhbnNmb3JtKHAsIG0pIHtcclxuICAgIHZhciB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xyXG4gICAgdmFyIHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XHJcbiAgICByZXR1cm4gW3h0LCB5dF07XHJcbiAgfTtcclxuXHJcbiAgVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBVdGlsX2FwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCBtKSB7XHJcbiAgICB2YXIgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XHJcbiAgICB2YXIgeHQgPSAocFswXSAqIG1bM10gLSBwWzFdICogbVsyXSArIG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZDtcclxuICAgIHZhciB5dCA9ICgtcFswXSAqIG1bMV0gKyBwWzFdICogbVswXSArIG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZDtcclxuICAgIHJldHVybiBbeHQsIHl0XTtcclxuICB9O1xyXG5cclxuICAvLyBBcHBsaWVzIHRoZSB0cmFuc2Zvcm0gdG8gdGhlIHJlY3RhbmdsZSBhbmQgZmluZHMgdGhlIG1pbmltdW0gYXhpYWxseVxyXG4gIC8vIGFsaWduZWQgYm91bmRpbmcgYm94LlxyXG4gIFV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3ggPVxyXG4gICAgZnVuY3Rpb24gVXRpbF9nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChyLCBtKSB7XHJcblxyXG4gICAgdmFyIHAxID0gVXRpbC5hcHBseVRyYW5zZm9ybShyLCBtKTtcclxuICAgIHZhciBwMiA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oci5zbGljZSgyLCA0KSwgbSk7XHJcbiAgICB2YXIgcDMgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyWzBdLCByWzNdXSwgbSk7XHJcbiAgICB2YXIgcDQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyWzJdLCByWzFdXSwgbSk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksXHJcbiAgICAgIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSxcclxuICAgICAgTWF0aC5tYXgocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLFxyXG4gICAgICBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSlcclxuICAgIF07XHJcbiAgfTtcclxuXHJcbiAgVXRpbC5pbnZlcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF9pbnZlcnNlVHJhbnNmb3JtKG0pIHtcclxuICAgIHZhciBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcclxuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCxcclxuICAgICAgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XHJcbiAgfTtcclxuXHJcbiAgLy8gQXBwbHkgYSBnZW5lcmljIDNkIG1hdHJpeCBNIG9uIGEgMy12ZWN0b3IgdjpcclxuICAvLyAgIHwgYSBiIGMgfCAgIHwgWCB8XHJcbiAgLy8gICB8IGQgZSBmIHwgeCB8IFkgfFxyXG4gIC8vICAgfCBnIGggaSB8ICAgfCBaIHxcclxuICAvLyBNIGlzIGFzc3VtZWQgdG8gYmUgc2VyaWFsaXplZCBhcyBbYSxiLGMsZCxlLGYsZyxoLGldLFxyXG4gIC8vIHdpdGggdiBhcyBbWCxZLFpdXHJcbiAgVXRpbC5hcHBseTNkVHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF9hcHBseTNkVHJhbnNmb3JtKG0sIHYpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIG1bMF0gKiB2WzBdICsgbVsxXSAqIHZbMV0gKyBtWzJdICogdlsyXSxcclxuICAgICAgbVszXSAqIHZbMF0gKyBtWzRdICogdlsxXSArIG1bNV0gKiB2WzJdLFxyXG4gICAgICBtWzZdICogdlswXSArIG1bN10gKiB2WzFdICsgbVs4XSAqIHZbMl1cclxuICAgIF07XHJcbiAgfTtcclxuXHJcbiAgLy8gVGhpcyBjYWxjdWxhdGlvbiB1c2VzIFNpbmd1bGFyIFZhbHVlIERlY29tcG9zaXRpb24uXHJcbiAgLy8gVGhlIFNWRCBjYW4gYmUgcmVwcmVzZW50ZWQgd2l0aCBmb3JtdWxhIEEgPSBVU1YuIFdlIGFyZSBpbnRlcmVzdGVkIGluIHRoZVxyXG4gIC8vIG1hdHJpeCBTIGhlcmUgYmVjYXVzZSBpdCByZXByZXNlbnRzIHRoZSBzY2FsZSB2YWx1ZXMuXHJcbiAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSA9XHJcbiAgICBmdW5jdGlvbiBVdGlsX3Npbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG0pIHtcclxuXHJcbiAgICB2YXIgdHJhbnNwb3NlID0gW21bMF0sIG1bMl0sIG1bMV0sIG1bM11dO1xyXG5cclxuICAgIC8vIE11bHRpcGx5IG1hdHJpeCBtIHdpdGggaXRzIHRyYW5zcG9zZS5cclxuICAgIHZhciBhID0gbVswXSAqIHRyYW5zcG9zZVswXSArIG1bMV0gKiB0cmFuc3Bvc2VbMl07XHJcbiAgICB2YXIgYiA9IG1bMF0gKiB0cmFuc3Bvc2VbMV0gKyBtWzFdICogdHJhbnNwb3NlWzNdO1xyXG4gICAgdmFyIGMgPSBtWzJdICogdHJhbnNwb3NlWzBdICsgbVszXSAqIHRyYW5zcG9zZVsyXTtcclxuICAgIHZhciBkID0gbVsyXSAqIHRyYW5zcG9zZVsxXSArIG1bM10gKiB0cmFuc3Bvc2VbM107XHJcblxyXG4gICAgLy8gU29sdmUgdGhlIHNlY29uZCBkZWdyZWUgcG9seW5vbWlhbCB0byBnZXQgcm9vdHMuXHJcbiAgICB2YXIgZmlyc3QgPSAoYSArIGQpIC8gMjtcclxuICAgIHZhciBzZWNvbmQgPSBNYXRoLnNxcnQoKGEgKyBkKSAqIChhICsgZCkgLSA0ICogKGEgKiBkIC0gYyAqIGIpKSAvIDI7XHJcbiAgICB2YXIgc3ggPSBmaXJzdCArIHNlY29uZCB8fCAxO1xyXG4gICAgdmFyIHN5ID0gZmlyc3QgLSBzZWNvbmQgfHwgMTtcclxuXHJcbiAgICAvLyBTY2FsZSB2YWx1ZXMgYXJlIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGVpZ2VudmFsdWVzLlxyXG4gICAgcmV0dXJuIFtNYXRoLnNxcnQoc3gpLCBNYXRoLnNxcnQoc3kpXTtcclxuICB9O1xyXG5cclxuICAvLyBOb3JtYWxpemUgcmVjdGFuZ2xlIHJlY3Q9W3gxLCB5MSwgeDIsIHkyXSBzbyB0aGF0ICh4MSx5MSkgPCAoeDIseTIpXHJcbiAgLy8gRm9yIGNvb3JkaW5hdGUgc3lzdGVtcyB3aG9zZSBvcmlnaW4gbGllcyBpbiB0aGUgYm90dG9tLWxlZnQsIHRoaXNcclxuICAvLyBtZWFucyBub3JtYWxpemF0aW9uIHRvIChCTCxUUikgb3JkZXJpbmcuIEZvciBzeXN0ZW1zIHdpdGggb3JpZ2luIGluIHRoZVxyXG4gIC8vIHRvcC1sZWZ0LCB0aGlzIG1lYW5zIChUTCxCUikgb3JkZXJpbmcuXHJcbiAgVXRpbC5ub3JtYWxpemVSZWN0ID0gZnVuY3Rpb24gVXRpbF9ub3JtYWxpemVSZWN0KHJlY3QpIHtcclxuICAgIHZhciByID0gcmVjdC5zbGljZSgwKTsgLy8gY2xvbmUgcmVjdFxyXG4gICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XHJcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xyXG4gICAgICByWzJdID0gcmVjdFswXTtcclxuICAgIH1cclxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xyXG4gICAgICByWzFdID0gcmVjdFszXTtcclxuICAgICAgclszXSA9IHJlY3RbMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcjtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIFt4MSwgeTEsIHgyLCB5Ml0gY29ycmVzcG9uZGluZyB0byB0aGVcclxuICAvLyBpbnRlcnNlY3Rpb24gb2YgcmVjdDEgYW5kIHJlY3QyLiBJZiBubyBpbnRlcnNlY3Rpb24sIHJldHVybnMgJ2ZhbHNlJ1xyXG4gIC8vIFRoZSByZWN0YW5nbGUgY29vcmRpbmF0ZXMgb2YgcmVjdDEsIHJlY3QyIHNob3VsZCBiZSBbeDEsIHkxLCB4MiwgeTJdXHJcbiAgVXRpbC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBVdGlsX2ludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcclxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xyXG4gICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3JkZXIgcG9pbnRzIGFsb25nIHRoZSBheGVzXHJcbiAgICB2YXIgb3JkZXJlZFggPSBbcmVjdDFbMF0sIHJlY3QxWzJdLCByZWN0MlswXSwgcmVjdDJbMl1dLnNvcnQoY29tcGFyZSksXHJcbiAgICAgICAgb3JkZXJlZFkgPSBbcmVjdDFbMV0sIHJlY3QxWzNdLCByZWN0MlsxXSwgcmVjdDJbM11dLnNvcnQoY29tcGFyZSksXHJcbiAgICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gICAgcmVjdDEgPSBVdGlsLm5vcm1hbGl6ZVJlY3QocmVjdDEpO1xyXG4gICAgcmVjdDIgPSBVdGlsLm5vcm1hbGl6ZVJlY3QocmVjdDIpO1xyXG5cclxuICAgIC8vIFg6IGZpcnN0IGFuZCBzZWNvbmQgcG9pbnRzIGJlbG9uZyB0byBkaWZmZXJlbnQgcmVjdGFuZ2xlcz9cclxuICAgIGlmICgob3JkZXJlZFhbMF0gPT09IHJlY3QxWzBdICYmIG9yZGVyZWRYWzFdID09PSByZWN0MlswXSkgfHxcclxuICAgICAgICAob3JkZXJlZFhbMF0gPT09IHJlY3QyWzBdICYmIG9yZGVyZWRYWzFdID09PSByZWN0MVswXSkpIHtcclxuICAgICAgLy8gSW50ZXJzZWN0aW9uIG11c3QgYmUgYmV0d2VlbiBzZWNvbmQgYW5kIHRoaXJkIHBvaW50c1xyXG4gICAgICByZXN1bHRbMF0gPSBvcmRlcmVkWFsxXTtcclxuICAgICAgcmVzdWx0WzJdID0gb3JkZXJlZFhbMl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gWTogZmlyc3QgYW5kIHNlY29uZCBwb2ludHMgYmVsb25nIHRvIGRpZmZlcmVudCByZWN0YW5nbGVzP1xyXG4gICAgaWYgKChvcmRlcmVkWVswXSA9PT0gcmVjdDFbMV0gJiYgb3JkZXJlZFlbMV0gPT09IHJlY3QyWzFdKSB8fFxyXG4gICAgICAgIChvcmRlcmVkWVswXSA9PT0gcmVjdDJbMV0gJiYgb3JkZXJlZFlbMV0gPT09IHJlY3QxWzFdKSkge1xyXG4gICAgICAvLyBJbnRlcnNlY3Rpb24gbXVzdCBiZSBiZXR3ZWVuIHNlY29uZCBhbmQgdGhpcmQgcG9pbnRzXHJcbiAgICAgIHJlc3VsdFsxXSA9IG9yZGVyZWRZWzFdO1xyXG4gICAgICByZXN1bHRbM10gPSBvcmRlcmVkWVsyXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIFV0aWwuc2lnbiA9IGZ1bmN0aW9uIFV0aWxfc2lnbihudW0pIHtcclxuICAgIHJldHVybiBudW0gPCAwID8gLTEgOiAxO1xyXG4gIH07XHJcblxyXG4gIFV0aWwuYXBwZW5kVG9BcnJheSA9IGZ1bmN0aW9uIFV0aWxfYXBwZW5kVG9BcnJheShhcnIxLCBhcnIyKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnIxLCBhcnIyKTtcclxuICB9O1xyXG5cclxuICBVdGlsLnByZXBlbmRUb0FycmF5ID0gZnVuY3Rpb24gVXRpbF9wcmVwZW5kVG9BcnJheShhcnIxLCBhcnIyKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShhcnIxLCBhcnIyKTtcclxuICB9O1xyXG5cclxuICBVdGlsLmV4dGVuZE9iaiA9IGZ1bmN0aW9uIGV4dGVuZE9iaihvYmoxLCBvYmoyKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMikge1xyXG4gICAgICBvYmoxW2tleV0gPSBvYmoyW2tleV07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgVXRpbC5nZXRJbmhlcml0YWJsZVByb3BlcnR5ID0gZnVuY3Rpb24gVXRpbF9nZXRJbmhlcml0YWJsZVByb3BlcnR5KGRpY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUpIHtcclxuICAgIHdoaWxlIChkaWN0ICYmICFkaWN0LmhhcyhuYW1lKSkge1xyXG4gICAgICBkaWN0ID0gZGljdC5nZXQoJ1BhcmVudCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkaWN0KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpY3QuZ2V0KG5hbWUpO1xyXG4gIH07XHJcblxyXG4gIFV0aWwuaW5oZXJpdCA9IGZ1bmN0aW9uIFV0aWxfaW5oZXJpdChzdWIsIGJhc2UsIHByb3RvdHlwZSkge1xyXG4gICAgc3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZS5wcm90b3R5cGUpO1xyXG4gICAgc3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YjtcclxuICAgIGZvciAodmFyIHByb3AgaW4gcHJvdG90eXBlKSB7XHJcbiAgICAgIHN1Yi5wcm90b3R5cGVbcHJvcF0gPSBwcm90b3R5cGVbcHJvcF07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgVXRpbC5sb2FkU2NyaXB0ID0gZnVuY3Rpb24gVXRpbF9sb2FkU2NyaXB0KHNyYywgY2FsbGJhY2spIHtcclxuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgIHZhciBsb2FkZWQgPSBmYWxzZTtcclxuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYyk7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghbG9hZGVkKSB7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2FkZWQgPSB0cnVlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBVdGlsO1xyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIFBERiBwYWdlIHZpZXdwb3J0IGNyZWF0ZWQgYmFzZWQgb24gc2NhbGUsIHJvdGF0aW9uIGFuZCBvZmZzZXQuXHJcbiAqIEBjbGFzc1xyXG4gKiBAYWxpYXMgUERGSlMuUGFnZVZpZXdwb3J0XHJcbiAqL1xyXG52YXIgUGFnZVZpZXdwb3J0ID0gUERGSlMuUGFnZVZpZXdwb3J0ID0gKGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydENsb3N1cmUoKSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0gdmlld0JveCB7QXJyYXl9IHhNaW4sIHlNaW4sIHhNYXggYW5kIHlNYXggY29vcmRpbmF0ZXMuXHJcbiAgICogQHBhcmFtIHNjYWxlIHtudW1iZXJ9IHNjYWxlIG9mIHRoZSB2aWV3cG9ydC5cclxuICAgKiBAcGFyYW0gcm90YXRpb24ge251bWJlcn0gcm90YXRpb25zIG9mIHRoZSB2aWV3cG9ydCBpbiBkZWdyZWVzLlxyXG4gICAqIEBwYXJhbSBvZmZzZXRYIHtudW1iZXJ9IG9mZnNldCBYXHJcbiAgICogQHBhcmFtIG9mZnNldFkge251bWJlcn0gb2Zmc2V0IFlcclxuICAgKiBAcGFyYW0gZG9udEZsaXAge2Jvb2xlYW59IGlmIHRydWUsIGF4aXMgWSB3aWxsIG5vdCBiZSBmbGlwcGVkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydCh2aWV3Qm94LCBzY2FsZSwgcm90YXRpb24sIG9mZnNldFgsIG9mZnNldFksIGRvbnRGbGlwKSB7XHJcbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xyXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcclxuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XHJcblxyXG4gICAgLy8gY3JlYXRpbmcgdHJhbnNmb3JtIHRvIGNvbnZlcnQgcGRmIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHRoZSBub3JtYWxcclxuICAgIC8vIGNhbnZhcyBsaWtlIGNvb3JkaW5hdGVzIHRha2luZyBpbiBhY2NvdW50IHNjYWxlIGFuZCByb3RhdGlvblxyXG4gICAgdmFyIGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcclxuICAgIHZhciBjZW50ZXJZID0gKHZpZXdCb3hbM10gKyB2aWV3Qm94WzFdKSAvIDI7XHJcbiAgICB2YXIgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcclxuICAgIHJvdGF0aW9uID0gcm90YXRpb24gJSAzNjA7XHJcbiAgICByb3RhdGlvbiA9IHJvdGF0aW9uIDwgMCA/IHJvdGF0aW9uICsgMzYwIDogcm90YXRpb247XHJcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XHJcbiAgICAgIGNhc2UgMTgwOlxyXG4gICAgICAgIHJvdGF0ZUEgPSAtMTsgcm90YXRlQiA9IDA7IHJvdGF0ZUMgPSAwOyByb3RhdGVEID0gMTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA5MDpcclxuICAgICAgICByb3RhdGVBID0gMDsgcm90YXRlQiA9IDE7IHJvdGF0ZUMgPSAxOyByb3RhdGVEID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyNzA6XHJcbiAgICAgICAgcm90YXRlQSA9IDA7IHJvdGF0ZUIgPSAtMTsgcm90YXRlQyA9IC0xOyByb3RhdGVEID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgLy9jYXNlIDA6XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcm90YXRlQSA9IDE7IHJvdGF0ZUIgPSAwOyByb3RhdGVDID0gMDsgcm90YXRlRCA9IC0xO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkb250RmxpcCkge1xyXG4gICAgICByb3RhdGVDID0gLXJvdGF0ZUM7IHJvdGF0ZUQgPSAtcm90YXRlRDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWTtcclxuICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xyXG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcclxuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WDtcclxuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcclxuICAgICAgd2lkdGggPSBNYXRoLmFicyh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcclxuICAgICAgaGVpZ2h0ID0gTWF0aC5hYnModmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xyXG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRZO1xyXG4gICAgICB3aWR0aCA9IE1hdGguYWJzKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xyXG4gICAgICBoZWlnaHQgPSBNYXRoLmFicyh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcclxuICAgIH1cclxuICAgIC8vIGNyZWF0aW5nIHRyYW5zZm9ybSBmb3IgdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxyXG4gICAgLy8gdHJhbnNsYXRlKC1jZW50ZXJYLCAtY2VudGVyWSksIHJvdGF0ZSBhbmQgZmxpcCB2ZXJ0aWNhbGx5LFxyXG4gICAgLy8gc2NhbGUsIGFuZCB0cmFuc2xhdGUob2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWSlcclxuICAgIHRoaXMudHJhbnNmb3JtID0gW1xyXG4gICAgICByb3RhdGVBICogc2NhbGUsXHJcbiAgICAgIHJvdGF0ZUIgKiBzY2FsZSxcclxuICAgICAgcm90YXRlQyAqIHNjYWxlLFxyXG4gICAgICByb3RhdGVEICogc2NhbGUsXHJcbiAgICAgIG9mZnNldENhbnZhc1ggLSByb3RhdGVBICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlQyAqIHNjYWxlICogY2VudGVyWSxcclxuICAgICAgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXHJcbiAgICBdO1xyXG5cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgdGhpcy5mb250U2NhbGUgPSBzY2FsZTtcclxuICB9XHJcbiAgUGFnZVZpZXdwb3J0LnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgUERGSlMuUGFnZVZpZXdwb3J0LnByb3RvdHlwZSAqLyB7XHJcbiAgICAvKipcclxuICAgICAqIENsb25lcyB2aWV3cG9ydCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cclxuICAgICAqIEBwYXJhbSBhcmdzIHtPYmplY3R9IChvcHRpb25hbCkgSWYgc3BlY2lmaWVkLCBtYXkgY29udGFpbiB0aGUgJ3NjYWxlJyBvclxyXG4gICAgICogJ3JvdGF0aW9uJyBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgaW5cclxuICAgICAqIHRoZSBjbG9uZWQgdmlld3BvcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7UERGSlMuUGFnZVZpZXdwb3J0fSBDbG9uZWQgdmlld3BvcnQuXHJcbiAgICAgKi9cclxuICAgIGNsb25lOiBmdW5jdGlvbiBQYWdlVmlld1BvcnRfY2xvbmUoYXJncykge1xyXG4gICAgICBhcmdzID0gYXJncyB8fCB7fTtcclxuICAgICAgdmFyIHNjYWxlID0gJ3NjYWxlJyBpbiBhcmdzID8gYXJncy5zY2FsZSA6IHRoaXMuc2NhbGU7XHJcbiAgICAgIHZhciByb3RhdGlvbiA9ICdyb3RhdGlvbicgaW4gYXJncyA/IGFyZ3Mucm90YXRpb24gOiB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh0aGlzLnZpZXdCb3guc2xpY2UoKSwgc2NhbGUsIHJvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgYXJncy5kb250RmxpcCk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBQREYgcG9pbnQgdG8gdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGVzLiBGb3IgZXhhbXBsZXMsIHVzZWZ1bCBmb3JcclxuICAgICAqIGNvbnZlcnRpbmcgUERGIGxvY2F0aW9uIGludG8gY2FudmFzIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIHgge251bWJlcn0gWCBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHkge251bWJlcn0gWSBjb29yZGluYXRlLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHRoYXQgY29udGFpbnMgJ3gnIGFuZCAneScgcHJvcGVydGllcyBvZiB0aGVcclxuICAgICAqIHBvaW50IGluIHRoZSB2aWV3cG9ydCBjb29yZGluYXRlIHNwYWNlLlxyXG4gICAgICogQHNlZSB7QGxpbmsgY29udmVydFRvUGRmUG9pbnR9XHJcbiAgICAgKiBAc2VlIHtAbGluayBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgY29udmVydFRvVmlld3BvcnRQb2ludDogZnVuY3Rpb24gUGFnZVZpZXdwb3J0X2NvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCwgeSkge1xyXG4gICAgICByZXR1cm4gVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIFBERiByZWN0YW5nbGUgdG8gdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIHJlY3Qge0FycmF5fSB4TWluLCB5TWluLCB4TWF4IGFuZCB5TWF4IGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBDb250YWlucyBjb3JyZXNwb25kaW5nIGNvb3JkaW5hdGVzIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIGluIHRoZSB2aWV3cG9ydCBjb29yZGluYXRlIHNwYWNlLlxyXG4gICAgICogQHNlZSB7QGxpbmsgY29udmVydFRvVmlld3BvcnRQb2ludH1cclxuICAgICAqL1xyXG4gICAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGU6XHJcbiAgICAgIGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydF9jb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShyZWN0KSB7XHJcbiAgICAgIHZhciB0bCA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMF0sIHJlY3RbMV1dLCB0aGlzLnRyYW5zZm9ybSk7XHJcbiAgICAgIHZhciBiciA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMl0sIHJlY3RbM11dLCB0aGlzLnRyYW5zZm9ybSk7XHJcbiAgICAgIHJldHVybiBbdGxbMF0sIHRsWzFdLCBiclswXSwgYnJbMV1dO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gdGhlIFBERiBsb2NhdGlvbi4gRm9yIGV4YW1wbGVzLCB1c2VmdWxcclxuICAgICAqIGZvciBjb252ZXJ0aW5nIGNhbnZhcyBwaXhlbCBsb2NhdGlvbiBpbnRvIFBERiBvbmUuXHJcbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgdGhhdCBjb250YWlucyAneCcgYW5kICd5JyBwcm9wZXJ0aWVzIG9mIHRoZVxyXG4gICAgICogcG9pbnQgaW4gdGhlIFBERiBjb29yZGluYXRlIHNwYWNlLlxyXG4gICAgICogQHNlZSB7QGxpbmsgY29udmVydFRvVmlld3BvcnRQb2ludH1cclxuICAgICAqL1xyXG4gICAgY29udmVydFRvUGRmUG9pbnQ6IGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydF9jb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XHJcbiAgICAgIHJldHVybiBVdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBQYWdlVmlld3BvcnQ7XHJcbn0pKCk7XHJcblxyXG52YXIgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSBbXHJcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcclxuICAweDJEOCwgMHgyQzcsIDB4MkM2LCAweDJEOSwgMHgyREQsIDB4MkRCLCAweDJEQSwgMHgyREMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcclxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxyXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyMDIyLCAweDIwMjAsIDB4MjAyMSwgMHgyMDI2LCAweDIwMTQsXHJcbiAgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzQSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxRSwgMHgyMDFDLFxyXG4gIDB4MjAxRCwgMHgyMDE4LCAweDIwMTksIDB4MjAxQSwgMHgyMTIyLCAweEZCMDEsIDB4RkIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCxcclxuICAweDE3OCwgMHgxN0QsIDB4MTMxLCAweDE0MiwgMHgxNTMsIDB4MTYxLCAweDE3RSwgMCwgMHgyMEFDXHJcbl07XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcclxuICB2YXIgaSwgbiA9IHN0ci5sZW5ndGgsIHN0ckJ1ZiA9IFtdO1xyXG4gIGlmIChzdHJbMF0gPT09ICdcXHhGRScgJiYgc3RyWzFdID09PSAnXFx4RkYnKSB7XHJcbiAgICAvLyBVVEYxNkJFIEJPTVxyXG4gICAgZm9yIChpID0gMjsgaSA8IG47IGkgKz0gMikge1xyXG4gICAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKFxyXG4gICAgICAgIChzdHIuY2hhckNvZGVBdChpKSA8PCA4KSB8IHN0ci5jaGFyQ29kZUF0KGkgKyAxKSkpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIHZhciBjb2RlID0gUERGU3RyaW5nVHJhbnNsYXRlVGFibGVbc3RyLmNoYXJDb2RlQXQoaSldO1xyXG4gICAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RyQnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XHJcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNCb29sKHYpIHtcclxuICByZXR1cm4gdHlwZW9mIHYgPT09ICdib29sZWFuJztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNJbnQodikge1xyXG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcicgJiYgKCh2IHwgMCkgPT09IHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc051bSh2KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTdHJpbmcodikge1xyXG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZyc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTnVsbCh2KSB7XHJcbiAgcmV0dXJuIHYgPT09IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTmFtZSh2KSB7XHJcbiAgcmV0dXJuIHYgaW5zdGFuY2VvZiBOYW1lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0NtZCh2LCBjbWQpIHtcclxuICByZXR1cm4gdiBpbnN0YW5jZW9mIENtZCAmJiAoY21kID09PSB1bmRlZmluZWQgfHwgdi5jbWQgPT09IGNtZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGljdCh2LCB0eXBlKSB7XHJcbiAgaWYgKCEodiBpbnN0YW5jZW9mIERpY3QpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmICghdHlwZSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIHZhciBkaWN0VHlwZSA9IHYuZ2V0KCdUeXBlJyk7XHJcbiAgcmV0dXJuIGlzTmFtZShkaWN0VHlwZSkgJiYgZGljdFR5cGUubmFtZSA9PT0gdHlwZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNBcnJheSh2KSB7XHJcbiAgcmV0dXJuIHYgaW5zdGFuY2VvZiBBcnJheTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTdHJlYW0odikge1xyXG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiB2LmdldEJ5dGVzICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodikge1xyXG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiB2LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNSZWYodikge1xyXG4gIHJldHVybiB2IGluc3RhbmNlb2YgUmVmO1xyXG59XHJcblxyXG4vKipcclxuICogUHJvbWlzZSBDYXBhYmlsaXR5IG9iamVjdC5cclxuICpcclxuICogQHR5cGVkZWYge09iamVjdH0gUHJvbWlzZUNhcGFiaWxpdHlcclxuICogQHByb3BlcnR5IHtQcm9taXNlfSBwcm9taXNlIC0gQSBwcm9taXNlIG9iamVjdC5cclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcmVzb2x2ZSAtIEZ1bGxmaWxscyB0aGUgcHJvbWlzZS5cclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcmVqZWN0IC0gUmVqZWN0cyB0aGUgcHJvbWlzZS5cclxuICovXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHByb21pc2UgY2FwYWJpbGl0eSBvYmplY3QuXHJcbiAqIEBhbGlhcyBQREZKUy5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlQ2FwYWJpbGl0eX0gQSBjYXBhYmlsaXR5IG9iamVjdCBjb250YWluczpcclxuICogLSBhIFByb21pc2UsIHJlc29sdmUgYW5kIHJlamVjdCBtZXRob2RzLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkoKSB7XHJcbiAgdmFyIGNhcGFiaWxpdHkgPSB7fTtcclxuICBjYXBhYmlsaXR5LnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICBjYXBhYmlsaXR5LnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgY2FwYWJpbGl0eS5yZWplY3QgPSByZWplY3Q7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGNhcGFiaWxpdHk7XHJcbn1cclxuXHJcblBERkpTLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5ID0gY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHk7XHJcblxyXG4vKipcclxuICogUG9seWZpbGwgZm9yIFByb21pc2VzOlxyXG4gKiBUaGUgZm9sbG93aW5nIHByb21pc2UgaW1wbGVtZW50YXRpb24gdHJpZXMgdG8gZ2VuZXJhbGx5IGltcGxlbWVudCB0aGVcclxuICogUHJvbWlzZS9BKyBzcGVjLiBTb21lIG5vdGFibGUgZGlmZmVyZW5jZXMgZnJvbSBvdGhlciBwcm9taXNlIGxpYmFyaWVzIGFyZTpcclxuICogLSBUaGVyZSBjdXJyZW50bHkgaXNuJ3QgYSBzZXBlcmF0ZSBkZWZlcnJlZCBhbmQgcHJvbWlzZSBvYmplY3QuXHJcbiAqIC0gVW5oYW5kbGVkIHJlamVjdGlvbnMgZXZlbnR1YWxseSBzaG93IGFuIGVycm9yIGlmIHRoZXkgYXJlbid0IGhhbmRsZWQuXHJcbiAqXHJcbiAqIEJhc2VkIG9mZiBvZiB0aGUgd29yayBpbjpcclxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODEwNDkwXHJcbiAqL1xyXG4oZnVuY3Rpb24gUHJvbWlzZUNsb3N1cmUoKSB7XHJcbiAgaWYgKGdsb2JhbFNjb3BlLlByb21pc2UpIHtcclxuICAgIC8vIFByb21pc2VzIGV4aXN0aW5nIGluIHRoZSBET00vV29ya2VyLCBjaGVja2luZyBwcmVzZW5jZSBvZiBhbGwvcmVzb2x2ZVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxTY29wZS5Qcm9taXNlLmFsbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBnbG9iYWxTY29wZS5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChpdGVyYWJsZSkge1xyXG4gICAgICAgIHZhciBjb3VudCA9IDAsIHJlc3VsdHMgPSBbXSwgcmVzb2x2ZSwgcmVqZWN0O1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGdsb2JhbFNjb3BlLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmVfLCByZWplY3RfKSB7XHJcbiAgICAgICAgICByZXNvbHZlID0gcmVzb2x2ZV87XHJcbiAgICAgICAgICByZWplY3QgPSByZWplY3RfO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGl0ZXJhYmxlLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcclxuICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBjb3VudC0tO1xyXG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbFNjb3BlLlByb21pc2UucmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBnbG9iYWxTY29wZS5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGdsb2JhbFNjb3BlLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxTY29wZS5Qcm9taXNlLnJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBnbG9iYWxTY29wZS5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IGdsb2JhbFNjb3BlLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbFNjb3BlLlByb21pc2UucHJvdG90eXBlLmNhdGNoICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGdsb2JhbFNjb3BlLlByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFNjb3BlLlByb21pc2UucHJvdG90eXBlLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4vLyNpZiAhTU9aQ0VOVFJBTFxyXG4gIHZhciBTVEFUVVNfUEVORElORyA9IDA7XHJcbiAgdmFyIFNUQVRVU19SRVNPTFZFRCA9IDE7XHJcbiAgdmFyIFNUQVRVU19SRUpFQ1RFRCA9IDI7XHJcblxyXG4gIC8vIEluIGFuIGF0dGVtcHQgdG8gYXZvaWQgc2lsZW50IGV4Y2VwdGlvbnMsIHVuaGFuZGxlZCByZWplY3Rpb25zIGFyZVxyXG4gIC8vIHRyYWNrZWQgYW5kIGlmIHRoZXkgYXJlbid0IGhhbmRsZWQgaW4gYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIGFuXHJcbiAgLy8gZXJyb3IgaXMgbG9nZ2VkLlxyXG4gIHZhciBSRUpFQ1RJT05fVElNRU9VVCA9IDUwMDtcclxuXHJcbiAgdmFyIEhhbmRsZXJNYW5hZ2VyID0ge1xyXG4gICAgaGFuZGxlcnM6IFtdLFxyXG4gICAgcnVubmluZzogZmFsc2UsXHJcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zOiBbXSxcclxuICAgIHBlbmRpbmdSZWplY3Rpb25DaGVjazogZmFsc2UsXHJcblxyXG4gICAgc2NoZWR1bGVIYW5kbGVyczogZnVuY3Rpb24gc2NoZWR1bGVIYW5kbGVycyhwcm9taXNlKSB7XHJcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0dXMgPT09IFNUQVRVU19QRU5ESU5HKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5jb25jYXQocHJvbWlzZS5faGFuZGxlcnMpO1xyXG4gICAgICBwcm9taXNlLl9oYW5kbGVycyA9IFtdO1xyXG5cclxuICAgICAgaWYgKHRoaXMucnVubmluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgc2V0VGltZW91dCh0aGlzLnJ1bkhhbmRsZXJzLmJpbmQodGhpcyksIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBydW5IYW5kbGVyczogZnVuY3Rpb24gcnVuSGFuZGxlcnMoKSB7XHJcbiAgICAgIHZhciBSVU5fVElNRU9VVCA9IDE7IC8vIG1zXHJcbiAgICAgIHZhciB0aW1lb3V0QXQgPSBEYXRlLm5vdygpICsgUlVOX1RJTUVPVVQ7XHJcbiAgICAgIHdoaWxlICh0aGlzLmhhbmRsZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnMuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgdmFyIG5leHRTdGF0dXMgPSBoYW5kbGVyLnRoaXNQcm9taXNlLl9zdGF0dXM7XHJcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGhhbmRsZXIudGhpc1Byb21pc2UuX3ZhbHVlO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKG5leHRTdGF0dXMgPT09IFNUQVRVU19SRVNPTFZFRCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25SZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgbmV4dFZhbHVlID0gaGFuZGxlci5vblJlc29sdmUobmV4dFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaGFuZGxlci5vblJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgIG5leHRWYWx1ZSA9IGhhbmRsZXIub25SZWplY3QobmV4dFZhbHVlKTtcclxuICAgICAgICAgICAgICBuZXh0U3RhdHVzID0gU1RBVFVTX1JFU09MVkVEO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoaGFuZGxlci50aGlzUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVVuaGFuZGVsZWRSZWplY3Rpb24oaGFuZGxlci50aGlzUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICBuZXh0U3RhdHVzID0gU1RBVFVTX1JFSkVDVEVEO1xyXG4gICAgICAgICAgbmV4dFZhbHVlID0gZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoYW5kbGVyLm5leHRQcm9taXNlLl91cGRhdGVTdGF0dXMobmV4dFN0YXR1cywgbmV4dFZhbHVlKTtcclxuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+PSB0aW1lb3V0QXQpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuaGFuZGxlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5ydW5IYW5kbGVycy5iaW5kKHRoaXMpLCAwKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRVbmhhbmRsZWRSZWplY3Rpb246IGZ1bmN0aW9uIGFkZFVuaGFuZGxlZFJlamVjdGlvbihwcm9taXNlKSB7XHJcbiAgICAgIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxyXG4gICAgICAgIHRpbWU6IERhdGUubm93KClcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuc2NoZWR1bGVSZWplY3Rpb25DaGVjaygpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVVbmhhbmRlbGVkUmVqZWN0aW9uOiBmdW5jdGlvbiByZW1vdmVVbmhhbmRlbGVkUmVqZWN0aW9uKHByb21pc2UpIHtcclxuICAgICAgcHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkUmVqZWN0aW9uc1tpXS5wcm9taXNlID09PSBwcm9taXNlKSB7XHJcbiAgICAgICAgICB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGkpO1xyXG4gICAgICAgICAgaS0tO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzY2hlZHVsZVJlamVjdGlvbkNoZWNrOiBmdW5jdGlvbiBzY2hlZHVsZVJlamVjdGlvbkNoZWNrKCkge1xyXG4gICAgICBpZiAodGhpcy5wZW5kaW5nUmVqZWN0aW9uQ2hlY2spIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wZW5kaW5nUmVqZWN0aW9uQ2hlY2sgPSB0cnVlO1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHJlamVjdGlvbkNoZWNrKCkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1JlamVjdGlvbkNoZWNrID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChub3cgLSB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnNbaV0udGltZSA+IFJFSkVDVElPTl9USU1FT1VUKSB7XHJcbiAgICAgICAgICAgIHZhciB1bmhhbmRsZWQgPSB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnNbaV0ucHJvbWlzZS5fdmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSAnVW5oYW5kbGVkIHJlamVjdGlvbjogJyArIHVuaGFuZGxlZDtcclxuICAgICAgICAgICAgaWYgKHVuaGFuZGxlZC5zdGFjaykge1xyXG4gICAgICAgICAgICAgIG1zZyArPSAnXFxuJyArIHVuaGFuZGxlZC5zdGFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3YXJuKG1zZyk7XHJcbiAgICAgICAgICAgIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoaSk7XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZWplY3Rpb25DaGVjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfS5iaW5kKHRoaXMpLCBSRUpFQ1RJT05fVElNRU9VVCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xyXG4gICAgdGhpcy5fc3RhdHVzID0gU1RBVFVTX1BFTkRJTkc7XHJcbiAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzb2x2ZXIuY2FsbCh0aGlzLCB0aGlzLl9yZXNvbHZlLmJpbmQodGhpcyksIHRoaXMuX3JlamVjdC5iaW5kKHRoaXMpKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdGhpcy5fcmVqZWN0KGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBCdWlsZHMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBhbGwgdGhlIHBhc3NlZCBpbiBwcm9taXNlcyBhcmVcclxuICAgKiByZXNvbHZlZC5cclxuICAgKiBAcGFyYW0ge2FycmF5fSBhcnJheSBvZiBkYXRhIGFuZC9vciBwcm9taXNlcyB0byB3YWl0IGZvci5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBOZXcgZGVwZW5kYW50IHByb21pc2UuXHJcbiAgICovXHJcbiAgUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiBQcm9taXNlX2FsbChwcm9taXNlcykge1xyXG4gICAgdmFyIHJlc29sdmVBbGwsIHJlamVjdEFsbDtcclxuICAgIHZhciBkZWZlcnJlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgcmVzb2x2ZUFsbCA9IHJlc29sdmU7XHJcbiAgICAgIHJlamVjdEFsbCA9IHJlamVjdDtcclxuICAgIH0pO1xyXG4gICAgdmFyIHVucmVzb2x2ZWQgPSBwcm9taXNlcy5sZW5ndGg7XHJcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgaWYgKHVucmVzb2x2ZWQgPT09IDApIHtcclxuICAgICAgcmVzb2x2ZUFsbChyZXN1bHRzKTtcclxuICAgICAgcmV0dXJuIGRlZmVycmVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xyXG4gICAgICBpZiAoZGVmZXJyZWQuX3N0YXR1cyA9PT0gU1RBVFVTX1JFSkVDVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdHMgPSBbXTtcclxuICAgICAgcmVqZWN0QWxsKHJlYXNvbik7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwcm9taXNlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgIHZhciBwcm9taXNlID0gcHJvbWlzZXNbaV07XHJcbiAgICAgIHZhciByZXNvbHZlID0gKGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIGlmIChkZWZlcnJlZC5fc3RhdHVzID09PSBTVEFUVVNfUkVKRUNURUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHZhbHVlO1xyXG4gICAgICAgICAgdW5yZXNvbHZlZC0tO1xyXG4gICAgICAgICAgaWYgKHVucmVzb2x2ZWQgPT09IDApIHtcclxuICAgICAgICAgICAgcmVzb2x2ZUFsbChyZXN1bHRzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9KShpKTtcclxuICAgICAgaWYgKFByb21pc2UuaXNQcm9taXNlKHByb21pc2UpKSB7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZmVycmVkO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgbGlrZWx5IGEgcHJvbWlzZSAoaGFzIGEgJ3RoZW4nIGZ1bmN0aW9uKS5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHZhbHVlIGlzIHRoZW5hYmxlXHJcbiAgICovXHJcbiAgUHJvbWlzZS5pc1Byb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlX2lzUHJvbWlzZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgcmVzb2x2ZWQgcHJvbWlzZVxyXG4gICAqIEBwYXJhbSB2YWx1ZSByZXNvbHZlIHZhbHVlXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICovXHJcbiAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gUHJvbWlzZV9yZXNvbHZlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgcmVqZWN0ZWQgcHJvbWlzZVxyXG4gICAqIEBwYXJhbSByZWFzb24gcmVqZWN0aW9uIHZhbHVlXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICovXHJcbiAgUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiBQcm9taXNlX3JlamVjdChyZWFzb24pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJlamVjdChyZWFzb24pOyB9KTtcclxuICB9O1xyXG5cclxuICBQcm9taXNlLnByb3RvdHlwZSA9IHtcclxuICAgIF9zdGF0dXM6IG51bGwsXHJcbiAgICBfdmFsdWU6IG51bGwsXHJcbiAgICBfaGFuZGxlcnM6IG51bGwsXHJcbiAgICBfdW5oYW5kbGVkUmVqZWN0aW9uOiBudWxsLFxyXG5cclxuICAgIF91cGRhdGVTdGF0dXM6IGZ1bmN0aW9uIFByb21pc2VfX3VwZGF0ZVN0YXR1cyhzdGF0dXMsIHZhbHVlKSB7XHJcbiAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IFNUQVRVU19SRVNPTFZFRCB8fFxyXG4gICAgICAgICAgdGhpcy5fc3RhdHVzID09PSBTVEFUVVNfUkVKRUNURUQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVU19SRVNPTFZFRCAmJlxyXG4gICAgICAgICAgUHJvbWlzZS5pc1Byb21pc2UodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUudGhlbih0aGlzLl91cGRhdGVTdGF0dXMuYmluZCh0aGlzLCBTVEFUVVNfUkVTT0xWRUQpLFxyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzLmJpbmQodGhpcywgU1RBVFVTX1JFSkVDVEVEKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcblxyXG4gICAgICBpZiAoc3RhdHVzID09PSBTVEFUVVNfUkVKRUNURUQgJiYgdGhpcy5faGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5fdW5oYW5kbGVkUmVqZWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICBIYW5kbGVyTWFuYWdlci5hZGRVbmhhbmRsZWRSZWplY3Rpb24odGhpcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIEhhbmRsZXJNYW5hZ2VyLnNjaGVkdWxlSGFuZGxlcnModGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9yZXNvbHZlOiBmdW5jdGlvbiBQcm9taXNlX3Jlc29sdmUodmFsdWUpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKFNUQVRVU19SRVNPTFZFRCwgdmFsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVqZWN0OiBmdW5jdGlvbiBQcm9taXNlX3JlamVjdChyZWFzb24pIHtcclxuICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKFNUQVRVU19SRUpFQ1RFRCwgcmVhc29uKTtcclxuICAgIH0sXHJcblxyXG4gICAgdGhlbjogZnVuY3Rpb24gUHJvbWlzZV90aGVuKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcclxuICAgICAgdmFyIG5leHRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLl9oYW5kbGVycy5wdXNoKHtcclxuICAgICAgICB0aGlzUHJvbWlzZTogdGhpcyxcclxuICAgICAgICBvblJlc29sdmU6IG9uUmVzb2x2ZSxcclxuICAgICAgICBvblJlamVjdDogb25SZWplY3QsXHJcbiAgICAgICAgbmV4dFByb21pc2U6IG5leHRQcm9taXNlXHJcbiAgICAgIH0pO1xyXG4gICAgICBIYW5kbGVyTWFuYWdlci5zY2hlZHVsZUhhbmRsZXJzKHRoaXMpO1xyXG4gICAgICByZXR1cm4gbmV4dFByb21pc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGNhdGNoOiBmdW5jdGlvbiBQcm9taXNlX2NhdGNoKG9uUmVqZWN0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZ2xvYmFsU2NvcGUuUHJvbWlzZSA9IFByb21pc2U7XHJcbi8vI2Vsc2VcclxuLy90aHJvdyBuZXcgRXJyb3IoJ0RPTSBQcm9taXNlIGlzIG5vdCBwcmVzZW50Jyk7XHJcbi8vI2VuZGlmXHJcbn0pKCk7XHJcblxyXG52YXIgU3RhdFRpbWVyID0gKGZ1bmN0aW9uIFN0YXRUaW1lckNsb3N1cmUoKSB7XHJcbiAgZnVuY3Rpb24gcnBhZChzdHIsIHBhZCwgbGVuZ3RoKSB7XHJcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xyXG4gICAgICBzdHIgKz0gcGFkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcbiAgZnVuY3Rpb24gU3RhdFRpbWVyKCkge1xyXG4gICAgdGhpcy5zdGFydGVkID0ge307XHJcbiAgICB0aGlzLnRpbWVzID0gW107XHJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gIH1cclxuICBTdGF0VGltZXIucHJvdG90eXBlID0ge1xyXG4gICAgdGltZTogZnVuY3Rpb24gU3RhdFRpbWVyX3RpbWUobmFtZSkge1xyXG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICB3YXJuKCdUaW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcgZm9yICcgKyBuYW1lKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnN0YXJ0ZWRbbmFtZV0gPSBEYXRlLm5vdygpO1xyXG4gICAgfSxcclxuICAgIHRpbWVFbmQ6IGZ1bmN0aW9uIFN0YXRUaW1lcl90aW1lRW5kKG5hbWUpIHtcclxuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XHJcbiAgICAgICAgd2FybignVGltZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgZm9yICcgKyBuYW1lKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRpbWVzLnB1c2goe1xyXG4gICAgICAgICduYW1lJzogbmFtZSxcclxuICAgICAgICAnc3RhcnQnOiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXHJcbiAgICAgICAgJ2VuZCc6IERhdGUubm93KClcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIFJlbW92ZSB0aW1lciBmcm9tIHN0YXJ0ZWQgc28gaXQgY2FuIGJlIGNhbGxlZCBhZ2Fpbi5cclxuICAgICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcclxuICAgIH0sXHJcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gU3RhdFRpbWVyX3RvU3RyaW5nKCkge1xyXG4gICAgICB2YXIgaSwgaWk7XHJcbiAgICAgIHZhciB0aW1lcyA9IHRoaXMudGltZXM7XHJcbiAgICAgIHZhciBvdXQgPSAnJztcclxuICAgICAgLy8gRmluZCB0aGUgbG9uZ2VzdCBuYW1lIGZvciBwYWRkaW5nIHB1cnBvc2VzLlxyXG4gICAgICB2YXIgbG9uZ2VzdCA9IDA7XHJcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gdGltZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgIHZhciBuYW1lID0gdGltZXNbaV1bJ25hbWUnXTtcclxuICAgICAgICBpZiAobmFtZS5sZW5ndGggPiBsb25nZXN0KSB7XHJcbiAgICAgICAgICBsb25nZXN0ID0gbmFtZS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gdGltZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgIHZhciBzcGFuID0gdGltZXNbaV07XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gc3Bhbi5lbmQgLSBzcGFuLnN0YXJ0O1xyXG4gICAgICAgIG91dCArPSBycGFkKHNwYW5bJ25hbWUnXSwgJyAnLCBsb25nZXN0KSArICcgJyArIGR1cmF0aW9uICsgJ21zXFxuJztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIFN0YXRUaW1lcjtcclxufSkoKTtcclxuXHJcblBERkpTLmNyZWF0ZUJsb2IgPSBmdW5jdGlvbiBjcmVhdGVCbG9iKGRhdGEsIGNvbnRlbnRUeXBlKSB7XHJcbiAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiBjb250ZW50VHlwZSB9KTtcclxuICB9XHJcbiAgLy8gQmxvYiBidWlsZGVyIGlzIGRlcHJlY2F0ZWQgaW4gRkYxNCBhbmQgcmVtb3ZlZCBpbiBGRjE4LlxyXG4gIHZhciBiYiA9IG5ldyBNb3pCbG9iQnVpbGRlcigpO1xyXG4gIGJiLmFwcGVuZChkYXRhKTtcclxuICByZXR1cm4gYmIuZ2V0QmxvYihjb250ZW50VHlwZSk7XHJcbn07XHJcblxyXG5QREZKUy5jcmVhdGVPYmplY3RVUkwgPSAoZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMQ2xvc3VyZSgpIHtcclxuICAvLyBCbG9iL2NyZWF0ZU9iamVjdFVSTCBpcyBub3QgYXZhaWxhYmxlLCBmYWxsaW5nIGJhY2sgdG8gZGF0YSBzY2hlbWEuXHJcbiAgdmFyIGRpZ2l0cyA9XHJcbiAgICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMKGRhdGEsIGNvbnRlbnRUeXBlKSB7XHJcbiAgICBpZiAoIVBERkpTLmRpc2FibGVDcmVhdGVPYmplY3RVUkwgJiZcclxuICAgICAgICB0eXBlb2YgVVJMICE9PSAndW5kZWZpbmVkJyAmJiBVUkwuY3JlYXRlT2JqZWN0VVJMKSB7XHJcbiAgICAgIHZhciBibG9iID0gUERGSlMuY3JlYXRlQmxvYihkYXRhLCBjb250ZW50VHlwZSk7XHJcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBidWZmZXIgPSAnZGF0YTonICsgY29udGVudFR5cGUgKyAnO2Jhc2U2NCwnO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XHJcbiAgICAgIHZhciBiMSA9IGRhdGFbaV0gJiAweEZGO1xyXG4gICAgICB2YXIgYjIgPSBkYXRhW2kgKyAxXSAmIDB4RkY7XHJcbiAgICAgIHZhciBiMyA9IGRhdGFbaSArIDJdICYgMHhGRjtcclxuICAgICAgdmFyIGQxID0gYjEgPj4gMiwgZDIgPSAoKGIxICYgMykgPDwgNCkgfCAoYjIgPj4gNCk7XHJcbiAgICAgIHZhciBkMyA9IGkgKyAxIDwgaWkgPyAoKGIyICYgMHhGKSA8PCAyKSB8IChiMyA+PiA2KSA6IDY0O1xyXG4gICAgICB2YXIgZDQgPSBpICsgMiA8IGlpID8gKGIzICYgMHgzRikgOiA2NDtcclxuICAgICAgYnVmZmVyICs9IGRpZ2l0c1tkMV0gKyBkaWdpdHNbZDJdICsgZGlnaXRzW2QzXSArIGRpZ2l0c1tkNF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBNZXNzYWdlSGFuZGxlcihuYW1lLCBjb21PYmopIHtcclxuICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gIHRoaXMuY29tT2JqID0gY29tT2JqO1xyXG4gIHRoaXMuY2FsbGJhY2tJbmRleCA9IDE7XHJcbiAgdGhpcy5wb3N0TWVzc2FnZVRyYW5zZmVycyA9IHRydWU7XHJcbiAgdmFyIGNhbGxiYWNrc0NhcGFiaWxpdGllcyA9IHRoaXMuY2FsbGJhY2tzQ2FwYWJpbGl0aWVzID0ge307XHJcbiAgdmFyIGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyID0ge307XHJcblxyXG4gIGFoWydjb25zb2xlX2xvZyddID0gW2Z1bmN0aW9uIGFoQ29uc29sZUxvZyhkYXRhKSB7XHJcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBkYXRhKTtcclxuICB9XTtcclxuICBhaFsnY29uc29sZV9lcnJvciddID0gW2Z1bmN0aW9uIGFoQ29uc29sZUVycm9yKGRhdGEpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgZGF0YSk7XHJcbiAgfV07XHJcbiAgYWhbJ191bnN1cHBvcnRlZF9mZWF0dXJlJ10gPSBbZnVuY3Rpb24gYWhfdW5zdXBwb3J0ZWRGZWF0dXJlKGRhdGEpIHtcclxuICAgIFVuc3VwcG9ydGVkTWFuYWdlci5ub3RpZnkoZGF0YSk7XHJcbiAgfV07XHJcblxyXG4gIGNvbU9iai5vbm1lc3NhZ2UgPSBmdW5jdGlvbiBtZXNzYWdlSGFuZGxlckNvbU9iak9uTWVzc2FnZShldmVudCkge1xyXG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xyXG4gICAgaWYgKGRhdGEuaXNSZXBseSkge1xyXG4gICAgICB2YXIgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcclxuICAgICAgaWYgKGRhdGEuY2FsbGJhY2tJZCBpbiBjYWxsYmFja3NDYXBhYmlsaXRpZXMpIHtcclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XHJcbiAgICAgICAgZGVsZXRlIGNhbGxiYWNrc0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcclxuICAgICAgICBpZiAoJ2Vycm9yJyBpbiBkYXRhKSB7XHJcbiAgICAgICAgICBjYWxsYmFjay5yZWplY3QoZGF0YS5lcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUoZGF0YS5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCByZXNvbHZlIGNhbGxiYWNrICcgKyBjYWxsYmFja0lkKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbiBpbiBhaCkge1xyXG4gICAgICB2YXIgYWN0aW9uID0gYWhbZGF0YS5hY3Rpb25dO1xyXG4gICAgICBpZiAoZGF0YS5jYWxsYmFja0lkKSB7XHJcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gYWN0aW9uWzBdLmNhbGwoYWN0aW9uWzFdLCBkYXRhLmRhdGEpO1xyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgaXNSZXBseTogdHJ1ZSxcclxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxyXG4gICAgICAgICAgICBkYXRhOiByZXN1bHRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgIGlzUmVwbHk6IHRydWUsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcclxuICAgICAgICAgICAgZXJyb3I6IHJlYXNvblxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWN0aW9uWzBdLmNhbGwoYWN0aW9uWzFdLCBkYXRhLmRhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlcnJvcignVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICcgKyBkYXRhLmFjdGlvbik7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuTWVzc2FnZUhhbmRsZXIucHJvdG90eXBlID0ge1xyXG4gIG9uOiBmdW5jdGlvbiBtZXNzYWdlSGFuZGxlck9uKGFjdGlvbk5hbWUsIGhhbmRsZXIsIHNjb3BlKSB7XHJcbiAgICB2YXIgYWggPSB0aGlzLmFjdGlvbkhhbmRsZXI7XHJcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcclxuICAgICAgZXJyb3IoJ1RoZXJlIGlzIGFscmVhZHkgYW4gYWN0aW9uTmFtZSBjYWxsZWQgXCInICsgYWN0aW9uTmFtZSArICdcIicpO1xyXG4gICAgfVxyXG4gICAgYWhbYWN0aW9uTmFtZV0gPSBbaGFuZGxlciwgc2NvcGVdO1xyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBjb21PYmogdG8gaW52b2tlIHRoZSBhY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgZGF0YS5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uTmFtZSBBY3Rpb24gdG8gY2FsbC5cclxuICAgKiBAcGFyYW0ge0pTT059IGRhdGEgSlNPTiBkYXRhIHRvIHNlbmQuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gW3RyYW5zZmVyc10gT3B0aW9uYWwgbGlzdCBvZiB0cmFuc2ZlcnMvQXJyYXlCdWZmZXJzXHJcbiAgICovXHJcbiAgc2VuZDogZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJTZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xyXG4gICAgdmFyIG1lc3NhZ2UgPSB7XHJcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcclxuICAgICAgZGF0YTogZGF0YVxyXG4gICAgfTtcclxuICAgIHRoaXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJzKTtcclxuICB9LFxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgY29tT2JqIHRvIGludm9rZSB0aGUgYWN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGRhdGEuXHJcbiAgICogRXhwZWN0cyB0aGF0IG90aGVyIHNpZGUgd2lsbCBjYWxsYmFjayB3aXRoIHRoZSByZXNwb25zZS5cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uTmFtZSBBY3Rpb24gdG8gY2FsbC5cclxuICAgKiBAcGFyYW0ge0pTT059IGRhdGEgSlNPTiBkYXRhIHRvIHNlbmQuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gW3RyYW5zZmVyc10gT3B0aW9uYWwgbGlzdCBvZiB0cmFuc2ZlcnMvQXJyYXlCdWZmZXJzLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIHRvIGJlIHJlc29sdmVkIHdpdGggcmVzcG9uc2UgZGF0YS5cclxuICAgKi9cclxuICBzZW5kV2l0aFByb21pc2U6XHJcbiAgICBmdW5jdGlvbiBtZXNzYWdlSGFuZGxlclNlbmRXaXRoUHJvbWlzZShhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcclxuICAgIHZhciBjYWxsYmFja0lkID0gdGhpcy5jYWxsYmFja0luZGV4Kys7XHJcbiAgICB2YXIgbWVzc2FnZSA9IHtcclxuICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxyXG4gICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICBjYWxsYmFja0lkOiBjYWxsYmFja0lkXHJcbiAgICB9O1xyXG4gICAgdmFyIGNhcGFiaWxpdHkgPSBjcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSgpO1xyXG4gICAgdGhpcy5jYWxsYmFja3NDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF0gPSBjYXBhYmlsaXR5O1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcnMpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XHJcbiAgfSxcclxuICAvKipcclxuICAgKiBTZW5kcyByYXcgbWVzc2FnZSB0byB0aGUgY29tT2JqLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIG1lc3NhZ2Uge09iamVjdH0gUmF3IG1lc3NhZ2UuXHJcbiAgICogQHBhcmFtIHRyYW5zZmVycyBMaXN0IG9mIHRyYW5zZmVycy9BcnJheUJ1ZmZlcnMsIG9yIHVuZGVmaW5lZC5cclxuICAgKi9cclxuICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gKG1lc3NhZ2UsIHRyYW5zZmVycykge1xyXG4gICAgaWYgKHRyYW5zZmVycyAmJiB0aGlzLnBvc3RNZXNzYWdlVHJhbnNmZXJzKSB7XHJcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZShtZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XHJcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEpweEltYWdlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkSnBlZ1N0cmVhbShpZCwgaW1hZ2VVcmwsIG9ianMpIHtcclxuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgaW1nLm9ubG9hZCA9IChmdW5jdGlvbiBsb2FkSnBlZ1N0cmVhbV9vbmxvYWRDbG9zdXJlKCkge1xyXG4gICAgb2Jqcy5yZXNvbHZlKGlkLCBpbWcpO1xyXG4gIH0pO1xyXG4gIGltZy5vbmVycm9yID0gKGZ1bmN0aW9uIGxvYWRKcGVnU3RyZWFtX29uZXJyb3JDbG9zdXJlKCkge1xyXG4gICAgb2Jqcy5yZXNvbHZlKGlkLCBudWxsKTtcclxuICAgIHdhcm4oJ0Vycm9yIGR1cmluZyBKUEVHIGltYWdlIGxvYWRpbmcnKTtcclxuICB9KTtcclxuICBpbWcuc3JjID0gaW1hZ2VVcmw7XHJcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBkb2Vzbid0IHdvcnRoIHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25hIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgIGNhc2UgSEVBRDpcbiAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuXG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICBiaXRzIC09IDQ7XG4gICAgICAvLy0tLS8vXG4gICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIEZMQUdTOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUSU1FOlxuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgIC8vPT09XG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE9TOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYTEVOOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWFRSQTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVuZCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE5BTUU6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPTU1FTlQ6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgSENSQzpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUNUSUQ6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJQ1Q6XG4gICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRTpcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRZUEVETzpcbiAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gMTtcbiAgICAgIGJpdHMgLT0gMTtcbiAgICAgIC8vLS0tLy9cblxuICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgYml0cyAtPSAyO1xuICAgICAgLy8tLS0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTVE9SRUQ6XG4gICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAvLy0tLS8vXG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZXzpcbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09QWTpcbiAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBpZiAoY29weSkge1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFRBQkxFOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuLy8jZW5kaWZcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5fOlxuICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTjpcbiAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgIC8vLS0tXG5cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVDpcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1RFWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE1BVENIOlxuICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgfVxuICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICBkbyB7XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMSVQ6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBsZWZ0LS07XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDSEVDSzpcbiAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAvLyBVc2UgJ3wnIGluc2RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgfVxuICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOR1RIOlxuICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRE9ORTpcbiAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIEJBRDpcbiAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIE1FTTpcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICBjYXNlIFNZTkM6XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc2RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsInZhciBtc2cgPSByZXF1aXJlKCdwYWtvL2xpYi96bGliL21lc3NhZ2VzJyk7XG52YXIgenN0cmVhbSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvenN0cmVhbScpO1xudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcycpO1xudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbmZvciAodmFyIGtleSBpbiBjb25zdGFudHMpIHtcbiAgZXhwb3J0c1trZXldID0gY29uc3RhbnRzW2tleV07XG59XG5cbi8vIHpsaWIgbW9kZXNcbmV4cG9ydHMuTk9ORSA9IDA7XG5leHBvcnRzLkRFRkxBVEUgPSAxO1xuZXhwb3J0cy5JTkZMQVRFID0gMjtcbmV4cG9ydHMuR1pJUCA9IDM7XG5leHBvcnRzLkdVTlpJUCA9IDQ7XG5leHBvcnRzLkRFRkxBVEVSQVcgPSA1O1xuZXhwb3J0cy5JTkZMQVRFUkFXID0gNjtcbmV4cG9ydHMuVU5aSVAgPSA3O1xuXG4vKipcbiAqIEVtdWxhdGUgTm9kZSdzIHpsaWIgQysrIGxheWVyIGZvciB1c2UgYnkgdGhlIEpTIGxheWVyIGluIGluZGV4LmpzXG4gKi9cbmZ1bmN0aW9uIFpsaWIobW9kZSkge1xuICBpZiAobW9kZSA8IGV4cG9ydHMuREVGTEFURSB8fCBtb2RlID4gZXhwb3J0cy5VTlpJUClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQmFkIGFyZ3VtZW50XCIpO1xuICAgIFxuICB0aGlzLm1vZGUgPSBtb2RlO1xuICB0aGlzLmluaXRfZG9uZSA9IGZhbHNlO1xuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuICB0aGlzLndpbmRvd0JpdHMgPSAwO1xuICB0aGlzLmxldmVsID0gMDtcbiAgdGhpcy5tZW1MZXZlbCA9IDA7XG4gIHRoaXMuc3RyYXRlZ3kgPSAwO1xuICB0aGlzLmRpY3Rpb25hcnkgPSBudWxsO1xufVxuXG5abGliLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24od2luZG93Qml0cywgbGV2ZWwsIG1lbUxldmVsLCBzdHJhdGVneSwgZGljdGlvbmFyeSkge1xuICB0aGlzLndpbmRvd0JpdHMgPSB3aW5kb3dCaXRzO1xuICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gIHRoaXMubWVtTGV2ZWwgPSBtZW1MZXZlbDtcbiAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAvLyBkaWN0aW9uYXJ5IG5vdCBzdXBwb3J0ZWQuXG4gIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLkdaSVAgfHwgdGhpcy5tb2RlID09PSBleHBvcnRzLkdVTlpJUClcbiAgICB0aGlzLndpbmRvd0JpdHMgKz0gMTY7XG4gICAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuVU5aSVApXG4gICAgdGhpcy53aW5kb3dCaXRzICs9IDMyO1xuICAgIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLkRFRkxBVEVSQVcgfHwgdGhpcy5tb2RlID09PSBleHBvcnRzLklORkxBVEVSQVcpXG4gICAgdGhpcy53aW5kb3dCaXRzID0gLXRoaXMud2luZG93Qml0cztcbiAgICBcbiAgdGhpcy5zdHJtID0gbmV3IHpzdHJlYW0oKTtcbiAgXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdaSVA6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICAgICAgdGhpcy5zdHJtLFxuICAgICAgICB0aGlzLmxldmVsLFxuICAgICAgICBleHBvcnRzLlpfREVGTEFURUQsXG4gICAgICAgIHRoaXMud2luZG93Qml0cyxcbiAgICAgICAgdGhpcy5tZW1MZXZlbCxcbiAgICAgICAgdGhpcy5zdHJhdGVneVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HVU5aSVA6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEVSQVc6XG4gICAgY2FzZSBleHBvcnRzLlVOWklQOlxuICAgICAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgICAgICB0aGlzLnN0cm0sXG4gICAgICAgIHRoaXMud2luZG93Qml0c1xuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vZGUgXCIgKyB0aGlzLm1vZGUpO1xuICB9XG4gIFxuICBpZiAoc3RhdHVzICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcihzdGF0dXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICB0aGlzLmluaXRfZG9uZSA9IHRydWU7XG59O1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiZGVmbGF0ZVBhcmFtcyBOb3Qgc3VwcG9ydGVkXCIpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3dyaXRlQ2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmluaXRfZG9uZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZSBiZWZvcmUgaW5pdFwiKTtcbiAgICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5OT05FKVxuICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxpemVkXCIpO1xuICAgIFxuICBpZiAodGhpcy53cml0ZV9pbl9wcm9ncmVzcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZSBhbHJlYWR5IGluIHByb2dyZXNzXCIpO1xuICAgIFxuICBpZiAodGhpcy5wZW5kaW5nX2Nsb3NlKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNsb3NlIGlzIHBlbmRpbmdcIik7XG59O1xuXG5abGliLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikgeyAgICBcbiAgdGhpcy5fd3JpdGVDaGVjaygpO1xuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gdHJ1ZTtcbiAgXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gICAgdmFyIHJlcyA9IHNlbGYuX3dyaXRlKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbik7XG4gICAgc2VsZi5jYWxsYmFjayhyZXNbMF0sIHJlc1sxXSk7XG4gICAgXG4gICAgaWYgKHNlbGYucGVuZGluZ19jbG9zZSlcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG4gIFxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCBtZXRob2QgZm9yIE5vZGUgYnVmZmVycywgdXNlZCBieSBwYWtvXG5mdW5jdGlvbiBidWZmZXJTZXQoZGF0YSwgb2Zmc2V0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBkYXRhW2ldO1xuICB9XG59XG5cblpsaWIucHJvdG90eXBlLndyaXRlU3luYyA9IGZ1bmN0aW9uKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikge1xuICB0aGlzLl93cml0ZUNoZWNrKCk7XG4gIHJldHVybiB0aGlzLl93cml0ZShmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuICBcbiAgaWYgKGZsdXNoICE9PSBleHBvcnRzLlpfTk9fRkxVU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfUEFSVElBTF9GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9TWU5DX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX0ZVTExfRkxVU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfRklOSVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX0JMT0NLKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBmbHVzaCB2YWx1ZVwiKTtcbiAgfVxuICBcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICBpbnB1dCA9IG5ldyBCdWZmZXIoMCk7XG4gICAgaW5fbGVuID0gMDtcbiAgICBpbl9vZmYgPSAwO1xuICB9XG4gIFxuICBpZiAob3V0Ll9zZXQpXG4gICAgb3V0LnNldCA9IG91dC5fc2V0O1xuICBlbHNlXG4gICAgb3V0LnNldCA9IGJ1ZmZlclNldDtcbiAgXG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICBzdHJtLmF2YWlsX2luID0gaW5fbGVuO1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0ubmV4dF9pbiA9IGluX29mZjtcbiAgc3RybS5hdmFpbF9vdXQgPSBvdXRfbGVuO1xuICBzdHJtLm91dHB1dCA9IG91dDtcbiAgc3RybS5uZXh0X291dCA9IG91dF9vZmY7XG4gIFxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIGZsdXNoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5VTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGZsdXNoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vZGUgXCIgKyB0aGlzLm1vZGUpO1xuICB9XG4gIFxuICBpZiAoc3RhdHVzICE9PSBleHBvcnRzLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKHN0YXR1cyk7XG4gIH1cbiAgXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgcmV0dXJuIFtzdHJtLmF2YWlsX2luLCBzdHJtLmF2YWlsX291dF07XG59O1xuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy53cml0ZV9pbl9wcm9ncmVzcykge1xuICAgIHRoaXMucGVuZGluZ19jbG9zZSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICB0aGlzLnBlbmRpbmdfY2xvc2UgPSBmYWxzZTtcbiAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURSB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1pJUCB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURVJBVykge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gIH0gZWxzZSB7XG4gICAgemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfVxuICBcbiAgdGhpcy5tb2RlID0gZXhwb3J0cy5OT05FO1xufTtcblxuWmxpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgaWYgKHN0YXR1cyAhPT0gZXhwb3J0cy5aX09LKSB7XG4gICAgdGhpcy5fZXJyb3Ioc3RhdHVzKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gIHRoaXMub25lcnJvcihtc2dbc3RhdHVzXSArICc6ICcgKyB0aGlzLnN0cm0ubXNnLCBzdGF0dXMpO1xuICBcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICBpZiAodGhpcy5wZW5kaW5nX2Nsb3NlKVxuICAgIHRoaXMuY2xvc2UoKTtcbn07XG5cbmV4cG9ydHMuWmxpYiA9IFpsaWI7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnZhciBiaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKS5vaztcblxuLy8gemxpYiBkb2Vzbid0IHByb3ZpZGUgdGhlc2UsIHNvIGtsdWRnZSB0aGVtIGluIGZvbGxvd2luZyB0aGUgc2FtZVxuLy8gY29uc3QgbmFtaW5nIHNjaGVtZSB6bGliIHVzZXMuXG5iaW5kaW5nLlpfTUlOX1dJTkRPV0JJVFMgPSA4O1xuYmluZGluZy5aX01BWF9XSU5ET1dCSVRTID0gMTU7XG5iaW5kaW5nLlpfREVGQVVMVF9XSU5ET1dCSVRTID0gMTU7XG5cbi8vIGZld2VyIHRoYW4gNjQgYnl0ZXMgcGVyIGNodW5rIGlzIHN0dXBpZC5cbi8vIHRlY2huaWNhbGx5IGl0IGNvdWxkIHdvcmsgd2l0aCBhcyBmZXcgYXMgOCwgYnV0IGV2ZW4gNjQgYnl0ZXNcbi8vIGlzIGFic3VyZGx5IGxvdy4gIFVzdWFsbHkgYSBNQiBvciBtb3JlIGlzIGJlc3QuXG5iaW5kaW5nLlpfTUlOX0NIVU5LID0gNjQ7XG5iaW5kaW5nLlpfTUFYX0NIVU5LID0gSW5maW5pdHk7XG5iaW5kaW5nLlpfREVGQVVMVF9DSFVOSyA9ICgxNiAqIDEwMjQpO1xuXG5iaW5kaW5nLlpfTUlOX01FTUxFVkVMID0gMTtcbmJpbmRpbmcuWl9NQVhfTUVNTEVWRUwgPSA5O1xuYmluZGluZy5aX0RFRkFVTFRfTUVNTEVWRUwgPSA4O1xuXG5iaW5kaW5nLlpfTUlOX0xFVkVMID0gLTE7XG5iaW5kaW5nLlpfTUFYX0xFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX0xFVkVMID0gYmluZGluZy5aX0RFRkFVTFRfQ09NUFJFU1NJT047XG5cbi8vIGV4cG9zZSBhbGwgdGhlIHpsaWIgY29uc3RhbnRzXG5PYmplY3Qua2V5cyhiaW5kaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgaWYgKGsubWF0Y2goL15aLykpIGV4cG9ydHNba10gPSBiaW5kaW5nW2tdO1xufSk7XG5cbi8vIHRyYW5zbGF0aW9uIHRhYmxlIGZvciByZXR1cm4gY29kZXMuXG5leHBvcnRzLmNvZGVzID0ge1xuICBaX09LOiBiaW5kaW5nLlpfT0ssXG4gIFpfU1RSRUFNX0VORDogYmluZGluZy5aX1NUUkVBTV9FTkQsXG4gIFpfTkVFRF9ESUNUOiBiaW5kaW5nLlpfTkVFRF9ESUNULFxuICBaX0VSUk5POiBiaW5kaW5nLlpfRVJSTk8sXG4gIFpfU1RSRUFNX0VSUk9SOiBiaW5kaW5nLlpfU1RSRUFNX0VSUk9SLFxuICBaX0RBVEFfRVJST1I6IGJpbmRpbmcuWl9EQVRBX0VSUk9SLFxuICBaX01FTV9FUlJPUjogYmluZGluZy5aX01FTV9FUlJPUixcbiAgWl9CVUZfRVJST1I6IGJpbmRpbmcuWl9CVUZfRVJST1IsXG4gIFpfVkVSU0lPTl9FUlJPUjogYmluZGluZy5aX1ZFUlNJT05fRVJST1Jcbn07XG5cbk9iamVjdC5rZXlzKGV4cG9ydHMuY29kZXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBleHBvcnRzLmNvZGVzW2V4cG9ydHMuY29kZXNba11dID0gaztcbn0pO1xuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuR3ppcCA9IEd6aXA7XG5leHBvcnRzLkd1bnppcCA9IEd1bnppcDtcbmV4cG9ydHMuRGVmbGF0ZVJhdyA9IERlZmxhdGVSYXc7XG5leHBvcnRzLkluZmxhdGVSYXcgPSBJbmZsYXRlUmF3O1xuZXhwb3J0cy5VbnppcCA9IFVuemlwO1xuXG5leHBvcnRzLmNyZWF0ZURlZmxhdGUgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBJbmZsYXRlKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVEZWZsYXRlUmF3ID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IERlZmxhdGVSYXcobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUluZmxhdGVSYXcgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3ppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBHemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVHdW56aXAgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgR3VuemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVVbnppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBVbnppcChvKTtcbn07XG5cblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kcy5cbi8vIGNvbXByZXNzL2RlY29tcHJlc3MgYSBzdHJpbmcgb3IgYnVmZmVyIGluIG9uZSBzdGVwLlxuZXhwb3J0cy5kZWZsYXRlID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5nemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHemlwKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZ3ppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBHemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy51bnppcCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgVW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy51bnppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuZ3VuemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5ndW56aXBTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgR3VuemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3ID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZnVuY3Rpb24gemxpYkJ1ZmZlcihlbmdpbmUsIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIG5yZWFkID0gMDtcblxuICBlbmdpbmUub24oJ2Vycm9yJywgb25FcnJvcik7XG4gIGVuZ2luZS5vbignZW5kJywgb25FbmQpO1xuXG4gIGVuZ2luZS5lbmQoYnVmZmVyKTtcbiAgZmxvdygpO1xuXG4gIGZ1bmN0aW9uIGZsb3coKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIHdoaWxlIChudWxsICE9PSAoY2h1bmsgPSBlbmdpbmUucmVhZCgpKSkge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgZW5naW5lLm9uY2UoJ3JlYWRhYmxlJywgZmxvdyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBmbG93KTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICBjYWxsYmFjayhudWxsLCBidWYpO1xuICAgIGVuZ2luZS5jbG9zZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXJTeW5jKGVuZ2luZSwgYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgc3RyaW5nIG9yIGJ1ZmZlcicpO1xuXG4gIHZhciBmbHVzaEZsYWcgPSBiaW5kaW5nLlpfRklOSVNIO1xuXG4gIHJldHVybiBlbmdpbmUuX3Byb2Nlc3NDaHVuayhidWZmZXIsIGZsdXNoRmxhZyk7XG59XG5cbi8vIGdlbmVyaWMgemxpYlxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEUpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEUpO1xufVxuXG5cblxuLy8gZ3ppcCAtIGJpZ2dlciBoZWFkZXIsIHNhbWUgZGVmbGF0ZSBjb21wcmVzc2lvblxuZnVuY3Rpb24gR3ppcChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHemlwKSkgcmV0dXJuIG5ldyBHemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HWklQKTtcbn1cblxuZnVuY3Rpb24gR3VuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd1bnppcCkpIHJldHVybiBuZXcgR3VuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HVU5aSVApO1xufVxuXG5cblxuLy8gcmF3IC0gbm8gaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlUmF3KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGVSYXcpKSByZXR1cm4gbmV3IERlZmxhdGVSYXcob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEVSQVcpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlUmF3KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGVSYXcpKSByZXR1cm4gbmV3IEluZmxhdGVSYXcob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEVSQVcpO1xufVxuXG5cbi8vIGF1dG8tZGV0ZWN0IGhlYWRlci5cbmZ1bmN0aW9uIFVuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVuemlwKSkgcmV0dXJuIG5ldyBVbnppcChvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuVU5aSVApO1xufVxuXG5cbi8vIHRoZSBabGliIGNsYXNzIHRoZXkgYWxsIGluaGVyaXQgZnJvbVxuLy8gVGhpcyB0aGluZyBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiByZXF1ZXN0cywgYW5kIHJldHVybnNcbi8vIHRydWUgb3IgZmFsc2UgaWYgdGhlcmUgaXMgYW55dGhpbmcgaW4gdGhlIHF1ZXVlIHdoZW5cbi8vIHlvdSBjYWxsIHRoZSAud3JpdGUoKSBtZXRob2QuXG5cbmZ1bmN0aW9uIFpsaWIob3B0cywgbW9kZSkge1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX2NodW5rU2l6ZSA9IG9wdHMuY2h1bmtTaXplIHx8IGV4cG9ydHMuWl9ERUZBVUxUX0NIVU5LO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChvcHRzLmZsdXNoKSB7XG4gICAgaWYgKG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9OT19GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfUEFSVElBTF9GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfU1lOQ19GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfRlVMTF9GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfRklOSVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9CTE9DSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZsdXNoIGZsYWc6ICcgKyBvcHRzLmZsdXNoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fZmx1c2hGbGFnID0gb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG5cbiAgaWYgKG9wdHMuY2h1bmtTaXplKSB7XG4gICAgaWYgKG9wdHMuY2h1bmtTaXplIDwgZXhwb3J0cy5aX01JTl9DSFVOSyB8fFxuICAgICAgICBvcHRzLmNodW5rU2l6ZSA+IGV4cG9ydHMuWl9NQVhfQ0hVTkspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaHVuayBzaXplOiAnICsgb3B0cy5jaHVua1NpemUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLndpbmRvd0JpdHMpIHtcbiAgICBpZiAob3B0cy53aW5kb3dCaXRzIDwgZXhwb3J0cy5aX01JTl9XSU5ET1dCSVRTIHx8XG4gICAgICAgIG9wdHMud2luZG93Qml0cyA+IGV4cG9ydHMuWl9NQVhfV0lORE9XQklUUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdpbmRvd0JpdHM6ICcgKyBvcHRzLndpbmRvd0JpdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmxldmVsKSB7XG4gICAgaWYgKG9wdHMubGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8XG4gICAgICAgIG9wdHMubGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBvcHRzLmxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tZW1MZXZlbCkge1xuICAgIGlmIChvcHRzLm1lbUxldmVsIDwgZXhwb3J0cy5aX01JTl9NRU1MRVZFTCB8fFxuICAgICAgICBvcHRzLm1lbUxldmVsID4gZXhwb3J0cy5aX01BWF9NRU1MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lbUxldmVsOiAnICsgb3B0cy5tZW1MZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyYXRlZ3kpIHtcbiAgICBpZiAob3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBvcHRzLnN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kaWN0aW9uYXJ5KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0cy5kaWN0aW9uYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpY3Rpb25hcnk6IGl0IHNob3VsZCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2JpbmRpbmcgPSBuZXcgYmluZGluZy5abGliKG1vZGUpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5faGFkRXJyb3IgPSBmYWxzZTtcbiAgdGhpcy5fYmluZGluZy5vbmVycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgZXJybm8pIHtcbiAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2xlYW5seSByZWNvdmVyLlxuICAgIC8vIGNvbnRpbnVpbmcgb25seSBvYnNjdXJlcyBwcm9ibGVtcy5cbiAgICBzZWxmLl9iaW5kaW5nID0gbnVsbDtcbiAgICBzZWxmLl9oYWRFcnJvciA9IHRydWU7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgICBlcnJvci5jb2RlID0gZXhwb3J0cy5jb2Rlc1tlcnJub107XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfTtcblxuICB2YXIgbGV2ZWwgPSBleHBvcnRzLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgaWYgKHR5cGVvZiBvcHRzLmxldmVsID09PSAnbnVtYmVyJykgbGV2ZWwgPSBvcHRzLmxldmVsO1xuXG4gIHZhciBzdHJhdGVneSA9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZO1xuICBpZiAodHlwZW9mIG9wdHMuc3RyYXRlZ3kgPT09ICdudW1iZXInKSBzdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3k7XG5cbiAgdGhpcy5fYmluZGluZy5pbml0KG9wdHMud2luZG93Qml0cyB8fCBleHBvcnRzLlpfREVGQVVMVF9XSU5ET1dCSVRTLFxuICAgICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLm1lbUxldmVsIHx8IGV4cG9ydHMuWl9ERUZBVUxUX01FTUxFVkVMLFxuICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLmRpY3Rpb25hcnkpO1xuXG4gIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5fY2h1bmtTaXplKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCB0aGlzLmNsb3NlKTtcbn1cblxudXRpbC5pbmhlcml0cyhabGliLCBUcmFuc2Zvcm0pO1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3ksIGNhbGxiYWNrKSB7XG4gIGlmIChsZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHxcbiAgICAgIGxldmVsID4gZXhwb3J0cy5aX01BWF9MRVZFTCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsOiAnICsgbGV2ZWwpO1xuICB9XG4gIGlmIChzdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9IVUZGTUFOX09OTFkgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1kpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0cmF0ZWd5OiAnICsgc3RyYXRlZ3kpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xldmVsICE9PSBsZXZlbCB8fCB0aGlzLl9zdHJhdGVneSAhPT0gc3RyYXRlZ3kpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mbHVzaChiaW5kaW5nLlpfU1lOQ19GTFVTSCwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9iaW5kaW5nLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpO1xuICAgICAgaWYgKCFzZWxmLl9oYWRFcnJvcikge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICBzZWxmLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9iaW5kaW5nLnJlc2V0KCk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBfZmx1c2ggZnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSB0cmFuc2Zvcm0gY2xhc3MsXG4vLyBpbnRlcm5hbGx5LCB3aGVuIHRoZSBsYXN0IGNodW5rIGhhcyBiZWVuIHdyaXR0ZW4uXG5abGliLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLl90cmFuc2Zvcm0obmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbn07XG5cblpsaWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oa2luZCwgY2FsbGJhY2spIHtcbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGtpbmQgPT09ICdmdW5jdGlvbicgfHwgKGtpbmQgPT09IHZvaWQgMCAmJiAhY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBraW5kO1xuICAgIGtpbmQgPSBiaW5kaW5nLlpfRlVMTF9GTFVTSDtcbiAgfVxuXG4gIGlmICh3cy5lbmRlZCkge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLmVuZGluZykge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHRoaXMub25jZSgnZW5kJywgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLm5lZWREcmFpbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZsdXNoKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9mbHVzaEZsYWcgPSBraW5kO1xuICAgIHRoaXMud3JpdGUobmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG5cbiAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuICB0aGlzLl9iaW5kaW5nLmNsb3NlKCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5abGliLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgZmx1c2hGbGFnO1xuICB2YXIgd3MgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgZW5kaW5nID0gd3MuZW5kaW5nIHx8IHdzLmVuZGVkO1xuICB2YXIgbGFzdCA9IGVuZGluZyAmJiAoIWNodW5rIHx8IHdzLmxlbmd0aCA9PT0gY2h1bmsubGVuZ3RoKTtcblxuICBpZiAoIWNodW5rID09PSBudWxsICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQnKSk7XG5cbiAgLy8gSWYgaXQncyB0aGUgbGFzdCBjaHVuaywgb3IgYSBmaW5hbCBmbHVzaCwgd2UgdXNlIHRoZSBaX0ZJTklTSCBmbHVzaCBmbGFnLlxuICAvLyBJZiBpdCdzIGV4cGxpY2l0bHkgZmx1c2hpbmcgYXQgc29tZSBvdGhlciB0aW1lLCB0aGVuIHdlIHVzZVxuICAvLyBaX0ZVTExfRkxVU0guIE90aGVyd2lzZSwgdXNlIFpfTk9fRkxVU0ggZm9yIG1heGltdW0gY29tcHJlc3Npb25cbiAgLy8gZ29vZG5lc3MuXG4gIGlmIChsYXN0KVxuICAgIGZsdXNoRmxhZyA9IGJpbmRpbmcuWl9GSU5JU0g7XG4gIGVsc2Uge1xuICAgIGZsdXNoRmxhZyA9IHRoaXMuX2ZsdXNoRmxhZztcbiAgICAvLyBvbmNlIHdlJ3ZlIGZsdXNoZWQgdGhlIGxhc3Qgb2YgdGhlIHF1ZXVlLCBzdG9wIGZsdXNoaW5nIGFuZFxuICAgIC8vIGdvIGJhY2sgdG8gdGhlIG5vcm1hbCBiZWhhdmlvci5cbiAgICBpZiAoY2h1bmsubGVuZ3RoID49IHdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZmx1c2hGbGFnID0gdGhpcy5fb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZywgY2IpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3Byb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGNodW5rLCBmbHVzaEZsYWcsIGNiKSB7XG4gIHZhciBhdmFpbEluQmVmb3JlID0gY2h1bmsgJiYgY2h1bmsubGVuZ3RoO1xuICB2YXIgYXZhaWxPdXRCZWZvcmUgPSB0aGlzLl9jaHVua1NpemUgLSB0aGlzLl9vZmZzZXQ7XG4gIHZhciBpbk9mZiA9IDA7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBhc3luYyA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAoIWFzeW5jKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICB2YXIgbnJlYWQgPSAwO1xuXG4gICAgdmFyIGVycm9yO1xuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oZXIpIHtcbiAgICAgIGVycm9yID0gZXI7XG4gICAgfSk7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5fYmluZGluZy53cml0ZVN5bmMoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLCAvLyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIsIC8vIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG4gICAgfSB3aGlsZSAoIXRoaXMuX2hhZEVycm9yICYmIGNhbGxiYWNrKHJlc1swXSwgcmVzWzFdKSk7XG5cbiAgICBpZiAodGhpcy5faGFkRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgdmFyIHJlcSA9IHRoaXMuX2JpbmRpbmcud3JpdGUoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuaywgLy8gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsIC8vIGluX29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0LCAvL291dF9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG5cbiAgcmVxLmJ1ZmZlciA9IGNodW5rO1xuICByZXEuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBmdW5jdGlvbiBjYWxsYmFjayhhdmFpbEluQWZ0ZXIsIGF2YWlsT3V0QWZ0ZXIpIHtcbiAgICBpZiAoc2VsZi5faGFkRXJyb3IpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgaGF2ZSA9IGF2YWlsT3V0QmVmb3JlIC0gYXZhaWxPdXRBZnRlcjtcbiAgICBhc3NlcnQoaGF2ZSA+PSAwLCAnaGF2ZSBzaG91bGQgbm90IGdvIGRvd24nKTtcblxuICAgIGlmIChoYXZlID4gMCkge1xuICAgICAgdmFyIG91dCA9IHNlbGYuX2J1ZmZlci5zbGljZShzZWxmLl9vZmZzZXQsIHNlbGYuX29mZnNldCArIGhhdmUpO1xuICAgICAgc2VsZi5fb2Zmc2V0ICs9IGhhdmU7XG4gICAgICAvLyBzZXJ2ZSBzb21lIG91dHB1dCB0byB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgc2VsZi5wdXNoKG91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzLnB1c2gob3V0KTtcbiAgICAgICAgbnJlYWQgKz0gb3V0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBleGhhdXN0ZWQgdGhlIG91dHB1dCBidWZmZXIsIG9yIHVzZWQgYWxsIHRoZSBpbnB1dCBjcmVhdGUgYSBuZXcgb25lLlxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwIHx8IHNlbGYuX29mZnNldCA+PSBzZWxmLl9jaHVua1NpemUpIHtcbiAgICAgIGF2YWlsT3V0QmVmb3JlID0gc2VsZi5fY2h1bmtTaXplO1xuICAgICAgc2VsZi5fb2Zmc2V0ID0gMDtcbiAgICAgIHNlbGYuX2J1ZmZlciA9IG5ldyBCdWZmZXIoc2VsZi5fY2h1bmtTaXplKTtcbiAgICB9XG5cbiAgICBpZiAoYXZhaWxPdXRBZnRlciA9PT0gMCkge1xuICAgICAgLy8gTm90IGFjdHVhbGx5IGRvbmUuICBOZWVkIHRvIHJlcHJvY2Vzcy5cbiAgICAgIC8vIEFsc28sIHVwZGF0ZSB0aGUgYXZhaWxJbkJlZm9yZSB0byB0aGUgYXZhaWxJbkFmdGVyIHZhbHVlLFxuICAgICAgLy8gc28gdGhhdCBpZiB3ZSBoYXZlIHRvIGhpdCBpdCBhIHRoaXJkIChmb3VydGgsIGV0Yy4pIHRpbWUsXG4gICAgICAvLyBpdCdsbCBoYXZlIHRoZSBjb3JyZWN0IGJ5dGUgY291bnRzLlxuICAgICAgaW5PZmYgKz0gKGF2YWlsSW5CZWZvcmUgLSBhdmFpbEluQWZ0ZXIpO1xuICAgICAgYXZhaWxJbkJlZm9yZSA9IGF2YWlsSW5BZnRlcjtcblxuICAgICAgaWYgKCFhc3luYylcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIHZhciBuZXdSZXEgPSBzZWxmLl9iaW5kaW5nLndyaXRlKGZsdXNoRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2h1bmtTaXplKTtcbiAgICAgIG5ld1JlcS5jYWxsYmFjayA9IGNhbGxiYWNrOyAvLyB0aGlzIHNhbWUgZnVuY3Rpb25cbiAgICAgIG5ld1JlcS5idWZmZXIgPSBjaHVuaztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFzeW5jKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZmluaXNoZWQgd2l0aCB0aGUgY2h1bmsuXG4gICAgY2IoKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhEZWZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd6aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHdW56aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhEZWZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKFVuemlwLCBabGliKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXI7XG52YXIgU2xvd0J1ZmZlciA9IGJ1ZmZlci5TbG93QnVmZmVyO1xudmFyIE1BWF9MRU4gPSBidWZmZXIua01heExlbmd0aCB8fCAyMTQ3NDgzNjQ3O1xuZXhwb3J0cy5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IG5vdCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgdmFyIGVuYyA9IGVuY29kaW5nO1xuICB2YXIgX2ZpbGwgPSBmaWxsO1xuICBpZiAoX2ZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuYyA9IHVuZGVmaW5lZDtcbiAgICBfZmlsbCA9IDA7XG4gIH1cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIGlmICh0eXBlb2YgX2ZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGZpbGxCdWYgPSBuZXcgQnVmZmVyKF9maWxsLCBlbmMpO1xuICAgIHZhciBmbGVuID0gZmlsbEJ1Zi5sZW5ndGg7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgc2l6ZSkge1xuICAgICAgYnVmW2ldID0gZmlsbEJ1ZltpICUgZmxlbl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKF9maWxsKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbn1cbmV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nICYmICghZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgVWludDhBcnJheS5mcm9tICE9PSBCdWZmZXIuZnJvbSkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIG9mZnNldCA9IGVuY29kaW5nT3JPZmZzZXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICB2YXIgbGVuID0gbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgbGVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldDtcbiAgICB9XG4gICAgaWYgKG9mZnNldCA+PSB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKGxlbiA+IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICB2YWx1ZS5jb3B5KG91dCwgMCwgMCwgdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgJyArICdBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZVNsb3coc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPj0gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzaXplKTtcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIEZMT0FUMzJfVklFVyA9IG5ldyBGbG9hdDMyQXJyYXkoIDEgKTtcbnZhciBVSU5UMzJfVklFVyA9IG5ldyBVaW50MzJBcnJheSggRkxPQVQzMl9WSUVXLmJ1ZmZlciApO1xuXG4vLyAxIDExMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IDQyODY1Nzg2ODggPT4gMHhmZjgwMDAwMCAoc2VlIElFRUUgNzU0LTIwMDgpXG52YXIgTklORiA9IDB4ZmY4MDAwMDA7XG5cbi8vIFNldCB0aGUgQXJyYXlCdWZmZXIgYml0IHNlcXVlbmNlOlxuVUlOVDMyX1ZJRVdbIDAgXSA9IE5JTkY7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMT0FUMzJfVklFV1sgMCBdO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIEZMT0FUMzJfVklFVyA9IG5ldyBGbG9hdDMyQXJyYXkoIDEgKTtcbnZhciBVSU5UMzJfVklFVyA9IG5ldyBVaW50MzJBcnJheSggRkxPQVQzMl9WSUVXLmJ1ZmZlciApO1xuXG4vLyAwIDExMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IDIxMzkwOTUwNDAgPT4gMHg3ZjgwMDAwMCAoc2VlIElFRUUgNzU0LTIwMDgpXG52YXIgUElORiA9IDB4N2Y4MDAwMDA7XG5cbi8vIFNldCB0aGUgQXJyYXlCdWZmZXIgYml0IHNlcXVlbmNlOlxuVUlOVDMyX1ZJRVdbIDAgXSA9IFBJTkY7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMT0FUMzJfVklFV1sgMCBdO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyohIGRpY29tLXBhcnNlciAtIHYxLjcuMyAtIDIwMTYtMDgtMTggfCAoYykgMjAxNCBDaHJpcyBIYWZleSB8IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFmZXkvZGljb21QYXJzZXIgKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXG4gICAgLy8gbm9kZS5qc1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgaWYodHlwZW9mIGNvcm5lcnN0b25lID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuXG4gICAgICAgICAgICAvLyBtZXRlb3JcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUGFja2FnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByb290LmRpY29tUGFyc2VyID0gZGljb21QYXJzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGljb21QYXJzZXIgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbi8qKlxuICogUGFyc2VzIGEgRElDT00gUDEwIGJ5dGUgYXJyYXkgYW5kIHJldHVybnMgYSBEYXRhU2V0IG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgZWxlbWVudHMuICBJZiB0aGUgb3B0aW9uc1xuICogYXJndW1lbnQgaXMgc3VwcGxpZWQgYW5kIGl0IGNvbnRhaW5zIHRoZSB1bnRpbFRhZyBwcm9wZXJ0eSwgcGFyc2luZyB3aWxsIHN0b3Agb25jZSB0aGF0XG4gKiB0YWcgaXMgZW5jb3V0ZXJlZC4gIFRoaXMgY2FuIGJlIHVzZWQgdG8gcGFyc2UgcGFydGlhbCBieXRlIHN0cmVhbXMuXG4gKlxuICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheVxuICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHRvIGNvbnRyb2wgcGFyc2luZyBiZWhhdmlvciAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7RGF0YVNldH1cbiAqIEB0aHJvd3MgZXJyb3IgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHBhcnNpbmcuICBUaGUgZXhjZXB0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gYSBwcm9wZXJ0eSBkYXRhU2V0IHdpdGggdGhlXG4gKiAgICAgICAgIGVsZW1lbnRzIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYmVmb3JlIHRoZSBlcnJvci5cbiAqL1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uKGRpY29tUGFyc2VyKSB7XG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIucGFyc2VEaWNvbSA9IGZ1bmN0aW9uKGJ5dGVBcnJheSwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmKGJ5dGVBcnJheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnBhcnNlRGljb206IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlQXJyYXknXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVHJhbnNmZXJTeW50YXgobWV0YUhlYWRlckRhdGFTZXQpIHtcbiAgICAgICAgICAgIGlmKG1ldGFIZWFkZXJEYXRhU2V0LmVsZW1lbnRzLngwMDAyMDAxMCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLnBhcnNlRGljb206IG1pc3NpbmcgcmVxdWlyZWQgbWV0YSBoZWFkZXIgYXR0cmlidXRlIDAwMDIsMDAxMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNmZXJTeW50YXhFbGVtZW50ID0gbWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHMueDAwMDIwMDEwO1xuICAgICAgICAgICAgcmV0dXJuIGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyhieXRlQXJyYXksIHRyYW5zZmVyU3ludGF4RWxlbWVudC5kYXRhT2Zmc2V0LCB0cmFuc2ZlclN5bnRheEVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzRXhwbGljaXQodHJhbnNmZXJTeW50YXgpIHtcbiAgICAgICAgICAgIGlmKHRyYW5zZmVyU3ludGF4ID09PSAnMS4yLjg0MC4xMDAwOC4xLjInKSAvLyBpbXBsaWNpdCBsaXR0bGUgZW5kaWFuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWxsIG90aGVyIHRyYW5zZmVyIHN5bnRheGVzIHNob3VsZCBiZSBleHBsaWNpdFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXREYXRhU2V0Qnl0ZVN0cmVhbSh0cmFuc2ZlclN5bnRheCwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmKHRyYW5zZmVyU3ludGF4ID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMS45OScpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYW4gaW5mYWx0ZXIgY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZCwgdXNlIGl0XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmZsYXRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbEJ5dGVBcnJheUNhbGxiYWNrID0gb3B0aW9ucy5pbmZsYXRlcihieXRlQXJyYXksIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciwgZnVsbEJ5dGVBcnJheUNhbGxiYWNrLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgcnVubmluZyBvbiBub2RlLCB1c2UgdGhlIHpsaWIgbGlicmFyeSB0byBpbmZsYXRlXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MjI0NjA2L2hvdy10by1jaGVjay13aGV0aGVyLWEtc2NyaXB0LWlzLXJ1bm5pbmctdW5kZXItbm9kZS1qc1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHRoaXMubW9kdWxlICE9PSBtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5mbGF0ZSBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmxhdGVkQnVmZmVyID0gZGljb21QYXJzZXIuc2hhcmVkQ29weShieXRlQXJyYXksIHBvc2l0aW9uLCBieXRlQXJyYXkubGVuZ3RoIC0gcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZWRCdWZmZXIgPSB6bGliLmluZmxhdGVSYXdTeW5jKGRlZmxhdGVkQnVmZmVyKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBzaW5nbGUgYnl0ZSBhcnJheSB3aXRoIHRoZSBmdWxsIGhlYWRlciBieXRlcyBhbmQgdGhlIGluZmxhdGVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxsQnl0ZUFycmF5QnVmZmVyID0gZGljb21QYXJzZXIuYWxsb2MoYnl0ZUFycmF5LCBpbmZsYXRlZEJ1ZmZlci5sZW5ndGggKyBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5jb3B5KGZ1bGxCeXRlQXJyYXlCdWZmZXIsIDAsIDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaW5mbGF0ZWRCdWZmZXIuY29weShmdWxsQnl0ZUFycmF5QnVmZmVyLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGZ1bGxCeXRlQXJyYXlCdWZmZXIsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBwYWtvIGlzIGRlZmluZWQgLSB1c2UgaXQuICBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBwYXRoXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvXG4gICAgICAgICAgICAgICAgZWxzZSBpZih0eXBlb2YgcGFrbyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmZsYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZsYXRlZCA9IGJ5dGVBcnJheS5zbGljZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlZCA9IHBha28uaW5mbGF0ZVJhdyhkZWZsYXRlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgc2luZ2xlIGJ5dGUgYXJyYXkgd2l0aCB0aGUgZnVsbCBoZWFkZXIgYnl0ZXMgYW5kIHRoZSBpbmZsYXRlZCBieXRlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbEJ5dGVBcnJheSA9IGRpY29tUGFyc2VyLmFsbG9jKGJ5dGVBcnJheSwgaW5mbGF0ZWQubGVuZ3RoICsgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBmdWxsQnl0ZUFycmF5LnNldChieXRlQXJyYXkuc2xpY2UoMCwgcG9zaXRpb24pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbEJ5dGVBcnJheS5zZXQoaW5mbGF0ZWQsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciwgZnVsbEJ5dGVBcnJheSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRocm93IGV4Y2VwdGlvbiBzaW5jZSBubyBpbmZsYXRlciBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLnBhcnNlRGljb206IG5vIGluZmxhdGVyIGF2YWlsYWJsZSB0byBoYW5kbGUgZGVmbGF0ZSB0cmFuc2ZlciBzeW50YXgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRyYW5zZmVyU3ludGF4ID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMicpIC8vIGV4cGxpY2l0IGJpZyBlbmRpYW5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIuYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXksIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNmZXIgc3ludGF4ZXMgYXJlIGxpdHRsZSBlbmRpYW47IG9ubHkgdGhlIHBpeGVsIGVuY29kaW5nIGRpZmZlcnNcbiAgICAgICAgICAgICAgICAvLyBtYWtlIGEgbmV3IHN0cmVhbSBzbyB0aGUgbWV0YWhlYWRlciB3YXJuaW5ncyBkb24ndCBjb21lIGFsb25nIGZvciB0aGUgcmlkZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGJ5dGVBcnJheSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VEYXRhU2V0cyhtZXRhSGVhZGVyRGF0YVNldCwgaW5zdGFuY2VEYXRhU2V0KVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gbWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYobWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlRGF0YVNldC5lbGVtZW50c1twcm9wZXJ0eU5hbWVdID0gbWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0YUhlYWRlckRhdGFTZXQud2FybmluZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlRGF0YVNldC53YXJuaW5ncyA9IG1ldGFIZWFkZXJEYXRhU2V0Lndhcm5pbmdzLmNvbmNhdChpbnN0YW5jZURhdGFTZXQud2FybmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlRGF0YVNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREYXRhU2V0KG1ldGFIZWFkZXJEYXRhU2V0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmZXJTeW50YXggPSByZWFkVHJhbnNmZXJTeW50YXgobWV0YUhlYWRlckRhdGFTZXQpO1xuICAgICAgICAgICAgdmFyIGV4cGxpY2l0ID0gaXNFeHBsaWNpdCh0cmFuc2ZlclN5bnRheCk7XG4gICAgICAgICAgICB2YXIgZGF0YVNldEJ5dGVTdHJlYW0gPSBnZXREYXRhU2V0Qnl0ZVN0cmVhbSh0cmFuc2ZlclN5bnRheCwgbWV0YUhlYWRlckRhdGFTZXQucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBkYXRhU2V0ID0gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoZGF0YVNldEJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBkYXRhU2V0Qnl0ZVN0cmVhbS5ieXRlQXJyYXksIGVsZW1lbnRzKTtcbiAgICAgICAgICAgIGRhdGFTZXQud2FybmluZ3MgPSBkYXRhU2V0Qnl0ZVN0cmVhbS53YXJuaW5ncztcblxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIGlmKGV4cGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQoZGF0YVNldCwgZGF0YVNldEJ5dGVTdHJlYW0sIGRhdGFTZXRCeXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEltcGxpY2l0KGRhdGFTZXQsIGRhdGFTZXRCeXRlU3RyZWFtLCBkYXRhU2V0Qnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4ID0ge1xuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb246IGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFTZXQ6IGRhdGFTZXRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFTZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWluIGZ1bmN0aW9uIGhlcmVcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VUaGVCeXRlU3RyZWFtKCkge1xuICAgICAgICAgICAgdmFyIG1ldGFIZWFkZXJEYXRhU2V0ID0gZGljb21QYXJzZXIucmVhZFBhcnQxMEhlYWRlcihieXRlQXJyYXksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YVNldCA9IHJlYWREYXRhU2V0KG1ldGFIZWFkZXJEYXRhU2V0KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YVNldHMobWV0YUhlYWRlckRhdGFTZXQsIGRhdGFTZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyB3aGVyZSB3ZSBhY3R1YWxseSBzdGFydCBwYXJzaW5nXG4gICAgICAgIHJldHVybiBwYXJzZVRoZUJ5dGVTdHJlYW0oKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufSkoZGljb21QYXJzZXIpO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgYmFzaWMgb2Zmc2V0IHRhYmxlIGZvciBKUEVHIHRyYW5zZmVyIHN5bnRheGVzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICAvLyBFYWNoIEpQRUcgaW1hZ2UgaGFzIGFuIGVuZCBvZiBpbWFnZSBtYXJrZXIgMHhGRkQ5XG4gIGZ1bmN0aW9uIGlzRW5kT2ZJbWFnZU1hcmtlcihkYXRhU2V0LCBwb3NpdGlvbikge1xuICAgIHJldHVybiAoZGF0YVNldC5ieXRlQXJyYXlbcG9zaXRpb25dID09PSAweEZGICYmXG4gICAgZGF0YVNldC5ieXRlQXJyYXlbcG9zaXRpb24gKyAxXSA9PT0gMHhEOSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZyYWdtZW50RW5kT2ZJbWFnZShkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFnbWVudEluZGV4KSB7XG4gICAgdmFyIGZyYWdtZW50ID0gcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHNbZnJhZ21lbnRJbmRleF07XG4gICAgLy8gTmVlZCB0byBjaGVjayB0aGUgbGFzdCB0d28gYnl0ZXMgYW5kIHRoZSBsYXN0IHRocmVlIGJ5dGVzIGZvciBtYXJrZXIgc2luY2Ugb2RkIGxlbmd0aFxuICAgIC8vIGZyYWdtZW50cyBhcmUgemVybyBwYWRkZWRcbiAgICBpZihpc0VuZE9mSW1hZ2VNYXJrZXIoZGF0YVNldCwgZnJhZ21lbnQucG9zaXRpb24gKyBmcmFnbWVudC5sZW5ndGggLSAyKSB8fFxuICAgICAgaXNFbmRPZkltYWdlTWFya2VyKGRhdGFTZXQsIGZyYWdtZW50LnBvc2l0aW9uICsgZnJhZ21lbnQubGVuZ3RoIC0gMykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTGFzdEltYWdlRnJhbWVGcmFnbWVudEluZGV4KGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIHN0YXJ0RnJhZ21lbnQpIHtcbiAgICBmb3IodmFyIGZyYWdtZW50SW5kZXg9c3RhcnRGcmFnbWVudDsgZnJhZ21lbnRJbmRleCA8IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aDsgZnJhZ21lbnRJbmRleCsrKSB7XG4gICAgICBpZihpc0ZyYWdtZW50RW5kT2ZJbWFnZShkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFnbWVudEluZGV4KSkge1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJhc2ljIG9mZnNldCB0YWJsZSBieSBzY2FubmluZyBmcmFnbWVudHMgZm9yIEpQRUcgc3RhcnQgb2YgaW1hZ2UgYW5kIGVuZCBPZiBJbWFnZSBtYXJrZXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhU2V0IC0gdGhlIHBhcnNlZCBkaWNvbSBkYXRhc2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwaXhlbERhdGFFbGVtZW50IC0gdGhlIHBpeGVsIGRhdGEgZWxlbWVudFxuICAgKiBAcGFyYW0gW2ZyYWdtZW50c10gLSBvcHRpb25hbCBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgZWFjaCBmcmFnbWVudCAob2Zmc2V0LCBwb3NpdGlvbiwgbGVuZ3RoKVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGJhc2ljIG9mZnNldCB0YWJsZSAoYXJyYXkgb2Ygb2Zmc2V0cyB0byBiZWdpbm5pbmcgb2YgZWFjaCBmcmFtZSlcbiAgICovXG4gIGRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlID0gZnVuY3Rpb24oZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhZ21lbnRzKSB7XG4gICAgLy8gVmFsaWRhdGUgcGFyYW1ldGVyc1xuICAgIGlmKGRhdGFTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBkYXRhU2V0JztcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyAnZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIHBpeGVsRGF0YUVsZW1lbnQnO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LnRhZyAhPT0gJ3g3ZmUwMDAxMCcpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIG5vbiBwaXhlbCBkYXRhIHRhZyAoZXhwZWN0ZWQgdGFnID0geDdmZTAwMDEwJ1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmVuY2Fwc3VsYXRlZFBpeGVsRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKGZyYWdtZW50cyAmJiBmcmFnbWVudHMubGVuZ3RoIDw9MCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdmcmFnbWVudHMnIG11c3Qgbm90IGJlIHplcm8gbGVuZ3RoXCI7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB2YWx1ZXNcbiAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMgfHwgcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHM7XG5cbiAgICB2YXIgYmFzaWNPZmZzZXRUYWJsZSA9IFtdO1xuXG4gICAgdmFyIHN0YXJ0RnJhZ21lbnRJbmRleCA9IDA7XG5cbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAvLyBBZGQgdGhlIG9mZnNldCBmb3IgdGhlIHN0YXJ0IGZyYWdtZW50XG4gICAgICBiYXNpY09mZnNldFRhYmxlLnB1c2gocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHNbc3RhcnRGcmFnbWVudEluZGV4XS5vZmZzZXQpO1xuICAgICAgdmFyIGVuZEZyYWdtZW50SW5kZXggPSBmaW5kTGFzdEltYWdlRnJhbWVGcmFnbWVudEluZGV4KGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIHN0YXJ0RnJhZ21lbnRJbmRleCk7XG4gICAgICBpZihlbmRGcmFnbWVudEluZGV4ID09PSB1bmRlZmluZWQgfHwgZW5kRnJhZ21lbnRJbmRleCA9PT0gcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMubGVuZ3RoIC0xKSB7XG4gICAgICAgIHJldHVybiBiYXNpY09mZnNldFRhYmxlO1xuICAgICAgfVxuICAgICAgc3RhcnRGcmFnbWVudEluZGV4ID0gZW5kRnJhZ21lbnRJbmRleCArIDE7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgYW4gZXhwbGljaXQgZGF0YVNldCB0byBhIGphdmFzY3JpcHQgb2JqZWN0XG4gICAgICogQHBhcmFtIGRhdGFTZXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmV4cGxpY2l0RGF0YVNldFRvSlMgPSBmdW5jdGlvbiAoZGF0YVNldCwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmKGRhdGFTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmV4cGxpY2l0RGF0YVNldFRvSlM6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGRhdGFTZXQnO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgb21pdFByaXZhdGVBdHRpYnV0ZXM6IHRydWUsIC8vIHRydWUgaWYgcHJpdmF0ZSBlbGVtZW50cyBzaG91bGQgYmUgb21pdHRlZFxuICAgICAgICAgICAgbWF4RWxlbWVudExlbmd0aCA6IDEyOCAgICAgIC8vIG1heGltdW0gZWxlbWVudCBsZW5ndGggdG8gdHJ5IGFuZCBjb252ZXJ0IHRvIHN0cmluZyBmb3JtYXRcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yKHZhciB0YWcgaW4gZGF0YVNldC5lbGVtZW50cykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkYXRhU2V0LmVsZW1lbnRzW3RhZ107XG5cbiAgICAgICAgICAgIC8vIHNraXAgdGhpcyBlbGVtZW50IGlmIGl0IGEgcHJpdmF0ZSBlbGVtZW50IGFuZCBvdXIgb3B0aW9ucyBzcGVjaWZ5IHRoYXQgd2Ugc2hvdWxkXG4gICAgICAgICAgICBpZihvcHRpb25zLm9taXRQcml2YXRlQXR0aWJ1dGVzID09PSB0cnVlICYmIGRpY29tUGFyc2VyLmlzUHJpdmF0ZVRhZyh0YWcpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlbGVtZW50Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIHZhciBzZXF1ZW5jZUl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBlbGVtZW50Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSXRlbXMucHVzaChkaWNvbVBhcnNlci5leHBsaWNpdERhdGFTZXRUb0pTKGVsZW1lbnQuaXRlbXNbaV0uZGF0YVNldCwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbdGFnXSA9IHNlcXVlbmNlSXRlbXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhc1N0cmluZztcbiAgICAgICAgICAgICAgICBhc1N0cmluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA8IG9wdGlvbnMubWF4RWxlbWVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhc1N0cmluZyA9IGRpY29tUGFyc2VyLmV4cGxpY2l0RWxlbWVudFRvU3RyaW5nKGRhdGFTZXQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGFzU3RyaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3RhZ10gPSBhc1N0cmluZztcbiAgICAgICAgICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3RhZ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0OiBlbGVtZW50LmRhdGFPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggOiBlbGVtZW50Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBleHBsaWNpdCBWUiBlbGVtZW50IHRvIGEgc3RyaW5nIG9yIHVuZGVmaW5lZCBpZiBpdCBpcyBub3QgcG9zc2libGUgdG8gY29udmVydC5cbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gaW1wbGljaXQgZWxlbWVudCBpcyBzdXBwbGllZFxuICAgICAqIEBwYXJhbSBkYXRhU2V0XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5leHBsaWNpdEVsZW1lbnRUb1N0cmluZyA9IGZ1bmN0aW9uKGRhdGFTZXQsIGVsZW1lbnQpXG4gICAge1xuICAgICAgICBpZihkYXRhU2V0ID09PSB1bmRlZmluZWQgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIuZXhwbGljaXRFbGVtZW50VG9TdHJpbmc6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVycyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZWxlbWVudC52ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIuZXhwbGljaXRFbGVtZW50VG9TdHJpbmc6IGNhbm5vdCBjb252ZXJ0IGltcGxpY2l0IGVsZW1lbnQgdG8gc3RyaW5nJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdnIgPSBlbGVtZW50LnZyO1xuICAgICAgICB2YXIgdGFnID0gZWxlbWVudC50YWc7XG5cbiAgICAgICAgdmFyIHRleHRSZXN1bHQ7XG5cbiAgICAgICAgZnVuY3Rpb24gbXVsdGlFbGVtZW50VG9TdHJpbmcobnVtSXRlbXMsIGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBudW1JdGVtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZnVuYy5jYWxsKGRhdGFTZXQsIHRhZywgaSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihkaWNvbVBhcnNlci5pc1N0cmluZ1ZyKHZyKSA9PT0gdHJ1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IGRhdGFTZXQuc3RyaW5nKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodnIgPT0gJ0FUJykge1xuICAgICAgICAgICAgdmFyIG51bSA9IGRhdGFTZXQudWludDMyKHRhZyk7XG4gICAgICAgICAgICBpZihudW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtIDwgMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW0gPSAweEZGRkZGRkZGICsgbnVtICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICd4JyArIG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ciA9PSAnVVMnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0UmVzdWx0ID0gbXVsdGlFbGVtZW50VG9TdHJpbmcoZWxlbWVudC5sZW5ndGggLyAyLCBkYXRhU2V0LnVpbnQxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih2ciA9PT0gJ1NTJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gMiwgZGF0YVNldC5pbnQxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodnIgPT0gJ1VMJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gNCwgZGF0YVNldC51aW50MzIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodnIgPT09ICdTTCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRSZXN1bHQgPSBtdWx0aUVsZW1lbnRUb1N0cmluZyhlbGVtZW50Lmxlbmd0aCAvIDQsIGRhdGFTZXQuaW50MzIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodnIgPT0gJ0ZEJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gOCwgZGF0YVNldC5kb3VibGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodnIgPT0gJ0ZMJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gNCwgZGF0YVNldC5mbG9hdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dFJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBESUNPTVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLy8gYWxnb3JpdGhtIGJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQzMzAzMC92YWxpZGF0ZS1udW1iZXItb2YtZGF5cy1pbi1hLWdpdmVuLW1vbnRoXG4gIGZ1bmN0aW9uIGRheXNJbk1vbnRoKG0sIHkpIHsgLy8gbSBpcyAwIGluZGV4ZWQ6IDAtMTFcbiAgICBzd2l0Y2ggKG0pIHtcbiAgICAgIGNhc2UgMiA6XG4gICAgICAgIHJldHVybiAoeSAlIDQgPT0gMCAmJiB5ICUgMTAwKSB8fCB5ICUgNDAwID09IDAgPyAyOSA6IDI4O1xuICAgICAgY2FzZSA5IDogY2FzZSA0IDogY2FzZSA2IDogY2FzZSAxMSA6XG4gICAgICByZXR1cm4gMzA7XG4gICAgICBkZWZhdWx0IDpcbiAgICAgICAgcmV0dXJuIDMxXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZERhdGUoZCwgbSwgeSkge1xuICAgIC8vIG1ha2UgeWVhciBpcyBhIG51bWJlclxuICAgIGlmKGlzTmFOKHkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtID4gMCAmJiBtIDw9IDEyICYmIGQgPiAwICYmIGQgPD0gZGF5c0luTW9udGgobSwgeSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBEQSBmb3JtYXR0ZWQgc3RyaW5nIGludG8gYSBKYXZhc2NyaXB0IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSBhIHN0cmluZyBpbiB0aGUgREEgVlIgZm9ybWF0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlXSAtIHRydWUgaWYgYW4gZXhjZXB0aW9uIHNob3VsZCBiZSB0aHJvd24gaWYgdGhlIGRhdGUgaXMgaW52YWxpZFxuICAgKiBAcmV0dXJucyB7Kn0gSmF2YXNjcmlwdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHllYXIsIG1vbnRoIGFuZCBkYXkgb3IgdW5kZWZpbmVkIGlmIG5vdCBwcmVzZW50IG9yIG5vdCA4IGJ5dGVzIGxvbmdcbiAgICovXG4gIGRpY29tUGFyc2VyLnBhcnNlREEgPSBmdW5jdGlvbihkYXRlLCB2YWxpZGF0ZSlcbiAge1xuICAgIGlmKGRhdGUgJiYgZGF0ZS5sZW5ndGggPT09IDgpXG4gICAge1xuICAgICAgdmFyIHl5eXkgPSBwYXJzZUludChkYXRlLnN1YnN0cmluZygwLCA0KSwgMTApO1xuICAgICAgdmFyIG1tID0gcGFyc2VJbnQoZGF0ZS5zdWJzdHJpbmcoNCwgNiksIDEwKTtcbiAgICAgIHZhciBkZCA9IHBhcnNlSW50KGRhdGUuc3Vic3RyaW5nKDYsIDgpLCAxMCk7XG5cbiAgICAgIGlmKHZhbGlkYXRlKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZShkZCwgbW0sIHl5eXkpICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgXCJpbnZhbGlkIERBICdcIiArIGRhdGUgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogeXl5eSxcbiAgICAgICAgbW9udGg6IG1tLFxuICAgICAgICBkYXk6IGRkXG4gICAgICB9O1xuICAgIH1cbiAgICBpZih2YWxpZGF0ZSkge1xuICAgICAgdGhyb3cgXCJpbnZhbGlkIERBICdcIiArIGRhdGUgKyBcIidcIjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGggRElDT01cbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBUTSBmb3JtYXR0ZWQgc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzIGFuZCBmcmFjdGlvbmFsU2Vjb25kc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZSAtIGEgc3RyaW5nIGluIHRoZSBUTSBWUiBmb3JtYXRcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsaWRhdGVdIC0gdHJ1ZSBpZiBhbiBleGNlcHRpb24gc2hvdWxkIGJlIHRocm93biBpZiB0aGUgZGF0ZSBpcyBpbnZhbGlkXG4gICAqIEByZXR1cm5zIHsqfSBqYXZhc2NyaXB0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzIGFuZCBmcmFjdGlvbmFsU2Vjb25kcyBvciB1bmRlZmluZWQgaWYgbm8gZWxlbWVudCBvciBkYXRhLiAgTWlzc2luZyBmaWVsZHMgYXJlIHNldCB0byB1bmRlZmluZWRcbiAgICovXG4gIGRpY29tUGFyc2VyLnBhcnNlVE0gPSBmdW5jdGlvbih0aW1lLCB2YWxpZGF0ZSkge1xuXG4gICAgaWYgKHRpbWUubGVuZ3RoID49IDIpIC8vIG11c3QgYXQgbGVhc3QgaGF2ZSBISFxuICAgIHtcbiAgICAgIC8vIDAxMjM0NTY3ODlcbiAgICAgIC8vIEhITU1TUy5GRkZGRkZcbiAgICAgIHZhciBoaCA9IHBhcnNlSW50KHRpbWUuc3Vic3RyaW5nKDAsIDIpLCAxMCk7XG4gICAgICB2YXIgbW0gPSB0aW1lLmxlbmd0aCA+PSA0ID8gcGFyc2VJbnQodGltZS5zdWJzdHJpbmcoMiwgNCksIDEwKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzcyA9IHRpbWUubGVuZ3RoID49IDYgPyBwYXJzZUludCh0aW1lLnN1YnN0cmluZyg0LCA2KSwgMTApIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGZmZmZmZiA9IHRpbWUubGVuZ3RoID49IDggPyBwYXJzZUludCh0aW1lLnN1YnN0cmluZyg3LCAxMyksIDEwKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYodmFsaWRhdGUpIHtcbiAgICAgICAgaWYoKGlzTmFOKGhoKSkgfHxcbiAgICAgICAgICAobW0gIT09IHVuZGVmaW5lZCAmJiBpc05hTihtbSkpIHx8XG4gICAgICAgICAgKHNzICE9PSB1bmRlZmluZWQgJiYgaXNOYU4oc3MpKSB8fFxuICAgICAgICAgIChmZmZmZmYgIT09IHVuZGVmaW5lZCAmJiBpc05hTihmZmZmZmYpKSB8fFxuICAgICAgICAgIChoaCA8IDAgfHwgaGggPiAyMykgfHxcbiAgICAgICAgICAobW0gJiYgKG1tIDwwIHx8IG1tID4gNTkpKSAgfHxcbiAgICAgICAgICAoc3MgJiYgKHNzIDwwIHx8IHNzID4gNTkpKSAgfHxcbiAgICAgICAgICAoZmZmZmZmICYmIChmZmZmZmYgPDAgfHwgZmZmZmZmID4gOTk5OTk5KSkpXG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBcImludmFsaWQgVE0gJ1wiICsgdGltZSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhvdXJzOiBoaCxcbiAgICAgICAgbWludXRlczogbW0sXG4gICAgICAgIHNlY29uZHM6IHNzLFxuICAgICAgICBmcmFjdGlvbmFsU2Vjb25kczogZmZmZmZmXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmKHZhbGlkYXRlKSB7XG4gICAgICB0aHJvdyBcImludmFsaWQgVE0gJ1wiICsgdGltZSArIFwiJ1wiO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERJQ09NXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzdHJpbmdWcnMgPSB7XG4gICAgICAgIEFFOiB0cnVlLFxuICAgICAgICBBUzogdHJ1ZSxcbiAgICAgICAgQVQ6IGZhbHNlLFxuICAgICAgICBDUzogdHJ1ZSxcbiAgICAgICAgREE6IHRydWUsXG4gICAgICAgIERTOiB0cnVlLFxuICAgICAgICBEVDogdHJ1ZSxcbiAgICAgICAgRkw6IGZhbHNlLFxuICAgICAgICBGRDogZmFsc2UsXG4gICAgICAgIElTOiB0cnVlLFxuICAgICAgICBMTzogdHJ1ZSxcbiAgICAgICAgTFQ6IHRydWUsXG4gICAgICAgIE9COiBmYWxzZSxcbiAgICAgICAgT0Q6IGZhbHNlLFxuICAgICAgICBPRjogZmFsc2UsXG4gICAgICAgIE9XOiBmYWxzZSxcbiAgICAgICAgUE46IHRydWUsXG4gICAgICAgIFNIOiB0cnVlLFxuICAgICAgICBTTDogZmFsc2UsXG4gICAgICAgIFNROiBmYWxzZSxcbiAgICAgICAgU1M6IGZhbHNlLFxuICAgICAgICBTVDogdHJ1ZSxcbiAgICAgICAgVE06IHRydWUsXG4gICAgICAgIFVJOiB0cnVlLFxuICAgICAgICBVTDogZmFsc2UsXG4gICAgICAgIFVOOiB1bmRlZmluZWQsIC8vIGR1bm5vXG4gICAgICAgIFVSOiB0cnVlLFxuICAgICAgICBVUzogZmFsc2UsXG4gICAgICAgIFVUOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHRvIHNlZSBpZiB2ciBpcyBhIHN0cmluZyBvciBub3QuXG4gICAgICogQHBhcmFtIHZyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBzdHJpbmcsIGZhbHNlIGl0IG5vdCBzdHJpbmcsIHVuZGVmaW5lZCBpZiB1bmtub3duIHZyIG9yIFVOIHR5cGVcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5pc1N0cmluZ1ZyID0gZnVuY3Rpb24odnIpXG4gICAge1xuICAgICAgICByZXR1cm4gc3RyaW5nVnJzW3ZyXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgdG8gc2VlIGlmIGEgZ2l2ZW4gdGFnIGluIHRoZSBmb3JtYXQgeGdnZ2dlZWVlIGlzIGEgcHJpdmF0ZSB0YWcgb3Igbm90XG4gICAgICogQHBhcmFtIHRhZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmlzUHJpdmF0ZVRhZyA9IGZ1bmN0aW9uKHRhZylcbiAgICB7XG4gICAgICAgIHZhciBsYXN0R3JvdXBEaWdpdCA9IHBhcnNlSW50KHRhZ1s0XSk7XG4gICAgICAgIHZhciBncm91cElzT2RkID0gKGxhc3RHcm91cERpZ2l0ICUgMikgPT09IDE7XG4gICAgICAgIHJldHVybiBncm91cElzT2RkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBQTiBmb3JtYXR0ZWQgc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIGdpdmVuTmFtZSwgZmFtaWx5TmFtZSwgbWlkZGxlTmFtZSwgcHJlZml4IGFuZCBzdWZmaXhcbiAgICAgKiBAcGFyYW0gcGVyc29uTmFtZSBhIHN0cmluZyBpbiB0aGUgUE4gVlIgZm9ybWF0XG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHJldHVybnMgeyp9IGphdmFzY3JpcHQgb2JqZWN0IHdpdGggcHJvcGVydGllcyBmb3IgZ2l2ZW5OYW1lLCBmYW1pbHlOYW1lLCBtaWRkbGVOYW1lLCBwcmVmaXggYW5kIHN1ZmZpeCBvciB1bmRlZmluZWQgaWYgbm8gZWxlbWVudCBvciBkYXRhXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucGFyc2VQTiA9IGZ1bmN0aW9uKHBlcnNvbk5hbWUpIHtcbiAgICAgICAgaWYocGVyc29uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZXMgPSBwZXJzb25OYW1lLnNwbGl0KCdeJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmYW1pbHlOYW1lOiBzdHJpbmdWYWx1ZXNbMF0sXG4gICAgICAgICAgICBnaXZlbk5hbWU6IHN0cmluZ1ZhbHVlc1sxXSxcbiAgICAgICAgICAgIG1pZGRsZU5hbWU6IHN0cmluZ1ZhbHVlc1syXSxcbiAgICAgICAgICAgIHByZWZpeDogc3RyaW5nVmFsdWVzWzNdLFxuICAgICAgICAgICAgc3VmZml4OiBzdHJpbmdWYWx1ZXNbNF1cbiAgICAgICAgfTtcbiAgICB9O1xuXG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogRnVuY3Rpb25hbGl0eSBmb3IgZXh0cmFjdGluZyBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRlZE5vdGljZUxvZ2dlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGl4ZWwgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBmcmFtZSBpbiBhbiBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YSBlbGVtZW50LiAgSWYgbm8gYmFzaWMgb2Zmc2V0XG4gICAgICogdGFibGUgaXMgcHJlc2VudCwgaXQgYXNzdW1lcyB0aGF0IGFsbCBmcmFnbWVudHMgYXJlIGZvciBvbmUgZnJhbWUuICBOb3RlIHRoYXQgdGhpcyBhc3N1bXB0aW9uL2xvZ2ljIGlzIG5vdFxuICAgICAqIHZhbGlkIGZvciBtdWx0aS1mcmFtZSBpbnN0YW5jZXMgc28gdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGV2ZW50dWFsbHkgYmUgcmVtb3ZlZC4gIENvZGVcbiAgICAgKiBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2UgcmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHMoKSBvciByZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZSgpXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuNiAtIHVzZSByZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50cygpIG9yIHJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lKClcbiAgICAgKiBAcGFyYW0gZGF0YVNldCAtIHRoZSBkYXRhU2V0IGNvbnRhaW5pbmcgdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gICAgICogQHBhcmFtIHBpeGVsRGF0YUVsZW1lbnQgLSB0aGUgcGl4ZWwgZGF0YSBlbGVtZW50ICh4N2ZlMDAwMTApIHRvIGV4dHJhY3QgdGhlIGZyYW1lIGZyb21cbiAgICAgKiBAcGFyYW0gZnJhbWUgLSB0aGUgemVybyBiYXNlZCBmcmFtZSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHdpdGggdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gICAgICovXG5cblxuICAgIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGEgPSBmdW5jdGlvbihkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFtZSlcbiAgICB7XG4gICAgICAgIGlmKCFkZXByZWNhdGVkTm90aWNlTG9nZ2VkKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkTm90aWNlTG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmKGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGEoKSBoYXMgYmVlbiBkZXByZWNhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGF0YVNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdkYXRhU2V0J1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZWxlbWVudCdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihmcmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdmcmFtZSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LnRhZyAhPT0gJ3g3ZmUwMDAxMCcpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogcGFyYW1ldGVyICdlbGVtZW50JyByZWZlcnMgdG8gbm9uIHBpeGVsIGRhdGEgdGFnIChleHBlY3RlZCB0YWcgPSB4N2ZlMDAwMTAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudC5lbmNhcHN1bGF0ZWRQaXhlbERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogcGFyYW1ldGVyICdlbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IHBhcmFtZXRlciAnZWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBwYXJhbWV0ZXIgJ2VsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBwYXJhbWV0ZXIgJ2VsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZnJhbWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IHBhcmFtZXRlciAnZnJhbWUnIG11c3QgYmUgPj0gMFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGJhc2ljIG9mZnNldCB0YWJsZSBpcyBub3QgZW1wdHksIHdlIGNhbiBleHRyYWN0IHRoZSBmcmFtZVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWUoZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gTm8gYmFzaWMgb2Zmc2V0IHRhYmxlLCBhc3N1bWUgYWxsIGZyYWdtZW50cyBhcmUgZm9yIG9uZSBmcmFtZSAtIE5PVEUgdGhhdCB0aGlzIGlzIE5PVCBhIHZhbGlkXG4gICAgICAgICAgICAvLyBhc3N1bXB0aW9uIGJ1dCBpcyB0aGUgb3JpZ2luYWwgYmVoYXZpb3Igc28gd2UgYXJlIGtlZXBpbmcgaXQgZm9yIG5vd1xuICAgICAgICAgICAgcmV0dXJuIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIDAsIHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuXG4vKipcbiAqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gYWxsb2NhdGUgbmV3IGJ5dGVBcnJheSBidWZmZXJzXG4gKi9cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYnl0ZUFycmF5IG9mIHRoZSBzYW1lIHR5cGUgKFVpbnQ4QXJyYXkgb3IgQnVmZmVyKSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgdW5kZXJseWluZyBieXRlQXJyYXkgKGVpdGhlciBVaW50OEFycmF5IG9yIEJ1ZmZlcilcbiAgICogQHBhcmFtIGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIEJ5dGUgQXJyYXlcbiAgICogQHJldHVybnMge29iamVjdH0gVWludDhBcnJheSBvciBCdWZmZXIgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGJ5dGVBcnJheVxuICAgKi9cbiAgZGljb21QYXJzZXIuYWxsb2MgPSBmdW5jdGlvbihieXRlQXJyYXksIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBieXRlQXJyYXkgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZihieXRlQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmFsbG9jOiB1bmtub3duIHR5cGUgZm9yIGJ5dGVBcnJheSc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBkaWZmZXJlbnQgdHlwZXMgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBkaWNvbVBhcnNlci5iaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJzZXMgYW4gdW5zaWduZWQgaW50IDE2IGZyb20gYSBiaWctZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgdW5zaWduZWQgaW50IDE2XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZFVpbnQxNjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MTY6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyAyID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQxNjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGJ5dGVBcnJheVtwb3NpdGlvbl0gPDwgOCkgKyBieXRlQXJyYXlbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyc2VzIGEgc2lnbmVkIGludCAxNiBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHNpZ25lZCBpbnQgMTZcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkSW50MTY6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MTY6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyAyID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDE2OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnQxNiA9IChieXRlQXJyYXlbcG9zaXRpb25dIDw8IDgpICsgYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgICAgICAvLyBmaXggc2lnblxuICAgICAgICAgICAgaWYgKGludDE2ICYgMHg4MDAwKSB7XG4gICAgICAgICAgICAgICAgaW50MTYgPSBpbnQxNiAtIDB4RkZGRiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50MTY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhbiB1bnNpZ25lZCBpbnQgMzIgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMzJcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkVWludDMyOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQzMjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgNCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MzI6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWludDMyID0gKDI1NiAqICgyNTYgKiAoMjU2ICogYnl0ZUFycmF5W3Bvc2l0aW9uXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXlbcG9zaXRpb24gKyAyXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHVpbnQzMjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGEgc2lnbmVkIGludCAzMiBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHNpZ25lZCBpbnQgMzJcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkSW50MzI6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MzI6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDQgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MzI6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW50MzIgPSAoKGJ5dGVBcnJheVtwb3NpdGlvbl0gPDwgMjQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl0gPDwgOCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXlbcG9zaXRpb24gKyAzXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnQzMjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIDMyLWJpdCBmbG9hdCBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIDMyLWJpdCBmbG9hdFxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRGbG9hdDogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRGbG9hdDogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgNCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRGbG9hdDogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEkgYW0gc3VyZSB0aGVyZSBpcyBhIGJldHRlciB3YXkgdGhhbiB0aGlzIGJ1dCB0aGlzIHNob3VsZCBiZSBzYWZlXG4gICAgICAgICAgICB2YXIgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbM10gPSBieXRlQXJyYXlbcG9zaXRpb25dO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzJdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAyXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFswXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdO1xuICAgICAgICAgICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdC5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyA2NC1iaXQgZmxvYXQgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCA2NC1iaXQgZmxvYXRcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkRG91YmxlOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZERvdWJsZTogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgOCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWREb3VibGU6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJIGFtIHN1cmUgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRoYW4gdGhpcyBidXQgdGhpcyBzaG91bGQgYmUgc2FmZVxuICAgICAgICAgICAgdmFyIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdCA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzddID0gYnl0ZUFycmF5W3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs2XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzVdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbNF0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAzXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFszXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDRdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzJdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgNV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA2XTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFswXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDddO1xuICAgICAgICAgICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdC5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGNvbW1vbiB0byBwYXJzaW5nIGJ5dGUgYXJyYXlzIG9mIGFueSB0eXBlXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgc3RyaW5nIG9mIDgtYml0IGNoYXJhY3RlcnMgZnJvbSBhbiBhcnJheSBvZiBieXRlcyBhbmQgYWR2YW5jZXNcbiAgICAgKiB0aGUgcG9zaXRpb24gYnkgbGVuZ3RoIGJ5dGVzLiAgQSBudWxsIHRlcm1pbmF0b3Igd2lsbCBlbmQgdGhlIHN0cmluZ1xuICAgICAqIGJ1dCB3aWxsIG5vdCBlZmZlY3QgYWR2YW5jZW1lbnQgb2YgdGhlIHBvc2l0aW9uLiAgVHJhaWxpbmcgYW5kIGxlYWRpbmdcbiAgICAgKiBzcGFjZXMgYXJlIHByZXNlcnZlZCAobm90IHRyaW1tZWQpXG4gICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZUFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIGxlbmd0aCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcGFyc2VkIHN0cmluZ1xuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nID0gZnVuY3Rpb24oYnl0ZUFycmF5LCBwb3NpdGlvbiwgbGVuZ3RoKVxuICAgIHtcbiAgICAgICAgaWYobGVuZ3RoIDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyAtIGxlbmd0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocG9zaXRpb24gKyBsZW5ndGggPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB2YXIgYnl0ZTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgYnl0ZSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIGldO1xuICAgICAgICAgICAgaWYoYnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9ICBsZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqXG4gKiBJbnRlcm5hbCBoZWxwZXIgY2xhc3MgdG8gYXNzaXN0IHdpdGggcGFyc2luZy4gU3VwcG9ydHMgcmVhZGluZyBmcm9tIGEgYnl0ZVxuICogc3RyZWFtIGNvbnRhaW5lZCBpbiBhIFVpbnQ4QXJyYXkuICBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICogIHZhciBieXRlU3RyZWFtID0gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXkpO1xuICpcbiAqICovXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEJ5dGVTdHJlYW0gb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0gYnl0ZUFycmF5UGFyc2VyIGEgcGFyc2VyIGZvciBwYXJzaW5nIHRoZSBieXRlIGFycmF5XG4gICAgICogQHBhcmFtIGJ5dGVBcnJheSBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgYnl0ZSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gKG9wdGlvbmFsKSB0aGUgcG9zaXRpb24gdG8gc3RhcnQgcmVhZGluZyBmcm9tLiAgMCBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHRocm93cyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBieXRlQXJyYXlQYXJzZXIgcGFyYW1ldGVyIGlzIG5vdCBwcmVzZW50XG4gICAgICogQHRocm93cyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBieXRlQXJyYXkgcGFyYW1ldGVyIGlzIG5vdCBwcmVzZW50IG9yIGludmFsaWRcbiAgICAgKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHBvc2l0aW9uIHBhcmFtZXRlciBpcyBub3QgaW5zaWRlIHRoZSBieXRlIGFycmF5XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuQnl0ZVN0cmVhbSA9IGZ1bmN0aW9uKGJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICBpZihieXRlQXJyYXlQYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5CeXRlU3RyZWFtOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZUFycmF5UGFyc2VyJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJ5dGVBcnJheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLkJ5dGVTdHJlYW06IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlQXJyYXknXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoKGJ5dGVBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpID09PSBmYWxzZSAmJlxuICAgICAgICAgIChieXRlQXJyYXkgaW5zdGFuY2VvZiBCdWZmZXIpID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5CeXRlU3RyZWFtOiBwYXJhbWV0ZXIgYnl0ZUFycmF5IGlzIG5vdCBvZiB0eXBlIFVpbnQ4QXJyYXkgb3IgQnVmZmVyJztcbiAgICAgICAgfVxuICAgICAgICBpZihwb3NpdGlvbiA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuQnl0ZVN0cmVhbTogcGFyYW1ldGVyICdwb3NpdGlvbicgY2Fubm90IGJlIGxlc3MgdGhhbiAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocG9zaXRpb24gPj0gYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5CeXRlU3RyZWFtOiBwYXJhbWV0ZXIgJ3Bvc2l0aW9uJyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICdieXRlQXJyYXknIGxlbmd0aFwiO1xuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ieXRlQXJyYXlQYXJzZXIgPSBieXRlQXJyYXlQYXJzZXI7XG4gICAgICAgIHRoaXMuYnl0ZUFycmF5ID0gYnl0ZUFycmF5O1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gPyBwb3NpdGlvbiA6IDA7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTsgLy8gYXJyYXkgb2Ygc3RyaW5nIHdhcm5pbmdzIGVuY291bnRlcmVkIHdoaWxlIHBhcnNpbmdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2FmZWx5IHNlZWtzIHRocm91Z2ggdGhlIGJ5dGUgc3RyZWFtLiAgV2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdFxuICAgICAqIGlzIG1hZGUgdG8gc2VlayBvdXRzaWRlIG9mIHRoZSBieXRlIGFycmF5LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgdGhlIG51bWJlciBvZiBieXRlcyB0byBhZGQgdG8gdGhlIHBvc2l0aW9uXG4gICAgICogQHRocm93cyBlcnJvciBpZiBzZWVrIHdvdWxkIGNhdXNlIHBvc2l0aW9uIHRvIGJlIG91dHNpZGUgb2YgdGhlIGJ5dGVBcnJheVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbihvZmZzZXQpXG4gICAge1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uICsgb2Zmc2V0IDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5zZWVrOiBjYW5ub3Qgc2VlayB0byBwb3NpdGlvbiA8IDBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IG9mZnNldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBCeXRlU3RyZWFtIG9iamVjdCBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBvZiB0aGUgcmVxdWVzdGVkIG51bWJlciBvZiBieXRlc1xuICAgICAqIEBwYXJhbSBudW1CeXRlcyB0aGUgbGVuZ3RoIG9mIHRoZSBieXRlIGFycmF5IGZvciB0aGUgQnl0ZVN0cmVhbSB0byBjb250YWluXG4gICAgICogQHJldHVybnMge2RpY29tUGFyc2VyLkJ5dGVTdHJlYW19XG4gICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkQnl0ZVN0cmVhbSA9IGZ1bmN0aW9uKG51bUJ5dGVzKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5wb3NpdGlvbiArIG51bUJ5dGVzID4gdGhpcy5ieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZEJ5dGVTdHJlYW06IHJlYWRCeXRlU3RyZWFtIC0gYnVmZmVyIG92ZXJyZWFkJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZUFycmF5VmlldyA9IGRpY29tUGFyc2VyLnNoYXJlZENvcHkodGhpcy5ieXRlQXJyYXksIHRoaXMucG9zaXRpb24sIG51bUJ5dGVzKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBudW1CeXRlcztcbiAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKHRoaXMuYnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXlWaWV3KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQYXJzZXMgYW4gdW5zaWduZWQgaW50IDE2IGZyb20gYSBieXRlIGFycmF5IGFuZCBhZHZhbmNlc1xuICAgICAqIHRoZSBwb3NpdGlvbiBieSAyIGJ5dGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMTZcbiAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50MTYgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ieXRlQXJyYXlQYXJzZXIucmVhZFVpbnQxNih0aGlzLmJ5dGVBcnJheSwgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIHVuc2lnbmVkIGludCAzMiBmcm9tIGEgYnl0ZSBhcnJheSBhbmQgYWR2YW5jZXNcbiAgICAgKiB0aGUgcG9zaXRpb24gYnkgMiBieXRlc1xuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZSB1bnNpZ25lZCBpbnQgMzJcbiAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ieXRlQXJyYXlQYXJzZXIucmVhZFVpbnQzMih0aGlzLmJ5dGVBcnJheSwgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBzdHJpbmcgb2YgOC1iaXQgY2hhcmFjdGVycyBmcm9tIGFuIGFycmF5IG9mIGJ5dGVzIGFuZCBhZHZhbmNlc1xuICAgICAqIHRoZSBwb3NpdGlvbiBieSBsZW5ndGggYnl0ZXMuICBBIG51bGwgdGVybWluYXRvciB3aWxsIGVuZCB0aGUgc3RyaW5nXG4gICAgICogYnV0IHdpbGwgbm90IGVmZmVjdCBhZHZhbmNlbWVudCBvZiB0aGUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIGxlbmd0aCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcGFyc2VkIHN0cmluZ1xuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZEZpeGVkU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKVxuICAgIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyh0aGlzLmJ5dGVBcnJheSwgdGhpcy5wb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICpcbiAqIFRoZSBEYXRhU2V0IGNsYXNzIGVuY2Fwc3VsYXRlcyBhIGNvbGxlY3Rpb24gb2YgRElDT00gRWxlbWVudHMgYW5kIHByb3ZpZGVzIHZhcmlvdXMgZnVuY3Rpb25zXG4gKiB0byBhY2Nlc3MgdGhlIGRhdGEgaW4gdGhvc2UgZWxlbWVudHNcbiAqXG4gKiBSdWxlcyBmb3IgaGFuZGxpbmcgcGFkZGVkIHNwYWNlczpcbiAqIERTID0gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gKiBEVCA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICogSVMgPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIFBOID0gU3RyaXAgdHJhaWxpbmcgc3BhY2VzXG4gKiBUTSA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICogQUUgPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIENTID0gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gKiBTSCA9IFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICogTE8gPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIExUID0gU3RyaXAgdHJhaWxpbmcgc3BhY2VzXG4gKiBTVCA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICogVVQgPSBTdHJpcCB0cmFpbGluZyBzcGFjZXNcbiAqXG4gKi9cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCeXRlQXJyYXlQYXJzZXIoZWxlbWVudCwgZGVmYXVsdFBhcnNlcilcbiAgICB7XG4gICAgICAgIHJldHVybiAoZWxlbWVudC5wYXJzZXIgIT09IHVuZGVmaW5lZCA/IGVsZW1lbnQucGFyc2VyIDogZGVmYXVsdFBhcnNlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBEYXRhU2V0IGdpdmVuIGJ5dGVBcnJheSBhbmQgY29sbGVjdGlvbiBvZiBlbGVtZW50c1xuICAgICAqIEBwYXJhbSBieXRlQXJyYXlQYXJzZXJcbiAgICAgKiBAcGFyYW0gYnl0ZUFycmF5XG4gICAgICogQHBhcmFtIGVsZW1lbnRzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldCA9IGZ1bmN0aW9uKGJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5LCBlbGVtZW50cylcbiAgICB7XG4gICAgICAgIHRoaXMuYnl0ZUFycmF5UGFyc2VyID0gYnl0ZUFycmF5UGFyc2VyO1xuICAgICAgICB0aGlzLmJ5dGVBcnJheSA9IGJ5dGVBcnJheTtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGFuIHVuc2lnbmVkIGludCAxNiBpZiBpdCBleGlzdHMgYW5kIGhhcyBkYXRhXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgaW4gYSBtdWx0aXZhbHVlZCBlbGVtZW50LiAgRGVmYXVsdCBpcyBpbmRleCAwIGlmIG5vdCBzdXBwbGllZFxuICAgICAqIEByZXR1cm5zIHsqfSB1bnNpZ25lZCBpbnQgMTYgb3IgdW5kZWZpbmVkIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQgb3IgaGFzIGRhdGEgb2YgbGVuZ3RoIDBcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS51aW50MTYgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkVWludDE2KHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKjIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGFuIHNpZ25lZCBpbnQgMTYgaWYgaXQgZXhpc3RzIGFuZCBoYXMgZGF0YVxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIGluIGEgbXVsdGl2YWx1ZWQgZWxlbWVudC4gIERlZmF1bHQgaXMgaW5kZXggMCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiBAcmV0dXJucyB7Kn0gc2lnbmVkIGludCAxNiBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBoYXMgZGF0YSBvZiBsZW5ndGggMFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLmludDE2ID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCB0aGlzLmJ5dGVBcnJheVBhcnNlcikucmVhZEludDE2KHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKiAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgZm9yIHRhZyBhbmQgcmV0dXJucyBhbiB1bnNpZ25lZCBpbnQgMzIgaWYgaXQgZXhpc3RzIGFuZCBoYXMgZGF0YVxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIGluIGEgbXVsdGl2YWx1ZWQgZWxlbWVudC4gIERlZmF1bHQgaXMgaW5kZXggMCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiBAcmV0dXJucyB7Kn0gdW5zaWduZWQgaW50IDMyIG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCB0aGlzLmJ5dGVBcnJheVBhcnNlcikucmVhZFVpbnQzMih0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0ICsgKGluZGV4ICogNCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IGZvciB0YWcgYW5kIHJldHVybnMgYW4gc2lnbmVkIGludCAzMiBpZiBpdCBleGlzdHMgYW5kIGhhcyBkYXRhXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgaW4gYSBtdWx0aXZhbHVlZCBlbGVtZW50LiAgRGVmYXVsdCBpcyBpbmRleCAwIGlmIG5vdCBzdXBwbGllZFxuICAgICAqIEByZXR1cm5zIHsqfSBzaWduZWQgaW50IDMyIG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkSW50MzIodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCArIChpbmRleCAqIDQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGEgMzIgYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciAoVlI9RkwpIGlmIGl0IGV4aXN0cyBhbmQgaGFzIGRhdGFcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpbiBhIG11bHRpdmFsdWVkIGVsZW1lbnQuICBEZWZhdWx0IGlzIGluZGV4IDAgaWYgbm90IHN1cHBsaWVkXG4gICAgICogQHJldHVybnMgeyp9IGZsb2F0IG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkRmxvYXQodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCArIChpbmRleCAqIDQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGEgNjQgYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciAoVlI9RkQpIGlmIGl0IGV4aXN0cyBhbmQgaGFzIGRhdGFcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpbiBhIG11bHRpdmFsdWVkIGVsZW1lbnQuICBEZWZhdWx0IGlzIGluZGV4IDAgaWYgbm90IHN1cHBsaWVkXG4gICAgICogQHJldHVybnMgeyp9IGZsb2F0IG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGRvZXNuJ3QgaGFzIGRhdGEgb2YgbGVuZ3RoIDBcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkRG91YmxlKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKiA4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHN0cmluZyB2YWx1ZXMgZm9yIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHJldHVybnMgeyp9IHRoZSBudW1iZXIgb2Ygc3RyaW5nIHZhbHVlcyBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBoYXMgemVybyBsZW5ndGggZGF0YVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLm51bVN0cmluZ1ZhbHVlcyA9IGZ1bmN0aW9uKHRhZylcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpeGVkU3RyaW5nID0gZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQsIGVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBudW1NYXRjaGluZyA9IGZpeGVkU3RyaW5nLm1hdGNoKC9cXFxcL2cpO1xuICAgICAgICAgICAgaWYobnVtTWF0Y2hpbmcgPT09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtTWF0Y2hpbmcubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIGZvciB0aGUgZWxlbWVudC4gIElmIGluZGV4IGlzIHByb3ZpZGVkLCB0aGUgZWxlbWVudCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICogbXVsdGktdmFsdWVkIGFuZCB3aWxsIHJldHVybiB0aGUgY29tcG9uZW50IHNwZWNpZmllZCBieSBpbmRleC4gIFVuZGVmaW5lZCBpcyByZXR1cm5lZFxuICAgICAqIGlmIHRoZXJlIGlzIG5vIGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXgsIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IG9yIGlzIHplcm8gbGVuZ3RoLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZnVuY3Rpb24gZm9yIFZSIHR5cGVzIG9mIEFFLCBDUywgU0ggYW5kIExPXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSBkZXNpcmVkIHZhbHVlIGluIGEgbXVsdGkgdmFsdWVkIHN0cmluZyBvciB1bmRlZmluZWQgZm9yIHRoZSBlbnRpcmUgc3RyaW5nXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpeGVkU3RyaW5nID0gZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQsIGVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmKGluZGV4ID49IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGZpeGVkU3RyaW5nLnNwbGl0KCdcXFxcJyk7XG4gICAgICAgICAgICAgICAgLy8gdHJpbSB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2luZGV4XS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gdHJpbSB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWRTdHJpbmcudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgbGVhZGluZyBzcGFjZXMgcHJlc2VydmVkIGFuZCB0cmFpbGluZyBzcGFjZXMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGFjY2VzcyBkYXRhIGZvciBWUnMgb2YgdHlwZSBVVCwgU1QgYW5kIExUXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFnXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaXhlZFN0cmluZyA9IGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyh0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0LCBlbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZihpbmRleCA+PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBmaXhlZFN0cmluZy5zcGxpdCgnXFxcXCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaW5kZXhdLnJlcGxhY2UoLyArJC8sICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWRTdHJpbmcucmVwbGFjZSgvICskLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHN0cmluZyB0byBhIGZsb2F0IGZvciB0aGUgc3BlY2lmaWVkIGluZGV4IGluIGEgbXVsdGktdmFsdWVkIGVsZW1lbnQuICBJZiBpbmRleCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIHRoZSBmaXJzdCB2YWx1ZSBpbiBhIG11bHRpLXZhbHVlZCBWUiB3aWxsIGJlIHBhcnNlZCBpZiBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIGRlc2lyZWQgdmFsdWUgaW4gYSBtdWx0aSB2YWx1ZWQgc3RyaW5nIG9yIHVuZGVmaW5lZCBmb3IgdGhlIGZpcnN0IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9IGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBub3QgcHJlc2VudCBvciBkYXRhIG5vdCBsb25nIGVub3VnaFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLmZsb2F0U3RyaW5nID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0cmluZyh0YWcsIGluZGV4KTtcbiAgICAgICAgICAgIGlmKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc3RyaW5nIHRvIGFuIGludGVnZXIgZm9yIHRoZSBzcGVjaWZpZWQgaW5kZXggaW4gYSBtdWx0aS12YWx1ZWQgZWxlbWVudC4gIElmIGluZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogdGhlIGZpcnN0IHZhbHVlIGluIGEgbXVsdGktdmFsdWVkIFZSIHdpbGwgYmUgcGFyc2VkIGlmIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgZGVzaXJlZCB2YWx1ZSBpbiBhIG11bHRpIHZhbHVlZCBzdHJpbmcgb3IgdW5kZWZpbmVkIGZvciB0aGUgZmlyc3QgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gYW4gaW50ZWdlciBvciB1bmRlZmluZWQgaWYgbm90IHByZXNlbnQgb3IgZGF0YSBub3QgbG9uZyBlbm91Z2hcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5pbnRTdHJpbmcgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RyaW5nKHRhZywgaW5kZXgpO1xuICAgICAgICAgICAgaWYodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLy9kaWNvbVBhcnNlci5EYXRhU2V0ID0gRGF0YVNldDtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIHJlYWRzIGZyb20gdGhlIGJ5dGUgc3RyZWFtIHVudGlsIGl0IGZpbmRzIHRoZSBtYWdpYyBudW1iZXIgZm9yIHRoZSBTZXF1ZW5jZSBEZWxpbWl0YXRpb24gSXRlbSBpdGVtXG4gICAqIGFuZCB0aGVuIHNldHMgdGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0gYnl0ZVN0cmVhbVxuICAgKiBAcGFyYW0gZWxlbWVudFxuICAgKi9cbiAgZGljb21QYXJzZXIuZmluZEFuZFNldFVORWxlbWVudExlbmd0aCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIGVsZW1lbnQpXG4gIHtcbiAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5maW5kQW5kU2V0VU5FbGVtZW50TGVuZ3RoOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICB9XG5cbiAgICB2YXIgaXRlbURlbGltaXRhdGlvbkl0ZW1MZW5ndGggPSA4OyAvLyBncm91cCwgZWxlbWVudCwgbGVuZ3RoXG4gICAgdmFyIG1heFBvc2l0aW9uID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gaXRlbURlbGltaXRhdGlvbkl0ZW1MZW5ndGg7XG4gICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8PSBtYXhQb3NpdGlvbilcbiAgICB7XG4gICAgICB2YXIgZ3JvdXBOdW1iZXI7XG4gICAgICBncm91cE51bWJlciA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgICAgaWYoZ3JvdXBOdW1iZXIgPT09IDB4ZmZmZSlcbiAgICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnROdW1iZXI7XG4gICAgICAgIGVsZW1lbnROdW1iZXIgPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgICAgaWYoZWxlbWVudE51bWJlciA9PT0gMHhlMGRkKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gTk9URTogSXQgd291bGQgYmUgYmV0dGVyIHRvIGFsc28gY2hlY2sgZm9yIHRoZSBsZW5ndGggdG8gYmUgMCBhcyBwYXJ0IG9mIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICAgIC8vIGJ1dCB3ZSB3aWxsIGp1c3QgbG9nIGEgd2FybmluZyBmb3Igbm93XG4gICAgICAgICAgdmFyIGl0ZW1EZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgaXRlbURlbGltaXRlckxlbmd0aCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpOyAvLyB0aGUgbGVuZ3RoXG4gICAgICAgICAgaWYoaXRlbURlbGltaXRlckxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncygnZW5jb3VudGVyZWQgbm9uIHplcm8gbGVuZ3RoIGZvbGxvd2luZyBpdGVtIGRlbGltaXRlciBhdCBwb3NpdGlvbicgKyBieXRlU3RyZWFtLnBvc2l0aW9uIC0gNCArIFwiIHdoaWxlIHJlYWRpbmcgZWxlbWVudCBvZiB1bmRlZmluZWQgbGVuZ3RoIHdpdGggdGFnICcgKyBlbGVtZW50LnRhZ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIGl0ZW0gZGVsaW1pdGF0aW9uIGl0ZW0gLSBzaWxlbnRseSBzZXQgdGhlIGxlbmd0aCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIgYW5kIHNldCB0aGUgcG9zaXRpb24gcGFzdCB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICBieXRlU3RyZWFtLnNlZWsoYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gYnl0ZVN0cmVhbS5wb3NpdGlvbik7XG4gIH07XG5cblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGEgZWxlbWVudCBhbmQgYWRkcyBhbiBhcnJheSBvZiBmcmFnbWVudHMgdG8gdGhlIGVsZW1lbnRcbiAgICAgKiBjb250YWluaW5nIHRoZSBvZmZzZXQgYW5kIGxlbmd0aCBvZiBlYWNoIGZyYWdtZW50IGFuZCBhbnkgb2Zmc2V0cyBmcm9tIHRoZSBiYXNpYyBvZmZzZXRcbiAgICAgKiB0YWJsZVxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5maW5kRW5kT2ZFbmNhcHN1bGF0ZWRFbGVtZW50ID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuZmluZEVuZE9mRW5jYXBzdWxhdGVkRWxlbWVudDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmZpbmRFbmRPZkVuY2Fwc3VsYXRlZEVsZW1lbnQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdlbGVtZW50J1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5lbmNhcHN1bGF0ZWRQaXhlbERhdGEgPSB0cnVlO1xuICAgICAgICBlbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUgPSBbXTtcbiAgICAgICAgZWxlbWVudC5mcmFnbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGJhc2ljT2Zmc2V0VGFibGVJdGVtVGFnID0gZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKTtcbiAgICAgICAgaWYoYmFzaWNPZmZzZXRUYWJsZUl0ZW1UYWcgIT09ICd4ZmZmZWUwMDAnKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmZpbmRFbmRPZkVuY2Fwc3VsYXRlZEVsZW1lbnQ6IGJhc2ljIG9mZnNldCB0YWJsZSBub3QgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzaWNPZmZzZXRUYWJsZUl0ZW1sZW5ndGggPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICAgICAgdmFyIG51bUZyYWdtZW50cyA9IGJhc2ljT2Zmc2V0VGFibGVJdGVtbGVuZ3RoIC8gNDtcbiAgICAgICAgZm9yKHZhciBpID0wOyBpIDwgbnVtRnJhZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYmFzaWNPZmZzZXRUYWJsZS5wdXNoKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VPZmZzZXQgPSBieXRlU3RyZWFtLnBvc2l0aW9uO1xuXG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgaWYodGFnID09PSAneGZmZmVlMGRkJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0YWcgPT09ICd4ZmZmZWUwMDAnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZnJhZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBiYXNlT2Zmc2V0IC0gOCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gOiBieXRlU3RyZWFtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggOiBsZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHdhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goJ3VuZXhwZWN0ZWQgdGFnICcgKyB0YWcgKyAnIHdoaWxlIHNlYXJjaGluZyBmb3IgZW5kIG9mIHBpeGVsIGRhdGEgZWxlbWVudCB3aXRoIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYobGVuZ3RoID4gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gYnl0ZVN0cmVhbS5wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gYnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5mcmFnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGJhc2VPZmZzZXQgLSA4LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA6IGJ5dGVTdHJlYW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA6IGxlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlayhsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlayhsZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYod2FybmluZ3MpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goXCJwaXhlbCBkYXRhIGVsZW1lbnQgXCIgKyBlbGVtZW50LnRhZyArIFwiIG1pc3Npbmcgc2VxdWVuY2UgZGVsaW1pdGVyIHRhZyB4ZmZmZWUwZGRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVhZHMgZnJvbSB0aGUgYnl0ZSBzdHJlYW0gdW50aWwgaXQgZmluZHMgdGhlIG1hZ2ljIG51bWJlcnMgZm9yIHRoZSBpdGVtIGRlbGltaXRhdGlvbiBpdGVtXG4gICAgICogYW5kIHRoZW4gc2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW1cbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmZpbmRJdGVtRGVsaW1pdGF0aW9uSXRlbUFuZFNldEVsZW1lbnRMZW5ndGggPSBmdW5jdGlvbihieXRlU3RyZWFtLCBlbGVtZW50KVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRJbXBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbURlbGltaXRhdGlvbkl0ZW1MZW5ndGggPSA4OyAvLyBncm91cCwgZWxlbWVudCwgbGVuZ3RoXG4gICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGl0ZW1EZWxpbWl0YXRpb25JdGVtTGVuZ3RoO1xuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDw9IG1heFBvc2l0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOdW1iZXIgPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGlmKGdyb3VwTnVtYmVyID09PSAweGZmZmUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnROdW1iZXIgPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50TnVtYmVyID09PSAweGUwMGQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBJdCB3b3VsZCBiZSBiZXR0ZXIgdG8gYWxzbyBjaGVjayBmb3IgdGhlIGxlbmd0aCB0byBiZSAwIGFzIHBhcnQgb2YgdGhlIGNoZWNrIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSB3aWxsIGp1c3QgbG9nIGEgd2FybmluZyBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtRGVsaW1pdGVyTGVuZ3RoID0gYnl0ZVN0cmVhbS5yZWFkVWludDMyKCk7IC8vIHRoZSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbURlbGltaXRlckxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncygnZW5jb3VudGVyZWQgbm9uIHplcm8gbGVuZ3RoIGZvbGxvd2luZyBpdGVtIGRlbGltaXRlciBhdCBwb3NpdGlvbicgKyBieXRlU3RyZWFtLnBvc2l0aW9uIC0gNCArIFwiIHdoaWxlIHJlYWRpbmcgZWxlbWVudCBvZiB1bmRlZmluZWQgbGVuZ3RoIHdpdGggdGFnICcgKyBlbGVtZW50LnRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBpdGVtIGRlbGltaXRhdGlvbiBpdGVtIC0gc2lsZW50bHkgc2V0IHRoZSBsZW5ndGggdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGFuZCBzZXQgdGhlIHBvc2l0aW9uIHBhc3QgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICBieXRlU3RyZWFtLnNlZWsoYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gYnl0ZVN0cmVhbS5wb3NpdGlvbik7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIGRpZmZlcmVudCB0eXBlcyBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcnNlcyBhbiB1bnNpZ25lZCBpbnQgMTYgZnJvbSBhIGxpdHRsZS1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMTZcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkVWludDE2OiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQxNjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDIgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDE2OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBieXRlQXJyYXlbcG9zaXRpb25dICsgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdICogMjU2KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyc2VzIGEgc2lnbmVkIGludCAxNiBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHNpZ25lZCBpbnQgMTZcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkSW50MTY6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MTY6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyAyID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDE2OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnQxNiA9IGJ5dGVBcnJheVtwb3NpdGlvbl0gKyAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gPDwgOCk7XG4gICAgICAgICAgICAvLyBmaXggc2lnblxuICAgICAgICAgICAgaWYgKGludDE2ICYgMHg4MDAwKSB7XG4gICAgICAgICAgICAgICAgaW50MTYgPSBpbnQxNiAtIDB4RkZGRiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50MTY7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGFuIHVuc2lnbmVkIGludCAzMiBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHVuc2lnbmVkIGludCAzMlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRVaW50MzI6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDMyOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQzMjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1aW50MzIgPSAoYnl0ZUFycmF5W3Bvc2l0aW9uXSArXG4gICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gKiAyNTYpICtcbiAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAyXSAqIDI1NiAqIDI1NikgK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdICogMjU2ICogMjU2ICogMjU2ICkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdWludDMyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYSBzaWduZWQgaW50IDMyIGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgdW5zaWduZWQgaW50IDMyXG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEludDMyOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDMyOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDMyOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGludDMyID0gKGJ5dGVBcnJheVtwb3NpdGlvbl0gK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdIDw8IDgpICtcbiAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAyXSA8PCAxNikgK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdIDw8IDI0KSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnQzMjtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgMzItYml0IGZsb2F0IGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgMzItYml0IGZsb2F0XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEZsb2F0OiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEZsb2F0OiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEZsb2F0OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSSBhbSBzdXJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0aGFuIHRoaXMgYnV0IHRoaXMgc2hvdWxkIGJlIHNhZmVcbiAgICAgICAgICAgIHZhciBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFswXSA9IGJ5dGVBcnJheVtwb3NpdGlvbl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsyXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzNdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgM107XG4gICAgICAgICAgICB2YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0LmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIDY0LWJpdCBmbG9hdCBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIDY0LWJpdCBmbG9hdFxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRG91YmxlOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA4ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZERvdWJsZTogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEkgYW0gc3VyZSB0aGVyZSBpcyBhIGJldHRlciB3YXkgdGhhbiB0aGlzIGJ1dCB0aGlzIHNob3VsZCBiZSBzYWZlXG4gICAgICAgICAgICB2YXIgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMF0gPSBieXRlQXJyYXlbcG9zaXRpb25dO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzFdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMl0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAyXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFszXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzRdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgNF07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbNV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA1XTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs2XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDZdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzddID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgN107XG4gICAgICAgICAgICB2YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDY0QXJyYXkoYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0LmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgaW1wbGljaXQgYW5kIGV4cGxpY2l0IERJQ09NIGRhdGEgc2V0c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZWFkcyBhbiBleHBsaWNpdCBkYXRhIHNldFxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtIHRoZSBieXRlIHN0cmVhbSB0byByZWFkIGZyb21cbiAgICAgKiBAcGFyYW0gbWF4UG9zaXRpb24gdGhlIG1heGltdW0gcG9zaXRpb24gdG8gcmVhZCB1cCB0byAob3B0aW9uYWwgLSBvbmx5IG5lZWRlZCB3aGVuIHJlYWRpbmcgc2VxdWVuY2UgaXRlbXMpXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRFeHBsaWNpdCA9IGZ1bmN0aW9uIChkYXRhU2V0LCBieXRlU3RyZWFtLCBtYXhQb3NpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgICAgIG1heFBvc2l0aW9uID0gKG1heFBvc2l0aW9uID09PSB1bmRlZmluZWQpID8gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIDogbWF4UG9zaXRpb24gO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRFeHBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWF4UG9zaXRpb24gPCBieXRlU3RyZWFtLnBvc2l0aW9uIHx8IG1heFBvc2l0aW9uID4gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQ6IGludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnbWF4UG9zaXRpb24nXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZGF0YVNldC5lbGVtZW50cztcblxuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgbWF4UG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGRhdGFTZXQud2FybmluZ3MsIG9wdGlvbnMudW50aWxUYWcpO1xuICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudC50YWddID0gZWxlbWVudDtcbiAgICAgICAgICAgIGlmKGVsZW1lbnQudGFnID09PSBvcHRpb25zLnVudGlsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0ucG9zaXRpb24gPiBtYXhQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlcjpwYXJzZURpY29tRGF0YVNldEV4cGxpY2l0OiBidWZmZXIgb3ZlcnJ1blwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlYWRzIGFuIGltcGxpY2l0IGRhdGEgc2V0XG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW0gdGhlIGJ5dGUgc3RyZWFtIHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBtYXhQb3NpdGlvbiB0aGUgbWF4aW11bSBwb3NpdGlvbiB0byByZWFkIHVwIHRvIChvcHRpb25hbCAtIG9ubHkgbmVlZGVkIHdoZW4gcmVhZGluZyBzZXF1ZW5jZSBpdGVtcylcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEltcGxpY2l0ID0gZnVuY3Rpb24oZGF0YVNldCwgYnl0ZVN0cmVhbSwgbWF4UG9zaXRpb24sIG9wdGlvbnMpXG4gICAge1xuICAgICAgICBtYXhQb3NpdGlvbiA9IChtYXhQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSA/IGRhdGFTZXQuYnl0ZUFycmF5Lmxlbmd0aCA6IG1heFBvc2l0aW9uIDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0SW1wbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKG1heFBvc2l0aW9uIDwgYnl0ZVN0cmVhbS5wb3NpdGlvbiB8fCBtYXhQb3NpdGlvbiA+IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEltcGxpY2l0OiBpbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ21heFBvc2l0aW9uJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZGF0YVNldC5lbGVtZW50cztcblxuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgbWF4UG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0KGJ5dGVTdHJlYW0sIG9wdGlvbnMudW50aWxUYWcsIG9wdGlvbnMudnJDYWxsYmFjayk7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuICAgICAgICAgICAgaWYoZWxlbWVudC50YWcgPT09IG9wdGlvbnMudW50aWxUYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGFMZW5ndGhTaXplSW5CeXRlc0ZvclZSKHZyKVxuICAgIHtcbiAgICAgICAgaWYoIHZyID09PSAnT0InIHx8XG4gICAgICAgICAgICB2ciA9PT0gJ09XJyB8fFxuICAgICAgICAgICAgdnIgPT09ICdTUScgfHxcbiAgICAgICAgICAgIHZyID09PSAnT0YnIHx8XG4gICAgICAgICAgICB2ciA9PT0gJ1VUJyB8fFxuICAgICAgICAgICAgdnIgPT09ICdVTicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50RXhwbGljaXQgPSBmdW5jdGlvbihieXRlU3RyZWFtLCB3YXJuaW5ncywgdW50aWxUYWcpXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEV4cGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgdGFnIDogZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKSxcbiAgICAgICAgICAgIHZyIDogYnl0ZVN0cmVhbS5yZWFkRml4ZWRTdHJpbmcoMilcbiAgICAgICAgICAgIC8vIGxlbmd0aCBzZXQgYmVsb3cgYmFzZWQgb24gVlJcbiAgICAgICAgICAgIC8vIGRhdGFPZmZzZXQgc2V0IGJlbG93IGJhc2VkIG9uIFZSIGFuZCBzaXplIG9mIGxlbmd0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkYXRhTGVuZ3RoU2l6ZUJ5dGVzID0gZ2V0RGF0YUxlbmd0aFNpemVJbkJ5dGVzRm9yVlIoZWxlbWVudC52cik7XG4gICAgICAgIGlmKGRhdGFMZW5ndGhTaXplQnl0ZXMgPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICBlbGVtZW50LmRhdGFPZmZzZXQgPSBieXRlU3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKDIpO1xuICAgICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIGVsZW1lbnQuZGF0YU9mZnNldCA9IGJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgZWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZWxlbWVudC50YWcgPT09IHVudGlsVGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIFZSIGlzIFNRLCBwYXJzZSB0aGUgc2VxdWVuY2UgaXRlbXNcbiAgICAgICAgaWYoZWxlbWVudC52ciA9PT0gJ1NRJylcbiAgICAgICAge1xuICAgICAgICAgICAgZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNFeHBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncyk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYoZWxlbWVudC5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKGVsZW1lbnQudGFnID09PSAneDdmZTAwMDEwJykge1xuICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLmZpbmRFbmRPZkVuY2Fwc3VsYXRlZEVsZW1lbnQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfSAgIGVsc2UgaWYoZWxlbWVudC52ciA9PT0gJ1VOJykge1xuICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLmZpbmRBbmRTZXRVTkVsZW1lbnRMZW5ndGgoYnl0ZVN0cmVhbSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy9kaWNvbVBhcnNlci5maW5kSXRlbURlbGltaXRhdGlvbkl0ZW1BbmRTZXRFbGVtZW50TGVuZ3RoKGJ5dGVTdHJlYW0sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKGVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTZXF1ZW5jZShlbGVtZW50LCBieXRlU3RyZWFtLCB2ckNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGlmIGEgZGF0YSBkaWN0aW9uYXJ5IGNhbGxiYWNrIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gdmVyaWZ5IHRoYXQgdGhlIGVsZW1lbnQgaXMgYSBzZXF1ZW5jZS5cbiAgICAgICAgaWYgKHR5cGVvZiB2ckNhbGxiYWNrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuICh2ckNhbGxiYWNrKGVsZW1lbnQudGFnKSA9PT0gJ1NRJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChieXRlU3RyZWFtLnBvc2l0aW9uICsgNCkgPD0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRhZyA9IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSk7XG4gICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoLTQpO1xuICAgICAgICAgICAgLy8gSXRlbSBzdGFydCB0YWcgKGZmZmUsZTAwMCkgb3Igc2VxdWVuY2UgZGVsaW1pdGVyIChpLmUuIGVuZCBvZiBzZXF1ZW5jZSkgdGFnICgwZmZmZSxlMGRkKVxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSB0YWdzIHRoYXQgY291bGQgcG90ZW50aWFsbHkgYmUgZm91bmQgZGlyZWN0bHkgYWZ0ZXIgYSBzZXF1ZW5jZSBzdGFydCB0YWcgKHRoZSBkZWxpbWl0ZXJcbiAgICAgICAgICAgIC8vIGlzIGZvdW5kIGluIHRoZSBjYXNlIG9mIGFuIGVtcHR5IHNlcXVlbmNlKS4gVGhpcyBpcyBub3QgMTAwJSBzYWZlIGJlY2F1c2UgYSBub24tc2VxdWVuY2UgaXRlbVxuICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBkYXRhIHRoYXQgaGFzIHRoZXNlIGJ5dGVzLCBidXQgdGhpcyBpcyBob3cgdG8gZG8gaXQgd2l0aG91dCBhIGRhdGEgZGljdGlvbmFyeS5cbiAgICAgICAgICAgIHJldHVybiAobmV4dFRhZyA9PT0gJ3hmZmZlZTAwMCcpIHx8IChuZXh0VGFnID09PSAneGZmZmVlMGRkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgc2VxdWVuY2UgaXRlbSB0YWcgb3Igc2VxdWVuY2UgZGVsaW1pdGVyIHRhZyBpbiBwZWVraW5nIHRvIGRldGVybWluZSBWUicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0ID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgdW50aWxUYWcsIHZyQ2FsbGJhY2spXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgdGFnIDogZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKSxcbiAgICAgICAgICAgIGxlbmd0aDogYnl0ZVN0cmVhbS5yZWFkVWludDMyKCksXG4gICAgICAgICAgICBkYXRhT2Zmc2V0IDogIGJ5dGVTdHJlYW0ucG9zaXRpb25cbiAgICAgICAgfTtcblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgZWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZWxlbWVudC50YWcgPT09IHVudGlsVGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NlcXVlbmNlKGVsZW1lbnQsIGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spKSB7XG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGVsZW1lbnQgaXMgbm90IGEgc2VxdWVuY2UgYW5kIGhhcyB1bmRlZmluZWQgbGVuZ3RoLCB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIHNjYW4gdGhlIGRhdGEgZm9yIGEgbWFnaWMgbnVtYmVyIHRvIGZpZ3VyZSBvdXQgd2hlbiBpdCBlbmRzLlxuICAgICAgICBpZihlbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgZGljb21QYXJzZXIuZmluZEl0ZW1EZWxpbWl0YXRpb25JdGVtQW5kU2V0RWxlbWVudExlbmd0aChieXRlU3RyZWFtLCBlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9uIHNlcXVlbmNlIGVsZW1lbnQgd2l0aCBrbm93biBsZW5ndGgsIHNraXAgb3ZlciB0aGUgZGF0YSBwYXJ0XG4gICAgICAgIGJ5dGVTdHJlYW0uc2VlayhlbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogRnVuY3Rpb25hbGl0eSBmb3IgZXh0cmFjdGluZyBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEZyYWdtZW50SW5kZXhXaXRoT2Zmc2V0KGZyYWdtZW50cywgb2Zmc2V0KSB7XG4gICAgZm9yKHZhciBpPTA7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGZyYWdtZW50c1tpXS5vZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVOdW1iZXJPZkZyYWdtZW50c0ZvckZyYW1lKGZyYW1lSW5kZXgsIGJhc2ljT2Zmc2V0VGFibGUsIGZyYWdtZW50cywgc3RhcnRGcmFnbWVudEluZGV4KSB7XG4gICAgLy8gc3BlY2lhbCBjYXNlIGZvciBsYXN0IGZyYW1lXG4gICAgaWYoZnJhbWVJbmRleCA9PT0gYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGggLTEpIHtcbiAgICAgIHJldHVybiBmcmFnbWVudHMubGVuZ3RoIC0gc3RhcnRGcmFnbWVudEluZGV4O1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIGZyYWdtZW50IGxvb2tpbmcgZm9yIHRoZSBvbmUgbWF0Y2hpbmcgdGhlIG9mZnNldCBmb3IgdGhlIG5leHQgZnJhbWVcbiAgICB2YXIgbmV4dEZyYW1lT2Zmc2V0ID0gYmFzaWNPZmZzZXRUYWJsZVtmcmFtZUluZGV4ICsgMV07XG4gICAgZm9yKHZhciBpPXN0YXJ0RnJhZ21lbnRJbmRleCArIDE7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGZyYWdtZW50c1tpXS5vZmZzZXQgPT09IG5leHRGcmFtZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gaSAtIHN0YXJ0RnJhZ21lbnRJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNhbGN1bGF0ZU51bWJlck9mRnJhZ21lbnRzRm9yRnJhbWU6IGNvdWxkIG5vdCBmaW5kIGZyYWdtZW50IHdpdGggb2Zmc2V0IG1hdGNoaW5nIGJhc2ljIG9mZnNldCB0YWJsZVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpeGVsIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgZnJhbWUgaW4gYW4gZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGhhcyBhIG5vblxuICAgKiBlbXB0eSBiYXNpYyBvZmZzZXQgdGFibGUuICBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIGZhaWwgaWYgdGhlIGJhc2ljIG9mZnNldCB0YWJsZSBpcyBlbXB0eSAtIGluIHRoYXRcbiAgICogY2FzZSB5b3UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2ggZnJhZ21lbnRzIG1hcCB0byB3aGljaCBmcmFtZXMgYW5kIHJlYWQgdGhlbSB1c2luZ1xuICAgKiByZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50cygpLiAgQWxzbyBzZWUgdGhlIGZ1bmN0aW9uIGNyZWF0ZUpFUEdCYXNpY09mZnNldFRhYmxlKCkgdG8gc2VlXG4gICAqIGhvdyBhIGJhc2ljIG9mZnNldCB0YWJsZSBjYW4gYmUgY3JlYXRlZCBmb3IgSlBFRyBpbWFnZXNcbiAgICpcbiAgICogQHBhcmFtIGRhdGFTZXQgLSB0aGUgZGF0YVNldCBjb250YWluaW5nIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgKiBAcGFyYW0gcGl4ZWxEYXRhRWxlbWVudCAtIHRoZSBwaXhlbCBkYXRhIGVsZW1lbnQgKHg3ZmUwMDAxMCkgdG8gZXh0cmFjdCB0aGUgZnJhbWUgZnJvbVxuICAgKiBAcGFyYW0gZnJhbWVJbmRleCAtIHRoZSB6ZXJvIGJhc2VkIGZyYW1lIGluZGV4XG4gICAqIEBwYXJhbSBbYmFzaWNPZmZzZXRUYWJsZV0gLSBvcHRpb25hbCBhcnJheSBvZiBzdGFydGluZyBvZmZzZXRzIGZvciBmcmFtZXNcbiAgICogQHBhcmFtIFtmcmFnbWVudHNdIC0gb3B0aW9uYWwgYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGVhY2ggZnJhZ21lbnQgKG9mZnNldCwgcG9zaXRpb24sIGxlbmd0aClcbiAgICogQHJldHVybnMge29iamVjdH0gd2l0aCB0aGUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAgICovXG4gIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lID0gZnVuY3Rpb24oZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhbWVJbmRleCwgYmFzaWNPZmZzZXRUYWJsZSwgZnJhZ21lbnRzKVxuICB7XG4gICAgLy8gZGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgYmFzaWNPZmZzZXRUYWJsZSA9IGJhc2ljT2Zmc2V0VGFibGUgfHwgcGl4ZWxEYXRhRWxlbWVudC5iYXNpY09mZnNldFRhYmxlO1xuICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cyB8fCBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cztcblxuICAgIC8vIFZhbGlkYXRlIHBhcmFtZXRlcnNcbiAgICBpZihkYXRhU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdkYXRhU2V0J1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50J1wiO1xuICAgIH1cbiAgICBpZihmcmFtZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdmcmFtZUluZGV4J1wiO1xuICAgIH1cbiAgICBpZihiYXNpY09mZnNldFRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgZG9lcyBub3QgaGF2ZSBiYXNpY09mZnNldFRhYmxlXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQudGFnICE9PSAneDdmZTAwMDEwJykge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gbm9uIHBpeGVsIGRhdGEgdGFnIChleHBlY3RlZCB0YWcgPSB4N2ZlMDAwMTAnXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZW5jYXBzdWxhdGVkUGl4ZWxEYXRhICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIHVuZGVmaW5lZCBsZW5ndGhcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBmcmFnbWVudHNcIjtcbiAgICB9XG4gICAgaWYoYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IGJhc2ljT2Zmc2V0VGFibGUgaGFzIHplcm8gZW50cmllc1wiO1xuICAgIH1cbiAgICBpZihmcmFtZUluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdmcmFtZUluZGV4JyBtdXN0IGJlID49IDBcIjtcbiAgICB9XG4gICAgaWYoZnJhbWVJbmRleCA+PSBiYXNpY09mZnNldFRhYmxlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdmcmFtZUluZGV4JyBtdXN0IGJlIDwgYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGhcIjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIHN0YXJ0aW5nIGZyYWdtZW50IGJhc2VkIG9uIHRoZSBvZmZzZXQgZm9yIHRoZSBmcmFtZSBpbiB0aGUgYmFzaWMgb2Zmc2V0IHRhYmxlXG4gICAgdmFyIG9mZnNldCA9IGJhc2ljT2Zmc2V0VGFibGVbZnJhbWVJbmRleF07XG4gICAgdmFyIHN0YXJ0RnJhZ21lbnRJbmRleCA9IGZpbmRGcmFnbWVudEluZGV4V2l0aE9mZnNldChmcmFnbWVudHMsIG9mZnNldCk7XG4gICAgaWYoc3RhcnRGcmFnbWVudEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHVuYWJsZSB0byBmaW5kIGZyYWdtZW50IHRoYXQgbWF0Y2hlcyBiYXNpYyBvZmZzZXQgdGFibGUgZW50cnlcIjtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoaXMgZnJhbWVcbiAgICB2YXIgbnVtRnJhZ21lbnRzID0gY2FsY3VsYXRlTnVtYmVyT2ZGcmFnbWVudHNGb3JGcmFtZShmcmFtZUluZGV4LCBiYXNpY09mZnNldFRhYmxlLCBmcmFnbWVudHMsIHN0YXJ0RnJhZ21lbnRJbmRleCk7XG5cbiAgICAvLyBub3cgZXh0cmFjdCB0aGUgZnJhbWUgZnJvbSB0aGUgZnJhZ21lbnRzXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIHN0YXJ0RnJhZ21lbnRJbmRleCwgbnVtRnJhZ21lbnRzLCBmcmFnbWVudHMpO1xuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcblxuLyoqXG4gKiBGdW5jdGlvbmFsaXR5IGZvciBleHRyYWN0aW5nIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVCdWZmZXJTaXplKGZyYWdtZW50cywgc3RhcnRGcmFnbWVudCwgbnVtRnJhZ21lbnRzKSB7XG4gICAgdmFyIGJ1ZmZlclNpemUgPSAwO1xuICAgIGZvcih2YXIgaT1zdGFydEZyYWdtZW50OyBpIDwgc3RhcnRGcmFnbWVudCArIG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICBidWZmZXJTaXplICs9IGZyYWdtZW50c1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhIGZyb20gdGhlIHNwZWNpZmllZCBmcmFnbWVudHMuICBVc2UgdGhpcyBmdW5jdGlvbiB3aGVuIHlvdSBrbm93XG4gICAqIHRoZSBmcmFnbWVudHMgeW91IHdhbnQgdG8gZXh0cmFjdCBkYXRhIGZyb20uICBTZWVcbiAgICpcbiAgICogQHBhcmFtIGRhdGFTZXQgLSB0aGUgZGF0YVNldCBjb250YWluaW5nIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgKiBAcGFyYW0gcGl4ZWxEYXRhRWxlbWVudCAtIHRoZSBwaXhlbCBkYXRhIGVsZW1lbnQgKHg3ZmUwMDAxMCkgdG8gZXh0cmFjdCB0aGUgZnJhZ21lbnQgZGF0YSBmcm9tXG4gICAqIEBwYXJhbSBzdGFydEZyYWdtZW50SW5kZXggLSB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBmaXJzdCBmcmFnbWVudCB0byBleHRyYWN0IGZyb21cbiAgICogQHBhcmFtIFtudW1GcmFnbWVudHNdIC0gdGhlIG51bWJlciBvZiBmcmFnbWVudHMgdG8gZXh0cmFjdCBmcm9tLCBkZWZhdWx0IGlzIDFcbiAgICogQHBhcmFtIFtmcmFnbWVudHNdIC0gb3B0aW9uYWwgYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGVhY2ggZnJhZ21lbnQgKG9mZnNldCwgcG9zaXRpb24sIGxlbmd0aClcbiAgICogQHJldHVybnMge29iamVjdH0gYnl0ZSBhcnJheSB3aXRoIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgKi9cbiAgZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHMgPSBmdW5jdGlvbihkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBzdGFydEZyYWdtZW50SW5kZXgsIG51bUZyYWdtZW50cywgZnJhZ21lbnRzKVxuICB7XG4gICAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgICBudW1GcmFnbWVudHMgPSBudW1GcmFnbWVudHMgfHwgMTtcbiAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMgfHwgcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHM7XG5cbiAgICAvLyBjaGVjayBwYXJhbWV0ZXJzXG4gICAgaWYoZGF0YVNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZGF0YVNldCdcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCdcIjtcbiAgICB9XG4gICAgaWYoc3RhcnRGcmFnbWVudEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdzdGFydEZyYWdtZW50SW5kZXgnXCI7XG4gICAgfVxuICAgIGlmKG51bUZyYWdtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnbnVtRnJhZ21lbnRzJ1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LnRhZyAhPT0gJ3g3ZmUwMDAxMCcpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIG5vbiBwaXhlbCBkYXRhIHRhZyAoZXhwZWN0ZWQgdGFnID0geDdmZTAwMDEwJ1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmVuY2Fwc3VsYXRlZFBpeGVsRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHN0YXJ0RnJhZ21lbnRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAnc3RhcnRGcmFnbWVudEluZGV4JyBtdXN0IGJlID49IDBcIjtcbiAgICB9XG4gICAgaWYoc3RhcnRGcmFnbWVudEluZGV4ID49IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdzdGFydEZyYWdtZW50SW5kZXgnIG11c3QgYmUgPCBudW1iZXIgb2YgZnJhZ21lbnRzXCI7XG4gICAgfVxuICAgIGlmKG51bUZyYWdtZW50cyA8IDEpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAnbnVtRnJhZ21lbnRzJyBtdXN0IGJlID4gMFwiO1xuICAgIH1cbiAgICBpZihzdGFydEZyYWdtZW50SW5kZXggKyBudW1GcmFnbWVudHMgPiBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAnc3RhcnRGcmFnbWVudCcgKyAnbnVtRnJhZ21lbnRzJyA8IG51bWJlciBvZiBmcmFnbWVudHNcIjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYnl0ZSBzdHJlYW0gb24gdGhlIGRhdGEgZm9yIHRoaXMgcGl4ZWwgZGF0YSBlbGVtZW50XG4gICAgdmFyIGJ5dGVTdHJlYW0gPSBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkYXRhU2V0LmJ5dGVBcnJheVBhcnNlciwgZGF0YVNldC5ieXRlQXJyYXksIHBpeGVsRGF0YUVsZW1lbnQuZGF0YU9mZnNldCk7XG5cbiAgICAvLyBzZWVrIHBhc3QgdGhlIGJhc2ljIG9mZnNldCB0YWJsZSAobm8gbmVlZCB0byBwYXJzZSBpdCBhZ2FpbiBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUpXG4gICAgdmFyIGJhc2ljT2Zmc2V0VGFibGUgPSBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtKGJ5dGVTdHJlYW0pO1xuICAgIGlmKGJhc2ljT2Zmc2V0VGFibGUudGFnICE9PSAneGZmZmVlMDAwJylcbiAgICB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IG1pc3NpbmcgYmFzaWMgb2Zmc2V0IHRhYmxlIHhmZmZlZTAwMFwiO1xuICAgIH1cbiAgICBieXRlU3RyZWFtLnNlZWsoYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGgpO1xuXG4gICAgdmFyIGZyYWdtZW50WmVyb1Bvc2l0aW9uID0gYnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICB2YXIgZnJhZ21lbnRIZWFkZXJTaXplID0gODsgLy8gdGFnICsgbGVuZ3RoXG5cbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBmcmFnbWVudCwgcmV0dXJuIGEgdmlldyBvbiB0aGlzIGFycmF5IHRvIGF2b2lkIGNvcHlpbmdcbiAgICBpZihudW1GcmFnbWVudHMgPT09IDEpIHtcbiAgICAgIHJldHVybiBkaWNvbVBhcnNlci5zaGFyZWRDb3B5KGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBmcmFnbWVudFplcm9Qb3NpdGlvbiArIGZyYWdtZW50c1tzdGFydEZyYWdtZW50SW5kZXhdLm9mZnNldCArIGZyYWdtZW50SGVhZGVyU2l6ZSwgZnJhZ21lbnRzW3N0YXJ0RnJhZ21lbnRJbmRleF0ubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBtb3JlIHRoYW4gb25lIGZyYWdtZW50LCBjb21iaW5lIGFsbCBvZiB0aGUgZnJhZ21lbnRzIGludG8gb25lIGJ1ZmZlclxuICAgIHZhciBidWZmZXJTaXplID0gY2FsY3VsYXRlQnVmZmVyU2l6ZShmcmFnbWVudHMsIHN0YXJ0RnJhZ21lbnRJbmRleCwgbnVtRnJhZ21lbnRzKTtcblxuICAgIHZhciBwaXhlbERhdGEgPSBkaWNvbVBhcnNlci5hbGxvYyhieXRlU3RyZWFtLmJ5dGVBcnJheSwgYnVmZmVyU2l6ZSk7XG5cbiAgICB2YXIgcGl4ZWxEYXRhSW5kZXggPSAwO1xuICAgIGZvcih2YXIgaT1zdGFydEZyYWdtZW50SW5kZXg7IGkgPCBzdGFydEZyYWdtZW50SW5kZXggKyBudW1GcmFnbWVudHM7IGkrKykge1xuICAgICAgdmFyIGZyYWdtZW50T2Zmc2V0ID0gZnJhZ21lbnRaZXJvUG9zaXRpb24gKyBmcmFnbWVudHNbaV0ub2Zmc2V0ICsgZnJhZ21lbnRIZWFkZXJTaXplO1xuICAgICAgZm9yKHZhciBqPTA7IGogPCBmcmFnbWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGl4ZWxEYXRhW3BpeGVsRGF0YUluZGV4KytdID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXlbZnJhZ21lbnRPZmZzZXQrK107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBpeGVsRGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG5cbi8qKlxuICogUGFyc2VzIGEgRElDT00gUDEwIGJ5dGUgYXJyYXkgYW5kIHJldHVybnMgYSBEYXRhU2V0IG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgZWxlbWVudHMuICBJZiB0aGUgb3B0aW9uc1xuICogYXJndW1lbnQgaXMgc3VwcGxpZWQgYW5kIGl0IGNvbnRhaW5zIHRoZSB1bnRpbFRhZyBwcm9wZXJ0eSwgcGFyc2luZyB3aWxsIHN0b3Agb25jZSB0aGF0XG4gKiB0YWcgaXMgZW5jb3V0ZXJlZC4gIFRoaXMgY2FuIGJlIHVzZWQgdG8gcGFyc2UgcGFydGlhbCBieXRlIHN0cmVhbXMuXG4gKlxuICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheVxuICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHRvIGNvbnRyb2wgcGFyc2luZyBiZWhhdmlvciAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7RGF0YVNldH1cbiAqIEB0aHJvd3MgZXJyb3IgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHBhcnNpbmcuICBUaGUgZXhjZXB0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gYSBwcm9wZXJ0eSBkYXRhU2V0IHdpdGggdGhlXG4gKiAgICAgICAgIGVsZW1lbnRzIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYmVmb3JlIHRoZSBlcnJvci5cbiAqL1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uKGRpY29tUGFyc2VyKSB7XG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgZGljb21QYXJzZXIucmVhZFBhcnQxMEhlYWRlciA9IGZ1bmN0aW9uKGJ5dGVBcnJheSwgb3B0aW9ucykge1xuXG4gICAgaWYoYnl0ZUFycmF5ID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkUGFydDEwSGVhZGVyOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZUFycmF5J1wiO1xuICAgIH1cblxuICAgIHZhciBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtID0gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXkpO1xuXG4gICAgZnVuY3Rpb24gcmVhZFByZWZpeCgpXG4gICAge1xuICAgICAgbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5zZWVrKDEyOCk7XG4gICAgICB2YXIgcHJlZml4ID0gbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5yZWFkRml4ZWRTdHJpbmcoNCk7XG4gICAgICBpZihwcmVmaXggIT09IFwiRElDTVwiKVxuICAgICAge1xuICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRQYXJ0MTBIZWFkZXI6IERJQ00gcHJlZml4IG5vdCBmb3VuZCBhdCBsb2NhdGlvbiAxMzIgLSB0aGlzIGlzIG5vdCBhIHZhbGlkIERJQ09NIFAxMCBmaWxlLlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1haW4gZnVuY3Rpb24gaGVyZVxuICAgIGZ1bmN0aW9uIHJlYWRUaGVIZWFkZXIoKSB7XG4gICAgICAvLyBQZXIgdGhlIERJQ09NIHN0YW5kYXJkLCB0aGUgaGVhZGVyIGlzIGFsd2F5cyBlbmNvZGVkIGluIEV4cGxpY2l0IFZSIExpdHRsZSBFbmRpYW4gKHNlZSBQUzMuMTAsIHNlY3Rpb24gNy4xKVxuICAgICAgLy8gc28gdXNlIGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0gdGhyb3VnaG91dCB0aGlzIG1ldGhvZCByZWdhcmRsZXNzIG9mIHRoZSB0cmFuc2ZlciBzeW50YXhcbiAgICAgIHJlYWRQcmVmaXgoKTtcblxuICAgICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgICB2YXIgZWxlbWVudHMgPSB7fTtcbiAgICAgIHdoaWxlKGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ucG9zaXRpb24gPCBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50RXhwbGljaXQobGl0dGxlRW5kaWFuQnl0ZVN0cmVhbSwgd2FybmluZ3MpO1xuICAgICAgICBpZihlbGVtZW50LnRhZyA+ICd4MDAwMmZmZmYnKSB7XG4gICAgICAgICAgbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhY2hlIHRoZSBsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIgZm9yIG1ldGEgaGVhZGVyIGVsZW1lbnRzLCBzaW5jZSB0aGUgcmVzdCBvZiB0aGUgZGF0YSBzZXQgbWF5IGJlIGJpZyBlbmRpYW5cbiAgICAgICAgLy8gYW5kIHRoaXMgcGFyc2VyIHdpbGwgYmUgbmVlZGVkIGxhdGVyIGlmIHRoZSBtZXRhIGhlYWRlciB2YWx1ZXMgYXJlIHRvIGJlIHJlYWQuXG4gICAgICAgIGVsZW1lbnQucGFyc2VyID0gZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyO1xuICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuICAgICAgfVxuICAgICAgdmFyIG1ldGFIZWFkZXJEYXRhU2V0ID0gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQobGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBlbGVtZW50cyk7XG4gICAgICBtZXRhSGVhZGVyRGF0YVNldC53YXJuaW5ncyA9IGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ud2FybmluZ3M7XG4gICAgICBtZXRhSGVhZGVyRGF0YVNldC5wb3NpdGlvbiA9IGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICByZXR1cm4gbWV0YUhlYWRlckRhdGFTZXQ7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB3aGVyZSB3ZSBhY3R1YWxseSBzdGFydCBwYXJzaW5nXG4gICAgcmV0dXJuIHJlYWRUaGVIZWFkZXIoKTtcbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KShkaWNvbVBhcnNlcik7XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkRGljb21EYXRhU2V0RXhwbGljaXRVbmRlZmluZWRMZW5ndGgoYnl0ZVN0cmVhbSwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcblxuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRFeHBsaWNpdChieXRlU3RyZWFtLCB3YXJuaW5ncyk7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuXG4gICAgICAgICAgICAvLyB3ZSBoaXQgYW4gaXRlbSBkZWxpbWl0ZXIgdGFnLCByZXR1cm4gdGhlIGN1cnJlbnQgb2Zmc2V0IHRvIG1hcmtcbiAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhpcyBzZXF1ZW5jZSBpdGVtXG4gICAgICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gJ3hmZmZlZTAwZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwgZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBlb2YgZW5jb3VudGVyZWQgLSBsb2cgYSB3YXJuaW5nIGFuZCByZXR1cm4gd2hhdCB3ZSBoYXZlIGZvciB0aGUgZWxlbWVudFxuICAgICAgICB3YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgaXRlbSBkZWxpbWl0ZXIgdGFnIHdoaWxlIHJlYWRpbmcgc2VxdWVuY2UgaXRlbSBvZiB1bmRlZmluZWQgbGVuZ3RoJyk7XG4gICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuRGF0YVNldChieXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgYnl0ZVN0cmVhbS5ieXRlQXJyYXksIGVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU2VxdWVuY2VJdGVtRXhwbGljaXQoYnl0ZVN0cmVhbSwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW0oYnl0ZVN0cmVhbSk7XG5cbiAgICAgICAgaWYoaXRlbS5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW0uaGFkVW5kZWZpbmVkTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICAgIGl0ZW0uZGF0YVNldCA9IHJlYWREaWNvbURhdGFTZXRFeHBsaWNpdFVuZGVmaW5lZExlbmd0aChieXRlU3RyZWFtLCB3YXJuaW5ncyk7XG4gICAgICAgICAgICBpdGVtLmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBpdGVtLmRhdGFPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpdGVtLmRhdGFTZXQgPSBuZXcgZGljb21QYXJzZXIuRGF0YVNldChieXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgYnl0ZVN0cmVhbS5ieXRlQXJyYXksIHt9KTtcbiAgICAgICAgICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQoaXRlbS5kYXRhU2V0LCBieXRlU3RyZWFtLCBieXRlU3RyZWFtLnBvc2l0aW9uICsgaXRlbS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTUUVsZW1lbnRVbmRlZmluZWRMZW5ndGhFeHBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncylcbiAgICB7XG4gICAgICAgIHdoaWxlKChieXRlU3RyZWFtLnBvc2l0aW9uICsgNCkgPD0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gZW5kIHJlYWRpbmcgdGhpcyBzZXF1ZW5jZSBpZiB0aGUgbmV4dCB0YWcgaXMgdGhlIHNlcXVlbmNlIGRlbGltaXRhdGlvbiBpdGVtXG4gICAgICAgICAgdmFyIG5leHRUYWcgPSBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pO1xuICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlaygtNCk7XG4gICAgICAgICAgaWYgKG5leHRUYWcgPT09ICd4ZmZmZWUwZGQnKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoOCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gcmVhZFNlcXVlbmNlSXRlbUV4cGxpY2l0KGJ5dGVTdHJlYW0sIHdhcm5pbmdzKTtcbiAgICAgICAgICAgIGVsZW1lbnQuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgc2VxdWVuY2UgZGVsaW1pdGF0aW9uIHRhZyB3aGlsZSByZWFkaW5nIHNlcXVlbmNlIG9mIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTUUVsZW1lbnRLbm93bkxlbmd0aEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKVxuICAgIHtcbiAgICAgICAgdmFyIG1heFBvc2l0aW9uID0gZWxlbWVudC5kYXRhT2Zmc2V0ICsgZWxlbWVudC5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBtYXhQb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSByZWFkU2VxdWVuY2VJdGVtRXhwbGljaXQoYnl0ZVN0cmVhbSwgd2FybmluZ3MpO1xuICAgICAgICAgICAgZWxlbWVudC5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNFeHBsaWNpdCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zRXhwbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0V4cGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZWxlbWVudCdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuaXRlbXMgPSBbXTtcblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVhZFNRRWxlbWVudFVuZGVmaW5lZExlbmd0aEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlYWRTUUVsZW1lbnRLbm93bkxlbmd0aEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkRGljb21EYXRhU2V0SW1wbGljaXRVbmRlZmluZWRMZW5ndGgoYnl0ZVN0cmVhbSwgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuXG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0KGJ5dGVTdHJlYW0sIHVuZGVmaW5lZCwgdnJDYWxsYmFjayk7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuXG4gICAgICAgICAgICAvLyB3ZSBoaXQgYW4gaXRlbSBkZWxpbWl0ZXIgdGFnLCByZXR1cm4gdGhlIGN1cnJlbnQgb2Zmc2V0IHRvIG1hcmtcbiAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhpcyBzZXF1ZW5jZSBpdGVtXG4gICAgICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gJ3hmZmZlZTAwZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwgZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVvZiBlbmNvdW50ZXJlZCAtIGxvZyBhIHdhcm5pbmcgYW5kIHJldHVybiB3aGF0IHdlIGhhdmUgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgIGJ5dGVTdHJlYW0ud2FybmluZ3MucHVzaCgnZW9mIGVuY291bnRlcmVkIGJlZm9yZSBmaW5kaW5nIHNlcXVlbmNlIGl0ZW0gZGVsaW1pdGVyIGluIHNlcXVlbmNlIGl0ZW0gb2YgdW5kZWZpbmVkIGxlbmd0aCcpO1xuICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoYnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFNlcXVlbmNlSXRlbUltcGxpY2l0KGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW0oYnl0ZVN0cmVhbSk7XG5cbiAgICAgICAgaWYoaXRlbS5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW0uaGFkVW5kZWZpbmVkTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICAgIGl0ZW0uZGF0YVNldCA9IHJlYWREaWNvbURhdGFTZXRJbXBsaWNpdFVuZGVmaW5lZExlbmd0aChieXRlU3RyZWFtLCB2ckNhbGxiYWNrKTtcbiAgICAgICAgICAgIGl0ZW0ubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGl0ZW0uZGF0YU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW0uZGF0YVNldCA9IG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwge30pO1xuICAgICAgICAgICAgZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRJbXBsaWNpdChpdGVtLmRhdGFTZXQsIGJ5dGVTdHJlYW0sIGJ5dGVTdHJlYW0ucG9zaXRpb24gKyBpdGVtLmxlbmd0aCwge3ZyQ2FsbGJhY2s6IHZyQ2FsbGJhY2t9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU1FFbGVtZW50VW5kZWZpbmVkTGVuZ3RoSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHdoaWxlKChieXRlU3RyZWFtLnBvc2l0aW9uICsgNCkgPD0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gZW5kIHJlYWRpbmcgdGhpcyBzZXF1ZW5jZSBpZiB0aGUgbmV4dCB0YWcgaXMgdGhlIHNlcXVlbmNlIGRlbGltaXRhdGlvbiBpdGVtXG4gICAgICAgICAgdmFyIG5leHRUYWcgPSBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pO1xuICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlaygtNCk7XG4gICAgICAgICAgaWYgKG5leHRUYWcgPT09ICd4ZmZmZWUwZGQnKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoOCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXRlbSA9IHJlYWRTZXF1ZW5jZUl0ZW1JbXBsaWNpdChieXRlU3RyZWFtLCB2ckNhbGxiYWNrKTtcbiAgICAgICAgICBlbGVtZW50Lml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgc2VxdWVuY2UgZGVsaW1pdGVyIGluIHNlcXVlbmNlIG9mIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFNRRWxlbWVudEtub3duTGVuZ3RoSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IGVsZW1lbnQuZGF0YU9mZnNldCArIGVsZW1lbnQubGVuZ3RoO1xuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgbWF4UG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gcmVhZFNlcXVlbmNlSXRlbUltcGxpY2l0KGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spO1xuICAgICAgICAgICAgZWxlbWVudC5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgc2VxdWVuY2UgaXRlbXMgZm9yIGFuIGVsZW1lbnQgaW4gYW4gaW1wbGljaXQgbGl0dGxlIGVuZGlhbiBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtIHRoZSBpbXBsaWNpdCBsaXR0bGUgZW5kaWFuIGJ5dGUgc3RyZWFtXG4gICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gcmVhZCB0aGUgc2VxdWVuY2UgaXRlbXMgZm9yXG4gICAgICogQHBhcmFtIHZyQ2FsbGJhY2sgYW4gb3B0aW9uYWwgbWV0aG9kIHRoYXQgcmV0dXJucyBhIFZSIHN0cmluZyBnaXZlbiBhIHRhZ1xuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQgPSBmdW5jdGlvbihieXRlU3RyZWFtLCBlbGVtZW50LCB2ckNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0ltcGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZWxlbWVudCdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuaXRlbXMgPSBbXTtcblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVhZFNRRWxlbWVudFVuZGVmaW5lZExlbmd0aEltcGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHZyQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmVhZFNRRWxlbWVudEtub3duTGVuZ3RoSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgdnJDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSB0YWcgYW5kIGxlbmd0aCBvZiBhIHNlcXVlbmNlIGl0ZW0gYW5kIHJldHVybnMgdGhlbSBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcbiAgICAgKiAgdGFnIDogc3RyaW5nIGZvciB0aGUgdGFnIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgZm9ybWF0IHhnZ2dnZWVlZVxuICAgICAqICBsZW5ndGg6IHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBpdGVtIG9yIDQyOTQ5NjcyOTUgaWYgdW5kZWZpbmVkXG4gICAgICogIGRhdGFPZmZzZXQ6IHRoZSBvZmZzZXQgaW50byB0aGUgYnl0ZVN0cmVhbSBvZiB0aGUgZGF0YSBmb3IgdGhpcyBpdGVtXG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW0gdGhlIGJ5dGVcbiAgICAgKiBAcmV0dXJucyB7e3RhZzogc3RyaW5nLCBsZW5ndGg6IGludGVnZXIsIGRhdGFPZmZzZXQ6IGludGVnZXJ9fVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW0gPSBmdW5jdGlvbihieXRlU3RyZWFtKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW06IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICB0YWcgOiBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pLFxuICAgICAgICAgICAgbGVuZ3RoIDogYnl0ZVN0cmVhbS5yZWFkVWludDMyKCksXG4gICAgICAgICAgICBkYXRhT2Zmc2V0IDogIGJ5dGVTdHJlYW0ucG9zaXRpb25cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZWxlbWVudC50YWcgIT09ICd4ZmZmZWUwMDAnKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IGJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW06IGl0ZW0gdGFnIChGRkZFLEUwMDApIG5vdCBmb3VuZCBhdCBvZmZzZXQgXCIgKyBzdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgdGFnIChncm91cCBudW1iZXIgYW5kIGVsZW1lbnQgbnVtYmVyKSBmcm9tIGEgYnl0ZVN0cmVhbVxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtIHRoZSBieXRlIHN0cmVhbSB0byByZWFkIGZyb21cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdGFnIGluIGZvcm1hdCB4Z2dnZ2VlZWUgd2hlcmUgZ2dnZyBpcyB0aGUgbG93ZXJjYXNlIGhleCB2YWx1ZSBvZiB0aGUgZ3JvdXAgbnVtYmVyXG4gICAgICogYW5kIGVlZWUgaXMgdGhlIGxvd2VyIGNhc2UgaGV4IHZhbHVlIG9mIHRoZSBlbGVtZW50IG51bWJlclxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnJlYWRUYWcgPSBmdW5jdGlvbihieXRlU3RyZWFtKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRUYWc6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwTnVtYmVyID0gIGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpICogMjU2ICogMjU2O1xuICAgICAgICB2YXIgZWxlbWVudE51bWJlciA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgICAgICB2YXIgdGFnID0gXCJ4XCIgKyAoJzAwMDAwMDAwJyArIChncm91cE51bWJlciArIGVsZW1lbnROdW1iZXIpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC04KTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHNoYXJlZCBjb3B5IG9mIGEgYnl0ZUFycmF5XG4gKlxuICovXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdmlldyBvZiB0aGUgdW5kZXJseWluZyBieXRlQXJyYXkuICBUaGUgdmlldyBpcyBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBieXRlQXJyYXkgKGUuZy5cbiAgICogVWludDhBcnJheSBvciBCdWZmZXIpIGFuZCBzaGFyZXMgdGhlIHNhbWUgdW5kZXJseWluZyBtZW1vcnkgKGNoYW5naW5nIG9uZSBjaGFuZ2VzIHRoZSBvdGhlcilcbiAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgdW5kZXJseWluZyBieXRlQXJyYXkgKGVpdGhlciBVaW50OEFycmF5IG9yIEJ1ZmZlcilcbiAgICogQHBhcmFtIGJ5dGVPZmZzZXQgb2Zmc2V0IGludG8gdGhlIHVuZGVybHlpbmcgYnl0ZUFycmF5IHRvIGNyZWF0ZSB0aGUgdmlldyBvZlxuICAgKiBAcGFyYW0gbGVuZ3RoIG51bWJlciBvZiBieXRlcyBpbiB0aGUgdmlld1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBVaW50OEFycmF5IG9yIEJ1ZmZlciBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYnl0ZUFycmF5XG4gICAqL1xuICBkaWNvbVBhcnNlci5zaGFyZWRDb3B5ID0gZnVuY3Rpb24oYnl0ZUFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnl0ZUFycmF5IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICByZXR1cm4gYnl0ZUFycmF5LnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmKGJ5dGVBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlQXJyYXkuYnVmZmVyLCBieXRlQXJyYXkuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdkaWNvbVBhcnNlci5mcm9tOiB1bmtub3duIHR5cGUgZm9yIGJ5dGVBcnJheSc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogVmVyc2lvblxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgZGljb21QYXJzZXIudmVyc2lvbiA9IFwiMS43LjNcIjtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufSkpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjID0ganBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhTYW1wID0gMDsgLy8gSG9yaXpvbnRhbCBzYW1wbGluZyBmYWN0b3JcbiAgICB0aGlzLnF1YW50VGFibGVTZWwgPSAwOyAvLyBRdWFudGl6YXRpb24gdGFibGUgZGVzdGluYXRpb24gc2VsZWN0b3JcbiAgICB0aGlzLnZTYW1wID0gMDsgLy8gVmVydGljYWxcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IERhdGFWaWV3KGRhdGEsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB0aGlzLmluZGV4ID0gMDtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0ucHJvdG90eXBlLmdldDE2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuYnVmZmVyLmdldFVpbnQxNih0aGlzLmluZGV4LCBmYWxzZSk7XG4gICAgdGhpcy5pbmRleCArPSAyO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0ucHJvdG90eXBlLmdldDggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5idWZmZXIuZ2V0VWludDgodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbmRleCArPSAxO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZGF0YS1zdHJlYW0uanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgPSBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2h1ZmZtYW4tdGFibGUuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSA9IGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9xdWFudGl6YXRpb24tdGFibGUuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyID0ganBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vc2Nhbi1oZWFkZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciA9IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9mcmFtZS1oZWFkZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5VdGlscyA9IGpwZWcubG9zc2xlc3MuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlscy5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIgPSBqcGVnLmxvc3NsZXNzLkRlY29kZXIgfHwgZnVuY3Rpb24gKGJ1ZmZlciwgbnVtQnl0ZXMpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLmZyYW1lID0gbmV3IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIoKTtcbiAgICB0aGlzLmh1ZmZUYWJsZSA9IG5ldyBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSgpO1xuICAgIHRoaXMucXVhbnRUYWJsZSA9IG5ldyBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlKCk7XG4gICAgdGhpcy5zY2FuID0gbmV3IGpwZWcubG9zc2xlc3MuU2NhbkhlYWRlcigpO1xuICAgIHRoaXMuRFUgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDEwLCA0LCA2NCk7IC8vIGF0IG1vc3QgMTAgZGF0YSB1bml0cyBpbiBhIE1DVSwgYXQgbW9zdCA0IGRhdGEgdW5pdHMgaW4gb25lIGNvbXBvbmVudFxuICAgIHRoaXMuSHVmZlRhYiA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgMiwgNTAgKiAyNTYpO1xuICAgIHRoaXMuSURDVF9Tb3VyY2UgPSBbXTtcbiAgICB0aGlzLm5CbG9jayA9IFtdOyAvLyBudW1iZXIgb2YgYmxvY2tzIGluIHRoZSBpLXRoIENvbXAgaW4gYSBzY2FuXG4gICAgdGhpcy5hY1RhYiA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoMTAsIDEpOyAvLyBhYyBIdWZmVGFiIGZvciB0aGUgaS10aCBDb21wIGluIGEgc2NhblxuICAgIHRoaXMuZGNUYWIgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDEwLCAxKTsgLy8gZGMgSHVmZlRhYiBmb3IgdGhlIGktdGggQ29tcCBpbiBhIHNjYW5cbiAgICB0aGlzLnFUYWIgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDEwLCAxKTsgLy8gcXVhbnRpemF0aW9uIHRhYmxlIGZvciB0aGUgaS10aCBDb21wIGluIGEgc2NhblxuICAgIHRoaXMubWFya2VyID0gMDtcbiAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICB0aGlzLm51bUNvbXAgPSAwO1xuICAgIHRoaXMucmVzdGFydEludGVydmFsID0gMDtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IDA7XG4gICAgdGhpcy54RGltID0gMDtcbiAgICB0aGlzLnlEaW0gPSAwO1xuICAgIHRoaXMueExvYyA9IDA7XG4gICAgdGhpcy55TG9jID0gMDtcbiAgICB0aGlzLm51bUJ5dGVzID0gMDtcbiAgICB0aGlzLm91dHB1dERhdGEgPSBudWxsO1xuICAgIHRoaXMucmVzdGFydGluZyA9IGZhbHNlO1xuICAgIHRoaXMubWFzayA9IDA7XG5cbiAgICBpZiAodHlwZW9mIG51bUJ5dGVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMubnVtQnl0ZXMgPSBudW1CeXRlcztcbiAgICB9XG59O1xuXG5cbi8qKiogU3RhdGljIFBzZXVkby1jb25zdGFudHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuSURDVF9QID0gWzAsIDUsIDQwLCAxNiwgNDUsIDIsIDcsIDQyLCAyMSwgNTYsIDgsIDYxLCAxOCwgNDcsIDEsIDQsIDQxLCAyMywgNTgsIDEzLCAzMiwgMjQsIDM3LCAxMCwgNjMsIDE3LCA0NCwgMywgNiwgNDMsIDIwLFxuICAgIDU3LCAxNSwgMzQsIDI5LCA0OCwgNTMsIDI2LCAzOSwgOSwgNjAsIDE5LCA0NiwgMjIsIDU5LCAxMiwgMzMsIDMxLCA1MCwgNTUsIDI1LCAzNiwgMTEsIDYyLCAxNCwgMzUsIDI4LCA0OSwgNTIsIDI3LCAzOCwgMzAsIDUxLCA1NF07XG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuVEFCTEUgPSBbMCwgMSwgNSwgNiwgMTQsIDE1LCAyNywgMjgsIDIsIDQsIDcsIDEzLCAxNiwgMjYsIDI5LCA0MiwgMywgOCwgMTIsIDE3LCAyNSwgMzAsIDQxLCA0MywgOSwgMTEsIDE4LCAyNCwgMzEsIDQwLCA0NCwgNTMsXG4gICAgMTAsIDE5LCAyMywgMzIsIDM5LCA0NSwgNTIsIDU0LCAyMCwgMjIsIDMzLCAzOCwgNDYsIDUxLCA1NSwgNjAsIDIxLCAzNCwgMzcsIDQ3LCA1MCwgNTYsIDU5LCA2MSwgMzUsIDM2LCA0OCwgNDksIDU3LCA1OCwgNjIsIDYzXTtcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5NQVhfSFVGRk1BTl9TVUJUUkVFID0gNTA7XG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuTVNCID0gMHg4MDAwMDAwMDtcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5SRVNUQVJUX01BUktFUl9CRUdJTiA9IDB4RkZEMDtcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5SRVNUQVJUX01BUktFUl9FTkQgPSAweEZGRDc7XG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmRlY29tcHJlc3MgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZShidWZmZXIsIG9mZnNldCwgbGVuZ3RoKS5idWZmZXI7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbnVtQnl0ZXMpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY3VycmVudCwgc2Nhbk51bSA9IDAsIHByZWQgPSBbXSwgaSwgY29tcE4sIHRlbXAgPSBbXSwgaW5kZXggPSBbXSwgbWN1TnVtO1xuXG4gICAgaWYgKHR5cGVvZiBidWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1CeXRlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLm51bUJ5dGVzID0gbnVtQnl0ZXM7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJlYW0gPSBuZXcganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtKHRoaXMuYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuXG4gICAgdGhpcy54TG9jID0gMDtcbiAgICB0aGlzLnlMb2MgPSAwO1xuICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IDB4RkZEOCkgeyAvLyBTT0lcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgSlBFRyBmaWxlXCIpO1xuICAgIH1cblxuICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuXG4gICAgd2hpbGUgKCgoKGN1cnJlbnQgPj4gNCkgIT09IDB4MEZGQykgfHwgKGN1cnJlbnQgPT09IDB4RkZDNCkpKSB7IC8vIFNPRiAwfjE1XG4gICAgICAgIHN3aXRjaCAoY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSAweEZGQzQ6IC8vIERIVFxuICAgICAgICAgICAgICAgIHRoaXMuaHVmZlRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIHRoaXMuSHVmZlRhYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkZDQzogLy8gREFDXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbSBkb2Vzbid0IHN1cHBvcnQgYXJpdGhtZXRpYyBjb2RpbmcuIChmb3JtYXQgdGhyb3cgbmV3IElPRXhjZXB0aW9uKVwiKTtcbiAgICAgICAgICAgIGNhc2UgMHhGRkRCOlxuICAgICAgICAgICAgICAgIHRoaXMucXVhbnRUYWJsZS5yZWFkKHRoaXMuc3RyZWFtLCBqcGVnLmxvc3NsZXNzLkRlY29kZXIuVEFCTEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGREQ6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0SW50ZXJ2YWwgPSB0aGlzLnJlYWROdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRkUwOlxuICAgICAgICAgICAgY2FzZSAweEZGRTE6XG4gICAgICAgICAgICBjYXNlIDB4RkZFMjpcbiAgICAgICAgICAgIGNhc2UgMHhGRkUzOlxuICAgICAgICAgICAgY2FzZSAweEZGRTQ6XG4gICAgICAgICAgICBjYXNlIDB4RkZFNTpcbiAgICAgICAgICAgIGNhc2UgMHhGRkU2OlxuICAgICAgICAgICAgY2FzZSAweEZGRTc6XG4gICAgICAgICAgICBjYXNlIDB4RkZFODpcbiAgICAgICAgICAgIGNhc2UgMHhGRkU5OlxuICAgICAgICAgICAgY2FzZSAweEZGRUE6XG4gICAgICAgICAgICBjYXNlIDB4RkZFQjpcbiAgICAgICAgICAgIGNhc2UgMHhGRkVDOlxuICAgICAgICAgICAgY2FzZSAweEZGRUQ6XG4gICAgICAgICAgICBjYXNlIDB4RkZFRTpcbiAgICAgICAgICAgIGNhc2UgMHhGRkVGOlxuICAgICAgICAgICAgICAgIHRoaXMucmVhZEFwcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGRkU6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnQgPj4gOCkgIT09IDB4RkYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24hIChkZWNvZGUpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgIH1cblxuICAgIGlmICgoY3VycmVudCA8IDB4RkZDMCkgfHwgKGN1cnJlbnQgPiAweEZGQzcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBjb3VsZCBub3QgaGFuZGxlIGFyaXRobWV0aWMgY29kZSFcIik7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZS5yZWFkKHRoaXMuc3RyZWFtKTtcbiAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcblxuICAgIGRvIHtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IDB4MEZGREEpIHsgLy8gU09TXG4gICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZDNDogLy8gREhUXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHVmZlRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIHRoaXMuSHVmZlRhYik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkNDOiAvLyBEQUNcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbSBkb2Vzbid0IHN1cHBvcnQgYXJpdGhtZXRpYyBjb2RpbmcuIChmb3JtYXQgdGhyb3cgbmV3IElPRXhjZXB0aW9uKVwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZEQjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFudFRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIGpwZWcubG9zc2xlc3MuRGVjb2Rlci5UQUJMRSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkREOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRJbnRlcnZhbCA9IHRoaXMucmVhZE51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFODpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFOTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFQTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFQjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFQzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFRDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFRTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFRjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQXBwKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkZFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudCA+PiA4KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24hIChQYXJzZXIuZGVjb2RlKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gdGhpcy5mcmFtZS5wcmVjaXNpb247XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHRoaXMuZnJhbWUuY29tcG9uZW50cztcblxuICAgICAgICBpZiAoIXRoaXMubnVtQnl0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtQnl0ZXMgPSBwYXJzZUludChNYXRoLmNlaWwodGhpcy5wcmVjaXNpb24gLyA4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5udW1CeXRlcyA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLm1hc2sgPSAweEZGO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXNrID0gMHhGRkZGO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2FuLnJlYWQodGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLm51bUNvbXAgPSB0aGlzLnNjYW4ubnVtQ29tcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNjYW4uc2VsZWN0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm51bUJ5dGVzID09PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5udW1Db21wID09PSAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSB0aGlzLmdldFZhbHVlUkdCO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyID0gdGhpcy5zZXRWYWx1ZVJHQjtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0UkdCO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldHRlciA9IHRoaXMuZ2V0VmFsdWU4O1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyID0gdGhpcy5zZXRWYWx1ZTg7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dFNpbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gdGhpcy5nZXRWYWx1ZTE2O1xuICAgICAgICAgICAgdGhpcy5zZXR0ZXIgPSB0aGlzLnNldFZhbHVlMTY7XG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0U2luZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0MztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Q0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Q3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3QxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2FuQ29tcHMgPSB0aGlzLnNjYW4uY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5xdWFudFRhYmxlcyA9IHRoaXMucXVhbnRUYWJsZS5xdWFudFRhYmxlcztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW1Db21wOyBpKz0xKSB7XG4gICAgICAgICAgICBjb21wTiA9IHRoaXMuc2NhbkNvbXBzW2ldLnNjYW5Db21wU2VsO1xuICAgICAgICAgICAgdGhpcy5xVGFiW2ldID0gdGhpcy5xdWFudFRhYmxlc1t0aGlzLmNvbXBvbmVudHNbY29tcE5dLnF1YW50VGFibGVTZWxdO1xuICAgICAgICAgICAgdGhpcy5uQmxvY2tbaV0gPSB0aGlzLmNvbXBvbmVudHNbY29tcE5dLnZTYW1wICogdGhpcy5jb21wb25lbnRzW2NvbXBOXS5oU2FtcDtcbiAgICAgICAgICAgIHRoaXMuZGNUYWJbaV0gPSB0aGlzLkh1ZmZUYWJbdGhpcy5zY2FuQ29tcHNbaV0uZGNUYWJTZWxdWzBdO1xuICAgICAgICAgICAgdGhpcy5hY1RhYltpXSA9IHRoaXMuSHVmZlRhYlt0aGlzLnNjYW5Db21wc1tpXS5hY1RhYlNlbF1bMV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnhEaW0gPSB0aGlzLmZyYW1lLmRpbVg7XG4gICAgICAgIHRoaXMueURpbSA9IHRoaXMuZnJhbWUuZGltWTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcih0aGlzLnhEaW0gKiB0aGlzLnlEaW0gKiB0aGlzLm51bUJ5dGVzICogdGhpcy5udW1Db21wKSk7XG5cbiAgICAgICAgc2Nhbk51bSs9MTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkgeyAvLyBEZWNvZGUgb25lIHNjYW5cbiAgICAgICAgICAgIHRlbXBbMF0gPSAwO1xuICAgICAgICAgICAgaW5kZXhbMF0gPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBwcmVkW2ldID0gKDEgPDwgKHRoaXMucHJlY2lzaW9uIC0gMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0YXJ0SW50ZXJ2YWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5kZWNvZGVVbml0KHByZWQsIHRlbXAsIGluZGV4KTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudCA9PT0gMCkgJiYgKCh0aGlzLnhMb2MgPCB0aGlzLnhEaW0pICYmICh0aGlzLnlMb2MgPCB0aGlzLnlEaW0pKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dChwcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuZGVjb2RlVW5pdChwcmVkLCB0ZW1wLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vY3VycmVudD1NQVJLRVJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChtY3VOdW0gPSAwOyBtY3VOdW0gPCB0aGlzLnJlc3RhcnRJbnRlcnZhbDsgbWN1TnVtKz0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0aW5nID0gKG1jdU51bSA9PSAwKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5kZWNvZGVVbml0KHByZWQsIHRlbXAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dChwcmVkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gKDB4RkYwMCB8IHRoaXMubWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISgoY3VycmVudCA+PSBqcGVnLmxvc3NsZXNzLkRlY29kZXIuUkVTVEFSVF9NQVJLRVJfQkVHSU4pICYmXG4gICAgICAgICAgICAgICAgKGN1cnJlbnQgPD0ganBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0VORCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vY3VycmVudD1NQVJLRVJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoY3VycmVudCA9PT0gMHhGRkRDKSAmJiAoc2Nhbk51bSA9PT0gMSkpIHsgLy9ETkxcbiAgICAgICAgICAgIHRoaXMucmVhZE51bWJlcigpO1xuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgoY3VycmVudCAhPT0gMHhGRkQ5KSAmJiAoKHRoaXMueExvYyA8IHRoaXMueERpbSkgJiYgKHRoaXMueUxvYyA8IHRoaXMueURpbSkpICYmIChzY2FuTnVtID09PSAwKSk7XG5cbiAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlVW5pdCA9IGZ1bmN0aW9uIChwcmV2LCB0ZW1wLCBpbmRleCkge1xuICAgIGlmICh0aGlzLm51bUNvbXAgPT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVTaW5nbGUocHJldiwgdGVtcCwgaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5udW1Db21wID09IDMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlUkdCKHByZXYsIHRlbXAsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0MSA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0MiA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0MyA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNYWShjb21wT2Zmc2V0KTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDQgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiAodGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSkgLSB0aGlzLmdldFByZXZpb3VzWFkoY29tcE9mZnNldCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZWxlY3Q1ID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyAoKHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpIC0gdGhpcy5nZXRQcmV2aW91c1hZKGNvbXBPZmZzZXQpKSA+PiAxKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDYgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSArICgodGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgLSB0aGlzLmdldFByZXZpb3VzWFkoY29tcE9mZnNldCkpID4+IDEpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0NyA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuICgodGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSkgLyAyKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmRlY29kZVJHQiA9IGZ1bmN0aW9uIChwcmV2LCB0ZW1wLCBpbmRleCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciB2YWx1ZSwgYWN0YWIsIGRjdGFiLCBxdGFiLCBjdHJDLCBpLCBrLCBqO1xuXG4gICAgcHJldlswXSA9IHRoaXMuc2VsZWN0b3IoMCk7XG4gICAgcHJldlsxXSA9IHRoaXMuc2VsZWN0b3IoMSk7XG4gICAgcHJldlsyXSA9IHRoaXMuc2VsZWN0b3IoMik7XG5cbiAgICBmb3IgKGN0ckMgPSAwOyBjdHJDIDwgdGhpcy5udW1Db21wOyBjdHJDKz0xKSB7XG4gICAgICAgIHF0YWIgPSB0aGlzLnFUYWJbY3RyQ107XG4gICAgICAgIGFjdGFiID0gdGhpcy5hY1RhYltjdHJDXTtcbiAgICAgICAgZGN0YWIgPSB0aGlzLmRjVGFiW2N0ckNdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5uQmxvY2tbY3RyQ107IGkrPTEpIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCB0aGlzLklEQ1RfU291cmNlLmxlbmd0aDsgays9MSkge1xuICAgICAgICAgICAgICAgIHRoaXMuSURDVF9Tb3VyY2Vba10gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SHVmZm1hblZhbHVlKGRjdGFiLCB0ZW1wLCBpbmRleCk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAweEZGMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZbY3RyQ10gPSB0aGlzLklEQ1RfU291cmNlWzBdID0gcHJldltjdHJDXSArIHRoaXMuZ2V0bihpbmRleCwgdmFsdWUsIHRlbXAsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuSURDVF9Tb3VyY2VbMF0gKj0gcXRhYlswXTtcblxuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IDY0OyBqKz0xKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEh1ZmZtYW5WYWx1ZShhY3RhYiwgdGVtcCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4RkYwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaiArPSAodmFsdWUgPj4gNCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHgwRikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA+PiA0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLklEQ1RfU291cmNlW2pwZWcubG9zc2xlc3MuRGVjb2Rlci5JRENUX1Bbal1dID0gdGhpcy5nZXRuKGluZGV4LCB2YWx1ZSAmIDB4MEYsIHRlbXAsIGluZGV4KSAqIHF0YWJbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVTaW5nbGUgPSBmdW5jdGlvbiAocHJldiwgdGVtcCwgaW5kZXgpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgdmFsdWUsIGksIG4sIG5SZXN0YXJ0O1xuXG4gICAgaWYgKHRoaXMucmVzdGFydGluZykge1xuICAgICAgICB0aGlzLnJlc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgcHJldlswXSA9ICgxIDw8ICh0aGlzLmZyYW1lLnByZWNpc2lvbiAtIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2WzBdID0gdGhpcy5zZWxlY3RvcigpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm5CbG9ja1swXTsgaSs9MSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SHVmZm1hblZhbHVlKHRoaXMuZGNUYWJbMF0sIHRlbXAsIGluZGV4KTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4RkYwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbiA9IHRoaXMuZ2V0bihwcmV2LCB2YWx1ZSwgdGVtcCwgaW5kZXgpO1xuICAgICAgICBuUmVzdGFydCA9IChuID4+IDgpO1xuXG4gICAgICAgIGlmICgoblJlc3RhcnQgPj0ganBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0JFR0lOKSAmJiAoblJlc3RhcnQgPD0ganBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0VORCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuUmVzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZbMF0gKz0gbjtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cblxuXG4vL1x0SHVmZm1hbiB0YWJsZSBmb3IgZmFzdCBzZWFyY2g6IChIdWZmVGFiKSA4LWJpdCBMb29rIHVwIHRhYmxlIDItbGF5ZXIgc2VhcmNoIGFyY2hpdGVjdHVyZSwgMXN0LWxheWVyIHJlcHJlc2VudCAyNTYgbm9kZSAoOCBiaXRzKSBpZiBjb2Rld29yZC1sZW5ndGggPiA4XG4vL1x0Yml0cywgdGhlbiB0aGUgZW50cnkgb2YgMXN0LWxheWVyID0gKCMgb2YgMm5kLWxheWVyIHRhYmxlKSB8IE1TQiBhbmQgaXQgaXMgc3RvcmVkIGluIHRoZSAybmQtbGF5ZXIgU2l6ZSBvZiB0YWJsZXMgaW4gZWFjaCBsYXllciBhcmUgMjU2LlxuLy9cdEh1ZmZUYWJbKl1bKl1bMC0yNTZdIGlzIGFsd2F5cyB0aGUgb25seSAxc3QtbGF5ZXIgdGFibGUuXG4vL1xuLy9cdEFuIGVudHJ5IGNhbiBiZTogKDEpICgjIG9mIDJuZC1sYXllciB0YWJsZSkgfCBNU0IgLCBmb3IgY29kZSBsZW5ndGggPiA4IGluIDFzdC1sYXllciAoMikgKENvZGUgbGVuZ3RoKSA8PCA4IHwgSHVmZlZhbFxuLy9cbi8vXHRIdWZmbWFuVmFsdWUodGFibGUgICBIdWZmVGFiW3hdW3ldIChleCkgSHVmZm1hblZhbHVlKEh1ZmZUYWJbMV1bMF0sLi4uKVxuLy9cdCAgICAgICAgICAgICAgICApOlxuLy9cdCAgICByZXR1cm46IEh1ZmZtYW4gVmFsdWUgb2YgdGFibGVcbi8vXHQgICAgICAgICAgICAweEZGPz8gaWYgaXQgcmVjZWl2ZXMgYSBNQVJLRVJcbi8vXHQgICAgUGFyYW1ldGVyOiAgdGFibGUgICBIdWZmVGFiW3hdW3ldIChleCkgSHVmZm1hblZhbHVlKEh1ZmZUYWJbMV1bMF0sLi4uKVxuLy9cdCAgICAgICAgICAgICAgICB0ZW1wICAgIHRlbXAgc3RvcmFnZSBmb3IgcmVtYWluZGVkIGJpdHNcbi8vXHQgICAgICAgICAgICAgICAgaW5kZXggICBpbmRleCB0byBiaXQgb2YgdGVtcFxuLy9cdCAgICAgICAgICAgICAgICBpbiAgICAgIEZJTEUgcG9pbnRlclxuLy9cdCAgICBFZmZlY3Q6XG4vL1x0ICAgICAgICB0ZW1wICBzdG9yZSBuZXcgcmVtYWluZGVkIGJpdHNcbi8vXHQgICAgICAgIGluZGV4IGNoYW5nZSB0byBuZXcgaW5kZXhcbi8vXHQgICAgICAgIGluICAgIGNoYW5nZSB0byBuZXcgcG9zaXRpb25cbi8vXHQgICAgTk9URTpcbi8vXHQgICAgICBJbml0aWFsIGJ5ICAgdGVtcD0wOyBpbmRleD0wO1xuLy9cdCAgICBOT1RFOiAoZXhwbGFpbiB0ZW1wIGFuZCBpbmRleClcbi8vXHQgICAgICB0ZW1wOiBpcyBhbHdheXMgaW4gdGhlIGZvcm0gYXQgY2FsbGluZyB0aW1lIG9yIHJldHVybmluZyB0aW1lXG4vL1x0ICAgICAgIHwgIGJ5dGUgNCAgfCAgYnl0ZSAzICB8ICBieXRlIDIgIHwgIGJ5dGUgMSAgfFxuLy9cdCAgICAgICB8ICAgICAwICAgIHwgICAgIDAgICAgfCAwMDAwMDAwMCB8IDAwMDAwPz8/IHwgIGlmIG5vdCBhIE1BUktFUlxuLy9cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXmluZGV4PTMgKGZyb20gMCB0byAxNSlcbi8vXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMyMVxuLy9cdCAgICBOT1RFIChtYXJrZXIgYW5kIG1hcmtlcl9pbmRleCk6XG4vL1x0ICAgICAgSWYgZ2V0IGEgTUFSS0VSIGZyb20gJ2luJywgbWFya2VyPXRoZSBsb3ctYnl0ZSBvZiB0aGUgTUFSS0VSXG4vL1x0ICAgICAgICBhbmQgbWFya2VyX2luZGV4PTlcbi8vXHQgICAgICBJZiBtYXJrZXJfaW5kZXg9OSB0aGVuIGluZGV4IGlzIGFsd2F5cyA+IDgsIG9yIEh1ZmZtYW5WYWx1ZSgpXG4vL1x0ICAgICAgICB3aWxsIG5vdCBiZSBjYWxsZWRcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0SHVmZm1hblZhbHVlID0gZnVuY3Rpb24gKHRhYmxlLCB0ZW1wLCBpbmRleCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjb2RlLCBpbnB1dCwgbWFzaztcbiAgICBtYXNrID0gMHhGRkZGO1xuXG4gICAgaWYgKGluZGV4WzBdIDwgOCkge1xuICAgICAgICB0ZW1wWzBdIDw8PSA4O1xuICAgICAgICBpbnB1dCA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgaWYgKGlucHV0ID09PSAweEZGKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlciAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSA5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhbMF0gLT0gODtcbiAgICB9XG5cbiAgICBjb2RlID0gdGFibGVbdGVtcFswXSA+PiBpbmRleFswXV07XG5cbiAgICBpZiAoKGNvZGUgJiBqcGVnLmxvc3NsZXNzLkRlY29kZXIuTVNCKSAhPT0gMCkge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXJJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gMHhGRjAwIHwgdGhpcy5tYXJrZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wWzBdICY9IChtYXNrID4+ICgxNiAtIGluZGV4WzBdKSk7XG4gICAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICAgIGlucHV0ID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gMHhGRikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgICAgIGNvZGUgPSB0YWJsZVsoKGNvZGUgJiAweEZGKSAqIDI1NikgKyAodGVtcFswXSA+PiBpbmRleFswXSldO1xuICAgICAgICBpbmRleFswXSArPSA4O1xuICAgIH1cblxuICAgIGluZGV4WzBdICs9IDggLSAoY29kZSA+PiA4KTtcblxuICAgIGlmIChpbmRleFswXSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXg9XCIgKyBpbmRleFswXSArIFwiIHRlbXA9XCIgKyB0ZW1wWzBdICsgXCIgY29kZT1cIiArIGNvZGUgKyBcIiBpbiBIdWZmbWFuVmFsdWUoKVwiKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXhbMF0gPCB0aGlzLm1hcmtlckluZGV4KSB7XG4gICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gMHhGRjAwIHwgdGhpcy5tYXJrZXI7XG4gICAgfVxuXG4gICAgdGVtcFswXSAmPSAobWFzayA+PiAoMTYgLSBpbmRleFswXSkpO1xuICAgIHJldHVybiBjb2RlICYgMHhGRjtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldG4gPSBmdW5jdGlvbiAoUFJFRCwgbiwgdGVtcCwgaW5kZXgpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgcmVzdWx0LCBvbmUsIG5fb25lLCBtYXNrLCBpbnB1dDtcbiAgICBvbmUgPSAxO1xuICAgIG5fb25lID0gLTE7XG4gICAgbWFzayA9IDB4RkZGRjtcblxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChuID09PSAxNikge1xuICAgICAgICBpZiAoUFJFRFswXSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTMyNzY4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDMyNzY4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXhbMF0gLT0gbjtcblxuICAgIGlmIChpbmRleFswXSA+PSAwKSB7XG4gICAgICAgIGlmICgoaW5kZXhbMF0gPCB0aGlzLm1hcmtlckluZGV4KSAmJiAhdGhpcy5pc0xhc3RQaXhlbCgpKSB7IC8vIHRoaXMgd2FzIGNvcnJ1cHRpbmcgdGhlIGxhc3QgcGl4ZWwgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gKDB4RkYwMCB8IHRoaXMubWFya2VyKSA8PCA4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGVtcFswXSA+PiBpbmRleFswXTtcbiAgICAgICAgdGVtcFswXSAmPSAobWFzayA+PiAoMTYgLSBpbmRleFswXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICAgIGlucHV0ID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gMHhGRikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgICAgIGluZGV4WzBdICs9IDg7XG5cbiAgICAgICAgaWYgKGluZGV4WzBdIDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VySW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDB4RkYwMCB8IHRoaXMubWFya2VyKSA8PCA4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZW1wWzBdIDw8PSA4O1xuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG5cbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gMHhGRikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlciAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgICAgICAgICBpbmRleFswXSArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4WzBdIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXg9XCIgKyBpbmRleFswXSArIFwiIGluIGdldG4oKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleFswXSA8IHRoaXMubWFya2VySW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICAgICAgcmV0dXJuICgweEZGMDAgfCB0aGlzLm1hcmtlcikgPDwgODtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRlbXBbMF0gPj4gaW5kZXhbMF07XG4gICAgICAgIHRlbXBbMF0gJj0gKG1hc2sgPj4gKDE2IC0gaW5kZXhbMF0pKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0IDwgKG9uZSA8PCAobiAtIDEpKSkge1xuICAgICAgICByZXN1bHQgKz0gKG5fb25lIDw8IG4pICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0UHJldmlvdXNYID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICBpZiAodGhpcy54TG9jID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoKCgodGhpcy55TG9jICogdGhpcy54RGltKSArIHRoaXMueExvYykgLSAxKSwgY29tcE9mZnNldCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnlMb2MgPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKDEgPDwgKHRoaXMuZnJhbWUucHJlY2lzaW9uIC0gMSkpO1xuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldFByZXZpb3VzWFkgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIGlmICgodGhpcy54TG9jID4gMCkgJiYgKHRoaXMueUxvYyA+IDApKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldHRlcigoKCgodGhpcy55TG9jIC0gMSkgKiB0aGlzLnhEaW0pICsgdGhpcy54TG9jKSAtIDEpLCBjb21wT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCk7XG4gICAgfVxufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0UHJldmlvdXNZID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICBpZiAodGhpcy55TG9jID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoKCgodGhpcy55TG9jIC0gMSkgKiB0aGlzLnhEaW0pICsgdGhpcy54TG9jKSwgY29tcE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpO1xuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmlzTGFzdFBpeGVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy54TG9jID09PSAodGhpcy54RGltIC0gMSkpICYmICh0aGlzLnlMb2MgPT09ICh0aGlzLnlEaW0gLSAxKSk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5vdXRwdXRTaW5nbGUgPSBmdW5jdGlvbiAoUFJFRCkge1xuICAgIGlmICgodGhpcy54TG9jIDwgdGhpcy54RGltKSAmJiAodGhpcy55TG9jIDwgdGhpcy55RGltKSkge1xuICAgICAgICB0aGlzLnNldHRlcigoKCh0aGlzLnlMb2MgKiB0aGlzLnhEaW0pICsgdGhpcy54TG9jKSksIHRoaXMubWFzayAmIFBSRURbMF0pO1xuXG4gICAgICAgIHRoaXMueExvYys9MTtcblxuICAgICAgICBpZiAodGhpcy54TG9jID49IHRoaXMueERpbSkge1xuICAgICAgICAgICAgdGhpcy55TG9jKz0xO1xuICAgICAgICAgICAgdGhpcy54TG9jID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLm91dHB1dFJHQiA9IGZ1bmN0aW9uIChQUkVEKSB7XG4gICAgdmFyIG9mZnNldCA9ICgodGhpcy55TG9jICogdGhpcy54RGltKSArIHRoaXMueExvYyk7XG5cbiAgICBpZiAoKHRoaXMueExvYyA8IHRoaXMueERpbSkgJiYgKHRoaXMueUxvYyA8IHRoaXMueURpbSkpIHtcbiAgICAgICAgdGhpcy5zZXR0ZXIob2Zmc2V0LCBQUkVEWzBdLCAwKTtcbiAgICAgICAgdGhpcy5zZXR0ZXIob2Zmc2V0LCBQUkVEWzFdLCAxKTtcbiAgICAgICAgdGhpcy5zZXR0ZXIob2Zmc2V0LCBQUkVEWzJdLCAyKTtcblxuICAgICAgICB0aGlzLnhMb2MrPTE7XG5cbiAgICAgICAgaWYgKHRoaXMueExvYyA+PSB0aGlzLnhEaW0pIHtcbiAgICAgICAgICAgIHRoaXMueUxvYys9MTtcbiAgICAgICAgICAgIHRoaXMueExvYyA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZXRWYWx1ZTE2ID0gZnVuY3Rpb24gKGluZGV4LCB2YWwpIHtcbiAgICB0aGlzLm91dHB1dERhdGEuc2V0SW50MTYoaW5kZXggKiAyLCB2YWwsIHRydWUpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0VmFsdWUxNiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dERhdGEuZ2V0SW50MTYoaW5kZXggKiAyLCB0cnVlKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNldFZhbHVlOCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XG4gICAgdGhpcy5vdXRwdXREYXRhLnNldEludDgoaW5kZXgsIHZhbCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRWYWx1ZTggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhLmdldEludDgoaW5kZXgpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2V0VmFsdWVSR0IgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbCwgY29tcE9mZnNldCkge1xuICAgIHRoaXMub3V0cHV0RGF0YS5zZXRVaW50OChpbmRleCAqIDMgKyBjb21wT2Zmc2V0LCB2YWwpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0VmFsdWVSR0IgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhLmdldFVpbnQ4KGluZGV4ICogMyArIGNvbXBPZmZzZXQpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUucmVhZEFwcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3VudCA9IDAsIGxlbmd0aCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHdoaWxlIChjb3VudCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuICAgIH1cblxuICAgIHJldHVybiBsZW5ndGg7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5yZWFkQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2IgPSBcIlwiLCBjb3VudCA9IDAsIGxlbmd0aDtcblxuICAgIGxlbmd0aCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHdoaWxlIChjb3VudCA8IGxlbmd0aCkge1xuICAgICAgICBzYiArPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuICAgIH1cblxuICAgIHJldHVybiBzYjtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnJlYWROdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgTGQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuXG4gICAgaWYgKExkICE9PSA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBEZWZpbmUgbnVtYmVyIGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24gW0xkIT00XVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbn07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5EZWNvZGVyO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5qcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMgPSBqcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9jb21wb25lbnQtc3BlYy5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbS5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyID0ganBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb21wb25lbnRzID0gW107IC8vIENvbXBvbmVudHNcbiAgICB0aGlzLmRpbVggPSAwOyAvLyBOdW1iZXIgb2Ygc2FtcGxlcyBwZXIgbGluZVxuICAgIHRoaXMuZGltWSA9IDA7IC8vIE51bWJlciBvZiBsaW5lc1xuICAgIHRoaXMubnVtQ29tcCA9IDA7IC8vIE51bWJlciBvZiBjb21wb25lbnQgaW4gdGhlIGZyYW1lXG4gICAgdGhpcy5wcmVjaXNpb24gPSAwOyAvLyBTYW1wbGUgUHJlY2lzaW9uIChmcm9tIHRoZSBvcmlnaW5hbCBpbWFnZSlcbn07XG5cblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGNvdW50ID0gMCwgbGVuZ3RoLCBpLCBjLCB0ZW1wO1xuXG4gICAgbGVuZ3RoID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB0aGlzLnByZWNpc2lvbiA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuXG4gICAgdGhpcy5kaW1ZID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB0aGlzLmRpbVggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHRoaXMubnVtQ29tcCA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuICAgIGZvciAoaSA9IDE7IGkgPD0gdGhpcy5udW1Db21wOyBpKz0xKSB7XG4gICAgICAgIGlmIChjb3VudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZyYW1lIGZvcm1hdCBlcnJvclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG5cbiAgICAgICAgaWYgKGNvdW50ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZyYW1lIGZvcm1hdCBlcnJvciBbYz49TGZdXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcblxuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50c1tjXSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW2NdID0gbmV3IGpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2NdLmhTYW1wID0gdGVtcCA+PiA0O1xuICAgICAgICB0aGlzLmNvbXBvbmVudHNbY10udlNhbXAgPSB0ZW1wICYgMHgwRjtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2NdLnF1YW50VGFibGVTZWwgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZyYW1lIGZvcm1hdCBlcnJvciBbTGYhPWNvdW50XVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXI7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuVXRpbHMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbHMuanMnKSA6IG51bGwpO1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgPSBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSg0LCAyLCAxNik7XG4gICAgdGhpcy50aCA9IFtdO1xuICAgIHRoaXMudiA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgMiwgMTYsIDIwMCk7XG4gICAgdGhpcy50YyA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgMik7XG5cbiAgICB0aGlzLnRjWzBdWzBdID0gMDtcbiAgICB0aGlzLnRjWzFdWzBdID0gMDtcbiAgICB0aGlzLnRjWzJdWzBdID0gMDtcbiAgICB0aGlzLnRjWzNdWzBdID0gMDtcbiAgICB0aGlzLnRjWzBdWzFdID0gMDtcbiAgICB0aGlzLnRjWzFdWzFdID0gMDtcbiAgICB0aGlzLnRjWzJdWzFdID0gMDtcbiAgICB0aGlzLnRjWzNdWzFdID0gMDtcbiAgICB0aGlzLnRoWzBdID0gMDtcbiAgICB0aGlzLnRoWzFdID0gMDtcbiAgICB0aGlzLnRoWzJdID0gMDtcbiAgICB0aGlzLnRoWzNdID0gMDtcbn07XG5cblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUuTVNCID0gMHg4MDAwMDAwMDtcblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihkYXRhLCBIdWZmVGFiKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGNvdW50ID0gMCwgbGVuZ3RoLCB0ZW1wLCB0LCBjLCBpLCBqO1xuXG4gICAgbGVuZ3RoID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgdCA9IHRlbXAgJiAweDBGO1xuICAgICAgICBpZiAodCA+IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIElEID4gM1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMgPSB0ZW1wID4+IDQ7XG4gICAgICAgIGlmIChjID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IEh1ZmZtYW4gdGFibGUgW1RhYmxlIGNsYXNzID4gMiBdXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aFt0XSA9IDE7XG4gICAgICAgIHRoaXMudGNbdF1bY10gPSAxO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSs9MSkge1xuICAgICAgICAgICAgdGhpcy5sW3RdW2NdW2ldID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSs9MSkge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMubFt0XVtjXVtpXTsgais9MSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogSHVmZm1hbiB0YWJsZSBmb3JtYXQgZXJyb3IgW2NvdW50PkxoXVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnZbdF1bY11baV1bal0gPSBkYXRhLmdldDgoKTtcbiAgICAgICAgICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3VudCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIGZvcm1hdCBlcnJvciBbY291bnQhPUxmXVwiKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSs9MSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMjsgais9MSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGNbaV1bal0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkSHVmZlRhYmxlKEh1ZmZUYWJbaV1bal0sIHRoaXMubFtpXVtqXSwgdGhpcy52W2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuXG5cbi8vXHRCdWlsZF9IdWZmVGFiKClcbi8vXHRQYXJhbWV0ZXI6ICB0ICAgICAgIHRhYmxlIElEXG4vL1x0ICAgICAgICAgICAgYyAgICAgICB0YWJsZSBjbGFzcyAoIDAgZm9yIERDLCAxIGZvciBBQyApXG4vL1x0ICAgICAgICAgICAgTFtpXSAgICAjIG9mIGNvZGV3b3JkcyB3aGljaCBsZW5ndGggaXMgaVxuLy9cdCAgICAgICAgICAgIFZbaV1bal0gSHVmZm1hbiBWYWx1ZSAobGVuZ3RoPWkpXG4vL1x0RWZmZWN0OlxuLy9cdCAgICBidWlsZCB1cCBIdWZmVGFiW3RdW2NdIHVzaW5nIEwgYW5kIFYuXG5qcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZS5wcm90b3R5cGUuYnVpbGRIdWZmVGFibGUgPSBmdW5jdGlvbih0YWIsIEwsIFYpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY3VycmVudFRhYmxlLCB0ZW1wLCBrLCBpLCBqLCBuO1xuICAgIHRlbXAgPSAyNTY7XG4gICAgayA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSs9MSkgeyAvLyBpKzEgaXMgQ29kZSBsZW5ndGhcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IExbaV07IGorPTEpIHtcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAodGVtcCA+PiAoaSArIDEpKTsgbis9MSkge1xuICAgICAgICAgICAgICAgIHRhYltrXSA9IFZbaV1bal0gfCAoKGkgKyAxKSA8PCA4KTtcbiAgICAgICAgICAgICAgICBrKz0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMTsgayA8IDI1NjsgaSs9MSwgays9MSkge1xuICAgICAgICB0YWJba10gPSBpIHwganBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUuTVNCO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYWJsZSA9IDE7XG4gICAgayA9IDA7XG5cbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrPTEpIHsgLy8gaSsxIGlzIENvZGUgbGVuZ3RoXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBMW2ldOyBqKz0xKSB7XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgKHRlbXAgPj4gKGkgLSA3KSk7IG4rPTEpIHtcbiAgICAgICAgICAgICAgICB0YWJbKGN1cnJlbnRUYWJsZSAqIDI1NikgKyBrXSA9IFZbaV1bal0gfCAoKGkgKyAxKSA8PCA4KTtcbiAgICAgICAgICAgICAgICBrKz0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoayA+PSAyNTYpIHtcbiAgICAgICAgICAgICAgICBpZiAoayA+IDI1Nikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogSHVmZm1hbiB0YWJsZSBlcnJvcigxKSFcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhYmxlKz0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGU7XG59XG4iLCIvKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYyA9IGpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2NvbXBvbmVudC1zcGVjLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuRGVjb2RlciA9IGpwZWcubG9zc2xlc3MuRGVjb2RlciB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RlY29kZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciA9IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9mcmFtZS1oZWFkZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgPSBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2h1ZmZtYW4tdGFibGUuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSA9IGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9xdWFudGl6YXRpb24tdGFibGUuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50ID0ganBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50IHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vc2Nhbi1jb21wb25lbnQuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyID0ganBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vc2Nhbi1oZWFkZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5VdGlscyA9IGpwZWcubG9zc2xlc3MuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlscy5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlV0aWxzID0ganBlZy5sb3NzbGVzcy5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxzLmpzJykgOiBudWxsKTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgPSBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZWNpc2lvbiA9IFtdOyAvLyBRdWFudGl6YXRpb24gcHJlY2lzaW9uIDggb3IgMTZcbiAgICB0aGlzLnRxID0gW107IC8vIDE6IHRoaXMgdGFibGUgaXMgcHJlc2VudGVkXG4gICAgdGhpcy5xdWFudFRhYmxlcyA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgNjQpOyAvLyBUYWJsZXNcblxuICAgIHRoaXMudHFbMF0gPSAwO1xuICAgIHRoaXMudHFbMV0gPSAwO1xuICAgIHRoaXMudHFbMl0gPSAwO1xuICAgIHRoaXMudHFbM10gPSAwO1xufTtcblxuXG5cbi8qKiogU3RhdGljIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlLmVuaGFuY2VRdWFudGl6YXRpb25UYWJsZSA9IGZ1bmN0aW9uKHF0YWIsIHRhYmxlKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSs9MSkge1xuICAgICAgICBxdGFiW3RhYmxlWygwICogOCkgKyBpXV0gKj0gOTA7XG4gICAgICAgIHF0YWJbdGFibGVbKDQgKiA4KSArIGldXSAqPSA5MDtcbiAgICAgICAgcXRhYlt0YWJsZVsoMiAqIDgpICsgaV1dICo9IDExODtcbiAgICAgICAgcXRhYlt0YWJsZVsoNiAqIDgpICsgaV1dICo9IDQ5O1xuICAgICAgICBxdGFiW3RhYmxlWyg1ICogOCkgKyBpXV0gKj0gNzE7XG4gICAgICAgIHF0YWJbdGFibGVbKDEgKiA4KSArIGldXSAqPSAxMjY7XG4gICAgICAgIHF0YWJbdGFibGVbKDcgKiA4KSArIGldXSAqPSAyNTtcbiAgICAgICAgcXRhYlt0YWJsZVsoMyAqIDgpICsgaV1dICo9IDEwNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSs9MSkge1xuICAgICAgICBxdGFiW3RhYmxlWzAgKyAoOCAqIGkpXV0gKj0gOTA7XG4gICAgICAgIHF0YWJbdGFibGVbNCArICg4ICogaSldXSAqPSA5MDtcbiAgICAgICAgcXRhYlt0YWJsZVsyICsgKDggKiBpKV1dICo9IDExODtcbiAgICAgICAgcXRhYlt0YWJsZVs2ICsgKDggKiBpKV1dICo9IDQ5O1xuICAgICAgICBxdGFiW3RhYmxlWzUgKyAoOCAqIGkpXV0gKj0gNzE7XG4gICAgICAgIHF0YWJbdGFibGVbMSArICg4ICogaSldXSAqPSAxMjY7XG4gICAgICAgIHF0YWJbdGFibGVbNyArICg4ICogaSldXSAqPSAyNTtcbiAgICAgICAgcXRhYlt0YWJsZVszICsgKDggKiBpKV1dICo9IDEwNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrPTEpIHtcbiAgICAgICAgcXRhYltpXSA+Pj0gNjtcbiAgICB9XG59O1xuXG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGRhdGEsIHRhYmxlKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGNvdW50ID0gMCwgbGVuZ3RoLCB0ZW1wLCB0LCBpO1xuXG4gICAgbGVuZ3RoID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgdCA9IHRlbXAgJiAweDBGO1xuXG4gICAgICAgIGlmICh0ID4gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBJRCA+IDNcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZWNpc2lvblt0XSA9IHRlbXAgPj4gNDtcblxuICAgICAgICBpZiAodGhpcy5wcmVjaXNpb25bdF0gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlY2lzaW9uW3RdID0gODtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvblt0XSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5wcmVjaXNpb25bdF0gPSAxNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBRdWFudGl6YXRpb24gdGFibGUgcHJlY2lzaW9uIGVycm9yXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cVt0XSA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMucHJlY2lzaW9uW3RdID09PSA4KSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBmb3JtYXQgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5xdWFudFRhYmxlc1t0XVtpXSA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICAgICAgICAgIGNvdW50Kz0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlLmVuaGFuY2VRdWFudGl6YXRpb25UYWJsZSh0aGlzLnF1YW50VGFibGVzW3RdLCB0YWJsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBmb3JtYXQgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5xdWFudFRhYmxlc1t0XVtpXSA9IGRhdGEuZ2V0MTYoKTtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlLmVuaGFuY2VRdWFudGl6YXRpb25UYWJsZSh0aGlzLnF1YW50VGFibGVzW3RdLCB0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY291bnQgIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogUXVhbnRpemF0aW9uIHRhYmxlIGVycm9yIFtjb3VudCE9THFdXCIpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQgPSBqcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWNUYWJTZWwgPSAwOyAvLyBBQyB0YWJsZSBzZWxlY3RvclxuICAgIHRoaXMuZGNUYWJTZWwgPSAwOyAvLyBEQyB0YWJsZSBzZWxlY3RvclxuICAgIHRoaXMuc2NhbkNvbXBTZWwgPSAwOyAvLyBTY2FuIGNvbXBvbmVudCBzZWxlY3RvclxufTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQ7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCA9IGpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3NjYW4tY29tcG9uZW50LmpzJykgOiBudWxsKTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuU2NhbkhlYWRlciA9IGpwZWcubG9zc2xlc3MuU2NhbkhlYWRlciB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5haCA9IDA7XG4gICAgdGhpcy5hbCA9IDA7XG4gICAgdGhpcy5udW1Db21wID0gMDsgLy8gTnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIHNjYW5cbiAgICB0aGlzLnNlbGVjdGlvbiA9IDA7IC8vIFN0YXJ0IG9mIHNwZWN0cmFsIG9yIHByZWRpY3RvciBzZWxlY3Rpb25cbiAgICB0aGlzLnNwZWN0cmFsRW5kID0gMDsgLy8gRW5kIG9mIHNwZWN0cmFsIHNlbGVjdGlvblxuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xufTtcblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjb3VudCA9IDAsIGxlbmd0aCwgaSwgdGVtcDtcblxuICAgIGxlbmd0aCA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgdGhpcy5udW1Db21wID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQrPTE7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW1Db21wOyBpKz0xKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tpXSA9IG5ldyBqcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQoKTtcblxuICAgICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBzY2FuIGhlYWRlciBmb3JtYXQgZXJyb3JcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbaV0uc2NhbkNvbXBTZWwgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG5cbiAgICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcblxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbaV0uZGNUYWJTZWwgPSAodGVtcCA+PiA0KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2ldLmFjVGFiU2VsID0gKHRlbXAgJiAweDBGKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbGVjdGlvbiA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuXG4gICAgdGhpcy5zcGVjdHJhbEVuZCA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuXG4gICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgIHRoaXMuYWggPSAodGVtcCA+PiA0KTtcbiAgICB0aGlzLmFsID0gKHRlbXAgJiAweDBGKTtcbiAgICBjb3VudCs9MTtcblxuICAgIGlmIChjb3VudCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBzY2FuIGhlYWRlciBmb3JtYXQgZXJyb3IgW2NvdW50IT1Oc11cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuU2NhbkhlYWRlcjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5VdGlscyA9IGpwZWcubG9zc2xlc3MuVXRpbHMgfHwge307XG5cblxuLyoqKiBTdGF0aWMgbWV0aG9kcyAqKiovXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTY2MjI1L2hvdy1jYW4taS1jcmVhdGUtYS10d28tZGltZW5zaW9uYWwtYXJyYXktaW4tamF2YXNjcmlwdFxuanBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbmd0aCB8fCAwKSxcbiAgICAgICAgaSA9IGxlbmd0aDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHdoaWxlKGktLSkgYXJyW2xlbmd0aC0xIC0gaV0gPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG59O1xuXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg2Mzg5MDAvamF2YXNjcmlwdC1jcmMzMlxuanBlZy5sb3NzbGVzcy5VdGlscy5tYWtlQ1JDVGFibGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjO1xuICAgIHZhciBjcmNUYWJsZSA9IFtdO1xuICAgIGZvcih2YXIgbiA9MDsgbiA8IDI1NjsgbisrKXtcbiAgICAgICAgYyA9IG47XG4gICAgICAgIGZvcih2YXIgayA9MDsgayA8IDg7IGsrKyl7XG4gICAgICAgICAgICBjID0gKChjJjEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjcmNUYWJsZVtuXSA9IGM7XG4gICAgfVxuICAgIHJldHVybiBjcmNUYWJsZTtcbn07XG5cbmpwZWcubG9zc2xlc3MuVXRpbHMuY3JjMzIgPSBmdW5jdGlvbihkYXRhVmlldykge1xuICAgIHZhciBjcmNUYWJsZSA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JjVGFibGUgfHwgKGpwZWcubG9zc2xlc3MuVXRpbHMuY3JjVGFibGUgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLm1ha2VDUkNUYWJsZSgpKTtcbiAgICB2YXIgY3JjID0gMCBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFWaWV3LmJ5dGVMZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiBjcmNUYWJsZVsoY3JjIF4gZGF0YVZpZXcuZ2V0VWludDgoaSkpICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKSA+Pj4gMDtcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuVXRpbHM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBGVU5DVElPTjogYWJzKCB4IClcbipcdENvbXB1dGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IC0gaW5wdXQgdmFsdWVcbiogQHJldHVybnMge051bWJlcn0gYWJzb2x1dGUgdmFsdWVcbiovXG5mdW5jdGlvbiBhYnMoIHggKSB7XG5cdGlmICggeCA8IDAgKSB7XG5cdFx0cmV0dXJuIC14O1xuXHR9XG5cdGlmICggeCA9PT0gMCApIHtcblx0XHRyZXR1cm4gMDsgLy8gaGFuZGxlIG5lZ2F0aXZlIHplcm9cblx0fVxuXHRyZXR1cm4geDtcbn0gLy8gZW5kIEZVTkNUSU9OIGFicygpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFicztcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguY2VpbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZmxvb3IgPSByZXF1aXJlKCAnbWF0aC1mbG9vcicgKTtcblxuXG4vLyBESVYyIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogZGl2MiggeCApXG4qXHRDb252ZXJ0cyBhIG5vbm5lZ2F0aXZlIGludGVnZXIgdG8gYSBsaXRlcmFsIGJpdCByZXByZXNlbnRhdGlvbiB1c2luZyB0aGUgZGl2aWRlLWJ5LTIgYWxnb3JpdGhtLlxuKlxuKiBAcGFyYW0ge051bWJlcn0geCAtIG5vbm5lZ2F0aXZlIGludGVnZXJcbiogQHJldHVybnMge1N0cmluZ30gYml0IHJlcHJlc2VudGF0aW9uXG4qL1xuZnVuY3Rpb24gZGl2MiggeCApIHtcblx0dmFyIHN0ciA9ICcnO1xuXHR2YXIgeTtcblxuXHQvLyBXZSByZXBlYXRlZGx5IGRpdmlkZSBieSAyIGFuZCBjaGVjayBmb3IgYSByZW1haW5kZXIuIElmIGEgcmVtYWluZGVyIGV4aXN0cywgdGhlIG51bWJlciBpcyBvZGQgYW5kIHdlIGFkZCBhICcxJyBiaXQuLi5cblx0d2hpbGUgKCB4ID4gMCApIHtcblx0XHR5ID0geCAvIDI7XG5cdFx0eCA9IGZsb29yKCB5ICk7XG5cdFx0aWYgKCB5ID09PSB4ICkge1xuXHRcdFx0c3RyID0gJzAnICsgc3RyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHIgPSAnMScgKyBzdHI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdHI7XG59IC8vIGVuZCBGVU5DVElPTiBkaXYyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZGl2MjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgcGluZiA9IHJlcXVpcmUoICdjb25zdC1waW5mLWZsb2F0MzInICk7XG52YXIgbmluZiA9IHJlcXVpcmUoICdjb25zdC1uaW5mLWZsb2F0MzInICk7XG52YXIgYWJzID0gcmVxdWlyZSggJ21hdGgtYWJzJyApO1xudmFyIGZsb29yID0gcmVxdWlyZSggJ21hdGgtZmxvb3InICk7XG52YXIgcnBhZCA9IHJlcXVpcmUoICd1dGlscy1yaWdodC1wYWQtc3RyaW5nJyApO1xudmFyIGxwYWQgPSByZXF1aXJlKCAndXRpbHMtbGVmdC1wYWQtc3RyaW5nJyApO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoICd1dGlscy1yZXBlYXQtc3RyaW5nJyApO1xudmFyIGRpdjIgPSByZXF1aXJlKCAnLi9kaXYyLmpzJyApO1xudmFyIG11bHQyID0gcmVxdWlyZSggJy4vbXVsdDIuanMnICk7XG5cblxuLy8gQ09OU1RBTlRTIC8vXG5cbnZhciBCSUFTID0gMTI3OyAvLyBleHBvbmVudCBiaWFzID0+ICgyKio4KS8yIC0gMVxuXG5cbi8vIEJJTkFSWSBTVFJJTkcgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBiaW5hcnlTdHJpbmcoIHggKVxuKlx0UmV0dXJucyBhIHN0cmluZyBnaXZpbmcgdGhlIGxpdGVyYWwgYml0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IC0gaW5wdXQgdmFsdWVcbiogQHJldHVybnMge1N0cmluZ30gYml0IHJlcHJlc2VudGF0aW9uXG4qL1xuZnVuY3Rpb24gYmluYXJ5U3RyaW5nKCB4ICkge1xuXHR2YXIgbmJpdHM7XG5cdHZhciBzaWduO1xuXHR2YXIgc3RyO1xuXHR2YXIgZXhwO1xuXHR2YXIgbjtcblx0dmFyIGY7XG5cdHZhciBpO1xuXG5cdC8vIENoZWNrIGZvciBhIG5lZ2F0aXZlIHZhbHVlIG9yIG5lZ2F0aXZlIHplcm8uLi5cblx0aWYgKCB4IDwgMCB8fCAxL3ggPT09IG5pbmYgKSB7XG5cdFx0c2lnbiA9ICcxJztcblx0fSBlbHNlIHtcblx0XHRzaWduID0gJzAnO1xuXHR9XG5cdC8vIFNwZWNpYWwgY2FzZTogKy1pbmZpbml0eVxuXHRpZiAoIHggPT09IHBpbmYgfHwgeCA9PT0gbmluZiApIHtcblx0XHQvLyBCYXNlZCBvbiBJRUVFIDc1NC0yMDA4Li4uXG5cdFx0ZXhwID0gcmVwZWF0KCAnMScsIDggKTsgLy8gYWxsIDFzXG5cdFx0c3RyID0gcmVwZWF0KCAnMCcsIDIzICk7IC8vIGFsbCAwc1xuXHRcdHJldHVybiBzaWduICsgZXhwICsgc3RyO1xuXHR9XG5cdC8vIFNwZWNpYWwgY2FzZTogTmFOXG5cdGlmICggeCAhPT0geCApIHtcblx0XHQvLyBCYXNlZCBvbiBJRUVFIDc1NC0yMDA4Li4uXG5cdFx0ZXhwID0gcmVwZWF0KCAnMScsIDggKTsgLy8gYWxsIDFzXG5cdFx0c3RyID0gJzEnICsgcmVwZWF0KCAnMCcsIDIyICk7IC8vIGNhbid0IGJlIGFsbCAwc1xuXHRcdHJldHVybiBzaWduICsgZXhwICsgc3RyO1xuXHR9XG5cdC8vIFNwZWNpYWwgY2FzZTogKy0wXG5cdGlmICggeCA9PT0gMCApIHtcblx0XHQvLyBCYXNlZCBvbiBJRUVFIDc1NC0yMDA4Li4uXG5cdFx0ZXhwID0gcmVwZWF0KCAnMCcsIDggKTsgLy8gYWxsIDBzXG5cdFx0c3RyID0gcmVwZWF0KCAnMCcsIDIzICk7IC8vIGFsbCAwc1xuXHRcdHJldHVybiBzaWduICsgZXhwICsgc3RyO1xuXHR9XG5cdHggPSBhYnMoIHggKTtcblxuXHQvLyBJc29sYXRlIHRoZSBpbnRlZ2VyIHBhcnQgKGRpZ2l0cyBiZWZvcmUgdGhlIGRlY2ltYWwpOlxuXHRuID0gZmxvb3IoIHggKTtcblxuXHQvLyBJc29sYXRlIHRoZSBmcmFjdGlvbmFsIHBhcnQgKGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCk6XG5cdGYgPSB4IC0gbjtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIHBhcnRzIHRvIGJpdCBzdHJpbmdzOlxuXHRuID0gZGl2MiggbiApO1xuXHRmID0gbXVsdDIoIGYgKTtcblxuXHQvLyBEZXRlcm1pbmUgdGhlIGV4cG9uZW50IG5lZWRlZCB0byBub3JtYWxpemUgdGhlIGludGVnZXIrZnJhY3Rpb25hbCBwYXJ0cy4uLlxuXHRpZiAoIG4gKSB7XG5cdFx0Ly8gTW92ZSB0aGUgZGVjaW1hbCBgZGAgZGlnaXRzIHRvIHRoZSBsZWZ0OlxuXHRcdGV4cCA9IG4ubGVuZ3RoIC0gMTtcblx0fSBlbHNlIHtcblx0XHQvLyBGaW5kIHRoZSBmaXJzdCAnMScgYml0Li4uXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBmLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCBmWyBpIF0gPT09ICcxJyApIHtcblx0XHRcdFx0bmJpdHMgPSBpICsgMTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE1vdmUgdGhlIGRlY2ltYWwgYGRgIGRpZ2l0cyB0byB0aGUgcmlnaHQ6XG5cdFx0ZXhwID0gLW5iaXRzO1xuXHR9XG5cdC8vIE5vcm1hbGl6ZSB0aGUgY29tYmluZWQgaW50ZWdlcitmcmFjdGlvbmFsIHN0cmluZy4uLlxuXHRzdHIgPSBuICsgZjtcblx0aWYgKCBleHAgPCAwICkge1xuXHRcdC8vIEhhbmRsZSBzdWJub3JtYWxzLi4uXG5cdFx0aWYgKCBleHAgPD0gLUJJQVMgKSB7XG5cdFx0XHQvLyBDYXAgdGhlIG51bWJlciBvZiBiaXRzIHJlbW92ZWQ6XG5cdFx0XHRuYml0cyA9IEJJQVMgLSAxO1xuXHRcdH1cblx0XHQvLyBSZW1vdmUgYWxsIGxlYWRpbmcgemVyb3MgYW5kIHRoZSBmaXJzdCAnMScgZm9yIG5vcm1hbCB2YWx1ZXMsIGFuZCwgZm9yIHN1Ym5vcm1hbHMsIHJlbW92ZSBhdCBtb3N0IEJJQVMtMSBsZWFkaW5nIGJpdHM6XG5cdFx0c3RyID0gc3RyLnN1YnN0cmluZyggbmJpdHMgKTtcblx0fSBlbHNlIHtcblx0XHQvLyBSZW1vdmUgdGhlIGxlYWRpbmcgJzEnIChpbXBsaWNpdC9oaWRkZW4gYml0KTpcblx0XHRzdHIgPSBzdHIuc3Vic3RyaW5nKCAxICk7XG5cdH1cblx0Ly8gQ29udmVydCB0aGUgZXhwb25lbnQgdG8gYSBiaXQgc3RyaW5nOlxuXHRleHAgPSBkaXYyKCBleHAgKyBCSUFTICk7XG5cdGV4cCA9IGxwYWQoIGV4cCwgOCwgJzAnICk7XG5cblx0Ly8gRmlsbCBpbiBhbnkgdHJhaWxpbmcgemVyb3MgYW5kIGVuc3VyZSB3ZSBoYXZlIG9ubHkgMjMgZnJhY3Rpb24gYml0czpcblx0c3RyID0gcnBhZCggc3RyLCAyMywgJzAnICkuc3Vic3RyaW5nKCAwLCAyMyApO1xuXG5cdC8vIFJldHVybiBhIGJpdCByZXByZXNlbnRhdGlvbjpcblx0cmV0dXJuIHNpZ24gKyBleHAgKyBzdHI7XG59IC8vIGVuZCBGVU5DVElPTiBiaW5hcnlTdHJpbmcoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5hcnlTdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgTUFYX0lURVIgPSAxNDk7IC8vIDEyNysyMiAoc3Vibm9ybWFscylcbnZhciBNQVhfQklUUyA9IDI0OyAvLyBvbmx5IDIzIGJpdHMgZm9yIGZyYWN0aW9uXG5cblxuLy8gTVVMVDIgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBtdWx0MiggeCApXG4qXHRDb252ZXJ0cyBhIGZyYWN0aW9uIHRvIGEgbGl0ZXJhbCBiaXQgcmVwcmVzZW50YXRpb24gdXNpbmcgdGhlIG11bHRpcGx5LWJ5LTIgYWxnb3JpdGhtLlxuKlxuKiBAcGFyYW0ge051bWJlcn0geCAtIG51bWJlciBsZXNzIHRoYW4gMVxuKiBAcmV0dXJucyB7U3RyaW5nfSBiaXQgcmVwcmVzZW50YXRpb25cbiovXG5mdW5jdGlvbiBtdWx0MiggeCApIHtcblx0dmFyIHN0cjtcblx0dmFyIHk7XG5cdHZhciBpO1xuXHR2YXIgajtcblxuXHRzdHIgPSAnJztcblx0aWYgKCB4ID09PSAwICkge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblx0aiA9IE1BWF9JVEVSO1xuXG5cdC8vIEVhY2ggdGltZSB3ZSBtdWx0aXBseSBieSAyIGFuZCBmaW5kIGEgb25lcyBkaWdpdCwgYWRkIGEgJzEnOyBvdGhlcndpc2UsIGFkZCBhICcwJy4uXG5cdGZvciAoIGkgPSAwOyBpIDwgTUFYX0lURVI7IGkrKyApIHtcblx0XHR5ID0geCAqIDI7XG5cdFx0aWYgKCB5ID49IDEgKSB7XG5cdFx0XHR4ID0geSAtIDE7XG5cdFx0XHRzdHIgKz0gJzEnO1xuXHRcdFx0aWYgKCBqID09PSBNQVhfSVRFUiApIHtcblx0XHRcdFx0aiA9IGk7IC8vIGZpcnN0ICcxJ1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0geTtcblx0XHRcdHN0ciArPSAnMCc7XG5cdFx0fVxuXHRcdC8vIFN0b3Agd2hlbiB3ZSBoYXZlIG5vIG1vcmUgZGVjaW1hbHMgdG8gcHJvY2VzcyBvciBpbiB0aGUgZXZlbnQgd2UgZm91bmQgYSBmcmFjdGlvbiB3aGljaCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gYSBmaW5pdGUgbnVtYmVyIG9mIGJpdHMuLi5cblx0XHRpZiAoIHkgPT09IDEgfHwgaS1qID4gTUFYX0JJVFMgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0cjtcbn0gLy8gZW5kIEZVTkNUSU9OIG11bHQyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbXVsdDI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZsb29yO1xuIiwiXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG5cbi8qKlxuICogbmlmdGlcbiAqIEB0eXBlIHsqfHt9fVxuICovXG52YXIgbmlmdGkgPSBuaWZ0aSB8fCB7fTtcbm5pZnRpLk5JRlRJMSA9IG5pZnRpLk5JRlRJMSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL25pZnRpMS5qcycpIDogbnVsbCk7XG5uaWZ0aS5OSUZUSTIgPSBuaWZ0aS5OSUZUSTIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9uaWZ0aTIuanMnKSA6IG51bGwpO1xubmlmdGkuVXRpbHMgPSBuaWZ0aS5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxpdGllcy5qcycpIDogbnVsbCk7XG5cbnZhciBwYWtvID0gcGFrbyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCdwYWtvJykgOiBudWxsKTtcblxuXG5cbi8qKiogU3RhdGljIE1ldGhvZHMgKioqL1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRhdGEgcmVwcmVzZW50cyBhIE5JRlRJLTEgaGVhZGVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm5pZnRpLmlzTklGVEkxID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgYnVmLCBtYWcxLCBtYWcyLCBtYWczO1xuXG4gICAgYnVmID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuICAgIG1hZzEgPSBidWYuZ2V0VWludDgobmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUl9MT0NBVElPTik7XG4gICAgbWFnMiA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OICsgMSk7XG4gICAgbWFnMyA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OICsgMik7XG5cbiAgICByZXR1cm4gISEoKG1hZzEgPT09IG5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJbMF0pICYmIChtYWcyID09PSBuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSWzFdKSAmJlxuICAgICAgICAobWFnMyA9PT0gbmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUlsyXSkpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRhdGEgcmVwcmVzZW50cyBhIE5JRlRJLTIgaGVhZGVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm5pZnRpLmlzTklGVEkyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgYnVmLCBtYWcxLCBtYWcyLCBtYWczO1xuXG4gICAgYnVmID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuICAgIG1hZzEgPSBidWYuZ2V0VWludDgobmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUl9MT0NBVElPTik7XG4gICAgbWFnMiA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OICsgMSk7XG4gICAgbWFnMyA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OICsgMik7XG5cbiAgICByZXR1cm4gISEoKG1hZzEgPT09IG5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJbMF0pICYmIChtYWcyID09PSBuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSWzFdKSAmJlxuICAgIChtYWczID09PSBuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSWzJdKSk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkYXRhIHJlcHJlc2VudHMgYSBOSUZUSSBoZWFkZXIuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubmlmdGkuaXNOSUZUSSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIChuaWZ0aS5pc05JRlRJMShkYXRhKSB8fCBuaWZ0aS5pc05JRlRJMihkYXRhKSk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkYXRhIGlzIEdaSVAgY29tcHJlc3NlZC5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5uaWZ0aS5pc0NvbXByZXNzZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBidWYsIG1hZ2ljQ29va2llMSwgbWFnaWNDb29raWUyO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgYnVmID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuXG4gICAgICAgIG1hZ2ljQ29va2llMSA9IGJ1Zi5nZXRVaW50OCgwKTtcbiAgICAgICAgbWFnaWNDb29raWUyID0gYnVmLmdldFVpbnQ4KDEpO1xuXG4gICAgICAgIGlmIChtYWdpY0Nvb2tpZTEgPT09IG5pZnRpLlV0aWxzLkdVTlpJUF9NQUdJQ19DT09LSUUxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYWdpY0Nvb2tpZTIgPT09IG5pZnRpLlV0aWxzLkdVTlpJUF9NQUdJQ19DT09LSUUyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgZGVjb21wcmVzc2VkIGRhdGEuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gKi9cbm5pZnRpLmRlY29tcHJlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBwYWtvLmluZmxhdGUoZGF0YSkuYnVmZmVyO1xufTtcblxuXG5cbi8qKlxuICogUmVhZHMgYW5kIHJldHVybnMgdGhlIGhlYWRlciBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7bmlmdGkuTklGVEkxfG5pZnRpLk5JRlRJMnxudWxsfVxuICovXG5uaWZ0aS5yZWFkSGVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgaGVhZGVyID0gbnVsbDtcblxuICAgIGlmIChuaWZ0aS5pc0NvbXByZXNzZWQoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IG5pZnRpLmRlY29tcHJlc3MoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKG5pZnRpLmlzTklGVEkxKGRhdGEpKSB7XG4gICAgICAgIGhlYWRlciA9IG5ldyBuaWZ0aS5OSUZUSTEoKTtcbiAgICB9IGVsc2UgaWYgKG5pZnRpLmlzTklGVEkyKGRhdGEpKSB7XG4gICAgICAgIGhlYWRlciA9IG5ldyBuaWZ0aS5OSUZUSTIoKTtcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIGhlYWRlci5yZWFkSGVhZGVyKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGF0IGZpbGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIE5JRlRJIVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgaGVhZGVyIGNvbnRhaW5zIGFuIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSB7bmlmdGkuTklGVEkxfG5pZnRpLk5JRlRJMn0gaGVhZGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubmlmdGkuaGFzRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGhlYWRlcikge1xuICAgIHJldHVybiAoaGVhZGVyLmV4dGVuc2lvbkZsYWdbMF0gIT0gMCk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbWFnZSBkYXRhLlxuICogQHBhcmFtIHtuaWZ0aS5OSUZUSTF8bmlmdGkuTklGVEkyfSBoZWFkZXJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAqL1xubmlmdGkucmVhZEltYWdlID0gZnVuY3Rpb24gKGhlYWRlciwgZGF0YSkge1xuICAgIHZhciBpbWFnZU9mZnNldCA9IGhlYWRlci52b3hfb2Zmc2V0LFxuICAgICAgICB0aW1lRGltID0gMSxcbiAgICAgICAgc3RhdERpbSA9IDE7XG5cbiAgICBpZiAoaGVhZGVyLmRpbXNbNF0pIHtcbiAgICAgICAgdGltZURpbSA9IGhlYWRlci5kaW1zWzRdO1xuICAgIH1cblxuICAgIGlmIChoZWFkZXIuZGltc1s1XSkge1xuICAgICAgICBzdGF0RGltID0gaGVhZGVyLmRpbXNbNV07XG4gICAgfVxuXG4gICAgdmFyIGltYWdlU2l6ZSA9IGhlYWRlci5kaW1zWzFdICogaGVhZGVyLmRpbXNbMl0gKiBoZWFkZXIuZGltc1szXSAqIHRpbWVEaW0gKiBzdGF0RGltICogKGhlYWRlci5udW1CaXRzUGVyVm94ZWwgLyA4KTtcbiAgICByZXR1cm4gZGF0YS5zbGljZShpbWFnZU9mZnNldCwgaW1hZ2VPZmZzZXQgKyBpbWFnZVNpemUpO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIGRhdGEgKGluY2x1ZGluZyBleHRlbnNpb24gaGVhZGVyKS5cbiAqIEBwYXJhbSB7bmlmdGkuTklGVEkxfG5pZnRpLk5JRlRJMn0gaGVhZGVyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gKi9cbm5pZnRpLnJlYWRFeHRlbnNpb24gPSBmdW5jdGlvbiAoaGVhZGVyLCBkYXRhKSB7XG4gICAgdmFyIGxvYyA9IGhlYWRlci5nZXRFeHRlbnNpb25Mb2NhdGlvbigpLFxuICAgICAgICBzaXplID0gaGVhZGVyLmV4dGVuc2lvblNpemU7XG5cbiAgICByZXR1cm4gZGF0YS5zbGljZShsb2MsIGxvYyArIHNpemUpO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIGRhdGEuXG4gKiBAcGFyYW0ge25pZnRpLk5JRlRJMXxuaWZ0aS5OSUZUSTJ9IGhlYWRlclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICovXG5uaWZ0aS5yZWFkRXh0ZW5zaW9uRGF0YSA9IGZ1bmN0aW9uIChoZWFkZXIsIGRhdGEpIHtcbiAgICB2YXIgbG9jID0gaGVhZGVyLmdldEV4dGVuc2lvbkxvY2F0aW9uKCksXG4gICAgICAgIHNpemUgPSBoZWFkZXIuZXh0ZW5zaW9uU2l6ZTtcblxuICAgIHJldHVybiBkYXRhLnNsaWNlKGxvYyArIDgsIGxvYyArIHNpemUgLSA4KTtcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5pZnRpO1xufVxuIiwiXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cblxudmFyIG5pZnRpID0gbmlmdGkgfHwge307XG5uaWZ0aS5VdGlscyA9IG5pZnRpLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbGl0aWVzLmpzJykgOiBudWxsKTtcblxuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuXG4vKipcbiAqIFRoZSBOSUZUSTEgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGltX2luZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGRpbXMgLSBpbWFnZSBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AxXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhdHlwZUNvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1CaXRzUGVyVm94ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9zdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2VuZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHBpeERpbXMgLSB2b3hlbCBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gdm94X29mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjbF9zbG9wZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjbF9pbnRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHh5enRfdW5pdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYWxfbWF4XG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FsX21pblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2R1cmF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9mZnNldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXV4X2ZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnRlbnRfbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHFmb3JtX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZm9ybV9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9iXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9jXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9kXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl94XG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl95XG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl96XG4gKiBAcHJvcGVydHkge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGFmZmluZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1hZ2ljXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSERSIC0gaWYgaGRyL2ltZyBmb3JtYXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGV4dGVuc2lvbkZsYWdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBleHRlbnNpb25TaXplXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXh0ZW5zaW9uQ29kZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5uaWZ0aS5OSUZUSTEgPSBuaWZ0aS5OSUZUSTEgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gICAgdGhpcy5kaW1faW5mbyA9IDA7XG4gICAgdGhpcy5kaW1zID0gW107XG4gICAgdGhpcy5pbnRlbnRfcDEgPSAwO1xuICAgIHRoaXMuaW50ZW50X3AyID0gMDtcbiAgICB0aGlzLmludGVudF9wMyA9IDA7XG4gICAgdGhpcy5pbnRlbnRfY29kZSA9IDA7XG4gICAgdGhpcy5kYXRhdHlwZUNvZGUgPSAwO1xuICAgIHRoaXMubnVtQml0c1BlclZveGVsID0gMDtcbiAgICB0aGlzLnNsaWNlX3N0YXJ0ID0gMDtcbiAgICB0aGlzLnNsaWNlX2VuZCA9IDA7XG4gICAgdGhpcy5zbGljZV9jb2RlID0gMDtcbiAgICB0aGlzLnBpeERpbXMgPSBbXTtcbiAgICB0aGlzLnZveF9vZmZzZXQgPSAwO1xuICAgIHRoaXMuc2NsX3Nsb3BlID0gMTtcbiAgICB0aGlzLnNjbF9pbnRlciA9IDA7XG4gICAgdGhpcy54eXp0X3VuaXRzID0gMDtcbiAgICB0aGlzLmNhbF9tYXggPSAwO1xuICAgIHRoaXMuY2FsX21pbiA9IDA7XG4gICAgdGhpcy5zbGljZV9kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b2Zmc2V0ID0gMDtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICB0aGlzLmF1eF9maWxlID0gXCJcIjtcbiAgICB0aGlzLmludGVudF9uYW1lID0gXCJcIjtcbiAgICB0aGlzLnFmb3JtX2NvZGUgPSAwO1xuICAgIHRoaXMuc2Zvcm1fY29kZSA9IDA7XG4gICAgdGhpcy5xdWF0ZXJuX2IgPSAwO1xuICAgIHRoaXMucXVhdGVybl9jID0gMDtcbiAgICB0aGlzLnF1YXRlcm5fZCA9IDA7XG4gICAgdGhpcy5xb2Zmc2V0X3ggPSAwO1xuICAgIHRoaXMucW9mZnNldF95ID0gMDtcbiAgICB0aGlzLnFvZmZzZXRfeiA9IDA7XG4gICAgdGhpcy5hZmZpbmUgPSBbWzEsIDAsIDAsIDBdLCBbMCwgMSwgMCwgMF0sIFswLCAwLCAxLCAwXSwgWzAsIDAsIDAsIDFdXTtcbiAgICB0aGlzLm1hZ2ljID0gMDtcbiAgICB0aGlzLmlzSERSID0gZmFsc2U7XG4gICAgdGhpcy5leHRlbnNpb25GbGFnID0gWzAsIDAsIDAsIDBdO1xuICAgIHRoaXMuZXh0ZW5zaW9uU2l6ZSA9IDA7XG4gICAgdGhpcy5leHRlbnNpb25Db2RlID0gMDtcbn07XG5cblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxuLy8gZGF0YXR5cGUgY29kZXNcbm5pZnRpLk5JRlRJMS5UWVBFX05PTkUgICAgICAgICAgICA9IDA7XG5uaWZ0aS5OSUZUSTEuVFlQRV9CSU5BUlkgICAgICAgICAgPSAxO1xubmlmdGkuTklGVEkxLlRZUEVfVUlOVDggICAgICAgICAgID0gMjtcbm5pZnRpLk5JRlRJMS5UWVBFX0lOVDE2ICAgICAgICAgICA9IDQ7XG5uaWZ0aS5OSUZUSTEuVFlQRV9JTlQzMiAgICAgICAgICAgPSA4O1xubmlmdGkuTklGVEkxLlRZUEVfRkxPQVQzMiAgICAgICAgPSAxNjtcbm5pZnRpLk5JRlRJMS5UWVBFX0NPTVBMRVg2NCAgICAgID0gMzI7XG5uaWZ0aS5OSUZUSTEuVFlQRV9GTE9BVDY0ICAgICAgICA9IDY0O1xubmlmdGkuTklGVEkxLlRZUEVfUkdCMjQgICAgICAgICA9IDEyODtcbm5pZnRpLk5JRlRJMS5UWVBFX0lOVDggICAgICAgICAgPSAyNTY7XG5uaWZ0aS5OSUZUSTEuVFlQRV9VSU5UMTYgICAgICAgID0gNTEyO1xubmlmdGkuTklGVEkxLlRZUEVfVUlOVDMyICAgICAgICA9IDc2ODtcbm5pZnRpLk5JRlRJMS5UWVBFX0lOVDY0ICAgICAgICA9IDEwMjQ7XG5uaWZ0aS5OSUZUSTEuVFlQRV9VSU5UNjQgICAgICAgPSAxMjgwO1xubmlmdGkuTklGVEkxLlRZUEVfRkxPQVQxMjggICAgID0gMTUzNjtcbm5pZnRpLk5JRlRJMS5UWVBFX0NPTVBMRVgxMjggICA9IDE3OTI7XG5uaWZ0aS5OSUZUSTEuVFlQRV9DT01QTEVYMjU2ICAgPSAyMDQ4O1xuXG4vLyB0cmFuc2Zvcm0gY29kZXNcbm5pZnRpLk5JRlRJMS5YRk9STV9VTktOT1dOICAgICAgICA9IDA7XG5uaWZ0aS5OSUZUSTEuWEZPUk1fU0NBTk5FUl9BTkFUICAgPSAxO1xubmlmdGkuTklGVEkxLlhGT1JNX0FMSUdORURfQU5BVCAgID0gMjtcbm5pZnRpLk5JRlRJMS5YRk9STV9UQUxBSVJBQ0ggICAgICA9IDM7XG5uaWZ0aS5OSUZUSTEuWEZPUk1fTU5JXzE1MiAgICAgICAgPSA0O1xuXG4vLyB1bml0IGNvZGVzXG5uaWZ0aS5OSUZUSTEuU1BBVElBTF9VTklUU19NQVNLID0gMHgwNztcbm5pZnRpLk5JRlRJMS5URU1QT1JBTF9VTklUU19NQVNLID0gMHgzODtcbm5pZnRpLk5JRlRJMS5VTklUU19VTktOT1dOICAgICAgICA9IDA7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfTUVURVIgICAgICAgICAgPSAxO1xubmlmdGkuTklGVEkxLlVOSVRTX01NICAgICAgICAgICAgID0gMjtcbm5pZnRpLk5JRlRJMS5VTklUU19NSUNST04gICAgICAgICA9IDM7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfU0VDICAgICAgICAgICAgPSA4O1xubmlmdGkuTklGVEkxLlVOSVRTX01TRUMgICAgICAgICAgPSAxNjtcbm5pZnRpLk5JRlRJMS5VTklUU19VU0VDICAgICAgICAgID0gMjQ7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfSFogICAgICAgICAgICA9IDMyO1xubmlmdGkuTklGVEkxLlVOSVRTX1BQTSAgICAgICAgICAgPSA0MDtcbm5pZnRpLk5JRlRJMS5VTklUU19SQURTICAgICAgICAgID0gNDg7XG5cbi8vIG5pZnRpMSBjb2Rlc1xubmlmdGkuTklGVEkxLk1BR0lDX0NPT0tJRSA9IDM0ODtcbm5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJfTE9DQVRJT04gPSAzNDQ7XG5uaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSID0gWzB4NkUsIDB4MkIsIDB4MzFdOyAgLy8gbisxICgubmlpKVxubmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUjIgPSBbMHg2RSwgMHg2OSwgMHgzMV07ICAvLyBuaTEgKC5oZHIvLmltZylcbm5pZnRpLk5JRlRJMS5FWFRFTlNJT05fSEVBREVSX1NJWkUgPSA4O1xuXG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG4vKipcbiAqIFJlYWRzIHRoZSBoZWFkZXIgZGF0YS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5yZWFkSGVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgcmF3RGF0YSA9IG5ldyBEYXRhVmlldyhkYXRhKSxcbiAgICAgICAgbWFnaWNDb29raWVWYWwgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAwLCB0aGlzLmxpdHRsZUVuZGlhbiksXG4gICAgICAgIGN0cixcbiAgICAgICAgY3RyT3V0LFxuICAgICAgICBjdHJJbixcbiAgICAgICAgaW5kZXg7XG5cbiAgICBpZiAobWFnaWNDb29raWVWYWwgIT09IG5pZnRpLk5JRlRJMS5NQUdJQ19DT09LSUUpIHsgIC8vIHRyeSBhcyBsaXR0bGUgZW5kaWFuXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgICAgICAgbWFnaWNDb29raWVWYWwgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKG1hZ2ljQ29va2llVmFsICE9PSBuaWZ0aS5OSUZUSTEuTUFHSUNfQ09PS0lFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgTklGVEkgZmlsZSFcIik7XG4gICAgfVxuXG4gICAgdGhpcy5kaW1faW5mbyA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAzOSk7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGluZGV4ID0gNDAgKyAoY3RyICogMik7XG4gICAgICAgIHRoaXMuZGltc1tjdHJdID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZW50X3AxID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCA1NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X3AyID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCA2MCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X3AzID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCA2NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDY4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLmRhdGF0eXBlQ29kZSA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgNzAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLm51bUJpdHNQZXJWb3hlbCA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgNzIsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2xpY2Vfc3RhcnQgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDc0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGluZGV4ID0gNzYgKyAoY3RyICogNCk7XG4gICAgICAgIHRoaXMucGl4RGltc1tjdHJdID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIHRoaXMudm94X29mZnNldCA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTA4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNjbF9zbG9wZSA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTEyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zY2xfaW50ZXIgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDExNiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zbGljZV9lbmQgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDEyMCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuc2xpY2VfY29kZSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAxMjIpO1xuXG4gICAgdGhpcy54eXp0X3VuaXRzID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDEyMyk7XG5cbiAgICB0aGlzLmNhbF9tYXggPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDEyNCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuY2FsX21pbiA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTI4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNsaWNlX2R1cmF0aW9uID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAxMzIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnRvZmZzZXQgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDEzNiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDE0OCwgMjI4KTtcbiAgICB0aGlzLmF1eF9maWxlID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMjI4LCAyNTIpO1xuXG4gICAgdGhpcy5xZm9ybV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCAyNTIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnNmb3JtX2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDI1NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5xdWF0ZXJuX2IgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDI1NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucXVhdGVybl9jID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAyNjAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnF1YXRlcm5fZCA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMjY0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xb2Zmc2V0X3ggPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDI2OCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucW9mZnNldF95ID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAyNzIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnFvZmZzZXRfeiA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMjc2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ck91dCA9IDA7IGN0ck91dCA8IDM7IGN0ck91dCArPSAxKSB7XG4gICAgICAgIGZvciAoY3RySW4gPSAwOyBjdHJJbiA8IDQ7IGN0ckluICs9IDEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMjgwICsgKCgoY3RyT3V0ICogNCkgKyBjdHJJbikgKiA0KTtcbiAgICAgICAgICAgIHRoaXMuYWZmaW5lW2N0ck91dF1bY3RySW5dID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZmZpbmVbM11bMF0gPSAwO1xuICAgIHRoaXMuYWZmaW5lWzNdWzFdID0gMDtcbiAgICB0aGlzLmFmZmluZVszXVsyXSA9IDA7XG4gICAgdGhpcy5hZmZpbmVbM11bM10gPSAxO1xuXG4gICAgdGhpcy5pbnRlbnRfbmFtZSA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDMyOCwgMzQ0KTtcbiAgICB0aGlzLm1hZ2ljID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMzQ0LCAzNDgpO1xuXG4gICAgdGhpcy5pc0hEUiA9ICh0aGlzLm1hZ2ljID09PSBuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSMik7XG5cbiAgICBpZiAocmF3RGF0YS5ieXRlTGVuZ3RoID4gbmlmdGkuTklGVEkxLk1BR0lDX0NPT0tJRSkge1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMF0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMzQ4KTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzFdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDM0OCArIDEpO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMl0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMzQ4ICsgMik7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1szXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAzNDggKyAzKTtcblxuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25GbGFnWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvblNpemUgPSB0aGlzLmdldEV4dGVuc2lvblNpemUocmF3RGF0YSk7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbkNvZGUgPSB0aGlzLmdldEV4dGVuc2lvbkNvZGUocmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgb2YgaGVhZGVyIGZpZWxkcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUudG9Gb3JtYXR0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZtdCA9IG5pZnRpLlV0aWxzLmZvcm1hdE51bWJlcixcbiAgICAgICAgc3RyaW5nID0gXCJcIjtcblxuICAgIHN0cmluZyArPSAoXCJEaW0gSW5mbyA9IFwiICsgdGhpcy5kaW1faW5mbyArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkltYWdlIERpbWVuc2lvbnMgKDEtOCk6IFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzBdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzFdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzJdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzNdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzRdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzVdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzZdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzddICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW50ZW50IFBhcmFtZXRlcnMgKDEtMyk6IFwiICtcbiAgICAgICAgdGhpcy5pbnRlbnRfcDEgKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmludGVudF9wMiArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuaW50ZW50X3AzKSArIFwiXFxuXCI7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW50ZW50IENvZGUgPSBcIiArIHRoaXMuaW50ZW50X2NvZGUgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGF0YXR5cGUgPSBcIiArIHRoaXMuZGF0YXR5cGVDb2RlICsgIFwiIChcIiArIHRoaXMuZ2V0RGF0YXR5cGVDb2RlU3RyaW5nKHRoaXMuZGF0YXR5cGVDb2RlKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiQml0cyBQZXIgVm94ZWwgPSBcIiArIHRoaXMubnVtQml0c1BlclZveGVsICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlNsaWNlIFN0YXJ0ID0gXCIgKyB0aGlzLnNsaWNlX3N0YXJ0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlZveGVsIERpbWVuc2lvbnMgKDEtOCk6IFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1swXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzFdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1szXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzRdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbNV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s2XSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzddKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkltYWdlIE9mZnNldCA9IFwiICsgdGhpcy52b3hfb2Zmc2V0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRhdGEgU2NhbGU6ICBTbG9wZSA9IFwiICsgZm10KHRoaXMuc2NsX3Nsb3BlKSArIFwiICBJbnRlcmNlcHQgPSBcIiArIGZtdCh0aGlzLnNjbF9pbnRlcikgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgRW5kID0gXCIgKyB0aGlzLnNsaWNlX2VuZCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBDb2RlID0gXCIgKyB0aGlzLnNsaWNlX2NvZGUgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiVW5pdHMgQ29kZSA9IFwiICsgdGhpcy54eXp0X3VuaXRzICsgXCIgKFwiICsgdGhpcy5nZXRVbml0c0NvZGVTdHJpbmcobmlmdGkuTklGVEkxLlNQQVRJQUxfVU5JVFNfTUFTSyAmIHRoaXMueHl6dF91bml0cykgKyBcIiwgXCIgKyB0aGlzLmdldFVuaXRzQ29kZVN0cmluZyhuaWZ0aS5OSUZUSTEuVEVNUE9SQUxfVU5JVFNfTUFTSyAmIHRoaXMueHl6dF91bml0cykgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRpc3BsYXkgUmFuZ2U6ICBNYXggPSBcIiArIGZtdCh0aGlzLmNhbF9tYXgpICsgXCIgIE1pbiA9IFwiICsgZm10KHRoaXMuY2FsX21pbikgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgRHVyYXRpb24gPSBcIiArIHRoaXMuc2xpY2VfZHVyYXRpb24gKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiVGltZSBBeGlzIFNoaWZ0ID0gXCIgKyB0aGlzLnRvZmZzZXQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGVzY3JpcHRpb246IFxcXCJcIiArIHRoaXMuZGVzY3JpcHRpb24gKyBcIlxcXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkF1eGlsaWFyeSBGaWxlOiBcXFwiXCIgKyB0aGlzLmF1eF9maWxlICsgXCJcXFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJRLUZvcm0gQ29kZSA9IFwiICsgdGhpcy5xZm9ybV9jb2RlICsgXCIgKFwiICsgdGhpcy5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nKHRoaXMucWZvcm1fY29kZSkgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBDb2RlID0gXCIgKyB0aGlzLnNmb3JtX2NvZGUgKyBcIiAoXCIgKyB0aGlzLmdldFRyYW5zZm9ybUNvZGVTdHJpbmcodGhpcy5zZm9ybV9jb2RlKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiUXVhdGVybmlvbiBQYXJhbWV0ZXJzOiAgXCIgK1xuICAgICAgICBcImIgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fYikgKyBcIiAgXCIgK1xuICAgICAgICBcImMgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fYykgKyBcIiAgXCIgK1xuICAgICAgICBcImQgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fZCkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJRdWF0ZXJuaW9uIE9mZnNldHM6ICBcIiArXG4gICAgICAgIFwieCA9IFwiICsgdGhpcy5xb2Zmc2V0X3ggKyBcIiAgXCIgK1xuICAgICAgICBcInkgPSBcIiArIHRoaXMucW9mZnNldF95ICsgXCIgIFwiICtcbiAgICAgICAgXCJ6ID0gXCIgKyB0aGlzLnFvZmZzZXRfeiArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFg6IFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzBdWzBdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVswXVsxXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMF1bMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzBdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFk6IFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzFdWzBdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsxXVsxXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMV1bMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzFdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFo6IFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzJdWzBdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsyXVsxXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMl1bMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzJdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkludGVudCBOYW1lOiBcXFwiXCIgKyB0aGlzLmludGVudF9uYW1lICsgXCJcXFwiXFxuXCIpO1xuXG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9uRmxhZ1swXSkge1xuICAgICAgICBzdHJpbmcgKz0gKFwiRXh0ZW5zaW9uOiBTaXplID0gXCIgKyB0aGlzLmV4dGVuc2lvblNpemUgKyBcIiAgQ29kZSA9IFwiICsgdGhpcy5leHRlbnNpb25Db2RlICsgXCJcXG5cIik7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgb2YgZGF0YXR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXREYXRhdHlwZUNvZGVTdHJpbmcgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9VSU5UOCkge1xuICAgICAgICByZXR1cm4gXCIxLUJ5dGUgVW5zaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfSU5UMTYpIHtcbiAgICAgICAgcmV0dXJuIFwiMi1CeXRlIFNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9JTlQzMikge1xuICAgICAgICByZXR1cm4gXCI0LUJ5dGUgU2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX0ZMT0FUMzIpIHtcbiAgICAgICAgcmV0dXJuIFwiNC1CeXRlIEZsb2F0XCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9GTE9BVDY0KSB7XG4gICAgICAgIHJldHVybiBcIjgtQnl0ZSBGbG9hdFwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfUkdCMjQpIHtcbiAgICAgICAgcmV0dXJuIFwiUkdCXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9JTlQ4KSB7XG4gICAgICAgIHJldHVybiBcIjEtQnl0ZSBTaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfVUlOVDE2KSB7XG4gICAgICAgIHJldHVybiBcIjItQnl0ZSBVbnNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9VSU5UMzIpIHtcbiAgICAgICAgcmV0dXJuIFwiNC1CeXRlIFVuc2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX0lOVDY0KSB7XG4gICAgICAgIHJldHVybiBcIjgtQnl0ZSBTaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfVUlOVDY0KSB7XG4gICAgICAgIHJldHVybiBcIjgtQnl0ZSBVbnNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiVW5rbm93blwiO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIHRyYW5zZm9ybSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5YRk9STV9TQ0FOTkVSX0FOQVQpIHtcbiAgICAgICAgcmV0dXJuIFwiU2Nhbm5lclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlhGT1JNX0FMSUdORURfQU5BVCkge1xuICAgICAgICByZXR1cm4gXCJBbGlnbmVkXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuWEZPUk1fVEFMQUlSQUNIKSB7XG4gICAgICAgIHJldHVybiBcIlRhbGFpcmFjaFwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlhGT1JNX01OSV8xNTIpIHtcbiAgICAgICAgcmV0dXJuIFwiTU5JXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiVW5rbm93blwiO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIHNwYXRpYWwgYW5kIHRlbXBvcmFsIHVuaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0VW5pdHNDb2RlU3RyaW5nID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX01FVEVSKSB7XG4gICAgICAgIHJldHVybiBcIk1ldGVyc1wiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX01NKSB7XG4gICAgICAgIHJldHVybiBcIk1pbGxpbWV0ZXJzXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfTUlDUk9OKSB7XG4gICAgICAgIHJldHVybiBcIk1pY3JvbnNcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19TRUMpIHtcbiAgICAgICAgcmV0dXJuIFwiU2Vjb25kc1wiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX01TRUMpIHtcbiAgICAgICAgcmV0dXJuIFwiTWlsbGlzZWNvbmRzXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfVVNFQykge1xuICAgICAgICByZXR1cm4gXCJNaWNyb3NlY29uZHNcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19IWikge1xuICAgICAgICByZXR1cm4gXCJIelwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX1BQTSkge1xuICAgICAgICByZXR1cm4gXCJQUE1cIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19SQURTKSB7XG4gICAgICAgIHJldHVybiBcIlJhZHNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJVbmtub3duXCI7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHFmb3JtIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldFFmb3JtTWF0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnROaWZ0aVFGb3JtVG9OaWZ0aVNGb3JtKHRoaXMucXVhdGVybl9iLCB0aGlzLnF1YXRlcm5fYywgdGhpcy5xdWF0ZXJuX2QsIHRoaXMucW9mZnNldF94LFxuICAgICAgICB0aGlzLnFvZmZzZXRfeSwgdGhpcy5xb2Zmc2V0X3osIHRoaXMucGl4RGltc1sxXSwgdGhpcy5waXhEaW1zWzJdLCB0aGlzLnBpeERpbXNbM10sIHRoaXMucGl4RGltc1swXSk7XG59O1xuXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBxZm9ybSB0byBhbiBhZmZpbmUuICAoU2VlIGh0dHA6Ly9uaWZ0aS5uaW1oLm5paC5nb3YvcHViL2Rpc3Qvc3JjL25pZnRpbGliL25pZnRpMV9pby5jKVxuICogQHBhcmFtIHtudW1iZXJ9IHFiXG4gKiBAcGFyYW0ge251bWJlcn0gcWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBxZFxuICogQHBhcmFtIHtudW1iZXJ9IHF4XG4gKiBAcGFyYW0ge251bWJlcn0gcXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBxelxuICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gKiBAcGFyYW0ge251bWJlcn0gZHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkelxuICogQHBhcmFtIHtudW1iZXJ9IHFmYWNcbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmNvbnZlcnROaWZ0aVFGb3JtVG9OaWZ0aVNGb3JtID0gZnVuY3Rpb24gKHFiLCBxYywgcWQsIHF4LCBxeSwgcXosIGR4LCBkeSwgZHosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxZmFjKSB7XG4gICAgdmFyIFIgPSBbWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdXSxcbiAgICAgICAgYSxcbiAgICAgICAgYiA9IHFiLFxuICAgICAgICBjID0gcWMsXG4gICAgICAgIGQgPSBxZCxcbiAgICAgICAgeGQsXG4gICAgICAgIHlkLFxuICAgICAgICB6ZDtcblxuICAgIC8vIGxhc3Qgcm93IGlzIGFsd2F5cyBbIDAgMCAwIDEgXVxuICAgIFJbM11bMF0gPSBSWzNdWzFdID0gUlszXVsyXSA9IDAuMDtcbiAgICBSWzNdWzNdID0gMS4wO1xuXG4gICAgLy8gY29tcHV0ZSBhIHBhcmFtZXRlciBmcm9tIGIsYyxkXG4gICAgYSA9IDEuMCAtIChiICogYiArIGMgKiBjICsgZCAqIGQpO1xuICAgIGlmIChhIDwgMC4wMDAwMDAxKSB7ICAgICAgICAgICAgICAgICAgIC8qIHNwZWNpYWwgY2FzZSAqL1xuXG4gICAgICAgIGEgPSAxLjAgLyBNYXRoLnNxcnQoYiAqIGIgKyBjICogYyArIGQgKiBkKTtcbiAgICAgICAgYiAqPSBhO1xuICAgICAgICBjICo9IGE7XG4gICAgICAgIGQgKj0gYTsgICAgICAgIC8qIG5vcm1hbGl6ZSAoYixjLGQpIHZlY3RvciAqL1xuICAgICAgICBhID0gMC4wOyAgICAgICAgICAgICAgICAgICAgICAgIC8qIGEgPSAwID09PiAxODAgZGVncmVlIHJvdGF0aW9uICovXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBhID0gTWF0aC5zcXJ0KGEpOyAgICAgICAgICAgICAgICAgICAgIC8qIGFuZ2xlID0gMiphcmNjb3MoYSkgKi9cbiAgICB9XG5cbiAgICAvLyBsb2FkIHJvdGF0aW9uIG1hdHJpeCwgaW5jbHVkaW5nIHNjYWxpbmcgZmFjdG9ycyBmb3Igdm94ZWwgc2l6ZXNcbiAgICB4ZCA9IChkeCA+IDAuMCkgPyBkeCA6IDEuMDsgICAgICAgLyogbWFrZSBzdXJlIGFyZSBwb3NpdGl2ZSAqL1xuICAgIHlkID0gKGR5ID4gMC4wKSA/IGR5IDogMS4wO1xuICAgIHpkID0gKGR6ID4gMC4wKSA/IGR6IDogMS4wO1xuXG4gICAgaWYgKHFmYWMgPCAwLjApIHtcbiAgICAgICAgemQgPSAtemQ7ICAgICAgICAgLyogbGVmdCBoYW5kZWRuZXNzPyAqL1xuICAgIH1cblxuICAgIFJbMF1bMF0gPSAgICAgICAoYSAqIGEgKyBiICogYiAtIGMgKiBjIC0gZCAqIGQpICogeGQ7XG4gICAgUlswXVsxXSA9IDIuMCAqIChiICogYyAtIGEgKiBkKSAqIHlkO1xuICAgIFJbMF1bMl0gPSAyLjAgKiAoYiAqIGQgKyBhICogYykgKiB6ZDtcbiAgICBSWzFdWzBdID0gMi4wICogKGIgKiBjICsgYSAqIGQpICogeGQ7XG4gICAgUlsxXVsxXSA9ICAgICAgIChhICogYSArIGMgKiBjIC0gYiAqIGIgLSBkICogZCkgKiB5ZDtcbiAgICBSWzFdWzJdID0gMi4wICogKGMgKiBkIC0gYSAqIGIpICogemQ7XG4gICAgUlsyXVswXSA9IDIuMCAqIChiICogZCAtIGEgKiBjKSAqIHhkO1xuICAgIFJbMl1bMV0gPSAyLjAgKiAoYyAqIGQgKyBhICogYikgKiB5ZDtcbiAgICBSWzJdWzJdID0gICAgICAgKGEgKiBhICsgZCAqIGQgLSBjICogYyAtIGIgKiBiKSAqIHpkO1xuXG4gICAgLy8gbG9hZCBvZmZzZXRzXG4gICAgUlswXVszXSA9IHF4O1xuICAgIFJbMV1bM10gPSBxeTtcbiAgICBSWzJdWzNdID0gcXo7XG5cbiAgICByZXR1cm4gUjtcbn07XG5cblxuXG4vKipcbiAqIENvbnZlcnRzIHNmb3JtIHRvIGFuIG9yaWVudGF0aW9uIHN0cmluZyAoZS5nLiwgWFlaKy0tKS4gIChTZWUgaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxX2lvLmMpXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IFJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuY29udmVydE5pZnRpU0Zvcm1Ub05FTUEgPSBmdW5jdGlvbiAoUikge1xuICAgIHZhciB4aSwgeGosIHhrLCB5aSwgeWosIHlrLCB6aSwgemosIHprLCB2YWwsIGRldFEsIGRldFAsIGksIGosIGssIHAsIHEsIHIsIGliZXN0LCBqYmVzdCwga2Jlc3QsIHBiZXN0LCBxYmVzdCwgcmJlc3QsXG4gICAgICAgIE0sIHZiZXN0LCBRLCBQLCBpQ2hhciwgakNoYXIsIGtDaGFyLCBpU2Vuc2UsIGpTZW5zZSwga1NlbnNlO1xuICAgIGsgPSAwO1xuXG4gICAgUSA9IFtbMCwgMCwgMF0sIFswLCAwLCAwXSwgWzAsIDAsIDBdXTtcbiAgICBQID0gW1swLCAwLCAwXSwgWzAsIDAsIDBdLCBbMCwgMCwgMF1dO1xuXG4gICAgLy9pZiggaWNvZCA9PSBOVUxMIHx8IGpjb2QgPT0gTlVMTCB8fCBrY29kID09IE5VTEwgKSByZXR1cm4gOyAvKiBiYWQgKi9cblxuICAgIC8vKmljb2QgPSAqamNvZCA9ICprY29kID0gMCA7IC8qIHRoaXMuZXJyb3JNZXNzYWdlIHJldHVybnMsIGlmIHNoKnQgaGFwcGVucyAqL1xuXG4gICAgLyogbG9hZCBjb2x1bW4gdmVjdG9ycyBmb3IgZWFjaCAoaSxqLGspIGRpcmVjdGlvbiBmcm9tIG1hdHJpeCAqL1xuXG4gICAgLyotLSBpIGF4aXMgLS0qLyAvKi0tIGogYXhpcyAtLSovIC8qLS0gayBheGlzIC0tKi9cblxuICAgIHhpID0gUlswXVswXTtcbiAgICB4aiA9IFJbMF1bMV07XG4gICAgeGsgPSBSWzBdWzJdO1xuXG4gICAgeWkgPSBSWzFdWzBdO1xuICAgIHlqID0gUlsxXVsxXTtcbiAgICB5ayA9IFJbMV1bMl07XG5cbiAgICB6aSA9IFJbMl1bMF07XG4gICAgemogPSBSWzJdWzFdO1xuICAgIHprID0gUlsyXVsyXTtcblxuICAgIC8qIG5vcm1hbGl6ZSBjb2x1bW4gdmVjdG9ycyB0byBnZXQgdW5pdCB2ZWN0b3JzIGFsb25nIGVhY2ggaWprLWF4aXMgKi9cblxuICAgIC8qIG5vcm1hbGl6ZSBpIGF4aXMgKi9cbiAgICB2YWwgPSBNYXRoLnNxcnQoeGkgKiB4aSArIHlpICogeWkgKyB6aSAqIHppKTtcbiAgICBpZiAodmFsID09PSAwLjApIHsgIC8qIHN0dXBpZCBpbnB1dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB4aSAvPSB2YWw7XG4gICAgeWkgLz0gdmFsO1xuICAgIHppIC89IHZhbDtcblxuICAgIC8qIG5vcm1hbGl6ZSBqIGF4aXMgKi9cbiAgICB2YWwgPSBNYXRoLnNxcnQoeGogKiB4aiArIHlqICogeWogKyB6aiAqIHpqKTtcbiAgICBpZiAodmFsID09PSAwLjApIHsgIC8qIHN0dXBpZCBpbnB1dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB4aiAvPSB2YWw7XG4gICAgeWogLz0gdmFsO1xuICAgIHpqIC89IHZhbDtcblxuICAgIC8qIG9ydGhvZ29uYWxpemUgaiBheGlzIHRvIGkgYXhpcywgaWYgbmVlZGVkICovXG4gICAgdmFsID0geGkgKiB4aiArIHlpICogeWogKyB6aSAqIHpqOyAgICAvKiBkb3QgcHJvZHVjdCBiZXR3ZWVuIGkgYW5kIGogKi9cbiAgICBpZiAoTWF0aC5hYnModmFsKSA+IDEuRS00KSB7XG4gICAgICAgIHhqIC09IHZhbCAqIHhpO1xuICAgICAgICB5aiAtPSB2YWwgKiB5aTtcbiAgICAgICAgemogLT0gdmFsICogemk7XG4gICAgICAgIHZhbCA9IE1hdGguc3FydCh4aiAqIHhqICsgeWogKiB5aiArIHpqICogemopOyAgLyogbXVzdCByZW5vcm1hbGl6ZSAqL1xuICAgICAgICBpZiAodmFsID09PSAwLjApIHsgICAgICAgICAgICAgIC8qIGogd2FzIHBhcmFsbGVsIHRvIGk/ICovXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB4aiAvPSB2YWw7XG4gICAgICAgIHlqIC89IHZhbDtcbiAgICAgICAgemogLz0gdmFsO1xuICAgIH1cblxuICAgIC8qIG5vcm1hbGl6ZSBrIGF4aXM7IGlmIGl0IGlzIHplcm8sIG1ha2UgaXQgdGhlIGNyb3NzIHByb2R1Y3QgaSB4IGogKi9cbiAgICB2YWwgPSBNYXRoLnNxcnQoeGsgKiB4ayArIHlrICogeWsgKyB6ayAqIHprKTtcbiAgICBpZiAodmFsID09PSAwLjApIHtcbiAgICAgICAgeGsgPSB5aSAqIHpqIC0gemkgKiB5ajtcbiAgICAgICAgeWsgPSB6aSAqIHhqIC0gemogKiB4aTtcbiAgICAgICAgemsgPSB4aSAqIHlqIC0geWkgKiB4ajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB4ayAvPSB2YWw7XG4gICAgICAgIHlrIC89IHZhbDtcbiAgICAgICAgemsgLz0gdmFsO1xuICAgIH1cblxuICAgIC8qIG9ydGhvZ29uYWxpemUgayB0byBpICovXG4gICAgdmFsID0geGkgKiB4ayArIHlpICogeWsgKyB6aSAqIHprOyAgICAvKiBkb3QgcHJvZHVjdCBiZXR3ZWVuIGkgYW5kIGsgKi9cbiAgICBpZiAoTWF0aC5hYnModmFsKSA+IDEuRS00KSB7XG4gICAgICAgIHhrIC09IHZhbCAqIHhpO1xuICAgICAgICB5ayAtPSB2YWwgKiB5aTtcbiAgICAgICAgemsgLT0gdmFsICogemk7XG4gICAgICAgIHZhbCA9IE1hdGguc3FydCh4ayAqIHhrICsgeWsgKiB5ayArIHprICogemspO1xuICAgICAgICBpZiAodmFsID09PSAwLjApIHsgICAgLyogYmFkICovXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB4ayAvPSB2YWw7XG4gICAgICAgIHlrIC89IHZhbDtcbiAgICAgICAgemsgLz0gdmFsO1xuICAgIH1cblxuICAgIC8qIG9ydGhvZ29uYWxpemUgayB0byBqICovXG4gICAgdmFsID0geGogKiB4ayArIHlqICogeWsgKyB6aiAqIHprOyAgICAvKiBkb3QgcHJvZHVjdCBiZXR3ZWVuIGogYW5kIGsgKi9cbiAgICBpZiAoTWF0aC5hYnModmFsKSA+IDEuZS00KSB7XG4gICAgICAgIHhrIC09IHZhbCAqIHhqO1xuICAgICAgICB5ayAtPSB2YWwgKiB5ajtcbiAgICAgICAgemsgLT0gdmFsICogemo7XG4gICAgICAgIHZhbCA9IE1hdGguc3FydCh4ayAqIHhrICsgeWsgKiB5ayArIHprICogemspO1xuICAgICAgICBpZiAodmFsID09PSAwLjApIHsgICAgIC8qIGJhZCAqL1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgeGsgLz0gdmFsO1xuICAgICAgICB5ayAvPSB2YWw7XG4gICAgICAgIHprIC89IHZhbDtcbiAgICB9XG5cbiAgICBRWzBdWzBdID0geGk7XG4gICAgUVswXVsxXSA9IHhqO1xuICAgIFFbMF1bMl0gPSB4aztcbiAgICBRWzFdWzBdID0geWk7XG4gICAgUVsxXVsxXSA9IHlqO1xuICAgIFFbMV1bMl0gPSB5aztcbiAgICBRWzJdWzBdID0gemk7XG4gICAgUVsyXVsxXSA9IHpqO1xuICAgIFFbMl1bMl0gPSB6aztcblxuICAgIC8qIGF0IHRoaXMgcG9pbnQsIFEgaXMgdGhlIHJvdGF0aW9uIG1hdHJpeCBmcm9tIHRoZSAoaSxqLGspIHRvICh4LHkseikgYXhlcyAqL1xuXG4gICAgZGV0USA9IHRoaXMubmlmdGlfbWF0MzNfZGV0ZXJtKFEpO1xuICAgIGlmIChkZXRRID09PSAwLjApIHsgLyogc2hvdWxkbid0IGhhcHBlbiB1bmxlc3MgdXNlciBpcyBhIERVRklTICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qIEJ1aWxkIGFuZCB0ZXN0IGFsbCBwb3NzaWJsZSArMS8tMSBjb29yZGluYXRlIHBlcm11dGF0aW9uIG1hdHJpY2VzIFA7XG4gICAgIHRoZW4gZmluZCB0aGUgUCBzdWNoIHRoYXQgdGhlIHJvdGF0aW9uIG1hdHJpeCBNPVBRIGlzIGNsb3Nlc3QgdG8gdGhlXG4gICAgIGlkZW50aXR5LCBpbiB0aGUgc2Vuc2Ugb2YgTSBoYXZpbmcgdGhlIHNtYWxsZXN0IHRvdGFsIHJvdGF0aW9uIGFuZ2xlLiAqL1xuXG4gICAgLyogRGVzcGl0ZSB0aGUgZm9ybWlkYWJsZSBsb29raW5nIDYgbmVzdGVkIGxvb3BzLCB0aGVyZSBhcmVcbiAgICAgb25seSAzKjMqMyoyKjIqMiA9IDIxNiBwYXNzZXMsIHdoaWNoIHdpbGwgcnVuIHZlcnkgcXVpY2tseS4gKi9cblxuICAgIHZiZXN0ID0gLTY2Ni4wO1xuICAgIGliZXN0ID0gcGJlc3QgPSBxYmVzdCA9IHJiZXN0ID0gMTtcbiAgICBqYmVzdCA9IDI7XG4gICAga2Jlc3QgPSAzO1xuXG4gICAgZm9yIChpID0gMTsgaSA8PSAzOyBpICs9IDEpIHsgICAgIC8qIGkgPSBjb2x1bW4gbnVtYmVyIHRvIHVzZSBmb3Igcm93ICMxICovXG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gMzsgaiArPSAxKSB7ICAgIC8qIGogPSBjb2x1bW4gbnVtYmVyIHRvIHVzZSBmb3Igcm93ICMyICovXG4gICAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGsgPD0gMzsgayArPSAxKSB7ICAvKiBrID0gY29sdW1uIG51bWJlciB0byB1c2UgZm9yIHJvdyAjMyAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpID09PSBrIHx8IGogPT09IGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBQWzBdWzBdID0gUFswXVsxXSA9IFBbMF1bMl0gPSBQWzFdWzBdID0gUFsxXVsxXSA9IFBbMV1bMl0gPSBQWzJdWzBdID0gUFsyXVsxXSA9IFBbMl1bMl0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgPSAtMTsgcCA8PSAxOyBwICs9IDIpIHsgICAgLyogcCxxLHIgYXJlIC0xIG9yICsxICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSAtMTsgcSA8PSAxOyBxICs9IDIpIHsgICAvKiBhbmQgZ28gaW50byByb3dzICMxLDIsMyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHIgPSAtMTsgciA8PSAxOyByICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBbMF1baSAtIDFdID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBbMV1baiAtIDFdID0gcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBbMl1bayAtIDFdID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldFAgPSB0aGlzLm5pZnRpX21hdDMzX2RldGVybShQKTsgICAgICAgICAgIC8qIHNpZ24gb2YgcGVybXV0YXRpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGV0UCAqIGRldFEpID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTSA9IHRoaXMubmlmdGlfbWF0MzNfbXVsKFAsIFEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogYW5nbGUgb2YgTSByb3RhdGlvbiA9IDIuMCphY29zKDAuNSpzcXJ0KDEuMCt0cmFjZShNKSkpICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogd2Ugd2FudCBsYXJnZXN0IHRyYWNlKE0pID09IHNtYWxsZXN0IGFuZ2xlID09IE0gbmVhcmVzdCB0byBJICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBNWzBdWzBdICsgTVsxXVsxXSArIE1bMl1bMl07IC8qIHRyYWNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IHZiZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZiZXN0ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYmVzdCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpiZXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2Jlc3QgPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYmVzdCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFiZXN0ID0gcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJlc3QgPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gIC8qIGRvZXNuJ3QgbWF0Y2ggc2lnbiBvZiBRICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBBdCB0aGlzIHBvaW50IGliZXN0IGlzIDEgb3IgMiBvciAzOyBwYmVzdCBpcyAtMSBvciArMTsgZXRjLlxuXG4gICAgIFRoZSBtYXRyaXggUCB0aGF0IGNvcnJlc3BvbmRzIGlzIHRoZSBiZXN0IHBlcm11dGF0aW9uIGFwcHJveGltYXRpb25cbiAgICAgdG8gUS1pbnZlcnNlOyB0aGF0IGlzLCBQIChhcHByb3hpbWF0ZWx5KSB0YWtlcyAoeCx5LHopIGNvb3JkaW5hdGVzXG4gICAgIHRvIHRoZSAoaSxqLGspIGF4ZXMuXG5cbiAgICAgRm9yIGV4YW1wbGUsIHRoZSBmaXJzdCByb3cgb2YgUCAod2hpY2ggY29udGFpbnMgcGJlc3QgaW4gY29sdW1uIGliZXN0KVxuICAgICBkZXRlcm1pbmVzIHRoZSB3YXkgdGhlIGkgYXhpcyBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIGFuYXRvbWljYWxcbiAgICAgKHgseSx6KSBheGVzLiAgSWYgaWJlc3QgaXMgMiwgdGhlbiB0aGUgaSBheGlzIGlzIGFsb25nIHRoZSB5IGF4aXMsXG4gICAgIHdoaWNoIGlzIGRpcmVjdGlvbiBQMkEgKGlmIHBiZXN0ID4gMCkgb3IgQTJQIChpZiBwYmVzdCA8IDApLlxuXG4gICAgIFNvLCB1c2luZyBpYmVzdCBhbmQgcGJlc3QsIHdlIGNhbiBhc3NpZ24gdGhlIG91dHB1dCBjb2RlIGZvclxuICAgICB0aGUgaSBheGlzLiAgTXV0YXRpcyBtdXRhbmRpcyBmb3IgdGhlIGogYW5kIGsgYXhlcywgb2YgY291cnNlLiAqL1xuXG4gICAgaUNoYXIgPSBqQ2hhciA9IGtDaGFyID0gaVNlbnNlID0galNlbnNlID0ga1NlbnNlID0gMDtcblxuICAgIHN3aXRjaCAoaWJlc3QgKiBwYmVzdCkge1xuICAgICAgICBjYXNlIDE6IC8qaSA9IE5JRlRJX0wyUiovXG4gICAgICAgICAgICBpQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGlTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0xOiAvKmkgPSBOSUZUSV9SMkwqL1xuICAgICAgICAgICAgaUNoYXIgPSAnWCc7XG4gICAgICAgICAgICBpU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAvKmkgPSBOSUZUSV9QMkEqL1xuICAgICAgICAgICAgaUNoYXIgPSAnWSc7XG4gICAgICAgICAgICBpU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMjogLyppID0gTklGVElfQTJQKi9cbiAgICAgICAgICAgIGlDaGFyID0gJ1knO1xuICAgICAgICAgICAgaVNlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLyppID0gTklGVElfSTJTKi9cbiAgICAgICAgICAgIGlDaGFyID0gJ1onO1xuICAgICAgICAgICAgaVNlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTM6IC8qaSA9IE5JRlRJX1MySSovXG4gICAgICAgICAgICBpQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGlTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN3aXRjaCAoamJlc3QgKiBxYmVzdCkge1xuICAgICAgICBjYXNlIDE6IC8qaiA9IE5JRlRJX0wyUiovXG4gICAgICAgICAgICBqQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGpTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0xOiAvKmogPSBOSUZUSV9SMkwqL1xuICAgICAgICAgICAgakNoYXIgPSAnWCc7XG4gICAgICAgICAgICBqU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAvKmogPSBOSUZUSV9QMkEqL1xuICAgICAgICAgICAgakNoYXIgPSAnWSc7XG4gICAgICAgICAgICBqU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMjogLypqID0gTklGVElfQTJQKi9cbiAgICAgICAgICAgIGpDaGFyID0gJ1knO1xuICAgICAgICAgICAgalNlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLypqID0gTklGVElfSTJTKi9cbiAgICAgICAgICAgIGpDaGFyID0gJ1onO1xuICAgICAgICAgICAgalNlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTM6IC8qaiA9IE5JRlRJX1MySSovXG4gICAgICAgICAgICBqQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGpTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN3aXRjaCAoa2Jlc3QgKiByYmVzdCkge1xuICAgICAgICBjYXNlIDE6IC8qayA9IE5JRlRJX0wyUiovXG4gICAgICAgICAgICBrQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGtTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0xOiAvKmsgPSBOSUZUSV9SMkwqL1xuICAgICAgICAgICAga0NoYXIgPSAnWCc7XG4gICAgICAgICAgICBrU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAvKmsgPSBOSUZUSV9QMkEqL1xuICAgICAgICAgICAga0NoYXIgPSAnWSc7XG4gICAgICAgICAgICBrU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMjogLyprID0gTklGVElfQTJQKi9cbiAgICAgICAgICAgIGtDaGFyID0gJ1knO1xuICAgICAgICAgICAga1NlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLyprID0gTklGVElfSTJTKi9cbiAgICAgICAgICAgIGtDaGFyID0gJ1onO1xuICAgICAgICAgICAga1NlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTM6IC8qayA9IE5JRlRJX1MySSovXG4gICAgICAgICAgICBrQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGtTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAoaUNoYXIgKyBqQ2hhciArIGtDaGFyICsgaVNlbnNlICsgalNlbnNlICsga1NlbnNlKTtcbn07XG5cblxuXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLm5pZnRpX21hdDMzX211bCA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gICAgdmFyIEMgPSBbWzAsIDAsIDBdLCBbMCwgMCwgMF0sIFswLCAwLCAwXV0sXG4gICAgICAgIGksXG4gICAgICAgIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAzOyBqICs9IDEpIHtcbiAgICAgICAgICAgIENbaV1bal0gPSAgQVtpXVswXSAqIEJbMF1bal0gICsgQVtpXVsxXSAqIEJbMV1bal0gKyBBW2ldWzJdICogQlsyXVtqXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDO1xufTtcblxuXG5cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUubmlmdGlfbWF0MzNfZGV0ZXJtID0gZnVuY3Rpb24gKFIpIHtcbiAgICB2YXIgcjExLCByMTIsIHIxMywgcjIxLCByMjIsIHIyMywgcjMxLCByMzIsIHIzMztcbiAgICAvKiAgSU5QVVQgTUFUUklYOiAgKi9cbiAgICByMTEgPSBSWzBdWzBdO1xuICAgIHIxMiA9IFJbMF1bMV07XG4gICAgcjEzID0gUlswXVsyXTtcbiAgICByMjEgPSBSWzFdWzBdO1xuICAgIHIyMiA9IFJbMV1bMV07XG4gICAgcjIzID0gUlsxXVsyXTtcbiAgICByMzEgPSBSWzJdWzBdO1xuICAgIHIzMiA9IFJbMl1bMV07XG4gICAgcjMzID0gUlsyXVsyXTtcblxuICAgIHJldHVybiAocjExICogcjIyICogcjMzIC0gcjExICogcjMyICogcjIzIC0gcjIxICogcjEyICogcjMzICsgcjIxICogcjMyICogcjEzICsgcjMxICogcjEyICogcjIzIC0gcjMxICogcjIyICogcjEzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBieXRlIGluZGV4IG9mIHRoZSBleHRlbnNpb24uXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldEV4dGVuc2lvbkxvY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5pZnRpLk5JRlRJMS5NQUdJQ19DT09LSUUgKyA0O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBzaXplLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRFeHRlbnNpb25TaXplID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBuaWZ0aS5VdGlscy5nZXRJbnRBdChkYXRhLCB0aGlzLmdldEV4dGVuc2lvbkxvY2F0aW9uKCksIHRoaXMubGl0dGxlRW5kaWFuKTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBjb2RlLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRFeHRlbnNpb25Db2RlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBuaWZ0aS5VdGlscy5nZXRJbnRBdChkYXRhLCB0aGlzLmdldEV4dGVuc2lvbkxvY2F0aW9uKCkgKyA0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG59O1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5pZnRpLk5JRlRJMTtcbn1cbiIsIlxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG5cbnZhciBuaWZ0aSA9IG5pZnRpIHx8IHt9O1xubmlmdGkuVXRpbHMgPSBuaWZ0aS5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxpdGllcy5qcycpIDogbnVsbCk7XG5uaWZ0aS5OSUZUSTEgPSBuaWZ0aS5OSUZUSTEgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9uaWZ0aTEuanMnKSA6IG51bGwpO1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuXG4vKipcbiAqIFRoZSBOSUZUSTIgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGltX2luZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGRpbXMgLSBpbWFnZSBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AxXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhdHlwZUNvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1CaXRzUGVyVm94ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9zdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2VuZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHBpeERpbXMgLSB2b3hlbCBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gdm94X29mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjbF9zbG9wZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjbF9pbnRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHh5enRfdW5pdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYWxfbWF4XG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FsX21pblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2R1cmF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9mZnNldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXV4X2ZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnRlbnRfbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHFmb3JtX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZm9ybV9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9iXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9jXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9kXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl94XG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl95XG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl96XG4gKiBAcHJvcGVydHkge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGFmZmluZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1hZ2ljXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBleHRlbnNpb25GbGFnXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbm5pZnRpLk5JRlRJMiA9IG5pZnRpLk5JRlRJMiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saXR0bGVFbmRpYW4gPSBmYWxzZTtcbiAgICB0aGlzLmRpbV9pbmZvID0gMDtcbiAgICB0aGlzLmRpbXMgPSBbXTtcbiAgICB0aGlzLmludGVudF9wMSA9IDA7XG4gICAgdGhpcy5pbnRlbnRfcDIgPSAwO1xuICAgIHRoaXMuaW50ZW50X3AzID0gMDtcbiAgICB0aGlzLmludGVudF9jb2RlID0gMDtcbiAgICB0aGlzLmRhdGF0eXBlQ29kZSA9IDA7XG4gICAgdGhpcy5udW1CaXRzUGVyVm94ZWwgPSAwO1xuICAgIHRoaXMuc2xpY2Vfc3RhcnQgPSAwO1xuICAgIHRoaXMuc2xpY2VfZW5kID0gMDtcbiAgICB0aGlzLnNsaWNlX2NvZGUgPSAwO1xuICAgIHRoaXMucGl4RGltcyA9IFtdO1xuICAgIHRoaXMudm94X29mZnNldCA9IDA7XG4gICAgdGhpcy5zY2xfc2xvcGUgPSAxO1xuICAgIHRoaXMuc2NsX2ludGVyID0gMDtcbiAgICB0aGlzLnh5enRfdW5pdHMgPSAwO1xuICAgIHRoaXMuY2FsX21heCA9IDA7XG4gICAgdGhpcy5jYWxfbWluID0gMDtcbiAgICB0aGlzLnNsaWNlX2R1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvZmZzZXQgPSAwO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIlwiO1xuICAgIHRoaXMuYXV4X2ZpbGUgPSBcIlwiO1xuICAgIHRoaXMuaW50ZW50X25hbWUgPSBcIlwiO1xuICAgIHRoaXMucWZvcm1fY29kZSA9IDA7XG4gICAgdGhpcy5zZm9ybV9jb2RlID0gMDtcbiAgICB0aGlzLnF1YXRlcm5fYiA9IDA7XG4gICAgdGhpcy5xdWF0ZXJuX2MgPSAwO1xuICAgIHRoaXMucXVhdGVybl9kID0gMDtcbiAgICB0aGlzLnFvZmZzZXRfeCA9IDA7XG4gICAgdGhpcy5xb2Zmc2V0X3kgPSAwO1xuICAgIHRoaXMucW9mZnNldF96ID0gMDtcbiAgICB0aGlzLmFmZmluZSA9IFtbMSwgMCwgMCwgMF0sIFswLCAxLCAwLCAwXSwgWzAsIDAsIDEsIDBdLCBbMCwgMCwgMCwgMV1dO1xuICAgIHRoaXMubWFnaWMgPSAwO1xuICAgIHRoaXMuZXh0ZW5zaW9uRmxhZyA9IFswLCAwLCAwLCAwXTtcbn07XG5cblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxubmlmdGkuTklGVEkyLk1BR0lDX0NPT0tJRSA9IDU0MDtcbm5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJfTE9DQVRJT04gPSA0O1xubmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUiA9IFsweDZFLCAweDJCLCAweDMyLCAwLCAweDBELCAweDBBLCAweDFBLCAweDBBXTsgIC8vIG4rMlxcMFxuXG5cblxuLyoqKiBQcm90b3R5cGUgTWV0aG9kcyAqKiovXG5cbi8qKlxuICogUmVhZHMgdGhlIGhlYWRlciBkYXRhLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLnJlYWRIZWFkZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciByYXdEYXRhID0gbmV3IERhdGFWaWV3KGRhdGEpLFxuICAgICAgICBtYWdpY0Nvb2tpZVZhbCA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDAsIHRoaXMubGl0dGxlRW5kaWFuKSxcbiAgICAgICAgY3RyLFxuICAgICAgICBjdHJPdXQsXG4gICAgICAgIGN0ckluLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgYXJyYXk7XG5cbiAgICBpZiAobWFnaWNDb29raWVWYWwgIT09IG5pZnRpLk5JRlRJMi5NQUdJQ19DT09LSUUpIHsgIC8vIHRyeSBhcyBsaXR0bGUgZW5kaWFuXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgICAgICAgbWFnaWNDb29raWVWYWwgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKG1hZ2ljQ29va2llVmFsICE9PSBuaWZ0aS5OSUZUSTIuTUFHSUNfQ09PS0lFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgTklGVEkgZmlsZSFcIik7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhdHlwZUNvZGUgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDEyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5udW1CaXRzUGVyVm94ZWwgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDE0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGluZGV4ID0gMTYgKyAoY3RyICogOCk7XG4gICAgICAgIHRoaXMuZGltc1tjdHJdID0gbmlmdGkuVXRpbHMuZ2V0TG9uZ0F0KHJhd0RhdGEsIGluZGV4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlbnRfcDEgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCA4MCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X3AyID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgODgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmludGVudF9wMyA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDk2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGluZGV4ID0gMTA0ICsgKGN0ciAqIDgpO1xuICAgICAgICB0aGlzLnBpeERpbXNbY3RyXSA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIGluZGV4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgdGhpcy52b3hfb2Zmc2V0ID0gbmlmdGkuVXRpbHMuZ2V0TG9uZ0F0KHJhd0RhdGEsIDE2OCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zY2xfc2xvcGUgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAxNzYsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnNjbF9pbnRlciA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDE4NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5jYWxfbWF4ID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMTkyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5jYWxfbWluID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMjAwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNsaWNlX2R1cmF0aW9uID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMjA4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnRvZmZzZXQgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAyMTYsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2xpY2Vfc3RhcnQgPSBuaWZ0aS5VdGlscy5nZXRMb25nQXQocmF3RGF0YSwgMjI0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zbGljZV9lbmQgPSBuaWZ0aS5VdGlscy5nZXRMb25nQXQocmF3RGF0YSwgMjMyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMjQwLCAyNDAgKyA4MCk7XG4gICAgdGhpcy5hdXhfZmlsZSA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDMyMCwgMzIwICsgMjQpO1xuXG4gICAgdGhpcy5xZm9ybV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgMzQ0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zZm9ybV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgMzQ4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnF1YXRlcm5fYiA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDM1MiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucXVhdGVybl9jID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMzYwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xdWF0ZXJuX2QgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAzNjgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnFvZmZzZXRfeCA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDM3NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucW9mZnNldF95ID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMzg0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xb2Zmc2V0X3ogPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAzOTIsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIGZvciAoY3RyT3V0ID0gMDsgY3RyT3V0IDwgMzsgY3RyT3V0ICs9IDEpIHtcbiAgICAgICAgZm9yIChjdHJJbiA9IDA7IGN0ckluIDwgNDsgY3RySW4gKz0gMSkge1xuICAgICAgICAgICAgaW5kZXggPSA0MDAgKyAoKChjdHJPdXQgKiA0KSArIGN0ckluKSAqIDgpO1xuICAgICAgICAgICAgdGhpcy5hZmZpbmVbY3RyT3V0XVtjdHJJbl0gPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZmZpbmVbM11bMF0gPSAwO1xuICAgIHRoaXMuYWZmaW5lWzNdWzFdID0gMDtcbiAgICB0aGlzLmFmZmluZVszXVsyXSA9IDA7XG4gICAgdGhpcy5hZmZpbmVbM11bM10gPSAxO1xuXG4gICAgdGhpcy5zbGljZV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgNDk2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy54eXp0X3VuaXRzID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgNTAwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5pbnRlbnRfY29kZSA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDUwNCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X25hbWUgPSBuaWZ0aS5VdGlscy5nZXRTdHJpbmdBdChyYXdEYXRhLCA1MDgsIDUwOCArIDE2KTtcblxuICAgIHRoaXMuZGltX2luZm8gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgNTI0KTtcblxuICAgIGlmIChyYXdEYXRhLmJ5dGVMZW5ndGggPiBuaWZ0aS5OSUZUSTIuTUFHSUNfQ09PS0lFKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1swXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCA1NDApO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMV0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgNTQwICsgMSk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1syXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCA1NDAgKyAyKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzNdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDU0MCArIDMpO1xuXG4gICAgICAgIGlmICh0aGlzLmV4dGVuc2lvbkZsYWdbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uU2l6ZSA9IHRoaXMuZ2V0RXh0ZW5zaW9uU2l6ZShyYXdEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uQ29kZSA9IHRoaXMuZ2V0RXh0ZW5zaW9uQ29kZShyYXdEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIG9mIGhlYWRlciBmaWVsZHMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLnRvRm9ybWF0dGVkU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbXQgPSBuaWZ0aS5VdGlscy5mb3JtYXROdW1iZXIsXG4gICAgICAgIHN0cmluZyA9IFwiXCI7XG5cbiAgICBzdHJpbmcgKz0gKFwiRGF0YXR5cGUgPSBcIiArICArIHRoaXMuZGF0YXR5cGVDb2RlICsgXCIgKFwiICsgdGhpcy5nZXREYXRhdHlwZUNvZGVTdHJpbmcodGhpcy5kYXRhdHlwZUNvZGUpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJCaXRzIFBlciBWb3hlbCA9IFwiICsgXCIgPSBcIiArIHRoaXMubnVtQml0c1BlclZveGVsICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkltYWdlIERpbWVuc2lvbnNcIiArIFwiICgxLTgpOiBcIiArXG4gICAgICAgIHRoaXMuZGltc1swXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1sxXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1syXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1szXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s0XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s1XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s2XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s3XSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkludGVudCBQYXJhbWV0ZXJzICgxLTMpOiBcIiArXG4gICAgICAgIHRoaXMuaW50ZW50X3AxICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5pbnRlbnRfcDIgKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmludGVudF9wMykgKyBcIlxcblwiO1xuXG4gICAgc3RyaW5nICs9IChcIlZveGVsIERpbWVuc2lvbnMgKDEtOCk6IFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1swXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzFdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1szXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzRdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbNV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s2XSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzddKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkltYWdlIE9mZnNldCA9IFwiICsgdGhpcy52b3hfb2Zmc2V0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRhdGEgU2NhbGU6ICBTbG9wZSA9IFwiICsgZm10KHRoaXMuc2NsX3Nsb3BlKSArIFwiICBJbnRlcmNlcHQgPSBcIiArIGZtdCh0aGlzLnNjbF9pbnRlcikgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGlzcGxheSBSYW5nZTogIE1heCA9IFwiICsgZm10KHRoaXMuY2FsX21heCkgKyBcIiAgTWluID0gXCIgKyBmbXQodGhpcy5jYWxfbWluKSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBEdXJhdGlvbiA9IFwiICsgdGhpcy5zbGljZV9kdXJhdGlvbiArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJUaW1lIEF4aXMgU2hpZnQgPSBcIiArIHRoaXMudG9mZnNldCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBTdGFydCA9IFwiICsgdGhpcy5zbGljZV9zdGFydCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBFbmQgPSBcIiArIHRoaXMuc2xpY2VfZW5kICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRlc2NyaXB0aW9uOiBcXFwiXCIgKyB0aGlzLmRlc2NyaXB0aW9uICsgXCJcXFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJBdXhpbGlhcnkgRmlsZTogXFxcIlwiICsgdGhpcy5hdXhfZmlsZSArIFwiXFxcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiUS1Gb3JtIENvZGUgPSBcIiArIHRoaXMucWZvcm1fY29kZSArIFwiIChcIiArIHRoaXMuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyh0aGlzLnFmb3JtX2NvZGUpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gQ29kZSA9IFwiICsgdGhpcy5zZm9ybV9jb2RlICsgXCIgKFwiICsgdGhpcy5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nKHRoaXMuc2Zvcm1fY29kZSkgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlF1YXRlcm5pb24gUGFyYW1ldGVyczogIFwiICtcbiAgICBcImIgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fYikgKyBcIiAgXCIgK1xuICAgIFwiYyA9IFwiICsgZm10KHRoaXMucXVhdGVybl9jKSArIFwiICBcIiArXG4gICAgXCJkID0gXCIgKyBmbXQodGhpcy5xdWF0ZXJuX2QpICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUXVhdGVybmlvbiBPZmZzZXRzOiAgXCIgK1xuICAgIFwieCA9IFwiICsgdGhpcy5xb2Zmc2V0X3ggKyBcIiAgXCIgK1xuICAgIFwieSA9IFwiICsgdGhpcy5xb2Zmc2V0X3kgKyBcIiAgXCIgK1xuICAgIFwieiA9IFwiICsgdGhpcy5xb2Zmc2V0X3ogKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gUGFyYW1ldGVycyBYOiBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzBdWzBdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzBdWzFdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzBdWzJdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzBdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFk6IFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMV1bMF0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMV1bMV0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMV1bMl0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMV1bM10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIFBhcmFtZXRlcnMgWjogXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsyXVswXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsyXVsxXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsyXVsyXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsyXVszXSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTbGljZSBDb2RlID0gXCIgKyB0aGlzLnNsaWNlX2NvZGUgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiVW5pdHMgQ29kZSA9IFwiICsgdGhpcy54eXp0X3VuaXRzICsgXCIgKFwiICsgdGhpcy5nZXRVbml0c0NvZGVTdHJpbmcobmlmdGkuTklGVEkxLlNQQVRJQUxfVU5JVFNfTUFTSyAmIHRoaXMueHl6dF91bml0cykgKyBcIiwgXCIgKyB0aGlzLmdldFVuaXRzQ29kZVN0cmluZyhuaWZ0aS5OSUZUSTEuVEVNUE9SQUxfVU5JVFNfTUFTSyAmIHRoaXMueHl6dF91bml0cykgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkludGVudCBDb2RlID0gXCIgKyB0aGlzLmludGVudF9jb2RlICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkludGVudCBOYW1lOiBcXFwiXCIgKyB0aGlzLmludGVudF9uYW1lICsgXCJcXFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkRpbSBJbmZvID0gXCIgKyB0aGlzLmRpbV9pbmZvICsgXCJcXG5cIik7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgYnl0ZSBpbmRleCBvZiB0aGUgZXh0ZW5zaW9uLlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRFeHRlbnNpb25Mb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuaWZ0aS5OSUZUSTIuTUFHSUNfQ09PS0lFICsgNDtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBzaXplLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRFeHRlbnNpb25TaXplID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRFeHRlbnNpb25TaXplO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gY29kZS5cbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uQ29kZSA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uQ29kZTtcblxuXG5cbi8qKlxuICogUmV0dXJucyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBvZiBkYXRhdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldERhdGF0eXBlQ29kZVN0cmluZyA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RGF0YXR5cGVDb2RlU3RyaW5nO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIHRyYW5zZm9ybSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZztcblxuXG5cbi8qKlxuICogUmV0dXJucyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBvZiBzcGF0aWFsIGFuZCB0ZW1wb3JhbCB1bml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldFVuaXRzQ29kZVN0cmluZyA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0VW5pdHNDb2RlU3RyaW5nO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBxZm9ybSBtYXRyaXguXG4gKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn1cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRRZm9ybU1hdCA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0UWZvcm1NYXQ7XG5cblxuXG4vKipcbiAqIENvbnZlcnRzIHFmb3JtIHRvIGFuIGFmZmluZS4gIChTZWUgaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxX2lvLmMpXG4gKiBAcGFyYW0ge251bWJlcn0gcWJcbiAqIEBwYXJhbSB7bnVtYmVyfSBxY1xuICogQHBhcmFtIHtudW1iZXJ9IHFkXG4gKiBAcGFyYW0ge251bWJlcn0gcXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBxeVxuICogQHBhcmFtIHtudW1iZXJ9IHF6XG4gKiBAcGFyYW0ge251bWJlcn0gZHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICogQHBhcmFtIHtudW1iZXJ9IGR6XG4gKiBAcGFyYW0ge251bWJlcn0gcWZhY1xuICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuY29udmVydE5pZnRpUUZvcm1Ub05pZnRpU0Zvcm0gPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmNvbnZlcnROaWZ0aVFGb3JtVG9OaWZ0aVNGb3JtO1xuXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBzZm9ybSB0byBhbiBvcmllbnRhdGlvbiBzdHJpbmcgKGUuZy4sIFhZWistLSkuICAoU2VlIGh0dHA6Ly9uaWZ0aS5uaW1oLm5paC5nb3YvcHViL2Rpc3Qvc3JjL25pZnRpbGliL25pZnRpMV9pby5jKVxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBSXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmNvbnZlcnROaWZ0aVNGb3JtVG9ORU1BID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5jb252ZXJ0TmlmdGlTRm9ybVRvTkVNQTtcblxuXG5cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUubmlmdGlfbWF0MzNfbXVsID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5uaWZ0aV9tYXQzM19tdWw7XG5cblxuXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLm5pZnRpX21hdDMzX2RldGVybSA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUubmlmdGlfbWF0MzNfZGV0ZXJtO1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5pZnRpLk5JRlRJMjtcbn1cbiIsIlxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xuXG52YXIgbmlmdGkgPSBuaWZ0aSB8fCB7fTtcbm5pZnRpLlV0aWxzID0gbmlmdGkuVXRpbHMgfHwge307XG5cblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxubmlmdGkuVXRpbHMuY3JjVGFibGUgPSBudWxsO1xubmlmdGkuVXRpbHMuR1VOWklQX01BR0lDX0NPT0tJRTEgPSAzMTtcbm5pZnRpLlV0aWxzLkdVTlpJUF9NQUdJQ19DT09LSUUyID0gMTM5O1xuXG5cblxuLyoqKiBTdGF0aWMgbWV0aG9kcyAqKiovXG5cbm5pZnRpLlV0aWxzLmdldFN0cmluZ0F0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc3RyID0gXCJcIiwgY3RyLCBjaDtcblxuICAgIGZvciAoY3RyID0gc3RhcnQ7IGN0ciA8IGVuZDsgY3RyICs9IDEpIHtcbiAgICAgICAgY2ggPSBkYXRhLmdldFVpbnQ4KGN0cik7XG5cbiAgICAgICAgaWYgKGNoICE9PSAwKSB7XG4gICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldEJ5dGVBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCkge1xuICAgIHJldHVybiBkYXRhLmdldEludDgoc3RhcnQpO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldFNob3J0QXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiBkYXRhLmdldEludDE2KHN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldEludEF0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZGF0YS5nZXRJbnQzMihzdGFydCwgbGl0dGxlRW5kaWFuKTtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5nZXRGbG9hdEF0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZGF0YS5nZXRGbG9hdDMyKHN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldERvdWJsZUF0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZGF0YS5nZXRGbG9hdDY0KHN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldExvbmdBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgdmFyIGN0ciwgYXJyYXkgPSBbXSwgdmFsdWUgPSAwO1xuXG4gICAgZm9yIChjdHIgPSAwOyBjdHIgPCA4OyBjdHIgKz0gMSkge1xuICAgICAgICBhcnJheVtjdHJdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KGRhdGEsIHN0YXJ0ICsgY3RyLCBsaXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIGZvciAoY3RyID0gYXJyYXkubGVuZ3RoIC0gMTsgY3RyID49IDA7IGN0ci0tKSB7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlICogMjU2KSArIGFycmF5W2N0cl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgdmFyIGFiLCB2aWV3LCBpO1xuXG4gICAgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XG4gICAgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgfVxuICAgIHJldHVybiBhYjtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5pc1N0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nKTtcbn07XG5cblxubmlmdGkuVXRpbHMuZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24gKG51bSwgc2hvcnRGb3JtYXQpIHtcbiAgICB2YXIgdmFsID0gMDtcblxuICAgIGlmIChuaWZ0aS5VdGlscy5pc1N0cmluZyhudW0pKSB7XG4gICAgICAgIHZhbCA9IE51bWJlcihudW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG51bTtcbiAgICB9XG5cbiAgICBpZiAoc2hvcnRGb3JtYXQpIHtcbiAgICAgICAgdmFsID0gdmFsLnRvUHJlY2lzaW9uKDUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHZhbC50b1ByZWNpc2lvbig3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xufTtcblxuXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg2Mzg5MDAvamF2YXNjcmlwdC1jcmMzMlxubmlmdGkuVXRpbHMubWFrZUNSQ1RhYmxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYztcbiAgICB2YXIgY3JjVGFibGUgPSBbXTtcbiAgICBmb3IodmFyIG4gPTA7IG4gPCAyNTY7IG4rKyl7XG4gICAgICAgIGMgPSBuO1xuICAgICAgICBmb3IodmFyIGsgPTA7IGsgPCA4OyBrKyspe1xuICAgICAgICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JjVGFibGVbbl0gPSBjO1xuICAgIH1cbiAgICByZXR1cm4gY3JjVGFibGU7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuY3JjMzIgPSBmdW5jdGlvbihkYXRhVmlldykge1xuICAgIHZhciBjcmNUYWJsZSA9IG5pZnRpLlV0aWxzLmNyY1RhYmxlIHx8IChuaWZ0aS5VdGlscy5jcmNUYWJsZSA9IG5pZnRpLlV0aWxzLm1ha2VDUkNUYWJsZSgpKTtcbiAgICB2YXIgY3JjID0gMCBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFWaWV3LmJ5dGVMZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiBjcmNUYWJsZVsoY3JjIF4gZGF0YVZpZXcuZ2V0VWludDgoaSkpICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKSA+Pj4gMDtcbn07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbmlmdGkuVXRpbHM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxudmFyIGxpbmVTZXBhcmF0b3JSRSA9IC9bIFxcZlxcdFxcdl0qXFxyP1xcbi87XG52YXIgTlJSRE1hZ2ljUkUgPSAvXk5SUkRcXGR7NH0kLztcbnZhciBsaW5lUkUgPSAvXihbXjpdKikoOlsgPV0pKC4qKSQvO1xudmFyIGRhdGFGaWxlTGlzdFJFID0gL15MSVNUKD86IChcXGQrKSk/JC87XG5cbi8vIFRoZSBtaW5pbWFsIG9iamVjdCB0aGlzIGFjY2VwdHMgaXMgZm9ybWVkIGxpa2UgdGhpczpcbi8vICAge2RhdGE6IFNvbWVUeXBlZEFycmF5LCBzaXplczogWy4uLl19XG4vLyBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgZGF0YSBpcyBub3QgZ2l2ZW4gaXQgbXVzdCBoYXZlIGEgZm9ybSBsaWtlIHRoaXM6XG4vLyAgIHtidWZmZXI6IFNvbWVBcnJheUJ1ZmZlciwgdHlwZTogLi4uLCBlbmRpYW46IC4uLiwgc2l6ZXM6IFsuLi5dfVxuLy8gT2YgY291cnNlLCBpZiAndHlwZScgaXMgYW4gOC1iaXQgdHlwZSwgZW5kaWFuIGlzIG5vdCBuZWVkZWQsIGFuZCBpZiAndHlwZScgZXF1YWxzICdibG9jaycsICdibG9ja1NpemUnIHNob3VsZCBiZSBzZXQgaW5zdGVhZCBvZiAnZW5kaWFuJy4gSW4gdGhpcyBjYXNlLCBubyBpbnRlcnByZXRhdGlvbiBvZiBidWZmZXIgaXMgZG9uZSAoYXQgYWxsLCBpdCBpcyB3cml0dGVuIHNlcmlhbGl6ZWQgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlcikuXG4vLyBUT0RPOiBGb3Igbm93IHRoaXMgb25seSBzdXBwb3J0cyBzZXJpYWxpemluZyBcImlubGluZVwiIGZpbGVzLCBvciBmaWxlcyBmb3Igd2hpY2ggeW91IGhhdmUgYWxyZWFkeSBwcmVwYXJlZCB0aGUgZGF0YS5cbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChucnJkT3JnKSB7XG4gICAgdmFyIGksIGJ1ZmZlciwgYXJyLCB0b3RhbExlbiA9IDEsIG5ycmQgPSB7fSwgcHJvcCwgbmF0aXZlVHlwZSwgbmF0aXZlU2l6ZSwgYnVmZmVyRGF0YSwgYXJyRGF0YSwgbGluZSwgbGluZXMgPSBbXSwgaGVhZGVyO1xuICAgIFxuICAgIC8vIENvcHkgbnJyZE9yZyB0byBucnJkIHRvIGFsbG93IG1vZGlmaWNhdGlvbnMgd2l0aG91dCBhbHRlcmluZyB0aGUgb3JpZ2luYWxcbiAgICBmb3IocHJvcCBpbiBucnJkT3JnKSB7XG4gICAgICAgIG5ycmRbcHJvcF0gPSBucnJkT3JnW3Byb3BdO1xuICAgIH1cbiAgICBcbiAgICAvLyBGb3Igc2F2aW5nIGZpbGVzIHdlIGFsbG93IGluZmVycmluZyBjZXJ0YWluIGluZm9ybWF0aW9uIGlmIGl0IGlzIG5vdCBleHBsaWNpdGx5IGdpdmVuLlxuICAgIC8vIEFsc28gd2Ugbm9ybWFsaXplIHNvbWUgZmllbGRzIHRvIG1ha2Ugb3VyIG93biBsaXZlcyBlYXNpZXIuXG4gICAgaWYgKG5ycmQuc2l6ZXM9PT11bmRlZmluZWQpIHsgLy8gJ3NpemVzJyBzaG91bGQgQUxXQVlTIGJlIGdpdmVuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpemVzIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kaW1lbnNpb249PT11bmRlZmluZWQpIHtcbiAgICAgICAgbnJyZC5kaW1lbnNpb24gPSBucnJkLnNpemVzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJpbnQ4XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcInVpbnQ4XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcImludDE2XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJ1aW50MTZcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwiaW50MzJcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcInVpbnQzMlwiO1xuICAgIC8vfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBJbnQ2NEFycmF5KSB7XG4gICAgLy8gICAgbmF0aXZlVHlwZSA9IFwiaW50NjRcIjtcbiAgICAvL30gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgVWludDY0QXJyYXkpIHtcbiAgICAvLyAgICBuYXRpdmVUeXBlID0gXCJ1aW50NjRcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJmbG9hdFwiO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcImRvdWJsZVwiO1xuICAgIH1cbiAgICBpZiAobnJyZC50eXBlPT09dW5kZWZpbmVkICYmIG5hdGl2ZVR5cGUhPT11bmRlZmluZWQpIHtcbiAgICAgICAgbnJyZC50eXBlID0gbmF0aXZlVHlwZTtcbiAgICB9IGVsc2UgaWYgKG5ycmQudHlwZT09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG9mIGRhdGEgaXMgbm90IGdpdmVuIGFuZCBjYW5ub3QgYmUgaW5mZXJyZWQhXCIpO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBucnJkLnR5cGUpID09IFwic3RyaW5nXCIgfHwgbnJyZC50eXBlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIG5ycmQudHlwZSA9IHBhcnNlTlJSRFR5cGUobnJyZC50eXBlKTtcbiAgICB9XG4gICAgaWYgKG5ycmQuZW5jb2Rpbmc9PT11bmRlZmluZWQpIHtcbiAgICAgICAgbnJyZC5lbmNvZGluZyA9IFwicmF3XCI7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIG5ycmQuZW5jb2RpbmcpID09IFwic3RyaW5nXCIgfHwgbnJyZC5lbmNvZGluZyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICBucnJkLmVuY29kaW5nID0gcGFyc2VOUlJERW5jb2RpbmcobnJyZC5lbmNvZGluZyk7XG4gICAgfVxuICAgIGlmIChucnJkLmRhdGEgJiYgbnJyZC50eXBlICE9ICdibG9jaycgJiYgbnJyZC50eXBlICE9ICdpbnQ4JyAmJiBucnJkLnR5cGUgIT0gJ3VpbnQ4JyAmJiBucnJkLmVuY29kaW5nICE9ICdhc2NpaScpIHtcbiAgICAgICAgbnJyZC5lbmRpYW4gPSBzeXN0ZW1FbmRpYW5uZXNzO1xuICAgIH0gZWxzZSBpZiAobnJyZC50eXBlID09ICdibG9jaycgfHwgbnJyZC50eXBlID09ICdpbnQ4JyB8fCBucnJkLnR5cGUgPT0gJ3VpbnQ4JyB8fCBucnJkLmVuY29kaW5nID09ICdhc2NpaScpIHtcbiAgICAgICAgbnJyZC5lbmRpYW4gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIG5ycmQuZW5kaWFuKSA9PSBcInN0cmluZ1wiIHx8IG5ycmQuZW5kaWFuIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIG5ycmQuZW5kaWFuID0gcGFyc2VOUlJERW5kaWFuKG5ycmQuZW5kaWFuKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGluZmVyIHNwYXRpYWwgZGltZW5zaW9uXG4gICAgdmFyIHNwYWNlRGltZW5zaW9uID0gdW5kZWZpbmVkO1xuICAgIGlmIChucnJkLnNwYWNlRGltZW5zaW9uIT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHNwYWNlRGltZW5zaW9uID0gbnJyZC5zcGFjZURpbWVuc2lvbjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuc3BhY2UhPT11bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoKG5ycmQuc3BhY2UpIHtcbiAgICAgICAgY2FzZSBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgICAgIGNhc2UgXCJSQVNcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdC1hbnRlcmlvci1zdXBlcmlvclwiOlxuICAgICAgICBjYXNlIFwiTEFTXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgICAgIGNhc2UgXCJMUFNcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICBcdCAgY2FzZSBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yLXRpbWVcIjpcbiAgICAgXHQgIGNhc2UgXCJSQVNUXCI6XG4gICAgIFx0ICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICBcdCAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdC1hbnRlcmlvci1zdXBlcmlvci10aW1lXCI6XG4gICAgICAgIGNhc2UgXCJMQVNUXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yLXRpbWVcIjpcbiAgICAgICAgY2FzZSBcIkxQU1RcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2Nhbm5lci14eXpcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2Nhbm5lci14eXotdGltZVwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIzRC1yaWdodC1oYW5kZWRcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiM0QtbGVmdC1oYW5kZWRcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiM0QtcmlnaHQtaGFuZGVkLXRpbWVcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiM0QtbGVmdC1oYW5kZWQtdGltZVwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgc3BhY2U6IFwiICsgbnJyZC5zcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTm93IGNoZWNrIHRoYXQgd2UgaGF2ZSBhIHZhbGlkIG5ycmQgc3RydWN0dXJlLlxuICAgIGNoZWNrTlJSRChucnJkKTtcblxuICAgIC8vIERldGVybWluZSBudW1iZXIgb2YgZWxlbWVudHMgYW5kIGNoZWNrIHRoYXQgd2UgaGF2ZSBlbm91Z2ggZGF0YSAoaWYgcG9zc2libGUpXG4gICAgZm9yKGk9MDsgaTxucnJkLnNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChucnJkLnNpemVzW2ldPD0wKSB0aHJvdyBuZXcgRXJyb3IoXCJTaXplcyBzaG91bGQgYmUgYSBsaXN0IG9mIHBvc2l0aXZlICg+MCkgaW50ZWdlcnMhXCIpO1xuICAgICAgICB0b3RhbExlbiAqPSBucnJkLnNpemVzW2ldO1xuICAgIH1cbiAgICBpZiAobnJyZC5kYXRhKSB7XG4gICAgICAgIGlmIChucnJkLmRhdGEubGVuZ3RoIDwgdG90YWxMZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGF0YSB0byBzZXJpYWxpemUhXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChucnJkLmJ1ZmZlcikge1xuICAgICAgICBpZiAobnJyZC5lbmNvZGluZyA9PSBcInJhd1wiKSB7XG4gICAgICAgICAgICBpZiAobnJyZC50eXBlPT1cImJsb2NrXCIgJiYgbnJyZC5ibG9ja1NpemUhPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVTaXplID0gbnJyZC5ibG9ja1NpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdGl2ZVNpemUgPSBnZXROUlJEVHlwZVNpemUobnJyZC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChucnJkLmJ1ZmZlci5ieXRlTGVuZ3RoIDwgdG90YWxMZW4qbmF0aXZlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGF0YSB0byBzZXJpYWxpemUhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGFGaWxlKSB7XG4gICAgICAgIC8vIE9rYXksIGlmIHlvdSBoYXZlIHlvdXIgZGF0YSByZWFkeSwgd2UnbGwganVzdCB3cml0ZSBhIGhlYWRlci5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWxsIG5vdCBzZXJpYWxpemUgYW4gZW1wdHkgTlJSRCBmaWxlIVwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgdGhlIGNvcnJlY3QgYnVmZmVyIGluIGJ1ZmZlckRhdGEuXG4gICAgaWYgKG5ycmQuZGF0YSkge1xuICAgICAgICBzd2l0Y2gobnJyZC5lbmNvZGluZykge1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgaWYgKG5ycmQudHlwZSA9PSBuYXRpdmVUeXBlICYmIG5ycmQuZW5kaWFuID09IHN5c3RlbUVuZGlhbm5lc3MpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gbnJyZC5kYXRhLmJ1ZmZlci5zbGljZShucnJkLmRhdGEuYnl0ZU9mZnNldCwgbnJyZC5kYXRhLmJ5dGVPZmZzZXQrbnJyZC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChucnJkLmVuZGlhbiA9PSBzeXN0ZW1FbmRpYW5uZXNzKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IGNhc3RUeXBlZEFycmF5KG5ycmQuZGF0YSwgbnJyZC50eXBlKTtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gYnVmZmVyRGF0YS5idWZmZXIuc2xpY2UoYnVmZmVyRGF0YS5ieXRlT2Zmc2V0LCBidWZmZXJEYXRhLmJ5dGVPZmZzZXQrYnVmZmVyRGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IHNlcmlhbGl6ZVRvQnVmZmVyKG5ycmQuZGF0YSwgbnJyZC50eXBlLCBucnJkLmVuZGlhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICAgICAgaWYgKG5ycmQudHlwZSA9PSBuYXRpdmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IHNlcmlhbGl6ZVRvVGV4dEJ1ZmZlcihucnJkLmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gc2VyaWFsaXplVG9UZXh0QnVmZmVyKGNhc3RUeXBlZEFycmF5KG5ycmQuZGF0YSwgbnJyZC50eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIE5SUkQgZW5jb2Rpbmc6IFwiICsgbnJyZC5lbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5ycmQuYnVmZmVyKSB7XG4gICAgICAgIGJ1ZmZlckRhdGEgPSBucnJkLmJ1ZmZlcjtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RhcnQgaGVhZGVyXG4gICAgbGluZXMucHVzaChcIk5SUkQwMDA1XCIpOyAvLyBUT0RPOiBBZGp1c3QgdmVyc2lvbiBiYXNlZCBvbiBmZWF0dXJlcyB0aGF0IGFyZSBhY3R1YWxseSB1c2VkIGFuZC9vciB0aGUgdmVyc2lvbiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgKGlmIGFueSkuXG4gICAgbGluZXMucHVzaChcIiMgR2VuZXJhdGVkIGJ5IG5ycmQtanNcIik7XG4gICAgXG4gICAgLy8gUHV0IGluIGRpbWVuc2lvbiBhbmQgc3BhY2UgZGltZW5zaW9uICh0aGUgTlJSRCBzcGVjIHJlcXVpcmVzIHRoYXQgdGhlc2UgYXJlIHByZXNlbnQgYmVmb3JlIGFueSBsaXN0cyB3aG9zZSBsZW5ndGggZGVwZW5kcyBvbiB0aGVtKVxuICAgIHZhciBmaXJzdFByb3BzID0gWydkaW1lbnNpb24nLCAnc3BhY2VEaW1lbnNpb24nLCAnc3BhY2UnXTtcbiAgICBmb3IoaT0wOyBpPGZpcnN0UHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IGZpcnN0UHJvcHNbaV07XG4gICAgICAgIGlmIChucnJkW3Byb3BdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAvLyBTa2lwIHRoaW5ncyB3ZSBleHBsaWNpdGx5IHNldCB0byB1bmRlZmluZWQuXG4gICAgICAgIGxpbmUgPSBzZXJpYWxpemVGaWVsZChwcm9wLCBucnJkW3Byb3BdLCBucnJkLmRpbWVuc2lvbiwgc3BhY2VEaW1lbnNpb24pO1xuICAgICAgICBpZiAobGluZSE9PXVuZGVmaW5lZCkgbGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUHV0IGluIGZpZWxkIHNwZWNpZmljYXRpb25zXG4gICAgZm9yKHByb3AgaW4gbnJyZCkge1xuICAgICAgICBpZiAobnJyZFtwcm9wXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gU2tpcCB0aGluZ3Mgd2UgZXhwbGljaXRseSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgICAgICBpZiAoZmlyc3RQcm9wcy5pbmRleE9mKHByb3ApPj0wKSBjb250aW51ZTsgLy8gU2tpcCB0aGUgZmllbGRzIHdlIGFscmVhZHkgb3V0cHV0LlxuICAgICAgICBsaW5lID0gc2VyaWFsaXplRmllbGQocHJvcCwgbnJyZFtwcm9wXSwgbnJyZC5kaW1lbnNpb24sIHNwYWNlRGltZW5zaW9uKTtcbiAgICAgICAgaWYgKGxpbmUhPT11bmRlZmluZWQpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFB1dCBpbiBrZXlzIChpZiBhbnkpXG4gICAgaWYgKG5ycmQua2V5cykgZm9yKHByb3AgaW4gbnJyZC5rZXlzKSB7XG4gICAgICAgIGlmIChwcm9wLmluZGV4T2YoXCI6PVwiKT49MCkgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbWJpbmF0aW9uICc6PScgaXMgbm90IGFsbG93ZWQgaW4gYW4gTlJSRCBrZXkhXCIpO1xuICAgICAgICBsaW5lcy5wdXNoKHByb3AgKyBcIjo9XCIgKyBlc2NhcGVWYWx1ZShucnJkW3Byb3BdKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFB1dCBpbiBkYXRhIGZpbGUgbGlzdCAoaWYgYW55KVxuICAgIGlmIChucnJkLmRhdGFGaWxlICYmIG5ycmQuZGF0YUZpbGUubGVuZ3RoKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCJkYXRhIGZpbGU6IExJU1RcIik7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpbmVzLCBucnJkLmRhdGFGaWxlKTtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YUZpbGUgJiYgbnJyZC5kYXRhRmlsZS5maWxlcyAmJiAnc3ViZGltJyBpbiBucnJkLmRhdGFGaWxlKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCJkYXRhIGZpbGU6IExJU1QgXCIgKyBucnJkLmRhdGFGaWxlLnN1YmRpbSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpbmVzLCBucnJkLmRhdGFGaWxlLmZpbGVzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUHV0IGluIGVtcHR5IGxpbmUgYW5kIGlubGluZSBkYXRhIChpZiB3ZSBoYXZlIGlubGluZSBkYXRhKSBhbmQgY29udmVydCBsaW5lcyB0byBidWZmZXJcbiAgICBpZiAoYnVmZmVyRGF0YSAmJiAhKCdkYXRhRmlsZScgaW4gbnJyZCkpIHtcbiAgICAgICAgbGluZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGluZXMucHVzaChcIlwiKTsgLy8gV2UgYWN0dWFsbHkgbmVlZCBhbiBleHRyYSBibGFuayBsaW5lIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgaXMgdGVybWluYXRlZC5cbiAgICAgICAgaGVhZGVyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGhlYWRlci5sZW5ndGggKyBidWZmZXJEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBhcnIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBmb3IoaT0wOyBpPGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyRGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckRhdGEpO1xuICAgICAgICBhcnIuc2V0KGFyckRhdGEsIGhlYWRlci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCJcIik7IC8vIEJsYW5rIGxpbmUgdG8gYXQgbGVhc3QgdGVybWluYXRlIHRoZSBsYXN0IGxpbmUuXG4gICAgICAgIGhlYWRlciA9IGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihoZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgZm9yKGk9MDsgaTxoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBUaGlzIGV4cGVjdHMgYW4gQXJyYXlCdWZmZXIuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICB2YXIgaSwgaGVhZGVyLCBkYXRhU3RhcnQsIHJldCA9IHtkYXRhOiB1bmRlZmluZWQvKiBwYXJzZWQgZGF0YSAqLywgYnVmZmVyOiB1bmRlZmluZWQvKiByYXcgYnVmZmVyIGhvbGRpbmcgZGF0YSAqLywga2V5czoge30sIHZlcnNpb246IHVuZGVmaW5lZH0sXG4gICAgICAgIGxpbmVzLCBtYXRjaCwgbWF0Y2gyLFxuICAgICAgICBidWY4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuICAgIC8vIEEgd29yay1hcm91bmQgZm9yIGluY29tcGF0aWJpbGl0aWVzIGJldHdlZW4gTm9kZSdzIEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIuXG4gICAgaWYgKGJ1ZjguYnVmZmVyICE9PSBidWZmZXIpIGJ1ZmZlciA9IGJ1ZjguYnVmZmVyO1xuXG4gICAgLy8gRmlyc3QgZmluZCB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIHRoZSBoZWFkZXIgYW5kIHRoZSBkYXRhIChpZiB0aGVyZSBpcyBvbmUpXG4gICAgLy8gTm90ZSB0aGF0IHdlIG5lZWQgdG8gZGVhbCB3aXRoIHdpdGggTEYgYW5kIENSTEYgYXMgcG9zc2libGUgbGluZSBlbmRpbmdzLlxuICAgIC8vIEx1Y2tpbHkgdGhpcyBtZWFucyB0aGUgbGluZSBhbHdheXMgZW5kcyB3aXRoIExGLCBzbyB3ZSBvbmx5IG5lZWQgdG8gY29uc2lkZXJcbiAgICAvLyBMRkxGIGFuZCBMRkNSTEYgYXMgcGF0dGVybnMgZm9yIHRoZSBzZXBhcmF0aW5nIGVtcHR5IGxpbmUuXG4gICAgaT0yOyAvLyBJdCBpcyBzYWZlIHRvIHN0YXJ0IGF0IHBvc2l0aW9uIDIgKGluIGZhY3QsIHdlIGNvdWxkIHN0YXJ0IGV2ZW4gbGF0ZXIpLCBhcyB0aGUgZmlsZSBIQVMgdG8gc3RhcnQgd2l0aCBhIG1hZ2ljIHdvcmQuXG4gICAgd2hpbGUoaTxidWY4Lmxlbmd0aCkge1xuICAgICAgICBpZiAoYnVmOFtpXSA9PSAxMCkgeyAvLyBXZSBoaXQgYW4gTEZcbiAgICAgICAgICAgIGlmIChidWY4W2ktMV0gPT0gMTAgfHwgKGJ1ZjhbaS0xXSA9PSAxMyAmJiBidWY4W2ktMl0gPT0gMTApKSB7IC8vIFNhZmUgYmVjYXVzZSB3ZSBzdGFydCBhdCBwb3NpdGlvbiAyIGFuZCBuZXZlciBtb3ZlIGJhY2t3YXJkc1xuICAgICAgICAgICAgICAgIGRhdGFTdGFydCA9IGkrMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrOyAvLyBNb3ZlIGZvcndhcmQganVzdCBvbmNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmOFtpXSA9PSAxMykgeyAvLyBXZSBoaXQgYSBDUlxuICAgICAgICAgICAgaSsrOyAvLyBNb3ZlIGZvcndhcmQganVzdCBvbmNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpICs9IDI7IC8vIE1vdmUgZm9yd2FyZCB0d28gcGxhY2VzLCBcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBOb3cgc3BsaXQgdXAgdGhlIGhlYWRlciBhbmQgZGF0YVxuICAgIGlmIChkYXRhU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWFkZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1ZjgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmOC5zdWJhcnJheSgwLGRhdGFTdGFydCkpO1xuICAgICAgICByZXQuYnVmZmVyID0gYnVmZmVyLnNsaWNlKGRhdGFTdGFydCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNwbGl0IGhlYWRlciBpbnRvIGxpbmVzLCByZW1vdmUgY29tbWVudHMgKGFuZCBibGFuayBsaW5lcykgYW5kIGNoZWNrIG1hZ2ljLlxuICAgIC8vIEFsbCByZW1haW5pbmcgbGluZXMgZXhjZXB0IHRoZSBmaXJzdCBzaG91bGQgYmUgZmllbGQgc3BlY2lmaWNhdGlvbnMgb3Iga2V5L3ZhbHVlIHBhaXJzLlxuICAgIC8vIFRPRE86IFRoaXMgZXhwbGljaXRseSByZW1vdmVzIGFueSB3aGl0ZXNwYWNlIGF0IHRoZSBlbmQgb2YgbGluZXMsIGhvd2V2ZXIsIEkgYW0gbm90IHN1cmUgdGhhdCB0aGlzIGlzIGFjdHVhbGx5IGRlc2lyZWQgYmVoYXZpb3VyIGZvciBhbGwga2luZHMgb2YgbGluZXMuXG4gICAgbGluZXMgPSBoZWFkZXIuc3BsaXQobGluZVNlcGFyYXRvclJFKTtcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5sZW5ndGg+MCAmJiBsWzBdICE9ICcjJzsgfSk7IC8vIFJlbW92ZSBjb21tZW50IGxpbmVzXG4gICAgaWYgKCFOUlJETWFnaWNSRS50ZXN0KGxpbmVzWzBdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIGlzIG5vdCBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH1cbiAgICByZXQudmVyc2lvbiA9IHBhcnNlSW50KGxpbmVzWzBdLnN1YnN0cmluZyg0LCA4KSwgMTApO1xuICAgIGlmIChyZXQudmVyc2lvbj41KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlJlYWRpbmcgYW4gdW5zdXBwb3J0ZWQgdmVyc2lvbiBvZiB0aGUgTlJSRCBmb3JtYXQ7IHRoaW5ncyBtYXkgZ28gaGF5d2lyZS5cIik7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgbGluZXNcbiAgICBmb3IoaT0xOyBpPGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgbGluZSBpbiBOUlJEIGhlYWRlcjogXCIgKyBsaW5lc1tpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMl0gPT0gJzogJykgeyAvLyBGaWVsZCBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICBtYXRjaFsxXSA9IG1hcE5SUkRUb0phdmFzY3JpcHQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgaWYgKCBtYXRjaFsxXSA9PSAnZGF0YUZpbGUnICYmXG4gICAgICAgICAgICAgICAgIChtYXRjaDIgPSBkYXRhRmlsZUxpc3RSRS5leGVjKG1hdGNoWzNdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB0aGUgbGFzdCBmaWVsZCBzcGVjaWZpY2F0aW9uLFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgcmVzdCBvZiB0aGUgbGluZXMgc2hvdWxkIGNvbnRhaW4gZmlsZSBuYW1lcy5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gyLmxlbmd0aCA9PSAyICYmIG1hdGNoMlsxXSkgeyAvLyBzdWJkaW0gc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICByZXRbbWF0Y2hbMV1dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXM6IGxpbmVzLnNsaWNlKGkrMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJkaW06IHBhcnNlTlJSREludGVnZXIobWF0Y2gyWzFdKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFttYXRjaFsxXV0gPSBsaW5lcy5zbGljZShpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcy5sZW5ndGggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRbbWF0Y2hbMV1dID0gcGFyc2VGaWVsZChtYXRjaFsxXSwgbWF0Y2hbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzJdID09ICc6PScpIHsgLy8gS2V5L3ZhbHVlIHBhaXJcbiAgICAgICAgICAgIHJldC5rZXlzW21hdGNoWzFdXSA9IHVuZXNjYXBlVmFsdWUobWF0Y2hbM10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9naWMgZXJyb3IgaW4gTlJSRCBwYXJzZXIuXCIpOyAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gKHVubGVzcyB0aGUgTlJSRCBzeW50YXggaXMgZXh0ZW5kZWQgYW5kIHRoZSByZWdleHAgaXMgdXBkYXRlZCwgYnV0IHRoaXMgc2VjdGlvbiBpcyBub3QsIG9yIHNvbWUgb3RoZXIgcHJvZ3JhbW1lciBlcnJvcikuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgc2F0aXNmaWVzIHRoZSByZXF1aXJlbWVudHMgb2YgdGhlIE5SUkQgZm9ybWF0XG4gICAgY2hlY2tOUlJEKHJldCk7XG4gICAgXG4gICAgLy8gXCJQYXJzZVwiIGRhdGFcbiAgICBpZiAoJ2RhdGFGaWxlJyBpbiByZXQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gc3VwcG9ydCBmb3IgZXh0ZXJuYWwgZGF0YSB5ZXQhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChyZXQuZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgICAgIHJldC5kYXRhID0gcGFyc2VOUlJEUmF3RGF0YShyZXQuYnVmZmVyLCByZXQudHlwZSwgcmV0LnNpemVzLCB7XG4gICAgICAgICAgICAgICAgZW5kaWFuOiByZXQuZW5kaWFuLCBibG9ja1NpemU6IHJldC5ibG9ja1NpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgICAgIHJldC5kYXRhID0gcGFyc2VOUlJEVGV4dERhdGEocmV0LmJ1ZmZlciwgcmV0LnR5cGUsIHJldC5zaXplcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIE5SUkQgZW5jb2Rpbmc6IFwiICsgcmV0LmVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gZXNjYXBlVmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKCdcXFxcJywgJ1xcXFxcXFxcJykucmVwbGFjZSgnXFxuJywgJ1xcXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlVmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIHZhbC5zcGxpdCgnXFxcXFxcXFwnKS5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgnXFxcXG4nLCAnXFxuJyk7IH1cbiAgICAgICAgKS5qb2luKCdcXFxcJyk7XG59XG5cbi8vIFNlcmlhbGl6ZXMgTlJSRCBmaWVsZHNcbmZ1bmN0aW9uIHNlcmlhbGl6ZUZpZWxkKHByb3AsIHZhbHVlLCBkaW1lbnNpb24sIHNwYWNlRGltZW5zaW9uKSB7XG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIHByb3BOUlJEID0gbWFwSmF2YXNjcmlwdFRvTlJSRChwcm9wKTtcbiAgICBzd2l0Y2gocHJvcCkge1xuICAgIC8vIG5ycmQtanMgc3R1ZmY6IHNraXBcbiAgICBjYXNlICdkYXRhJzpcbiAgICBjYXNlICdidWZmZXInOlxuICAgIGNhc2UgJ2tleXMnOlxuICAgIGNhc2UgJ3ZlcnNpb24nOlxuICAgICAgICBicmVhaztcbiAgICAvLyBMaXRlcmFsICh1bmludGVycHJldGVkKSBmaWVsZHNcbiAgICBjYXNlICdjb250ZW50JzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3NhbXBsZVVuaXRzJzpcbiAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAvLyBJbnRlZ2VycyAobm8gaW5maW5pdHkgb3Igd2hhdGV2ZXIsIGp1c3QgYSBwbGFpbiBpbnRlZ2VyLCBzbyB0aGUgZGVmYXVsdCBzZXJpYWxpemF0aW9uIGlzIGdvb2QgZW5vdWdoKVxuICAgIGNhc2UgJ2Jsb2NrU2l6ZSc6XG4gICAgY2FzZSAnbGluZVNraXAnOlxuICAgIGNhc2UgJ2J5dGVTa2lwJzpcbiAgICBjYXNlICdkaW1lbnNpb24nOlxuICAgIGNhc2UgJ3NwYWNlRGltZW5zaW9uJzpcbiAgICAgICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUpID09IFwibnVtYmVyXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGF0IGxlYXN0IGNvbnRhaW4gYSBudW1iZXIhXCIpO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gRmxvYXRzIChkZWZhdWx0IHNlcmlhbGl6YXRpb24gaXMgZ29vZCBlbm91Z2gsIGFzIE5hTiBjb250YWlucyBuYW4sIGlnbm9yaW5nIGNhc2UsIGFuZCBzaW1pbGFybHkgZm9yIEluZmluaXR5IGluZilcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ21heCc6XG4gICAgY2FzZSAnb2xkTWluJzpcbiAgICBjYXNlICdvbGRNYXgnOlxuICAgICAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSkgPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgY29udGFpbiBhIG51bWJlciFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAvLyBWZWN0b3JzXG4gICAgY2FzZSAnc3BhY2VPcmlnaW4nOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoID09PSBzcGFjZURpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBzcGFjZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcIm51bWJlclwiIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlciwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IChcIiArIHZhbHVlLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIHN0cmluZ3NcbiAgICBjYXNlICdsYWJlbHMnOlxuICAgIGNhc2UgJ3VuaXRzJzpcbiAgICBjYXNlICdzcGFjZVVuaXRzJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7IGFzc2VydCgodHlwZW9mIHZhbCkgPT0gXCJzdHJpbmdcIiB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmcsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCBvZiBudW1iZXJzIVwiKTsgfSk7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLm1hcChzZXJpYWxpemVOUlJEUXVvdGVkU3RyaW5nKS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgaW50ZWdlcnNcbiAgICBjYXNlICdzaXplcyc6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPT0gZGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbCkgeyBhc3NlcnQoKHR5cGVvZiB2YWwpID09IFwibnVtYmVyXCIgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgb2YgbnVtYmVycyFcIik7IH0pO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgZmxvYXRzXG4gICAgY2FzZSAnc3BhY2luZ3MnOlxuICAgIGNhc2UgJ3RoaWNrbmVzc2VzJzpcbiAgICBjYXNlICdheGlzTWlucyc6XG4gICAgY2FzZSAnYXhpc01heHMnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09IGRpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcIm51bWJlclwiIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlciwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIHZlY3RvcnMgKGRpbWVuc2lvbiBzaXplZClcbiAgICBjYXNlICdzcGFjZURpcmVjdGlvbnMnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmVjKSB7XG4gICAgICAgICAgYXNzZXJ0KHZlYyA9PT0gbnVsbCB8fCAodmVjLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZlYy5sZW5ndGggPT09IHNwYWNlRGltZW5zaW9uKSwgXCJUaGUgZWxlbWVudHMgb2YgZmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGxpc3RzIHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBzcGFjZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICAgIGlmICh2ZWMgIT09IG51bGwpIHZlYy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcIm51bWJlclwiIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlciwgXCJUaGUgZWxlbWVudHMgb2YgZmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGxpc3RzIG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLm1hcChmdW5jdGlvbih2ZWMpIHsgcmV0dXJuIHZlYyA9PT0gbnVsbCA/IFwibm9uZVwiIDogKFwiKFwiICsgdmVjLmpvaW4oXCIsXCIpICsgXCIpXCIpOyB9KS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgdmVjdG9ycyAoc3BhY2UgZGltZW5zaW9uIHNpemVkKVxuICAgIGNhc2UgJ21lYXN1cmVtZW50RnJhbWUnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09PSBzcGFjZURpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBzcGFjZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2ZWMpIHtcbiAgICAgICAgICBhc3NlcnQodmVjID09PSBudWxsIHx8ICh2ZWMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmVjLmxlbmd0aCA9PT0gc3BhY2VEaW1lbnNpb24pLCBcIlRoZSBlbGVtZW50cyBvZiBmaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgbGlzdHMgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIHNwYWNlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgICAgaWYgKHZlYyAhPT0gbnVsbCkgdmVjLmZvckVhY2goZnVuY3Rpb24gKHZhbCkgeyBhc3NlcnQoKHR5cGVvZiB2YWwpID09IFwibnVtYmVyXCIgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyLCBcIlRoZSBlbGVtZW50cyBvZiBmaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgbGlzdHMgb2YgbnVtYmVycyFcIik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUubWFwKGZ1bmN0aW9uKHZlYykgeyByZXR1cm4gdmVjID09PSBudWxsID8gXCJub25lXCIgOiAoXCIoXCIgKyB2ZWMuam9pbihcIixcIikgKyBcIilcIik7IH0pLmpvaW4oXCIgXCIpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBPbmUtb2YtYS1raW5kIGZpZWxkc1xuICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSkgPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZywgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgY29udGFpbiBhIHN0cmluZyFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdlbmNvZGluZyc6XG4gICAgICAgIGFzc2VydCgodHlwZW9mIHZhbHVlKSA9PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBjb250YWluIGEgc3RyaW5nIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZGlhbic6XG4gICAgICAgIGFzc2VydCgodHlwZW9mIHZhbHVlKSA9PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBjb250YWluIGEgc3RyaW5nIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RhdGFGaWxlJzpcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCB8fCAodmFsdWUuZmlsZXMgJiYgJ3N1YmRpbScgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIGRhdGEgZmlsZXM6IHNraXAgZm9yIG5vd1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgc2VyaWFsaXplTlJSRERhdGFGaWxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXJzJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUubWFwKHNlcmlhbGl6ZU5SUkRPcHRpb25hbCkuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2tpbmRzJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUubWFwKHNlcmlhbGl6ZU5SUkRPcHRpb25hbCkuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIFNvbWV0aGluZyB1bmtub3duXG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgZmllbGQ6IFwiICsgcHJvcCArIFwiLCBza2lwcGluZy5cIik7XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuXG4vLyBQYXJzZXMgYW5kIG5vcm1hbGl6ZXMgTlJSRCBmaWVsZHMsIGFzc3VtZXMgdGhlIGZpZWxkIG5hbWVzIGFyZSBhbHJlYWR5IGxvd2VyIGNhc2UuXG5mdW5jdGlvbiBwYXJzZUZpZWxkKGlkZW50aWZpZXIsIGRlc2NyaXB0b3IpIHtcbiAgICBzd2l0Y2goaWRlbnRpZmllcikge1xuICAgIC8vIExpdGVyYWwgKHVuaW50ZXJwcmV0ZWQpIGZpZWxkc1xuICAgIGNhc2UgJ2NvbnRlbnQnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc2FtcGxlVW5pdHMnOlxuICAgICAgICBicmVhaztcbiAgICAvLyBJbnRlZ2Vyc1xuICAgIGNhc2UgJ2RpbWVuc2lvbic6XG4gICAgY2FzZSAnYmxvY2tTaXplJzpcbiAgICBjYXNlICdsaW5lU2tpcCc6XG4gICAgY2FzZSAnYnl0ZVNraXAnOlxuICAgIGNhc2UgJ3NwYWNlRGltZW5zaW9uJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSREludGVnZXIoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIEZsb2F0c1xuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbWF4JzpcbiAgICBjYXNlICdvbGRNaW4nOlxuICAgIGNhc2UgJ29sZE1heCc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRGbG9hdChkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gVmVjdG9yc1xuICAgIGNhc2UgJ3NwYWNlT3JpZ2luJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFZlY3RvcihkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2Ygc3RyaW5nc1xuICAgIGNhc2UgJ2xhYmVscyc6XG4gICAgY2FzZSAndW5pdHMnOlxuICAgIGNhc2UgJ3NwYWNlVW5pdHMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJEUXVvdGVkU3RyaW5nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgaW50ZWdlcnNcbiAgICBjYXNlICdzaXplcyc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRXaGl0ZXNwYWNlU2VwYXJhdGVkTGlzdChkZXNjcmlwdG9yLCBwYXJzZU5SUkRJbnRlZ2VyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgZmxvYXRzXG4gICAgY2FzZSAnc3BhY2luZ3MnOlxuICAgIGNhc2UgJ3RoaWNrbmVzc2VzJzpcbiAgICBjYXNlICdheGlzTWlucyc6XG4gICAgY2FzZSAnYXhpc01heHMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJERmxvYXQpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiB2ZWN0b3JzXG4gICAgY2FzZSAnc3BhY2VEaXJlY3Rpb25zJzpcbiAgICBjYXNlICdtZWFzdXJlbWVudEZyYW1lJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KGRlc2NyaXB0b3IsIHBhcnNlTlJSRFZlY3Rvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIE9uZS1vZi1hLWtpbmQgZmllbGRzXG4gICAgY2FzZSAndHlwZSc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRUeXBlKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdlbmNvZGluZyc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRFbmNvZGluZyhkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kaWFuJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSREVuZGlhbihkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGF0YUZpbGUnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJERGF0YUZpbGUoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlcnMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJEQ2VudGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAna2luZHMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJES2luZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFNwYWNlKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBTb21ldGhpbmcgdW5rbm93blxuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBOUlJEIGZpZWxkOiBcIiArIGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cblxuLy8gVGhpcyBvbmx5IGluY2x1ZGVzIG5hbWVzIHdob3NlIGxvd2VyIGNhc2UgZm9ybSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgSmF2YXNjcmlwdCBmb3JtLlxudmFyIG1hcE5SUkRUb0phdmFzY3JpcHRTdGF0aWMgPSB7XG4gICAgJ2Jsb2NrIHNpemUnOiAnYmxvY2tTaXplJyxcbiAgICAnYmxvY2tzaXplJzogJ2Jsb2NrU2l6ZScsXG4gICAgJ29sZCBtaW4nOiAnb2xkTWluJyxcbiAgICAnb2xkbWluJzogJ29sZE1pbicsXG4gICAgJ29sZCBtYXgnOiAnb2xkTWF4JyxcbiAgICAnb2xkbWF4JzogJ29sZE1heCcsXG4gICAgJ2RhdGEgZmlsZSc6ICdkYXRhRmlsZScsXG4gICAgJ2RhdGFmaWxlJzogJ2RhdGFGaWxlJyxcbiAgICAnbGluZSBza2lwJzogJ2xpbmVTa2lwJyxcbiAgICAnbGluZXNraXAnOiAnbGluZVNraXAnLFxuICAgICdieXRlIHNraXAnOiAnYnl0ZVNraXAnLFxuICAgICdieXRlc2tpcCc6ICdieXRlU2tpcCcsXG4gICAgJ3NhbXBsZSB1bml0cyc6ICdzYW1wbGVVbml0cycsXG4gICAgJ3NhbXBsZXVuaXRzJzogJ3NhbXBsZVVuaXRzJyxcbiAgICAnYXhpcyBtaW5zJzogJ2F4aXNNaW5zJyxcbiAgICAnYXhpcyBtYXhzJzogJ2F4aXNNYXhzJyxcbiAgICAnY2VudGVycyc6ICdjZW50ZXJzJywgLy8gTm90IGRpZmZlcmVudCwganVzdCBpbmNsdWRlZCBzbyBpdCBpcyBjbGVhciB3aHkgY2VudGVyaW5ncyBtYXBzIHRvIGNlbnRlcnNcbiAgICAnY2VudGVyaW5ncyc6ICdjZW50ZXJzJyxcbiAgICAnc3BhY2UgZGltZW5zaW9uJzogJ3NwYWNlRGltZW5zaW9uJyxcbiAgICAnc3BhY2UgdW5pdHMnOiAnc3BhY2VVbml0cycsXG4gICAgJ3NwYWNlIG9yaWdpbic6ICdzcGFjZU9yaWdpbicsXG4gICAgJ3NwYWNlIGRpcmVjdGlvbnMnOiAnc3BhY2VEaXJlY3Rpb25zJyxcbiAgICAnbWVhc3VyZW1lbnQgZnJhbWUnOiAnbWVhc3VyZW1lbnRGcmFtZSdcbn07XG52YXIgbWFwSmF2YXNjcmlwdFRvTlJSRFN0YXRpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWQsIG0gPSB7fTtcbiAgZm9yKGlkIGluIG1hcE5SUkRUb0phdmFzY3JpcHRTdGF0aWMpIHtcbiAgICBtW21hcE5SUkRUb0phdmFzY3JpcHRTdGF0aWNbaWRdXSA9IGlkO1xuICB9XG4gIHJldHVybiBtO1xufSgpO1xuZnVuY3Rpb24gbWFwTlJSRFRvSmF2YXNjcmlwdChpZCkge1xuICAgIC8vIEluIGFueSBjYXNlLCB1c2UgdGhlIGxvd2VyIGNhc2UgdmVyc2lvbiBvZiB0aGUgaWRcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgZmllbGRzIGZvciB3aGljaCB3ZSBoYXZlIGFuIGV4cGxpY2l0IEphdmFzY3JpcHQgbmFtZVxuICAgIGlmIChpZCBpbiBtYXBOUlJEVG9KYXZhc2NyaXB0U3RhdGljKSByZXR1cm4gbWFwTlJSRFRvSmF2YXNjcmlwdFN0YXRpY1tpZF07XG4gICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiB0aGUgKGxvd2VyIGNhc2UpIGlkXG4gICAgcmV0dXJuIGlkO1xufVxuZnVuY3Rpb24gbWFwSmF2YXNjcmlwdFRvTlJSRChpZCkge1xuICAgIC8vIEZpbHRlciBvdXQgYW55IGZpZWxkcyBmb3Igd2hpY2ggd2UgaGF2ZSBhbiBleHBsaWNpdCBOUlJEIG5hbWVcbiAgICBpZiAoaWQgaW4gbWFwSmF2YXNjcmlwdFRvTlJSRFN0YXRpYykgcmV0dXJuIG1hcEphdmFzY3JpcHRUb05SUkRTdGF0aWNbaWRdO1xuICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gdGhlIGlkXG4gICAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRJbnRlZ2VyKHN0cikge1xuICAgIHZhciB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbCkpIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBOUlJEIGludGVnZXI6IFwiICsgc3RyKTtcbiAgICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRGbG9hdChzdHIpIHtcbiAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoc3RyLmluZGV4T2YoJ25hbicpPj0wKSByZXR1cm4gTmFOO1xuICAgIGlmIChzdHIuaW5kZXhPZignLWluZicpPj0wKSByZXR1cm4gLUluZmluaXR5O1xuICAgIGlmIChzdHIuaW5kZXhPZignaW5mJyk+PTApIHJldHVybiBJbmZpbml0eTtcbiAgICB2YXIgdmFsID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odmFsKSkgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIE5SUkQgZmxvYXQ6IFwiICsgc3RyKTtcbiAgICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRWZWN0b3Ioc3RyKSB7XG4gICAgaWYgKHN0ciA9PSBcIm5vbmVcIikgcmV0dXJuIG51bGw7XG4gICAgaWYgKHN0ci5sZW5ndGg8MiB8fCBzdHJbMF0hPT1cIihcIiB8fCBzdHJbc3RyLmxlbmd0aC0xXSE9PVwiKVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgTlJSRCB2ZWN0b3I6IFwiICsgc3RyKTtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDEsIC0xKS5zcGxpdChcIixcIikubWFwKHBhcnNlTlJSREZsb2F0KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJEUXVvdGVkU3RyaW5nKHN0cikge1xuICAgIGlmIChsZW5ndGg8MiB8fCBzdHJbMF0hPSdcIicgfHwgc3RyW3N0ci5sZW5ndGgtMV0hPSdcIicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBOUlJEIHF1b3RlZCBzdHJpbmc6IFwiICsgc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zbGljZSgxLCAtMSkucmVwbGFjZSgnXFxcXFwiJywgJ1wiJyk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5SUkRRdW90ZWRTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZSgnXCInLCAnXFxcXFwiJykgKyAnXCInO1xufVxuXG52YXIgd2hpdGVzcGFjZUxpc3RTZXBhcmF0b3IgPSAvWyBcXHRdKy87IC8vIE5vdGUgdGhhdCB0aGlzIGV4Y2x1ZGVzIG90aGVyIHR5cGVzIG9mIHdoaXRlc3BhY2Ugb24gcHVycG9zZSFcbmZ1bmN0aW9uIHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KHN0ciwgcGFyc2VFbGVtZW50KSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCh3aGl0ZXNwYWNlTGlzdFNlcGFyYXRvcikubWFwKHBhcnNlRWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSRFR5cGUoZGVzY3JpcHRvcikge1xuICAgIHN3aXRjaChkZXNjcmlwdG9yLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwic2lnbmVkIGNoYXJcIjpcbiAgICBjYXNlIFwiaW50OFwiOlxuICAgIGNhc2UgXCJpbnQ4X3RcIjpcbiAgICAgICAgcmV0dXJuICdpbnQ4JztcbiAgICBjYXNlIFwidWNoYXJcIjpcbiAgICBjYXNlIFwidW5zaWduZWQgY2hhclwiOlxuICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgIGNhc2UgXCJ1aW50OF90XCI6XG4gICAgICAgIHJldHVybiAndWludDgnO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgIGNhc2UgXCJzaG9ydCBpbnRcIjpcbiAgICBjYXNlIFwic2lnbmVkIHNob3J0XCI6XG4gICAgY2FzZSBcInNpZ25lZCBzaG9ydCBpbnRcIjpcbiAgICBjYXNlIFwiaW50MTZcIjpcbiAgICBjYXNlIFwiaW50MTZfdFwiOlxuICAgICAgICByZXR1cm4gJ2ludDE2JztcbiAgICBjYXNlIFwidXNob3J0XCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIHNob3J0XCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIHNob3J0IGludFwiOlxuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICBjYXNlIFwidWludDE2X3RcIjpcbiAgICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgIGNhc2UgXCJpbnRcIjpcbiAgICBjYXNlIFwic2lnbmVkIGludFwiOlxuICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgIGNhc2UgXCJpbnQzMl90XCI6XG4gICAgICAgIHJldHVybiAnaW50MzInO1xuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIGludFwiOlxuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICBjYXNlIFwidWludDMyX3RcIjpcbiAgICAgICAgcmV0dXJuICd1aW50MzInO1xuICAgIGNhc2UgXCJsb25nbG9uZ1wiOlxuICAgIGNhc2UgXCJsb25nIGxvbmdcIjpcbiAgICBjYXNlIFwibG9uZyBsb25nIGludFwiOlxuICAgIGNhc2UgXCJzaWduZWQgbG9uZyBsb25nXCI6XG4gICAgY2FzZSBcInNpZ25lZCBsb25nIGxvbmcgaW50XCI6XG4gICAgY2FzZSBcImludDY0XCI6XG4gICAgY2FzZSBcImludDY0X3RcIjpcbiAgICAgICAgcmV0dXJuICdpbnQ2NCc7XG4gICAgY2FzZSBcInVsb25nbG9uZ1wiOlxuICAgIGNhc2UgXCJ1bnNpZ25lZCBsb25nIGxvbmdcIjpcbiAgICBjYXNlIFwidW5zaWduZWQgbG9uZyBsb25nIGludFwiOlxuICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICBjYXNlIFwidWludDY0X3RcIjpcbiAgICAgICAgcmV0dXJuICd1aW50NjQnO1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0JztcbiAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIHJldHVybiAnZG91YmxlJztcbiAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgcmV0dXJuICdibG9jayc7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgdHlwZTogXCIgKyBkZXNjcmlwdG9yKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIHN3aXRjaChlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcInJhd1wiOlxuICAgICAgICByZXR1cm4gXCJyYXdcIjtcbiAgICBjYXNlIFwidHh0XCI6XG4gICAgY2FzZSBcInRleHRcIjpcbiAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgcmV0dXJuIFwiYXNjaWlcIjtcbiAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgIHJldHVybiBcImhleFwiO1xuICAgIGNhc2UgXCJnelwiOlxuICAgIGNhc2UgXCJnemlwXCI6XG4gICAgICAgIHJldHVybiBcImd6aXBcIjtcbiAgICBjYXNlIFwiYnoyXCI6XG4gICAgY2FzZSBcImJ6aXAyXCI6XG4gICAgICAgIHJldHVybiBcImJ6aXAyXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgZW5jb2Rpbmc6IFwiICsgZW5jb2RpbmcpO1xuICAgICAgICByZXR1cm4gZW5jb2Rpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRTcGFjZShzcGFjZSkge1xuICAgIHN3aXRjaChzcGFjZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgY2FzZSBcInJhc1wiOlxuICAgICAgICByZXR1cm4gXCJyaWdodC1hbnRlcmlvci1zdXBlcmlvclwiO1xuICAgIGNhc2UgXCJsZWZ0LWFudGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgY2FzZSBcImxhc1wiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LWFudGVyaW9yLXN1cGVyaW9yXCI7XG4gICAgY2FzZSBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgY2FzZSBcImxwc1wiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LXBvc3Rlcmlvci1zdXBlcmlvclwiO1xuIFx0ICBjYXNlIFwicmlnaHQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiOlxuIFx0ICBjYXNlIFwicmFzdFwiOlxuICAgICAgICByZXR1cm4gXCJyaWdodC1hbnRlcmlvci1zdXBlcmlvci10aW1lXCI7XG4gICAgY2FzZSBcImxlZnQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiOlxuICAgIGNhc2UgXCJsYXN0XCI6XG4gICAgICAgIHJldHVybiBcImxlZnQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiO1xuICAgIGNhc2UgXCJsZWZ0LXBvc3Rlcmlvci1zdXBlcmlvci10aW1lXCI6XG4gICAgY2FzZSBcImxwc3RcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1wb3N0ZXJpb3Itc3VwZXJpb3ItdGltZVwiO1xuICAgIGNhc2UgXCJzY2FubmVyLXh5elwiOlxuICAgICAgICByZXR1cm4gXCJzY2FubmVyLXh5elwiO1xuICAgIGNhc2UgXCJzY2FubmVyLXh5ei10aW1lXCI6XG4gICAgICAgIHJldHVybiBcInNjYW5uZXIteHl6LXRpbWVcIjtcbiAgICBjYXNlIFwiM2QtcmlnaHQtaGFuZGVkXCI6XG4gICAgICAgIHJldHVybiBcIjNELXJpZ2h0LWhhbmRlZFwiO1xuICAgIGNhc2UgXCIzZC1sZWZ0LWhhbmRlZFwiOlxuICAgICAgICByZXR1cm4gXCIzRC1sZWZ0LWhhbmRlZFwiO1xuICAgIGNhc2UgXCIzZC1yaWdodC1oYW5kZWQtdGltZVwiOlxuICAgICAgICByZXR1cm4gXCIzRC1yaWdodC1oYW5kZWQtdGltZVwiO1xuICAgIGNhc2UgXCIzZC1sZWZ0LWhhbmRlZC10aW1lXCI6XG4gICAgICAgIHJldHVybiBcIjNELWxlZnQtaGFuZGVkLXRpbWVcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgc3BhY2U6IFwiICsgc3BhY2UpO1xuICAgICAgICByZXR1cm4gc3BhY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRFbmRpYW4oZW5kaWFuKSB7XG4gICAgc3dpdGNoKGVuZGlhbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnbGl0dGxlJzpcbiAgICAgICAgcmV0dXJuICdsaXR0bGUnO1xuICAgIGNhc2UgJ2JpZyc6XG4gICAgICAgIHJldHVybiAnYmlnJztcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCBlbmRpYW5uZXNzOiBcIiArIGVuZGlhbik7XG4gICAgICAgIHJldHVybiBlbmRpYW47XG4gICAgfVxufVxuXG4vLyBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIG5ldmVyIGVuY291bnRlciB0aGUgTElTVCBkYXRhIGZpbGUgc3BlY2lmaWNhdGlvbiBmb3JtYXQsIGFzIHRoaXMgaXMgaGFuZGxlZCBlbHNld2hlcmUuXG52YXIgZGF0YUZpbGVGb3JtYXRSRSA9IC8gKC0/XFxkKykgKC0/XFxkKykgKC0/XFxkKykoPzogKFxcZCspKT8kLztcbmZ1bmN0aW9uIHBhcnNlTlJSRERhdGFGaWxlKGRhdGFGaWxlKSB7XG4gICAgdmFyIG1hdGNoID0gZGF0YUZpbGVGb3JtYXRSRS5leGVjKGRhdGFGaWxlKTtcbiAgICBpZiAobWF0Y2gpIHsgLy8gV2UgaGF2ZSBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uXG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPT0gNSAmJiBtYXRjaFs0XSkgeyAvLyBzdWJkaW0gc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGRhdGFGaWxlLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCksXG4gICAgICAgICAgICAgICAgbWluOiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICBtYXg6IHBhcnNlTlJSREludGVnZXIobWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHBhcnNlTlJSREludGVnZXIobWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIHN1YmRpbTogcGFyc2VOUlJESW50ZWdlcihtYXRjaFs0XSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogZGF0YUZpbGUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgICAgICBtaW46IHBhcnNlTlJSREludGVnZXIobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgIG1heDogcGFyc2VOUlJESW50ZWdlcihtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgc3RlcDogcGFyc2VOUlJESW50ZWdlcihtYXRjaFszXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBKdXN0IGEgZmlsZVxuICAgICAgICByZXR1cm4gZGF0YUZpbGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVOUlJERGF0YUZpbGUoZGF0YUZpbGUpIHtcbiAgICBpZiAoKHR5cGVvZiBkYXRhRmlsZSkgPT0gXCJzdHJpbmdcIiB8fCBkYXRhRmlsZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gZGF0YUZpbGU7XG4gICAgfSBlbHNlIGlmICgnZm9ybWF0JyBpbiBkYXRhRmlsZSAmJiAnbWluJyBpbiBkYXRhRmlsZSAmJiAnbWF4JyBpbiBkYXRhRmlsZSAmJiAnc3RlcCcgaW4gZGF0YUZpbGUpIHtcbiAgICAgICAgaWYgKCdzdWJkaW0nIGluIGRhdGFGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUZpbGUuZm9ybWF0ICsgXCIgXCIgKyBkYXRhRmlsZS5taW4gKyBcIiBcIiArIGRhdGFGaWxlLm1heCArIFwiIFwiICsgZGF0YUZpbGUuc3RlcCArIFwiIFwiICsgZGF0YUZpbGUuc3ViZGltO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFGaWxlLmZvcm1hdCArIFwiIFwiICsgZGF0YUZpbGUubWluICsgXCIgXCIgKyBkYXRhRmlsZS5tYXggKyBcIiBcIiArIGRhdGFGaWxlLnN0ZXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZGF0YSBmaWxlIGZvcm1hdCFcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRDZW50ZXIoY2VudGVyKSB7XG4gICAgc3dpdGNoKGNlbnRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImNlbGxcIjpcbiAgICAgICAgcmV0dXJuIFwiY2VsbFwiO1xuICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICAgIHJldHVybiBcIm5vZGVcIjtcbiAgICBjYXNlIFwiPz8/XCI6XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgY2VudGVyOiBcIiArIGNlbnRlcik7XG4gICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgfVxufVxuXG52YXIgTlJSREtpbmRzID0ge1xuICAgIFwiZG9tYWluXCI6IFwiZG9tYWluXCIsXG4gICAgXCJzcGFjZVwiOiBcInNwYWNlXCIsXG4gICAgXCJ0aW1lXCI6IFwidGltZVwiLFxuICAgIFwibGlzdFwiOiBcImxpc3RcIixcbiAgICBcInBvaW50XCI6IFwicG9pbnRcIixcbiAgICBcInZlY3RvclwiOiBcInZlY3RvclwiLFxuICAgIFwiY292YXJpYW50LXZlY3RvclwiOiBcImNvdmFyaWFudC12ZWN0b3JcIixcbiAgICBcIm5vcm1hbFwiOiBcIm5vcm1hbFwiLFxuICAgIFwic3R1YlwiOiBcInN0dWJcIixcbiAgICBcInNjYWxhclwiOiBcInNjYWxhclwiLFxuICAgIFwiY29tcGxleFwiOiBcImNvbXBsZXhcIixcbiAgICBcIjItdmVjdG9yXCI6IFwiMi12ZWN0b3JcIixcbiAgICBcIjMtY29sb3JcIjogXCIzLWNvbG9yXCIsXG4gICAgXCJyZ2ItY29sb3JcIjogXCJSR0ItY29sb3JcIixcbiAgICBcImhzdi1jb2xvclwiOiBcIkhTVi1jb2xvclwiLFxuICAgIFwieHl6LWNvbG9yXCI6IFwiWFlaLWNvbG9yXCIsXG4gICAgXCI0LWNvbG9yXCI6IFwiNC1jb2xvclwiLFxuICAgIFwicmdiYS1jb2xvclwiOiBcIlJHQkEtY29sb3JcIixcbiAgICBcIjMtdmVjdG9yXCI6IFwiMy12ZWN0b3JcIixcbiAgICBcIjMtZ3JhZGllbnRcIjogXCIzLWdyYWRpZW50XCIsXG4gICAgXCIzLW5vcm1hbFwiOiBcIjMtbm9ybWFsXCIsXG4gICAgXCI0LXZlY3RvclwiOiBcIjQtdmVjdG9yXCIsXG4gICAgXCJxdWF0ZXJuaW9uXCI6IFwicXVhdGVybmlvblwiLFxuICAgIFwiMmQtc3ltbWV0cmljLW1hdHJpeFwiOiBcIjJELXN5bW1ldHJpYy1tYXRyaXhcIixcbiAgICBcIjJkLW1hc2tlZC1zeW1tZXRyaWMtbWF0cml4XCI6IFwiMkQtbWFza2VkLXN5bW1ldHJpYy1tYXRyaXhcIixcbiAgICBcIjJkLW1hdHJpeFwiOiBcIjJELW1hdHJpeFwiLFxuICAgIFwiMmQtbWFza2VkLW1hdHJpeFwiOiBcIjJELW1hc2tlZC1tYXRyaXhcIixcbiAgICBcIjNkLXN5bW1ldHJpYy1tYXRyaXhcIjogXCIzRC1zeW1tZXRyaWMtbWF0cml4XCIsXG4gICAgXCIzZC1tYXNrZWQtc3ltbWV0cmljLW1hdHJpeFwiOiBcIjNELW1hc2tlZC1zeW1tZXRyaWMtbWF0cml4XCIsXG4gICAgXCIzZC1tYXRyaXhcIjogXCIzRC1tYXRyaXhcIixcbiAgICBcIjNkLW1hc2tlZC1tYXRyaXhcIjogXCIzRC1tYXNrZWQtbWF0cml4XCIsXG4gICAgXCI/Pz9cIjogbnVsbCxcbiAgICBcIm5vbmVcIjogbnVsbFxufTtcbmZ1bmN0aW9uIHBhcnNlTlJSREtpbmQoa2luZCkge1xuICAgIHZhciBraW5kTEMgPSBraW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGtpbmRMQyBpbiBOUlJES2luZHMpIHJldHVybiBOUlJES2luZHNba2luZExDXTtcbiAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCBraW5kOiBcIiArIGtpbmQpO1xuICAgIHJldHVybiBraW5kO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVOUlJET3B0aW9uYWwoYSkge1xuICAgIHJldHVybiBhPT09bnVsbCA/IFwiPz8/XCIgOiBhO1xufVxuXG52YXIgc3lzdGVtRW5kaWFubmVzcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDQpLFxuICAgICAgICBpbnRBcnIgPSBuZXcgVWludDMyQXJyYXkoYnVmKSxcbiAgICAgICAgYnl0ZUFyciA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgaW50QXJyWzBdID0gMHgwMTAyMDMwNDtcbiAgICBpZiAoYnl0ZUFyclswXT09MSAmJiBieXRlQXJyWzFdPT0yICYmIGJ5dGVBcnJbMl09PTMgJiYgYnl0ZUFyclszXT09NCkge1xuICAgICAgICByZXR1cm4gJ2JpZyc7XG4gICAgfSBlbHNlIGlmIChieXRlQXJyWzBdPT00ICYmIGJ5dGVBcnJbMV09PTMgJiYgYnl0ZUFyclsyXT09MiAmJiBieXRlQXJyWzNdPT0xKSB7XG4gICAgICAgIHJldHVybiAnbGl0dGxlJztcbiAgICB9XG4gICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIHN5c3RlbSBlbmRpYW5uZXNzIVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufSkoKTtcblxuZnVuY3Rpb24gcGFyc2VOUlJEUmF3RGF0YShidWZmZXIsIHR5cGUsIHNpemVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGksIGFyciwgdmlldywgdG90YWxMZW4gPSAxLCBlbmRpYW5GbGFnO1xuICAgIGZvcihpPTA7IGk8c2l6ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNpemVzW2ldPD0wKSB0aHJvdyBuZXcgRXJyb3IoXCJTaXplcyBzaG91bGQgYmUgYSBsaXN0IG9mIHBvc2l0aXZlICg+MCkgaW50ZWdlcnMhXCIpO1xuICAgICAgICB0b3RhbExlbiAqPSBzaXplc1tpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ2Jsb2NrJykge1xuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBzcGVjaWFsLCBqdXN0IHJldHVybiB0aGUgc2xpY2UgY29udGFpbmluZyBhbGwgYmxvY2tzLlxuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qb3B0aW9ucy5ibG9ja1NpemUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnaW50OCcgfHwgdHlwZSA9PSAndWludDgnIHx8IG9wdGlvbnMuZW5kaWFuID09IHN5c3RlbUVuZGlhbm5lc3MpIHtcbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKSk7XG4gICAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKSk7XG4gICAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjIpKTtcbiAgICAgICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbioyKSk7XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjQpKTtcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio0KSk7XG4gICAgICAgIC8vY2FzZSBcImludDY0XCI6XG4gICAgICAgIC8vICAgIGNoZWNrU2l6ZSg4KTtcbiAgICAgICAgLy8gICAgcmV0dXJuIG5ldyBJbnQ2NEFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjgpKTtcbiAgICAgICAgLy9jYXNlIFwidWludDY0XCI6XG4gICAgICAgIC8vICAgIGNoZWNrU2l6ZSg4KTtcbiAgICAgICAgLy8gICAgcmV0dXJuIG5ldyBVaW50NjRBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio4KSk7XG4gICAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qNCkpO1xuICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBjaGVja1NpemUoOCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio4KSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBOUlJEIHR5cGU6IFwiICsgdHlwZSArIFwiLCByZXR1cm5pbmcgcmF3IGJ1ZmZlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKG9wdGlvbnMuZW5kaWFuKSB7XG4gICAgICAgIGNhc2UgJ2JpZyc6XG4gICAgICAgICAgICBlbmRpYW5GbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGl0dGxlJzpcbiAgICAgICAgICAgIGVuZGlhbkZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBlbmRpYW5uZXNzIGluIE5SUkQgZmlsZTogXCIgKyBvcHRpb25zLmVuZGlhbik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludDhcIjogLy8gTm90ZSB0aGF0IGhlcmUgd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlciwgYXMgdGhlIERhdGFWaWV3LmdldCBtZXRob2RzIHNob3VsZCB0aHJvdyBhbiBleGNlcHRpb24gaWYgd2UgcmVhZCBiZXlvbmQgdGhlIGJ1ZmZlci5cbiAgICAgICAgICAgIGFyciA9IG5ldyBJbnQ4QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRJbnQ4KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldFVpbnQ4KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgSW50MTZBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldEludDE2KGkqMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDE2QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRVaW50MTYoaSoyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IEludDMyQXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRJbnQzMihpKjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQzMkFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0VWludDMyKGkqNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAvL2Nhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAvLyAgICBhcnIgPSBuZXcgSW50NjRBcnJheSh0b3RhbExlbik7XG4gICAgICAgIC8vICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAvLyAgICAgICAgYXJyW2ldID0gdmlldy5nZXRJbnQ2NChpKjgpO1xuICAgICAgICAvLyAgICB9XG4gICAgICAgIC8vICAgIHJldHVybiBhcnI7XG4gICAgICAgIC8vY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAvLyAgICBhcnIgPSBuZXcgVWludDY0QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAvLyAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgLy8gICAgICAgIGFycltpXSA9IHZpZXcuZ2V0VWludDY0KGkqOCk7XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy8gICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgRmxvYXQzMkFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0RmxvYXQzMihpKjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IEZsb2F0NjRBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldEZsb2F0NjQoaSo4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBOUlJEIHR5cGU6IFwiICsgdHlwZSArIFwiLCByZXR1cm5pbmcgcmF3IGJ1ZmZlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2l6ZShzaXplT2ZUeXBlKSB7XG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aDx0b3RhbExlbipzaXplT2ZUeXBlKSB0aHJvdyBuZXcgRXJyb3IoXCJOUlJEIGZpbGUgZG9lcyBub3QgY29udGFpbiBlbm91Z2ggZGF0YSFcIik7XG4gICAgfVxufVxuXG52YXIgd2hpdGVzcGFjZURhdGFWYWx1ZUxpc3RTZXBhcmF0b3JSRSA9IC9bIFxcdFxcblxcclxcdlxcZl0rLztcbmZ1bmN0aW9uIHBhcnNlTlJSRFRleHREYXRhKGJ1ZmZlciwgdHlwZSwgc2l6ZXMpIHtcbiAgICB2YXIgaSwgYnVmOCwgc3RyLCBzdHJMaXN0LCB0b3RhbExlbiA9IDE7XG4gICAgZm9yKGk9MDsgaTxzaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2l6ZXNbaV08PTApIHRocm93IG5ldyBFcnJvcihcIlNpemVzIHNob3VsZCBiZSBhIGxpc3Qgb2YgcG9zaXRpdmUgKD4wKSBpbnRlZ2VycyFcIik7XG4gICAgICAgIHRvdGFsTGVuICo9IHNpemVzW2ldO1xuICAgIH1cbiAgICBidWY4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1ZjgpO1xuICAgIHN0ckxpc3QgPSBzdHIuc3BsaXQod2hpdGVzcGFjZURhdGFWYWx1ZUxpc3RTZXBhcmF0b3JSRSk7XG4gICAgaWYgKHN0ckxpc3QubGVuZ3RoPHRvdGFsTGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBlbm91Z2ggZGF0YSBpbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAoc3RyTGlzdC5sZW5ndGg+dG90YWxMZW4pIHtcbiAgICAgICAgaWYgKHN0ckxpc3RbMF0gPT09ICcnKSBzdHJMaXN0ID0gc3RyTGlzdC5zbGljZSgxKTsgLy8gU3RyaWN0bHkgc3BlYWtpbmcgdGhlIHNwZWMgZG9lc24ndCAoZXhwbGljaXRseSkgYWxsb3cgd2hpdGVzcGFjZSBpbiBmcm9udCBvZiB0aGUgZmlyc3QgbnVtYmVyLCBidXQgbGV0J3MgYmUgbGVuaWVudC5cbiAgICAgICAgc3RyTGlzdCA9IHN0ckxpc3Quc2xpY2UoMCwgdG90YWxMZW4pO1xuICAgIH1cbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgLy9jYXNlIFwiaW50NjRcIjpcbiAgICAvLyAgICByZXR1cm4gbmV3IEludDY0QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIC8vY2FzZSBcInVpbnQ2NFwiOlxuICAgIC8vICAgIHJldHVybiBuZXcgVWludDY0QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRGbG9hdCkpO1xuICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJERmxvYXQpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBOUlJEIHR5cGU6IFwiICsgdHlwZSArIFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbi8vIFRoaXMgQUxXQVlTIHJldHVybnMgYW4gaW50ZWdlciwgb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbmZ1bmN0aW9uIGdldE5SUkRUeXBlU2l6ZSh0eXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgICByZXR1cm4gMTtcbiAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgIHJldHVybiA4O1xuICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGtub3cgdGhlIHNpemUgb2YgTlJSRCB0eXBlOiBcIiArIHR5cGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOUlJEKHJldCkge1xuICAgIC8vIEFsd2F5cyBuZWNlc3NhcnkgZmllbGRzXG4gICAgaWYgKHJldC5kaW1lbnNpb249PT11bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnR5cGU9PT11bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5lbmNvZGluZz09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvZGluZyBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5zaXplcz09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplcyBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU29tZXRpbWVzIG5lY2Vzc2FyeSBmaWVsZHNcbiAgICBpZiAocmV0LnR5cGUgIT0gJ2Jsb2NrJyAmJiByZXQudHlwZSAhPSAnaW50OCcgJiYgcmV0LnR5cGUgIT0gJ3VpbnQ4JyAmJlxuICAgICAgICAgIHJldC5lbmNvZGluZyAhPSAnYXNjaWknICYmIHJldC5lbmRpYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmRpYW5uZXNzIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnR5cGUgPT0gJ2Jsb2NrJyAmJiByZXQuYmxvY2tTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBibG9jayBzaXplIGluIE5SUkQgZmlsZSFcIik7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGRpbWVuc2lvbiBhbmQgcGVyLWF4aXMgZmllbGQgbGVuZ3Roc1xuICAgIGlmIChyZXQuZGltZW5zaW9uID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlplcm8tZGltZW5zaW9uYWwgTlJSRCBmaWxlP1wiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5kaW1lbnNpb24gIT0gcmV0LnNpemVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ3NpemVzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnNwYWNpbmdzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LnNwYWNpbmdzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ3NwYWNpbmdzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnRoaWNrbmVzc2VzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LnRoaWNrbmVzc2VzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ3RoaWNrbmVzc2VzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LmF4aXNNaW5zICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LmF4aXNNaW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ2F4aXMgbWlucycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5heGlzTWF4cyAmJiByZXQuZGltZW5zaW9uICE9IHJldC5heGlzTWF4cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdheGlzIG1heHMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQuY2VudGVycyAmJiByZXQuZGltZW5zaW9uICE9IHJldC5jZW50ZXJzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ2NlbnRlcnMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQubGFiZWxzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LmxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdsYWJlbHMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQudW5pdHMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQudW5pdHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAndW5pdHMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQua2luZHMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQua2luZHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAna2luZHMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfVxuICAgIFxuICAgIC8vIFRPRE86IENoZWNrIHNwYWNlL29yaWVudGF0aW9uIGZpZWxkcy5cbiAgICBcbiAgICAvLyBXZSBzaG91bGQgZWl0aGVyIGhhdmUgaW5saW5lIGRhdGEgb3IgZXh0ZXJuYWwgZGF0YVxuICAgIGlmICgocmV0LmRhdGEgPT09IHVuZGVmaW5lZCB8fCByZXQuZGF0YS5sZW5ndGggPT09IDApICYmIChyZXQuYnVmZmVyID09PSB1bmRlZmluZWQgfHwgcmV0LmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSAmJiByZXQuZGF0YUZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOUlJEIGZpbGUgaGFzIG5laXRoZXIgaW5saW5lIG9yIGV4dGVybmFsIGRhdGEhXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FzdFR5cGVkQXJyYXkoZGF0YSwgdHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoZGF0YSk7XG4gICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShkYXRhKTtcbiAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAvL2Nhc2UgXCJpbnQ2NFwiOlxuICAgIC8vICAgIHJldHVybiBuZXcgSW50NjRBcnJheShkYXRhKTtcbiAgICAvL2Nhc2UgXCJ1aW50NjRcIjpcbiAgICAvLyAgICByZXR1cm4gbmV3IFVpbnQ2NEFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGRhdGEpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYXN0IHRvIE5SUkQgdHlwZTogXCIgKyB0eXBlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRvQnVmZmVyKGRhdGEsIHR5cGUsIGVuZGlhbikge1xuICAgIHZhciBpLCBlbmRpYW5GbGFnLCB2aWV3LCBuYXRpdmVTaXplID0gZ2V0TlJSRFR5cGVTaXplKHR5cGUpLCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YS5sZW5ndGgqbmF0aXZlU2l6ZSk7XG4gICAgc3dpdGNoKGVuZGlhbikge1xuICAgIGNhc2UgJ2JpZyc6XG4gICAgICAgIGVuZGlhbkZsYWcgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGl0dGxlJzpcbiAgICAgICAgZW5kaWFuRmxhZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIGVuZGlhbm5lc3MgaW4gTlJSRCBmaWxlOiBcIiArIGVuZGlhbik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgXCJpbnQ4XCI6IC8vIE5vdGUgdGhhdCBoZXJlIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIHRoZSBzaXplIG9mIHRoZSBidWZmZXIsIGFzIHRoZSBEYXRhVmlldy5nZXQgbWV0aG9kcyBzaG91bGQgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHdlIHJlYWQgYmV5b25kIHRoZSBidWZmZXIuXG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRJbnQ4KGksIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChpLCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50MTYoaSoyLCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQxNihpKjIsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRJbnQzMihpKjQsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKGkqNCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAvL2Nhc2UgXCJpbnQ2NFwiOlxuICAgIC8vICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICB2aWV3LnNldEludDY0KGkqOCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgLy8gICAgfVxuICAgIC8vICAgIHJldHVybiBidWZmZXI7XG4gICAgLy9jYXNlIFwidWludDY0XCI6XG4gICAgLy8gICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgICAgIHZpZXcuc2V0VWludDY0KGkqOCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgLy8gICAgfVxuICAgIC8vICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDMyKGkqNCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDY0KGkqOCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJDYW5ub3Qgc2VyaWFsaXplIE5SUkQgdHlwZTogXCIgKyB0eXBlICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplVG9UZXh0QnVmZmVyKGRhdGEpIHtcbiAgICB2YXIgaSwgc3RycyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCksIHN0ciwgYnVmZmVyLCBhcnI7XG4gICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0cnNbaV0gPSAnJyArIGRhdGFbaV07XG4gICAgfVxuICAgIHN0ciA9IHN0cnMuam9pbihcIiBcIik7XG4gICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHN0ci5sZW5ndGgpO1xuICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgZm9yKGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG4iLCIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMvY29tbW9uJykuYXNzaWduO1xuXG52YXIgZGVmbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xudmFyIGluZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG52YXIgcGFrbyA9IHt9O1xuXG5hc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWtvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnNoIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2c7IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnNoIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG4gIHZhciBkaWN0O1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICAgIGlmICh0eXBlb2YgZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWN0ID0gZGljdGlvbmFyeTtcbiAgICAgIH1cblxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHtcbiAgICAgIHN0YXR1cyA9IGMuWl9PSztcbiAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBubyBtb3JlIGlucHV0IGRhdGEsIHdlIHNob3VsZCBjaGVjayB0aGF0IGludGVybmFsIGluZmxhdGUgYnVmZmVyc1xuICAgIC8vIGFyZSBmbHVzaGVkLiBUaGUgb25seSB3YXkgdG8gZG8gaXQgd2hlbiBhdmFpbF9vdXQgPSAwIC0gcnVuIG9uZSBtb3JlXG4gICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuXG4gICAgLy8gSGVyZSB3ZSBzZXQgZmxhZyB0byBwcm9jZXNzIHRoaXMgZXJyb3IgcHJvcGVybHkuXG4gICAgLy9cbiAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2hcbiAgICAvLyBsb2dpYy5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7XG5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHtcbiAgICBfbW9kZSA9IGMuWl9GSU5JU0g7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoYy5aX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsbGlnbmVkIHN0cmluZ3MgdG8gb25EYXRhXG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB7IHRocm93IGluZmxhdG9yLm1zZzsgfVxuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbmV4cG9ydHMudW5nemlwICA9IGluZmxhdGU7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcnlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIHVzZSBmYWxsYmFjayBmb3IgYmlnIGFycmF5cyB0byBhdm9pZCBzdGFjayBvdmVyZmxvd1xuICBpZiAobGVuIDwgNjU1MzcpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICBzLmRfYnVmID0gcy5saXRfYnVmc2l6ZSA+PiAxO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xuICB9IGNhdGNoIChfKSB7fSBmaW5hbGx5IHtcbiAgICBpZiAoIVN0cmVhbSkgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICB9XG59KSgpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9IEJ1ZmZlci5pc0J1ZmZlcihjaHVuayk7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBidWZmZXJTaGltLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLXN0cmluZy1wcmltaXRpdmUnICk7XG52YXIgaXNOb25OZWdhdGl2ZUludGVnZXIgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tbm9ubmVnYXRpdmUtaW50ZWdlcicgKTtcbnZhciBjZWlsID0gcmVxdWlyZSggJ21hdGgtY2VpbCcgKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCAndXRpbHMtcmVwZWF0LXN0cmluZycgKTtcblxuXG4vLyBDT05TVEFOVFMgLy9cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOyAvLyAyKio1MyAtIDFcblxuXG4vLyBMRUZUIFBBRCAvL1xuXG4vKipcbiogRlVOQ1RJT046IGxwYWQoIHN0ciwgbGVuWywgcGFkXSApXG4qXHRMZWZ0IHBhZHMgYSBzdHJpbmcgc3VjaCB0aGF0IHRoZSBwYWRkZWQgc3RyaW5nIGhhcyBhIGxlbmd0aCBvZiBhdCBsZWFzdCBgbGVuYC5cbipcbiogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byBwYWRcbiogQHBhcmFtIHtOdW1iZXJ9IGxlbiAtIG1pbmltdW0gc3RyaW5nIGxlbmd0aFxuKiBAcGFyYW0ge1N0cmluZ30gW3BhZD0nICddIC0gc3RyaW5nIHVzZWQgdG8gcGFkXG4qIEByZXR1cm5zIHtTdHJpbmd9IHBhZGRlZCBzdHJpbmdcbiovXG5mdW5jdGlvbiBscGFkKCBzdHIsIGxlbiwgcGFkICkge1xuXHR2YXIgbjtcblx0dmFyIHA7XG5cdGlmICggIWlzU3RyaW5nKCBzdHIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZy4gVmFsdWU6IGAnICsgc3RyICsgJ2AuJyApO1xuXHR9XG5cdGlmICggIWlzTm9uTmVnYXRpdmVJbnRlZ2VyKCBsZW4gKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLiBWYWx1ZTogYCcgKyBsZW4gKyAnYC4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMiApIHtcblx0XHRwID0gcGFkO1xuXHRcdGlmICggIWlzU3RyaW5nKCBwICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gVGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZy4gVmFsdWU6IGAnICsgcCArICdgLicgKTtcblx0XHR9XG5cdFx0aWYgKCBwLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gUGFkIHN0cmluZyBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuJyApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRwID0gJyAnO1xuXHR9XG5cdGlmICggbGVuID4gTUFYX1NBRkVfSU5URUdFUiApIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIE91dHB1dCBzdHJpbmcgbGVuZ3RoIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHN0cmluZyBsZW5ndGguJyApO1xuXHR9XG5cdG4gPSAoIGxlbiAtIHN0ci5sZW5ndGggKSAvIHAubGVuZ3RoO1xuXHRpZiAoIG4gPD0gMCApIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cdG4gPSBjZWlsKCBuICk7XG5cdHJldHVybiByZXBlYXQoIHAsIG4gKSArIHN0cjtcbn0gLy8gZW5kIEZVTkNUSU9OIGxwYWQoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBscGFkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1zdHJpbmctcHJpbWl0aXZlJyApO1xudmFyIGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW5vbm5lZ2F0aXZlLWludGVnZXInICk7XG5cblxuLy8gTk9URVMgLy9cblxuLyoqXG4qIFRoZSBhbGdvcml0aG1pYyB0cmljayB1c2VkIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyB0byB0cmVhdCBzdHJpbmcgY29uY2F0ZW5hdGlvbiB0aGUgc2FtZSBhcyBiaW5hcnkgYWRkaXRpb24gKGkuZS4sIGFueSBuYXR1cmFsIG51bWJlciAobm9ubmVnYXRpdmUgaW50ZWdlcikgY2FuIGJlIGV4cHJlc3NlZCBhcyBhIHN1bSBvZiBwb3dlcnMgb2YgdHdvKS5cbipcbiogRm9yIGV4YW1wbGUsXG4qXG4qICBuID0gMTAgPT4gMTAxMCA9PiAyXjMgKyAyXjAgKyAyXjEgKyAyXjBcbipcbiogV2UgY2FuIHByb2R1Y2UgYSAxMC1yZXBlYXQgc3RyaW5nIGJ5IFwiYWRkaW5nXCIgdGhlIHJlc3VsdHMgb2YgYSA4LXJlcGVhdCBzdHJpbmcgYW5kIGEgMi1yZXBlYXQgc3RyaW5nLlxuKlxuKiBUaGUgaW1wbGVtZW50YXRpb24gaXMgdGhlbiBhcyBmb2xsb3dzOlxuKiAgOiBMZXQgYHNgIGJlIHRoZSBzdHJpbmcgdG8gYmUgcmVwZWF0ZWQgYW5kIGBvYCBiZSBhbiBvdXRwdXQgc3RyaW5nLlxuKiAgMCkgSW5pdGlhbGl6ZSBhbiBvdXRwdXQgc3RyaW5nIGBvYC5cbiogIDEpIENoZWNrIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGBzYCBzdHJpbmcgc2hvdWxkIGJlIFwiYWRkZWRcIiB0byB0aGUgb3V0cHV0IFwidG90YWxcIi5cbiogICAgIC0gaWYgdGhlIGJpdCBpcyBhIG9uZSwgYWRkXG4qICAgICAtIG90aGVyd2lzZSwgbW92ZSBvblxuKiAgMikgRG91YmxlIHRoZSBzdHJpbmcgYHNgIGJ5IGFkZGluZyBgc2AgdG8gYHNgLlxuKiAgMykgUmlnaHQtc2hpZnQgdGhlIGJpdHMgb2YgYG5gLlxuKiAgNCkgQ2hlY2sgaWYgd2UgaGF2ZSBzaGlmdGVkIG9mZiBhbGwgYml0cy5cbiogICAgIC0gaWYgeWVzLCBkb25lLlxuKiAgICAgLSBvdGhlcndpc2UsIG1vdmUgb25cbiogIDUpIFJlcGVhdCAxLTQuXG4qXG4qIFRoZSByZXN1bHQgaXMgdGhhdCwgYXMgdGhlIHN0cmluZyBpcyByZXBlYXRlZCwgd2UgY29udGludWFsbHkgY2hlY2sgdG8gc2VlIGlmIHRoZSBkb3VibGVkIHN0cmluZyBpcyBvbmUgd2hpY2ggd2Ugd2FudCB0byBhZGQgdG8gb3VyIFwidG90YWxcIi5cbipcbiogVGhlIGFsZ29yaXRobSBydW5zIGluIE8obG9nXzIobikpIGNvbXBhcmVkIHRvIE8obikuXG4qL1xuXG5cbi8vIENPTlNUQU5UUyAvL1xuXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7IC8vIDIqKjUzIC0gMVxuXG5cbi8vIFJFUEVBVCAvL1xuXG4vKipcbiogRlVOQ1RJT046IHJlcGVhdCggc3RyLCBuIClcbipcdFJlcGVhdHMgYSBzdHJpbmcgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzIGFuZCByZXR1cm5zIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0LlxuKlxuKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHJlcGVhdFxuKiBAcGFyYW0ge051bWJlcn0gbiAtIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZ1xuKiBAcmV0dXJucyB7U3RyaW5nfVxuKi9cbmZ1bmN0aW9uIHJlcGVhdCggc3RyLCBuICkge1xuXHR2YXIgcnB0O1xuXHR2YXIgY250O1xuXHRpZiAoICFpc1N0cmluZyggc3RyICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcuIFZhbHVlOiBgJyArIHN0ciArICdgLicgKTtcblx0fVxuXHRpZiAoICFpc05vbk5lZ2F0aXZlSW50ZWdlciggbiApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXIuIFZhbHVlOiBgJyArIG4gKyAnYC4nICk7XG5cdH1cblx0aWYgKCBzdHIubGVuZ3RoID09PSAwIHx8IG4gPT09IDAgKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdC8vIENoZWNrIHRoYXQgb3V0cHV0IHN0cmluZyB3aWxsIG5vdCBleGNlZWQgdGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aDpcblx0aWYgKCBzdHIubGVuZ3RoICogbiA+IE1BWF9TQUZFX0lOVEVHRVIgKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBPdXRwdXQgc3RyaW5nIGxlbmd0aCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzdHJpbmcgbGVuZ3RoLicgKTtcblx0fVxuXHRycHQgPSAnJztcblx0Y250ID0gbjtcblx0Zm9yKCA7IDsgKSB7XG5cdFx0Ly8gSWYgdGhlIGNvdW50IGlzIG9kZCwgYXBwZW5kIHRoZSBjdXJyZW50IGNvbmNhdGVuYXRlZCBzdHJpbmc6XG5cdFx0aWYgKCAoY250JjEpID09PSAxICkge1xuXHRcdFx0cnB0ICs9IHN0cjtcblx0XHR9XG5cdFx0Ly8gUmlnaHQtc2hpZnQgdGhlIGJpdHM6XG5cdFx0Y250ID4+Pj0gMTtcblx0XHRpZiAoIGNudCA9PT0gMCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvLyBEb3VibGUgdGhlIHN0cmluZzpcblx0XHRzdHIgKz0gc3RyO1xuXHR9XG5cdHJldHVybiBycHQ7XG59IC8vIGVuZCBGVU5DVElPTiByZXBlYXQoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSByZXBlYXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLXN0cmluZy1wcmltaXRpdmUnICk7XG52YXIgaXNOb25OZWdhdGl2ZUludGVnZXIgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tbm9ubmVnYXRpdmUtaW50ZWdlcicgKTtcbnZhciBjZWlsID0gcmVxdWlyZSggJ21hdGgtY2VpbCcgKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCAndXRpbHMtcmVwZWF0LXN0cmluZycgKTtcblxuXG4vLyBDT05TVEFOVFMgLy9cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOyAvLyAyKio1MyAtIDFcblxuXG4vLyBSSUdIVCBQQUQgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBycGFkKCBzdHIsIGxlblssIHBhZF0gKVxuKlx0UmlnaHQgcGFkcyBhIHN0cmluZyBzdWNoIHRoYXQgdGhlIHBhZGRlZCBzdHJpbmcgaGFzIGEgbGVuZ3RoIG9mIGF0IGxlYXN0IGBsZW5gLlxuKlxuKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHBhZFxuKiBAcGFyYW0ge051bWJlcn0gbGVuIC0gbWluaW11bSBzdHJpbmcgbGVuZ3RoXG4qIEBwYXJhbSB7U3RyaW5nfSBbcGFkPScgJ10gLSBzdHJpbmcgdXNlZCB0byBwYWRcbiogQHJldHVybnMge1N0cmluZ30gcGFkZGVkIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIHJwYWQoIHN0ciwgbGVuLCBwYWQgKSB7XG5cdHZhciBuO1xuXHR2YXIgcDtcblx0aWYgKCAhaXNTdHJpbmcoIHN0ciApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLiBWYWx1ZTogYCcgKyBzdHIgKyAnYC4nICk7XG5cdH1cblx0aWYgKCAhaXNOb25OZWdhdGl2ZUludGVnZXIoIGxlbiApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXIuIFZhbHVlOiBgJyArIGxlbiArICdgLicgKTtcblx0fVxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAyICkge1xuXHRcdHAgPSBwYWQ7XG5cdFx0aWYgKCAhaXNTdHJpbmcoIHAgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBUaGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLiBWYWx1ZTogYCcgKyBwICsgJ2AuJyApO1xuXHRcdH1cblx0XHRpZiAoIHAubGVuZ3RoID09PSAwICkge1xuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBQYWQgc3RyaW5nIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZy4nICk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHAgPSAnICc7XG5cdH1cblx0aWYgKCBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSICkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gT3V0cHV0IHN0cmluZyBsZW5ndGggZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc3RyaW5nIGxlbmd0aC4nICk7XG5cdH1cblx0biA9ICggbGVuIC0gc3RyLmxlbmd0aCApIC8gcC5sZW5ndGg7XG5cdGlmICggbiA8PSAwICkge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblx0biA9IGNlaWwoIG4gKTtcblx0cmV0dXJuIHN0ciArIHJlcGVhdCggcCwgbiApO1xufSAvLyBlbmQgRlVOQ1RJT04gcnBhZCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJwYWQ7XG4iLCIvKipcbipcbipcdFZBTElEQVRFOiBpbnRlZ2VyXG4qXG4qXG4qXHRERVNDUklQVElPTjpcbipcdFx0LSBWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW51bWJlcicgKTtcblxuXG4vLyBJU0lOVEVHRVIgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBpc0ludGVnZXIoIHZhbHVlIClcbipcdFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIGJlIHZhbGlkYXRlZFxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gaW50ZWdlclxuKi9cbmZ1bmN0aW9uIGlzSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiBpc051bWJlciggdmFsdWUgKSAmJiB2YWx1ZSUxID09PSAwO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNJbnRlZ2VyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyO1xuIiwiLyoqXG4qXG4qXHRWQUxJREFURTogbm9ubmVnYXRpdmUtaW50ZWdlclxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gVmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNS4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTUuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1pbnRlZ2VyJyApO1xuXG5cbi8vIElTIE5PTk5FR0FUSVZFIElOVEVHRVIgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBpc05vbk5lZ2F0aXZlSW50ZWdlciggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gYmUgdmFsaWRhdGVkXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIG5vbm5lZ2F0aXZlIGludGVnZXJcbiovXG5mdW5jdGlvbiBpc05vbk5lZ2F0aXZlSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiBpc0ludGVnZXIoIHZhbHVlICkgJiYgdmFsdWUgPj0gMDtcbn0gLy8gZW5kIEZVTkNUSU9OIGlzTm9uTmVnYXRpdmVJbnRlZ2VyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb25OZWdhdGl2ZUludGVnZXI7XG4iLCIvKipcbipcbipcdFZBTElEQVRFOiBudW1iZXJcbipcbipcbipcdERFU0NSSVBUSU9OOlxuKlx0XHQtIFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBGVU5DVElPTjogaXNOdW1iZXIoIHZhbHVlIClcbipcdFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gYmUgdmFsaWRhdGVkXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhIG51bWJlclxuKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKCB2YWx1ZSApIHtcblx0cmV0dXJuICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIHZhbHVlICkgPT09ICdbb2JqZWN0IE51bWJlcl0nICkgJiYgdmFsdWUudmFsdWVPZigpID09PSB2YWx1ZS52YWx1ZU9mKCk7XG59IC8vIGVuZCBGVU5DVElPTiBpc051bWJlcigpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyBwcmltaXRpdmUuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyBwcmltaXRpdmVcbiovXG5mdW5jdGlvbiBpc1N0cmluZyggdmFsdWUgKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNTdHJpbmcoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsIm1vZHVsZS5leHBvcnRzPXtcclxuICBcIm5hbWVcIjogXCJhbWkuanNcIixcclxuICBcInZlcnNpb25cIjogXCIwLjAuMTctZGV2XCIsXHJcbiAgXCJtYWluXCI6IFwibGliL2FtaS5qc1wiLFxyXG4gIFwia2V5d29yZHNcIjogW1xyXG4gICAgXCJhbWlcIixcclxuICAgIFwiYW1pLmpzXCIsXHJcbiAgICBcInRocmVlLmpzXCIsXHJcbiAgICBcIndlYmdsXCIsXHJcbiAgICBcImRpY29tXCIsXHJcbiAgICBcIm5pZnRpXCIsXHJcbiAgICBcImF3ZXNvbWVcIixcclxuICAgIFwibWVkaWNhbFwiLFxyXG4gICAgXCJpbWFnaW5nXCIsXHJcbiAgICBcInh0a1wiLFxyXG4gICAgXCJucnJkXCIsXHJcbiAgICBcInZ0a1wiLFxyXG4gICAgXCJzdGxcIixcclxuICAgIFwidHJrXCJcclxuICBdLFxyXG4gIFwiYXV0aG9yXCI6IHtcclxuICAgIFwibmFtZVwiOiBcIk5pY29sYXMgUmFubm91XCIsXHJcbiAgICBcImVtYWlsXCI6IFwibmljb2xhc0BldW5hdGUuY2hcIixcclxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9ldW5hdGUuY2hcIlxyXG4gIH0sXHJcbiAgXCJsaWNlbnNlXCI6IFwiQXBhY2hlLTIuMFwiLFxyXG4gIFwicmVwb3NpdG9yeVwiOiB7XHJcbiAgICBcInR5cGVcIjogXCJnaXRcIixcclxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9mbm5kc2MuZ2l0aHViLmlvL2FtaVwiXHJcbiAgfSxcclxuICBcImNvbmZpZ1wiOiB7XHJcbiAgICBcInRocmVlVmVyc2lvblwiOiBcIjg2XCIsXHJcbiAgICBcImFtaUNETlwiOiBcImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2FtaS5qcy9cIixcclxuICAgIFwiZ2FLZXlcIjogXCJVQS0zOTMwMzAyMi0zXCIsXHJcbiAgICBcInRyYW5zZm9ybXNcIjogXCItdCBbYmFiZWxpZnkgLS1wcmVzZXRzIFsgZXMyMDE1IF0gXVwiXHJcbiAgfSxcclxuICBcImRlcGVuZGVuY2llc1wiOiB7XHJcbiAgICBcImRpY29tLXBhcnNlclwiOiBcIjEuNy4zXCIsXHJcbiAgICBcImltYWdlLUpQRUcyMDAwXCI6IFwiT0hJRi9pbWFnZS1KUEVHMjAwMCNtYXN0ZXJcIixcclxuICAgIFwianBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzXCI6IFwiMS4yLjNcIixcclxuICAgIFwibWF0aC1mbG9hdDMyLXRvLWJpbmFyeS1zdHJpbmdcIjogXCJeMS4wLjBcIixcclxuICAgIFwibmlmdGktcmVhZGVyLWpzXCI6IFwidjAuNS4zXCIsXHJcbiAgICBcIm5ycmQtanNcIjogXCJeMC4yLjFcIixcclxuICAgIFwicGFrb1wiOiBcIjEuMC4xXCJcclxuICB9LFxyXG4gIFwic2NyaXB0c1wiOiB7XHJcbiAgICBcImRpc3Q6cHJlcGFyZVwiOiBcIm5vZGUgLi9zY3JpcHRzLyRucG1fcGFja2FnZV9jb25maWdfbW9kZS5qcyAtLWRpc3RcIixcclxuICAgIFwiZGlzdDp3YXRjaEFtaVwiOiBcIndhdGNoaWZ5IC1kIHNyYy9hbWkgJG5wbV9wYWNrYWdlX2NvbmZpZ190cmFuc2Zvcm1zIC0tc3RhbmRhbG9uZSBBTUkgLW8gZGlzdC9idWlsZC9hbWkuanMgLXZcIixcclxuICAgIFwiZGlzdDp3YXRjaFwiOiBcIndhdGNoaWZ5ICRucG1fcGFja2FnZV9jb25maWdfdGFyZ2V0IC1kICRucG1fcGFja2FnZV9jb25maWdfdHJhbnNmb3JtcyAtbyBkaXN0LyRucG1fcGFja2FnZV9jb25maWdfdGFyZ2V0IC12XCIsXHJcbiAgICBcImRpc3RcIjogXCJucG0gcnVuIGRpc3Q6cHJlcGFyZSAtLWFtaS5qczptb2RlPSRucG1fcGFja2FnZV9jb25maWdfbW9kZSAmJiAobGl2ZS1zZXJ2ZXIgZGlzdCAtLW9wZW49JG5wbV9wYWNrYWdlX2NvbmZpZ19vcGVuICYgbnBtIHJ1biBkaXN0OndhdGNoIC0tYW1pLmpzOnRhcmdldD0kbnBtX3BhY2thZ2VfY29uZmlnX3RhcmdldClcIixcclxuICAgIFwiZXhhbXBsZVwiOiBcIm5wbSBydW4gY2xlYW4gJiYgbm9kZSAuL3NjcmlwdHMvcm91dGVyLmpzIGV4YW1wbGVzIFwiLFxyXG4gICAgXCJsZXNzb25cIjogXCJucG0gcnVuIGNsZWFuICYmIG1rZGlyIGRpc3QvYnVpbGQgJiYgdG91Y2ggZGlzdC9idWlsZC9hbWkuanMgJiYgbm9kZSAuL3NjcmlwdHMvcm91dGVyLmpzIGxlc3NvbnMgXCIsXHJcbiAgICBcImRlbW9cIjogXCJub2RlIC4vc2NyaXB0cy9sZXNzb25zLmpzIC0tZGVtb1wiLFxyXG4gICAgXCJsaW50XCI6IFwiZXNsaW50ICoqLyouanMgLS1xdWlldFwiLFxyXG4gICAgXCJidWlsZDpleGFtcGxlc1wiOiBcIm5wbSBydW4gZGlzdDpwcmVwYXJlIC0tYW1pLmpzOm1vZGU9ZXhhbXBsZXMgJiYgZmluZCBleGFtcGxlcyAtbmFtZSAnKi5qcycgLXByaW50MCB8IHhhcmdzIC0wIC1uMSAtSXt9IGJhc2ggLWMgXFxcImVjaG8gQnVpbGRpbmcge307IGJyb3dzZXJpZnkge30gLWQgLXYgJG5wbV9wYWNrYWdlX2NvbmZpZ190cmFuc2Zvcm1zID4gZGlzdC97fSBcXFwiXCIsXHJcbiAgICBcImJ1aWxkOmFtaVwiOiBcImJyb3dzZXJpZnkgc3JjL2FtaS5qcyAtZCAtdiAkbnBtX3BhY2thZ2VfY29uZmlnX3RyYW5zZm9ybXMgLS1zdGFuZGFsb25lIEFNSSA+IGJ1aWxkL2FtaS5qcyAmJiB1Z2xpZnlqcyBidWlsZC9hbWkuanMgLW8gYnVpbGQvYW1pLm1pbi5qc1wiLFxyXG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gY2xlYW4gJiYgY3AgaW5kZXguaHRtbCBkaXN0L2luZGV4Lmh0bWwgJiYgbnBtIHJ1biBidWlsZDpleGFtcGxlcyAmJiBucG0gcnVuIGRvY1wiLFxyXG4gICAgXCJidWlsZC1janNcIjogXCJyaW1yYWYgbGliICYmIGNyb3NzLWVudiBCQUJFTF9FTlY9Y2pzIGJhYmVsIC4vc3JjIC1kIGxpYlwiLFxyXG4gICAgXCJjbGVhblwiOiBcInJpbXJhZiAtcmYgZGlzdC8qXCIsXHJcbiAgICBcInRlc3RcIjogXCJrYXJtYSBzdGFydFwiLFxyXG4gICAgXCJkb2NcIjogXCJqc2RvYyAtcCAtciAtUiBSRUFETUUubWQgLWMganNkb2MuY29uZiAtZCBkaXN0L2RvYyBzcmNcIixcclxuICAgIFwiYW1pXCI6IFwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gZGVtbyAmJiBucG0gcnVuIGJ1aWxkOmFtaSAmJiBucG0gcnVuIHRlc3RcIixcclxuICAgIFwiZGVwbG95XCI6IFwibnBtIHJ1biBidWlsZCAmJiBnaC1wYWdlcyAtZCBkaXN0XCJcclxuICB9LFxyXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcclxuICAgIFwiYmFiZWwtY2xpXCI6IFwibGF0ZXN0XCIsXHJcbiAgICBcImJhYmVsLXBsdWdpbi1hZGQtbW9kdWxlLWV4cG9ydHNcIjogXCJeMC4yLjFcIixcclxuICAgIFwiYmFiZWwtcG9seWZpbGxcIjogXCJeNi4xMy4wXCIsXHJcbiAgICBcImJhYmVsLXByZXNldC1lczIwMTVcIjogXCJeNi4xMy4yXCIsXHJcbiAgICBcImJhYmVsaWZ5XCI6IFwiNy4zLjBcIixcclxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4xMy4xLjBcIixcclxuICAgIFwiY3Jvc3MtZW52XCI6IFwiXjMuMi4zXCIsXHJcbiAgICBcImVzbGludFwiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJlc2xpbnQtY29uZmlnLWdvb2dsZVwiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJnaC1wYWdlc1wiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJnbHNsaWZ5XCI6IFwiNS4xLjBcIixcclxuICAgIFwiamFzbWluZS1jb3JlXCI6IFwibGF0ZXN0XCIsXHJcbiAgICBcImpzZG9jXCI6IFwianNkb2MzL2pzZG9jI21hc3RlclwiLFxyXG4gICAgXCJrYXJtYVwiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJrYXJtYS1icm93c2VyaWZ5XCI6IFwibGF0ZXN0XCIsXHJcbiAgICBcImthcm1hLWphc21pbmVcIjogXCJsYXRlc3RcIixcclxuICAgIFwia2FybWEtcGhhbnRvbWpzLWxhdW5jaGVyXCI6IFwiMS4wLjRcIixcclxuICAgIFwia2FybWEtc2lub25cIjogXCJeMS4wLjVcIixcclxuICAgIFwia2FybWEtc3BlYy1yZXBvcnRlclwiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJsaXZlLXNlcnZlclwiOiBcIl4xLjEuMFwiLFxyXG4gICAgXCJwaGFudG9tanMtcHJlYnVpbHRcIjogXCIyLjEuMTRcIixcclxuICAgIFwicmltcmFmXCI6IFwiXjIuNi4xXCIsXHJcbiAgICBcInNoZWxsanNcIjogXCJsYXRlc3RcIixcclxuICAgIFwic2lub25cIjogXCJeMi4wLjBcIixcclxuICAgIFwidWdsaWZ5LWpzXCI6IFwiXjIuNy4zXCIsXHJcbiAgICBcIndhdGNoaWZ5XCI6IFwiMy43LjBcIlxyXG4gIH0sXHJcbiAgXCJlbmdpbmVzXCI6IHtcclxuICAgIFwibm9kZVwiOiBcIj49Ni45LjBcIlxyXG4gIH0sXHJcbiAgXCJicm93c2VyaWZ5XCI6IHtcclxuICAgIFwidHJhbnNmb3JtXCI6IFtcclxuICAgICAgXCJiYWJlbGlmeVwiXHJcbiAgICBdXHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBDYW1lcmFzIGZyb20gJy4vY2FtZXJhcy9jYW1lcmFzJztcclxuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4vY29udHJvbHMvY29udHJvbHMnO1xyXG5pbXBvcnQgQ29yZSBmcm9tICcuL2NvcmUvY29yZSc7XHJcbmltcG9ydCBHZW9tZXRyaWVzIGZyb20gJy4vZ2VvbWV0cmllcy9nZW9tZXRyaWVzJztcclxuaW1wb3J0IEhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzL2hlbHBlcnMnO1xyXG5pbXBvcnQgTG9hZGVycyBmcm9tICcuL2xvYWRlcnMvbG9hZGVycyc7XHJcbmltcG9ydCBNb2RlbHMgZnJvbSAnLi9tb2RlbHMvbW9kZWxzJztcclxuaW1wb3J0IFBhcnNlcnMgZnJvbSAnLi9wYXJzZXJzL3BhcnNlcnMnO1xyXG5pbXBvcnQgU2hhZGVycyBmcm9tICcuL3NoYWRlcnMvc2hhZGVycyc7XHJcbmltcG9ydCBXaWRnZXRzIGZyb20gJy4vd2lkZ2V0cy93aWRnZXRzJztcclxuXHJcbmNvbnN0IHBja2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0e1xyXG4gIENhbWVyYXMsXHJcbiAgQ29udHJvbHMsXHJcbiAgQ29yZSxcclxuICBHZW9tZXRyaWVzLFxyXG4gIEhlbHBlcnMsXHJcbiAgTG9hZGVycyxcclxuICBNb2RlbHMsXHJcbiAgUGFyc2VycyxcclxuICBTaGFkZXJzLFxyXG4gIFdpZGdldHMsXHJcbn07XHJcblxyXG53aW5kb3cuY29uc29sZS5sb2coYEFNSSAke3Bja2cudmVyc2lvbn0gKCBUaHJlZUpTICR7cGNrZy5jb25maWcudGhyZWVWZXJzaW9ufSlgKTtcclxuIiwiaW1wb3J0IE9ydGhvZ3JhcGhpYyBmcm9tICcuL2NhbWVyYXMub3J0aG9ncmFwaGljJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGNhbWVyYXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBPcnRob2dyYXBoaWMsXHJcbn07XHJcbiIsImltcG9ydCBJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcclxuaW1wb3J0IFZhbGlkYXRvcnMgZnJvbSAnLi4vY29yZS9jb3JlLnZhbGlkYXRvcnMnO1xyXG5cclxuLyoqXHJcbiAqIE9ydGhvZ3JhcGhpYyBjYW1lcmEgZnJvbSBUSFJFRS5KUyB3aXRoIHNvbWUgZXh0cmEgY29udmVuaWVuY2VcclxuICogZnVuY3Rpb25hbGl0aWVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvL1xyXG4gKiAvL1xyXG4gKlxyXG4gKiBAbW9kdWxlIGNhbWVyYXMvb3J0aG9ncmFwaGljXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW1lcmFzT3J0aG9ncmFwaGljIGV4dGVuZHMgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhIHtcclxuICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcikge1xyXG4gICAgc3VwZXIobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIpO1xyXG5cclxuICAgIHRoaXMuX2Zyb250ID0gbnVsbDtcclxuICAgIHRoaXMuX2JhY2sgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2RpcmVjdGlvbnMgPSBbXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApLFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSksXHJcbiAgICAgIF07XHJcblxyXG4gICAgdGhpcy5fZGlyZWN0aW9uc0xhYmVsID0gW1xyXG4gICAgICAnQScsICdQJywgLy8gVE9QL0JPVFRPTVxyXG4gICAgICAnTCcsICdSJywgLy8gTEVGVC9SSUdIVFxyXG4gICAgICAnSScsICdTJywgLy8gRlJPTS9UT1xyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdkZWZhdWx0JztcclxuICAgIHRoaXMuX2NvbnZlbnRpb24gPSAncmFkaW8nO1xyXG4gICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDA7XHJcblxyXG4gICAgdGhpcy5fcmlnaHQgPSBudWxsO1xyXG4gICAgdGhpcy5fdXAgPSBudWxsO1xyXG4gICAgdGhpcy5fZGlyZWN0aW9uID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9jb250cm9scyA9IG51bGw7XHJcbiAgICB0aGlzLl9ib3ggPSBudWxsO1xyXG4gICAgdGhpcy5fY2FudmFzID0ge1xyXG4gICAgICB3aWR0aDogbnVsbCxcclxuICAgICAgaGVpZ2h0OiBudWxsLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9mcm9tRnJvbnQgPSB0cnVlO1xyXG4gICAgdGhpcy5fYW5nbGUgPSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBvcnRob2dyYXBoaWMgY2FtZXJhIHZhcmlhYmxlc1xyXG4gICAqL1xyXG4gIGluaXQoeENvc2luZSwgeUNvc2luZSwgekNvc2luZSwgY29udHJvbHMsIGJveCwgY2FudmFzKSB7XHJcbiAgICAvLyBERVBSRUNBVEVEXHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgIGBjYW1lcmFzLm9ydGhvZ3JhcGhpYy5pbml0KC4uLikgaXMgZGVwcmVjYXRlZC5cclxuICAgICAgVXNlIC5jb3NpbmVzLCAuY29udHJvbHMsIC5ib3ggYW5kIC5jYW52YXMgaW5zdGVhZC5gKTtcclxuXHJcbiAgICAvL1xyXG4gICAgaWYgKCEoVmFsaWRhdG9ycy52ZWN0b3IzKHhDb3NpbmUpICYmXHJcbiAgICAgIFZhbGlkYXRvcnMudmVjdG9yMyh5Q29zaW5lKSAmJlxyXG4gICAgICBWYWxpZGF0b3JzLnZlY3RvcjMoekNvc2luZSkgJiZcclxuICAgICAgVmFsaWRhdG9ycy5ib3goYm94KSAmJlxyXG4gICAgICBjb250cm9scykpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGlucHV0IHByb3ZpZGVkLicpO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3JpZ2h0ID0geENvc2luZTtcclxuICAgIHRoaXMuX3VwID0gdGhpcy5fYWRqdXN0VG9wRGlyZWN0aW9uKHhDb3NpbmUsIHlDb3NpbmUpO1xyXG4gICAgdGhpcy5fZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnModGhpcy5fcmlnaHQsIHRoaXMuX3VwKTtcclxuICAgIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgICB0aGlzLl9ib3ggPSBib3g7XHJcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XHJcblxyXG4gICAgbGV0IHJheSA9IHtcclxuICAgICAgcG9zaXRpb246IHRoaXMuX2JveC5jZW50ZXIsXHJcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5fZGlyZWN0aW9uLFxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9XHJcbiAgICAgIHRoaXMuX29yZGVySW50ZXJzZWN0aW9ucyhcclxuICAgICAgICBJbnRlcnNlY3Rpb25zLnJheUJveChyYXksIHRoaXMuX2JveCksXHJcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uKTtcclxuICAgIHRoaXMuX2Zyb250ID0gaW50ZXJzZWN0aW9uc1swXTtcclxuICAgIHRoaXMuX2JhY2sgPSBpbnRlcnNlY3Rpb25zWzFdO1xyXG5cclxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlc1xyXG4gICAgdGhpcy51cC5zZXQodGhpcy5fdXAueCwgdGhpcy5fdXAueSwgdGhpcy5fdXAueik7XHJcbiAgICB0aGlzLl91cGRhdGVDYW52YXMoKTtcclxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uQW5kVGFyZ2V0KHRoaXMuX2Zyb250LCB0aGlzLl9iYWNrKTtcclxuICAgIHRoaXMuX3VwZGF0ZU1hdHJpY2VzKCk7XHJcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoKSB7XHJcbiAgICAvLyBodHRwOi8vd3d3LmdyYWhhbXdpZGVtYW4uY29tL2d3L2JyYWluL29yaWVudGF0aW9uL29yaWVudHRlcm1zLmh0bVxyXG4gICAgLy8gZG8gbWFnaWNzIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbiBhbmQgY29udmVudGlvblxyXG4gICAgLy8gYWxzbyBuZWVkcyBhIGRlZmF1bHQgbW9kZVxyXG5cclxuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5fZ2V0TWF4SW5kZXgodGhpcy5fZGlyZWN0aW9uc1syXSkpIHtcclxuXHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnc2FnaXR0YWwnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ2Nvcm9uYWwnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ2F4aWFsJztcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnZnJlZSc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gJ2ZyZWUnKSB7XHJcbiAgICAgIHRoaXMuX3JpZ2h0ID0gdGhpcy5fZGlyZWN0aW9uc1swXTtcclxuICAgICAgdGhpcy5fdXAgPSB0aGlzLl9kaXJlY3Rpb25zWzFdO1xyXG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb25zWzJdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IGxlZnRJbmRleCA9IHRoaXMubGVmdERpcmVjdGlvbigpO1xyXG4gICAgICBsZXQgbGVmdERpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbnNbbGVmdEluZGV4XTtcclxuICAgICAgbGV0IHBvc3RlcmlvckluZGV4ID0gdGhpcy5wb3N0ZXJpb3JEaXJlY3Rpb24oKTtcclxuICAgICAgbGV0IHBvc3RlcmlvckRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbnNbcG9zdGVyaW9ySW5kZXhdO1xyXG4gICAgICBsZXQgc3VwZXJpb3JJbmRleCA9IHRoaXMuc3VwZXJpb3JEaXJlY3Rpb24oKTtcclxuICAgICAgbGV0IHN1cGVyaW9yRGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uc1tzdXBlcmlvckluZGV4XTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9jb252ZW50aW9uID09PSAncmFkaW8nKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuX29yaWVudGF0aW9uKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdheGlhbCc6XHJcbiAgICAgICAgICAgICAgLy8gdXAgdmVjdG9yIGlzICdhbnRlcmlvcidcclxuICAgICAgICAgICAgICBpZiAocG9zdGVyaW9yRGlyZWN0aW9uLnkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0ZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBsb29raW5nIHRvd2FyZHMgc3VwZXJpb3JcclxuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IGxlZnREaXJlY3Rpb247IC8vIGRvZXMgbm90IG1hdHRlciByaWdodC9sZWZ0XHJcbiAgICAgICAgICAgICAgdGhpcy5fdXAgPSBwb3N0ZXJpb3JEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gc3VwZXJpb3JEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdjb3JvbmFsJzpcclxuICAgICAgICAgICAgICAvLyB1cCB2ZWN0b3IgaXMgJ3N1cGVyaW9yJ1xyXG4gICAgICAgICAgICAgIGlmIChzdXBlcmlvckRpcmVjdGlvbi56IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3VwZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBsb29raW5nIHRvd2FyZHMgcG9zdGVyaW9yXHJcbiAgICAgICAgICAgICAgaWYgKHBvc3RlcmlvckRpcmVjdGlvbi55IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcG9zdGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IGxlZnREaXJlY3Rpb247IC8vIGRvZXMgbm90IG1hdHRlciByaWdodC9sZWZ0XHJcbiAgICAgICAgICAgICAgdGhpcy5fdXAgPSBzdXBlcmlvckRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBwb3N0ZXJpb3JEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdzYWdpdHRhbCc6XHJcbiAgICAgICAgICAgICAgLy8gdXAgdmVjdG9yIGlzICdzdXBlcmlvcidcclxuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIHJpZ2h0XHJcbiAgICAgICAgICAgICAgaWYgKGxlZnREaXJlY3Rpb24ueCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxlZnREaXJlY3Rpb24ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcG9zdGVyaW9yRGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxyXG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gc3VwZXJpb3JEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gbGVmdERpcmVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgICAgIGBcIiR7dGhpcy5fb3JpZW50YXRpb259XCIgb3JpZW50YXRpb24gaXMgbm90IHZhbGlkLlxyXG4gICAgICAgICAgICAgICAgKGNob2ljZXM6IGF4aWFsLCBjb3JvbmFsLCBzYWdpdHRhbClgKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fY29udmVudGlvbiA9PT0gJ25ldXJvJykge1xyXG4gICAgICAgICAgc3dpdGNoICh0aGlzLl9vcmllbnRhdGlvbikge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYXhpYWwnOlxyXG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnYW50ZXJpb3InXHJcbiAgICAgICAgICAgICAgaWYgKHBvc3RlcmlvckRpcmVjdGlvbi55ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcG9zdGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIGluZmVyaW9yXHJcbiAgICAgICAgICAgICAgaWYgKHN1cGVyaW9yRGlyZWN0aW9uLnogPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSBsZWZ0RGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxyXG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gcG9zdGVyaW9yRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHN1cGVyaW9yRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnY29yb25hbCc6XHJcbiAgICAgICAgICAgICAgLy8gdXAgdmVjdG9yIGlzICdzdXBlcmlvcidcclxuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIGFudGVyaW9yXHJcbiAgICAgICAgICAgICAgaWYgKHBvc3RlcmlvckRpcmVjdGlvbi55ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcG9zdGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IGxlZnREaXJlY3Rpb247IC8vIGRvZXMgbm90IG1hdHRlciByaWdodC9sZWZ0XHJcbiAgICAgICAgICAgICAgdGhpcy5fdXAgPSBzdXBlcmlvckRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBwb3N0ZXJpb3JEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdzYWdpdHRhbCc6XHJcbiAgICAgICAgICAgICAgLy8gdXAgdmVjdG9yIGlzICdzdXBlcmlvcidcclxuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIHJpZ2h0XHJcbiAgICAgICAgICAgICAgaWYgKGxlZnREaXJlY3Rpb24ueCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxlZnREaXJlY3Rpb24ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcG9zdGVyaW9yRGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxyXG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gc3VwZXJpb3JEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gbGVmdERpcmVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgICAgIGBcIiR7dGhpcy5fb3JpZW50YXRpb259XCIgb3JpZW50YXRpb24gaXMgbm90IHZhbGlkLlxyXG4gICAgICAgICAgICAgICAgKGNob2ljZXM6IGF4aWFsLCBjb3JvbmFsLCBzYWdpdHRhbClgKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICBgJHt0aGlzLl9jb252ZW50aW9ufSBpcyBub3QgdmFsaWQgKGNob2ljZXM6IHJhZGlvLCBuZXVybylgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoYXQgaXMgd2hhdCBkZXRlcm1pbmVzIGxlZnQvcmlnaHRcclxuICAgIGxldCByYXkgPSB7XHJcbiAgICAgIHBvc2l0aW9uOiB0aGlzLl9ib3guY2VudGVyLFxyXG4gICAgICBkaXJlY3Rpb246IHRoaXMuX2RpcmVjdGlvbixcclxuICAgIH07XHJcblxyXG4gICAgbGV0IGludGVyc2VjdGlvbnMgPVxyXG4gICAgICB0aGlzLl9vcmRlckludGVyc2VjdGlvbnMoXHJcbiAgICAgICAgSW50ZXJzZWN0aW9ucy5yYXlCb3gocmF5LCB0aGlzLl9ib3gpLFxyXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbik7XHJcbiAgICB0aGlzLl9mcm9udCA9IGludGVyc2VjdGlvbnNbMF07XHJcbiAgICB0aGlzLl9iYWNrID0gaW50ZXJzZWN0aW9uc1sxXTtcclxuXHJcbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXNcclxuICAgIHRoaXMudXAuc2V0KHRoaXMuX3VwLngsIHRoaXMuX3VwLnksIHRoaXMuX3VwLnopO1xyXG4gICAgdGhpcy5fdXBkYXRlQ2FudmFzKCk7XHJcbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldCh0aGlzLl9mcm9udCwgdGhpcy5fYmFjayk7XHJcbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xyXG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9ucygpO1xyXG4gIH1cclxuXHJcbiAgbGVmdERpcmVjdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9maW5kTWF4SW5kZXgodGhpcy5fZGlyZWN0aW9ucywgMCk7XHJcbiAgfVxyXG5cclxuICBwb3N0ZXJpb3JEaXJlY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnMsIDEpO1xyXG4gIH1cclxuXHJcbiAgc3VwZXJpb3JEaXJlY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnMsIDIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52ZXJ0IHJvd3MgaW4gdGhlIGN1cnJlbnQgc2xpY2UuXHJcbiAgICogSW52ZXJ0aW5nIHJvd3MgaW4gMiBzdGVwczpcclxuICAgKiAgICogRmxpcCB0aGUgXCJ1cFwiIHZlY3RvclxyXG4gICAqICAgKiBMb29rIGF0IHRoZSBzbGljZSBmcm9tIHRoZSBvdGhlciBzaWRlXHJcbiAgICovXHJcbiAgaW52ZXJ0Um93cygpIHtcclxuICAgIC8vIGZsaXAgXCJ1cFwiIHZlY3RvclxyXG4gICAgLy8gd2UgZmxpcCB1cCBmaXJzdCBiZWNhdXNlIGludmVydENvbHVtbnMgdXBkYXRlIHByb2plY3RpbyBtYXRyaWNlc1xyXG4gICAgdGhpcy51cC5tdWx0aXBseVNjYWxhcigtMSk7XHJcbiAgICB0aGlzLmludmVydENvbHVtbnMoKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZlcnQgcm93cyBpbiB0aGUgY3VycmVudCBzbGljZS5cclxuICAgKiBJbnZlcnRpbmcgcm93cyBpbiAxIHN0ZXA6XHJcbiAgICogICAqIExvb2sgYXQgdGhlIHNsaWNlIGZyb20gdGhlIG90aGVyIHNpZGVcclxuICAgKi9cclxuICBpbnZlcnRDb2x1bW5zKCkge1xyXG4gICAgdGhpcy5jZW50ZXIoKTtcclxuICAgIC8vIHJvdGF0ZSAxODAgZGVncmVlcyBhcm91bmQgdGhlIHVwIHZlY3Rvci4uLlxyXG4gICAgbGV0IG9wcG9zaXRlUG9zaXRpb24gPSB0aGlzLl9vcHBvc2l0ZVBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBwb3Npc3Rpb24gYW5kIHRhcmdldFxyXG4gICAgLy8gY2xvbmUgaXMgbmVlZGVkIGJlY2F1c2UgdGhpcy5wb3NpdGlvbiBpcyBvdmVyd3JpdHRlbiBpbiBtZXRob2RcclxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uQW5kVGFyZ2V0KG9wcG9zaXRlUG9zaXRpb24sIHRoaXMucG9zaXRpb24uY2xvbmUoKSk7XHJcbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xyXG4gICAgdGhpcy5fZnJvbUZyb250ID0gIXRoaXMuX2Zyb21Gcm9udDtcclxuXHJcbiAgICB0aGlzLl9hbmdsZSAlPSAzNjA7XHJcbiAgICB0aGlzLl9hbmdsZSA9IDM2MCAtIHRoaXMuX2FuZ2xlO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbnMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENlbnRlciBzbGljZSBpbiB0aGUgY2FtZXJhIEZPVi5cclxuICAgKiBJdCBhbHNvIHVwZGF0ZXMgdGhlIGNvbnRyb2xsZXJzIHByb3Blcmx5LlxyXG4gICAqIFdlIGNhbiBjZW50ZXIgYSBjYW1lcmEgZnJvbSB0aGUgZnJvbnQgb3IgZnJvbSB0aGUgYmFjay5cclxuICAgKi9cclxuICBjZW50ZXIoKSB7XHJcbiAgICBpZiAodGhpcy5fZnJvbUZyb250KSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uQW5kVGFyZ2V0KHRoaXMuX2Zyb250LCB0aGlzLl9iYWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uQW5kVGFyZ2V0KHRoaXMuX2JhY2ssIHRoaXMuX2Zyb250KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xyXG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9ucygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGkvMiByb3RhdGlvbiBhcm91bmQgdGhlIHpDb3NpbmUgYXhpcy5cclxuICAgKiBDbG9jay13aXNlIHJvdGF0aW9uIGZyb20gdGhlIHVzZXIgcG9pbnQgb2Ygdmlldy5cclxuICAgKi9cclxuICByb3RhdGUoYW5nbGU9bnVsbCkge1xyXG4gICAgdGhpcy5jZW50ZXIoKTtcclxuXHJcbiAgICBsZXQgY29tcHV0ZWRBbmdsZSA9IDkwO1xyXG5cclxuICAgIGxldCBjbG9ja3dpc2UgPSAxO1xyXG4gICAgaWYgKCF0aGlzLl9mcm9tRnJvbnQpIHtcclxuICAgICAgY2xvY2t3aXNlID0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFuZ2xlID09PSBudWxsKSB7XHJcbiAgICAgIGNvbXB1dGVkQW5nbGUgKj0gLWNsb2Nrd2lzZTtcclxuICAgICAgdGhpcy5fYW5nbGUgKz0gOTA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb21wdXRlZEFuZ2xlID0gMzYwIC0gY2xvY2t3aXNlICogKGFuZ2xlIC0gdGhpcy5fYW5nbGUpO1xyXG4gICAgICB0aGlzLl9hbmdsZSA9IGFuZ2xlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2FuZ2xlICU9IDM2MDtcclxuXHJcbiAgICAvLyBSb3RhdGUgdGhlIHVwIHZlY3RvciBhcm91bmQgdGhlIFwiekNvc2luZVwiXHJcbiAgICBsZXQgcm90YXRpb24gPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvbkF4aXMoXHJcbiAgICAgIHRoaXMuX2RpcmVjdGlvbixcclxuICAgICAgY29tcHV0ZWRBbmdsZSAqIE1hdGguUEkvMTgwKTtcclxuICAgIHRoaXMudXAuYXBwbHlNYXRyaXg0KHJvdGF0aW9uKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xyXG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9ucygpO1xyXG4gIH1cclxuXHJcbiAgLy8gZGltZW5zaW9uc1swXSAvLyB3aWR0aFxyXG4gIC8vIGRpbWVuc2lvbnNbMV0gLy8gaGVpZ2h0XHJcbiAgLy8gZGlyZWN0aW9uPSAwIHdpZHRoLCAxIGhlaWdodCwgMiBiZXN0XHJcbiAgLy8gZmFjdG9yXHJcbiAgZml0Qm94KGRpcmVjdGlvbiA9IDAsIGZhY3Rvcj0xLjUpIHtcclxuICAgIC8vXHJcbiAgICAvLyBpZiAoIShkaW1lbnNpb25zICYmIGRpbWVuc2lvbnMubGVuZ3RoID49IDIpKSB7XHJcbiAgICAvLyAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBkaW1lbnNpb25zIGNvbnRhaW5lci4nKTtcclxuICAgIC8vICAgd2luZG93LmNvbnNvbGUubG9nKGRpbWVuc2lvbnMpO1xyXG5cclxuICAgIC8vICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vXHJcbiAgICBsZXQgem9vbSA9IDE7XHJcblxyXG4gICAgLy8gdXBkYXRlIHpvb21cclxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICB6b29tID0gZmFjdG9yICogdGhpcy5fY29tcHV0ZVpvb20odGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9yaWdodCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICB6b29tID0gZmFjdG9yICogdGhpcy5fY29tcHV0ZVpvb20odGhpcy5fY2FudmFzLmhlaWdodCwgdGhpcy5fdXApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgem9vbSA9IGZhY3RvciAqIChNYXRoLm1pbihcclxuICAgICAgICAgIHRoaXMuX2NvbXB1dGVab29tKHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fcmlnaHQpLFxyXG4gICAgICAgICAgdGhpcy5fY29tcHV0ZVpvb20odGhpcy5fY2FudmFzLmhlaWdodCwgdGhpcy5fdXApXHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF6b29tKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnpvb20gPSB6b29tO1xyXG5cclxuICAgIHRoaXMuY2VudGVyKCk7XHJcbiAgfVxyXG5cclxuICBfYWRqdXN0VG9wRGlyZWN0aW9uKGhvcml6b250YWxEaXJlY3Rpb24sIHZlcnRpY2FsRGlyZWN0aW9uKSB7XHJcbiAgICBjb25zdCB2TWF4SW5kZXggPSB0aGlzLl9nZXRNYXhJbmRleCh2ZXJ0aWNhbERpcmVjdGlvbik7XHJcblxyXG4gICAgLy8gc2hvdWxkIGhhbmRsZSB2TWF4IGluZGV4ID09PSAwXHJcbiAgICBpZiAoKHZNYXhJbmRleCA9PT0gMiAmJiB2ZXJ0aWNhbERpcmVjdGlvbi5nZXRDb21wb25lbnQodk1heEluZGV4KSA8IDApIHx8XHJcbiAgICAgICAgKHZNYXhJbmRleCA9PT0gMSAmJiB2ZXJ0aWNhbERpcmVjdGlvbi5nZXRDb21wb25lbnQodk1heEluZGV4KSA+IDApIHx8XHJcbiAgICAgICAgKHZNYXhJbmRleCA9PT0gMCAmJiB2ZXJ0aWNhbERpcmVjdGlvbi5nZXRDb21wb25lbnQodk1heEluZGV4KSA+IDApKSB7XHJcbiAgICAgIHZlcnRpY2FsRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgcmV0dXJuIHZlcnRpY2FsRGlyZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgX2dldE1heEluZGV4KHZlY3Rvcikge1xyXG4gICAgLy8gaW5pdCB3aXRoIFggdmFsdWVcclxuICAgIGxldCBtYXhWYWx1ZSA9IE1hdGguYWJzKHZlY3Rvci54KTtcclxuICAgIGxldCBpbmRleCA9IDA7XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKHZlY3Rvci55KSA+IG1heFZhbHVlKSB7XHJcbiAgICAgIG1heFZhbHVlID0gTWF0aC5hYnModmVjdG9yLnkpO1xyXG4gICAgICBpbmRleCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKHZlY3Rvci56KSA+IG1heFZhbHVlKSB7XHJcbiAgICAgIGluZGV4ID0gMjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbiAgfVxyXG5cclxuICBfZmluZE1heEluZGV4KGRpcmVjdGlvbnMsIHRhcmdldCkge1xyXG4gICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBtb3N0IHN1cGVyaW9yIGRpcmVjdGlvblxyXG4gICAgbGV0IG1heEluZGljZXMgPSB0aGlzLl9nZXRNYXhJbmRpY2VzKGRpcmVjdGlvbnMpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4SW5kaWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAobWF4SW5kaWNlc1tpXSA9PT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9nZXRNYXhJbmRpY2VzKGRpcmVjdGlvbnMpIHtcclxuICAgIGxldCBpbmRpY2VzID0gW107XHJcbiAgICBpbmRpY2VzLnB1c2godGhpcy5fZ2V0TWF4SW5kZXgoZGlyZWN0aW9uc1swXSkpO1xyXG4gICAgaW5kaWNlcy5wdXNoKHRoaXMuX2dldE1heEluZGV4KGRpcmVjdGlvbnNbMV0pKTtcclxuICAgIGluZGljZXMucHVzaCh0aGlzLl9nZXRNYXhJbmRleChkaXJlY3Rpb25zWzJdKSk7XHJcblxyXG4gICAgcmV0dXJuIGluZGljZXM7XHJcbiAgfVxyXG5cclxuICBfb3JkZXJJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIGRpcmVjdGlvbikge1xyXG4gICAgY29uc3Qgb3JkZXJlZCA9XHJcbiAgICAgIGludGVyc2VjdGlvbnNbMF0uZG90KGRpcmVjdGlvbikgPCBpbnRlcnNlY3Rpb25zWzFdLmRvdChkaXJlY3Rpb24pO1xyXG5cclxuICAgIGlmICghb3JkZXJlZCkge1xyXG4gICAgICAgIHJldHVybiBbaW50ZXJzZWN0aW9uc1sxXSwgaW50ZXJzZWN0aW9uc1swXV07XHJcbiAgICB9XHJcblxyXG4gICByZXR1cm4gaW50ZXJzZWN0aW9ucztcclxuICB9XHJcblxyXG4gIF91cGRhdGVDYW52YXMoKSB7XHJcbiAgICBsZXQgY2FtRmFjdG9yID0gMjtcclxuICAgIHRoaXMubGVmdCA9IC10aGlzLl9jYW52YXMud2lkdGggLyBjYW1GYWN0b3I7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5fY2FudmFzLndpZHRoIC8gY2FtRmFjdG9yO1xyXG4gICAgdGhpcy50b3AgPSB0aGlzLl9jYW52YXMuaGVpZ2h0IC8gY2FtRmFjdG9yO1xyXG4gICAgdGhpcy5ib3R0b20gPSAtdGhpcy5fY2FudmFzLmhlaWdodCAvIGNhbUZhY3RvcjtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xyXG4gICAgdGhpcy5jb250cm9scy5oYW5kbGVSZXNpemUoKTtcclxuICB9XHJcblxyXG4gIF9vcHBvc2l0ZVBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICBsZXQgb3Bwb3NpdGVQb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICAvLyBjZW50ZXIgd29ybGQgcG9zdGlvbiBhcm91bmQgYm94IGNlbnRlclxyXG4gICAgb3Bwb3NpdGVQb3NpdGlvbi5zdWIodGhpcy5fYm94LmNlbnRlcik7XHJcbiAgICAvLyByb3RhdGVcclxuICAgIGxldCByb3RhdGlvbiA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVJvdGF0aW9uQXhpcyhcclxuICAgICAgdGhpcy51cCxcclxuICAgICAgTWF0aC5QSSk7XHJcblxyXG4gICAgb3Bwb3NpdGVQb3NpdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb24pO1xyXG4gICAgLy8gdHJhbnNsYXRlIGJhY2sgdG8gd29ybGQgcG9zaXRpb25cclxuICAgIG9wcG9zaXRlUG9zaXRpb24uYWRkKHRoaXMuX2JveC5jZW50ZXIpO1xyXG4gICAgcmV0dXJuIG9wcG9zaXRlUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBfY29tcHV0ZVpvb20oZGltZW5zaW9uLCBkaXJlY3Rpb24pIHtcclxuICAgIGlmICghKGRpbWVuc2lvbiAmJiBkaW1lbnNpb24gPiAwKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgZGltZW5zaW9uIHByb3ZpZGVkLicpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coZGltZW5zaW9uKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJheVxyXG4gICAgbGV0IHJheSA9IHtcclxuICAgICAgcG9zaXRpb246IHRoaXMuX2JveC5jZW50ZXIuY2xvbmUoKSxcclxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBpbnRlcnNlY3Rpb25zID0gSW50ZXJzZWN0aW9ucy5yYXlCb3gocmF5LCB0aGlzLl9ib3gpO1xyXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoIDwgMikge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0NhbiBub3QgYWRqdXN0IHRoZSBjYW1lcmEgKCA8IDIgaW50ZXJzZWN0aW9ucykuJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhyYXkpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fYm94KTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkaW1lbnNpb24gLyBpbnRlcnNlY3Rpb25zWzBdLmRpc3RhbmNlVG8oaW50ZXJzZWN0aW9uc1sxXSk7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlUG9zaXRpb25BbmRUYXJnZXQocG9zaXRpb24sIHRhcmdldCkge1xyXG4gICAgICAvLyBwb3NpdGlvblxyXG4gICAgICB0aGlzLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcclxuXHJcbiAgICAgIC8vIHRhcmdldHNcclxuICAgICAgdGhpcy5sb29rQXQodGFyZ2V0LngsIHRhcmdldC55LCB0YXJnZXQueik7XHJcbiAgICAgIHRoaXMuX2NvbnRyb2xzLnRhcmdldC5zZXQodGFyZ2V0LngsIHRhcmdldC55LCB0YXJnZXQueik7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlTWF0cmljZXMoKSB7XHJcbiAgICB0aGlzLl9jb250cm9scy51cGRhdGUoKTtcclxuICAgIC8vIFRIRU4gY2FtZXJhXHJcbiAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVMYWJlbHMoKSB7XHJcbiAgICB0aGlzLl9kaXJlY3Rpb25zTGFiZWwgPSBbXHJcbiAgICAgIHRoaXMuX3ZlY3RvcjJMYWJlbCh0aGlzLl91cCksXHJcbiAgICAgIHRoaXMuX3ZlY3RvcjJMYWJlbCh0aGlzLl91cC5jbG9uZSgpLm5lZ2F0ZSgpKSxcclxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX3JpZ2h0KSxcclxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX3JpZ2h0LmNsb25lKCkubmVnYXRlKCkpLFxyXG4gICAgICB0aGlzLl92ZWN0b3IyTGFiZWwodGhpcy5fZGlyZWN0aW9uKSxcclxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX2RpcmVjdGlvbi5jbG9uZSgpLm5lZ2F0ZSgpKSxcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICBfdmVjdG9yMkxhYmVsKGRpcmVjdGlvbikge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9nZXRNYXhJbmRleChkaXJlY3Rpb24pO1xyXG4gICAgLy8gc2V0IHZlY3RvciBtYXggdmFsdWUgdG8gMVxyXG4gICAgY29uc3Qgc2NhbGVkRGlyZWN0aW9uID1cclxuICAgICAgZGlyZWN0aW9uLmNsb25lKCkuZGl2aWRlU2NhbGFyKE1hdGguYWJzKGRpcmVjdGlvbi5nZXRDb21wb25lbnQoaW5kZXgpKSk7XHJcbiAgICBjb25zdCBkZWx0YSA9IDAuMjtcclxuICAgIGxldCBsYWJlbCA9ICcnO1xyXG5cclxuICAgIC8vIGxvb3AgdGhyb3VnaCBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcclxuICAgIGZvciAobGV0IGkgPSAwOyBpPDM7IGkrKykge1xyXG4gICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgIGlmIChzY2FsZWREaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGkpICsgZGVsdGEgPj0gMSkge1xyXG4gICAgICAgICAgbGFiZWwgKz0gJ0wnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSAtIGRlbHRhIDw9IC0xKSB7XHJcbiAgICAgICAgICBsYWJlbCArPSAnUic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChzY2FsZWREaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGkpICsgZGVsdGEgPj0gMSkge1xyXG4gICAgICAgICAgbGFiZWwgKz0gJ1AnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSAtIGRlbHRhIDw9IC0xKSB7XHJcbiAgICAgICAgICBsYWJlbCArPSAnQSc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaSA9PT0gMikge1xyXG4gICAgICAgIGlmIChzY2FsZWREaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGkpICsgZGVsdGEgPj0gMSkge1xyXG4gICAgICAgICAgbGFiZWwgKz0gJ1MnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSAtIGRlbHRhIDw9IC0xKSB7XHJcbiAgICAgICAgICBsYWJlbCArPSAnSSc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxhYmVsO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZURpcmVjdGlvbnMoKSB7XHJcbiAgICAvLyB1cCBpcyBjb3JyZWN0XHJcbiAgICB0aGlzLl91cCA9IHRoaXMudXAuY2xvbmUoKTtcclxuXHJcbiAgICAvLyBkaXJlY3Rpb25cclxuICAgIGxldCBwTG9jYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtMSk7XHJcbiAgICBsZXQgcFdvcmxkID0gcExvY2FsLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcclxuICAgIHRoaXMuX2RpcmVjdGlvbiA9IHBXb3JsZC5zdWIodGhpcy5wb3NpdGlvbikubm9ybWFsaXplKCk7XHJcblxyXG4gICAgLy8gcmlnaHRcclxuICAgIHRoaXMuX3JpZ2h0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnModGhpcy5fZGlyZWN0aW9uLCB0aGlzLnVwKTtcclxuXHJcbiAgICAvLyB1cGRhdGUgbGFiZWxzIGFjY29yZGluZ2x5XHJcbiAgICB0aGlzLl91cGRhdGVMYWJlbHMoKTtcclxuICB9XHJcblxyXG4gIHNldCBjb250cm9scyhjb250cm9scykge1xyXG4gICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcclxuICB9XHJcblxyXG4gIGdldCBjb250cm9scygpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb250cm9scztcclxuICB9XHJcblxyXG4gIHNldCBib3goYm94KSB7XHJcbiAgICB0aGlzLl9ib3ggPSBib3g7XHJcbiAgfVxyXG5cclxuICBnZXQgYm94KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JveDtcclxuICB9XHJcblxyXG4gIHNldCBjYW52YXMoY2FudmFzKSB7XHJcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XHJcbiAgICB0aGlzLl91cGRhdGVDYW52YXMoKTtcclxuICB9XHJcblxyXG4gIGdldCBjYW52YXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xyXG4gIH1cclxuXHJcbiAgc2V0IGFuZ2xlKGFuZ2xlKSB7XHJcbiAgICB0aGlzLnJvdGF0ZShhbmdsZSk7XHJcbiAgfVxyXG5cclxuICBnZXQgYW5nbGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYW5nbGU7XHJcbiAgfVxyXG5cclxuICBzZXQgZGlyZWN0aW9ucyhkaXJlY3Rpb25zKSB7XHJcbiAgICB0aGlzLl9kaXJlY3Rpb25zID0gZGlyZWN0aW9ucztcclxuICB9XHJcblxyXG4gIGdldCBkaXJlY3Rpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbnM7XHJcbiAgfVxyXG5cclxuICBzZXQgY29udmVudGlvbihjb252ZW50aW9uKSB7XHJcbiAgICB0aGlzLl9jb252ZW50aW9uID0gY29udmVudGlvbjtcclxuICB9XHJcblxyXG4gIGdldCBjb252ZW50aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbnZlbnRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgb3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcclxuICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgfVxyXG5cclxuICBnZXQgb3JpZW50YXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgZGlyZWN0aW9uc0xhYmVsKGRpcmVjdGlvbnNMYWJlbCkge1xyXG4gICAgdGhpcy5fZGlyZWN0aW9uc0xhYmVsID0gZGlyZWN0aW9uc0xhYmVsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpcmVjdGlvbnNMYWJlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb25zTGFiZWw7XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhY2tPcmllbnRhdGlvbihzdGFja09yaWVudGF0aW9uKSB7XHJcbiAgICB0aGlzLl9zdGFja09yaWVudGF0aW9uID0gc3RhY2tPcmllbnRhdGlvbjtcclxuXHJcbiAgICBpZiAodGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9PT0gMCkge1xyXG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdkZWZhdWx0JztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IG1heEluZGV4ID1cclxuICAgICAgICB0aGlzLl9nZXRNYXhJbmRleChcclxuICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbnNbKHRoaXMuX3N0YWNrT3JpZW50YXRpb24gKyAyKSAlIDNdKTtcclxuXHJcbiAgICAgIGlmIChtYXhJbmRleCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ3NhZ2l0dGFsJztcclxuICAgICAgfSBlbHNlIGlmIChtYXhJbmRleCA9PT0gMSkge1xyXG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ2Nvcm9uYWwnO1xyXG4gICAgICB9IGVsc2UgaWYgKG1heEluZGV4ID09PSAyKSB7XHJcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnYXhpYWwnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgc3RhY2tPcmllbnRhdGlvbigpIHtcclxuICAgIC8vXHJcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICB0aGlzLl9zdGFja09yaWVudGF0aW9uID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBtYXhJbmRleCA9IHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbik7XHJcblxyXG4gICAgICBpZiAobWF4SW5kZXggPT09IHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnNbMl0pKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAobWF4SW5kZXggPT09IHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnNbMF0pKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDE7XHJcbiAgICAgIH0gZWxzZSBpZiAobWF4SW5kZXggPT09IHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnNbMV0pKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tPcmllbnRhdGlvbjtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBUcmFja2JhbGwgZnJvbSAnLi9jb250cm9scy50cmFja2JhbGwnO1xyXG5pbXBvcnQgVHJhY2tiYWxsT3J0aG8gZnJvbSAnLi9jb250cm9scy50cmFja2JhbGxvcnRobyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgVHJhY2tiYWxsLFxyXG4gIFRyYWNrYmFsbE9ydGhvLFxyXG59O1xyXG4iLCIvKipcclxuICogT3JpZ2luYWwgYXV0aG9ycyBmcm9tIFRIUkVFSlMgcmVwb1xyXG4gKiBAYXV0aG9yIEViZXJoYXJkIEdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgTWFyayBMdW5kaW4gIC8gaHR0cDovL21hcmstbHVuZGluLmNvbVxyXG4gKiBAYXV0aG9yIFNpbW9uZSBNYW5pbmkgLyBodHRwOi8vZGFyb24xMzM3LmdpdGh1Yi5pb1xyXG4gKiBAYXV0aG9yIEx1Y2EgQW50aWdhICAvIGh0dHA6Ly9sYW50aWdhLmdpdGh1Yi5pb1xyXG4gKi9cclxuXHJcbiBleHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFja2JhbGwgZXh0ZW5kcyBUSFJFRS5FdmVudERpc3BhdGNoZXIge1xyXG4gIGNvbnN0cnVjdG9yKG9iamVjdCwgZG9tRWxlbWVudCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xyXG4gICAgbGV0IFNUQVRFID0ge05PTkU6IC0xLCBST1RBVEU6IDAsIFpPT006IDEsIFBBTjogMiwgVE9VQ0hfUk9UQVRFOiAzLCBUT1VDSF9aT09NOiA0LCBUT1VDSF9QQU46IDUsIENVU1RPTTogOTl9O1xyXG5cclxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgdGhpcy5kb21FbGVtZW50ID0gKGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XHJcblxyXG4gICAgLy8gQVBJXHJcblxyXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnNjcmVlbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9O1xyXG5cclxuICAgIHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XHJcbiAgICB0aGlzLnpvb21TcGVlZCA9IDEuMjtcclxuICAgIHRoaXMucGFuU3BlZWQgPSAwLjM7XHJcblxyXG4gICAgdGhpcy5ub1JvdGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5ub1pvb20gPSBmYWxzZTtcclxuICAgIHRoaXMubm9QYW4gPSBmYWxzZTtcclxuICAgIHRoaXMubm9DdXN0b20gPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmZvcmNlU3RhdGUgPSAtMTtcclxuXHJcbiAgICB0aGlzLnN0YXRpY01vdmluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5keW5hbWljRGFtcGluZ0ZhY3RvciA9IDAuMjtcclxuXHJcbiAgICB0aGlzLm1pbkRpc3RhbmNlID0gMDtcclxuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcclxuXHJcbiAgICB0aGlzLmtleXMgPSBbNjUgLyogQSovLCA4MyAvKiBTKi8sIDY4XTtcclxuXHJcbiAgICAvLyBpbnRlcm5hbHNcclxuXHJcbiAgICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgbGV0IEVQUyA9IDAuMDAwMDAxO1xyXG5cclxuICAgIGxldCBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIGxldCBfc3RhdGUgPSBTVEFURS5OT05FLFxyXG4gICAgX3ByZXZTdGF0ZSA9IFNUQVRFLk5PTkUsXHJcblxyXG4gICAgX2V5ZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG4gICAgX21vdmVQcmV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICAgIF9tb3ZlQ3VyciA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcblxyXG4gICAgX2xhc3RBeGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgIF9sYXN0QW5nbGUgPSAwLFxyXG5cclxuICAgIF96b29tU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gICAgX3pvb21FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG5cclxuICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gMCxcclxuICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IDAsXHJcblxyXG4gICAgX3BhblN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICAgIF9wYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG5cclxuICAgIF9jdXN0b21TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAgICBfY3VzdG9tRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbiAgICAvLyBmb3IgcmVzZXRcclxuXHJcbiAgICB0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xyXG4gICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xyXG4gICAgdGhpcy51cDAgPSB0aGlzLm9iamVjdC51cC5jbG9uZSgpO1xyXG5cclxuICAgIC8vIGV2ZW50c1xyXG5cclxuICAgIGxldCBjaGFuZ2VFdmVudCA9IHt0eXBlOiAnY2hhbmdlJ307XHJcbiAgICBsZXQgc3RhcnRFdmVudCA9IHt0eXBlOiAnc3RhcnQnfTtcclxuICAgIGxldCBlbmRFdmVudCA9IHt0eXBlOiAnZW5kJ307XHJcblxyXG4gICAgLy8gbWV0aG9kc1xyXG5cclxuICAgIHRoaXMuaGFuZGxlUmVzaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50KSB7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4ubGVmdCA9IDA7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4udG9wID0gMDtcclxuICAgICAgICB0aGlzLnNjcmVlbi53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgYm94ID0gdGhpcy5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIC8vIGFkanVzdG1lbnRzIGNvbWUgZnJvbSBzaW1pbGFyIGNvZGUgaW4gdGhlIGpxdWVyeSBvZmZzZXQoKSBmdW5jdGlvblxyXG4gICAgICAgIGxldCBkID0gdGhpcy5kb21FbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLmxlZnQgPSBib3gubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCAtIGQuY2xpZW50TGVmdDtcclxuICAgICAgICB0aGlzLnNjcmVlbi50b3AgPSBib3gudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IC0gZC5jbGllbnRUb3A7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSBib3gud2lkdGg7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gYm94LmhlaWdodDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzW2V2ZW50LnR5cGVdID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aGlzW2V2ZW50LnR5cGVdKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgZ2V0TW91c2VPblNjcmVlbiA9IChmdW5jdGlvbigpIHtcclxuICAgICAgbGV0IHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgdmVjdG9yLnNldChcclxuICAgICAgICAgICAgKHBhZ2VYIC0gX3RoaXMuc2NyZWVuLmxlZnQpIC8gX3RoaXMuc2NyZWVuLndpZHRoLFxyXG4gICAgICAgICAgICAocGFnZVkgLSBfdGhpcy5zY3JlZW4udG9wKSAvIF90aGlzLnNjcmVlbi5oZWlnaHRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICBsZXQgZ2V0TW91c2VPbkNpcmNsZSA9IChmdW5jdGlvbigpIHtcclxuICAgICAgbGV0IHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgdmVjdG9yLnNldChcclxuICAgICAgICAgICAgKChwYWdlWCAtIF90aGlzLnNjcmVlbi53aWR0aCAqIDAuNSAtIF90aGlzLnNjcmVlbi5sZWZ0KSAvIChfdGhpcy5zY3JlZW4ud2lkdGggKiAwLjUpKSxcclxuICAgICAgICAgICAgKChfdGhpcy5zY3JlZW4uaGVpZ2h0ICsgMiAqIChfdGhpcy5zY3JlZW4udG9wIC0gcGFnZVkpKSAvIF90aGlzLnNjcmVlbi53aWR0aCkgLy8gc2NyZWVuLndpZHRoIGludGVudGlvbmFsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgdGhpcy5yb3RhdGVDYW1lcmEgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGxldCBheGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICAgIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLFxyXG4gICAgICAgICAgZXllRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICAgIG9iamVjdFVwRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICAgIG9iamVjdFNpZGV3YXlzRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICAgIG1vdmVEaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgYW5nbGU7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbW92ZURpcmVjdGlvbi5zZXQoX21vdmVDdXJyLnggLSBfbW92ZVByZXYueCwgX21vdmVDdXJyLnkgLSBfbW92ZVByZXYueSwgMCk7XHJcbiAgICAgICAgYW5nbGUgPSBtb3ZlRGlyZWN0aW9uLmxlbmd0aCgpO1xyXG5cclxuICAgICAgICBpZiAoYW5nbGUpIHtcclxuICAgICAgICAgIF9leWUuY29weShfdGhpcy5vYmplY3QucG9zaXRpb24pLnN1YihfdGhpcy50YXJnZXQpO1xyXG5cclxuICAgICAgICAgIGV5ZURpcmVjdGlvbi5jb3B5KF9leWUpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgb2JqZWN0VXBEaXJlY3Rpb24uY29weShfdGhpcy5vYmplY3QudXApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgb2JqZWN0U2lkZXdheXNEaXJlY3Rpb24uY3Jvc3NWZWN0b3JzKG9iamVjdFVwRGlyZWN0aW9uLCBleWVEaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgIG9iamVjdFVwRGlyZWN0aW9uLnNldExlbmd0aChfbW92ZUN1cnIueSAtIF9tb3ZlUHJldi55KTtcclxuICAgICAgICAgIG9iamVjdFNpZGV3YXlzRGlyZWN0aW9uLnNldExlbmd0aChfbW92ZUN1cnIueCAtIF9tb3ZlUHJldi54KTtcclxuXHJcbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uLmNvcHkob2JqZWN0VXBEaXJlY3Rpb24uYWRkKG9iamVjdFNpZGV3YXlzRGlyZWN0aW9uKSk7XHJcblxyXG4gICAgICAgICAgYXhpcy5jcm9zc1ZlY3RvcnMobW92ZURpcmVjdGlvbiwgX2V5ZSkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgYW5nbGUgKj0gX3RoaXMucm90YXRlU3BlZWQ7XHJcbiAgICAgICAgICBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xyXG5cclxuICAgICAgICAgIF9leWUuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xyXG4gICAgICAgICAgX3RoaXMub2JqZWN0LnVwLmFwcGx5UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcclxuXHJcbiAgICAgICAgICBfbGFzdEF4aXMuY29weShheGlzKTtcclxuICAgICAgICAgIF9sYXN0QW5nbGUgPSBhbmdsZTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFfdGhpcy5zdGF0aWNNb3ZpbmcgJiYgX2xhc3RBbmdsZSkge1xyXG4gICAgICAgICAgX2xhc3RBbmdsZSAqPSBNYXRoLnNxcnQoMS4wIC0gX3RoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IpO1xyXG4gICAgICAgICAgX2V5ZS5jb3B5KF90aGlzLm9iamVjdC5wb3NpdGlvbikuc3ViKF90aGlzLnRhcmdldCk7XHJcbiAgICAgICAgICBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoX2xhc3RBeGlzLCBfbGFzdEFuZ2xlKTtcclxuICAgICAgICAgIF9leWUuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xyXG4gICAgICAgICAgX3RoaXMub2JqZWN0LnVwLmFwcGx5UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XHJcbiAgICAgIH07XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIHRoaXMuem9vbUNhbWVyYSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBsZXQgZmFjdG9yO1xyXG5cclxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuVE9VQ0hfWk9PTSkge1xyXG4gICAgICAgIGZhY3RvciA9IF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0IC8gX3RvdWNoWm9vbURpc3RhbmNlRW5kO1xyXG4gICAgICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kO1xyXG4gICAgICAgIF9leWUubXVsdGlwbHlTY2FsYXIoZmFjdG9yKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmYWN0b3IgPSAxLjAgKyAoX3pvb21FbmQueSAtIF96b29tU3RhcnQueSkgKiBfdGhpcy56b29tU3BlZWQ7XHJcblxyXG4gICAgICAgIGlmIChmYWN0b3IgIT09IDEuMCAmJiBmYWN0b3IgPiAwLjApIHtcclxuICAgICAgICAgIF9leWUubXVsdGlwbHlTY2FsYXIoZmFjdG9yKTtcclxuXHJcbiAgICAgICAgICBpZiAoX3RoaXMuc3RhdGljTW92aW5nKSB7XHJcbiAgICAgICAgICAgIF96b29tU3RhcnQuY29weShfem9vbUVuZCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfem9vbVN0YXJ0LnkgKz0gKF96b29tRW5kLnkgLSBfem9vbVN0YXJ0LnkpICogdGhpcy5keW5hbWljRGFtcGluZ0ZhY3RvcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wYW5DYW1lcmEgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGxldCBtb3VzZUNoYW5nZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAgICAgICAgICBvYmplY3RVcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICBwYW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIG1vdXNlQ2hhbmdlLmNvcHkoX3BhbkVuZCkuc3ViKF9wYW5TdGFydCk7XHJcblxyXG4gICAgICAgIGlmIChtb3VzZUNoYW5nZS5sZW5ndGhTcSgpKSB7XHJcbiAgICAgICAgICBtb3VzZUNoYW5nZS5tdWx0aXBseVNjYWxhcihfZXllLmxlbmd0aCgpICogX3RoaXMucGFuU3BlZWQpO1xyXG5cclxuICAgICAgICAgIHBhbi5jb3B5KF9leWUpLmNyb3NzKF90aGlzLm9iamVjdC51cCkuc2V0TGVuZ3RoKG1vdXNlQ2hhbmdlLngpO1xyXG4gICAgICAgICAgcGFuLmFkZChvYmplY3RVcC5jb3B5KF90aGlzLm9iamVjdC51cCkuc2V0TGVuZ3RoKG1vdXNlQ2hhbmdlLnkpKTtcclxuXHJcbiAgICAgICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uYWRkKHBhbik7XHJcbiAgICAgICAgICBfdGhpcy50YXJnZXQuYWRkKHBhbik7XHJcblxyXG4gICAgICAgICAgaWYgKF90aGlzLnN0YXRpY01vdmluZykge1xyXG4gICAgICAgICAgICBfcGFuU3RhcnQuY29weShfcGFuRW5kKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9wYW5TdGFydC5hZGQobW91c2VDaGFuZ2Uuc3ViVmVjdG9ycyhfcGFuRW5kLCBfcGFuU3RhcnQpLm11bHRpcGx5U2NhbGFyKF90aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICB0aGlzLmNoZWNrRGlzdGFuY2VzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghX3RoaXMubm9ab29tIHx8ICFfdGhpcy5ub1Bhbikge1xyXG4gICAgICAgIGlmIChfZXllLmxlbmd0aFNxKCkgPiBfdGhpcy5tYXhEaXN0YW5jZSAqIF90aGlzLm1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uYWRkVmVjdG9ycyhfdGhpcy50YXJnZXQsIF9leWUuc2V0TGVuZ3RoKF90aGlzLm1heERpc3RhbmNlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX2V5ZS5sZW5ndGhTcSgpIDwgX3RoaXMubWluRGlzdGFuY2UgKiBfdGhpcy5taW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmFkZFZlY3RvcnMoX3RoaXMudGFyZ2V0LCBfZXllLnNldExlbmd0aChfdGhpcy5taW5EaXN0YW5jZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBfZXllLnN1YlZlY3RvcnMoX3RoaXMub2JqZWN0LnBvc2l0aW9uLCBfdGhpcy50YXJnZXQpO1xyXG5cclxuICAgICAgaWYgKCFfdGhpcy5ub1JvdGF0ZSkge1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZUNhbWVyYSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIV90aGlzLm5vWm9vbSkge1xyXG4gICAgICAgIF90aGlzLnpvb21DYW1lcmEoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFfdGhpcy5ub1Bhbikge1xyXG4gICAgICAgIF90aGlzLnBhbkNhbWVyYSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIV90aGlzLm5vQ3VzdG9tKSB7XHJcbiAgICAgICAgX3RoaXMuY3VzdG9tKF9jdXN0b21TdGFydCwgX2N1c3RvbUVuZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGRWZWN0b3JzKF90aGlzLnRhcmdldCwgX2V5ZSk7XHJcblxyXG4gICAgICBfdGhpcy5jaGVja0Rpc3RhbmNlcygpO1xyXG5cclxuICAgICAgX3RoaXMub2JqZWN0Lmxvb2tBdChfdGhpcy50YXJnZXQpO1xyXG5cclxuICAgICAgaWYgKGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZChfdGhpcy5vYmplY3QucG9zaXRpb24pID4gRVBTKSB7XHJcbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XHJcblxyXG4gICAgICAgIGxhc3RQb3NpdGlvbi5jb3B5KF90aGlzLm9iamVjdC5wb3NpdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG4gICAgICBfcHJldlN0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcbiAgICAgIF90aGlzLnRhcmdldC5jb3B5KF90aGlzLnRhcmdldDApO1xyXG4gICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uY29weShfdGhpcy5wb3NpdGlvbjApO1xyXG4gICAgICBfdGhpcy5vYmplY3QudXAuY29weShfdGhpcy51cDApO1xyXG5cclxuICAgICAgX2V5ZS5zdWJWZWN0b3JzKF90aGlzLm9iamVjdC5wb3NpdGlvbiwgX3RoaXMudGFyZ2V0KTtcclxuXHJcbiAgICAgIF90aGlzLm9iamVjdC5sb29rQXQoX3RoaXMudGFyZ2V0KTtcclxuXHJcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xyXG5cclxuICAgICAgbGFzdFBvc2l0aW9uLmNvcHkoX3RoaXMub2JqZWN0LnBvc2l0aW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHRhcmdldFN0YXRlKSB7XHJcbiAgICAgIF90aGlzLmZvcmNlU3RhdGUgPSB0YXJnZXRTdGF0ZTtcclxuICAgICAgX3ByZXZTdGF0ZSA9IHRhcmdldFN0YXRlO1xyXG4gICAgICBfc3RhdGUgPSB0YXJnZXRTdGF0ZTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jdXN0b20gPSBmdW5jdGlvbihjdXN0b21TdGFydCwgY3VzdG9tRW5kKSB7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBsaXN0ZW5lcnNcclxuXHJcbiAgICBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duKTtcclxuXHJcbiAgICAgIF9wcmV2U3RhdGUgPSBfc3RhdGU7XHJcblxyXG4gICAgICBpZiAoX3N0YXRlICE9PSBTVEFURS5OT05FKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbU1RBVEUuUk9UQVRFXSAmJiAhX3RoaXMubm9Sb3RhdGUpIHtcclxuICAgICAgICBfc3RhdGUgPSBTVEFURS5ST1RBVEU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1tTVEFURS5aT09NXSAmJiAhX3RoaXMubm9ab29tKSB7XHJcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuWk9PTTtcclxuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzW1NUQVRFLlBBTl0gJiYgIV90aGlzLm5vUGFuKSB7XHJcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuUEFOO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBfc3RhdGUgPSBfcHJldlN0YXRlO1xyXG5cclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5OT05FKSB7XHJcbiAgICAgICAgX3N0YXRlID0gZXZlbnQuYnV0dG9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5ST1RBVEUgJiYgIV90aGlzLm5vUm90YXRlKSB7XHJcbiAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcclxuICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xyXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuWk9PTSAmJiAhX3RoaXMubm9ab29tKSB7XHJcbiAgICAgICAgX3pvb21TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgICAgX3pvb21FbmQuY29weShfem9vbVN0YXJ0KTtcclxuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlBBTiAmJiAhX3RoaXMubm9QYW4pIHtcclxuICAgICAgICBfcGFuU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xyXG4gICAgICAgIF9wYW5FbmQuY29weShfcGFuU3RhcnQpO1xyXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuQ1VTVE9NICYmICFfdGhpcy5ub0N1c3RvbSkge1xyXG4gICAgICAgIF9jdXN0b21TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgICAgX2N1c3RvbUVuZC5jb3B5KF9wYW5TdGFydCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSwgZmFsc2UpO1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCwgZmFsc2UpO1xyXG5cclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLlJPVEFURSAmJiAhX3RoaXMubm9Sb3RhdGUpIHtcclxuICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xyXG4gICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5aT09NICYmICFfdGhpcy5ub1pvb20pIHtcclxuICAgICAgICBfem9vbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5QQU4gJiYgIV90aGlzLm5vUGFuKSB7XHJcbiAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5DVVNUT00gJiYgIV90aGlzLm5vQ3VzdG9tKSB7XHJcbiAgICAgICAgX2N1c3RvbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3VzZXVwKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICBpZiAoX3RoaXMuZm9yY2VTdGF0ZSA9PT0gLTEpIHtcclxuICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCk7XHJcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdXNld2hlZWwoZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgIGxldCBkZWx0YSA9IDA7XHJcblxyXG4gICAgICBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xyXG4gLy8gV2ViS2l0IC8gT3BlcmEgLyBFeHBsb3JlciA5XHJcblxyXG4gICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvIDQwO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xyXG4gLy8gRmlyZWZveFxyXG5cclxuICAgICAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX3N0YXRlICE9PSBTVEFURS5DVVNUT00pIHtcclxuICAgICAgICBfem9vbVN0YXJ0LnkgKz0gZGVsdGEgKiAwLjAxO1xyXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuQ1VTVE9NKSB7XHJcbiAgICAgICAgX2N1c3RvbVN0YXJ0LnkgKz0gZGVsdGEgKiAwLjAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0KGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKF90aGlzLmZvcmNlU3RhdGUgPT09IC0xKSB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xyXG4gICAgICAgICAgICBfbW92ZUN1cnIuY29weShnZXRNb3VzZU9uQ2lyY2xlKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcclxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9aT09NO1xyXG4gICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcclxuICAgICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XHJcbiAgICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XHJcbiAgICAgICAgICAgIF9wYW5TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHsgTk9ORTogLTEsIFJPVEFURTogMCwgWk9PTTogMSwgUEFOOiAyLCBUT1VDSF9ST1RBVEU6IDMsIFRPVUNIX1pPT01fUEFOOiA0LCBDVVNUT006IDk5IH07XHJcbiAgICAgICAgc3dpdGNoIChfc3RhdGUpIHtcclxuXHJcbiAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIC8vIDEgb3IgMiBmaW5nZXJzLCBzbWFlIGJlaGF2aW9yXHJcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcclxuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9aT09NO1xyXG4gICAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xyXG4gICAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xyXG4gICAgICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5aT09NO1xyXG4gICAgICAgICAgICAgIF96b29tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcclxuICAgICAgICAgICAgICBfem9vbUVuZC5jb3B5KF96b29tU3RhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XHJcbiAgICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcclxuICAgICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xyXG4gICAgICAgICAgICAgIF9wYW5TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgICAgIF9wYW5FbmQuY29weShfcGFuU3RhcnQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlBBTjtcclxuICAgICAgICAgICAgICBfcGFuU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcclxuICAgICAgICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDk5OlxyXG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5DVVNUT007XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XHJcbiAgICAgICAgICAgIF9jdXN0b21TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgICBfY3VzdG9tRW5kLmNvcHkoX2N1c3RvbVN0YXJ0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvdWNobW92ZShldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgaWYgKF90aGlzLmZvcmNlU3RhdGUgPT09IC0xKSB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcclxuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdmFyIGR4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XHJcbiAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xyXG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcclxuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcclxuICAgICAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB7IE5PTkU6IC0xLCBST1RBVEU6IDAsIFpPT006IDEsIFBBTjogMiwgVE9VQ0hfUk9UQVRFOiAzLCBUT1VDSF9aT09NX1BBTjogNCwgQ1VTVE9NOiA5OSB9O1xyXG4gICAgICAgIHN3aXRjaCAoX3N0YXRlKSB7XHJcblxyXG4gICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xyXG4gICAgICAgICAgICBfbW92ZUN1cnIuY29weShnZXRNb3VzZU9uQ2lyY2xlKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBfem9vbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAvLyAyIGZpbmdlcnMhXHJcbiAgICAgICAgICAgIC8vIFRPVUNIIFpPT01cclxuICAgICAgICAgICAgdmFyIGR4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XHJcbiAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xyXG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgIC8vIDIgZmluZ2Vyc1xyXG4gICAgICAgICAgICAvLyBUT1VDSF9QQU5cclxuICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcclxuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcclxuICAgICAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDk5OlxyXG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xyXG4gICAgICAgICAgICBfY3VzdG9tRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvdWNoZW5kKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKF90aGlzLmZvcmNlU3RhdGUgPT09IC0xKSB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcclxuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSAwO1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcclxuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcclxuICAgICAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgICBfcGFuU3RhcnQuY29weShfcGFuRW5kKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzd2l0Y2ggKF9zdGF0ZSkge1xyXG5cclxuICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcclxuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAvLyBUT1VDSCBaT09NXHJcbiAgICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gMDtcclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuWk9PTTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAvLyBUT1VDSCBaT09NXHJcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcclxuICAgICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xyXG4gICAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgICAgICBfcGFuU3RhcnQuY29weShfcGFuRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5QQU47XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgOTk6XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XHJcbiAgICAgICAgICAgIF9jdXN0b21FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgICAgX2N1c3RvbVN0YXJ0LmNvcHkoX2N1c3RvbUVuZCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZXZlbnQpIHtcclxuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbn0sIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2Vkb3duLCBmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsLCBmYWxzZSk7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBtb3VzZXdoZWVsLCBmYWxzZSk7IC8vIGZpcmVmb3hcclxuXHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlKTtcclxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSk7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlLCBmYWxzZSk7XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duLCBmYWxzZSk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cCwgZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XHJcblxyXG4gICAgLy8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogQGF1dGhvciBFYmVyaGFyZCBHcmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIE1hcmsgTHVuZGluICAvIGh0dHA6Ly9tYXJrLWx1bmRpbi5jb21cclxuICogQGF1dGhvciBQYXRyaWNrIEZ1bGxlciAvIGh0dHA6Ly9wYXRyaWNrLWZ1bGxlci5jb21cclxuICogQGF1dGhvciBNYXggU21vbGVucyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9tc21vbGVuc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYWNrYmFsbG9ydGhvIGV4dGVuZHMgVEhSRUUuRXZlbnREaXNwYXRjaGVyIHtcclxuICBjb25zdHJ1Y3RvcihvYmplY3QsIGRvbUVsZW1lbnQsIHN0YXRlID0ge05PTkU6IC0xLCBST1RBVEU6IDEsIFpPT006IDIsIFBBTjogMCwgU0NST0xMOiA0LCBUT1VDSF9ST1RBVEU6IDQsIFRPVUNIX1pPT01fUEFOOiA1fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xyXG4gICAgbGV0IFNUQVRFID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSAoZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcclxuXHJcbiAgICAvLyBBUElcclxuXHJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc2NyZWVuID0ge2xlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG4gICAgdGhpcy5yYWRpdXMgPSAwO1xyXG5cclxuICAgIHRoaXMuem9vbVNwZWVkID0gMS4yO1xyXG5cclxuICAgIHRoaXMubm9ab29tID0gZmFsc2U7XHJcbiAgICB0aGlzLm5vUGFuID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5zdGF0aWNNb3ZpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IgPSAwLjI7XHJcblxyXG4gICAgdGhpcy5rZXlzID0gWzY1IC8qIEEqLywgODMgLyogUyovLCA2OF07XHJcblxyXG4gICAgLy8gaW50ZXJuYWxzXHJcblxyXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIGxldCBFUFMgPSAwLjAwMDAwMTtcclxuXHJcbiAgICBsZXQgX2NoYW5nZWQgPSB0cnVlO1xyXG5cclxuICAgIGxldCBfc3RhdGUgPSBTVEFURS5OT05FLFxyXG4gICAgX3ByZXZTdGF0ZSA9IFNUQVRFLk5PTkUsXHJcblxyXG4gICAgX2V5ZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG4gICAgX3pvb21TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAgICBfem9vbUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcblxyXG4gICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSAwLFxyXG4gICAgX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gMCxcclxuXHJcbiAgICBfcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gICAgX3BhbkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgLy8gd2luZG93IGxldmVsIGZpcmUgYWZ0ZXIuLi5cclxuXHJcbiAgICAvLyBmb3IgcmVzZXRcclxuXHJcbiAgICB0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xyXG4gICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xyXG4gICAgdGhpcy51cDAgPSB0aGlzLm9iamVjdC51cC5jbG9uZSgpO1xyXG5cclxuICAgIHRoaXMubGVmdDAgPSB0aGlzLm9iamVjdC5sZWZ0O1xyXG4gICAgdGhpcy5yaWdodDAgPSB0aGlzLm9iamVjdC5yaWdodDtcclxuICAgIHRoaXMudG9wMCA9IHRoaXMub2JqZWN0LnRvcDtcclxuICAgIHRoaXMuYm90dG9tMCA9IHRoaXMub2JqZWN0LmJvdHRvbTtcclxuXHJcbiAgICAvLyBldmVudHNcclxuXHJcbiAgICBsZXQgY2hhbmdlRXZlbnQgPSB7dHlwZTogJ2NoYW5nZSd9O1xyXG4gICAgbGV0IHN0YXJ0RXZlbnQgPSB7dHlwZTogJ3N0YXJ0J307XHJcbiAgICBsZXQgZW5kRXZlbnQgPSB7dHlwZTogJ2VuZCd9O1xyXG5cclxuICAgIC8vIG1ldGhvZHNcclxuXHJcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCkge1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLmxlZnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLnRvcCA9IDA7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGJveCA9IHRoaXMuZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAvLyBhZGp1c3RtZW50cyBjb21lIGZyb20gc2ltaWxhciBjb2RlIGluIHRoZSBqcXVlcnkgb2Zmc2V0KCkgZnVuY3Rpb25cclxuICAgICAgICBsZXQgZCA9IHRoaXMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICB0aGlzLnNjcmVlbi5sZWZ0ID0gYm94LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgLSBkLmNsaWVudExlZnQ7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4udG9wID0gYm94LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCAtIGQuY2xpZW50VG9wO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLndpZHRoID0gYm94LndpZHRoO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IGJveC5oZWlnaHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucmFkaXVzID0gMC41ICogTWF0aC5taW4odGhpcy5zY3JlZW4ud2lkdGgsIHRoaXMuc2NyZWVuLmhlaWdodCk7XHJcblxyXG4gICAgICB0aGlzLmxlZnQwID0gdGhpcy5vYmplY3QubGVmdDtcclxuICAgICAgdGhpcy5yaWdodDAgPSB0aGlzLm9iamVjdC5yaWdodDtcclxuICAgICAgdGhpcy50b3AwID0gdGhpcy5vYmplY3QudG9wO1xyXG4gICAgICB0aGlzLmJvdHRvbTAgPSB0aGlzLm9iamVjdC5ib3R0b207XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBpZiAodHlwZW9mIHRoaXNbZXZlbnQudHlwZV0gPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRoaXNbZXZlbnQudHlwZV0oZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBnZXRNb3VzZU9uU2NyZWVuID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICBsZXQgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRNb3VzZU9uU2NyZWVuKHBhZ2VYLCBwYWdlWSkge1xyXG4gICAgICAgIHZlY3Rvci5zZXQoXHJcbiAgICAgICAgICAocGFnZVggLSBfdGhpcy5zY3JlZW4ubGVmdCkgLyBfdGhpcy5zY3JlZW4ud2lkdGgsXHJcbiAgICAgICAgICAocGFnZVkgLSBfdGhpcy5zY3JlZW4udG9wKSAvIF90aGlzLnNjcmVlbi5oZWlnaHRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICB0aGlzLnpvb21DYW1lcmEgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuVE9VQ0hfWk9PTV9QQU4pIHtcclxuICAgICAgICB2YXIgZmFjdG9yID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kIC8gX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQ7XHJcbiAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSBfdG91Y2hab29tRGlzdGFuY2VFbmQ7XHJcblxyXG4gICAgICAgIF90aGlzLm9iamVjdC56b29tICo9IGZhY3RvcjtcclxuXHJcbiAgICAgICAgX2NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBmYWN0b3IgPSAxLjAgKyAoX3pvb21FbmQueSAtIF96b29tU3RhcnQueSkgKiBfdGhpcy56b29tU3BlZWQ7XHJcblxyXG4gICAgICAgIGlmIChNYXRoLmFicyhmYWN0b3IgLSAxLjApID4gRVBTICYmIGZhY3RvciA+IDAuMCkge1xyXG4gICAgICAgICAgX3RoaXMub2JqZWN0Lnpvb20gLz0gZmFjdG9yO1xyXG5cclxuICAgICAgICAgIGlmIChfdGhpcy5zdGF0aWNNb3ZpbmcpIHtcclxuICAgICAgICAgICAgX3pvb21TdGFydC5jb3B5KF96b29tRW5kKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF96b29tU3RhcnQueSArPSAoX3pvb21FbmQueSAtIF96b29tU3RhcnQueSkgKiB0aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wYW5DYW1lcmEgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGxldCBtb3VzZUNoYW5nZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAgICAgICAgb2JqZWN0VXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgIHBhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcGFuQ2FtZXJhKCkge1xyXG4gICAgICAgIG1vdXNlQ2hhbmdlLmNvcHkoX3BhbkVuZCkuc3ViKF9wYW5TdGFydCk7XHJcblxyXG4gICAgICAgIGlmIChtb3VzZUNoYW5nZS5sZW5ndGhTcSgpKSB7XHJcbiAgICAgICAgICAvLyBTY2FsZSBtb3ZlbWVudCB0byBrZWVwIGNsaWNrZWQvZHJhZ2dlZCBwb3NpdGlvbiB1bmRlciBjdXJzb3JcclxuICAgICAgICAgIGxldCBzY2FsZV94ID0gKF90aGlzLm9iamVjdC5yaWdodCAtIF90aGlzLm9iamVjdC5sZWZ0KSAvIF90aGlzLm9iamVjdC56b29tO1xyXG4gICAgICAgICAgbGV0IHNjYWxlX3kgPSAoX3RoaXMub2JqZWN0LnRvcCAtIF90aGlzLm9iamVjdC5ib3R0b20pIC8gX3RoaXMub2JqZWN0Lnpvb207XHJcbiAgICAgICAgICBtb3VzZUNoYW5nZS54ICo9IHNjYWxlX3g7XHJcbiAgICAgICAgICBtb3VzZUNoYW5nZS55ICo9IHNjYWxlX3k7XHJcblxyXG4gICAgICAgICAgcGFuLmNvcHkoX2V5ZSkuY3Jvc3MoX3RoaXMub2JqZWN0LnVwKS5zZXRMZW5ndGgobW91c2VDaGFuZ2UueCk7XHJcbiAgICAgICAgICBwYW4uYWRkKG9iamVjdFVwLmNvcHkoX3RoaXMub2JqZWN0LnVwKS5zZXRMZW5ndGgobW91c2VDaGFuZ2UueSkpO1xyXG5cclxuICAgICAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGQocGFuKTtcclxuICAgICAgICAgIF90aGlzLnRhcmdldC5hZGQocGFuKTtcclxuXHJcbiAgICAgICAgICBpZiAoX3RoaXMuc3RhdGljTW92aW5nKSB7XHJcbiAgICAgICAgICAgIF9wYW5TdGFydC5jb3B5KF9wYW5FbmQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3BhblN0YXJ0LmFkZChtb3VzZUNoYW5nZS5zdWJWZWN0b3JzKF9wYW5FbmQsIF9wYW5TdGFydCkubXVsdGlwbHlTY2FsYXIoX3RoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBfY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBfZXllLnN1YlZlY3RvcnMoX3RoaXMub2JqZWN0LnBvc2l0aW9uLCBfdGhpcy50YXJnZXQpO1xyXG5cclxuICAgICAgaWYgKCFfdGhpcy5ub1pvb20pIHtcclxuICAgICAgICBfdGhpcy56b29tQ2FtZXJhKCk7XHJcblxyXG4gICAgICAgIGlmIChfY2hhbmdlZCkge1xyXG4gICAgICAgICAgX3RoaXMub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghX3RoaXMubm9QYW4pIHtcclxuICAgICAgICBfdGhpcy5wYW5DYW1lcmEoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmFkZFZlY3RvcnMoX3RoaXMudGFyZ2V0LCBfZXllKTtcclxuXHJcbiAgICAgIF90aGlzLm9iamVjdC5sb29rQXQoX3RoaXMudGFyZ2V0KTtcclxuXHJcbiAgICAgIGlmIChfY2hhbmdlZCkge1xyXG4gICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xyXG5cclxuICAgICAgICBfY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcclxuICAgICAgX3ByZXZTdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICBfdGhpcy50YXJnZXQuY29weShfdGhpcy50YXJnZXQwKTtcclxuICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmNvcHkoX3RoaXMucG9zaXRpb24wKTtcclxuICAgICAgX3RoaXMub2JqZWN0LnVwLmNvcHkoX3RoaXMudXAwKTtcclxuXHJcbiAgICAgIF9leWUuc3ViVmVjdG9ycyhfdGhpcy5vYmplY3QucG9zaXRpb24sIF90aGlzLnRhcmdldCk7XHJcblxyXG4gICAgICBfdGhpcy5vYmplY3QubGVmdCA9IF90aGlzLmxlZnQwO1xyXG4gICAgICBfdGhpcy5vYmplY3QucmlnaHQgPSBfdGhpcy5yaWdodDA7XHJcbiAgICAgIF90aGlzLm9iamVjdC50b3AgPSBfdGhpcy50b3AwO1xyXG4gICAgICBfdGhpcy5vYmplY3QuYm90dG9tID0gX3RoaXMuYm90dG9tMDtcclxuXHJcbiAgICAgIF90aGlzLm9iamVjdC5sb29rQXQoX3RoaXMudGFyZ2V0KTtcclxuXHJcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xyXG5cclxuICAgICAgX2NoYW5nZWQgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gbGlzdGVuZXJzXHJcblxyXG4gICAgZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93bik7XHJcblxyXG4gICAgICBfcHJldlN0YXRlID0gX3N0YXRlO1xyXG5cclxuICAgICAgaWYgKF9zdGF0ZSAhPT0gU1RBVEUuTk9ORSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzW1NUQVRFLlJPVEFURV0gJiYgIV90aGlzLm5vUm90YXRlKSB7XHJcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuUk9UQVRFO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbU1RBVEUuWk9PTV0gJiYgIV90aGlzLm5vWm9vbSkge1xyXG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlpPT007XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1tTVEFURS5QQU5dICYmICFfdGhpcy5ub1Bhbikge1xyXG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlBBTjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGtleXVwKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgX3N0YXRlID0gX3ByZXZTdGF0ZTtcclxuXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93biwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bihldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuTk9ORSkge1xyXG4gICAgICAgIF9zdGF0ZSA9IGV2ZW50LmJ1dHRvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICYmICFfdGhpcy5ub1JvdGF0ZSkge1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlpPT00gJiYgIV90aGlzLm5vWm9vbSkge1xyXG4gICAgICAgIF96b29tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xyXG4gICAgICAgIF96b29tRW5kLmNvcHkoX3pvb21TdGFydCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5QQU4gJiYgIV90aGlzLm5vUGFuKSB7XHJcbiAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcclxuICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlLCBmYWxzZSk7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZXVwLCBmYWxzZSk7XHJcblxyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZShldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICYmICFfdGhpcy5ub1JvdGF0ZSkge1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlpPT00gJiYgIV90aGlzLm5vWm9vbSkge1xyXG4gICAgICAgIF96b29tRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcclxuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlBBTiAmJiAhX3RoaXMubm9QYW4pIHtcclxuICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdXNldXAoZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCk7XHJcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdXNld2hlZWwoZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgIGxldCBkZWx0YSA9IDA7XHJcblxyXG4gICAgICBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xyXG4gICAgICAgIC8vIFdlYktpdCAvIE9wZXJhIC8gRXhwbG9yZXIgOVxyXG5cclxuICAgICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyA0MDtcclxuICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcclxuICAgICAgICAvLyBGaXJlZm94XHJcblxyXG4gICAgICAgIGRlbHRhID0gLWV2ZW50LmRldGFpbCAvIDM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZJUkUgU0NST0xMIEVWRU5UXHJcblxyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHtcclxuICAgICAgICB0eXBlOiAnT25TY3JvbGwnLFxyXG4gICAgICAgIGRlbHRhOiBkZWx0YSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBfem9vbVN0YXJ0LnkgKz0gZGVsdGEgKiAwLjAxO1xyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0KGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlRPVUNIX1pPT01fUEFOO1xyXG4gICAgICAgICAgdmFyIGR4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XHJcbiAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcclxuICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuXHJcbiAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xyXG4gICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcclxuICAgICAgICAgIF9wYW5TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICB9XHJcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG91Y2htb3ZlKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgIGNhc2UgMTpcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgdmFyIGR4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XHJcbiAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcclxuICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcblxyXG4gICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcclxuICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XHJcbiAgICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG91Y2hlbmQoZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgIGNhc2UgMTpcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSAwO1xyXG5cclxuICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xyXG4gICAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgX3BhblN0YXJ0LmNvcHkoX3BhbkVuZCk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnRleHRtZW51KGV2ZW50KSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGNvbnRleHRtZW51LCBmYWxzZSk7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZWRvd24sIGZhbHNlKTtcclxuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsLCBmYWxzZSk7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgbW91c2V3aGVlbCwgZmFsc2UpOyAvLyBmaXJlZm94XHJcblxyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlKTtcclxuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlKTtcclxuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSwgZmFsc2UpO1xyXG5cclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlLCBmYWxzZSk7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZXVwLCBmYWxzZSk7XHJcblxyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24sIGZhbHNlKTtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywga2V5dXAsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgY29udGV4dG1lbnUsIGZhbHNlKTtcclxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZWRvd24sIGZhbHNlKTtcclxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbCwgZmFsc2UpO1xyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBtb3VzZXdoZWVsLCBmYWxzZSk7IC8vIGZpcmVmb3hcclxuXHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlKTtcclxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSk7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlLCBmYWxzZSk7XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duLCBmYWxzZSk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cCwgZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XHJcblxyXG4gICAgLy8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxufVxyXG5cclxuIiwiLyoqXHJcbiAqIENvbG9ycyB1dGlsaXR5IGZ1bmN0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JzIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBMQUIgdG8gWFlaXHJcbiAgICogaHR0cDovL3d3dy5lYXN5cmdiLmNvbS9pbmRleC5waHA/WD1NQVRIJkg9MDgjdGV4dDhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gbFxyXG4gICAqIEBwYXJhbSB7Kn0gYVxyXG4gICAqIEBwYXJhbSB7Kn0gYlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdGF0aWMgY2llbGFiMlhZWihsLCBhLCBiKSB7XHJcbiAgICBjb25zdCByZWZYID0gOTUuMDQ3O1xyXG4gICAgY29uc3QgcmVmWSA9IDEwMC4wMDtcclxuICAgIGNvbnN0IHJlZlogPSAxMDguODgzO1xyXG5cclxuICAgIGxldCB5ID0gKGwgKyAxNikgLyAxMTY7XHJcbiAgICBsZXQgeCA9IGEgLyA1MDAgKyB5O1xyXG4gICAgbGV0IHogPSB5IC0gYiAvIDIwMDtcclxuXHJcbiAgICBpZiAoTWF0aC5wb3coeSwgMykgPiAwLjAwODg1Nikge1xyXG4gICAgICB5ID0gTWF0aC5wb3coeSwgMyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB5ID0gKHkgLSAxNiAvIDExNikgLyA3Ljc4NztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTWF0aC5wb3coeCwgMykgPiAwLjAwODg1Nikge1xyXG4gICAgICB4ID0gTWF0aC5wb3coeCwgMyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ID0gKHggLSAxNiAvIDExNikgLyA3Ljc4NztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTWF0aC5wb3coeiwgMykgPiAwLjAwODg1Nikge1xyXG4gICAgICB6ID0gTWF0aC5wb3coeiwgMyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB6ID0gKHogLSAxNiAvIDExNikgLyA3Ljc4NztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW3JlZlggKiB4LCByZWZZICogeSwgcmVmWiAqIHpdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBYWVogdG8gUkdCIHNwYWNlXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHhcclxuICAgKiBAcGFyYW0geyp9IHlcclxuICAgKiBAcGFyYW0geyp9IHpcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgc3RhdGljIHh5ejJSR0IoeCwgeSwgeikge1xyXG4gICAgeCAvPSAxMDA7XHJcbiAgICB5IC89IDEwMDtcclxuICAgIHogLz0gMTAwO1xyXG4gICAgbGV0IHIgPSB4ICogMy4yNDA2ICsgeSAqIC0xLjUzNzIgKyB6ICogLTAuNDk4NjtcclxuICAgIGxldCBnID0geCAqIC0wLjk2ODkgKyB5ICogMS44NzU4ICsgeiAqIDAuMDQxNTtcclxuICAgIGxldCBiID0geCAqIDAuMDU1NyArIHkgKiAtMC4yMDQwICsgeiAqIDEuMDU3MDtcclxuXHJcbiAgICBpZiAociA+IDAuMDAzMTMwOCkge1xyXG4gICAgICByID0gMS4wNTUgKiAoTWF0aC5wb3cociwgMSAvIDIuNCkpIC0gMC4wNTU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gMTIuOTIgKiByO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChnID4gMC4wMDMxMzA4KSB7XHJcbiAgICAgIGcgPSAxLjA1NSAqIChNYXRoLnBvdyhnLCAxIC8gMi40KSkgLSAwLjA1NTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGcgPSAxMi45MiAqIGc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGIgPiAwLjAwMzEzMDgpIHtcclxuICAgICAgYiA9IDEuMDU1ICogKE1hdGgucG93KGIsIDEgLyAyLjQpKSAtIDAuMDU1O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYiA9IDEyLjkyICogYjtcclxuICAgIH1cclxuXHJcbiAgICByID0gciAqIDI1NTtcclxuICAgIGcgPSBnICogMjU1O1xyXG4gICAgYiA9IGIgKiAyNTU7XHJcblxyXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgTEFCIHRvIFJHQlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBsXHJcbiAgICogQHBhcmFtIHsqfSBhXHJcbiAgICogQHBhcmFtIHsqfSBiXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjaWVsYWIyUkdCKGwgPSA1MCwgYSA9IDAsIGIgPSAwKSB7XHJcbiAgICBpZiAoIShsID49IDAgJiYgbCA8PSAxMDApKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB4eXogPSB0aGlzLmNpZWxhYjJYWVoobCwgYSwgYik7XHJcbiAgICByZXR1cm4gdGhpcy54eXoyUkdCKC4uLnh5eik7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgQ29yZVV0aWxzIGZyb20gJy4vY29yZS51dGlscyc7XHJcbmltcG9ydCBWYWxpZGF0b3JzIGZyb20gJy4vY29yZS52YWxpZGF0b3JzJztcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlL3Rlc3QgaW50ZXJzZWN0aW9uIGJldHdlZW4gZGlmZmVyZW50IG9iamVjdHMuXHJcbiAqXHJcbiAqIEBtb2R1bGUgY29yZS9pbnRlcnNlY3Rpb25zXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJzZWN0aW9ucyB7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBvcmllbnRlZCBib3VuZGluZyBib3ggYW5kIGEgcGxhbmUuXHJcbiAqXHJcbiAqIFJldHVybnMgaW50ZXJzZWN0aW9uIGluIHBsYW5lJ3Mgc3BhY2UuXHJcbiAqXHJcbiAqIFNob3VsZCByZXR1cm4gYXQgbGVhc3QgMyBpbnRlcnNlY3Rpb25zLiBJZiBub3QsIHRoZSBwbGFuZSBhbmQgdGhlIGJveCBkbyBub3RcclxuICogaW50ZXJzZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gYWFiYiAtIEF4ZSBBbGlnbmVkIEJvdW5kaW5nIEJveCByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBhYWJiLmhhbGZEaW1lbnNpb25zIC0gSGFsZiBkaW1lbnNpb25zIG9mIHRoZSBib3guXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gYWFiYi5jZW50ZXIgLSBDZW50ZXIgb2YgdGhlIGJveC5cclxuICogQHBhcmFtIHtUSFJFRS5NYXRyaXg0fSBhYWJiLnRvQUFCQiAtIFRyYW5zZm9ybSB0byBnbyBmcm9tIHBsYW5lIHNwYWNlIHRvIGJveCBzcGFjZS5cclxuICogQHBhcmFtIHtPYmplY3R9IHBsYW5lIC0gUGxhbmUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBwbGFuZS5wb3NpdGlvbiAtIHBvc2l0aW9uIG9mIG5vcm1hbCB3aGljaCBkZXNjcmliZXMgdGhlIHBsYW5lLlxyXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHBsYW5lLmRpcmVjdGlvbiAtIERpcmVjdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSBwbGFuZS5cclxuICpcclxuICogQHJldHVybnMge0FycmF5PFRIUkVFLlZlY3RvcjM+fSBMaXN0IG9mIGFsbCBpbnRlcnNlY3Rpb25zIGluIHBsYW5lJ3Mgc3BhY2UuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpcyBpbnZhbGlkIGlucHV0IHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvL1JldHVybnMgYXJyYXkgd2l0aCBpbnRlcnNlY3Rpb24gTiBpbnRlcnNlY3Rpb25zXHJcbiAqIGxldCBhYWJiID0ge1xyXG4gKiAgIGNlbnRlcjogbmV3IFRIUkVFLlZlY3RvcjMoMTUwLCAxNTAsIDE1MCksXHJcbiAqICAgaGFsZkRpbWVuc2lvbnM6IG5ldyBUSFJFRS5WZWN0b3IzKDUwLCA2MCwgNzApLFxyXG4gKiAgIHRvQUFCQjogbmV3IFRIUkVFLk1hdHJpeDQoKVxyXG4gKiB9XHJcbiAqIGxldCBwbGFuZSA9IHtcclxuICogICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoMTEwLCAxMjAsIDEzMCksXHJcbiAqICAgZGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKVxyXG4gKiB9XHJcbiAqXHJcbiAqIGxldCBpbnRlcnNlY3Rpb25zID0gQ29yZUludGVyc2VjdGlvbnMuYWFiYlBsYW5lKGFhYmIsIHBsYW5lKTtcclxuICogLy8gaW50ZXJzZWN0aW9ucyA9PVxyXG4gKiAvL1sgeyB4IDogMTEwLCB5IDogOTAsICB6IDogODAgfSxcclxuICogLy8gIHsgeCA6IDExMCwgeSA6IDIxMCwgeiA6IDIyMCB9LFxyXG4gKiAvLyAgeyB4IDogMTEwLCB5IDogMjEwLCB6IDogODAgfSxcclxuICogLy8gIHsgeCA6IDExMCwgeSA6IDkwLCAgeiA6IDIyMCB9IF1cclxuICpcclxuICogLy9SZXR1cm5zIGVtcHR5IGFycmF5IHdpdGggMCBpbnRlcnNlY3Rpb25zXHJcbiAqIGxldCBhYWJiID0ge1xyXG4gKlxyXG4gKiB9XHJcbiAqIGxldCBwbGFuZSA9IHtcclxuICpcclxuICogfVxyXG4gKlxyXG4gKiBsZXQgaW50ZXJzZWN0aW9ucyA9IFZKUy5Db3JlLlZhbGlkYXRvcnMubWF0cml4NChuZXcgVEhSRUUuVmVjdG9yMygpKTtcclxuICpcclxuICogLy9SZXR1cm5zIGZhbHNlIGlmIGludmFsaWQgaW5wdXQ/XHJcbiAqXHJcbiAqL1xyXG4gIHN0YXRpYyBhYWJiUGxhbmUoYWFiYiwgcGxhbmUpIHtcclxuICAgIC8vXHJcbiAgICAvLyBvYmIgPSB7IGhhbGZEaW1lbnNpb25zLCBvcmllbnRhdGlvbiwgY2VudGVyLCB0b0FBQkIgfVxyXG4gICAgLy8gcGxhbmUgPSB7IHBvc2l0aW9uLCBkaXJlY3Rpb24gfVxyXG4gICAgLy9cclxuICAgIC8vXHJcbiAgICAvLyBMT0dJQzpcclxuICAgIC8vXHJcbiAgICAvLyBUZXN0IGludGVyc2VjdGlvbiBvZiBlYWNoIGVkZ2Ugb2YgdGhlIE9yaWVudGVkIEJvdW5kaW5nIEJveCB3aXRoIHRoZSBQbGFuZVxyXG4gICAgLy9cclxuICAgIC8vIEFMTCBFREdFU1xyXG4gICAgLy9cclxuICAgIC8vICAgICAgListLS0tLS0tK1xyXG4gICAgLy8gICAgLicgfCAgICAgLid8XHJcbiAgICAvLyAgICstLS0rLS0tKycgIHxcclxuICAgIC8vICAgfCAgIHwgICB8ICAgfFxyXG4gICAgLy8gICB8ICAsKy0tLSstLS0rXHJcbiAgICAvLyAgIHwuJyAgICAgfCAuJ1xyXG4gICAgLy8gICArLS0tLS0tLSsnXHJcbiAgICAvL1xyXG4gICAgLy8gU1BBQ0UgT1JJRU5UQVRJT05cclxuICAgIC8vXHJcbiAgICAvLyAgICAgICArXHJcbiAgICAvLyAgICAgaiB8XHJcbiAgICAvLyAgICAgICB8XHJcbiAgICAvLyAgICAgICB8ICAgaVxyXG4gICAgLy8gICBrICAsKy0tLS0tLS0rXHJcbiAgICAvLyAgICAuJ1xyXG4gICAgLy8gICArXHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vIDEtIE1vdmUgUGxhbmUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIGluIElKSyBzcGFjZVxyXG4gICAgLy8gMi0gVGVzdCBFZGdlcy8gSUpLIFBsYW5lIGludGVyc2VjdGlvbnNcclxuICAgIC8vIDMtIFJldHVybiBpbnRlcnNlY3Rpb24gRWRnZS8gSUpLIFBsYW5lIGlmIGl0IHRvdWNoZXMgdGhlIE9yaWVudGVkIEJCb3hcclxuXHJcbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9IFtdO1xyXG5cclxuICAgIGlmICghKHRoaXMudmFsaWRhdGVBYWJiKGFhYmIpICYmXHJcbiAgICAgICB0aGlzLnZhbGlkYXRlUGxhbmUocGxhbmUpKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgYWFiYiBvciBwbGFuZSBwcm92aWRlZC4nKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGludmVydCBzcGFjZSBtYXRyaXhcclxuICAgIGxldCBmcm9tQUFCQiA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICBmcm9tQUFCQi5nZXRJbnZlcnNlKGFhYmIudG9BQUJCKTtcclxuXHJcbiAgICBsZXQgdDEgPSBwbGFuZS5kaXJlY3Rpb24uY2xvbmUoKS5hcHBseU1hdHJpeDQoYWFiYi50b0FBQkIpO1xyXG4gICAgbGV0IHQwID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkuYXBwbHlNYXRyaXg0KGFhYmIudG9BQUJCKTtcclxuXHJcbiAgICBsZXQgcGxhbmVBQUJCID0gdGhpcy5wb3NkaXIoXHJcbiAgICAgIHBsYW5lLnBvc2l0aW9uLmNsb25lKCkuYXBwbHlNYXRyaXg0KGFhYmIudG9BQUJCKSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjModDEueCAtIHQwLngsIHQxLnkgLSB0MC55LCB0MS56IC0gdDAueikubm9ybWFsaXplKClcclxuICAgICk7XHJcblxyXG4gICAgbGV0IGJib3ggPSBDb3JlVXRpbHMuYmJveChhYWJiLmNlbnRlciwgYWFiYi5oYWxmRGltZW5zaW9ucyk7XHJcblxyXG4gICAgbGV0IG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApLFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSkpO1xyXG5cclxuICAgIC8vIDEyIGVkZ2VzIChpLmUuIHJheSkvcGxhbmUgaW50ZXJzZWN0aW9uIHRlc3RzXHJcbiAgICAvLyBSQVlTIFNUQVJUSU5HIEZST00gVEhFIEZJUlNUIENPUk5FUiAoMCwgMCwgMClcclxuICAgIC8vXHJcbiAgICAvLyAgICAgICArXHJcbiAgICAvLyAgICAgICB8XHJcbiAgICAvLyAgICAgICB8XHJcbiAgICAvLyAgICAgICB8XHJcbiAgICAvLyAgICAgICwrLS0tKy0tLStcclxuICAgIC8vICAgIC4nXHJcbiAgICAvLyAgICtcclxuXHJcbiAgICBsZXQgcmF5ID0gdGhpcy5wb3NkaXIoXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnggLSBhYWJiLmhhbGZEaW1lbnNpb25zLngsXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueSAtIGFhYmIuaGFsZkRpbWVuc2lvbnMueSxcclxuICAgICAgICBhYWJiLmNlbnRlci56IC0gYWFiYi5oYWxmRGltZW5zaW9ucy56KSxcclxuICAgICAgb3JpZW50YXRpb24ueFxyXG4gICAgKTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIHJheS5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi55O1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgcmF5LmRpcmVjdGlvbiA9IG9yaWVudGF0aW9uLno7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICAvLyBSQVlTIFNUQVJUSU5HIEZST00gVEhFIExBU1QgQ09STkVSXHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAgICAgICAgICArXHJcbiAgICAvLyAgICAgICAgICAgICAuJ1xyXG4gICAgLy8gICArLS0tLS0tLSsnXHJcbiAgICAvLyAgICAgICAgICAgfFxyXG4gICAgLy8gICAgICAgICAgIHxcclxuICAgIC8vICAgICAgICAgICB8XHJcbiAgICAvLyAgICAgICAgICAgK1xyXG4gICAgLy9cclxuXHJcbiAgICBsZXQgcmF5MiA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBhYWJiLmNlbnRlci54ICsgYWFiYi5oYWxmRGltZW5zaW9ucy54LFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnkgKyBhYWJiLmhhbGZEaW1lbnNpb25zLnksXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueiArIGFhYmIuaGFsZkRpbWVuc2lvbnMueiksXHJcbiAgICAgIG9yaWVudGF0aW9uLnhcclxuICAgICk7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTIsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgcmF5Mi5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi55O1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXkyLCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIHJheTIuZGlyZWN0aW9uID0gb3JpZW50YXRpb24uejtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5MiwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICAvLyBSQVlTIFNUQVJUSU5HIEZST00gVEhFIFNFQ09ORCBDT1JORVJcclxuICAgIC8vXHJcbiAgICAvLyAgICAgICAgICAgICAgICtcclxuICAgIC8vICAgICAgICAgICAgICAgfFxyXG4gICAgLy8gICAgICAgICAgICAgICB8XHJcbiAgICAvLyAgICAgICAgICAgICAgIHxcclxuICAgIC8vICAgICAgICAgICAgICAgK1xyXG4gICAgLy8gICAgICAgICAgICAgLidcclxuICAgIC8vICAgICAgICAgICArJ1xyXG5cclxuICAgIGxldCByYXkzID0gdGhpcy5wb3NkaXIoXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnggKyBhYWJiLmhhbGZEaW1lbnNpb25zLngsXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueSAtIGFhYmIuaGFsZkRpbWVuc2lvbnMueSxcclxuICAgICAgICBhYWJiLmNlbnRlci56IC0gYWFiYi5oYWxmRGltZW5zaW9ucy56KSxcclxuICAgICAgb3JpZW50YXRpb24ueVxyXG4gICAgKTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5MywgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICByYXkzLmRpcmVjdGlvbiA9IG9yaWVudGF0aW9uLno7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTMsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgLy8gUkFZUyBTVEFSVElORyBGUk9NIFRIRSBUSElSRCBDT1JORVJcclxuICAgIC8vXHJcbiAgICAvLyAgICAgIC4rLS0tLS0tLStcclxuICAgIC8vICAgIC4nXHJcbiAgICAvLyAgICtcclxuICAgIC8vXHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vXHJcblxyXG4gICAgbGV0IHJheTQgPSB0aGlzLnBvc2RpcihcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueCAtIGFhYmIuaGFsZkRpbWVuc2lvbnMueCxcclxuICAgICAgICBhYWJiLmNlbnRlci55ICsgYWFiYi5oYWxmRGltZW5zaW9ucy55LFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnogLSBhYWJiLmhhbGZEaW1lbnNpb25zLnopLFxyXG4gICAgICBvcmllbnRhdGlvbi54XHJcbiAgICApO1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXk0LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIHJheTQuZGlyZWN0aW9uID0gb3JpZW50YXRpb24uejtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5NCwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICAvLyBSQVlTIFNUQVJUSU5HIEZST00gVEhFIEZPVVJUSCBDT1JORVJcclxuICAgIC8vXHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vICAgK1xyXG4gICAgLy8gICB8XHJcbiAgICAvLyAgIHxcclxuICAgIC8vICAgfFxyXG4gICAgLy8gICArLS0tLS0tLStcclxuXHJcbiAgICBsZXQgcmF5NSA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBhYWJiLmNlbnRlci54IC0gYWFiYi5oYWxmRGltZW5zaW9ucy54LFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnkgLSBhYWJiLmhhbGZEaW1lbnNpb25zLnksXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueiArIGFhYmIuaGFsZkRpbWVuc2lvbnMueiksXHJcbiAgICAgIG9yaWVudGF0aW9uLnhcclxuICAgICk7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTUsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgcmF5NS5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi55O1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXk1LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIC8vIEB0b2RvIG1ha2Ugc3VyZSBvYmplY3RzIGFyZSB1bmlxdWUuLi5cclxuXHJcbiAgICAvLyBiYWNrIHRvIG9yaWdpbmFsIHNwYWNlXHJcbiAgICBpbnRlcnNlY3Rpb25zLm1hcChcclxuICAgICAgZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50LmFwcGx5TWF0cml4NChmcm9tQUFCQik7XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XHJcbiAgfVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gYSByYXkgYW5kIGEgcGxhbmUuXHJcbiAqXHJcbiAqIEBtZW1iZXJPZiB0aGlzXHJcbiAqIEBwdWJsaWNcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHJheSAtIFJheSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSByYXkucG9zaXRpb24gLSBwb3NpdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSByYXkuXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcmF5LmRpcmVjdGlvbiAtIERpcmVjdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSByYXkuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGFuZSAtIFBsYW5lIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcGxhbmUucG9zaXRpb24gLSBwb3NpdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSBwbGFuZS5cclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBwbGFuZS5kaXJlY3Rpb24gLSBEaXJlY3Rpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcGxhbmUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfG51bGx9IEludGVyc2VjdGlvbiBiZXR3ZWVuIHJheSBhbmQgcGxhbmUgb3IgbnVsbC5cclxuICovXHJcbiAgc3RhdGljIHJheVBsYW5lKHJheSwgcGxhbmUpIHtcclxuICAvLyByYXk6IHtwb3NpdGlvbiwgZGlyZWN0aW9ufVxyXG4gIC8vIHBsYW5lOiB7cG9zaXRpb24sIGRpcmVjdGlvbn1cclxuXHJcbiAgaWYgKHJheS5kaXJlY3Rpb24uZG90KHBsYW5lLmRpcmVjdGlvbikgIT09IDApIHtcclxuICAgIC8vXHJcbiAgICAvLyBub3QgcGFyYWxsZWwsIG1vdmUgZm9yd2FyZFxyXG4gICAgLy9cclxuICAgIC8vIExPR0lDOlxyXG4gICAgLy9cclxuICAgIC8vIFJheSBlcXVhdGlvbjogUCA9IFAwICsgdFZcclxuICAgIC8vIFAgPSA8UHgsIFB5LCBQej5cclxuICAgIC8vIFAwID0gPHJheS5wb3NpdGlvbi54LCByYXkucG9zaXRpb24ueSwgcmF5LnBvc2l0aW9uLno+XHJcbiAgICAvLyBWID0gPHJheS5kaXJlY3Rpb24ueCwgcmF5LmRpcmVjdGlvbi55LCByYXkuZGlyZWN0aW9uLno+XHJcbiAgICAvL1xyXG4gICAgLy8gVGhlcmVmb3JlOlxyXG4gICAgLy8gUHggPSByYXkucG9zaXRpb24ueCArIHQqcmF5LmRpcmVjdGlvbi54XHJcbiAgICAvLyBQeSA9IHJheS5wb3NpdGlvbi55ICsgdCpyYXkuZGlyZWN0aW9uLnlcclxuICAgIC8vIFB6ID0gcmF5LnBvc2l0aW9uLnogKyB0KnJheS5kaXJlY3Rpb24uelxyXG4gICAgLy9cclxuICAgIC8vXHJcbiAgICAvL1xyXG4gICAgLy8gUGxhbmUgZXF1YXRpb246IGF4ICsgYnkgKyBjeiArIGQgPSAwXHJcbiAgICAvLyBhID0gcGxhbmUuZGlyZWN0aW9uLnhcclxuICAgIC8vIGIgPSBwbGFuZS5kaXJlY3Rpb24ueVxyXG4gICAgLy8gYyA9IHBsYW5lLmRpcmVjdGlvbi56XHJcbiAgICAvLyBkID0gLSggcGxhbmUuZGlyZWN0aW9uLngqcGxhbmUucG9zaXRpb24ueCArXHJcbiAgICAvLyAgICAgICAgcGxhbmUuZGlyZWN0aW9uLnkqcGxhbmUucG9zaXRpb24ueSArXHJcbiAgICAvLyAgICAgICAgcGxhbmUuZGlyZWN0aW9uLnoqcGxhbmUucG9zaXRpb24ueiApXHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vIDEtIGluIHRoZSBwbGFuZSBlcXVhdGlvbiwgd2UgcmVwbGFjZSB4LCB5IGFuZCB6IGJ5IFB4LCBQeSBhbmQgUHpcclxuICAgIC8vIDItIGZpbmQgdFxyXG4gICAgLy8gMy0gcmVwbGFjZSB0IGluIFB4LCBQeSBhbmQgUHogdG8gZ2V0IHRoZSBjb29yZGluYXRlIG9mIHRoZSBpbnRlcnNlY3Rpb25cclxuICAgIC8vXHJcbiAgICBsZXQgdCA9IChwbGFuZS5kaXJlY3Rpb24ueCAqIChwbGFuZS5wb3NpdGlvbi54IC0gcmF5LnBvc2l0aW9uLngpICsgcGxhbmUuZGlyZWN0aW9uLnkgKiAocGxhbmUucG9zaXRpb24ueSAtIHJheS5wb3NpdGlvbi55KSArIHBsYW5lLmRpcmVjdGlvbi56ICogKHBsYW5lLnBvc2l0aW9uLnogLSByYXkucG9zaXRpb24ueikpIC9cclxuICAgICAgICAocGxhbmUuZGlyZWN0aW9uLnggKiByYXkuZGlyZWN0aW9uLnggKyBwbGFuZS5kaXJlY3Rpb24ueSAqIHJheS5kaXJlY3Rpb24ueSArIHBsYW5lLmRpcmVjdGlvbi56ICogcmF5LmRpcmVjdGlvbi56KTtcclxuXHJcbiAgICBsZXQgaW50ZXJzZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgcmF5LnBvc2l0aW9uLnggKyB0ICogcmF5LmRpcmVjdGlvbi54LFxyXG4gICAgICAgIHJheS5wb3NpdGlvbi55ICsgdCAqIHJheS5kaXJlY3Rpb24ueSxcclxuICAgICAgICByYXkucG9zaXRpb24ueiArIHQgKiByYXkuZGlyZWN0aW9uLnopO1xyXG5cclxuICAgIHJldHVybiBpbnRlcnNlY3Rpb247XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgcmF5IGFuZCBhIGJveFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByYXlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gYm94XHJcbiAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICovXHJcbiAgc3RhdGljIHJheUJveChyYXksIGJveCkge1xyXG4gICAgLy8gc2hvdWxkIGFsc28gZG8gdGhlIHNwYWNlIHRyYW5zZm9ybXMgaGVyZVxyXG4gICAgLy8gcmF5OiB7cG9zaXRpb24sIGRpcmVjdGlvbn1cclxuICAgIC8vIGJveDoge2hhbGZEaW1lbnNpb25zLCBjZW50ZXJ9XHJcblxyXG4gICAgbGV0IGludGVyc2VjdGlvbnMgPSBbXTtcclxuXHJcbiAgICBsZXQgYmJveCA9IENvcmVVdGlscy5iYm94KGJveC5jZW50ZXIsIGJveC5oYWxmRGltZW5zaW9ucyk7XHJcblxyXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGJib3gpO1xyXG5cclxuICAgIC8vIFggbWluXHJcbiAgICBsZXQgcGxhbmUgPSB0aGlzLnBvc2RpcihcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgYmJveC5taW4ueCxcclxuICAgICAgICBib3guY2VudGVyLnksXHJcbiAgICAgICAgYm94LmNlbnRlci56KSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoLTEsIDAsIDApXHJcbiAgICApO1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICAvLyBYIG1heFxyXG4gICAgcGxhbmUgPSB0aGlzLnBvc2RpcihcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgYmJveC5tYXgueCxcclxuICAgICAgICBib3guY2VudGVyLnksXHJcbiAgICAgICAgYm94LmNlbnRlci56KSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMClcclxuICAgICk7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmUsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIC8vIFkgbWluXHJcbiAgICBwbGFuZSA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBib3guY2VudGVyLngsXHJcbiAgICAgICAgYmJveC5taW4ueSxcclxuICAgICAgICBib3guY2VudGVyLnopLFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAtMSwgMClcclxuICAgICk7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmUsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIC8vIFkgbWF4XHJcbiAgICBwbGFuZSA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBib3guY2VudGVyLngsXHJcbiAgICAgICAgYmJveC5tYXgueSxcclxuICAgICAgICBib3guY2VudGVyLnopLFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKVxyXG4gICAgKTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZSwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgLy8gWiBtaW5cclxuICAgIHBsYW5lID0gdGhpcy5wb3NkaXIoXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIGJveC5jZW50ZXIueCxcclxuICAgICAgICBib3guY2VudGVyLnksXHJcbiAgICAgICAgYmJveC5taW4ueiksXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIC0xKVxyXG4gICAgKTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZSwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgLy8gWiBtYXhcclxuICAgIHBsYW5lID0gdGhpcy5wb3NkaXIoXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIGJveC5jZW50ZXIueCxcclxuICAgICAgICBib3guY2VudGVyLnksXHJcbiAgICAgICAgYmJveC5tYXgueiksXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpXHJcbiAgICApO1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVyc2VjdGlvbiBiZXR3ZWVuIHJheSBhbmQgYSBwbGFuZSB0aGF0IGFyZSBpbiBhIGJveC5cclxuICAgKiBAcGFyYW0geyp9IHJheVxyXG4gICAqIEBwYXJhbSB7Kn0gcGxhbmVBQUJCXHJcbiAgICogQHBhcmFtIHsqfSBiYm94XHJcbiAgICogQHBhcmFtIHsqfSBpbnRlcnNlY3Rpb25zXHJcbiAgICovXHJcbiAgc3RhdGljIHJheVBsYW5lSW5CQm94KHJheSwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKSB7XHJcbiAgICBsZXQgaW50ZXJzZWN0aW9uID0gdGhpcy5yYXlQbGFuZShyYXksIHBsYW5lQUFCQik7XHJcbiAgICAvLyB3aW5kb3cuY29uc29sZS5sb2coaW50ZXJzZWN0aW9uKTtcclxuICAgIGlmIChpbnRlcnNlY3Rpb24gJiYgdGhpcy5pbkJCb3goaW50ZXJzZWN0aW9uLCBiYm94KSkge1xyXG4gICAgICBpZiAoIWludGVyc2VjdGlvbnMuZmluZCh0aGlzLmZpbmRJbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9uKSkpIHtcclxuICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCBpbnRlcnNlY3Rpb24gaW4gYXJyYXlcclxuICAgKiBAcGFyYW0geyp9IG15aW50ZXJzZWN0aW9uXHJcbiAgICovXHJcbiAgc3RhdGljIGZpbmRJbnRlcnNlY3Rpb24obXlpbnRlcnNlY3Rpb24pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBmb3VuZChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcclxuICAgICAgaWYgKG15aW50ZXJzZWN0aW9uLnggPT09IGVsZW1lbnQueCAmJlxyXG4gICAgICAgIG15aW50ZXJzZWN0aW9uLnkgPT09IGVsZW1lbnQueSAmJlxyXG4gICAgICAgIG15aW50ZXJzZWN0aW9uLnogPT09IGVsZW1lbnQueikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSXMgcG9pbnQgaW4gYm94LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiYm94XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBzdGF0aWMgaW5CQm94KHBvaW50LCBiYm94KSB7XHJcbiAgICAvL1xyXG4gICAgbGV0IGVwc2lsb24gPSAwLjAwMDE7XHJcbiAgICBpZiAocG9pbnQgJiZcclxuICAgICAgICBwb2ludC54ID49IGJib3gubWluLnggLSBlcHNpbG9uICYmXHJcbiAgICAgICAgcG9pbnQueSA+PSBiYm94Lm1pbi55IC0gZXBzaWxvbiAmJlxyXG4gICAgICAgIHBvaW50LnogPj0gYmJveC5taW4ueiAtIGVwc2lsb24gJiZcclxuICAgICAgICBwb2ludC54IDw9IGJib3gubWF4LnggKyBlcHNpbG9uICYmXHJcbiAgICAgICAgcG9pbnQueSA8PSBiYm94Lm1heC55ICsgZXBzaWxvbiAmJlxyXG4gICAgICAgIHBvaW50LnogPD0gYmJveC5tYXgueiArIGVwc2lsb24pIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcG9zZGlyKHBvc2l0aW9uLCBkaXJlY3Rpb24pIHtcclxuICAgIHJldHVybiB7cG9zaXRpb24sIGRpcmVjdGlvbn07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdmFsaWRhdGVQbGFuZShwbGFuZSkge1xyXG4gICAgLy9cclxuICAgIGlmIChwbGFuZSA9PT0gbnVsbCkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgcGxhbmUuJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhwbGFuZSk7XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFWYWxpZGF0b3JzLnZlY3RvcjMocGxhbmUucG9zaXRpb24pKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBwbGFuZS5wb3NpdGlvbi4nKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHBsYW5lLnBvc2l0aW9uKTtcclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIVZhbGlkYXRvcnMudmVjdG9yMyhwbGFuZS5kaXJlY3Rpb24pKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBwbGFuZS5kaXJlY3Rpb24uJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhwbGFuZS5kaXJlY3Rpb24pO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHZhbGlkYXRlQWFiYihhYWJiKSB7XHJcbiAgICAvL1xyXG4gICAgaWYgKGFhYmIgPT09IG51bGwpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIuJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhYWJiKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghVmFsaWRhdG9ycy5tYXRyaXg0KGFhYmIudG9BQUJCKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgYWFiYi50b0FBQkI6ICcpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coYWFiYi50b0FBQkIpO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghVmFsaWRhdG9ycy52ZWN0b3IzKGFhYmIuY2VudGVyKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgYWFiYi5jZW50ZXIuJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhYWJiLmNlbnRlcik7XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoVmFsaWRhdG9ycy52ZWN0b3IzKGFhYmIuaGFsZkRpbWVuc2lvbnMpICYmXHJcbiAgICAgICBhYWJiLmhhbGZEaW1lbnNpb25zLnggPj0gMCAmJlxyXG4gICAgICAgYWFiYi5oYWxmRGltZW5zaW9ucy55ID49IDAgJiZcclxuICAgICAgIGFhYmIuaGFsZkRpbWVuc2lvbnMueiA+PSAwKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgYWFiYi5oYWxmRGltZW5zaW9ucy4nKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGFhYmIuaGFsZkRpbWVuc2lvbnMpO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IENvbG9ycyBmcm9tICcuL2NvcmUuY29sb3JzJztcclxuaW1wb3J0IEludGVyc2VjdGlvbnMgZnJvbSAnLi9jb3JlLmludGVyc2VjdGlvbnMnO1xyXG5pbXBvcnQgUGFjayBmcm9tICcuL2NvcmUucGFjayc7XHJcbmltcG9ydCBWYWxpZGF0b3JzIGZyb20gJy4vY29yZS52YWxpZGF0b3JzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4vY29yZS51dGlscyc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBjb3JlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgQ29sb3JzLFxyXG4gIEludGVyc2VjdGlvbnMsXHJcbiAgVXRpbHMsXHJcbiAgVmFsaWRhdG9ycyxcclxufTtcclxuIiwiLyoqXHJcbiAqIFBhY2tpbmcgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGNvcmUvcGFjayAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFjayB7XHJcblxyXG4gIC8qKlxyXG4gICAqXHJcbiAgICovXHJcbiAgLy8gc3RhdGljIHBhY2tUbzhCaXRzVGV4dHVyZShiaXRzLCBjaGFubmVscywgZnJhbWUsIHRleHR1cmVTaXplLCBzdGFydFZveGVsLCBzdG9wVm94ZWwpIHtcclxuICAvLyAgIGxldCBwYWNrZWQgPSB7XHJcbiAgLy8gICAgIHRleHR1cmVUeXBlOiBudWxsLFxyXG4gIC8vICAgICBkYXRhOiBudWxsXHJcbiAgLy8gICB9O1xyXG5cclxuICAvLyAgIGxldCBwYWNrSW5kZXggPSAwO1xyXG4gIC8vICAgbGV0IGZyYW1lSW5kZXggPSAwO1xyXG4gIC8vICAgbGV0IGluRnJhbWVJbmRleCA9IDA7XHJcbiAgLy8gICBsZXQgZnJhbWVEaW1lbnNpb24gPSBmcmFtZVswXS5yb3dzICogZnJhbWVbMF0uY29sdW1ucztcclxuICAvLyAgIGxldCBkYXRhID0gbnVsbDtcclxuXHJcbiAgLy8gICBpZiAoYml0cyA9PT0gOCAmJiBjaGFubmVscyA9PT0gMSkge1xyXG4gIC8vICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiAxKTtcclxuICAvLyAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xyXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cclxuICAvLyAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcclxuICAvLyAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cclxuXHJcbiAgLy8gICAgICAgZGF0YVtwYWNrSW5kZXhdID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XHJcbiAgLy8gICAgICAgcGFja0luZGV4Kys7XHJcblxyXG4gIC8vICAgICB9XHJcbiAgLy8gICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkZvcm1hdDtcclxuICAvLyAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xyXG4gIC8vICAgfSBlbHNlIGlmIChiaXRzID09PSAxNiAmJiBjaGFubmVscyA9PT0gMSkge1xyXG4gIC8vICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiAyKTtcclxuICAvLyAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xyXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cclxuICAvLyAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcclxuICAvLyAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cclxuXHJcbiAgLy8gICAgICAgLy8gc2xvdyFcclxuICAvLyAgICAgICAvL2xldCBhc2IgPSBWSlMuY29yZS5wYWNrLnVpbnQxNlRvQWxwaGFMdW1pbmFuY2UoZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF0pO1xyXG4gIC8vICAgICAgIGxldCByYXcgPSBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcclxuXHJcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xyXG4gIC8vICAgICAgIGxldCBsc2IgPSByYXcgJiAweDAwRkY7XHJcbiAgLy8gICAgICAgbGV0IG1zYiA9IChyYXcgPj4+IDgpICYgMHgwMEZGO1xyXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IHRydWUqL1xyXG4gIC8vICAgICAgIGRhdGFbMiAqIHBhY2tJbmRleF0gPSBsc2I7XHJcbiAgLy8gICAgICAgZGF0YVsyICogcGFja0luZGV4ICsgMV0gPSBtc2I7XHJcbiAgLy8gICAgICAgcGFja0luZGV4Kys7XHJcbiAgLy8gICAgIH1cclxuICAvLyAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQ7XHJcbiAgLy8gICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcclxuICAvLyAgIH0gZWxzZSBpZiAoYml0cyA9PT0gMzIgJiYgY2hhbm5lbHMgPT09IDEpIHtcclxuXHJcbiAgLy8gICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDQpO1xyXG4gIC8vICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XHJcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xyXG4gIC8vICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xyXG4gIC8vICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xyXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IHRydWUqL1xyXG5cclxuICAvLyAgICAgICAvLyBzbG93IVxyXG4gIC8vICAgICAgIC8vbGV0IGFzYiA9IFZKUy5jb3JlLnBhY2sudWludDE2VG9BbHBoYUx1bWluYW5jZShmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XSk7XHJcbiAgLy8gICAgICAgbGV0IHJhdyA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdO1xyXG5cclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXHJcbiAgLy8gICAgICAgbGV0IGIwID0gcmF3ICYgMHgwMDAwMDBGRjtcclxuICAvLyAgICAgICBsZXQgYjEgPSAocmF3ID4+PiA4KSAmIDB4MDAwMDAwRkY7XHJcbiAgLy8gICAgICAgbGV0IGIyID0gKHJhdyA+Pj4gOCkgJiAweDAwMDAwMEZGO1xyXG4gIC8vICAgICAgIGxldCBiMyA9IChyYXcgPj4+IDgpICYgMHgwMDAwMDBGRjtcclxuICAvLyAgICAgICAvLyBsZXQgbHNiMSA9IHJhdyAmIDB4RkY7XHJcbiAgLy8gICAgICAgLy8gbGV0IG1zYjEgPSAocmF3ID4+IDgpICYgMHhGRjtcclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cclxuICAvLyAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXhdID0gYjA7XHJcbiAgLy8gICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMV0gPSBiMTtcclxuICAvLyAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAyXSA9IGIyO1xyXG4gIC8vICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDNdID0gYjM7XHJcbiAgLy8gICAgICAgcGFja0luZGV4Kys7XHJcbiAgLy8gICAgIH1cclxuICAvLyAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuUkdCQUZvcm1hdDtcclxuICAvLyAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xyXG4gIC8vICAgfSBlbHNlIGlmIChiaXRzID09PSA4ICYmIGNoYW5uZWxzID09PSAzKSB7XHJcbiAgLy8gICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDMpO1xyXG4gIC8vICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XHJcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xyXG4gIC8vICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xyXG4gIC8vICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xyXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IHRydWUqL1xyXG5cclxuICAvLyAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXhdID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXhdO1xyXG4gIC8vICAgICAgIGRhdGFbMyAqIHBhY2tJbmRleCArIDFdID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXggKyAxXTtcclxuICAvLyAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXggKyAyXSA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVszICogaW5GcmFtZUluZGV4ICsgMl07XHJcbiAgLy8gICAgICAgcGFja0luZGV4Kys7XHJcblxyXG4gIC8vICAgICB9XHJcbiAgLy8gICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLkx1bWluYW5jZUZvcm1hdDtcclxuICAvLyAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xyXG4gIC8vICAgfVxyXG5cclxuICAvLyAgIHJldHVybiBwYWNrZWQ7XHJcblxyXG4gIC8vIH1cclxufVxyXG5cclxuLy8gJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gdmFyIFZKUyA9IFZKUyB8fCB7fTtcclxuLy8gVkpTLmNvcmUgPSBWSlMuY29yZSB8fCB7fTtcclxuXHJcbi8vIC8qKlxyXG4vLyAgKiBAY29uc3RydWN0b3JcclxuLy8gICogQGNsYXNzXHJcbi8vICAqIEBtZW1iZXJPZiBWSlMuY29yZVxyXG4vLyAgKiBAcHVibGljXHJcbi8vICovXHJcbi8vIFZKUy5jb3JlLnBhY2sgPSBWSlMuY29yZS5wYWNrIHx8IHt9O1xyXG5cclxuLy8gLy8gRGVhbCB3aXRoIGVuZGlhbmVzc1xyXG4vLyAvLyBkbyBub3QgYWRkIGEgaWYgdGhlcmUgYWYgaXMgaXMgc2xvdyBpbiBib2cgbG9vcHNcclxuLy8gLy8gYWRkIG1vcmUgZnVuY3Rpb25zXHJcbi8vIFZKUy5jb3JlLnBhY2sudWludDE2VG9BbHBoYUx1bWluYW5jZSA9IGZ1bmN0aW9uKHVpbnQxNiwgYWIpIHtcclxuLy8gICAvKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXHJcbi8vICAgdmFyIGxzYiA9IHVpbnQxNiAmIDB4RkY7XHJcbi8vICAgdmFyIG1zYiA9ICh1aW50MTYgPj4gOCkgJiAweEZGO1xyXG4vLyAgIC8qanNoaW50IGJpdHdpc2U6IHRydWUqL1xyXG4vLyAgIGFiID0gW2xzYiwgbXNiXTtcclxuLy8gfTtcclxuXHJcbi8vIFZKUy5jb3JlLnBhY2sudWludDhUb0x1bWluYW5jZSA9IGZ1bmN0aW9uKHVpbnQ4KSB7XHJcbi8vICAgcmV0dXJuIHVpbnQ4O1xyXG4vLyB9O1xyXG5cclxuLy8gVkpTLmNvcmUucGFjay51aW50OFYzVG9SR0IgPSBmdW5jdGlvbih1aW50OFYzKSB7XHJcbi8vICAgcmV0dXJuIHVpbnQ4VjM7XHJcbi8vIH07XHJcblxyXG4vLyAvKioqIEV4cG9ydHMgKioqL1xyXG5cclxuLy8gdmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xyXG4vLyBpZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4vLyAgIG1vZHVsZS5leHBvcnRzID0gVkpTLmNvcmUucGFjaztcclxuLy8gfVxyXG4iLCJjb25zdCBVUkwgPSByZXF1aXJlKCd1cmwnKTtcclxuaW1wb3J0IFZhbGlkYXRvcnMgZnJvbSAnLi9jb3JlLnZhbGlkYXRvcnMnO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYWwgcHVycG9zZSBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIEBtb2R1bGUgY29yZS91dGlsc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZVV0aWxzIHtcclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBib3VkaW5nIGJveCBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBjZW50ZXIgLSBDZW50ZXIgb2YgdGhlIGJveC5cclxuICAgKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGhhbGZEaW1lbnNpb25zIC0gSGFsZiBEaW1lbnNpb25zIG9mIHRoZSBib3guXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgYm91bmRpbmcgYm94IG9iamVjdC4ge09iamVjdC5taW59IGlzIGEge1RIUkVFLlZlY3RvcjN9XHJcbiAgICogY29udGFpbmluZyB0aGUgbWluIGJvdW5kcy4ge09iamVjdC5tYXh9IGlzIGEge1RIUkVFLlZlY3RvcjN9IGNvbnRhaW5pbmcgdGhlXHJcbiAgICogbWF4IGJvdW5kcy5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSBpbnB1dCBOT1QgdmFsaWQuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAvLyBSZXR1cm5zXHJcbiAgICogLy97IG1pbjogeyB4IDogMCwgeSA6IDAsICB6IDogMCB9LFxyXG4gICAqIC8vICBtYXg6IHsgeCA6IDIsIHkgOiA0LCAgeiA6IDYgfVxyXG4gICAqIC8vfVxyXG4gICAqIFZKUy5Db3JlLlV0aWxzLmJib3goXHJcbiAgICogICBuZXcgVEhSRUUuVmVjdG9yMygxLCAyLCAzKSwgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMiwgMykpO1xyXG4gICAqXHJcbiAgICogLy9SZXR1cm5zIGZhbHNlXHJcbiAgICogVkpTLkNvcmUuVXRpbHMuYmJveChuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuTWF0cml4NCgpKTtcclxuICAgKlxyXG4gICAqL1xyXG4gIHN0YXRpYyBiYm94KGNlbnRlciwgaGFsZkRpbWVuc2lvbnMpIHtcclxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHZhbGlkIGlucHV0c1xyXG4gICAgaWYgKCEoVmFsaWRhdG9ycy52ZWN0b3IzKGNlbnRlcikgJiZcclxuICAgICAgVmFsaWRhdG9ycy52ZWN0b3IzKGhhbGZEaW1lbnNpb25zKSkpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGNlbnRlciBvciBwbGFuZSBoYWxmRGltZW5zaW9ucy4nKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSBoYWxmIGRpbWVuc2lvbnMgYXJlID49IDBcclxuICAgIGlmICghKGhhbGZEaW1lbnNpb25zLnggPj0gMCAmJlxyXG4gICAgICBoYWxmRGltZW5zaW9ucy55ID49IDAgJiZcclxuICAgICAgaGFsZkRpbWVuc2lvbnMueiA+PSAwKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2hhbGZEaW1lbnNpb25zIG11c3QgYmUgPj0gMC4nKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGhhbGZEaW1lbnNpb25zKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1pbi9tYXggYm91bmRcclxuICAgIGxldCBtaW4gPSBjZW50ZXIuY2xvbmUoKS5zdWIoaGFsZkRpbWVuc2lvbnMpO1xyXG4gICAgbGV0IG1heCA9IGNlbnRlci5jbG9uZSgpLmFkZChoYWxmRGltZW5zaW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbWluLFxyXG4gICAgICBtYXgsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCBtaW4vbWF4IHZhbHVlcyBpbiBhbiBhcnJheVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcclxuICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgKi9cclxuICBzdGF0aWMgbWluTWF4KGRhdGEgPSBbXSkge1xyXG4gICAgbGV0IG1pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcclxuICAgIGxldCBudW1QaXhlbHMgPSBkYXRhLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtUGl4ZWxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGxldCBzcHYgPSBkYXRhW2luZGV4XTtcclxuICAgICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCBzcHYpO1xyXG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIHNwdik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1pbk1heDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIEhUTUxFbGVtZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdGF0aWMgaXNFbGVtZW50KG9iaikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVXNpbmcgVzMgRE9NMiAod29ya3MgZm9yIEZGLCBPcGVyYSBhbmQgQ2hyb20pXHJcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gQnJvd3NlcnMgbm90IHN1cHBvcnRpbmcgVzMgRE9NMiBkb24ndCBoYXZlIEhUTUxFbGVtZW50IGFuZFxyXG4gICAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGFuZCB3ZSBlbmQgdXAgaGVyZS4gVGVzdGluZyBzb21lXHJcbiAgICAgIC8vIHByb3BlcnRpZXMgdGhhdCBhbGwgZWxlbWVudHMgaGF2ZS4gKHdvcmtzIG9uIElFNylcclxuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JykgJiZcclxuICAgICAgICAob2JqLm5vZGVUeXBlID09PSAxKSAmJiAodHlwZW9mIG9iai5zdHlsZSA9PT0gJ29iamVjdCcpICYmXHJcbiAgICAgICAgKHR5cGVvZiBvYmoub3duZXJEb2N1bWVudCA9PT0gJ29iamVjdCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgc3RyaW5nXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RhdGljIGlzU3RyaW5nKHN0cikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIHVybFxyXG4gICAqIEBwYXJhbSB7Kn0gdXJsXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIHN0YXRpYyBwYXJzZVVybCh1cmwpIHtcclxuICAgIC8vXHJcbiAgICBjb25zdCBkYXRhID0ge307XHJcbiAgICBkYXRhLmZpbGVuYW1lID0gJyc7XHJcbiAgICBkYXRhLmV4dGVuc2lvbiA9ICcnO1xyXG4gICAgZGF0YS5wYXRobmFtZSA9ICcnO1xyXG4gICAgZGF0YS5xdWVyeSA9ICcnO1xyXG5cclxuICAgIGxldCBwYXJzZWRVcmwgPSBVUkwucGFyc2UodXJsKTtcclxuICAgIGRhdGEucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWU7XHJcbiAgICBkYXRhLnF1ZXJ5ID0gcGFyc2VkVXJsLnF1ZXJ5O1xyXG5cclxuICAgIC8vIGdldCBmaWxlIG5hbWVcclxuICAgIGRhdGEuZmlsZW5hbWUgPSBkYXRhLnBhdGhuYW1lLnNwbGl0KCcvJykucG9wKCk7XHJcblxyXG4gICAgLy8gZmluZCBleHRlbnNpb25cclxuICAgIGxldCBzcGxpdHRlZE5hbWUgPSBkYXRhLmZpbGVuYW1lLnNwbGl0KCcuJyk7XHJcbiAgICBpZiAoc3BsaXR0ZWROYW1lLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgIGRhdGEuZXh0ZW5zaW9uID0gJ2RpY29tJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRhdGEuZXh0ZW5zaW9uID0gZGF0YS5maWxlbmFtZS5zcGxpdCgnLicpLnBvcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNOYU4oZGF0YS5leHRlbnNpb24pKSB7XHJcbiAgICAgIGRhdGEuZXh0ZW5zaW9uID0gJ2RpY29tJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YS5xdWVyeSAmJlxyXG4gICAgICBkYXRhLnF1ZXJ5LmluY2x1ZGVzKCdjb250ZW50VHlwZT1hcHBsaWNhdGlvbiUyRmRpY29tJykpIHtcclxuICAgICAgZGF0YS5leHRlbnNpb24gPSAnZGljb20nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBJSksgdG8gTFBTIHRyYW5mb3JtLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSB4Q29zXHJcbiAgICogQHBhcmFtIHsqfSB5Q29zXHJcbiAgICogQHBhcmFtIHsqfSB6Q29zXHJcbiAgICogQHBhcmFtIHsqfSBzcGFjaW5nXHJcbiAgICogQHBhcmFtIHsqfSBvcmlnaW5cclxuICAgKiBAcGFyYW0geyp9IHJlZ2lzdHJhdGlvbk1hdHJpeFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdGF0aWMgaWprMkxQUyhcclxuICAgIHhDb3MsIHlDb3MsIHpDb3MsXHJcbiAgICBzcGFjaW5nLCBvcmlnaW4sXHJcbiAgICByZWdpc3RyYXRpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpKSB7XHJcbiAgICBjb25zdCBpamsyTFBTID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIGlqazJMUFMuc2V0KFxyXG4gICAgICB4Q29zLnggKiBzcGFjaW5nLngsIHlDb3MueCAqIHNwYWNpbmcueSwgekNvcy54ICogc3BhY2luZy56LCBvcmlnaW4ueCxcclxuICAgICAgeENvcy55ICogc3BhY2luZy54LCB5Q29zLnkgKiBzcGFjaW5nLnksIHpDb3MueSAqIHNwYWNpbmcueiwgb3JpZ2luLnksXHJcbiAgICAgIHhDb3MueiAqIHNwYWNpbmcueCwgeUNvcy56ICogc3BhY2luZy55LCB6Q29zLnogKiBzcGFjaW5nLnosIG9yaWdpbi56LFxyXG4gICAgICAwLCAwLCAwLCAxKTtcclxuICAgIGlqazJMUFMucHJlbXVsdGlwbHkocmVnaXN0cmF0aW9uTWF0cml4KTtcclxuXHJcbiAgICByZXR1cm4gaWprMkxQUztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgQUFCQiB0byBMUFMgdHJhbnNmb3JtLlxyXG4gICAqIEFBQkI6IEF4ZSBBbGlnbmVkIEJvdW5kaW5nIEJveC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0geENvc1xyXG4gICAqIEBwYXJhbSB7Kn0geUNvc1xyXG4gICAqIEBwYXJhbSB7Kn0gekNvc1xyXG4gICAqIEBwYXJhbSB7Kn0gb3JpZ2luXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhYWJiMkxQUyhcclxuICAgIHhDb3MsIHlDb3MsIHpDb3MsXHJcbiAgICBvcmlnaW4pIHtcclxuICAgIGNvbnN0IGFhYmIyTFBTID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIGFhYmIyTFBTLnNldChcclxuICAgICAgICB4Q29zLngsIHlDb3MueCwgekNvcy54LCBvcmlnaW4ueCxcclxuICAgICAgICB4Q29zLnksIHlDb3MueSwgekNvcy55LCBvcmlnaW4ueSxcclxuICAgICAgICB4Q29zLnosIHlDb3MueiwgekNvcy56LCBvcmlnaW4ueixcclxuICAgICAgICAwLCAwLCAwLCAxKTtcclxuXHJcbiAgICByZXR1cm4gYWFiYjJMUFM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gY29vcmRpbmF0ZXMgZnJvbSB3b3JsZCBjb29yZGluYXRlIHRvIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gbHBzMklKS1xyXG4gICAqIEBwYXJhbSB7Kn0gd29ybGRDb29yZGluYXRlc1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICAgIHN0YXRpYyB3b3JsZFRvRGF0YShscHMySUpLLCB3b3JsZENvb3JkaW5hdGVzKSB7XHJcbiAgICBsZXQgZGF0YUNvb3JkaW5hdGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpXHJcbiAgICAgIC5jb3B5KHdvcmxkQ29vcmRpbmF0ZXMpXHJcbiAgICAgIC5hcHBseU1hdHJpeDQobHBzMklKSyk7XHJcblxyXG4gICAgLy8gc2FtZSByb3VuZGluZyBpbiB0aGUgc2hhZGVyc1xyXG4gICAgZGF0YUNvb3JkaW5hdGUuYWRkU2NhbGFyKDAuNSkuZmxvb3IoKTtcclxuXHJcbiAgICByZXR1cm4gZGF0YUNvb3JkaW5hdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdm94ZWwgdmFsdWVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gc3RhY2tcclxuICAgKiBAcGFyYW0geyp9IGNvb3JkaW5hdGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgc3RhdGljIHZhbHVlKHN0YWNrLCBjb29yZGluYXRlKSB7XHJcbiAgICBpZiAoY29vcmRpbmF0ZS56ID49IDAgJiZcclxuICAgICAgICBjb29yZGluYXRlLnogPCBzdGFjay5fZnJhbWUubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBzdGFjay5fZnJhbWVbY29vcmRpbmF0ZS56XS5cclxuICAgICAgICB2YWx1ZShjb29yZGluYXRlLngsIGNvb3JkaW5hdGUueSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGx5IHNsb3BlL2ludGVyY2VwdCB0byBhIHZhbHVlXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICogQHBhcmFtIHsqfSBzbG9wZVxyXG4gICAqIEBwYXJhbSB7Kn0gaW50ZXJjZXB0XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHN0YXRpYyByZXNjYWxlU2xvcGVJbnRlcmNlcHQodmFsdWUsIHNsb3BlLCBpbnRlcmNlcHQpIHtcclxuICAgIHJldHVybiB2YWx1ZSAqIHNsb3BlICsgaW50ZXJjZXB0O1xyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqIFZhbGlkYXRlIGJhc2ljIHN0cnVjdHVyZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vUmV0dXJucyB0cnVlXHJcbiAqIFZKUy5Db3JlLlZhbGlkYXRvcnMubWF0cml4NChuZXcgVEhSRUUuTWF0cml4NCgpKTtcclxuICpcclxuICogLy9SZXR1cm5zIGZhbHNlXHJcbiAqIFZKUy5Db3JlLlZhbGlkYXRvcnMubWF0cml4NChuZXcgVEhSRUUuVmVjdG9yMygpKTtcclxuICpcclxuICogQG1vZHVsZSBjb3JlL3ZhbGlkYXRvcnNcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYWxpZGF0b3JzIHtcclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGVzIGEgbWF0cml4IGFzIGEgVEhSRUVKUy5NYXRyaXg0XHJcbiAgICogbGlua1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RUb1Rlc3QgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIE1hdHJpeDQsIGZhbHNlIGlmIE5PVC5cclxuICAgKi9cclxuICBzdGF0aWMgbWF0cml4NChvYmplY3RUb1Rlc3QpIHtcclxuICAgIGlmICghKG9iamVjdFRvVGVzdCAhPT0gbnVsbCAmJlxyXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgnZWxlbWVudHMnKSAmJlxyXG4gICAgICAgb2JqZWN0VG9UZXN0LmVsZW1lbnRzLmxlbmd0aCA9PT0gMTYgJiZcclxuICAgICAgIHR5cGVvZiBvYmplY3RUb1Rlc3QuaWRlbnRpdHkgPT09ICdmdW5jdGlvbicmJlxyXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdC5jb3B5ID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICB0eXBlb2Ygb2JqZWN0VG9UZXN0LmRldGVybWluYW50ID09PSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIFZhbGlkYXRlcyBhIHZlY3RvciBhcyBhIFRIUkVFSlMuVmVjdG9yM1xyXG4gICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFRvVGVzdCAtIFRoZSBvYmplY3QgdG8gYmUgdGVzdGVkLlxyXG4gICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCBWZWN0b3IzLCBmYWxzZSBpZiBOT1QuXHJcbiAgKi9cclxuICBzdGF0aWMgdmVjdG9yMyhvYmplY3RUb1Rlc3QpIHtcclxuICAgIGlmICghKG9iamVjdFRvVGVzdCAhPT0gbnVsbCAmJlxyXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgneCcpICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ3knKSAmJlxyXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCd6JykgJiZcclxuICAgICAgICFvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ3cnKSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAvKipcclxuICAqIFZhbGlkYXRlcyBhIGJveC5cclxuICAqXHJcbiAgKiBAZXhhbXBsZVxyXG4gICogLy8gYSBib3ggaXMgZGVmaW5lZCBhc1xyXG4gICogbGV0IGJveCA9IHtcclxuICAqICAgY2VudGVyOiBUSFJFRS5WZWN0b3IzLFxyXG4gICogICBoYWxmRGltZW5zaW9uczogVEhSRUUuVmVjdG9yM1xyXG4gICogfVxyXG4gICpcclxuICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RUb1Rlc3QgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cclxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsaWQgYm94LCBmYWxzZSBpZiBOT1QuXHJcbiAgKi9cclxuICBzdGF0aWMgYm94KG9iamVjdFRvVGVzdCkge1xyXG4gICAgaWYgKCEob2JqZWN0VG9UZXN0ICE9PSBudWxsICYmXHJcbiAgICAgICB0eXBlb2Ygb2JqZWN0VG9UZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCdjZW50ZXInKSAmJlxyXG4gICAgICAgdGhpcy52ZWN0b3IzKG9iamVjdFRvVGVzdC5jZW50ZXIpICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ2hhbGZEaW1lbnNpb25zJykgJiZcclxuICAgICAgIHRoaXMudmVjdG9yMyhvYmplY3RUb1Rlc3QuaGFsZkRpbWVuc2lvbnMpICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFsZkRpbWVuc2lvbnMueCA+PSAwICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFsZkRpbWVuc2lvbnMueSA+PSAwICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFsZkRpbWVuc2lvbnMueiA+PSAwKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuIC8qKlxyXG4gICogVmFsaWRhdGVzIGEgcmF5LlxyXG4gICpcclxuICAqIEBleGFtcGxlXHJcbiAgKiAvLyBhIHJheSBpcyBkZWZpbmVkIGFzXHJcbiAgKiBsZXQgcmF5ID0ge1xyXG4gICogICBwb3N0aW9uOiBUSFJFRS5WZWN0b3IzLFxyXG4gICogICBkaXJlY3Rpb246IFRIUkVFLlZlY3RvcjNcclxuICAqIH1cclxuICAqXHJcbiAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0VG9UZXN0IC0gVGhlIG9iamVjdCB0byBiZSB0ZXN0ZWQuXHJcbiAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIHJheSwgZmFsc2UgaWYgTk9ULlxyXG4gICovXHJcbiAgc3RhdGljIHJheShvYmplY3RUb1Rlc3QpIHtcclxuICAgIGlmICghKG9iamVjdFRvVGVzdCAhPT0gbnVsbCAmJlxyXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgncG9zaXRpb24nKSAmJlxyXG4gICAgICAgdGhpcy52ZWN0b3IzKG9iamVjdFRvVGVzdC5wb3NpdGlvbikgJiZcclxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgnZGlyZWN0aW9uJykgJiZcclxuICAgICAgIHRoaXMudmVjdG9yMyhvYmplY3RUb1Rlc3QuZGlyZWN0aW9uKSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgU2xpY2UgZnJvbSAnLi9nZW9tZXRyaWVzLnNsaWNlJztcclxuaW1wb3J0IFZveGVsIGZyb20gJy4vZ2VvbWV0cmllcy52b3hlbCc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBnZW9tZXRyaWVzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIFNsaWNlLFxyXG4gIFZveGVsLFxyXG59O1xyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IGNvcmVJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBJdCBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgY3JlYXRpbmcgYW4gaXJyZWd1bGFyIDNEIHBsYW5hciBzaGFwZSBnaXZlbiBhIGJveCBhbmQgdGhlIGN1dC1wbGFuZS5cclxuICpcclxuICogRGVtbzoge0BsaW5rIGh0dHBzOi8vZm5uZHNjLmdpdGh1Yi5pby92anMjZ2VvbWV0cnlfc2xpY2V9XHJcbiAqXHJcbiAqIEBtb2R1bGUgZ2VvbWV0cmllcy9zbGljZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGhhbGZEaW1lbnNpb25zIC0gSGFsZi1kaW1lbnNpb25zIG9mIHRoZSBib3ggdG8gYmUgc2xpY2VkLlxyXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGNlbnRlciAtIENlbnRlciBvZiB0aGUgYm94IHRvIGJlIHNsaWNlZC5cclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzPFRIUkVFLlZlY3RvcjM+fSBvcmllbnRhdGlvbiAtIE9yaWVudGF0aW9uIG9mIHRoZSBib3ggdG8gYmUgc2xpY2VkLiAobWlnaHQgbm90IGJlIG5lY2Vzc2FyeS4uPylcclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBwb3NpdGlvbiAtIFBvc2l0aW9uIG9mIHRoZSBjdXR0aW5nIHBsYW5lLlxyXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGRpcmVjdGlvbiAtIENyb3NzIGRpcmVjdGlvbiBvZiB0aGUgY3V0dGluZyBwbGFuZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gRGVmaW5lIGJveCB0byBiZSBzbGljZWRcclxuICogbGV0IGhhbGZEaW1lbnNpb25zID0gbmV3IFRIUkVFLlZlY3RvcigxMjMsIDQ1LCA2Nyk7XHJcbiAqIGxldCBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKTtcclxuICogbGV0IG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksXHJcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCksXHJcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSlcclxuICogKTtcclxuICpcclxuICogLy8gRGVmaW5lIHNsaWNlIHBsYW5lXHJcbiAqIGxldCBwb3NpdGlvbiA9IGNlbnRlci5jbG9uZSgpO1xyXG4gKiBsZXQgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoLTAuMiwgMC41LCAwLjMpO1xyXG4gKlxyXG4gKiAvLyBDcmVhdGUgdGhlIHNsaWNlIGdlb21ldHJ5ICYgbWF0ZXJpYWxzXHJcbiAqIGxldCBzbGljZUdlb21ldHJ5ID0gbmV3IFZKUy5nZW9tZXRyaWVzLnNsaWNlKGhhbGZEaW1lbnNpb25zLCBjZW50ZXIsIG9yaWVudGF0aW9uLCBwb3NpdGlvbiwgZGlyZWN0aW9uKTtcclxuICogbGV0IHNsaWNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xyXG4gKiAgICdzaWRlJzogVEhSRUUuRG91YmxlU2lkZSxcclxuICogICAnY29sb3InOiAweEZGNTcyMlxyXG4gKiB9KTtcclxuICpcclxuICogIC8vIENyZWF0ZSBtZXNoIGFuZCBhZGQgaXQgdG8gdGhlIHNjZW5lXHJcbiAqICBsZXQgc2xpY2UgPSBuZXcgVEhSRUUuTWVzaChzbGljZUdlb21ldHJ5LCBzbGljZU1hdGVyaWFsKTtcclxuICogIHNjZW5lLmFkZChzbGljZSk7XHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvbWV0cmllc1NsaWNlIGV4dGVuZHMgVEhSRUUuU2hhcGVHZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihoYWxmRGltZW5zaW9ucywgY2VudGVyLCBwb3NpdGlvbiwgZGlyZWN0aW9uLCB0b0FBQkIgPSBuZXcgVEhSRUUuTWF0cml4NCgpKSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIHByZXBhcmUgZGF0YSBmb3IgdGhlIHNoYXBlIVxyXG4gICAgICAvL1xyXG4gICAgICBsZXQgYWFiYiA9IHtcclxuICAgICAgICBoYWxmRGltZW5zaW9ucyxcclxuICAgICAgICBjZW50ZXIsXHJcbiAgICAgICAgdG9BQUJCLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgbGV0IHBsYW5lID0ge1xyXG4gICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgIGRpcmVjdGlvbixcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEJPT00hXHJcbiAgICAgIGxldCBpbnRlcnNlY3Rpb25zID0gY29yZUludGVyc2VjdGlvbnMuYWFiYlBsYW5lKGFhYmIsIHBsYW5lKTtcclxuXHJcbiAgICAgIC8vIGNhbiBub3QgZXhpc3QgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yXHJcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1dBUk5JTkc6IExlc3MgdGhhbiAzIGludGVyc2VjdGlvbnMgYmV0d2VlbiBBQUJCIGFuZCBQbGFuZS4nKTtcclxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0FBQkInKTtcclxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYWFiYik7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdQbGFuZScpO1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhwbGFuZSk7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdleGl0aW5nLi4uJyk7XHJcbiAgICAgICAgLy8gb3IgdGhyb3cgZXJyb3I/XHJcbiAgICAgICAgdGhyb3cgJ2dlb21ldHJpZXMuc2xpY2UgaGFzIGxlc3MgdGhhbiAzIGludGVyc2VjdGlvbnMsIGNhbiBub3QgY3JlYXRlIGEgdmFsaWQgZ2VvbWV0cnkuJztcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG9yZGVyZWRJbnRlcnNlY3Rpb25zID0gR2VvbWV0cmllc1NsaWNlLm9yZGVySW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBkaXJlY3Rpb24pO1xyXG4gICAgICBsZXQgc2xpY2VTaGFwZSA9IEdlb21ldHJpZXNTbGljZS5zaGFwZShvcmRlcmVkSW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgICAvL1xyXG4gICAgICAvLyBHZW5lcmF0ZSBHZW9tZXRyeSBmcm9tIHNoYXBlXHJcbiAgICAgIC8vIEl0IGRvZXMgdHJpYW5ndWxhdGlvbiBmb3IgdXMhXHJcbiAgICAgIC8vXHJcbiAgICAgIHN1cGVyKHNsaWNlU2hhcGUpO1xyXG4gICAgICB0aGlzLnR5cGUgPSAnU2xpY2VHZW9tZXRyeSc7XHJcblxyXG4gICAgICAvLyB1cGRhdGUgcmVhbCBwb3NpdGlvbiBvZiBlYWNoIHZlcnRleCEgKG5vdCBpbiAyZClcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG9yZGVyZWRJbnRlcnNlY3Rpb25zO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHNoYXBlKHBvaW50cykge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBDcmVhdGUgU2hhcGVcclxuICAgICAgLy9cclxuICAgICAgbGV0IHNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XHJcbiAgICAgIC8vIG1vdmUgdG8gZmlyc3QgcG9pbnQhXHJcbiAgICAgIHNoYXBlLm1vdmVUbyhwb2ludHNbMF0ueHkueCwgcG9pbnRzWzBdLnh5LnkpO1xyXG5cclxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBwb2ludHMhXHJcbiAgICAgIGZvciAobGV0IGwgPSAxOyBsIDwgcG9pbnRzLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgLy8gcHJvamVjdCBlYWNoIG9uIHBsYW5lIVxyXG4gICAgICAgIHNoYXBlLmxpbmVUbyhwb2ludHNbbF0ueHkueCwgcG9pbnRzW2xdLnh5LnkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjbG9zZSB0aGUgc2hhcGUhXHJcbiAgICAgIHNoYXBlLmxpbmVUbyhwb2ludHNbMF0ueHkueCwgcG9pbnRzWzBdLnh5LnkpO1xyXG4gICAgICByZXR1cm4gc2hhcGU7XHJcbiAgICB9XHJcblxyXG4gLyoqXHJcbiAgKlxyXG4gICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZXh0cmFjdCBjZW50ZXIgb2YgbWFzcyBmcm9tIGxpc3Qgb2YgcG9pbnRzLlxyXG4gICpcclxuICAqIEBwcml2YXRlXHJcbiAgKlxyXG4gICogQHBhcmFtIHtBcnJheTxUSFJFRS5WZWN0b3IzPn0gcG9pbnRzIC0gU2V0IG9mIHBvaW50cyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gZXh0cmFjdCB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgKlxyXG4gICogQHJldHVybnMge1RIUkVFLlZlY3RvcjN9IENlbnRlciBvZiBtYXNzIGZyb20gZ2l2ZW4gcG9pbnRzLlxyXG4gICovXHJcbiAgc3RhdGljIGNlbnRlck9mTWFzcyhwb2ludHMpIHtcclxuICAgIGxldCBjZW50ZXJPZk1hc3MgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNlbnRlck9mTWFzcy54ICs9IHBvaW50c1tpXS54O1xyXG4gICAgICBjZW50ZXJPZk1hc3MueSArPSBwb2ludHNbaV0ueTtcclxuICAgICAgY2VudGVyT2ZNYXNzLnogKz0gcG9pbnRzW2ldLno7XHJcbiAgICB9XHJcbiAgICBjZW50ZXJPZk1hc3MuZGl2aWRlU2NhbGFyKHBvaW50cy5sZW5ndGgpO1xyXG5cclxuICAgIHJldHVybiBjZW50ZXJPZk1hc3M7XHJcbiAgfVxyXG5cclxuIC8qKlxyXG4gICpcclxuICAqIE9yZGVyIDNEIHBsYW5hciBwb2ludHMgYXJvdW5kIGEgcmVmZW5jZSBwb2ludC5cclxuICAqXHJcbiAgKiBAcHJpdmF0ZVxyXG4gICpcclxuICAqIEBwYXJhbSB7QXJyYXk8VEhSRUUuVmVjdG9yMz59IHBvaW50cyAtIFNldCBvZiBwbGFuYXIgM0QgcG9pbnRzIHRvIGJlIG9yZGVyZWQuXHJcbiAgKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGRpcmVjdGlvbiAtIERpcmVjdGlvbiBvZiB0aGUgcGxhbmUgaW4gd2hpY2ggcG9pbnRzIGFuZCByZWZlcmVuY2UgYXJlIHNpdHRpbmcuXHJcbiAgKlxyXG4gICogQHJldHVybnMge0FycmF5PE9iamVjdD59IFNldCBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBvcmRlcmVkIHBvaW50cy5cclxuICAqL1xyXG4gIHN0YXRpYyBvcmRlckludGVyc2VjdGlvbnMocG9pbnRzLCBkaXJlY3Rpb24pIHtcclxuICAgIGxldCByZWZlcmVuY2UgPSBHZW9tZXRyaWVzU2xpY2UuY2VudGVyT2ZNYXNzKHBvaW50cyk7XHJcbiAgICAvLyBkaXJlY3Rpb24gZnJvbSBmaXJzdCBwb2ludCB0byByZWZlcmVuY2VcclxuICAgIGxldCByZWZlcmVuY2VEaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgcG9pbnRzWzBdLnggLSByZWZlcmVuY2UueCxcclxuICAgICAgcG9pbnRzWzBdLnkgLSByZWZlcmVuY2UueSxcclxuICAgICAgcG9pbnRzWzBdLnogLSByZWZlcmVuY2UuelxyXG4gICAgICApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIGxldCBiYXNlID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMClcclxuICAgICAgICAuY3Jvc3NWZWN0b3JzKHJlZmVyZW5jZURpcmVjdGlvbiwgZGlyZWN0aW9uKVxyXG4gICAgICAgIC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICBsZXQgb3JkZXJlZHBvaW50cyA9IFtdO1xyXG5cclxuICAgIC8vIG90aGVyIGxpbmVzIC8vIGlmIGludGVyLCByZXR1cm4gbG9jYXRpb24gKyBhbmdsZVxyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgbGV0IHBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgcG9pbnRzW2pdLngsXHJcbiAgICAgICAgcG9pbnRzW2pdLnksXHJcbiAgICAgICAgcG9pbnRzW2pdLnopO1xyXG4gICAgICBwb2ludC5kaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBwb2ludHNbal0ueCAtIHJlZmVyZW5jZS54LFxyXG4gICAgICAgIHBvaW50c1tqXS55IC0gcmVmZXJlbmNlLnksXHJcbiAgICAgICAgcG9pbnRzW2pdLnogLSByZWZlcmVuY2Uueikubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICBsZXQgeCA9IHJlZmVyZW5jZURpcmVjdGlvbi5kb3QocG9pbnQuZGlyZWN0aW9uKTtcclxuICAgICAgbGV0IHkgPSBiYXNlLmRvdChwb2ludC5kaXJlY3Rpb24pO1xyXG4gICAgICBwb2ludC54eSA9IHt4LCB5fTtcclxuXHJcbiAgICAgIGxldCB0aGV0YSA9IE1hdGguYXRhbjIoeSwgeCkgKiAoMTgwIC8gTWF0aC5QSSk7XHJcbiAgICAgIHBvaW50LmFuZ2xlID0gdGhldGE7XHJcblxyXG4gICAgICBvcmRlcmVkcG9pbnRzLnB1c2gocG9pbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIG9yZGVyZWRwb2ludHMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgIHJldHVybiBhLmFuZ2xlIC0gYi5hbmdsZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBub0R1cHMgPSBbb3JkZXJlZHBvaW50c1swXV07XHJcbiAgICBsZXQgZXBzaWxvbiA9IDAuMDAwMTtcclxuICAgIGZvcihsZXQgaT0xOyBpPG9yZGVyZWRwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYoTWF0aC5hYnMob3JkZXJlZHBvaW50c1tpLTFdLmFuZ2xlIC0gb3JkZXJlZHBvaW50c1tpXS5hbmdsZSkgPiBlcHNpbG9uKSB7XHJcbiAgICAgICAgbm9EdXBzLnB1c2gob3JkZXJlZHBvaW50c1tpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbm9EdXBzO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqXHJcbiAqIEBtb2R1bGUgZ2VvbWV0cmllcy92b3hlbFxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdlb21ldHJpZXNWb3hlbCBleHRlbmRzIFRIUkVFLkJveEdlb21ldHJ5IHtcclxuICBjb25zdHJ1Y3RvcihkYXRhUG9zaXRpb24pIHtcclxuICAgIHN1cGVyKDEsIDEsIDEpO1xyXG5cclxuICAgIHRoaXMuX2xvY2F0aW9uID0gZGF0YVBvc2l0aW9uO1xyXG5cclxuICAgIHRoaXMuYXBwbHlNYXRyaXgobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oXHJcbiAgICAgIHRoaXMuX2xvY2F0aW9uLngsXHJcbiAgICAgIHRoaXMuX2xvY2F0aW9uLnksXHJcbiAgICAgIHRoaXMuX2xvY2F0aW9uLnopKTtcclxuXHJcbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICByZXNldFZlcnRpY2VzKCkge1xyXG4gICAgdGhpcy52ZXJ0aWNlc1swXS5zZXQoMC41LCAwLjUsIDAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzFdLnNldCgwLjUsIDAuNSwgLTAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzJdLnNldCgwLjUsIC0wLjUsIDAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzNdLnNldCgwLjUsIC0wLjUsIC0wLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1s0XS5zZXQoLTAuNSwgMC41LCAtMC41KTtcclxuICAgIHRoaXMudmVydGljZXNbNV0uc2V0KC0wLjUsIDAuNSwgMC41KTtcclxuICAgIHRoaXMudmVydGljZXNbNl0uc2V0KC0wLjUsIC0wLjUsIC0wLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1s3XS5zZXQoLTAuNSwgLTAuNSwgMC41KTtcclxuICB9XHJcblxyXG4gIHNldCBsb2NhdGlvbihsb2NhdGlvbikge1xyXG4gICAgdGhpcy5fbG9jYXRpb24gPSBsb2NhdGlvbjtcclxuXHJcbiAgICAvLyB1cGRhdGUgdmVydGljZXMgZnJvbSBsb2NhdGlvblxyXG4gICAgdGhpcy52ZXJ0aWNlc1swXS5zZXQoKyAwLjUsICsgMC41LCArIDAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzFdLnNldCgrIDAuNSwgKyAwLjUsIC0gMC41KTtcclxuICAgIHRoaXMudmVydGljZXNbMl0uc2V0KCsgMC41LCAtIDAuNSwgKyAwLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1szXS5zZXQoKyAwLjUsIC0gMC41LCAtIDAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzRdLnNldCgtIDAuNSwgKyAwLjUsIC0gMC41KTtcclxuICAgIHRoaXMudmVydGljZXNbNV0uc2V0KC0gMC41LCArIDAuNSwgKyAwLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1s2XS5zZXQoLSAwLjUsIC0gMC41LCAtIDAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzddLnNldCgtIDAuNSwgLSAwLjUsICsgMC41KTtcclxuXHJcbiAgICB0aGlzLmFwcGx5TWF0cml4KFxyXG4gICAgICBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbihcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbi54LFxyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uLnksXHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24ueikpO1xyXG5cclxuICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGdldCBsb2NhdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbjtcclxuICB9XHJcblxyXG5cclxufVxyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvYm9yZGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzQm9yZGVyIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xyXG4gIGNvbnN0cnVjdG9yKGhlbHBlcnNTbGljZSkge1xyXG4gICAgLy9cclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5faGVscGVyc1NsaWNlID0gaGVscGVyc1NsaWNlO1xyXG5cclxuICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xyXG4gICAgdGhpcy5fY29sb3IgPSAweGZmMDAwMDtcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcclxuICAgIHRoaXMuX21lc2ggPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2NyZWF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgc2V0IGhlbHBlcnNTbGljZShoZWxwZXJzU2xpY2UpIHtcclxuICAgIHRoaXMuX2hlbHBlcnNTbGljZSA9IGhlbHBlcnNTbGljZTtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhlbHBlcnNTbGljZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9oZWxwZXJzU2xpY2U7XHJcbiAgfVxyXG5cclxuICBzZXQgdmlzaWJsZSh2aXNpYmxlKSB7XHJcbiAgICB0aGlzLl92aXNpYmxlID0gdmlzaWJsZTtcclxuICAgIGlmICh0aGlzLl9tZXNoKSB7XHJcbiAgICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgdmlzaWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yKGNvbG9yKSB7XHJcbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xyXG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgY29sb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29sb3I7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICB0aGlzLl9tYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7XHJcbiAgICAgICAgY29sb3I6IHRoaXMuX2NvbG9yLFxyXG4gICAgICAgIGxpbmV3aWR0aDogMSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuICAgIGlmICghdGhpcy5faGVscGVyc1NsaWNlLmdlb21ldHJ5LnZlcnRpY2VzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9oZWxwZXJzU2xpY2UuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oZWxwZXJzU2xpY2UuZ2VvbWV0cnkudmVydGljZXNbaV0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oZWxwZXJzU2xpY2UuZ2VvbWV0cnkudmVydGljZXNbMF0pO1xyXG5cclxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgaWYgKHRoaXMuX2hlbHBlcnNTbGljZS5hYWJiU3BhY2UgPT09ICdJSksnKSB7XHJcbiAgICAgIHRoaXMuX21lc2guYXBwbHlNYXRyaXgodGhpcy5faGVscGVyc1NsaWNlLnN0YWNrLmlqazJMUFMpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbWVzaC52aXNpYmxlID0gdGhpcy5fdmlzaWJsZTtcclxuXHJcbiAgICAvLyBhbmQgYWRkIGl0IVxyXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlKCkge1xyXG4gICAgLy8gdXBkYXRlIHNsaWNlXHJcbiAgICBpZiAodGhpcy5fbWVzaCkge1xyXG4gICAgICB0aGlzLnJlbW92ZSh0aGlzLl9tZXNoKTtcclxuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NyZWF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuX21lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fbWVzaC5tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tYXRlcmlhbC5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgfVxyXG59XHJcbiIsIlxyXG4vKipcclxuICogQG1vZHVsZSBoZWxwZXJzL2JvdW5kaW5nYm94XHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc0JvdW5kaW5nQm94IGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xyXG4gIGNvbnN0cnVjdG9yKHN0YWNrKSB7XHJcbiAgICAvL1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvLyBwcml2YXRlIHZhcnNcclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcclxuICAgIHRoaXMuX2NvbG9yID0gMHhGRkZGRkY7XHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuXHJcbiAgICAvLyBjcmVhdGUgb2JqZWN0XHJcbiAgICB0aGlzLl9jcmVhdGUoKTtcclxuICB9XHJcblxyXG4gIC8vIGdldHRlcnMvc2V0dGVyc1xyXG4gIHNldCB2aXNpYmxlKHZpc2libGUpIHtcclxuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgaWYgKHRoaXMuX21lc2gpIHtcclxuICAgICAgdGhpcy5fbWVzaC52aXNpYmxlID0gdGhpcy5fdmlzaWJsZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCB2aXNpYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgfVxyXG5cclxuICBzZXQgY29sb3IoY29sb3IpIHtcclxuICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XHJcbiAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBjb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICB9XHJcblxyXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xyXG4gIF9jcmVhdGUoKSB7XHJcbiAgICAvLyBDb252ZW5pZW5jZSB2YXJzXHJcbiAgICBsZXQgZGltZW5zaW9ucyA9IHRoaXMuX3N0YWNrLmRpbWVuc2lvbnNJSks7XHJcbiAgICBsZXQgaGFsZkRpbWVuc2lvbnMgPSB0aGlzLl9zdGFjay5oYWxmRGltZW5zaW9uc0lKSztcclxuICAgIGxldCBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygtMC41LCAtMC41LCAtMC41KTtcclxuXHJcbiAgICAvLyBHZW9tZXRyeVxyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoXHJcbiAgICAgIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLnopO1xyXG4gICAgLy8gcG9zaXRpb24gYmJveCBpbiBpbWFnZSBzcGFjZVxyXG4gICAgdGhpcy5fZ2VvbWV0cnkgLmFwcGx5TWF0cml4KG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKFxyXG4gICAgICBoYWxmRGltZW5zaW9ucy54ICsgb2Zmc2V0LngsXHJcbiAgICAgIGhhbGZEaW1lbnNpb25zLnkgKyBvZmZzZXQueSxcclxuICAgICAgaGFsZkRpbWVuc2lvbnMueiArIG9mZnNldC56KSk7XHJcblxyXG5cclxuICAgIC8vIE1lc2hcclxuICAgIGxldCBib3hNZXNoID1cclxuICAgICAgbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgweGZmMDAwMCkpO1xyXG4gICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5Cb3hIZWxwZXIoYm94TWVzaCwgdGhpcy5fY29sb3IpO1xyXG5cclxuICAgIC8vIE1hdGVyaWFsXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IHRoaXMuX21lc2gubWF0ZXJpYWw7XHJcblxyXG4gICAgLy8gcG9zaXRpb24gYmJveCBpbiB3b3JsZCBzcGFjZVxyXG4gICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9zdGFjay5pamsyTFBTKTtcclxuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XHJcblxyXG4gICAgLy8gYW5kIGFkZCBpdCFcclxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZSgpIHtcclxuICAgIC8vIHVwZGF0ZSBzbGljZVxyXG4gICAgaWYgKHRoaXMuX21lc2gpIHtcclxuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XHJcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgdGhpcy5fbWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcbiAgICAgIHRoaXMuX21lc2gubWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jcmVhdGUoKTtcclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX21lc2gubWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQm9yZGVyIGZyb20gJy4vaGVscGVycy5ib3JkZXInO1xyXG5pbXBvcnQgQm91bmRpbmdCb3ggZnJvbSAnLi9oZWxwZXJzLmJvdW5kaW5nYm94JztcclxuaW1wb3J0IExvY2FsaXplciBmcm9tICcuL2hlbHBlcnMubG9jYWxpemVyJztcclxuaW1wb3J0IEx1dCBmcm9tICcuL2hlbHBlcnMubHV0JztcclxuaW1wb3J0IFByb2dyZXNzQmFyIGZyb20gJy4vaGVscGVycy5wcm9ncmVzc2Jhcic7XHJcbmltcG9ydCBQcm9ncmVzc0JhckV2ZW50QmFzZWQgZnJvbSAnLi9oZWxwZXJzLnByb2dyZXNzYmFyLmV2ZW50YmFzZWQnO1xyXG5pbXBvcnQgU2xpY2UgZnJvbSAnLi9oZWxwZXJzLnNsaWNlJztcclxuaW1wb3J0IFN0YWNrIGZyb20gJy4vaGVscGVycy5zdGFjayc7XHJcbmltcG9ydCBWb2x1bWVSZW5kZXJpbmcgZnJvbSAnLi9oZWxwZXJzLnZvbHVtZXJlbmRlcmluZyc7XHJcbmltcG9ydCBYIGZyb20gJy4veC9oZWxwZXJzLngnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVyc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBCb3JkZXIsXHJcbiAgQm91bmRpbmdCb3gsXHJcbiAgTG9jYWxpemVyLFxyXG4gIEx1dCxcclxuICBQcm9ncmVzc0JhcixcclxuICBQcm9ncmVzc0JhckV2ZW50QmFzZWQsXHJcbiAgU2xpY2UsXHJcbiAgU3RhY2ssXHJcbiAgVm9sdW1lUmVuZGVyaW5nLFxyXG4gIFgsXHJcbn07XHJcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xyXG5pbXBvcnQgU2hhZGVyc1VuaWZvcm0gZnJvbVxyXG4gICcuLi9zaGFkZXJzL3NoYWRlcnMubG9jYWxpemVyLnVuaWZvcm0nO1xyXG5pbXBvcnQgU2hhZGVyc1ZlcnRleCBmcm9tXHJcbiAgJy4uL3NoYWRlcnMvc2hhZGVycy5sb2NhbGl6ZXIudmVydGV4JztcclxuaW1wb3J0IFNoYWRlcnNGcmFnbWVudCBmcm9tXHJcbiAgJy4uL3NoYWRlcnMvc2hhZGVycy5sb2NhbGl6ZXIuZnJhZ21lbnQnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9sb2NhbGl6ZXJcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzTG9jYWxpemVyIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xyXG4gIGNvbnN0cnVjdG9yKHN0YWNrLCBnZW9tZXRyeSwgcmVmZXJlbmNlUGxhbmUpIHtcclxuICAgIC8vXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcbiAgICB0aGlzLl9yZWZlcmVuY2VQbGFuZSA9IHJlZmVyZW5jZVBsYW5lO1xyXG4gICAgdGhpcy5fcGxhbmUxID0gbnVsbDtcclxuICAgIHRoaXMuX2NvbG9yMSA9IG51bGw7XHJcbiAgICB0aGlzLl9wbGFuZTIgPSBudWxsO1xyXG4gICAgdGhpcy5fY29sb3IyID0gbnVsbDtcclxuICAgIHRoaXMuX3BsYW5lMyA9IG51bGw7XHJcbiAgICB0aGlzLl9jb2xvcjMgPSBudWxsO1xyXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xyXG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gMDtcclxuICAgIHRoaXMuX3NoYWRlcnNGcmFnbWVudCA9IFNoYWRlcnNGcmFnbWVudDtcclxuICAgIHRoaXMuX3NoYWRlcnNWZXJ0ZXggPSBTaGFkZXJzVmVydGV4O1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSBTaGFkZXJzVW5pZm9ybS51bmlmb3JtcygpO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHJcbiAgICB0aGlzLl9jcmVhdGUoKTtcclxuICB9XHJcblxyXG4gIF9jcmVhdGUoKSB7XHJcbiAgICB0aGlzLl9wcmVwYXJlTWF0ZXJpYWwoKTtcclxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTWVzaCh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9zdGFjay5faWprMkxQUyk7XHJcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcclxuICB9XHJcblxyXG4gIF9wcmVwYXJlTWF0ZXJpYWwoKSB7XHJcbiAgICBpZiAoIXRoaXMubWF0ZXJpYWwpIHtcclxuICAgICAgLy8gcmVmZXJlbmNlIHBsYW5lXHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVTbGljZS52YWx1ZSA9IHRoaXMuX3JlZmVyZW5jZVBsYW5lO1xyXG5cclxuICAgICAgLy8gbG9jYWxpemVyIHBsYW5lc1xyXG4gICAgICBpZiAodGhpcy5fcGxhbmUxKSB7XHJcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lMS52YWx1ZSA9IHRoaXMuX3BsYW5lMTtcclxuICAgICAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmVDb2xvcjEudmFsdWUgPSB0aGlzLl9jb2xvcjE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9wbGFuZTIpIHtcclxuICAgICAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmUyLnZhbHVlID0gdGhpcy5fcGxhbmUyO1xyXG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZUNvbG9yMi52YWx1ZSA9IHRoaXMuX2NvbG9yMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX3BsYW5lMykge1xyXG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZTMudmFsdWUgPSB0aGlzLl9wbGFuZTM7XHJcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lQ29sb3IzLnZhbHVlID0gdGhpcy5fY29sb3IzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL1xyXG4gICAgICB0aGlzLl91bmlmb3Jtcy51Q2FudmFzV2lkdGgudmFsdWUgPSB0aGlzLl9jYW52YXNXaWR0aDtcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc0hlaWdodC52YWx1ZSA9IHRoaXMuX2NhbnZhc0hlaWdodDtcclxuXHJcbiAgICAgIC8vIGdlbmVyYXRlIG1hdGVyaWFsXHJcbiAgICAgIGxldCBmcyA9IG5ldyBTaGFkZXJzRnJhZ21lbnQodGhpcy5fdW5pZm9ybXMpO1xyXG4gICAgICBsZXQgdnMgPSBuZXcgU2hhZGVyc1ZlcnRleCgpO1xyXG4gICAgICB0aGlzLl9tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbChcclxuICAgICAgICB7c2lkZTogVEhSRUUuRG91YmxlU2lkZSxcclxuICAgICAgICAgdW5pZm9ybXM6IHRoaXMuX3VuaWZvcm1zLFxyXG4gICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHZzLmNvbXB1dGUoKSxcclxuICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzLmNvbXB1dGUoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgdGhpcy5fbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgaWYgKHRoaXMuX21lc2gpIHtcclxuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XHJcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgZ2VvbWV0cnkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XHJcbiAgfVxyXG5cclxuICBzZXQgZ2VvbWV0cnkoZ2VvbWV0cnkpIHtcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblxyXG4gICAgaWYgKHRoaXMuX21lc2gpIHtcclxuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XHJcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgcmVmZXJlbmNlUGxhbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlUGxhbmU7XHJcbiAgfVxyXG5cclxuICBzZXQgcmVmZXJlbmNlUGxhbmUocmVmZXJlbmNlUGxhbmUpIHtcclxuICAgIHRoaXMuX3JlZmVyZW5jZVBsYW5lID0gcmVmZXJlbmNlUGxhbmU7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51U2xpY2UudmFsdWUgPSB0aGlzLl9yZWZlcmVuY2VQbGFuZTtcclxuICB9XHJcblxyXG4gIGdldCBwbGFuZTEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGxhbmUxO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBsYW5lMShwbGFuZTEpIHtcclxuICAgIHRoaXMuX3BsYW5lMSA9IHBsYW5lMTtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZTEudmFsdWUgPSB0aGlzLl9wbGFuZTE7XHJcbiAgfVxyXG5cclxuICBnZXQgY29sb3IxKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yMTtcclxuICB9XHJcblxyXG4gIHNldCBjb2xvcjEoY29sb3IxKSB7XHJcbiAgICB0aGlzLl9jb2xvcjEgPSBjb2xvcjE7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmVDb2xvcjEudmFsdWUgPSB0aGlzLl9jb2xvcjE7XHJcbiAgfVxyXG5cclxuICBnZXQgcGxhbmUyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lMjtcclxuICB9XHJcblxyXG4gIHNldCBwbGFuZTIocGxhbmUyKSB7XHJcbiAgICB0aGlzLl9wbGFuZTIgPSBwbGFuZTI7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmUyLnZhbHVlID0gdGhpcy5fcGxhbmUyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbG9yMigpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2xvcjI7XHJcbiAgfVxyXG5cclxuICBzZXQgY29sb3IyKGNvbG9yMikge1xyXG4gICAgdGhpcy5fY29sb3IyID0gY29sb3IyO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lQ29sb3IyLnZhbHVlID0gdGhpcy5fY29sb3IyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBsYW5lMygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wbGFuZTM7XHJcbiAgfVxyXG5cclxuICBzZXQgcGxhbmUzKHBsYW5lMykge1xyXG4gICAgdGhpcy5fcGxhbmUzID0gcGxhbmUzO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lMy52YWx1ZSA9IHRoaXMuX3BsYW5lMztcclxuICB9XHJcblxyXG4gIGdldCBjb2xvcjMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29sb3IzO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yMyhjb2xvcjMpIHtcclxuICAgIHRoaXMuX2NvbG9yMyA9IGNvbG9yMztcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZUNvbG9yMy52YWx1ZSA9IHRoaXMuX2NvbG9yMztcclxuICB9XHJcblxyXG4gIGdldCBjYW52YXNXaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYW52YXNXaWR0aDtcclxuICB9XHJcblxyXG4gIHNldCBjYW52YXNXaWR0aChjYW52YXNXaWR0aCkge1xyXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNXaWR0aC52YWx1ZSA9IHRoaXMuX2NhbnZhc1dpZHRoO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYW52YXNIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBzZXQgY2FudmFzSGVpZ2h0KGNhbnZhc0hlaWdodCkge1xyXG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc0hlaWdodC52YWx1ZSA9IHRoaXMuX2NhbnZhc0hlaWdodDtcclxuICB9XHJcbn1cclxuIiwiXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvbHV0XHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc0x1dCB7XHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVySUQsXHJcbiAgICAgICAgICAgICAgbHV0ID0gJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgIGx1dE8gPSAnbGluZWFyJyxcclxuICAgICAgICAgICAgICBjb2xvciA9IFtbMCwgMCwgMCwgMF0sIFsxLCAxLCAxLCAxXV0sXHJcbiAgICAgICAgICAgICAgb3BhY2l0eSA9IFtbMCwgMF0sIFsxLCAxXV0sXHJcbiAgICAgICAgICAgICAgZGlzY3JldGUgPSBmYWxzZSkge1xyXG4gICAgLy8gbWluL21heCAoMC0xIG9yIHJlYWwgaW50ZW5zaXRpZXMpXHJcbiAgICAvLyBzaG93L2hpZGVcclxuICAgIC8vIGhvcml6b250YWwvdmVydGljYWxcclxuICAgIHRoaXMuX2NvbnRhaW5lcklEID0gY29udGFpbmVySUQ7XHJcblxyXG4gICAgdGhpcy5fZGlzY3JldGUgPSBkaXNjcmV0ZTtcclxuICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XHJcbiAgICB0aGlzLl9sdXQgPSBsdXQ7XHJcbiAgICB0aGlzLl9sdXRzID0ge1tsdXRdOiBjb2xvcn07XHJcblxyXG4gICAgdGhpcy5fb3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgICB0aGlzLl9sdXRPID0gbHV0TztcclxuICAgIHRoaXMuX2x1dHNPID0ge1tsdXRPXTogb3BhY2l0eX07XHJcblxyXG4gICAgdGhpcy5pbml0Q2FudmFzKCk7XHJcbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XHJcbiAgfVxyXG5cclxuICBpbml0Q2FudmFzKCkge1xyXG4gICAgLy8gY29udGFpbmVyXHJcbiAgICB0aGlzLl9jYW52YXNDb250YWluZXIgPSB0aGlzLmluaXRDYW52YXNDb250YWluZXIodGhpcy5fY29udGFpbmVySUQpO1xyXG4gICAgLy8gYmFja2dyb3VuZFxyXG4gICAgdGhpcy5fY2FudmFzQmcgPSB0aGlzLmNyZWF0ZUNhbnZhcygpO1xyXG4gICAgdGhpcy5fY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhc0JnKTtcclxuICAgIC8vIGZvcmVncm91bmRcclxuICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKCk7XHJcbiAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKTtcclxuICB9XHJcblxyXG4gIGluaXRDYW52YXNDb250YWluZXIoY2FudmFzQ29udGFpbmVySWQpIHtcclxuICAgIGxldCBjYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNDb250YWluZXJJZCk7XHJcbiAgICBjYW52YXNDb250YWluZXIuc3R5bGUud2lkdGggPSAnMjU2IHB4JztcclxuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMTI4IHB4JztcclxuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICNGOUY5RjknO1xyXG4gICAgcmV0dXJuIGNhbnZhc0NvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIGNyZWF0ZUNhbnZhcygpIHtcclxuICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSAxNjtcclxuICAgIGNhbnZhcy53aWR0aCA9IDI1NjtcclxuICAgIHJldHVybiBjYW52YXM7XHJcbiAgfVxyXG5cclxuICBwYWludENhbnZhcygpIHtcclxuICAgIC8vIHNldHVwIGNvbnRleHRcclxuICAgIGxldCBjdHggPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcclxuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xyXG5cclxuICAgIC8vIGFwcGx5IGNvbG9yXHJcbiAgICBpZiAoIXRoaXMuX2Rpc2NyZXRlKSB7XHJcbiAgICAgIGxldCBjb2xvciA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NvbG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29sb3IuYWRkQ29sb3JTdG9wKHRoaXMuX2NvbG9yW2ldWzBdLCBgcmdiYSggJHtNYXRoLnJvdW5kKHRoaXMuX2NvbG9yW2ldWzFdICogMjU1KX0sICR7TWF0aC5yb3VuZCh0aGlzLl9jb2xvcltpXVsyXSAqIDI1NSl9LCAke01hdGgucm91bmQodGhpcy5fY29sb3JbaV1bM10gKiAyNTUpfSwgMSlgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN0eC5saW5lV2lkdGg9Mip0aGlzLl9jYW52YXMuaGVpZ2h0O1xyXG5cclxuICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX2NvbG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSB0aGlzLl9jb2xvcltpXVswXTtcclxuICAgICAgICBsZXQgbmV4dFBvcyA9IDE7XHJcbiAgICAgICAgaWYgKGkgPCB0aGlzLl9jb2xvci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICBuZXh0UG9zID0gdGhpcy5fY29sb3JbaSsxXVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHByZXZpb3VzUG9zID0gMDtcclxuICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgIHByZXZpb3VzUG9zID0gdGhpcy5fY29sb3JbaS0xXVswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmcm9tID0gcHJldmlvdXNQb3MgKyAoY3VycmVudFBvcyAtIHByZXZpb3VzUG9zKS8yO1xyXG4gICAgICAgIGxldCB0byA9IGN1cnJlbnRQb3MgKyAobmV4dFBvcyAtIGN1cnJlbnRQb3MpLzI7XHJcbiAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5fY29sb3JbaV07XHJcbiAgICAgICAgbGV0IG9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5W2ldID8gdGhpcy5fb3BhY2l0eVtpXVsxXSA6IDE7XHJcblxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBgcmdiYSggJHtNYXRoLnJvdW5kKGNvbG9yWzFdICogMjU1KX0sICR7TWF0aC5yb3VuZChjb2xvclsyXSAqIDI1NSl9LCAke01hdGgucm91bmQoY29sb3JbM10gKiAyNTUpfSwgJHtvcGFjaXR5fSlgO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oZnJvbSp0aGlzLl9jYW52YXMud2lkdGgsIDApO1xyXG4gICAgICAgIGN0eC5saW5lVG8odG8qdGhpcy5fY2FudmFzLndpZHRoLCAwKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9kaXNjcmV0ZSkge1xyXG4gICAgICAvLyBpZiBkaXNjcmV0ZSwgd2UgYWxyZWFkeSB0b29rIGNhcmUgb2YgdGhlIG9wYWNpdHkuXHJcbiAgICAgIC8vIHNldHVwIGNvbnRleHRcclxuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XHJcblxyXG4gICAgICAvLyBhcHBseSBvcGFjaXR5XHJcbiAgICAgIGxldCBvcGFjaXR5ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fb3BhY2l0eS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG9wYWNpdHkuYWRkQ29sb3JTdG9wKHRoaXMuX29wYWNpdHlbaV1bMF0sICdyZ2JhKDI1NSwgMjU1LCAyNTUsICcgKyB0aGlzLl9vcGFjaXR5W2ldWzFdICsgJyknKTtcclxuICAgICAgfVxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3BhY2l0eTtcclxuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgdGV4dHVyZSgpIHtcclxuICAgIGxldCB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUodGhpcy5fY2FudmFzKTtcclxuICAgIHRleHR1cmUubWFwcGluZyA9IFRIUkVFLlVWTWFwcGluZztcclxuICAgIHRleHR1cmUud3JhcFMgPSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuICAgIHRleHR1cmUubWFnRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xyXG4gICAgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID0gdHJ1ZTtcclxuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgfVxyXG5cclxuICBzZXQgbHV0KHRhcmdldExVVCkge1xyXG4gICAgdGhpcy5fY29sb3IgPSB0aGlzLl9sdXRzW3RhcmdldExVVF07XHJcbiAgICB0aGlzLl9sdXQgPSB0YXJnZXRMVVQ7XHJcblxyXG4gICAgdGhpcy5wYWludENhbnZhcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGx1dCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9sdXQ7XHJcbiAgfVxyXG5cclxuICBzZXQgbHV0cyhuZXdMdXRzKSB7XHJcbiAgICB0aGlzLl9sdXRzID0gbmV3THV0cztcclxuICB9XHJcblxyXG4gIGdldCBsdXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2x1dHM7XHJcbiAgfVxyXG5cclxuICBzZXQgbHV0Tyh0YXJnZXRMVVRPKSB7XHJcbiAgICB0aGlzLl9vcGFjaXR5ID0gdGhpcy5fbHV0c09bdGFyZ2V0TFVUT107XHJcbiAgICB0aGlzLl9sdXRPID0gdGFyZ2V0TFVUTztcclxuXHJcbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgbHV0TygpIHtcclxuICAgIHJldHVybiB0aGlzLl9sdXRPO1xyXG4gIH1cclxuXHJcbiAgc2V0IGx1dHNPKG5ld0x1dHNPKSB7XHJcbiAgICB0aGlzLl9sdXRzTyA9IG5ld0x1dHNPO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGx1dHNPKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2x1dHNPO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRpc2NyZXRlKGRpc2NyZXRlKSB7XHJcbiAgICB0aGlzLl9kaXNjcmV0ZSA9IGRpc2NyZXRlO1xyXG5cclxuICAgIHRoaXMucGFpbnRDYW52YXMoKTtcclxuICB9XHJcblxyXG4gIGdldCBkaXNjcmV0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kaXNjcmV0ZTtcclxuICB9XHJcblxyXG4gIGx1dHNBdmFpbGFibGUodHlwZSA9ICdjb2xvcicpIHtcclxuICAgIGxldCBhdmFpbGFibGUgPSBbXTtcclxuICAgIGxldCBsdXRzID0gdGhpcy5fbHV0cztcclxuXHJcbiAgICBpZiAodHlwZSAhPT0gJ2NvbG9yJykge1xyXG4gICAgICBsdXRzID0gdGhpcy5fbHV0c087XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSBpbiBsdXRzKSB7XHJcbiAgICAgIGF2YWlsYWJsZS5wdXNoKGkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhdmFpbGFibGU7XHJcbiAgfVxyXG5cclxuICAvLyBhZGQgbHV0cyB0byBjbGFzcycgbHV0IChzbyBhIHVzZXIgY2FuIGFkZCBpdHMgb3duIGFzIHdlbGwpXHJcbiAgc3RhdGljIHByZXNldEx1dHMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnZGVmYXVsdCc6IFtbMCwgMCwgMCwgMF0sIFsxLCAxLCAxLCAxXV0sXHJcbiAgICAgICdzcGVjdHJ1bSc6IFtbMCwgMCwgMCwgMF0sIFswLjEsIDAsIDAsIDFdLCBbMC4zMywgMCwgMSwgMV0sIFswLjUsIDAsIDEsIDBdLCBbMC42NiwgMSwgMSwgMF0sIFswLjksIDEsIDAsIDBdLCBbMSwgMSwgMSwgMV1dLFxyXG4gICAgICAnaG90X2FuZF9jb2xkJzogW1swLCAwLCAwLCAxXSwgWzAuMTUsIDAsIDEsIDFdLCBbMC4zLCAwLCAxLCAwXSwgWzAuNDUsIDAsIDAsIDBdLCBbMC41LCAwLCAwLCAwXSwgWzAuNTUsIDAsIDAsIDBdLCBbMC43LCAxLCAxLCAwXSwgWzAuODUsIDEsIDAsIDBdLCBbMSwgMSwgMSwgMV1dLFxyXG4gICAgICAnZ29sZCc6IFtbMCwgMCwgMCwgMF0sIFswLjEzLCAwLjE5LCAwLjAzLCAwXSwgWzAuMjUsIDAuMzksIDAuMTIsIDBdLCBbMC4zOCwgMC41OSwgMC4yNiwgMF0sIFswLjUwLCAwLjgwLCAwLjQ2LCAwLjA4XSwgWzAuNjMsIDAuOTksIDAuNzEsIDAuMjFdLCBbMC43NSwgMC45OSwgMC44OCwgMC4zNF0sIFswLjg4LCAwLjk5LCAwLjk5LCAwLjQ4XSwgWzEsIDAuOTAsIDAuOTUsIDAuNjFdXSxcclxuICAgICAgJ3JlZCc6IFtbMCwgMC43NSwgMCwgMF0sIFswLjUsIDEsIDAuNSwgMF0sIFswLjk1LCAxLCAxLCAwXSwgWzEsIDEsIDEsIDFdXSxcclxuICAgICAgJ2dyZWVuJzogW1swLCAwLCAwLjc1LCAwXSwgWzAuNSwgMC41LCAxLCAwXSwgWzAuOTUsIDEsIDEsIDBdLCBbMSwgMSwgMSwgMV1dLFxyXG4gICAgICAnYmx1ZSc6IFtbMCwgMCwgMCwgMV0sIFswLjUsIDAsIDAuNSwgMV0sIFswLjk1LCAwLCAxLCAxXSwgWzEsIDEsIDEsIDFdXSxcclxuICAgICAgJ3dhbGtpbmdfZGVhZCc6IFtbMCwgMC4xLCAxLCAxXSwgWzEsIDEsIDEsIDFdXSxcclxuICAgICAgJ3JhbmRvbSc6IFtbMCwgMCwgMCwgMF0sIFswLjI3LCAwLjE4LCAwLjE4LCAwLjE4XSwgWzAuNDEsIDEsIDEsIDFdLCBbMC43LCAxLCAwLCAwXSwgWzEsIDEsIDEsIDFdXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcHJlc2V0THV0c08oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnbGluZWFyJzogW1swLCAwXSwgWzEsIDFdXSxcclxuICAgICAgJ2xvd3Bhc3MnOiBbWzAsIDAuOF0sIFswLjIsIDAuNl0sIFswLjMsIDAuMV0sIFsxLCAwXV0sXHJcbiAgICAgICdiYW5kcGFzcyc6IFtbMCwgMF0sIFswLjQsIDAuOF0sIFswLjYsIDAuOF0sIFsxLCAwXV0sXHJcbiAgICAgICdoaWdocGFzcyc6IFtbMCwgMF0sIFswLjcsIDAuMV0sIFswLjgsIDAuNl0sIFsxLCAwLjhdXSxcclxuICAgICAgJ2ZsYXQnOiBbWzAsIC43XSwgWzEsIDFdXSxcclxuICAgICAgJ3JhbmRvbSc6IFtbMCwgMC5dLCBbMC4zOCwgMC5dLCBbMC41NSwgMS5dLCBbMC43MiwgMS5dLCBbMSwgMC4wNV1dLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG59XHJcbiIsIi8qKlxyXG4gKiBIZWxwZXJzIG1hdGVyaWFsIG1peGluLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvbWF0ZXJpYWwvbWl4aW5cclxuICovXHJcblxyXG5sZXQgSGVybHBlcnNNYXRlcmlhbE1peGluID0gKHN1cGVyY2xhc3MpID0+IGNsYXNzIGV4dGVuZHMgc3VwZXJjbGFzcyB7XHJcblxyXG4gIF9jcmVhdGVNYXRlcmlhbChleHRyYU9wdGlvbnMpIHtcclxuICAgIC8vIGdlbmVyYXRlIHNoYWRlcnMgb24tZGVtYW5kIVxyXG4gICAgbGV0IGZzID0gbmV3IHRoaXMuX3NoYWRlcnNGcmFnbWVudCh0aGlzLl91bmlmb3Jtcyk7XHJcbiAgICBsZXQgdnMgPSBuZXcgdGhpcy5fc2hhZGVyc1ZlcnRleCgpO1xyXG5cclxuICAgIC8vIG1hdGVyaWFsXHJcbiAgICBsZXQgZ2xvYmFsT3B0aW9ucyA9IHtcclxuICAgICAgdW5pZm9ybXM6IHRoaXMuX3VuaWZvcm1zLFxyXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzLmNvbXB1dGUoKSxcclxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzLmNvbXB1dGUoKSxcclxuICAgIH07XHJcblxyXG4gICAgbGV0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGV4dHJhT3B0aW9ucywgZ2xvYmFsT3B0aW9ucyk7XHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbChvcHRpb25zKTtcclxuICAgIHRoaXMuX21hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVNYXRlcmlhbCgpIHtcclxuICAgIC8vIGdlbmVyYXRlIHNoYWRlcnMgb24tZGVtYW5kIVxyXG4gICAgbGV0IGZzID0gbmV3IHRoaXMuX3NoYWRlcnNGcmFnbWVudCh0aGlzLl91bmlmb3Jtcyk7XHJcbiAgICBsZXQgdnMgPSBuZXcgdGhpcy5fc2hhZGVyc1ZlcnRleCgpO1xyXG5cclxuICAgIHRoaXMuX21hdGVyaWFsLnZlcnRleFNoYWRlciA9IHZzLmNvbXB1dGUoKTtcclxuICAgIHRoaXMuX21hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gZnMuY29tcHV0ZSgpO1xyXG5cclxuICAgIHRoaXMuX21hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIF9wcmVwYXJlVGV4dHVyZSgpIHtcclxuICAgIHRoaXMuX3RleHR1cmVzID0gW107XHJcbiAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMuX3N0YWNrLl9yYXdEYXRhLmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgIGxldCB0ZXggPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoXHJcbiAgICAgICAgdGhpcy5fc3RhY2sucmF3RGF0YVttXSxcclxuICAgICAgICB0aGlzLl9zdGFjay50ZXh0dXJlU2l6ZSxcclxuICAgICAgICB0aGlzLl9zdGFjay50ZXh0dXJlU2l6ZSxcclxuICAgICAgICB0aGlzLl9zdGFjay50ZXh0dXJlVHlwZSxcclxuICAgICAgICBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlLFxyXG4gICAgICAgIFRIUkVFLlVWTWFwcGluZyxcclxuICAgICAgICBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLFxyXG4gICAgICAgIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsXHJcbiAgICAgICAgVEhSRUUuTmVhcmVzdEZpbHRlcixcclxuICAgICAgICBUSFJFRS5OZWFyZXN0RmlsdGVyKTtcclxuICAgICAgdGV4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgdGV4LmZsaXBZID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fdGV4dHVyZXMucHVzaCh0ZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZXJscGVyc01hdGVyaWFsTWl4aW47XHJcbiIsImltcG9ydCBDb3JlVXRpbHMgZnJvbSAnLi4vY29yZS9jb3JlLnV0aWxzJztcclxuLyoqXHJcbiAqIEV2ZW50IEJhc2VkIHByb2dyZXNzYmFyXHJcbiAqIEBtb2R1bGUgaGVscGVycy9wcm9ncmVzc0JhclxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBsZXQgbG9hZGVyID0gbmV3IExvYWRlcnNWb2x1bWUoKTtcclxuICogY29uc3QgZG9tQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyZXNzYmFyJyk7XHJcbiAqIGNvbnN0IHBiID0gbmV3IEhlbHBlcnNQcm9ncmVzc0JhckV2ZW50QmFzZWQobG9hZGVyLCBkb21Db250YWluZXIpO1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNQcm9ncmVzc0JhckV2ZW50QmFzZWQge1xyXG4gIGNvbnN0cnVjdG9yKGVtaXR0ZXIsIGRvbVRhcmdldCkge1xyXG4gICAgaWYgKCFlbWl0dGVyIHx8ICF0aGlzLl9pc0Z1bmN0aW9uKGVtaXR0ZXIuZW1pdCkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcigncGxlYXNlIGdpdmUgdGhlIHRoaXMuX2VtaXR0ZXIgaW5zdGFuY2UnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChDb3JlVXRpbHMuaXNTdHJpbmcoZG9tVGFyZ2V0KSkge1xyXG4gICAgICB0aGlzLl9kb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkb21UYXJnZXQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZG9tID0gZG9tVGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghQ29yZVV0aWxzLmlzRWxlbWVudCh0aGlzLl9kb20pKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3BsZWFzZSBnaXZlIHRoZSBpZCBvZiBjb250YWluZXIgZG9tIG9yIGRpcmVjdGx5IGEgZG9tIGluc3RhbmNlJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyO1xyXG4gICAgdGhpcy5pbml0Q29udGFpbmVyRG9tKCk7XHJcbiAgICB0aGlzLmluaXRFdmVudExpc3Rlbm5lcigpO1xyXG4gICAgdGhpcy5sb2FkZWQgPSAwO1xyXG4gICAgdGhpcy50b3RhbEZpbGUgPSAwO1xyXG4gIH1cclxuXHJcbiAgX2lzRnVuY3Rpb24oZm4pIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG4gIH1cclxuXHJcbiAgaW5pdEV2ZW50TGlzdGVubmVyKCkge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5fZW1pdHRlci5vbignbG9hZC1zdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIGNvbnN0IHRvdGFsRmlsZXMgPSBldmVudC50b3RhbEZpbGVzO1xyXG4gICAgICBzZWxmLnRvdGFsRmlsZSA9IHRvdGFsRmlsZXM7XHJcbiAgICAgIHNlbGYuX2RvbVRvdGFsRmlsZS5pbm5lckhUTUwgPSB0b3RhbEZpbGVzO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBjb25zdCBmZXRjaExpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcclxuXHJcbiAgICAgIGNvbnN0IGZpbGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgZmlsZVRhZy5pbm5lckhUTUwgPSAnZmlsZTogJyArIGV2ZW50LmZpbGU7XHJcbiAgICAgIGZpbGVUYWcuc3R5bGUuY29sb3IgPSAnI2ZmZmZmZic7XHJcbiAgICAgIGZldGNoTGkuYXBwZW5kKGZpbGVUYWcpO1xyXG5cclxuICAgICAgZmV0Y2hMaS5jbGFzc05hbWUgPSAnZmV0Y2gtZmlsZSc7XHJcbiAgICAgIGZldGNoTGkuaWQgPSAnZmlsZS0nICsgZXZlbnQuZmlsZTtcclxuICAgICAgZmV0Y2hMaS5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnN3B4JztcclxuICAgICAgZmV0Y2hMaS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICNmZmZmZmY7JztcclxuICAgICAgZmV0Y2hMaS5zdHlsZS53aWR0aCA9ICc2MCUnO1xyXG4gICAgICBjb25zdCBmZXRjaHByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGZldGNocHJvZ3Jlc3MuaWQgPSAnZmlsZS1mZXRjaC0nICsgZXZlbnQuZmlsZTtcclxuICAgICAgZmV0Y2hwcm9ncmVzcy5zdHlsZS53aWR0aCA9ICcwJSc7XHJcbiAgICAgIGZldGNoTGkuYXBwZW5kKGZldGNocHJvZ3Jlc3MpO1xyXG4gICAgICBzZWxmLl9kb21Qcm9jZXNzTGlzdC5hcHBlbmQoZmV0Y2hMaSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC1wcm9ncmVzcycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIGNvbnN0IGlkID0gJ2ZpbGUtZmV0Y2gtJyArIGV2ZW50LmZpbGU7XHJcbiAgICAgIGNvbnN0IGZpbGVGZXRjaERvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuICAgICAgZmlsZUZldGNoRG9tLnN0eWxlLndpZHRoID0gKGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKSAqIDEwMCArICclJztcclxuICAgICAgZmlsZUZldGNoRG9tLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgcmVkJztcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2ZldGNoLXN1Y2Nlc3MnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAvLyBzaG93IHJlc3VsdFxyXG4gICAgICBjb25zdCBsaVBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlLScgKyBldmVudC5maWxlKTtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIHJlc3VsdC5pZCA9ICdmaWxlLXJlc3VsdC0nICsgZXZlbnQuZmlsZTtcclxuICAgICAgcmVzdWx0LmlubmVySFRNTCA9ICdmZXRjaC1zdWNjZXNzJztcclxuICAgICAgcmVzdWx0LnN0eWxlLmNvbG9yID0gJyNmZmZmZmYnO1xyXG4gICAgICBsaVBhcmVudC5hcHBlbmQocmVzdWx0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2ZldGNoLWVycm9yJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtYWJvcnQnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhldmVudCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC1lbmQnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhldmVudCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC10aW1lb3V0JywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fZW1pdHRlci5vbigncGFyc2Utc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBjb25zdCBsaVBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlLScgKyBldmVudC5maWxlKVxyXG4gICAgICBjb25zdCBwYXJzZXByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIHBhcnNlcHJvZ3Jlc3MuaWQgPSAnZmlsZS1wYXJzZS0nICsgZXZlbnQuZmlsZTtcclxuICAgICAgcGFyc2Vwcm9ncmVzcy5zdHlsZS53aWR0aCA9ICcwJSc7XHJcbiAgICAgIGxpUGFyZW50LmFwcGVuZChwYXJzZXByb2dyZXNzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ3BhcnNpbmcnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBjb25zdCBpZCA9ICdmaWxlLXBhcnNlLScgKyBldmVudC5maWxlO1xyXG4gICAgICBjb25zdCBmaWxlUGFyc2VEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICAgIGZpbGVQYXJzZURvbS5zdHlsZS53aWR0aCA9IChldmVudC5wYXJzZWQgLyBldmVudC50b3RhbCkgKiAxMDAgKyAnJSc7XHJcbiAgICAgIGZpbGVQYXJzZURvbS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHllbGxvdyc7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdwYXJzZS1zdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgc2VsZi5sb2FkZWQgKz0gMTtcclxuICAgICAgc2VsZi5fZG9tQ3VycmVudEZpbGUuaW5uZXJIVE1MID0gc2VsZi5sb2FkZWQ7XHJcbiAgICAgIHNlbGYuX2RvbUN1cnJlbnRQcm9ncmVzcy5zdHlsZS53aWR0aCA9IChzZWxmLmxvYWRlZCAvIHNlbGYudG90YWxGaWxlKSAqXHJcbiAgICAgICAgMTAwICsgJyUnO1xyXG4gICAgICAvLyBzaG93IHJlc3VsdFxyXG4gICAgICBjb25zdCBsaVBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlLScgKyBldmVudC5maWxlKVxyXG4gICAgICBjb25zdCByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgcmVzdWx0LmlkID0gJ2ZpbGUtcmVzdWx0LScgKyBldmVudC5maWxlO1xyXG4gICAgICByZXN1bHQuaW5uZXJIVE1MID0gJ3BhcnNlLXN1Y2Nlc3MnO1xyXG4gICAgICByZXN1bHQuc3R5bGUuY29sb3IgPSAnI2ZmZmZmZic7XHJcbiAgICAgIGxpUGFyZW50LmFwcGVuZChyZXN1bHQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpbml0Q29udGFpbmVyRG9tKCkge1xyXG4gICAgY29uc3QgY29udGFpbmVyRG9tID1cclxuICAgICAgXCI8ZGl2IGlkPSdhbWktcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcicgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6IHJnYigzMywgMzMsIDMzKTsgY29sb3I6ICNmZmZmZmY7Jz5cIiArXHJcbiAgICAgIFwiPGRpdj5cIiArXHJcbiAgICAgIFwiPGxhYmVsIGZvcj0ncHJvZ3Jlc3MtYmFyJyBpZD0ncHJvZ3Jlc3MtbGFiZWwnIHN0eWxlPSd3aWR0aDogNjAlOyBib3JkZXI6IDFweCBzb2xpZCAjZmZmZmZmOyB0ZXh0LWFsaWduOiBjZW50ZXI7Jz5cIiArXHJcbiAgICAgIFwiPHNwYW4gaWQ9J2N1cnJlbnQtZmlsZS1pbmRleCc+MDwvc3Bhbj5cIiArXHJcbiAgICAgIFwiL1wiICtcclxuICAgICAgXCI8c3BhbiBpZD0ndG90YWwtZmlsZSc+MDwvc3Bhbj5cIiArXHJcbiAgICAgIFwiPC9sYWJlbD5cIiArXHJcbiAgICAgIFwiPGRpdiBpZD0ncHJvZ3Jlc3MtYmFyJyBzdHlsZT0nd2lkdGg6IDYwJTsgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjsgdGV4dC1hbGlnbjogY2VudGVyOyc+XCIgK1xyXG4gICAgICBcIjxkaXYgaWQ9J2N1cnJlbnQtcHJvZ3Jlc3MnIHN0eWxlPSdib3JkZXI6IDFweCBzb2xpZCByZWQ7IHdpZHRoOiAwJTsnPjwvZGl2PlwiICtcclxuICAgICAgXCI8L2Rpdj5cIiArXHJcbiAgICAgIFwiPC9kaXY+XCIgK1xyXG4gICAgICBcIjx1bCBpZD0ncHJvY2Vzcy1saXN0JyBzdHlsZT0nbGlzdC1zdHlsZS10eXBlOiBub25lOyBwYWRkaW5nOiAwOyBvdmVyZmxvdy15OiBhdXRvOyc+XCIgK1xyXG4gICAgICAvLyBcIjxsaSBjbGFzcz0nZmV0Y2gtZmlsZSc+XCIgK1xyXG4gICAgICAvLyBcIjxkaXYgaWQ9J2ZpbGUtZmV0Y2gteHh4eHhpZCc+PC9kaXY+XCIgK1xyXG4gICAgICAvLyBcIjxkaXYgaWQ9J2ZpbGUtcGFyc2UteHh4eHhpZCc+PC9kaXY+XCIgK1xyXG4gICAgICAvLyBcIjwvbGk+XCIgK1xyXG4gICAgICBcIjwvdWw+XCIgK1xyXG4gICAgICBcIjwvZGl2PlwiO1xyXG4gICAgY29uc3Qgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgd3JhcC5pbm5lckhUTUwgPSBjb250YWluZXJEb207XHJcbiAgICB0aGlzLl9kb20uYXBwZW5kKHdyYXApO1xyXG4gICAgLy8gZG9tIGludGVyZmFjZVxyXG4gICAgdGhpcy5fZG9tQ3VycmVudEZpbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudC1maWxlLWluZGV4Jyk7XHJcbiAgICB0aGlzLl9kb21Ub3RhbEZpbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG90YWwtZmlsZScpO1xyXG4gICAgdGhpcy5fZG9tUHJvY2Vzc0xpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvY2Vzcy1saXN0Jyk7XHJcbiAgICB0aGlzLl9kb21DdXJyZW50UHJvZ3Jlc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudC1wcm9ncmVzcycpO1xyXG4gIH1cclxufVxyXG4iLCJcclxuLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9wcm9ncmVzc0JhclxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNQcm9ncmVzc0JhciB7XHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLl9tb2RlcyA9IHtcclxuICAgICAgJ2xvYWQnOiB7XHJcbiAgICAgICAgJ25hbWUnOiAnbG9hZCcsXHJcbiAgICAgICAgJ2NvbG9yJzogJyNGRkY1NkYnLFxyXG4gICAgICB9LFxyXG4gICAgICAncGFyc2UnOiB7XHJcbiAgICAgICAgJ25hbWUnOiAncGFyc2UnLFxyXG4gICAgICAgICdjb2xvcic6ICcjMjE5NkYzJyxcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJRCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fbW9kZSA9IG51bGw7XHJcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XHJcbiAgICB0aGlzLl90b3RhbCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcbiAgfVxyXG5cclxuICBmcmVlKCkge1xyXG4gICAgbGV0IHByb2dyZXNzQ29udGFpbmVycyA9IHRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwcm9ncmVzcyBjb250YWluZXInKTtcclxuICAgIGlmIChwcm9ncmVzc0NvbnRhaW5lcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICBwcm9ncmVzc0NvbnRhaW5lcnNbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcm9ncmVzc0NvbnRhaW5lcnNbMF0pO1xyXG4gICAgfVxyXG4gICAgcHJvZ3Jlc3NDb250YWluZXJzID0gbnVsbDtcclxuICAgIC8vIHN0b3AgcmVuZGVyaW5nIGxvb3BcclxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlEKTtcclxuICB9XHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICBsZXQgcHJvZ3Jlc3NDb250YWluZXIgPSB0aGlzLl9kb21Db250YWluZXIoKTtcclxuXHJcbiAgICBmb3IgKGxldCBtb2RlIGluIHRoaXMuX21vZGVzKSB7XHJcbiAgICAgIGlmICh0aGlzLl9tb2Rlcy5oYXNPd25Qcm9wZXJ0eShtb2RlKSkge1xyXG4gICAgICAgIGxldCBiYXIgPSB0aGlzLl9kb21CYXIodGhpcy5fbW9kZXNbbW9kZV0pO1xyXG4gICAgICAgIHByb2dyZXNzQ29udGFpbmVyLmFwcGVuZENoaWxkKGJhcik7XHJcbiAgICAgICAgYmFyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChwcm9ncmVzc0NvbnRhaW5lcik7XHJcbiAgICBwcm9ncmVzc0NvbnRhaW5lciA9IG51bGw7XHJcblxyXG4gICAgLy8gc3RhcnQgcmVuZGVyaW5nIGxvb3BcclxuICAgIHRoaXMudXBkYXRlVUkoKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZSh2YWx1ZSwgdG90YWwsIG1vZGUpIHtcclxuICAgIHRoaXMuX21vZGUgPSBtb2RlO1xyXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgIC8vIGRlcGVuZGluZyBvbiBDRE4sIHRvdGFsIHJldHVybiB0byBYSFRUUFJlcXVlc3QgY2FuIGJlIDAuXHJcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciB0byBhbmltYXRlIHRoZSBwcm9ncmVzc2JhclxyXG4gICAgaWYgKHRvdGFsID09PSAwKSB7XHJcbiAgICAgIHRoaXMuX3RvdGFsID0gdmFsdWU7XHJcbiAgICAgIHRoaXMuX3ZhbHVlID0gTWF0aC5yYW5kb20oKSp2YWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3RvdGFsID0gdG90YWw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVVSSgpIHtcclxuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT57XHJcbiAgICAgIHRoaXMudXBkYXRlVUkoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghKHRoaXMuX21vZGVzLmhhc093blByb3BlcnR5KHRoaXMuX21vZGUpICYmXHJcbiAgICAgIHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmhhc093blByb3BlcnR5KCduYW1lJykgJiZcclxuICAgICAgdGhpcy5fbW9kZXNbdGhpcy5fbW9kZV0uaGFzT3duUHJvcGVydHkoJ2NvbG9yJykpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtZXNzYWdlID0gJyc7XHJcbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgucm91bmQoKHRoaXMuX3ZhbHVlIC8gdGhpcy5fdG90YWwpICogMTAwKTtcclxuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fbW9kZXNbdGhpcy5fbW9kZV0uY29sb3I7XHJcblxyXG4gICAgbGV0IHByb2dyZXNzQmFyID0gdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Byb2dyZXNzICcgKyB0aGlzLl9tb2Rlc1t0aGlzLl9tb2RlXS5uYW1lKTtcclxuICAgIGlmIChwcm9ncmVzc0Jhci5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHByb2dyZXNzQmFyWzBdLnN0eWxlLmJvcmRlckNvbG9yID0gY29sb3I7XHJcbiAgICAgIHByb2dyZXNzQmFyWzBdLnN0eWxlLndpZHRoID0gcHJvZ3Jlc3MgKyAnJSc7XHJcbiAgICB9XHJcbiAgICBwcm9ncmVzc0JhciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBfZG9tQ29udGFpbmVyKCkge1xyXG4gICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgIC8vIGNsYXNzIGl0XHJcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgncHJvZ3Jlc3MnKTtcclxuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb250YWluZXInKTtcclxuXHJcbiAgICAvLyBzdHlsZSBpdFxyXG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICc4cHgnO1xyXG4gICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgxNTgsIDE1OCwgMTU4LCAwLjUpJztcclxuICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSAnMCc7XHJcbiAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gJzEnO1xyXG5cclxuICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICBfZG9tQmFyKG1vZGUpIHtcclxuICAgIGlmICghKG1vZGUuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJlxyXG4gICAgICAobW9kZS5oYXNPd25Qcm9wZXJ0eSgnY29sb3InKSkpKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBtb2RlIHByb3ZpZGVkLicpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cobW9kZSk7XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgIC8vIGNsYXNzIGl0XHJcbiAgICBiYXIuY2xhc3NMaXN0LmFkZChtb2RlLm5hbWUpO1xyXG4gICAgYmFyLmNsYXNzTGlzdC5hZGQoJ3Byb2dyZXNzJyk7XHJcblxyXG4gICAgLy8gc3R5bGUgaXRcclxuICAgIGJhci5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICcgKyBtb2RlLmNvbG9yO1xyXG4gICAgYmFyLnN0eWxlLndpZHRoID0gJzAlJztcclxuXHJcbiAgICByZXR1cm4gYmFyO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqICogSW1wb3J0cyAqKiovXHJcbmltcG9ydCBHZW9tZXRyaWVzU2xpY2UgZnJvbSAnLi4vZ2VvbWV0cmllcy9nZW9tZXRyaWVzLnNsaWNlJztcclxuaW1wb3J0IFNoYWRlcnNVbmlmb3JtIGZyb20gJy4uL3NoYWRlcnMvc2hhZGVycy5kYXRhLnVuaWZvcm0nO1xyXG5pbXBvcnQgU2hhZGVyc1ZlcnRleCBmcm9tICcuLi9zaGFkZXJzL3NoYWRlcnMuZGF0YS52ZXJ0ZXgnO1xyXG5pbXBvcnQgU2hhZGVyc0ZyYWdtZW50IGZyb20gJy4uL3NoYWRlcnMvc2hhZGVycy5kYXRhLmZyYWdtZW50JztcclxuXHJcbmltcG9ydCBIZWxwZXJzTWF0ZXJpYWxNaXhpbiBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0ZXJpYWwubWl4aW4nO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9zbGljZVxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNTbGljZSBleHRlbmRzIEhlbHBlcnNNYXRlcmlhbE1peGluKFRIUkVFLk9iamVjdDNEKSB7XHJcbiAgY29uc3RydWN0b3Ioc3RhY2ssXHJcbiAgICAgICAgICAgICAgaW5kZXggPSAwLFxyXG4gICAgICAgICAgICAgIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCksXHJcbiAgICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSksXHJcbiAgICAgICAgICAgICAgYWFiYlNwYWNlID0gJ0lKSycpIHtcclxuICAgIC8vXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8vIHByaXZhdGUgdmFyc1xyXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcclxuXHJcbiAgICAvLyBpbWFnZSBzZXR0aW5nc1xyXG4gICAgLy8gaW5kZXggb25seSB1c2VkIHRvIGdyYWIgd2luZG93L2xldmVsIGFuZCBpbnRlcmNlcHQvc2xvcGVcclxuICAgIHRoaXMuX2ludmVydCA9IHRoaXMuX3N0YWNrLmludmVydDtcclxuXHJcbiAgICB0aGlzLl9sdXQgPSAnbm9uZSc7XHJcbiAgICB0aGlzLl9sdXRUZXh0dXJlID0gbnVsbDtcclxuICAgIC8vIGlmIGF1dG8gPT09IHRydWUsIGdldCBmcm9tIGluZGV4XHJcbiAgICAvLyBlbHNlIGZyb20gc3RhY2sgd2hpY2ggaG9sZHMgdGhlIGRlZmF1bHQgdmFsdWVzXHJcbiAgICB0aGlzLl9pbnRlbnNpdHlBdXRvID0gdHJ1ZTtcclxuICAgIHRoaXMuX2ludGVycG9sYXRpb24gPSAxOyAvLyBkZWZhdWx0IHRvIHRyaWxpbmVhciBpbnRlcnBvbGF0aW9uXHJcbiAgICAvLyBzdGFydHMgYXQgMFxyXG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gbnVsbDtcclxuICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IG51bGw7XHJcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSBudWxsO1xyXG4gICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xyXG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gMDtcclxuICAgIHRoaXMuX2JvcmRlckNvbG9yID0gbnVsbDtcclxuXHJcbiAgICAvLyBPYmplY3QzRCBzZXR0aW5nc1xyXG4gICAgLy8gc2hhcGVcclxuICAgIHRoaXMuX3BsYW5lUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuX3BsYW5lRGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgLy8gY2hhbmdlIGFhQkJTcGFjZSBjaGFuZ2VzIHRoZSBib3ggZGltZW5zaW9uc1xyXG4gICAgLy8gYWxzbyBjaGFuZ2VzIHRoZSB0cmFuc2Zvcm1cclxuICAgIC8vIHRoZXJlIGlzIGFsc28gYSBzd2l0Y2ggdG8gbW92ZSBiYWNrIG1lc2ggdG8gTFBTIHNwYWNlIGF1dG9tYXRpY2FsbHlcclxuICAgIHRoaXMuX2FhQkJzcGFjZSA9IGFhYmJTcGFjZTsgLy8gb3IgTFBTIC0+IGRpZmZlcmVudCB0cmFuc2Zvcm1zLCBlc3AgZm9yIHRoZSBnZW9tZXRyeS9tZXNoXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xyXG4gICAgdGhpcy5fc2hhZGVyc0ZyYWdtZW50ID0gU2hhZGVyc0ZyYWdtZW50O1xyXG4gICAgdGhpcy5fc2hhZGVyc1ZlcnRleCA9IFNoYWRlcnNWZXJ0ZXg7XHJcbiAgICB0aGlzLl91bmlmb3JtcyA9IFNoYWRlcnNVbmlmb3JtLnVuaWZvcm1zKCk7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBkaW1lbnNpb25zLCBjZW50ZXIsIGV0Yy5cclxuICAgIC8vIGRlcGVuZGluZyBvbiBhYUJCU3BhY2VcclxuICAgIHRoaXMuX2luaXQoKTtcclxuXHJcbiAgICAvLyB1cGRhdGUgb2JqZWN0XHJcbiAgICB0aGlzLl9jcmVhdGUoKTtcclxuICB9XHJcblxyXG4gIC8vIGdldHRlcnMvc2V0dGVyc1xyXG5cclxuICBnZXQgc3RhY2soKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhY2s7XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhY2soc3RhY2spIHtcclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcbiAgfVxyXG5cclxuICBnZXQgd2luZG93V2lkdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2luZG93V2lkdGg7XHJcbiAgfVxyXG5cclxuICBzZXQgd2luZG93V2lkdGgod2luZG93V2lkdGgpIHtcclxuICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gd2luZG93V2lkdGg7XHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcclxuICB9XHJcblxyXG4gIGdldCB3aW5kb3dDZW50ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2luZG93Q2VudGVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IHdpbmRvd0NlbnRlcih3aW5kb3dDZW50ZXIpIHtcclxuICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IHdpbmRvd0NlbnRlcjtcclxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlc2NhbGVTbG9wZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNjYWxlU2xvcGU7XHJcbiAgfVxyXG5cclxuICBzZXQgcmVzY2FsZVNsb3BlKHJlc2NhbGVTbG9wZSkge1xyXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gcmVzY2FsZVNsb3BlO1xyXG4gICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgcmVzY2FsZUludGVyY2VwdCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0O1xyXG4gIH1cclxuXHJcbiAgc2V0IHJlc2NhbGVJbnRlcmNlcHQocmVzY2FsZUludGVyY2VwdCkge1xyXG4gICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCA9IHJlc2NhbGVJbnRlcmNlcHQ7XHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcclxuICB9XHJcblxyXG4gIGdldCBpbnZlcnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW52ZXJ0O1xyXG4gIH1cclxuXHJcbiAgc2V0IGludmVydChpbnZlcnQpIHtcclxuICAgIHRoaXMuX2ludmVydCA9IGludmVydDtcclxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGx1dCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9sdXQ7XHJcbiAgfVxyXG5cclxuICBzZXQgbHV0KGx1dCkge1xyXG4gICAgdGhpcy5fbHV0ID0gbHV0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGx1dFRleHR1cmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbHV0VGV4dHVyZTtcclxuICB9XHJcblxyXG4gIHNldCBsdXRUZXh0dXJlKGx1dFRleHR1cmUpIHtcclxuICAgIHRoaXMuX2x1dFRleHR1cmUgPSBsdXRUZXh0dXJlO1xyXG4gICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgaW50ZW5zaXR5QXV0bygpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlbnNpdHlBdXRvO1xyXG4gIH1cclxuXHJcbiAgc2V0IGludGVuc2l0eUF1dG8oaW50ZW5zaXR5QXV0bykge1xyXG4gICAgdGhpcy5faW50ZW5zaXR5QXV0byA9IGludGVuc2l0eUF1dG87XHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcclxuICB9XHJcblxyXG4gIGdldCBpbnRlcnBvbGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgaW50ZXJwb2xhdGlvbihpbnRlcnBvbGF0aW9uKSB7XHJcbiAgICB0aGlzLl9pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcclxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xyXG4gICAgdGhpcy5fdXBkYXRlTWF0ZXJpYWwoKTtcclxuICB9XHJcblxyXG4gIGdldCBpbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbmRleDtcclxuICB9XHJcblxyXG4gIHNldCBpbmRleChpbmRleCkge1xyXG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBsYW5lUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgIHRoaXMuX3BsYW5lUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBsYW5lUG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGxhbmVQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBwbGFuZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcclxuICAgIHRoaXMuX3BsYW5lRGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgcGxhbmVEaXJlY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGxhbmVEaXJlY3Rpb247XHJcbiAgfVxyXG5cclxuICBzZXQgaGFsZkRpbWVuc2lvbnMoaGFsZkRpbWVuc2lvbnMpIHtcclxuICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zID0gaGFsZkRpbWVuc2lvbnM7XHJcbiAgfVxyXG5cclxuICBnZXQgaGFsZkRpbWVuc2lvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGFsZkRpbWVuc2lvbnM7XHJcbiAgfVxyXG5cclxuICBzZXQgY2VudGVyKGNlbnRlcikge1xyXG4gICAgdGhpcy5fY2VudGVyID0gY2VudGVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNlbnRlcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9jZW50ZXI7XHJcbiAgfVxyXG5cclxuICBzZXQgYWFiYlNwYWNlKGFhYmJTcGFjZSkge1xyXG4gICAgdGhpcy5fYWFCQnNwYWNlID0gYWFiYlNwYWNlO1xyXG4gICAgdGhpcy5faW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGFhYmJTcGFjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9hYUJCc3BhY2U7XHJcbiAgfVxyXG5cclxuICBzZXQgbWVzaChtZXNoKSB7XHJcbiAgICB0aGlzLl9tZXNoID0gbWVzaDtcclxuICB9XHJcblxyXG4gIGdldCBtZXNoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21lc2g7XHJcbiAgfVxyXG5cclxuICBzZXQgZ2VvbWV0cnkoZ2VvbWV0cnkpIHtcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcbiAgfVxyXG5cclxuICBnZXQgZ2VvbWV0cnkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XHJcbiAgfVxyXG5cclxuICBzZXQgY2FudmFzV2lkdGgoY2FudmFzV2lkdGgpIHtcclxuICAgIHRoaXMuX2NhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51Q2FudmFzV2lkdGgudmFsdWUgPSB0aGlzLl9jYW52YXNXaWR0aDtcclxuICB9XHJcblxyXG4gIGdldCBjYW52YXNXaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYW52YXNXaWR0aDtcclxuICB9XHJcblxyXG4gIHNldCBjYW52YXNIZWlnaHQoY2FudmFzSGVpZ2h0KSB7XHJcbiAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51Q2FudmFzSGVpZ2h0LnZhbHVlID0gdGhpcy5fY2FudmFzSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYW52YXNIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBzZXQgYm9yZGVyQ29sb3IoYm9yZGVyQ29sb3IpIHtcclxuICAgIHRoaXMuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51Qm9yZGVyQ29sb3IudmFsdWUgPSBuZXcgVEhSRUUuQ29sb3IoYm9yZGVyQ29sb3IpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJvcmRlckNvbG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JvcmRlckNvbG9yO1xyXG4gIH1cclxuXHJcbiAgX2luaXQoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3N0YWNrIHx8ICF0aGlzLl9zdGFjay5fcHJlcGFyZWQgfHwgIXRoaXMuX3N0YWNrLl9wYWNrZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9hYUJCc3BhY2UgPT09ICdJSksnKSB7XHJcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XHJcbiAgICAgIHRoaXMuX2NlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIHRoaXMuX3N0YWNrLmhhbGZEaW1lbnNpb25zSUpLLnggLSAwLjUsXHJcbiAgICAgICAgdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSksueSAtIDAuNSxcclxuICAgICAgICB0aGlzLl9zdGFjay5oYWxmRGltZW5zaW9uc0lKSy56IC0gMC41KTtcclxuICAgICAgdGhpcy5fdG9BQUJCID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIExQU1xyXG4gICAgICBsZXQgYWFCQm94ID0gdGhpcy5fc3RhY2suQUFCQm94KCk7XHJcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zID0gYWFCQm94LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMC41KTtcclxuICAgICAgdGhpcy5fY2VudGVyID0gdGhpcy5fc3RhY2suY2VudGVyQUFCQm94KCk7XHJcbiAgICAgIHRoaXMuX3RvQUFCQiA9IHRoaXMuX3N0YWNrLmxwczJBQUJCO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gcHJpdmF0ZSBtZXRob2RzXHJcbiAgX2NyZWF0ZSgpIHtcclxuICAgIGlmICghdGhpcy5fc3RhY2sgfHwgIXRoaXMuX3N0YWNrLnByZXBhcmVkIHx8ICF0aGlzLl9zdGFjay5wYWNrZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlbmllbmNlIHZhcnNcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNTbGljZShcclxuICAgICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucyxcclxuICAgICAgICB0aGlzLl9jZW50ZXIsXHJcbiAgICAgICAgdGhpcy5fcGxhbmVQb3NpdGlvbixcclxuICAgICAgICB0aGlzLl9wbGFuZURpcmVjdGlvbixcclxuICAgICAgICB0aGlzLl90b0FBQkIpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coZSk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnaW52YWxpZCBzbGljZSBnZW9tZXRyeSAtIGV4aXRpbmcuLi4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fZ2VvbWV0cnkudmVydGljZXMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgLy9cclxuICAgICAgdGhpcy5fdW5pZm9ybXMudVRleHR1cmVTaXplLnZhbHVlID0gdGhpcy5fc3RhY2sudGV4dHVyZVNpemU7XHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVEYXRhRGltZW5zaW9ucy52YWx1ZSA9IFt0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrLmRpbWVuc2lvbnNJSksueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy56XTtcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudVdvcmxkVG9EYXRhLnZhbHVlID0gdGhpcy5fc3RhY2subHBzMklKSztcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudU51bWJlck9mQ2hhbm5lbHMudmFsdWUgPSB0aGlzLl9zdGFjay5udW1iZXJPZkNoYW5uZWxzO1xyXG4gICAgICB0aGlzLl91bmlmb3Jtcy51UGl4ZWxUeXBlLnZhbHVlID0gdGhpcy5fc3RhY2sucGl4ZWxUeXBlO1xyXG4gICAgICB0aGlzLl91bmlmb3Jtcy51Qml0c0FsbG9jYXRlZC52YWx1ZSA9IHRoaXMuX3N0YWNrLmJpdHNBbGxvY2F0ZWQ7XHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVQYWNrZWRQZXJQaXhlbC52YWx1ZSA9IHRoaXMuX3N0YWNrLnBhY2tlZFBlclBpeGVsO1xyXG4gICAgICAvLyBjb21wdXRlIHRleHR1cmUgaWYgbWF0ZXJpYWwgZXhpc3RcclxuICAgICAgdGhpcy5fcHJlcGFyZVRleHR1cmUoKTtcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudVRleHR1cmVDb250YWluZXIudmFsdWUgPSB0aGlzLl90ZXh0dXJlcztcclxuXHJcbiAgICAgIHRoaXMuX2NyZWF0ZU1hdGVyaWFsKHtcclxuICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgaW50ZW5zaXR5IHJlbGF0ZWQgc3R1ZmZcclxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3MoKTtcclxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgbWVzaCFcclxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTWVzaCh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgaWYgKHRoaXMuX2FhQkJzcGFjZSA9PT0gJ0lKSycpIHtcclxuICAgICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9zdGFjay5pamsyTFBTKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xyXG5cclxuICAgIC8vIGFuZCBhZGQgaXQhXHJcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZUludGVuc2l0eVNldHRpbmdzKCkge1xyXG4gICAgLy8gaWYgYXV0bywgZ2V0IGZyb20gZnJhbWUgaW5kZXhcclxuICAgIGlmICh0aGlzLl9pbnRlbnNpdHlBdXRvKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZygnd2luZG93Q2VudGVyJyk7XHJcbiAgICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZygnd2luZG93V2lkdGgnKTtcclxuICAgICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nKCdyZXNjYWxlU2xvcGUnKTtcclxuICAgICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nKCdyZXNjYWxlSW50ZXJjZXB0Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGhpcy5fd2luZG93Q2VudGVyID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fd2luZG93Q2VudGVyID0gdGhpcy5fc3RhY2sud2luZG93Q2VudGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fX3dpbmRvd1dpZHRoID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fd2luZG93V2lkdGggPSB0aGlzLl9zdGFjay53aW5kb3dXaWR0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX3Jlc2NhbGVTbG9wZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc2NhbGVTbG9wZSA9IHRoaXMuX3N0YWNrLnJlc2NhbGVTbG9wZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gdGhpcy5fc3RhY2sucmVzY2FsZUludGVyY2VwdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpIHtcclxuICAgIC8vIGNvbXBlbnNhdGUgZm9yIHRoZSBvZmZzZXQgdG8gb25seSBwYXNzID4gMCB2YWx1ZXMgdG8gc2hhZGVyc1xyXG4gICAgLy8gbW9kZWxzID4gbW9kZWxzLnN0YWNrLmpzIDogX3BhY2tUbzhCaXRzXHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGlmICh0aGlzLl9zdGFjay5fbWluTWF4WzBdIDwgMCkge1xyXG4gICAgICBvZmZzZXQgLT0gdGhpcy5fc3RhY2suX21pbk1heFswXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgc2xpY2Ugd2luZG93IGNlbnRlciBhbmQgd2lkdGhcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVSZXNjYWxlU2xvcGVJbnRlcmNlcHQudmFsdWUgPVxyXG4gICAgICBbdGhpcy5fcmVzY2FsZVNsb3BlLCB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0XTtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVXaW5kb3dDZW50ZXJXaWR0aC52YWx1ZSA9XHJcbiAgICAgIFtvZmZzZXQgKyB0aGlzLl93aW5kb3dDZW50ZXIsIHRoaXMuX3dpbmRvd1dpZHRoXTtcclxuXHJcbiAgICAvLyBpbnZlcnRcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVJbnZlcnQudmFsdWUgPSB0aGlzLl9pbnZlcnQgPT09IHRydWUgPyAxIDogMDtcclxuXHJcbiAgICAvLyBpbnRlcnBvbGF0aW9uXHJcbiAgICB0aGlzLl91bmlmb3Jtcy51SW50ZXJwb2xhdGlvbi52YWx1ZSA9IHRoaXMuX2ludGVycG9sYXRpb247XHJcblxyXG4gICAgLy8gbHV0XHJcbiAgICBpZiAodGhpcy5fbHV0ID09PSAnbm9uZScpIHtcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudUx1dC52YWx1ZSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl91bmlmb3Jtcy51THV0LnZhbHVlID0gMTtcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudVRleHR1cmVMVVQudmFsdWUgPSB0aGlzLl9sdXRUZXh0dXJlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlSW50ZW5zaXR5U2V0dGluZyhzZXR0aW5nKSB7XHJcbiAgICBpZiAodGhpcy5fc3RhY2suZnJhbWVbdGhpcy5faW5kZXhdICYmXHJcbiAgICAgICAgdGhpcy5fc3RhY2suZnJhbWVbdGhpcy5faW5kZXhdW3NldHRpbmddKSB7XHJcbiAgICAgIHRoaXNbJ18nICsgc2V0dGluZ10gPSB0aGlzLl9zdGFjay5mcmFtZVt0aGlzLl9pbmRleF1bc2V0dGluZ107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzWydfJyArIHNldHRpbmddID0gdGhpcy5fc3RhY2tbc2V0dGluZ107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlKCkge1xyXG4gICAgLy8gdXBkYXRlIHNsaWNlXHJcbiAgICBpZiAodGhpcy5fbWVzaCkge1xyXG4gICAgICB0aGlzLnJlbW92ZSh0aGlzLl9tZXNoKTtcclxuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBkaXNwb3NlIHRoZSB0ZXh0dXJlIVxyXG4gICAgICAvLyB0aGlzLl9tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgICAgLy8gdGhpcy5fbWVzaC5tYXRlcmlhbCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NyZWF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIC8vIFJlbGVhc2UgbWVtb3J5XHJcbiAgICBmb3IodmFyIGogPTA7IGo8IHRoaXMuX3RleHR1cmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIHRoaXMuX3RleHR1cmVzW2pdLmRpc3Bvc2UoKTtcclxuICAgICAgdGhpcy5fdGV4dHVyZXNbal0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdGV4dHVyZXMgPSBudWxsO1xyXG4gICAgdGhpcy5fc2hhZGVyc0ZyYWdtZW50ID0gbnVsbDtcclxuICAgIHRoaXMuX3NoYWRlcnNWZXJ0ZXggPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX3VuaWZvcm1zID0gbnVsbDtcclxuXHJcbiAgICAvLyBtYXRlcmlhbCwgZ2VvbWV0cnkgYW5kIG1lc2hcclxuICAgIHRoaXMucmVtb3ZlKHRoaXMuX21lc2gpO1xyXG4gICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLl9tZXNoLmdlb21ldHJ5ID0gbnVsbDtcclxuICAgIHRoaXMuX21lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fbWVzaC5tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwudW5pZm9ybXMgPSBudWxsO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX3N0YWNrID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGNhcnRlc2lhbkVxdWF0aW9uKCkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBnZW9tZXRyeVxyXG4gICAgaWYgKCF0aGlzLl9nZW9tZXRyeSB8fFxyXG4gICAgICAgIXRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzIHx8XHJcbiAgICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yNCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB2ZXJ0aWNlcyA9IHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzO1xyXG4gICAgbGV0IGRhdGFUb1dvcmxkID0gdGhpcy5fc3RhY2suaWprMkxQUztcclxuICAgIGxldCBwMSA9IG5ldyBUSFJFRS5WZWN0b3IzKHZlcnRpY2VzWzBdLngsIHZlcnRpY2VzWzBdLnksIHZlcnRpY2VzWzBdLnopXHJcbiAgICAgIC5hcHBseU1hdHJpeDQoZGF0YVRvV29ybGQpO1xyXG4gICAgbGV0IHAyID0gbmV3IFRIUkVFLlZlY3RvcjModmVydGljZXNbMV0ueCwgdmVydGljZXNbMV0ueSwgdmVydGljZXNbMV0ueilcclxuICAgICAgLmFwcGx5TWF0cml4NChkYXRhVG9Xb3JsZCk7XHJcbiAgICBsZXQgcDMgPSBuZXcgVEhSRUUuVmVjdG9yMyh2ZXJ0aWNlc1syXS54LCB2ZXJ0aWNlc1syXS55LCB2ZXJ0aWNlc1syXS56KVxyXG4gICAgICAuYXBwbHlNYXRyaXg0KGRhdGFUb1dvcmxkKTtcclxuICAgIGxldCB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRsZXQgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgbGV0IG5vcm1hbCA9IHYxXHJcbiAgICAgIC5zdWJWZWN0b3JzKHAzLCBwMilcclxuICAgICAgLmNyb3NzKHYyLnN1YlZlY3RvcnMocDEsIHAyKSlcclxuICAgICAgLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yNChcclxuICAgICAgbm9ybWFsLngsXHJcbiAgICAgIG5vcm1hbC55LFxyXG4gICAgICBub3JtYWwueixcclxuICAgICAgLSBub3JtYWwuZG90KHAxKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiLyoqICogSW1wb3J0cyAqKiovXHJcbmltcG9ydCBIZWxwZXJzQm9yZGVyIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5ib3JkZXInO1xyXG5pbXBvcnQgSGVscGVyc0JvdW5kaW5nQm94IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5ib3VuZGluZ2JveCc7XHJcbmltcG9ydCBIZWxwZXJzU2xpY2UgZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNsaWNlJztcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZWFzaWx5IGRpc3BsYXkgYW5kIGludGVyYWN0IHdpdGggYSBzdGFjay48YnI+XHJcbiAqPGJyPlxyXG4gKiBEZWZhdWx0czo8YnI+XHJcbiAqICAgLSBvcmllbnRhdGlvbjogMCAoYWNxdWlzaXRpb24gZGlyZWN0aW9uKTxicj5cclxuICogICAtIGluZGV4OiBtaWRkbGUgc2xpY2UgaW4gYWNxdWlzaXRpb24gZGlyZWN0aW9uPGJyPlxyXG4gKjxicj5cclxuICogRmVhdHVyZXM6PGJyPlxyXG4gKiAgIC0gc2xpY2UgZnJvbSB0aGUgc3RhY2sgKGluIGFueSBkaXJlY3Rpb24pPGJyPlxyXG4gKiAgIC0gc2xpY2UgYm9yZGVyPGJyPlxyXG4gKiAgIC0gc3RhY2sgYm91bmRpbmcgYm94PGJyPlxyXG4gKjxicj5cclxuICogTGl2ZSBkZW1vIGF0OiB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9naC9nZXQvbGlicmFyeS9wdXJlL2ZubmRzYy9hbWkvdHJlZS9tYXN0ZXIvbGVzc29ucy8wMSNydW58TGVzc29uIDAxfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBsZXQgc3RhY2sgPSBuZXcgVkpTLk1vZGVscy5TdGFjaygpO1xyXG4gKiAuLi4gLy8gcHJlcGFyZSB0aGUgc3RhY2tcclxuICpcclxuICogbGV0IHN0YWNrSGVscGVyID0gbmV3IFZKUy5IZWxwZXJzLlN0YWNrKHN0YWNrKTtcclxuICogc3RhY2tIZWxwZXIuYmJveC5jb2xvciA9IDB4RjlGOUY5O1xyXG4gKiBzdGFja0hlbHBlci5ib3JkZXIuY29sb3IgPSAweEY5RjlGOTtcclxuICpcclxuICogbGV0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcbiAqIHNjZW5lLmFkZChzdGFja0hlbHBlcik7XHJcbiAqXHJcbiAqIEBleHRlbmRzIFRIUkVFLk9iamVjdDNEXHJcbiAqXHJcbiAqIEBzZWUgbW9kdWxlOmhlbHBlcnMvYm9yZGVyXHJcbiAqIEBzZWUgbW9kdWxlOmhlbHBlcnMvYm91bmRpbmdib3hcclxuICogQHNlZSBtb2R1bGU6aGVscGVycy9zbGljZVxyXG4gKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvc3RhY2tcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNTdGFjayBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcclxuICBjb25zdHJ1Y3RvcihzdGFjaykge1xyXG4gICAgLy9cclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcclxuICAgIHRoaXMuX2JCb3ggPSBudWxsO1xyXG4gICAgdGhpcy5fc2xpY2UgPSBudWxsO1xyXG4gICAgdGhpcy5fYm9yZGVyID0gbnVsbDtcclxuICAgIHRoaXMuX2R1bW15ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IDA7XHJcbiAgICB0aGlzLl9pbmRleCA9IDA7XHJcblxyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSBudWxsO1xyXG4gICAgdGhpcy5fYXV0b1dpbmRvd0xldmVsID0gZmFsc2U7XHJcbiAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IGZhbHNlO1xyXG4gICAgdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCA9IDA7XHJcblxyXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xyXG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gMDtcclxuICAgIHRoaXMuX2JvcmRlckNvbG9yID0gbnVsbDtcclxuXHJcblxyXG4gICAgLy8gdGhpcy5fYXJyb3cgPSB7XHJcbiAgICAvLyAgIHZpc2libGU6IHRydWUsXHJcbiAgICAvLyAgIGNvbG9yOiAweEZGRjMzNixcclxuICAgIC8vICAgbGVuZ3RoOiAyMCxcclxuICAgIC8vICAgbWF0ZXJpYWw6IG51bGwsXHJcbiAgICAvLyAgIGdlb21ldHJ5OiBudWxsLFxyXG4gICAgLy8gICBtZXNoOiBudWxsXHJcbiAgICAvLyB9O1xyXG4gICAgdGhpcy5fY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIFBVQkxJQyBNRVRIT0RTXHJcbiAgLy9cclxuXHJcbiAgLy9cclxuICAvLyBTRVRURVJTL0dFVFRFUlNcclxuICAvL1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgc3RhY2suXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TW9kZWxzU3RhY2t9XHJcbiAgICovXHJcbiAgZ2V0IHN0YWNrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHN0YWNrLlxyXG4gICAqXHJcbiAgICogQHR5cGUge01vZGVsc1N0YWNrfVxyXG4gICAqL1xyXG4gIHNldCBzdGFjayhzdGFjaykge1xyXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBib3VuZGluZyBib3ggaGVscGVyLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0hlbHBlcnNCb3VuZGluZ0JveH1cclxuICAgKi9cclxuICBnZXQgYmJveCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9iQm94O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHNsaWNlIGhlbHBlci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtIZWxwZXJzU2xpY2V9XHJcbiAgICovXHJcbiAgZ2V0IHNsaWNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGJvcmRlciBoZWxwZXIuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7SGVscGVyc1NsaWNlfVxyXG4gICAqL1xyXG4gIGdldCBib3JkZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYm9yZGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0L2dldCBjdXJyZW50IHNsaWNlIGluZGV4Ljxicj5cclxuICAgKiBTZXRzIG91dE9mQm91bmRzIGZsYWcgdG8ga25vdyBpZiB0YXJnZXQgaW5kZXggaXMgaW4vb3V0IHN0YWNrIGJvdW5kaW5nIGJveC48YnI+XHJcbiAgICogPGJyPlxyXG4gICAqIEludGVybmFsbHkgdXBkYXRlcyB0aGUgc2xpY2VIZWxwZXIgaW5kZXggYW5kIHBvc2l0aW9uLiBBbHNvIHVwZGF0ZXMgdGhlXHJcbiAgICogYm9yZGVySGVscGVyIHdpdGggdGhlIHVwZGF0ZWQgc2xpY2VIZWxwZXIuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBpbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbmRleDtcclxuICB9XHJcblxyXG4gIHNldCBpbmRleChpbmRleCkge1xyXG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAvLyB1cGRhdGUgdGhlIHNsaWNlXHJcbiAgICB0aGlzLl9zbGljZS5pbmRleCA9IGluZGV4O1xyXG4gICAgbGV0IGhhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XHJcbiAgICB0aGlzLl9zbGljZS5wbGFuZVBvc2l0aW9uID0gdGhpcy5fcHJlcGFyZVNsaWNlUG9zaXRpb24oaGFsZkRpbWVuc2lvbnMsIHRoaXMuX2luZGV4KTtcclxuXHJcbiAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgYm9yZGVyXHJcbiAgICB0aGlzLl9ib3JkZXIuaGVscGVyc1NsaWNlID0gdGhpcy5fc2xpY2U7XHJcblxyXG4gICAgLy8gdXBkYXRlIG91ck9mQm91bmRzIGZsYWdcclxuICAgIHRoaXMuX2lzSW5kZXhPdXRPZkJvdW5kcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0L2dldCBjdXJyZW50IHNsaWNlIG9yaWVudGF0aW9uLjxicj5cclxuICAgKiBWYWx1ZXM6IDxicj5cclxuICAgKiAgIC0gMDogYWNxdWlzaXRpb24gZGlyZWN0aW9uIChzbGljZSBub3JtYWwgaXMgel9jb3NpbmUpPGJyPlxyXG4gICAqICAgLSAxOiBuZXh0IGRpcmVjdGlvbiAoc2xpY2Ugbm9ybWFsIGlzIHhfY29zaW5lKTxicj5cclxuICAgKiAgIC0gMjogbmV4dCBkaXJlY3Rpb24gKHNsaWNlIG5vcm1hbCBpcyB5X2Nvc2luZSk8YnI+XHJcbiAgICogICAtIG46IHNldCBvcmllbnRhdGlvbiB0byAwPGJyPlxyXG4gICAqIDxicj5cclxuICAgKiBJbnRlcm5hbGx5IHVwZGF0ZXMgdGhlIHNsaWNlSGVscGVyIGRpcmVjdGlvbi4gQWxzbyB1cGRhdGVzIHRoZVxyXG4gICAqIGJvcmRlckhlbHBlciB3aXRoIHRoZSB1cGRhdGVkIHNsaWNlSGVscGVyLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBzZXQgb3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcclxuICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICB0aGlzLl9jb21wdXRlT3JpZW50YXRpb25NYXhJbmRleCgpO1xyXG5cclxuICAgIHRoaXMuX3NsaWNlLnBsYW5lRGlyZWN0aW9uID0gdGhpcy5fcHJlcGFyZURpcmVjdGlvbih0aGlzLl9vcmllbnRhdGlvbik7XHJcblxyXG4gICAgLy8gYWxzbyB1cGRhdGUgdGhlIGJvcmRlclxyXG4gICAgdGhpcy5fYm9yZGVyLmhlbHBlcnNTbGljZSA9IHRoaXMuX3NsaWNlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0L2dldCB0aGUgb3V0T2ZCb3VuZCBmbGFnLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc2V0IG91dE9mQm91bmRzKG91dE9mQm91bmRzKSB7XHJcbiAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IG91dE9mQm91bmRzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG91dE9mQm91bmRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX291dE9mQm91bmRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0L2dldCB0aGUgb3JpZW50YXRpb25NYXhJbmRleCBmbGFnLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc2V0IG9yaWVudGF0aW9uTWF4SW5kZXgob3JpZW50YXRpb25NYXhJbmRleCkge1xyXG4gICAgdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCA9IG9yaWVudGF0aW9uTWF4SW5kZXg7XHJcbiAgfVxyXG5cclxuICBnZXQgb3JpZW50YXRpb25NYXhJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4O1xyXG4gIH1cclxuXHJcbiAgc2V0IGNhbnZhc1dpZHRoKGNhbnZhc1dpZHRoKSB7XHJcbiAgICB0aGlzLl9jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xyXG4gICAgdGhpcy5fc2xpY2UuY2FudmFzV2lkdGggPSB0aGlzLl9jYW52YXNXaWR0aDtcclxuICB9XHJcblxyXG4gIGdldCBjYW52YXNXaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYW52YXNXaWR0aDtcclxuICB9XHJcblxyXG4gIHNldCBjYW52YXNIZWlnaHQoY2FudmFzSGVpZ2h0KSB7XHJcbiAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XHJcbiAgICB0aGlzLl9zbGljZS5jYW52YXNIZWlnaHQgPSB0aGlzLl9jYW52YXNIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBnZXQgY2FudmFzSGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhc0hlaWdodDtcclxuICB9XHJcblxyXG4gIHNldCBib3JkZXJDb2xvcihib3JkZXJDb2xvcikge1xyXG4gICAgdGhpcy5fYm9yZGVyQ29sb3IgPSBib3JkZXJDb2xvcjtcclxuICAgIHRoaXMuX2JvcmRlci5jb2xvciA9IGJvcmRlckNvbG9yO1xyXG4gICAgdGhpcy5fc2xpY2UuYm9yZGVyQ29sb3IgPSB0aGlzLl9ib3JkZXJDb2xvcjtcclxuICB9XHJcblxyXG4gIGdldCBib3JkZXJDb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9ib3JkZXJDb2xvcjtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gUFJJVkFURSBNRVRIT0RTXHJcbiAgLy9cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbCBzZXR1cCwgaW5jbHVkaW5nIHN0YWNrIHByZXBhcmUsIGJib3ggcHJlcGFyZSwgc2xpY2UgcHJlcGFyZSBhbmRcclxuICAgKiBib3JkZXIgcHJlcGFyZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NyZWF0ZSgpIHtcclxuICAgIGlmICh0aGlzLl9zdGFjaykge1xyXG4gICAgICAvLyBwcmVwYXJlIHN0aGUgc3RhY2sgaW50ZXJuYWxzXHJcbiAgICAgIHRoaXMuX3ByZXBhcmVTdGFjaygpO1xyXG5cclxuICAgICAgLy8gcHJlcGFyZSB2aXN1YWwgb2JqZWN0c1xyXG4gICAgICB0aGlzLl9wcmVwYXJlQkJveCgpO1xyXG4gICAgICB0aGlzLl9wcmVwYXJlU2xpY2UoKTtcclxuICAgICAgdGhpcy5fcHJlcGFyZUJvcmRlcigpO1xyXG4gICAgICAvLyB0b2RvOiBBcnJvd1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdubyBzdGFjayB0byBiZSBwcmVwYXJlZC4uLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NvbXB1dGVPcmllbnRhdGlvbk1heEluZGV4KCkge1xyXG4gICAgbGV0IGRpbWVuc2lvbnNJSksgPSB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLO1xyXG4gICAgdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCA9IDA7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX29yaWVudGF0aW9uKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4ID0gZGltZW5zaW9uc0lKSy56IC0gMTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSBkaW1lbnNpb25zSUpLLnggLSAxO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCA9IGRpbWVuc2lvbnNJSksueSAtIDE7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgLy8gZG8gbm90aGluZyFcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmVuIG9yaWVudGF0aW9uLCBjaGVjayBpZiBpbmRleCBpcyBpbi9vdXQgb2YgYm91bmRzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfaXNJbmRleE91dE9mQm91bmRzKCkge1xyXG4gICAgdGhpcy5fY29tcHV0ZU9yaWVudGF0aW9uTWF4SW5kZXgoKTtcclxuICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4IHx8IHRoaXMuX2luZGV4IDwgMCkge1xyXG4gICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlcGFyZSBhIHN0YWNrIGZvciB2aXN1YWxpemF0aW9uLiAoaW1hZ2UgdG8gd29ybGQgdHJhbnNmb3JtLCBmcmFtZXMgb3JkZXIsXHJcbiAgICogcGFjayBkYXRhIGludG8gOCBiaXRzIHRleHR1cmVzLCBldGMuKVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcHJlcGFyZVN0YWNrKCkge1xyXG4gICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZywgaWYgbm90IHRocm93IGFuIGVycm9yXHJcbiAgICAvLyBjb21wdXRlIGltYWdlIHRvIHdvcmtkIHRyYW5zZm9ybSwgb3JkZXIgZnJhbWVzLCBldGMuXHJcbiAgICBpZiAoIXRoaXMuX3N0YWNrLnByZXBhcmVkKSB7XHJcbiAgICAgIHRoaXMuX3N0YWNrLnByZXBhcmUoKTtcclxuICAgIH1cclxuICAgIC8vIHBhY2sgZGF0YSBpbnRvIDggYml0cyByZ2JhIHRleHR1cmUgZm9yIHRoZSBzaGFkZXJcclxuICAgIC8vIHRoaXMgb25lIGNhbiBiZSBzbG93Li4uXHJcbiAgICBpZiAoIXRoaXMuX3N0YWNrLnBhY2tlZCkge1xyXG4gICAgICB0aGlzLl9zdGFjay5wYWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR1cCBib3VuZGluZyBib3ggaGVscGVyIGdpdmVuIHByZXBhcmVkIHN0YWNrIGFuZCBhZGQgYm91bmRpbmcgYm94IGhlbHBlclxyXG4gICAqIHRvIHN0YWNrIGhlbHBlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3ByZXBhcmVCQm94KCkge1xyXG4gICAgdGhpcy5fYkJveCA9IG5ldyBIZWxwZXJzQm91bmRpbmdCb3godGhpcy5fc3RhY2spO1xyXG4gICAgdGhpcy5hZGQodGhpcy5fYkJveCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR1cCBib3JkZXIgaGVscGVyIGdpdmVuIHNsaWNlIGhlbHBlciBhbmQgYWRkIGJvcmRlciBoZWxwZXJcclxuICAgKiB0byBzdGFjayBoZWxwZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcmVwYXJlQm9yZGVyKCkge1xyXG4gICAgdGhpcy5fYm9yZGVyID0gbmV3IEhlbHBlcnNCb3JkZXIodGhpcy5fc2xpY2UpO1xyXG4gICAgdGhpcy5hZGQodGhpcy5fYm9yZGVyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHVwIHNsaWNlIGhlbHBlciBnaXZlbiBwcmVwYXJlZCBzdGFjayBoZWxwZXIgYW5kIGFkZCBzbGljZSBoZWxwZXJcclxuICAgKiB0byBzdGFjayBoZWxwZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcmVwYXJlU2xpY2UoKSB7XHJcbiAgICBsZXQgaGFsZkRpbWVuc2lvbnNJSksgPSB0aGlzLl9zdGFjay5oYWxmRGltZW5zaW9uc0lKSztcclxuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCBpbmRleCBnaXZlbiBvcmllbnRhdGlvblxyXG4gICAgdGhpcy5faW5kZXggPSB0aGlzLl9wcmVwYXJlU2xpY2VJbmRleChoYWxmRGltZW5zaW9uc0lKSyk7XHJcbiAgICAvLyBjb21wdXRlIGluaXRpYWwgcG9zaXRpb24gZ2l2ZW4gb3JpZW50YXRpb24gYW5kIGluZGV4XHJcbiAgICBsZXQgcG9zaXRpb24gPSB0aGlzLl9wcmVwYXJlU2xpY2VQb3NpdGlvbihoYWxmRGltZW5zaW9uc0lKSywgdGhpcy5faW5kZXgpO1xyXG4gICAgLy8gY29tcHV0ZSBpbml0aWFsIGRpcmVjdGlvbiBvcmllbnRhdGlvblxyXG4gICAgbGV0IGRpcmVjdGlvbiA9IHRoaXMuX3ByZXBhcmVEaXJlY3Rpb24odGhpcy5fb3JpZW50YXRpb24pO1xyXG5cclxuICAgIHRoaXMuX3NsaWNlID0gbmV3IEhlbHBlcnNTbGljZSh0aGlzLl9zdGFjaywgdGhpcy5faW5kZXgsIHBvc2l0aW9uLCBkaXJlY3Rpb24pO1xyXG4gICAgdGhpcy5hZGQodGhpcy5fc2xpY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBzbGljZSBpbmRleCBkZXBlbmRpbmcgb24gb3JpZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGluZGljZXMgLSBJbmRpY2VzIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn0gU2xpY2UgaW5kZXggYWNjb3JkaW5nIHRvIGN1cnJlbnQgb3JpZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcmVwYXJlU2xpY2VJbmRleChpbmRpY2VzKSB7XHJcbiAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgc3dpdGNoICh0aGlzLl9vcmllbnRhdGlvbikge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGljZXMueik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kaWNlcy54KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRpY2VzLnkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vIGRvIG5vdGhpbmchXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlIHNsaWNlIHBvc2l0aW9uIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbi5cclxuICAgKiBTZXRzIGluZGV4IGluIHByb3BlciBsb2NhdGlvbiBvZiByZWZlcmVuY2UgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHJQb3NpdGlvbiAtIFJlZmVyZW5jZSBwb3NpdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBDdXJyZW50IGluZGV4LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn0gU2xpY2UgaW5kZXggYWNjb3JkaW5nIHRvIGN1cnJlbnQgb3JpZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcmVwYXJlU2xpY2VQb3NpdGlvbihyUG9zaXRpb24sIGluZGV4KSB7XHJcbiAgICBsZXQgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKTtcclxuICAgIHN3aXRjaCAodGhpcy5fb3JpZW50YXRpb24pIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICBNYXRoLmZsb29yKHJQb3NpdGlvbi54KSxcclxuICAgICAgICAgIE1hdGguZmxvb3IoclBvc2l0aW9uLnkpLFxyXG4gICAgICAgICAgaW5kZXgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgTWF0aC5mbG9vcihyUG9zaXRpb24ueSksXHJcbiAgICAgICAgICBNYXRoLmZsb29yKHJQb3NpdGlvbi56KSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgTWF0aC5mbG9vcihyUG9zaXRpb24ueCksXHJcbiAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgIE1hdGguZmxvb3IoclBvc2l0aW9uLnopKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICAvLyBkbyBub3RoaW5nIVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBzbGljZSBkaXJlY3Rpb24gZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWVudGF0aW9uIC0gU2xpY2Ugb3JpZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7VEhSRUUuVmVjdG9yM30gU2xpY2UgZGlyZWN0aW9uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcmVwYXJlRGlyZWN0aW9uKG9yaWVudGF0aW9uKSB7XHJcbiAgICBsZXQgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSk7XHJcbiAgICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgLy8gZG8gbm90aGluZyFcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGlyZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVsZWFzZSB0aGUgc3RhY2sgaGVscGVyIG1lbW9yeSBpbmNsdWRpbmcgdGhlIHNsaWNlIG1lbW9yeS5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgdGhpcy5yZW1vdmUodGhpcy5fc2xpY2UpO1xyXG4gICAgdGhpcy5fc2xpY2UuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fc2xpY2UgPSBudWxsO1xyXG4gICAgdGhpcy5fYkJveC5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLl9iQm94ID0gIG51bGw7XHJcbiAgICB0aGlzLl9ib3JkZXIuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fYm9yZGVyID0gIG51bGw7XHJcbiAgfVxyXG5cclxufVxyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IFNoYWRlcnNVbmlmb3JtIGZyb20gJy4uL3NoYWRlcnMvc2hhZGVycy52ci51bmlmb3JtJztcclxuaW1wb3J0IFNoYWRlcnNWZXJ0ZXggZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLnZyLnZlcnRleCc7XHJcbmltcG9ydCBTaGFkZXJzRnJhZ21lbnQgZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLnZyLmZyYWdtZW50JztcclxuXHJcbmltcG9ydCBIZWxwZXJzTWF0ZXJpYWxNaXhpbiBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0ZXJpYWwubWl4aW4nO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvdm9sdW1lcmVuZGVyaW5nXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc1ZvbHVtZVJlbmRlcmluZyBleHRlbmRzIEhlbHBlcnNNYXRlcmlhbE1peGluKFRIUkVFLk9iamVjdDNEKSB7XHJcbiAgY29uc3RydWN0b3Ioc3RhY2spIHtcclxuICAgIC8vXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xyXG4gICAgdGhpcy5fc2hhZGVyc0ZyYWdtZW50ID0gU2hhZGVyc0ZyYWdtZW50O1xyXG4gICAgdGhpcy5fc2hhZGVyc1ZlcnRleCA9IFNoYWRlcnNWZXJ0ZXg7XHJcbiAgICB0aGlzLl91bmlmb3JtcyA9IFNoYWRlcnNVbmlmb3JtLnVuaWZvcm1zKCk7XHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5faW50ZXJwb2xhdGlvbiA9IDE7IC8vIGRlZmF1bHQgdG8gdHJpbGluZWFyIGludGVycG9sYXRpb25cclxuXHJcbiAgICB0aGlzLl9jcmVhdGUoKTtcclxuICB9XHJcblxyXG4gIF9jcmVhdGUoKSB7XHJcbiAgICB0aGlzLl9wcmVwYXJlU3RhY2soKTtcclxuICAgIHRoaXMuX3ByZXBhcmVUZXh0dXJlKCk7XHJcbiAgICB0aGlzLl9wcmVwYXJlTWF0ZXJpYWwoKTtcclxuICAgIHRoaXMuX3ByZXBhcmVHZW9tZXRyeSgpO1xyXG5cclxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTWVzaCh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XHJcbiAgfVxyXG5cclxuICBfcHJlcGFyZVN0YWNrKCkge1xyXG4gICAgaWYgKCF0aGlzLl9zdGFjay5wcmVwYXJlZCkge1xyXG4gICAgICB0aGlzLl9zdGFjay5wcmVwYXJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9zdGFjay5wYWNrZWQpIHtcclxuICAgICAgdGhpcy5fc3RhY2sucGFjaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3ByZXBhcmVNYXRlcmlhbCgpIHtcclxuICAgIC8vIGNvbXBlbnNhdGUgZm9yIHRoZSBvZmZzZXQgdG8gb25seSBwYXNzID4gMCB2YWx1ZXMgdG8gc2hhZGVyc1xyXG4gICAgLy8gbW9kZWxzID4gbW9kZWxzLnN0YWNrLmpzIDogX3BhY2tUbzhCaXRzXHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGlmICh0aGlzLl9zdGFjay5fbWluTWF4WzBdIDwgMCkge1xyXG4gICAgICBvZmZzZXQgPSB0aGlzLl9zdGFjay5fbWluTWF4WzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVuaWZvcm1zXHJcbiAgICB0aGlzLl91bmlmb3JtcyA9IFNoYWRlcnNVbmlmb3JtLnVuaWZvcm1zKCk7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51V29ybGRCQm94LnZhbHVlID0gdGhpcy5fc3RhY2sud29ybGRCb3VuZGluZ0JveCgpO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVRleHR1cmVTaXplLnZhbHVlID0gdGhpcy5fc3RhY2sudGV4dHVyZVNpemU7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51VGV4dHVyZUNvbnRhaW5lci52YWx1ZSA9IHRoaXMuX3RleHR1cmVzO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVdvcmxkVG9EYXRhLnZhbHVlID0gdGhpcy5fc3RhY2subHBzMklKSztcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVOdW1iZXJPZkNoYW5uZWxzLnZhbHVlID0gdGhpcy5fc3RhY2subnVtYmVyT2ZDaGFubmVscztcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVQaXhlbFR5cGUudmFsdWUgPSB0aGlzLl9zdGFjay5waXhlbFR5cGU7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51Qml0c0FsbG9jYXRlZC52YWx1ZSA9IHRoaXMuX3N0YWNrLmJpdHNBbGxvY2F0ZWQ7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51UGFja2VkUGVyUGl4ZWwudmFsdWUgPSB0aGlzLl9zdGFjay5wYWNrZWRQZXJQaXhlbDtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVXaW5kb3dDZW50ZXJXaWR0aC52YWx1ZSA9IFtvZmZzZXQgKyB0aGlzLl9zdGFjay53aW5kb3dDZW50ZXIsIHRoaXMuX3N0YWNrLndpbmRvd1dpZHRoICogMC44XTtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVSZXNjYWxlU2xvcGVJbnRlcmNlcHQudmFsdWUgPSBbdGhpcy5fc3RhY2sucmVzY2FsZVNsb3BlLCB0aGlzLl9zdGFjay5yZXNjYWxlSW50ZXJjZXB0XTtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVEYXRhRGltZW5zaW9ucy52YWx1ZSA9IFt0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrLmRpbWVuc2lvbnNJSksueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy56XTtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVJbnRlcnBvbGF0aW9uLnZhbHVlID0gdGhpcy5faW50ZXJwb2xhdGlvbjtcclxuXHJcbiAgICB0aGlzLl9jcmVhdGVNYXRlcmlhbCh7XHJcbiAgICAgIHNpZGU6IFRIUkVFLkZyb250U2lkZSxcclxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9wcmVwYXJlR2VvbWV0cnkoKSB7XHJcbiAgICBsZXQgd29ybGRCQm94ID0gdGhpcy5fc3RhY2sud29ybGRCb3VuZGluZ0JveCgpO1xyXG4gICAgbGV0IGNlbnRlckxQUyA9IHRoaXMuX3N0YWNrLndvcmxkQ2VudGVyKCk7XHJcblxyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoXHJcbiAgICAgIHdvcmxkQkJveFsxXSAtIHdvcmxkQkJveFswXSxcclxuICAgICAgd29ybGRCQm94WzNdIC0gd29ybGRCQm94WzJdLFxyXG4gICAgICB3b3JsZEJCb3hbNV0gLSB3b3JsZEJCb3hbNF0pO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkuYXBwbHlNYXRyaXgobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oXHJcbiAgICAgIGNlbnRlckxQUy54LCBjZW50ZXJMUFMueSwgY2VudGVyTFBTLnopKTtcclxuICB9XHJcblxyXG4gIGdldCB1bmlmb3JtcygpIHtcclxuICAgIHJldHVybiB0aGlzLl91bmlmb3JtcztcclxuICB9XHJcblxyXG4gIHNldCB1bmlmb3Jtcyh1bmlmb3Jtcykge1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSB1bmlmb3JtcztcclxuICB9XHJcblxyXG4gIGdldCBzdGFjaygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGFjaztcclxuICB9XHJcblxyXG4gIHNldCBzdGFjayhzdGFjaykge1xyXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcclxuICB9XHJcblxyXG4gIGdldCBpbnRlcnBvbGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgaW50ZXJwb2xhdGlvbihpbnRlcnBvbGF0aW9uKSB7XHJcbiAgICB0aGlzLl9pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVJbnRlcnBvbGF0aW9uLnZhbHVlID0gdGhpcy5faW50ZXJwb2xhdGlvbjtcclxuICAgIHRoaXMuX3VwZGF0ZU1hdGVyaWFsKCk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9pbnRlcmFjdG9yXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcmFjdG9yIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICB9XHJcblxyXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xyXG4gIF9jcmVhdGUoKSB7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlKCkge1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IEludGVyYWN0b3IgZnJvbSAnLi9oZWxwZXJzLnguaW50ZXJhY3Rvcic7XHJcbmltcG9ydCBNZXNoIGZyb20gJy4vaGVscGVycy54Lm1lc2gnO1xyXG5pbXBvcnQgUmVuZGVyZXIzRCBmcm9tICcuL2hlbHBlcnMueC5yZW5kZXJlcjNkJztcclxuaW1wb3J0IFJlbmRlcmVyMkQgZnJvbSAnLi9oZWxwZXJzLngucmVuZGVyZXIyZCc7XHJcbmltcG9ydCBWb2x1bWUgZnJvbSAnLi9oZWxwZXJzLngudm9sdW1lJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnNcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgSW50ZXJhY3RvcixcclxuICBNZXNoLFxyXG4gIFJlbmRlcmVyM0QsXHJcbiAgUmVuZGVyZXIyRCxcclxuICBWb2x1bWUsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9tZXNoXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fZmlsZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fM2pzVlRLX2xvYWRlciA9IG5ldyBUSFJFRS5WVEtMb2FkZXIoKTtcclxuICAgIHRoaXMuX21lc2ggPSBudWxsO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWxDb2xvciA9IDB4RTkxRTYzO1xyXG4gICAgdGhpcy5fUkFTdG9MUFMgPSBudWxsO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuX21hdGVyaWFsQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBhY2Nlc3NvciBwcm9wZXJ0aWVzXHJcbiAgZ2V0IGZpbGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlsZTtcclxuICB9XHJcblxyXG4gIHNldCBmaWxlKGZuYW1lKSB7XHJcbiAgICB0aGlzLl9maWxlID0gZm5hbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgbWF0ZXJpYWxDb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbENvbG9yO1xyXG4gIH1cclxuXHJcbiAgc2V0IG1hdGVyaWFsQ29sb3IoY29sb3IpIHtcclxuICAgIHRoaXMuX21hdGVyaWFsQ29sb3IgPSBjb2xvcjtcclxuICB9XHJcblxyXG4gIC8vIGxvYWQgZnVuY3Rpb25cclxuICBsb2FkKCkge1xyXG4gICAgaWYgKHRoaXMuZmlsZSkge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRoaXMuXzNqc1ZUS19sb2FkZXIubG9hZCh0aGlzLmZpbGUsXHJcbiAgICAgICAgICAoZ2VvbWV0cnkpID0+IHtcclxuICAgICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG4gICAgICAgICAgICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgICAgICAgICAgIHRoaXMuX1JBU3RvTFBTID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgICAgICAgICAgICB0aGlzLl9SQVN0b0xQUy5zZXQoLTEsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAtMSwgMCwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAxKTtcclxuICAgICAgICAgICAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX1JBU3RvTFBTKTtcclxuICAgICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIGFuZCByZXR1cm4gdGhlIG1lc2hcclxuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuX21lc2gpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgICgpID0+IHt9LFxyXG4gICAgICAgICAgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICBtZXNzYWdlOiBgQ291bGRuJ3QgbG9hZCBmaWxlOiAke3RoaXMuZmlsZX0uYCxcclxuICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7bWVzc2FnZTogYEZpbGUgaXMgbm90IGRlZmluZWQ6ICR7dGhpcy5maWxlfS5gfSk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9yZW5kZXJlcjJkXHJcbiAqL1xyXG5pbXBvcnQgQ2FtZXJhc09ydGhvZ3JhcGhpYyBmcm9tICcuLi8uLi9jYW1lcmFzL2NhbWVyYXMub3J0aG9ncmFwaGljJztcclxuaW1wb3J0IENvbnRyb2xzT3J0aG9ncmFwaGljIGZyb20gJy4uLy4uL2NvbnRyb2xzL2NvbnRyb2xzLnRyYWNrYmFsbG9ydGhvJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJJZD0ncjJkJywgb3JpZW50YXRpb249J2RlZmF1bHQnKSB7XHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fY2FtZXJhID0gbnVsbDtcclxuICAgIHRoaXMuX2NvbnRyb2xzID0gbnVsbDtcclxuICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICB0aGlzLl9zY2VuZSA9IG51bGw7XHJcbiAgICB0aGlzLl9vYmplY3QgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2luaXRSZW5kZXJlcihjb250YWluZXJJZCk7XHJcbiAgICB0aGlzLl9pbml0Q2FtZXJhKCk7XHJcbiAgICB0aGlzLl9pbml0U2NlbmUoKTtcclxuICAgIHRoaXMuX2luaXRDb250cm9scygpO1xyXG5cclxuICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgdGhpcy5fb25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fb25XaW5kb3dSZXNpemUgPSB0aGlzLl9vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xyXG4gIH1cclxuXHJcbiAgYWRkKG9iamVjdCkge1xyXG4gICAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgdGhpcy5fc2NlbmUuYWRkKHRoaXMuX29iamVjdCk7XHJcblxyXG4gICAgdGhpcy5fc2V0dXBDYW1lcmEodGhpcy5fb2JqZWN0LnN0YWNrKTtcclxuICAgIHRoaXMuX29yaWVudENhbWVyYSh0aGlzLl9vYmplY3QsIHRoaXMuX29yaWVudGF0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9vYmplY3QuY2FudmFzV2lkdGggPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGg7XHJcbiAgICB0aGlzLl9vYmplY3QuY2FudmFzSGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodDtcclxuICB9XHJcblxyXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignT25TY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgZmFsc2UpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcclxuICAgIHRoaXMuX2NvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ09uU2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIGZhbHNlKTtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgYW5pbWF0ZSgpIHtcclxuICAgIHRoaXMuX2NvbnRyb2xzLnVwZGF0ZSgpO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX3NjZW5lLCB0aGlzLl9jYW1lcmEpO1xyXG5cclxuICAgIC8vIHJlcXVlc3QgbmV3IGZyYW1lXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgLy8gcHJpdmF0ZSBtZXRob2RzXHJcblxyXG4gIF9pbml0UmVuZGVyZXIoY29udGFpbmVySWQpIHtcclxuICAgIC8vIHJlbmRlcmVyXHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJZCk7XHJcbiAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcclxuICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTaXplKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MjEyMTIxLCAxKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgX2luaXRDYW1lcmEoKSB7XHJcbiAgICB0aGlzLl9jYW1lcmEgPSBuZXcgQ2FtZXJhc09ydGhvZ3JhcGhpYyh0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggLyAtMixcclxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIC8gMiwgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCAvIDIsXHJcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgLyAtMiwgMSwgMTAwMCk7XHJcbiAgfVxyXG5cclxuICBfaW5pdFNjZW5lKCkge1xyXG4gICAgdGhpcy5fc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuICB9XHJcblxyXG4gIF9pbml0Q29udHJvbHMoKSB7XHJcbiAgICAvLyBjb250cm9sc1xyXG4gICAgdGhpcy5fY29udHJvbHMgPSBuZXcgQ29udHJvbHNPcnRob2dyYXBoaWModGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgdGhpcy5fY29udHJvbHMuc3RhdGljTW92aW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuX2NvbnRyb2xzLm5vUm90YXRlID0gdHJ1ZTtcclxuICAgIHRoaXMuX2NhbWVyYS5jb250cm9scyA9IHRoaXMuX2NvbnRyb2xzO1xyXG4gIH1cclxuXHJcbiAgX3NldHVwQ2FtZXJhKHN0YWNrKSB7XHJcbiAgICAvLyBzZXQgY2FtZXJhXHJcbiAgICBsZXQgd29ybGRiYiA9IHN0YWNrLndvcmxkQm91bmRpbmdCb3goKTtcclxuICAgIGxldCBscHNEaW1zID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgIHdvcmxkYmJbMV0gLSB3b3JsZGJiWzBdLFxyXG4gICAgICB3b3JsZGJiWzNdIC0gd29ybGRiYlsyXSxcclxuICAgICAgd29ybGRiYls1XSAtIHdvcmxkYmJbNF1cclxuICAgICk7XHJcblxyXG4gICAgLy8gYm94OiB7aGFsZkRpbWVuc2lvbnMsIGNlbnRlcn1cclxuICAgIGxldCBib3ggPSB7XHJcbiAgICAgIGNlbnRlcjogc3RhY2sud29ybGRDZW50ZXIoKS5jbG9uZSgpLFxyXG4gICAgICBoYWxmRGltZW5zaW9uczogbmV3IFRIUkVFLlZlY3RvcjMobHBzRGltcy54ICsgMTAsIGxwc0RpbXMueSArIDEwLFxyXG4gICAgICAgIGxwc0RpbXMueiArIDEwKSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gaW5pdCBhbmQgem9vbVxyXG4gICAgbGV0IGNhbnZhcyA9IHtcclxuICAgICAgICB3aWR0aDogdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCxcclxuICAgICAgfTtcclxuXHJcbiAgICB0aGlzLl9jYW1lcmEuZGlyZWN0aW9ucyA9IFtzdGFjay54Q29zaW5lLCBzdGFjay55Q29zaW5lLCBzdGFjay56Q29zaW5lXTtcclxuICAgIHRoaXMuX2NhbWVyYS5ib3ggPSBib3g7XHJcbiAgICB0aGlzLl9jYW1lcmEuY2FudmFzID0gY2FudmFzO1xyXG4gICAgdGhpcy5fY2FtZXJhLnVwZGF0ZSgpO1xyXG4gICAgdGhpcy5fY2FtZXJhLmZpdEJveCgyKTtcclxuICB9XHJcblxyXG4gIF9vcmllbnRDYW1lcmEodGFyZ2V0LCBvcmllbnRhdGlvbj0nZGVmYXVsdCcpIHtcclxuICAgICAgdGhpcy5fY2FtZXJhLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgIHRoaXMuX2NhbWVyYS51cGRhdGUoKTtcclxuICAgICAgdGhpcy5fY2FtZXJhLmZpdEJveCgyKTtcclxuICAgICAgdGFyZ2V0Lm9yaWVudGF0aW9uID0gdGhpcy5fY2FtZXJhLnN0YWNrT3JpZW50YXRpb247XHJcbiAgfVxyXG5cclxuICBfb25XaW5kb3dSZXNpemUoKSB7XHJcbiAgICAgIHRoaXMuX2NhbWVyYS5jYW52YXMgPSB7XHJcbiAgICAgICAgd2lkdGg6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQsXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX2NhbWVyYS5maXRCb3goMik7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFNpemUodGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xyXG4gICAgICB0aGlzLl9vYmplY3QuY2FudmFzV2lkdGggPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGg7XHJcbiAgICAgIHRoaXMuX29iamVjdC5jYW52YXNIZWlnaHQgPSB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgX29uU2Nyb2xsKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuZGVsdGEgPiAwKSB7XHJcbiAgICAgIGlmICh0aGlzLl9vYmplY3QuaW5kZXggPj0gdGhpcy5fb2JqZWN0Lm9yaWVudGF0aW9uTWF4SW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fb2JqZWN0LmluZGV4ICs9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGhpcy5fb2JqZWN0LmluZGV4IDw9IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fb2JqZWN0LmluZGV4IC09IDE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL3gvcmVuZGVyZXIzZFxyXG4gKi9cclxuaW1wb3J0IENvbnRyb2xzVHJhY2tiYWxsIGZyb20gJy4uLy4uL2NvbnRyb2xzL2NvbnRyb2xzLnRyYWNrYmFsbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVySWQ9J3IzZCcpIHtcclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XHJcbiAgICB0aGlzLl9jYW1lcmEgPSBudWxsO1xyXG4gICAgdGhpcy5fY29udHJvbHMgPSBudWxsO1xyXG4gICAgdGhpcy5fc2NlbmUgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2luaXRSZW5kZXJlcihjb250YWluZXJJZCk7XHJcbiAgICB0aGlzLl9pbml0Q2FtZXJhKCk7XHJcbiAgICB0aGlzLl9pbml0U2NlbmUoKTtcclxuICAgIHRoaXMuX2luaXRDb250cm9scygpO1xyXG5cclxuICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgdGhpcy5fb25XaW5kb3dSZXNpemUgPSB0aGlzLl9vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIGdldCBjb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgYWRkKG9iaikge1xyXG4gICAgdGhpcy5fc2NlbmUuYWRkKG9iaik7XHJcbiAgfVxyXG5cclxuICBhZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGNlbnRlcih3b3JsZFBvc2l0aW9uKSB7XHJcbiAgICAvLyB1cGRhdGUgY2FtcmVhJ3MgYW5kIGNvbnRyb2wncyB0YXJnZXRcclxuICAgIHRoaXMuX2NhbWVyYS5sb29rQXQod29ybGRQb3NpdGlvbi54LCB3b3JsZFBvc2l0aW9uLnksIHdvcmxkUG9zaXRpb24ueik7XHJcbiAgICB0aGlzLl9jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG4gICAgdGhpcy5fY29udHJvbHMudGFyZ2V0LnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSxcclxuICAgICAgd29ybGRQb3NpdGlvbi56KTtcclxuICB9XHJcblxyXG4gIGFuaW1hdGUoKSB7XHJcbiAgICB0aGlzLl9jb250cm9scy51cGRhdGUoKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcclxuXHJcbiAgICAvLyByZXF1ZXN0IG5ldyBmcmFtZVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xyXG5cclxuICBfb25XaW5kb3dSZXNpemUoKSB7XHJcbiAgICB0aGlzLl9jYW1lcmEuYXNwZWN0ID1cclxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIC8gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodDtcclxuICAgIHRoaXMuX2NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U2l6ZSh0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXHJcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgX2luaXRSZW5kZXJlcihjb250YWluZXJJZCkge1xyXG4gICAgLy8gcmVuZGVyZXJcclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcklkKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xyXG4gICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFNpemUodGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnNldENsZWFyQ29sb3IoMHg0MjQyNDIsIDEpO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XHJcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBfaW5pdENhbWVyYSgpIHtcclxuICAgIHRoaXMuX2NhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSxcclxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIC8gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCwgMSwgMTAwMDAwMDApO1xyXG4gICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnggPSAyNTA7XHJcbiAgICB0aGlzLl9jYW1lcmEucG9zaXRpb24ueSA9IDI1MDtcclxuICAgIHRoaXMuX2NhbWVyYS5wb3NpdGlvbi56ID0gMjUwO1xyXG4gIH1cclxuXHJcbiAgX2luaXRTY2VuZSgpIHtcclxuICAgIC8vIGFkZCBzb21lIGxpZ2h0cyB0byB0aGUgc2NlbmUgYnkgZGVmYXVsdFxyXG4gICAgdGhpcy5fc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuXHJcbiAgICAvLyBhbWJpZW50XHJcbiAgICB0aGlzLl9zY2VuZS5hZGQobmV3IFRIUkVFLkFtYmllbnRMaWdodCgweDM1MzUzNSkpO1xyXG5cclxuICAgIC8vIGRpcmVjdGlvbmFsIDFcclxuICAgIGxldCBkaXJlY3Rpb25hbExpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDEpO1xyXG4gICAgZGlyZWN0aW9uYWxMaWdodC5wb3NpdGlvbi5zZXQoMjAwLCAyMDAsIDEwMDApLm5vcm1hbGl6ZSgpO1xyXG4gICAgdGhpcy5fc2NlbmUuYWRkKGRpcmVjdGlvbmFsTGlnaHQpO1xyXG5cclxuICAgIC8vIGRpcmVjdGlvbmFsIDJcclxuICAgIGxldCBkaXJlY3Rpb25hbExpZ2h0MiA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcclxuICAgIGRpcmVjdGlvbmFsTGlnaHQyLnBvc2l0aW9uLnNldCgtMjAwLCAtMjAwLCAtMTAwMCkubm9ybWFsaXplKCk7XHJcbiAgICB0aGlzLl9zY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodDIpO1xyXG4gIH1cclxuXHJcbiAgX2luaXRDb250cm9scygpIHtcclxuICAgIC8vIGNvbnRyb2xzXHJcbiAgICB0aGlzLl9jb250cm9scyA9IG5ldyBDb250cm9sc1RyYWNrYmFsbCh0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICB0aGlzLl9jb250cm9scy5yb3RhdGVTcGVlZCA9IDEuNDtcclxuICAgIHRoaXMuX2NvbnRyb2xzLnpvb21TcGVlZCA9IDEuMjtcclxuICAgIHRoaXMuX2NvbnRyb2xzLnBhblNwZWVkID0gMC44O1xyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy94L3ZvbHVtZVxyXG4gKi9cclxuXHJcbmltcG9ydCBIZWxwZXJzU3RhY2sgZnJvbSAnLi4vaGVscGVycy5zdGFjayc7XHJcbmltcG9ydCBMb2FkZXJzVm9sdW1lIGZyb20gJy4uLy4uL2xvYWRlcnMvbG9hZGVycy52b2x1bWUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9maWxlID0gbnVsbDtcclxuICAgIHRoaXMuX3Byb2dyZXNzYmFyQ29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuX3N0YWNrID0gbnVsbDtcclxuICAgIHRoaXMuX2NlbnRlckxQUyA9IG51bGw7XHJcbiAgICB0aGlzLl94U2xpY2UgPSBudWxsO1xyXG4gICAgdGhpcy5feVNsaWNlID0gbnVsbDtcclxuICAgIHRoaXMuX3pTbGljZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBhY2Nlc3NvciBwcm9wZXJ0aWVzXHJcbiAgZ2V0IGZpbGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlsZTtcclxuICB9XHJcblxyXG4gIHNldCBmaWxlKGZuYW1lKSB7XHJcbiAgICB0aGlzLl9maWxlID0gZm5hbWU7XHJcbiAgfVxyXG5cclxuICBzZXQgcHJvZ3Jlc3NiYXJDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLl9wcm9ncmVzc2JhckNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIGdldCBjZW50ZXJMUFMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2VudGVyTFBTO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YWNrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xyXG4gIH1cclxuXHJcbiAgLy8gcHJpdmF0ZSBtZXRob2RzXHJcbiAgX2NyZWF0ZVNsaWNlKG9yaWVudGF0aW9uKSB7XHJcbiAgICBpZiAodGhpcy5fc3RhY2spIHtcclxuICAgICAgY29uc3Qgc3RhY2tIZWxwZXIgPSBuZXcgSGVscGVyc1N0YWNrKHRoaXMuX3N0YWNrKTtcclxuICAgICAgc3RhY2tIZWxwZXIub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuXHJcbiAgICAgIGlmIChvcmllbnRhdGlvbj09PTApIHtcclxuICAgICAgICBzdGFja0hlbHBlci5ib3JkZXIuY29sb3IgPSAweEY0NDMzNjtcclxuICAgICAgICB0aGlzLl94U2xpY2UgPSBzdGFja0hlbHBlcjtcclxuICAgICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbj09PTEpIHtcclxuICAgICAgICBzdGFja0hlbHBlci5iYm94LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICBzdGFja0hlbHBlci5ib3JkZXIuY29sb3IgPSAweDRDQUY1MDtcclxuICAgICAgICB0aGlzLl95U2xpY2UgPSBzdGFja0hlbHBlcjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdGFja0hlbHBlci5iYm94LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICBzdGFja0hlbHBlci5ib3JkZXIuY29sb3IgPSAweDIxOTZGMztcclxuICAgICAgICB0aGlzLl96U2xpY2UgPSBzdGFja0hlbHBlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fY2VudGVyTFBTID0gc3RhY2tIZWxwZXIuc3RhY2sud29ybGRDZW50ZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHB1YmxpYyBtZXRob2RzXHJcbiAgbG9hZCgpIHtcclxuICAgIGlmICh0aGlzLmZpbGUpIHtcclxuICAgICAgLy8gaW5zdGFudGlhdGUgdGhlIGxvYWRlclxyXG4gICAgICAvLyBpdCBsb2FkcyBhbmQgcGFyc2VzIHRoZSBkaWNvbSBpbWFnZVxyXG4gICAgICBjb25zdCBsb2FkZXIgPSBuZXcgTG9hZGVyc1ZvbHVtZSh0aGlzLl9wcm9ncmVzc2JhckNvbnRhaW5lcik7XHJcbiAgICAgIHJldHVybiBsb2FkZXIubG9hZCh0aGlzLmZpbGUpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICBpZiAobG9hZGVyLmRhdGEubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh7bWVzc2FnZTogYE5vIGRhdGEgbG9hZGVkOiAke2xvYWRlci5kYXRhfS5gfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSB0aHJlZSBzbGljZXMgd2hlbiBhbGwgZmlsZXMgaGF2ZSBiZWVuIGxvYWRlZFxyXG4gICAgICAgICAgY29uc3Qgc2VyaWVzID0gbG9hZGVyLmRhdGFbMF0ubWVyZ2VTZXJpZXMobG9hZGVyLmRhdGEpWzBdO1xyXG4gICAgICAgICAgbG9hZGVyLmZyZWUoKTtcclxuXHJcbiAgICAgICAgICB0aGlzLl9zdGFjayA9IHNlcmllcy5zdGFja1swXTtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVNsaWNlKDApO1xyXG4gICAgICAgICAgdGhpcy5hZGQodGhpcy5feFNsaWNlKTtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVNsaWNlKDEpO1xyXG4gICAgICAgICAgdGhpcy5hZGQodGhpcy5feVNsaWNlKTtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVNsaWNlKDIpO1xyXG4gICAgICAgICAgdGhpcy5hZGQodGhpcy5felNsaWNlKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICBsb2FkZXIuZnJlZSgpO1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnU29tZXRoaW5nIHdlbnQgd3JvbmcgbG9hZGluZyB0aGUgdm9sdW1lLi4uJyk7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHttZXNzYWdlOiBgRmlsZSBub3QgZGVmaW5lZDogJHt0aGlzLmZpbGV9LmB9KTtcclxuICB9XHJcbn1cclxuIiwiLyoqIEltcG9ydHMgKiovXHJcbmltcG9ydCBIZWxwZXJzUHJvZ3Jlc3NCYXIgZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnByb2dyZXNzYmFyJztcclxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xyXG5cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBJdCBpcyB0eXBpY2FsbHkgdXNlZCB0byBsb2FkIGEgRElDT00gaW1hZ2UuIFVzZSBsb2FkaW5nIG1hbmFnZXIgZm9yXHJcbiAqIGFkdmFuY2VkIHVzYWdlLCBzdWNoIGFzIG11bHRpcGxlIGZpbGVzIGhhbmRsaW5nLlxyXG4gKlxyXG4gKiBEZW1vOiB7QGxpbmsgaHR0cHM6Ly9mbm5kc2MuZ2l0aHViLmlvL3ZqcyNsb2FkZXJfZGljb219XHJcbiAqXHJcbiAqIEBtb2R1bGUgbG9hZGVycy9iYXNlXHJcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgZmlsZXMgPSBbJy9kYXRhL2RjbS9mcnVpdCddO1xyXG4gKlxyXG4gKiAvLyBJbnN0YW50aWF0ZSBhIGRpY29tIGxvYWRlclxyXG4gKiB2YXIgbERpY29tb2FkZXIgPSBuZXcgZGljb20oKTtcclxuICpcclxuICogLy8gbG9hZCBhIHJlc291cmNlXHJcbiAqIGxvYWRlci5sb2FkKFxyXG4gKiAgIC8vIHJlc291cmNlIFVSTFxyXG4gKiAgIGZpbGVzWzBdLFxyXG4gKiAgIC8vIEZ1bmN0aW9uIHdoZW4gcmVzb3VyY2UgaXMgbG9hZGVkXHJcbiAqICAgZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAqICAgICAvL3NjZW5lLmFkZCggb2JqZWN0ICk7XHJcbiAqICAgICB3aW5kb3cuY29uc29sZS5sb2cob2JqZWN0KTtcclxuICogICB9XHJcbiAqICk7XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2FkZXJzQmFzZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgTG9hZGVyLlxyXG4gICAqIEBwYXJhbSB7ZG9tfSBjb250YWluZXIgLSBUaGUgZG9tIGNvbnRhaW5lciBvZiBsb2FkZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFByb2dyZXNzQmFyIC0gVGhlIHByb2dyZXNzYmFyIG9mIGxvYWRlci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIgPSBudWxsLCBQcm9ncmVzc0JhciA9IEhlbHBlcnNQcm9ncmVzc0Jhcikge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX2xvYWRlZCA9IC0xO1xyXG4gICAgdGhpcy5fdG90YWxMb2FkZWQgPSAtMTtcclxuICAgIHRoaXMuX3BhcnNlZCA9IC0xO1xyXG4gICAgdGhpcy5fdG90YWxQYXJzZWQgPSAtMTtcclxuXHJcbiAgICB0aGlzLl9kYXRhID0gW107XHJcblxyXG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy5fcHJvZ3Jlc3NCYXIgPSBudWxsO1xyXG4gICAgaWYgKHRoaXMuX2NvbnRhaW5lciAmJiBQcm9ncmVzc0Jhcikge1xyXG4gICAgICB0aGlzLl9wcm9ncmVzc0JhciA9IG5ldyBQcm9ncmVzc0Jhcih0aGlzLl9jb250YWluZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogZnJlZSB0aGUgcmVmZXJlbmNlLlxyXG4gICAqL1xyXG4gIGZyZWUoKSB7XHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xyXG4gICAgLy8gdGhpcy5faGVscGVyc1Byb2dyZXNzQmFyID0gbnVsbDtcclxuXHJcbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NCYXIpIHtcclxuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIuZnJlZSgpO1xyXG4gICAgICB0aGlzLl9wcm9ncmVzc0JhciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBsb2FkIHRoZSByZXNvdXJjZSBieSB1cmwuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHJlc291cmNlIHVybC5cclxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlLlxyXG4gICAqL1xyXG4gIGZldGNoKHVybCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCk7XHJcbiAgICAgIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSB0cnVlO1xyXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy8gZW1pdCAnZmV0Y2gtc3RhcnQnIGV2ZW50XHJcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1zdGFydCcsIHtcclxuICAgICAgICAgIGZpbGU6IHVybCxcclxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICB0aGlzLl9sb2FkZWQgPSBldmVudC5sb2FkZWQ7XHJcbiAgICAgICAgICB0aGlzLl90b3RhbExvYWRlZCA9IGV2ZW50LnRvdGFsO1xyXG5cclxuICAgICAgICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBldmVudGVyIHNldCB1cFxyXG4gICAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzQmFyLnVwZGF0ZSh0aGlzLl9sb2FkZWQsIHRoaXMuX3RvdGFsTG9hZGVkLFxyXG4gICAgICAgICAgICAgICdsb2FkJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbGV0IGJ1ZmZlciA9IHJlcXVlc3QucmVzcG9uc2U7XHJcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB7XHJcbiAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgYnVmZmVyLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBlbWl0ICdmZXRjaC1zdWNjZXNzJyBldmVudFxyXG4gICAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1zdWNjZXNzJywge1xyXG4gICAgICAgICAgICBmaWxlOiB1cmwsXHJcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIHRvdGFsTG9hZGVkOiBldmVudC50b3RhbCxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXNUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgLy8gZW1pdCAnZmV0Y2gtZXJyb3InIGV2ZW50XHJcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1lcnJvcicsIHtcclxuICAgICAgICAgIGZpbGU6IHVybCxcclxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlamVjdChyZXF1ZXN0LnN0YXR1c1RleHQpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmFib3J0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy8gZW1pdCAnZmV0Y2gtc3RhcnQnIGV2ZW50XHJcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1hYm9ydCcsIHtcclxuICAgICAgICAgIGZpbGU6IHVybCxcclxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlamVjdChyZXF1ZXN0LnN0YXR1c1RleHQpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSAoKSA9PiB7XHJcbiAgICAgICAgLy8gZW1pdCAnZmV0Y2gtdGltZW91dCcgZXZlbnRcclxuICAgICAgICB0aGlzLmVtaXQoJ2ZldGNoLXRpbWVvdXQnLCB7XHJcbiAgICAgICAgICBmaWxlOiB1cmwsXHJcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXNUZXh0KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IGV2ZW50LmxvYWRlZDtcclxuICAgICAgICB0aGlzLl90b3RhbExvYWRlZCA9IGV2ZW50LnRvdGFsO1xyXG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLXByb2dyZXNzJyBldmVudFxyXG4gICAgICAgIHRoaXMuZW1pdCgnZmV0Y2gtcHJvZ3Jlc3MnLCB7XHJcbiAgICAgICAgICBmaWxlOiB1cmwsXHJcbiAgICAgICAgICB0b3RhbDogZXZlbnQudG90YWwsXHJcbiAgICAgICAgICBsb2FkZWQ6IGV2ZW50LmxvYWRlZCxcclxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gd2lsbCBiZSByZW1vdmVkIGFmdGVyIGV2ZW50ZXIgc2V0IHVwXHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XHJcbiAgICAgICAgICB0aGlzLl9wcm9ncmVzc0Jhci51cGRhdGUodGhpcy5fbG9hZGVkLCB0aGlzLl90b3RhbExvYWRlZCxcclxuICAgICAgICAgICAgJ2xvYWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLWVuZCcgZXZlbnRcclxuICAgICAgICB0aGlzLmVtaXQoJ2ZldGNoLWVuZCcsIHtcclxuICAgICAgICAgIGZpbGU6IHVybCxcclxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8ganVzdCB1c2Ugb25sb2FkIHdoZW4gc3VjY2VzcyBhbmQgb25lcnJvciB3aGVuIGZhaWx1cmUsIGV0YyBvbmFib3J0XHJcbiAgICAgICAgLy8gcmVqZWN0KHJlcXVlc3Quc3RhdHVzVGV4dCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcGFyc2UgdGhlIGRhdGEgbG9hZGVkXHJcbiAgICogU0hPVUxEIEJFIGltcGxlbWVudGQgYnkgZGV0YWlsIGxvYWRlci5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgLSBsb2FkZWQgZGF0YS5cclxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlLlxyXG4gICAqL1xyXG4gIHBhcnNlKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogZGVmYXVsdCBsb2FkIHNlcXVlbmNlIGdyb3VwIHByb21pc2UuXHJcbiAgICogQHBhcmFtIHthcnJheX0gdXJsIC0gcmVzb3VyY2UgdXJsLlxyXG4gICAqIEByZXR1cm4ge3Byb21pc2V9IHByb21pc2UuXHJcbiAgICovXHJcbiAgbG9hZFNlcXVlbmNlR3JvdXAodXJsKSB7XHJcbiAgICBjb25zdCBmZXRjaFNlcXVlbmNlID0gW107XHJcblxyXG4gICAgdXJsLmZvckVhY2goKGZpbGUpID0+IHtcclxuICAgICAgZmV0Y2hTZXF1ZW5jZS5wdXNoKFxyXG4gICAgICAgIHRoaXMuZmV0Y2goZmlsZSlcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLmFsbChmZXRjaFNlcXVlbmNlKVxyXG4gICAgICAudGhlbigocmF3ZGF0YSkgPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKHJhd2RhdGEpO1xyXG4gICAgICB9KVxyXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChkYXRhKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdvb3BzLi4uIHNvbWV0aGluZyB3ZW50IHdyb25nLi4uJyk7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBkZWZhdWx0IGxvYWQgc2VxdWVuY2UgcHJvbWlzZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gcmVzb3VyY2UgdXJsLlxyXG4gICAqIEByZXR1cm4ge3Byb21pc2V9IHByb21pc2UuXHJcbiAgICovXHJcbiAgbG9hZFNlcXVlbmNlKHVybCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2godXJsKVxyXG4gICAgICAudGhlbigocmF3ZGF0YSkgPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKHJhd2RhdGEpO1xyXG4gICAgICB9KVxyXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChkYXRhKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdvb3BzLi4uIHNvbWV0aGluZyB3ZW50IHdyb25nLi4uJyk7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBsb2FkIHRoZSBkYXRhIGJ5IHVybCh1cmxzKVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB1cmwgLSByZXNvdXJjZSB1cmwuXHJcbiAgICogQHJldHVybiB7cHJvbWlzZX0gcHJvbWlzZVxyXG4gICAqL1xyXG4gIGxvYWQodXJsKSB7XHJcbiAgICAvLyBpZiB3ZSBsb2FkIGEgc2luZ2xlIGZpbGUsIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXlcclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh1cmwpKSB7XHJcbiAgICAgIHVybCA9IFt1cmxdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVtaXQgJ2xvYWQtc3RhcnQnIGV2ZW50XHJcbiAgICB0aGlzLmVtaXQoJ2xvYWQtc3RhcnQnLCB7XHJcbiAgICAgIGZpbGVzOiB1cmwsXHJcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBsb2FkU2VxdWVuY2VzID0gW107XHJcbiAgICB1cmwuZm9yRWFjaCgoZmlsZSkgPT4ge1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZSkpIHtcclxuICAgICAgICBsb2FkU2VxdWVuY2VzLnB1c2goXHJcbiAgICAgICAgICB0aGlzLmxvYWRTZXF1ZW5jZShmaWxlKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9hZFNlcXVlbmNlcy5wdXNoKFxyXG4gICAgICAgICAgdGhpcy5sb2FkU2VxdWVuY2VHcm91cChmaWxlKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRTZXF1ZW5jZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGRhdGFcclxuICAgKiBAcGFyYW0ge2FycmF5fSBkYXRhXHJcbiAgICovXHJcbiAgc2V0IGRhdGEoZGF0YSkge1xyXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgZGF0YVxyXG4gICAqIEByZXR1cm4ge2FycmF5fSBkYXRhIGxvYWRlZFxyXG4gICAqL1xyXG4gIGdldCBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgVm9sdW1lIGZyb20gJy4vbG9hZGVycy52b2x1bWUnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgbG9hZGVyc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBWb2x1bWUsXHJcbn07XHJcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xyXG5jb25zdCBQQUtPID0gcmVxdWlyZSgncGFrbycpO1xyXG5cclxuaW1wb3J0IExvYWRlcnNCYXNlIGZyb20gJy4vbG9hZGVycy5iYXNlJztcclxuaW1wb3J0IENvcmVVdGlscyBmcm9tICcuLi9jb3JlL2NvcmUudXRpbHMnO1xyXG5pbXBvcnQgTW9kZWxzU2VyaWVzIGZyb20gJy4uL21vZGVscy9tb2RlbHMuc2VyaWVzJztcclxuaW1wb3J0IE1vZGVsc1N0YWNrIGZyb20gJy4uL21vZGVscy9tb2RlbHMuc3RhY2snO1xyXG5pbXBvcnQgTW9kZWxzRnJhbWUgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5mcmFtZSc7XHJcbmltcG9ydCBQYXJzZXJzRGljb20gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZXJzLmRpY29tJztcclxuaW1wb3J0IFBhcnNlcnNNaGQgZnJvbSAnLi4vcGFyc2Vycy9wYXJzZXJzLm1oZCc7XHJcbmltcG9ydCBQYXJzZXJzTmlmdGkgZnJvbSAnLi4vcGFyc2Vycy9wYXJzZXJzLm5pZnRpJztcclxuaW1wb3J0IFBhcnNlcnNOcnJkIGZyb20gJy4uL3BhcnNlcnMvcGFyc2Vycy5ucnJkJztcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBJdCBpcyB0eXBpY2FsbHkgdXNlZCB0byBsb2FkIGEgRElDT00gaW1hZ2UuIFVzZSBsb2FkaW5nIG1hbmFnZXIgZm9yXHJcbiAqIGFkdmFuY2VkIHVzYWdlLCBzdWNoIGFzIG11bHRpcGxlIGZpbGVzIGhhbmRsaW5nLlxyXG4gKlxyXG4gKiBEZW1vOiB7QGxpbmsgaHR0cHM6Ly9mbm5kc2MuZ2l0aHViLmlvL3ZqcyNsb2FkZXJfZGljb219XHJcbiAqXHJcbiAqIEBtb2R1bGUgbG9hZGVycy92b2x1bWVzXHJcbiAqIEBleHRlbmRzIExvYWRlcnNCYXNlXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBmaWxlcyA9IFsnL2RhdGEvZGNtL2ZydWl0J107XHJcbiAqXHJcbiAqIC8vIEluc3RhbnRpYXRlIGEgZGljb20gbG9hZGVyXHJcbiAqIHZhciBsRGljb21vYWRlciA9IG5ldyBkaWNvbSgpO1xyXG4gKlxyXG4gKiAvLyBsb2FkIGEgcmVzb3VyY2VcclxuICogbG9hZGVyLmxvYWQoXHJcbiAqICAgLy8gcmVzb3VyY2UgVVJMXHJcbiAqICAgZmlsZXNbMF0sXHJcbiAqICAgLy8gRnVuY3Rpb24gd2hlbiByZXNvdXJjZSBpcyBsb2FkZWRcclxuICogICBmdW5jdGlvbihvYmplY3QpIHtcclxuICogICAgIC8vc2NlbmUuYWRkKCBvYmplY3QgKTtcclxuICogICAgIHdpbmRvdy5jb25zb2xlLmxvZyhvYmplY3QpO1xyXG4gKiAgIH1cclxuICogKTtcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRlcnNWb2x1bWVzIGV4dGVuZHMgTG9hZGVyc0Jhc2Uge1xyXG5cclxuICAvKipcclxuICAgKiBQYXJzZSByZXNwb25zZS5cclxuICAgKiByZXNwb25zZSBpcyBmb3JtYXRlZCBhczpcclxuICAgKiAgICB7XHJcbiAgICogICAgICB1cmw6ICdyZXNvdXJjZSB1cmwnLFxyXG4gICAqICAgICAgYnVmZmVyOiB4bWxyZXNwb25zZSxcclxuICAgKiAgICB9XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIC0gcmVzcG9uc2VcclxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlXHJcbiAgICovXHJcbiAgcGFyc2UocmVzcG9uc2UpIHtcclxuICAgIC8vIGVtaXQgJ3BhcnNlLXN0YXJ0JyBldmVudFxyXG4gICAgdGhpcy5lbWl0KCdwYXJzZS1zdGFydCcsIHtcclxuICAgICAgZmlsZTogcmVzcG9uc2UudXJsLFxyXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgfSk7XHJcbiAgICAvLyBnaXZlIGEgY2hhbmNlIHRvIHRoZSBVSSB0byB1cGRhdGUgYmVjYXVzZVxyXG4gICAgLy8gYWZ0ZXIgdGhlIHJlbmRlcmluZyB3aWxsIGJlIGJsb2NrZWQgd2l0aCBpbnRlbnNpdmUgSlNcclxuICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBldmVudGVyIHNldCB1cFxyXG4gICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XHJcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyLnVwZGF0ZSgwLCAxMDAsICdwYXJzZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShcclxuICAgICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KFxyXG4gICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICBsZXQgZGF0YSA9IHJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkYXRhLmZvckVhY2goKGRhdGFzZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXByb2Nlc3MoZGF0YXNldCk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbMF07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHJhdy9taGQgcGFpclxyXG4gICAgICAgICAgICAgICAgbGV0IG1oZEZpbGUgPVxyXG4gICAgICAgICAgICAgICAgICBkYXRhLmZpbHRlcih0aGlzLl9maWx0ZXJCeUV4dGVuc2lvbi5iaW5kKG51bGwsICdNSEQnKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmF3RmlsZSA9XHJcbiAgICAgICAgICAgICAgICAgIGRhdGEuZmlsdGVyKHRoaXMuX2ZpbHRlckJ5RXh0ZW5zaW9uLmJpbmQobnVsbCwgJ1JBVycpKTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG1oZEZpbGUubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcmF3RmlsZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgZGF0YS51cmwgPSBtaGRGaWxlWzBdLnVybDtcclxuICAgICAgICAgICAgICAgICAgZGF0YS5leHRlbnNpb24gPSBtaGRGaWxlWzBdLmV4dGVuc2lvbjtcclxuICAgICAgICAgICAgICAgICAgZGF0YS5taGRCdWZmZXIgPSBtaGRGaWxlWzBdLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgZGF0YS5yYXdCdWZmZXIgPSByYXdGaWxlWzBdLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGxldCBQYXJzZXIgPSB0aGlzLl9wYXJzZXIoZGF0YS5leHRlbnNpb24pO1xyXG4gICAgICAgICAgICAgIGlmICghUGFyc2VyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbWl0ICdwYXJzZS1lcnJvcicgZXZlbnRcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGFyc2UtZXJyb3InLCB7XHJcbiAgICAgICAgICAgICAgICAgIGZpbGU6IHJlc3BvbnNlLnVybCxcclxuICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGRhdGEuZmlsZW5hbWUgKyAnY2FuIG5vdCBiZSBwYXJzZWQuJyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGRhdGEuZmlsZW5hbWUgKyAnIGNhbiBub3QgYmUgcGFyc2VkLicpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gY2hlY2sgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgbGV0IHZvbHVtZVBhcnNlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZvbHVtZVBhcnNlciA9IG5ldyBQYXJzZXIoZGF0YSwgMCk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gZW1pdCAncGFyc2UtZXJyb3InIGV2ZW50XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BhcnNlLWVycm9yJywge1xyXG4gICAgICAgICAgICAgICAgICBmaWxlOiByZXNwb25zZS51cmwsXHJcbiAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBzZXJpZXNcclxuICAgICAgICAgICAgICBsZXQgc2VyaWVzID0gbmV3IE1vZGVsc1NlcmllcygpO1xyXG4gICAgICAgICAgICAgIC8vIGdsb2JhbCBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgIHNlcmllcy5zZXJpZXNJbnN0YW5jZVVJRCA9IHZvbHVtZVBhcnNlci5zZXJpZXNJbnN0YW5jZVVJRCgpO1xyXG4gICAgICAgICAgICAgIHNlcmllcy50cmFuc2ZlclN5bnRheFVJRCA9IHZvbHVtZVBhcnNlci50cmFuc2ZlclN5bnRheFVJRCgpO1xyXG4gICAgICAgICAgICAgIHNlcmllcy5zZXJpZXNEZXNjcmlwdGlvbiA9IHZvbHVtZVBhcnNlci5zZXJpZXNEZXNjcmlwdGlvbigpO1xyXG4gICAgICAgICAgICAgIHNlcmllcy5zdHVkeURlc2NyaXB0aW9uID0gdm9sdW1lUGFyc2VyLnN0dWR5RGVzY3JpcHRpb24oKTtcclxuICAgICAgICAgICAgICBzZXJpZXMubnVtYmVyT2ZGcmFtZXMgPSB2b2x1bWVQYXJzZXIubnVtYmVyT2ZGcmFtZXMoKTtcclxuICAgICAgICAgICAgICBpZiAoIXNlcmllcy5udW1iZXJPZkZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgc2VyaWVzLm51bWJlck9mRnJhbWVzID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgc2VyaWVzLm51bWJlck9mQ2hhbm5lbHMgPSB2b2x1bWVQYXJzZXIubnVtYmVyT2ZDaGFubmVscygpO1xyXG4gICAgICAgICAgICAgIHNlcmllcy5tb2RhbGl0eSA9IHZvbHVtZVBhcnNlci5tb2RhbGl0eSgpO1xyXG4gICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgc2VnbWVudGF0aW9uLCBhdHRhY2ggZXh0cmEgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICBpZiAoc2VyaWVzLm1vZGFsaXR5ID09PSAnU0VHJykge1xyXG4gICAgICAgICAgICAgICAgLy8gY29sb3JzXHJcbiAgICAgICAgICAgICAgICAvLyBsYWJlbHNcclxuICAgICAgICAgICAgICAgIC8vIGV0Yy5cclxuICAgICAgICAgICAgICAgIHNlcmllcy5zZWdtZW50YXRpb25UeXBlID0gdm9sdW1lUGFyc2VyLnNlZ21lbnRhdGlvblR5cGUoKTtcclxuICAgICAgICAgICAgICAgIHNlcmllcy5zZWdtZW50YXRpb25TZWdtZW50cyA9XHJcbiAgICAgICAgICAgICAgICAgIHZvbHVtZVBhcnNlci5zZWdtZW50YXRpb25TZWdtZW50cygpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAvLyBwYXRpZW50IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgc2VyaWVzLnBhdGllbnRJRCA9IHZvbHVtZVBhcnNlci5wYXRpZW50SUQoKTtcclxuICAgICAgICAgICAgICBzZXJpZXMucGF0aWVudE5hbWUgPSB2b2x1bWVQYXJzZXIucGF0aWVudE5hbWUoKTtcclxuICAgICAgICAgICAgICBzZXJpZXMucGF0aWVudEFnZSA9IHZvbHVtZVBhcnNlci5wYXRpZW50QWdlKCk7XHJcbiAgICAgICAgICAgICAgc2VyaWVzLnBhdGllbnRCaXJ0aGRhdGUgPSB2b2x1bWVQYXJzZXIucGF0aWVudEJpcnRoZGF0ZSgpO1xyXG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50U2V4ID0gdm9sdW1lUGFyc2VyLnBhdGllbnRTZXgoKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8ganVzdCBjcmVhdGUgMSBkdW1teSBzdGFjayBmb3Igbm93XHJcbiAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3IE1vZGVsc1N0YWNrKCk7XHJcbiAgICAgICAgICAgICAgc3RhY2subnVtYmVyT2ZDaGFubmVscyA9IHZvbHVtZVBhcnNlci5udW1iZXJPZkNoYW5uZWxzKCk7XHJcbiAgICAgICAgICAgICAgc3RhY2sucGl4ZWxSZXByZXNlbnRhdGlvbiA9XHJcbiAgICAgICAgICAgICAgICB2b2x1bWVQYXJzZXIucGl4ZWxSZXByZXNlbnRhdGlvbigpO1xyXG4gICAgICAgICAgICAgIHN0YWNrLnBpeGVsVHlwZSA9IHZvbHVtZVBhcnNlci5waXhlbFR5cGUoKTtcclxuICAgICAgICAgICAgICBzdGFjay5pbnZlcnQgPSB2b2x1bWVQYXJzZXIuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgICAgc3RhY2suc3BhY2luZ0JldHdlZW5TbGljZXMgPVxyXG4gICAgICAgICAgICAgICAgdm9sdW1lUGFyc2VyLnNwYWNpbmdCZXR3ZWVuU2xpY2VzKCk7XHJcbiAgICAgICAgICAgICAgc3RhY2subW9kYWxpdHkgPSBzZXJpZXMubW9kYWxpdHk7XHJcbiAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgYSBzZWdtZW50YXRpb24sIGF0dGFjaCBleHRyYSBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgIGlmIChzdGFjay5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbG9yc1xyXG4gICAgICAgICAgICAgICAgLy8gbGFiZWxzXHJcbiAgICAgICAgICAgICAgICAvLyBldGMuXHJcbiAgICAgICAgICAgICAgICBzdGFjay5zZWdtZW50YXRpb25UeXBlID0gc2VyaWVzLnNlZ21lbnRhdGlvblR5cGU7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5zZWdtZW50YXRpb25TZWdtZW50cyA9IHNlcmllcy5zZWdtZW50YXRpb25TZWdtZW50cztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgc2VyaWVzLnN0YWNrLnB1c2goc3RhY2spO1xyXG4gICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZSBjYWxsIGZvciBlYWNoIGZyYW1lXHJcbiAgICAgICAgICAgICAgLy8gYmV0dGVyIHRoYW4gZm9yIGxvb3AgdG8gYmUgYWJsZVxyXG4gICAgICAgICAgICAgIC8vIHRvIHVwZGF0ZSBkb20gd2l0aCBcInByb2dyZXNzXCIgY2FsbGJhY2tcclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUZyYW1lKFxyXG4gICAgICAgICAgICAgICAgICBzZXJpZXMsIHN0YWNrLCByZXNwb25zZS51cmwsIDAsXHJcbiAgICAgICAgICAgICAgICAgIHZvbHVtZVBhcnNlciwgcmVzb2x2ZSwgcmVqZWN0KSwgMCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIH0sIDEwKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHJlY3Vyc2l2ZSBwYXJzZSBmcmFtZVxyXG4gICAqIEBwYXJhbSB7TW9kZWxzU2VyaWVzfSBzZXJpZXMgLSBkYXRhIHNlcmllc1xyXG4gICAqIEBwYXJhbSB7TW9kZWxzU3RhY2t9IHN0YWNrIC0gZGF0YSBzdGFja1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSByZXNvdXJjZSB1cmxcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaSAtIGZyYW1lIGluZGV4XHJcbiAgICogQHBhcmFtIHtwYXJzZXJ9IGRhdGFQYXJzZXIgLSBzZWxlY3RlZCBwYXJzZXJcclxuICAgKiBAcGFyYW0ge3Byb21pc2UucmVzb2x2ZX0gcmVzb2x2ZSAtIHByb21pc2UgcmVzb2x2ZSBhcmdzXHJcbiAgICogQHBhcmFtIHtwcm9taXNlLnJlamVjdH0gcmVqZWN0IC0gcHJvbWlzZSByZWplY3QgYXJnc1xyXG4gICAqL1xyXG4gIHBhcnNlRnJhbWUoc2VyaWVzLCBzdGFjaywgdXJsLCBpLCBkYXRhUGFyc2VyLCByZXNvbHZlLCByZWplY3QpIHtcclxuICAgIGxldCBmcmFtZSA9IG5ldyBNb2RlbHNGcmFtZSgpO1xyXG4gICAgZnJhbWUuc29wSW5zdGFuY2VVSUQgPSBkYXRhUGFyc2VyLnNvcEluc3RhbmNlVUlEKGkpO1xyXG4gICAgZnJhbWUudXJsID0gdXJsO1xyXG4gICAgZnJhbWUuaW5kZXggPSBpO1xyXG4gICAgZnJhbWUucm93cyA9IGRhdGFQYXJzZXIucm93cyhpKTtcclxuICAgIGZyYW1lLmNvbHVtbnMgPSBkYXRhUGFyc2VyLmNvbHVtbnMoaSk7XHJcbiAgICBmcmFtZS5udW1iZXJPZkNoYW5uZWxzID0gc3RhY2subnVtYmVyT2ZDaGFubmVscztcclxuICAgIGZyYW1lLnBpeGVsUmVwcmVzZW50YXRpb24gPSBzdGFjay5waXhlbFJlcHJlc2VudGF0aW9uO1xyXG4gICAgZnJhbWUucGl4ZWxUeXBlID0gc3RhY2sucGl4ZWxUeXBlO1xyXG4gICAgZnJhbWUucGl4ZWxEYXRhID0gZGF0YVBhcnNlci5leHRyYWN0UGl4ZWxEYXRhKGkpO1xyXG4gICAgZnJhbWUucGl4ZWxTcGFjaW5nID0gZGF0YVBhcnNlci5waXhlbFNwYWNpbmcoaSk7XHJcbiAgICBmcmFtZS5zcGFjaW5nQmV0d2VlblNsaWNlcyA9IGRhdGFQYXJzZXIuc3BhY2luZ0JldHdlZW5TbGljZXMoaSk7XHJcbiAgICBmcmFtZS5zbGljZVRoaWNrbmVzcyA9IGRhdGFQYXJzZXIuc2xpY2VUaGlja25lc3MoaSk7XHJcbiAgICBmcmFtZS5pbWFnZU9yaWVudGF0aW9uID0gZGF0YVBhcnNlci5pbWFnZU9yaWVudGF0aW9uKGkpO1xyXG4gICAgZnJhbWUucmlnaHRIYW5kZWQgPSBkYXRhUGFyc2VyLnJpZ2h0SGFuZGVkKCk7XHJcbiAgICBzdGFjay5yaWdodEhhbmRlZCA9IGZyYW1lLnJpZ2h0SGFuZGVkO1xyXG4gICAgaWYgKGZyYW1lLmltYWdlT3JpZW50YXRpb24gPT09IG51bGwpIHtcclxuICAgICAgZnJhbWUuaW1hZ2VPcmllbnRhdGlvbiA9IFsxLCAwLCAwLCAwLCAxLCAwXTtcclxuICAgIH1cclxuICAgIGZyYW1lLmltYWdlUG9zaXRpb24gPSBkYXRhUGFyc2VyLmltYWdlUG9zaXRpb24oaSk7XHJcbiAgICBpZiAoZnJhbWUuaW1hZ2VQb3NpdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICBmcmFtZS5pbWFnZVBvc2l0aW9uID0gWzAsIDAsIGldO1xyXG4gICAgfVxyXG4gICAgZnJhbWUuZGltZW5zaW9uSW5kZXhWYWx1ZXMgPSBkYXRhUGFyc2VyLmRpbWVuc2lvbkluZGV4VmFsdWVzKGkpO1xyXG4gICAgZnJhbWUuYml0c0FsbG9jYXRlZCA9IGRhdGFQYXJzZXIuYml0c0FsbG9jYXRlZChpKTtcclxuICAgIGZyYW1lLmluc3RhbmNlTnVtYmVyID0gZGF0YVBhcnNlci5pbnN0YW5jZU51bWJlcihpKTtcclxuICAgIGZyYW1lLndpbmRvd0NlbnRlciA9IGRhdGFQYXJzZXIud2luZG93Q2VudGVyKGkpO1xyXG4gICAgZnJhbWUud2luZG93V2lkdGggPSBkYXRhUGFyc2VyLndpbmRvd1dpZHRoKGkpO1xyXG4gICAgZnJhbWUucmVzY2FsZVNsb3BlID0gZGF0YVBhcnNlci5yZXNjYWxlU2xvcGUoaSk7XHJcbiAgICBmcmFtZS5yZXNjYWxlSW50ZXJjZXB0ID0gZGF0YVBhcnNlci5yZXNjYWxlSW50ZXJjZXB0KGkpO1xyXG4gICAgLy8gc2hvdWxkIHBhc3MgZnJhbWUgaW5kZXggZm9yIGNvbnNpc3RlbmN5Li4uXHJcbiAgICBmcmFtZS5taW5NYXggPSBkYXRhUGFyc2VyLm1pbk1heFBpeGVsRGF0YShmcmFtZS5waXhlbERhdGEpO1xyXG5cclxuICAgIC8vIGlmIHNlcmllcy5tb1xyXG4gICAgaWYgKHNlcmllcy5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcclxuICAgICAgZnJhbWUucmVmZXJlbmNlZFNlZ21lbnROdW1iZXIgPSBkYXRhUGFyc2VyLnJlZmVyZW5jZWRTZWdtZW50TnVtYmVyKGkpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YWNrLmZyYW1lLnB1c2goZnJhbWUpO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBzdGF0dXNcclxuICAgIHRoaXMuX3BhcnNlZCA9IGkgKyAxO1xyXG4gICAgdGhpcy5fdG90YWxQYXJzZWQgPSBzZXJpZXMubnVtYmVyT2ZGcmFtZXM7XHJcblxyXG4gICAgLy8gd2lsbCBiZSByZW1vdmVkIGFmdGVyIGV2ZW50ZXIgc2V0IHVwXHJcbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NCYXIpIHtcclxuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIudXBkYXRlKHRoaXMuX3BhcnNlZCwgdGhpcy5fdG90YWxQYXJzZWQsICdwYXJzZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVtaXQgJ3BhcnNpbmcnIGV2ZW50XHJcbiAgICB0aGlzLmVtaXQoJ3BhcnNpbmcnLCB7XHJcbiAgICAgIGZpbGU6IHVybCxcclxuICAgICAgdG90YWw6IHRoaXMuX3RvdGFsUGFyc2VkLFxyXG4gICAgICBwYXJzZWQ6IHRoaXMuX3BhcnNlZCxcclxuICAgICAgdGltZTogbmV3IERhdGUoKSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl9wYXJzZWQgPT09IHRoaXMuX3RvdGFsUGFyc2VkKSB7XHJcbiAgICAgIC8vIGVtaXQgJ3BhcnNlLXN1Y2Nlc3MnIGV2ZW50XHJcbiAgICAgIHRoaXMuZW1pdCgncGFyc2Utc3VjY2VzcycsIHtcclxuICAgICAgICBmaWxlOiB1cmwsXHJcbiAgICAgICAgdG90YWw6IHRoaXMuX3RvdGFsUGFyc2VkLFxyXG4gICAgICAgIHBhcnNlZDogdGhpcy5fcGFyc2VkLFxyXG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmVzb2x2ZShzZXJpZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0VGltZW91dChcclxuICAgICAgICB0aGlzLnBhcnNlRnJhbWUoXHJcbiAgICAgICAgICBzZXJpZXMsIHN0YWNrLCB1cmwsIHRoaXMuX3BhcnNlZCwgZGF0YVBhcnNlciwgcmVzb2x2ZSwgcmVqZWN0KSwgMFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHBhcnNlciBnaXZlbiBhbiBleHRlbnNpb25cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXh0ZW5zaW9uIC0gZXh0ZW5zaW9uXHJcbiAgICogQHJldHVybiB7cGFyc2VyfSBzZWxlY3RlZCBwYXJzZXJcclxuICAgKi9cclxuICBfcGFyc2VyKGV4dGVuc2lvbikge1xyXG4gICAgbGV0IFBhcnNlciA9IG51bGw7XHJcblxyXG4gICAgc3dpdGNoIChleHRlbnNpb24udG9VcHBlckNhc2UoKSkge1xyXG4gICAgICBjYXNlICdOSUknOlxyXG4gICAgICBjYXNlICdOSUlfJzpcclxuICAgICAgICBQYXJzZXIgPSBQYXJzZXJzTmlmdGk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0RDTSc6XHJcbiAgICAgIGNhc2UgJ0RJQ09NJzpcclxuICAgICAgY2FzZSAnSU1BJzpcclxuICAgICAgY2FzZSAnJzpcclxuICAgICAgICBQYXJzZXIgPSBQYXJzZXJzRGljb207XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ01IRCc6XHJcbiAgICAgICAgUGFyc2VyID0gUGFyc2Vyc01oZDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnTlJSRCc6XHJcbiAgICAgICAgUGFyc2VyID0gUGFyc2Vyc05ycmQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCd1bnN1cHBvcnRlZCBleHRlbnNpb246ICcgKyBleHRlbnNpb24pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBQYXJzZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlLXByb2Nlc3MgZGF0YSB0byBiZSBwYXJzZWQgKGZpbmQgZGF0YSB0eXBlIGFuZCBkZS1jb21wcmVzcylcclxuICAgKiBAcGFyYW0geyp9IGRhdGFcclxuICAgKi9cclxuICBfcHJlcHJvY2VzcyhkYXRhKSB7XHJcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBDb3JlVXRpbHMucGFyc2VVcmwoZGF0YS51cmwpO1xyXG4gICAgLy8gdXBkYXRlIGRhdGFcclxuICAgIGRhdGEuZmlsZW5hbWUgPSBwYXJzZWRVcmwuZmlsZW5hbWU7XHJcbiAgICBkYXRhLmV4dGVuc2lvbiA9IHBhcnNlZFVybC5leHRlbnNpb247XHJcbiAgICBkYXRhLnBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xyXG4gICAgZGF0YS5xdWVyeSA9IHBhcnNlZFVybC5xdWVyeTtcclxuXHJcbiAgICAvLyB1bnppcCBpZiBleHRlbnNpb24gaXMgJy5neidcclxuICAgIGlmIChkYXRhLmV4dGVuc2lvbiA9PT0gJ2d6Jykge1xyXG4gICAgICBkYXRhLmd6Y29tcHJlc3NlZCA9IHRydWU7XHJcbiAgICAgIGRhdGEuZXh0ZW5zaW9uID1cclxuICAgICAgICBkYXRhLmZpbGVuYW1lLnNwbGl0KCcuZ3onKS5zaGlmdCgpLnNwbGl0KCcuJykucG9wKCk7XHJcbiAgICAgIGxldCBkZWNvbXByZXNzZWREYXRhID0gUEFLTy5pbmZsYXRlKGRhdGEuYnVmZmVyKTtcclxuICAgICAgZGF0YS5idWZmZXIgPSBkZWNvbXByZXNzZWREYXRhLmJ1ZmZlcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRhdGEuZ3pjb21wcmVzc2VkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaWx0ZXIgZGF0YSBieSBleHRlbnNpb25cclxuICAgKiBAcGFyYW0geyp9IGV4dGVuc2lvblxyXG4gICAqIEBwYXJhbSB7Kn0gaXRlbVxyXG4gICAqIEByZXR1cm5zIEJvb2xlYW5cclxuICAgKi9cclxuICBfZmlsdGVyQnlFeHRlbnNpb24oZXh0ZW5zaW9uLCBpdGVtKSB7XHJcbiAgICBpZiAoaXRlbS5leHRlbnNpb24udG9VcHBlckNhc2UoKSA9PT0gZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBCYXNlIG9iamVjdC5cclxuICpcclxuICogQG1vZHVsZSBtb2RlbHMvYmFzZVxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc0Jhc2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5faWQgPSAtMTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogTWVyZ2UgMiBhcnJheXMgb2YgbW9kZWxzLlxyXG4gICAqIE1lcmdlIHRoZSB0YXJnZXQgYXJyYXkgaW50byB0aGUgcmVmZXJlbmNlIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48TW9kZWxzPn0gcmVmZXJlbmNlQXJyYXkgLSBBcnJheSB0byBiZSBtZXJnZSBhZ2FpbnN0XHJcbiAgICogQHBhcmFtIHtBcnJheS48TW9kZWxzPn0gdGFyZ2V0QXJyYXkgLSBBcnJheSB0byBiZSBtZXJnZWQgYWdhaW5zdCByZWZlcmVuY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1lcmdlIHdhcyBzdWNlc3NmdWwuIEZhbHNlIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxyXG4gICAqL1xyXG4gIG1lcmdlTW9kZWxzKHJlZmVyZW5jZUFycmF5LCB0YXJnZXRBcnJheSkge1xyXG4gICAgaWYgKCEodGhpcy5fdmFsaWRhdGVNb2RlbEFycmF5KHJlZmVyZW5jZUFycmF5KSAmJlxyXG4gICAgICB0aGlzLl92YWxpZGF0ZU1vZGVsQXJyYXkodGFyZ2V0QXJyYXkpKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2ludmFsaWQgaW5wdXRzIHByb3ZpZGVkLicpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAvLyB0ZXN0IHRhcmdldEFycmF5IGFnYWluc3QgZXhpc3RpbmcgdGFyZ2V0QXJyYXlcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWZlcmVuY2VBcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChyZWZlcmVuY2VBcnJheVtqXS5tZXJnZSh0YXJnZXRBcnJheVtpXSkpIHtcclxuICAgICAgICAgIC8vIG1lcmdlZCBzdWNjZXNzZnVsbHlcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaiA9PT0gcmVmZXJlbmNlQXJyYXkubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgLy8gbGFzdCBtZXJnZSB3YXMgbm90IHN1Y2Nlc3NmdWxcclxuICAgICAgICAgIC8vIHRoaXMgaXMgYSBuZXcgdGFyZ2V0QXJyYXlcclxuICAgICAgICAgIHJlZmVyZW5jZUFycmF5LnB1c2godGFyZ2V0QXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWVyZ2UgbW9kZWwgYWdhaW5zdCBjdXJyZW50IG1vZGVsLlxyXG4gICAqL1xyXG4gIG1lcmdlKG1vZGVsKSB7XHJcbiAgICAvLyBtYWtlIHN1cmUgbW9kZWwgaXMgdmFsaWRcclxuICAgIGlmKCEodGhpcy52YWxpZGF0ZShtb2RlbCkpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGV5IGNhbiBiZSBtZXJnZWQgaWYgdGhleSBtYXRjaFxyXG4gICAgaWYodGhpcy5faWQgPT09IG1vZGVsLl9pZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIGEgbW9kZWwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vZGVsIGlzIHZhbGlkLiBGYWxzZSBpZiBub3QuXHJcbiAgICovXHJcbiAgdmFsaWRhdGUobW9kZWwpIHtcclxuICAgIGlmICghKG1vZGVsICYmXHJcbiAgICAgIG1vZGVsICE9PSBudWxsICYmXHJcbiAgICAgIHR5cGVvZiBtb2RlbC5tZXJnZSA9PT0gJ2Z1bmN0aW9uJykpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGUgYXJyYXkgb2YgbW9kZWxzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48TW9kZWxzPn0gbW9kZWxBcnJheSAtIEFycmF5IGNvbnRhaW5pbmcgbW9kZWxzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhcnJheSBpcyB2YWxpZC4gRmFsc2UgaWYgbm90LlxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZU1vZGVsQXJyYXkobW9kZWxBcnJheSkge1xyXG4gICAgaWYgKCEobW9kZWxBcnJheSAhPT0gbnVsbCAmJiBBcnJheSA9PT0gbW9kZWxBcnJheS5jb25zdHJ1Y3RvcikpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdpbnZhbGlkIG1vZGVsIGFycmF5IHByb3ZpZGVkLicpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbEFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICghKG1vZGVsQXJyYXlbaV0gJiZcclxuICAgICAgICBtb2RlbEFycmF5W2ldICE9PSBudWxsICYmXHJcbiAgICAgICAgdHlwZW9mIG1vZGVsQXJyYXlbaV0udmFsaWRhdGUgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICBtb2RlbEFycmF5W2ldLnZhbGlkYXRlKG1vZGVsQXJyYXlbaV0pKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxufVxyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IE1vZGVsc0Jhc2UgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5iYXNlJztcclxuXHJcbi8qKlxyXG4gKiBGcmFtZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBtb2R1bGUgbW9kZWxzL2ZyYW1lXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbHNGcmFtZSBleHRlbmRzIE1vZGVsc0Jhc2Uge1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9zb3BJbnN0YW5jZVVJRCA9IG51bGw7XHJcbiAgICB0aGlzLl91cmwgPSBudWxsO1xyXG4gICAgdGhpcy5fc3RhY2tJRCA9IC0xO1xyXG4gICAgdGhpcy5fcm93cyA9IDA7XHJcbiAgICB0aGlzLl9jb2x1bW5zID0gMDtcclxuICAgIHRoaXMuX2RpbWVuc2lvbkluZGV4VmFsdWVzID0gW107XHJcbiAgICB0aGlzLl9pbWFnZVBvc2l0aW9uID0gbnVsbDtcclxuICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb24gPSBudWxsO1xyXG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fc2xpY2VUaGlja25lc3MgPSAxO1xyXG4gICAgdGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXMgPSBudWxsO1xyXG4gICAgdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbiA9IDA7XHJcbiAgICB0aGlzLl9waXhlbFR5cGUgPSAwO1xyXG4gICAgdGhpcy5fcGl4ZWxTcGFjaW5nID0gbnVsbDtcclxuICAgIHRoaXMuX3BpeGVsQXNwZWN0UmF0aW8gPSBudWxsO1xyXG4gICAgdGhpcy5fcGl4ZWxEYXRhID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9pbnN0YW5jZU51bWJlciA9IG51bGw7XHJcbiAgICB0aGlzLl93aW5kb3dDZW50ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fd2luZG93V2lkdGggPSBudWxsO1xyXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gbnVsbDtcclxuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSA4O1xyXG5cclxuICAgIHRoaXMuX21pbk1heCA9IG51bGw7XHJcbiAgICB0aGlzLl9kaXN0ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9pbmRleCA9IC0xO1xyXG5cclxuICAgIHRoaXMuX3JlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gLTE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWYWxpZGF0ZSB0aGUgZnJhbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IG1vZGVsXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHZhbGlkYXRlKG1vZGVsKSB7XHJcbiAgICBpZiAoIShzdXBlci52YWxpZGF0ZShtb2RlbCkgJiZcclxuICAgICAgdHlwZW9mIG1vZGVsLmNvc2luZXMgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgdHlwZW9mIG1vZGVsLnNwYWNpbmdYWSA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX3NvcEluc3RhbmNlVUlEJykgJiZcclxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19kaW1lbnNpb25JbmRleFZhbHVlcycpICYmXHJcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfaW1hZ2VPcmllbnRhdGlvbicpICYmXHJcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfaW1hZ2VQb3NpdGlvbicpKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNZXJnZSBjdXJyZW50IGZyYW1lIHdpdGggcHJvdmlkZWQgZnJhbWUuXHJcbiAgICpcclxuICAgKiBGcmFtZXMgY2FuIGJlIG1lcmdlZCAoaS5lLiBhcmUgaWRlbnRpY2FsKSBpZiBmb2xsb3dpbmcgYXJlIGVxdWFsczpcclxuICAgKiAgLSBkaW1lbnNpb25JbmRleFZhbHVlc1xyXG4gICAqICAtIGltYWdlT3JpZW50YXRpb25cclxuICAgKiAgLSBpbWFnZVBvc2l0aW9uXHJcbiAgICogIC0gaW5zdGFuY2VOdW1iZXJcclxuICAgKiAgLSBzb3BJbnN0YW5jZVVJRFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBmcmFtZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBmcmFtZXMgY291bGQgYmUgbWVyZ2UuIEZhbHNlIGlmIG5vdC5cclxuICAgKi9cclxuICBtZXJnZShmcmFtZSkge1xyXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlKGZyYW1lKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2NvbXBhcmVBcnJheXMoXHJcbiAgICAgICAgICB0aGlzLl9kaW1lbnNpb25JbmRleFZhbHVlcywgZnJhbWUuZGltZW5zaW9uSW5kZXhWYWx1ZXMpICYmXHJcbiAgICAgICAgdGhpcy5fY29tcGFyZUFycmF5cyhcclxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb24sIGZyYW1lLmltYWdlT3JpZW50YXRpb24pICYmXHJcbiAgICAgICAgdGhpcy5fY29tcGFyZUFycmF5cyhcclxuICAgICAgICAgIHRoaXMuX2ltYWdlUG9zaXRpb24sIGZyYW1lLmltYWdlUG9zaXRpb24pICYmXHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2VOdW1iZXIgPT09IGZyYW1lLmluc3RhbmNlTnVtYmVyICYmXHJcbiAgICAgICAgdGhpcy5fc29wSW5zdGFuY2VVSUQgPT09IGZyYW1lLnNvcEluc3RhbmNlVUlEKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgWCwgeSBhbmQgWiBjb3NpbmVzIGZyb20gaW1hZ2Ugb3JpZW50YXRpb25cclxuICAgKiBSZXR1cm5zIGRlZmF1bHQgb3JpZW50YXRpb24gaWYgX2ltYWdlT3JpZW50YXRpb24gd2FzIGludmFsaWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7YXJyYXl9IEFycmF5WzNdIGNvbnRhaW5pbmcgY29zaW5lc1gsIFkgYW5kIFouXHJcbiAgICovXHJcbiAgY29zaW5lcygpIHtcclxuICAgIGxldCBjb3NpbmVzID0gW25ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApLFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSldO1xyXG5cclxuICAgICBpZiAodGhpcy5faW1hZ2VPcmllbnRhdGlvbiAmJlxyXG4gICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uLmxlbmd0aCA9PT0gNikge1xyXG4gICAgICBsZXQgeENvcyA9XHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uWzBdLFxyXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvblsxXSxcclxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb25bMl0pO1xyXG4gICAgICBsZXQgeUNvcyA9XHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uWzNdLFxyXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbls0XSxcclxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb25bNV0pO1xyXG5cclxuICAgICAgaWYgKHhDb3MubGVuZ3RoKCkgPiAwICYmIHlDb3MubGVuZ3RoKCkgPiAwKSB7XHJcbiAgICAgICAgY29zaW5lc1swXSA9IHhDb3M7XHJcbiAgICAgICAgY29zaW5lc1sxXSA9IHlDb3M7XHJcbiAgICAgICAgY29zaW5lc1syXSA9XHJcbiAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKS5cclxuICAgICAgICAgIGNyb3NzVmVjdG9ycyhjb3NpbmVzWzBdLCBjb3NpbmVzWzFdKS5cclxuICAgICAgICAgIG5vcm1hbGl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ05vIHZhbGlkIGltYWdlIG9yaWVudGF0aW9uIGZvciBmcmFtZScpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2codGhpcyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnUmV0dXJuaW5nIGRlZmF1bHQgb3JpZW50YXRpb24uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9yaWdodEhhbmRlZCkge1xyXG4gICAgICBjb3NpbmVzWzJdLm5lZ2F0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb3NpbmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHgveSBzcGFjaW5nIG9mIGEgZnJhbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHNwYWNpbmdYWSgpIHtcclxuICAgIGxldCBzcGFjaW5nWFkgPSBbMS4wLCAxLjBdO1xyXG5cclxuICAgIGlmICh0aGlzLnBpeGVsU3BhY2luZykge1xyXG4gICAgICBzcGFjaW5nWFlbMF0gPSB0aGlzLnBpeGVsU3BhY2luZ1swXTtcclxuXHJcbiAgICAgIHNwYWNpbmdYWVsxXSA9IHRoaXMucGl4ZWxTcGFjaW5nWzFdO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLnBpeGVsQXNwZWN0UmF0aW8pIHtcclxuICAgICAgc3BhY2luZ1hZWzBdID0gMS4wO1xyXG4gICAgICBzcGFjaW5nWFlbMV0gPSAxLjAgKiB0aGlzLnBpeGVsQXNwZWN0UmF0aW9bMV0gLyB0aGlzLnBpeGVsQXNwZWN0UmF0aW9bMF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNwYWNpbmdYWTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBkYXRhIHZhbHVlXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGNvbHVtblxyXG4gICAqIEBwYXJhbSB7Kn0gcm93XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHZhbHVlKGNvbHVtbiwgcm93KSB7XHJcbiAgICByZXR1cm4gdGhpcy5waXhlbERhdGFbY29sdW1uICsgdGhpcy5fY29sdW1ucyAqIHJvd107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wYXJlIDIgYXJyYXlzLlxyXG4gICAqXHJcbiAgICogMiBudWxsIGFycmF5cyByZXR1cm4gdHJ1ZS5cclxuICAgKiBEbyBubyBwZXJmb3JtIHN0cmljdCB0eXBlIGNoZWNraW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSByZWZlcmVuY2VcclxuICAgKiBAcGFyYW0geyp9IHRhcmdldFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhcnJheXMgYXJlIGlkZW50aWNhbHMuIEZhbHNlIGlmIG5vdC5cclxuICAgKi9cclxuICBfY29tcGFyZUFycmF5cyhyZWZlcmVuY2UsIHRhcmdldCkge1xyXG4gICAgLy8gY291bGQgYm90aCBiZSBudWxsXHJcbiAgICBpZiAocmVmZXJlbmNlID09PSB0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgbm90IG51bGwuLi4uXHJcbiAgICBpZiAocmVmZXJlbmNlICYmXHJcbiAgICAgICAgdGFyZ2V0ICYmXHJcbiAgICAgICAgcmVmZXJlbmNlLmpvaW4oKSA9PT0gdGFyZ2V0LmpvaW4oKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBnZXQgcm93cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9yb3dzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJvd3Mocm93cykge1xyXG4gICAgdGhpcy5fcm93cyA9IHJvd3M7XHJcbiAgfVxyXG5cclxuICBnZXQgY29sdW1ucygpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbHVtbnMoY29sdW1ucykge1xyXG4gICAgdGhpcy5fY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgfVxyXG5cclxuICBnZXQgc3BhY2luZ0JldHdlZW5TbGljZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXM7XHJcbiAgfVxyXG5cclxuICBzZXQgc3BhY2luZ0JldHdlZW5TbGljZXMoc3BhY2luZ0JldHdlZW5TbGljZXMpIHtcclxuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gc3BhY2luZ0JldHdlZW5TbGljZXM7XHJcbiAgfVxyXG5cclxuICBnZXQgc2xpY2VUaGlja25lc3MoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2xpY2VUaGlja25lc3M7XHJcbiAgfVxyXG5cclxuICBzZXQgc2xpY2VUaGlja25lc3Moc2xpY2VUaGlja25lc3MpIHtcclxuICAgIHRoaXMuX3NsaWNlVGhpY2tuZXNzID0gc2xpY2VUaGlja25lc3M7XHJcbiAgfVxyXG5cclxuICBnZXQgaW1hZ2VQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbWFnZVBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IGltYWdlUG9zaXRpb24oaW1hZ2VQb3NpdGlvbikge1xyXG4gICAgdGhpcy5faW1hZ2VQb3NpdGlvbiA9IGltYWdlUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBnZXQgaW1hZ2VPcmllbnRhdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbWFnZU9yaWVudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IGltYWdlT3JpZW50YXRpb24oaW1hZ2VPcmllbnRhdGlvbikge1xyXG4gICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbiA9IGltYWdlT3JpZW50YXRpb247XHJcbiAgfVxyXG5cclxuICBnZXQgd2luZG93V2lkdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2luZG93V2lkdGg7XHJcbiAgfVxyXG5cclxuICBzZXQgd2luZG93V2lkdGgod2luZG93V2lkdGgpIHtcclxuICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gd2luZG93V2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgd2luZG93Q2VudGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd0NlbnRlcjtcclxuICB9XHJcblxyXG4gIHNldCB3aW5kb3dDZW50ZXIod2luZG93Q2VudGVyKSB7XHJcbiAgICB0aGlzLl93aW5kb3dDZW50ZXIgPSB3aW5kb3dDZW50ZXI7XHJcbiAgfVxyXG5cclxuICBnZXQgcmVzY2FsZVNsb3BlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Jlc2NhbGVTbG9wZTtcclxuICB9XHJcblxyXG4gIHNldCByZXNjYWxlU2xvcGUocmVzY2FsZVNsb3BlKSB7XHJcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSByZXNjYWxlU2xvcGU7XHJcbiAgfVxyXG5cclxuICBnZXQgcmVzY2FsZUludGVyY2VwdCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0O1xyXG4gIH1cclxuXHJcbiAgc2V0IHJlc2NhbGVJbnRlcmNlcHQocmVzY2FsZUludGVyY2VwdCkge1xyXG4gICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCA9IHJlc2NhbGVJbnRlcmNlcHQ7XHJcbiAgfVxyXG5cclxuICBnZXQgYml0c0FsbG9jYXRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9iaXRzQWxsb2NhdGVkO1xyXG4gIH1cclxuXHJcbiAgc2V0IGJpdHNBbGxvY2F0ZWQoYml0c0FsbG9jYXRlZCkge1xyXG4gICAgdGhpcy5fYml0c0FsbG9jYXRlZCA9IGJpdHNBbGxvY2F0ZWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgZGlzdCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kaXN0O1xyXG4gIH1cclxuXHJcbiAgc2V0IGRpc3QoZGlzdCkge1xyXG4gICAgdGhpcy5fZGlzdCA9IGRpc3Q7XHJcbiAgfVxyXG5cclxuICBnZXQgcGl4ZWxTcGFjaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BpeGVsU3BhY2luZztcclxuICB9XHJcblxyXG4gIHNldCBwaXhlbFNwYWNpbmcocGl4ZWxTcGFjaW5nKSB7XHJcbiAgICB0aGlzLl9waXhlbFNwYWNpbmcgPSBwaXhlbFNwYWNpbmc7XHJcbiAgfVxyXG5cclxuICBnZXQgcGl4ZWxBc3BlY3RSYXRpbygpIHtcclxuICAgIHJldHVybiB0aGlzLl9waXhlbEFzcGVjdFJhdGlvO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBpeGVsQXNwZWN0UmF0aW8ocGl4ZWxBc3BlY3RSYXRpbykge1xyXG4gICAgdGhpcy5fcGl4ZWxBc3BlY3RSYXRpbyA9IHBpeGVsQXNwZWN0UmF0aW87XHJcbiAgfVxyXG5cclxuICBnZXQgbWluTWF4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21pbk1heDtcclxuICB9XHJcblxyXG4gIHNldCBtaW5NYXgobWluTWF4KSB7XHJcbiAgICB0aGlzLl9taW5NYXggPSBtaW5NYXg7XHJcbiAgfVxyXG5cclxuICBnZXQgZGltZW5zaW9uSW5kZXhWYWx1ZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGltZW5zaW9uSW5kZXhWYWx1ZXM7XHJcbiAgfVxyXG5cclxuICBzZXQgZGltZW5zaW9uSW5kZXhWYWx1ZXMoZGltZW5zaW9uSW5kZXhWYWx1ZXMpIHtcclxuICAgIHRoaXMuX2RpbWVuc2lvbkluZGV4VmFsdWVzID0gZGltZW5zaW9uSW5kZXhWYWx1ZXM7XHJcbiAgfVxyXG5cclxuICBnZXQgaW5zdGFuY2VOdW1iZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VOdW1iZXI7XHJcbiAgfVxyXG5cclxuICBzZXQgaW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VOdW1iZXIpIHtcclxuICAgIHRoaXMuX2luc3RhbmNlTnVtYmVyID0gaW5zdGFuY2VOdW1iZXI7XHJcbiAgfVxyXG5cclxuICBnZXQgcGl4ZWxEYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BpeGVsRGF0YTtcclxuICB9XHJcblxyXG4gIHNldCBwaXhlbERhdGEocGl4ZWxEYXRhKSB7XHJcbiAgICB0aGlzLl9waXhlbERhdGEgPSBwaXhlbERhdGE7XHJcbiAgfVxyXG5cclxuICBzZXQgc29wSW5zdGFuY2VVSUQoc29wSW5zdGFuY2VVSUQpIHtcclxuICAgIHRoaXMuX3NvcEluc3RhbmNlVUlEID0gc29wSW5zdGFuY2VVSUQ7XHJcbiAgfVxyXG5cclxuICBnZXQgc29wSW5zdGFuY2VVSUQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc29wSW5zdGFuY2VVSUQ7XHJcbiAgfVxyXG5cclxuICBnZXQgcGl4ZWxSZXByZXNlbnRhdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9waXhlbFJlcHJlc2VudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBpeGVsUmVwcmVzZW50YXRpb24ocGl4ZWxSZXByZXNlbnRhdGlvbikge1xyXG4gICAgdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbiA9IHBpeGVsUmVwcmVzZW50YXRpb247XHJcbiAgfVxyXG5cclxuICBnZXQgcGl4ZWxUeXBlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BpeGVsVHlwZTtcclxuICB9XHJcblxyXG4gIHNldCBwaXhlbFR5cGUocGl4ZWxUeXBlKSB7XHJcbiAgICB0aGlzLl9waXhlbFR5cGUgPSBwaXhlbFR5cGU7XHJcbiAgfVxyXG5cclxuICBnZXQgdXJsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICB9XHJcblxyXG4gIHNldCB1cmwodXJsKSB7XHJcbiAgICB0aGlzLl91cmwgPSB1cmw7XHJcbiAgfVxyXG5cclxuICBnZXQgcmVmZXJlbmNlZFNlZ21lbnROdW1iZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlZFNlZ21lbnROdW1iZXI7XHJcbiAgfVxyXG5cclxuICBzZXQgcmVmZXJlbmNlZFNlZ21lbnROdW1iZXIocmVmZXJlbmNlZFNlZ21lbnROdW1iZXIpIHtcclxuICAgIHRoaXMuX3JlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gcmVmZXJlbmNlZFNlZ21lbnROdW1iZXI7XHJcbiAgfVxyXG5cclxuICBnZXQgcmlnaHRIYW5kZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmlnaHRIYW5kZWQ7XHJcbiAgfVxyXG5cclxuICBzZXQgcmlnaHRIYW5kZWQocmlnaHRIYW5kZWQpIHtcclxuICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gcmlnaHRIYW5kZWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgaW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XHJcbiAgfVxyXG5cclxuICBzZXQgaW5kZXgoaW5kZXgpIHtcclxuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBGcmFtZSBmcm9tICcuL21vZGVscy5mcmFtZSc7XHJcbmltcG9ydCBTdGFjayBmcm9tICcuL21vZGVscy5zdGFjayc7XHJcbmltcG9ydCBTZXJpZXMgZnJvbSAnLi9tb2RlbHMuc2VyaWVzJztcclxuaW1wb3J0IFZveGVsIGZyb20gJy4vbW9kZWxzLnZveGVsJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIG1vZGVsc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBGcmFtZSxcclxuICBTdGFjayxcclxuICBTZXJpZXMsXHJcbiAgVm94ZWwsXHJcbn07XHJcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xyXG5pbXBvcnQgTW9kZWxzQmFzZSBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLmJhc2UnO1xyXG5cclxuLyoqXHJcbiAqIFNlcmllcyBvYmplY3QuXHJcbiAqXHJcbiAqIEBtb2R1bGUgbW9kZWxzL3Nlcmllc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxzU2VyaWVzIGV4dGVuZHMgTW9kZWxzQmFzZSB7XHJcbiAgLyoqXHJcbiAgICogTW9kZWxzIHNlcmllcyBjb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9jb25jYXRlbmF0aW9uVUlEID0gLTE7XHJcbiAgICB0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRCA9IC0xO1xyXG4gICAgdGhpcy5fdHJhbnNmZXJTeW50YXhVSUQgPSAnJztcclxuICAgIHRoaXMuX3Nlcmllc051bWJlciA9IC0xO1xyXG4gICAgdGhpcy5fc2VyaWVzRGVzY3JpcHRpb24gPSAnJztcclxuICAgIHRoaXMuX3N0dWR5RGVzY3JpcHRpb24gPSAnJztcclxuICAgIHRoaXMuX21vZGFsaXR5ID0gJ01vZGFsaXR5IG5vdCBzZXQnO1xyXG4gICAgdGhpcy5fZGltZW5zaW9uSW5kZXhTZXF1ZW5jZSA9IFtdO1xyXG4gICAgLy8gaXQgaXMgdXNlZCBpbiB0aGUgbG9hZGVyIGluIGNhc2UgYSBkaWNvbS9uaWZ0aSBjb250YWlucyBtdWx0aXBsZSBmcmFtZXNcclxuICAgIC8vIHNob3VsZCBiZSB1cGRhdGVkIGFmdGVyIG1lcmdlIG9yIHJlbmFtZWRcclxuICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gMDtcclxuICAgIHRoaXMuX251bWJlck9mQ2hhbm5lbHMgPSAxO1xyXG5cclxuICAgIC8vIHBhdGllbnQgaW5mb3JtYXRpb25cclxuICAgIHRoaXMuX3BhdGllbnRJRCA9ICcnO1xyXG4gICAgdGhpcy5fcGF0aWVudE5hbWUgPSAnJztcclxuICAgIHRoaXMuX3BhdGllbnRBZ2UgPSAnJztcclxuICAgIHRoaXMuX3BhdGllbnRCaXJ0aGRhdGUgPSAnJztcclxuICAgIHRoaXMuX3BhdGllbnRTZXggPSAnJztcclxuXHJcbiAgICAvLyBTRUdNRU5UQVRJT04gU1RVRkZcclxuICAgIHRoaXMuX3NlZ21lbnRhdGlvblR5cGUgPSBudWxsO1xyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMgPSBbXTtcclxuXHJcbiAgICAvLyBTVEFDS1xyXG4gICAgdGhpcy5fc3RhY2sgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIGEgc2VyaWVzLlxyXG4gICAqXHJcbiAgICogUmVxdWlyZW1lbnRzOlxyXG4gICAqICAgLSBtZXJnZVNlcmllcyBtZXRob2RcclxuICAgKiAgIC0gX3Nlcmllc0luc3RhbmNlVUlEXHJcbiAgICogICAtIF9udW1iZXJPZkZyYW1lc1xyXG4gICAqICAgLSBfbnVtYmVyT2ZDaGFubmVsc1xyXG4gICAqICAgXyBfc3RhY2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TW9kZWxzU2VyaWVzfSBtb2RlbCAtIE1vZGVsIHRvIGJlIHZhbGlkYXRlZCBhcyBzZXJpZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHNlcmllcyBpcyB2YWxpZC4gRmFsc2UgaWYgbm90LlxyXG4gICAqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgdmFsaWRhdGUobW9kZWwpIHtcclxuICAgIGlmICghKHN1cGVyLnZhbGlkYXRlKG1vZGVsKSAmJlxyXG4gICAgICB0eXBlb2YgbW9kZWwubWVyZ2VTZXJpZXMgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19zZXJpZXNJbnN0YW5jZVVJRCcpICYmXHJcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfbnVtYmVyT2ZGcmFtZXMnKSAmJlxyXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX251bWJlck9mQ2hhbm5lbHMnKSAmJlxyXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX3N0YWNrJykgJiZcclxuICAgICAgdHlwZW9mIG1vZGVsLl9zdGFjayAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgQXJyYXkgPT09IG1vZGVsLl9zdGFjay5jb25zdHJ1Y3RvcikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWVyZ2UgY3VycmVudCBzZXJpZXMgd2l0aCBwcm92aWRlZCBzZXJpZXMuXHJcbiAgICogMiBzZXJpZXMgY2FuIE9OTFkgYmUgbWVyZ2UgaWYgdGhleSBoYXZlIHRoZSBzYW1lIFNlcmllc0luc3RhbmNlVUlELlxyXG4gICAqXHJcbiAgICogQWxzbyBtZXJnZXMgdGhlIHN0YWNrcyBpbnNpZGUgYSBzZXJpZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01vZGVsc1Nlcmllc30gc2VyaWVzIC0gU2VyaWVzIHRvIGJlIG1lcmdlZCBhZ2FpbnN0IGN1cnJlbnQgc2VyaWVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBzZXJpZXMgY291bGQgYmUgbWVyZ2UuIEZhbHNlIGlmIG5vdC5cclxuICAgKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIG1lcmdlKHNlcmllcykge1xyXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlKHNlcmllcykpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRCA9PT0gc2VyaWVzLnNlcmllc0luc3RhbmNlVUlEKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1lcmdlTW9kZWxzKHRoaXMuX3N0YWNrLCBzZXJpZXMuc3RhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWVyZ2UgY3VycmVudCBzZXJpZXMgd2l0aCBwcm92aWRlZCBhcnJheSBvZiBzZXJpZXMuXHJcbiAgICogMiBzZXJpZXMgY2FuIE9OTFkgYmUgbWVyZ2UgaWYgdGhleSBoYXZlIHRoZSBzYW1lIFNlcmllc0luc3RhbmNlVUlELlxyXG4gICAqXHJcbiAgICogQWxzbyBtZXJnZXMgdGhlIHN0YWNrcyBpbnNpZGUgYSBzZXJpZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxNb2RlbHNTZXJpZXM+fSB0YXJnZXQgLSBTZXJpZXMgdG8gYmUgbWVyZ2VkIGFnYWluc3QgY3VycmVudCBzZXJpZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtBcnJheS48TW9kZWxzU2VyaWVzPn0gQXJyYXkgb2Ygc2VyaWVzIHByb3Blcmx5IG1lcmdlZC5cclxuICAgKi9cclxuICBtZXJnZVNlcmllcyh0YXJnZXQpIHtcclxuICAgIGxldCBzZXJpZXNDb250YWluZXIgPSBbdGhpc107XHJcbiAgICB0aGlzLm1lcmdlTW9kZWxzKHNlcmllc0NvbnRhaW5lciwgdGFyZ2V0KTtcclxuICAgIHJldHVybiBzZXJpZXNDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXJpZXMgaW5zdGFuY2UgVUlEIHNldHRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBzZXJpZXNJbnN0YW5jZVVJRFxyXG4gICAqL1xyXG4gIHNldCBzZXJpZXNJbnN0YW5jZVVJRChzZXJpZXNJbnN0YW5jZVVJRCkge1xyXG4gICAgdGhpcy5fc2VyaWVzSW5zdGFuY2VVSUQgPSBzZXJpZXNJbnN0YW5jZVVJRDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlcmllcyBpbnN0YWNlIFVJRCBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IHNlcmllc0luc3RhbmNlVUlEKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Nlcmllc0luc3RhbmNlVUlEO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmZXIgc3ludGF4IFVJRCBzZXR0ZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gdHJhbnNmZXJTeW50YXhVSURcclxuICAgKi9cclxuICBzZXQgdHJhbnNmZXJTeW50YXhVSUQodHJhbnNmZXJTeW50YXhVSUQpIHtcclxuICAgIHRoaXMuX3RyYW5zZmVyU3ludGF4VUlEID0gdHJhbnNmZXJTeW50YXhVSUQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2ZlciBzeW50YXggVUlEIGdldHRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBnZXQgdHJhbnNmZXJTeW50YXhVSUQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmZXJTeW50YXhVSUQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2ZlciBzeW50YXggVUlEIGdldHRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBnZXQgdHJhbnNmZXJTeW50YXhVSURMYWJlbCgpIHtcclxuICAgIHN3aXRjaCAodGhpcy5fdHJhbnNmZXJTeW50YXhVSUQpIHtcclxuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC45MCc6XHJcbiAgICAgICAgcmV0dXJuICdKUEVHIDIwMDAgTG9zc2xlc3MnO1xyXG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi40LjkxJzpcclxuICAgICAgICByZXR1cm4gJ0pQRUcgMjAwMCBMb3NzeSc7XHJcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjQuNTcnOlxyXG4gICAgICAgIHJldHVybiAnSlBFRyBMb3NzbGVzcywgTm9uaGllcmFyY2hpY2FsIChQcm9jZXNzZXMgMTQpJztcclxuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC43MCc6XHJcbiAgICAgICAgcmV0dXJuICdKUEVHIExvc3NsZXNzLCBOb25oaWVyYXJjaGljYWwgKFByb2Nlc3NlcyAxNCBbU2VsZWN0aW9uIDFdKSc7XHJcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjQuNTAnOlxyXG4gICAgICAgIHJldHVybiAnSlBFRyBCYXNlbGluZSBsb3NzeSBwcm9jZXNzIDEgKDggYml0KSc7XHJcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjQuNTEnOlxyXG4gICAgICAgIHJldHVybiAnSlBFRyBCYXNlbGluZSBsb3NzeSBwcm9jZXNzIDIgJiA0ICgxMiBiaXQpJztcclxuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjInOlxyXG4gICAgICAgIHJldHVybiAnSW1wbGljaXQgVlIgTGl0dGxlIEVuZGlhbic7XHJcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjEnOlxyXG4gICAgICAgIHJldHVybiAnRXhwbGljaXQgVlIgTGl0dGxlIEVuZGlhbic7XHJcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjInOlxyXG4gICAgICAgIHJldHVybiAnRXhwbGljaXQgVlIgQmlnIEVuZGlhbic7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIGBVbmtub3duIHRyYW5zZmVyc3ludGF4OiAke3RoaXMuX3RyYW5zZmVyU3ludGF4VUlEfWA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHVkeSBkZXNjcmlwaXRpb24gc2V0dGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHN0dWR5RGVzY3JpcHRpb25cclxuICAgKi9cclxuICBzZXQgc3R1ZHlEZXNjcmlwdGlvbihzdHVkeURlc2NyaXB0aW9uKSB7XHJcbiAgICB0aGlzLl9zdHVkeURlc2NyaXB0aW9uID0gc3R1ZHlEZXNjcmlwdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0dWR5IGRlc2NyaXB0aW9uIGdldHRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBnZXQgc3R1ZHlEZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdHVkeURlc2NyaXB0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VyaWVzIGRlc2NyaXBpdGlvbiBzZXR0ZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gc2VyaWVzRGVzY3JpcHRpb25cclxuICAgKi9cclxuICBzZXQgc2VyaWVzRGVzY3JpcHRpb24oc2VyaWVzRGVzY3JpcHRpb24pIHtcclxuICAgIHRoaXMuX3Nlcmllc0Rlc2NyaXB0aW9uID0gc2VyaWVzRGVzY3JpcHRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXJpZXMgZGVzY3JpcHRpb24gZ2V0dGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBzZXJpZXNEZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZXJpZXNEZXNjcmlwdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGllbnQgSUQgc2V0dGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHBhdGllbnRJRFxyXG4gICAqL1xyXG4gIHNldCBwYXRpZW50SUQocGF0aWVudElEKSB7XHJcbiAgICB0aGlzLl9wYXRpZW50SUQgPSBwYXRpZW50SUQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IElEIGdldHRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBnZXQgcGF0aWVudElEKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhdGllbnRJRDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGllbnQgbmFtZSBzZXR0ZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gcGF0aWVudE5hbWVcclxuICAgKi9cclxuICBzZXQgcGF0aWVudE5hbWUocGF0aWVudE5hbWUpIHtcclxuICAgIHRoaXMuX3BhdGllbnROYW1lID0gcGF0aWVudE5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IG5hbWUgZ2V0dGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBwYXRpZW50TmFtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXRpZW50TmFtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGllbnQgYWdlIHNldHRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBwYXRpZW50QWdlXHJcbiAgICovXHJcbiAgc2V0IHBhdGllbnRBZ2UocGF0aWVudEFnZSkge1xyXG4gICAgdGhpcy5fcGF0aWVudEFnZSA9IHBhdGllbnRBZ2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IGFnZSBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IHBhdGllbnRBZ2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF0aWVudEFnZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGllbnQgYmlydGhkYXRlIHNldHRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBwYXRpZW50QmlydGhkYXRlXHJcbiAgICovXHJcbiAgc2V0IHBhdGllbnRCaXJ0aGRhdGUocGF0aWVudEJpcnRoZGF0ZSkge1xyXG4gICAgdGhpcy5fcGF0aWVudEJpcnRoZGF0ZSA9IHBhdGllbnRCaXJ0aGRhdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IGJpcnRoZGF0ZSBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IHBhdGllbnRCaXJ0aGRhdGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF0aWVudEJpcnRoZGF0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGllbnQgc2V4IHNldHRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBwYXRpZW50U2V4XHJcbiAgICovXHJcbiAgc2V0IHBhdGllbnRTZXgocGF0aWVudFNleCkge1xyXG4gICAgdGhpcy5fcGF0aWVudFNleCA9IHBhdGllbnRTZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IHNleCBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IHBhdGllbnRTZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF0aWVudFNleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE51bWJlciBvZiBmcmFtZXMgc2V0dGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IG51bWJlck9mRnJhbWVzXHJcbiAgICovXHJcbiAgc2V0IG51bWJlck9mRnJhbWVzKG51bWJlck9mRnJhbWVzKSB7XHJcbiAgICB0aGlzLl9udW1iZXJPZkZyYW1lcyA9IG51bWJlck9mRnJhbWVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTnVtYmVyIG9mIGZyYW1lcyBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IG51bWJlck9mRnJhbWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX251bWJlck9mRnJhbWVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTnVtYmVyIG9mIGNoYW5uZWxzIHNldHRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBudW1iZXJPZkNoYW5uZWxzXHJcbiAgICovXHJcbiAgc2V0IG51bWJlck9mQ2hhbm5lbHMobnVtYmVyT2ZDaGFubmVscykge1xyXG4gICAgdGhpcy5fbnVtYmVyT2ZDaGFubmVscyA9IG51bWJlck9mQ2hhbm5lbHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOdW1iZXIgb2YgY2hhbm5lbHMgZ2V0dGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBudW1iZXJPZkNoYW5uZWxzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX251bWJlck9mQ2hhbm5lbHM7XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhY2soc3RhY2spIHtcclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcbiAgfVxyXG5cclxuICBnZXQgc3RhY2soKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhY2s7XHJcbiAgfVxyXG5cclxuICBzZXQgbW9kYWxpdHkobW9kYWxpdHkpIHtcclxuICAgIHRoaXMuX21vZGFsaXR5ID0gbW9kYWxpdHk7XHJcbiAgfVxyXG5cclxuICBnZXQgbW9kYWxpdHkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbW9kYWxpdHk7XHJcbiAgfVxyXG5cclxuICBzZXQgc2VnbWVudGF0aW9uVHlwZShzZWdtZW50YXRpb25UeXBlKSB7XHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25UeXBlID0gc2VnbWVudGF0aW9uVHlwZTtcclxuICB9XHJcblxyXG4gIGdldCBzZWdtZW50YXRpb25UeXBlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRhdGlvblR5cGU7XHJcbiAgfVxyXG5cclxuICBzZXQgc2VnbWVudGF0aW9uU2VnbWVudHMoc2VnbWVudGF0aW9uU2VnbWVudHMpIHtcclxuICAgIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzID0gc2VnbWVudGF0aW9uU2VnbWVudHM7XHJcbiAgfVxyXG5cclxuICBnZXQgc2VnbWVudGF0aW9uU2VnbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHM7XHJcbiAgfVxyXG59XHJcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xyXG5pbXBvcnQgQ29yZUNvbG9ycyBmcm9tICcuLi9jb3JlL2NvcmUuY29sb3JzJztcclxuaW1wb3J0IENvcmVVdGlscyBmcm9tICcuLi9jb3JlL2NvcmUudXRpbHMnO1xyXG5pbXBvcnQgTW9kZWxzQmFzZSBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLmJhc2UnO1xyXG5cclxuY29uc3QgYmluYXJ5U3RyaW5nID0gcmVxdWlyZSgnbWF0aC1mbG9hdDMyLXRvLWJpbmFyeS1zdHJpbmcnKTtcclxuXHJcbi8qKlxyXG4gKiBTdGFjayBvYmplY3QuXHJcbiAqXHJcbiAqIEBtb2R1bGUgbW9kZWxzL3N0YWNrXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbHNTdGFjayBleHRlbmRzIE1vZGVsc0Jhc2Uge1xyXG4gIC8qKlxyXG4gICAqIE1vZGVscyBTdGFjayBjb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl91aWQgPSBudWxsO1xyXG4gICAgdGhpcy5fc3RhY2tJRCA9IC0xO1xyXG5cclxuICAgIHRoaXMuX2ZyYW1lID0gW107XHJcbiAgICB0aGlzLl9udW1iZXJPZkZyYW1lcyA9IDA7XHJcblxyXG4gICAgdGhpcy5fcm93cyA9IDA7XHJcbiAgICB0aGlzLl9jb2x1bW5zID0gMDtcclxuICAgIHRoaXMuX251bWJlck9mQ2hhbm5lbHMgPSAxO1xyXG4gICAgdGhpcy5fYml0c0FsbG9jYXRlZCA9IDg7XHJcbiAgICB0aGlzLl9waXhlbFR5cGUgPSAwO1xyXG4gICAgdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbiA9IDA7XHJcblxyXG4gICAgdGhpcy5fdGV4dHVyZVNpemUgPSA0MDk2O1xyXG4gICAgdGhpcy5fbmJUZXh0dXJlcyA9IDc7XHJcbiAgICB0aGlzLl9yYXdEYXRhID0gW107XHJcblxyXG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gMDtcclxuICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gMDtcclxuXHJcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSAxO1xyXG4gICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCA9IDA7XHJcblxyXG4gICAgdGhpcy5fbWluTWF4ID0gWzY1NTM1LCAtMzI3NjhdO1xyXG5cclxuICAgIC8vIFRSQU5TRk9STUFUSU9OIE1BVFJJQ0VTXHJcbiAgICB0aGlzLl9yZWdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgIHRoaXMuX2lqazJMUFMgPSBudWxsO1xyXG4gICAgdGhpcy5fbHBzMklKSyA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fYWFiYjJMUFMgPSBudWxsO1xyXG4gICAgdGhpcy5fbHBzMkFBQkIgPSBudWxsO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBJSksgZGltZW5zaW9uc1xyXG4gICAgdGhpcy5fZGltZW5zaW9uc0lKSyA9IG51bGw7XHJcbiAgICB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSyA9IG51bGw7XHJcbiAgICB0aGlzLl9zcGFjaW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoMSwgMSwgMSk7XHJcbiAgICB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcyA9IDA7XHJcbiAgICB0aGlzLl9zbGljZVRoaWNrbmVzcyA9IDA7XHJcbiAgICB0aGlzLl9vcmlnaW4gPSBudWxsO1xyXG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5feENvc2luZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApO1xyXG4gICAgdGhpcy5feUNvc2luZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xyXG4gICAgdGhpcy5fekNvc2luZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xyXG5cclxuICAgIC8vIGNvbnZlbmllbmNlIHZhcnNcclxuICAgIHRoaXMuX3ByZXBhcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wYWNrZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BhY2tlZFBlclBpeGVsID0gMTtcclxuXHJcbiAgICAvL1xyXG4gICAgdGhpcy5fbW9kYWxpdHkgPSAnTW9kYWxpdHkgbm90IHNldCc7XHJcblxyXG4gICAgLy8gU0VHTUVOVEFUSU9OIFNUVUZGXHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25UeXBlID0gbnVsbDtcclxuICAgIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzID0gW107XHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25EZWZhdWx0Q29sb3IgPSBbNjMsIDE3NCwgMTI4XTtcclxuICAgIHRoaXMuX2ZyYW1lU2VnbWVudCA9IFtdO1xyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uTFVUID0gW107XHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25MVVRPID0gW107XHJcblxyXG4gICAgLy8gcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiBNb25vY2hyb21lMSBWUyBNb25vY2hyb21lMlxyXG4gICAgdGhpcy5faW52ZXJ0ID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVwYXJlIHNlZ21lbnRhdGlvbiBzdGFjay5cclxuICAgKiBBIHNlZ21lbnRhdGlvbiBzdGFjayBjYW4gaG9sZCB4IGZyYW1lcyB0aGF0IGFyZSBhdCB0aGUgc2FtZSBsb2NhdGlvblxyXG4gICAqIGJ1dCBzZWdtZW50YXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb246XHJcbiAgICogLSBGcmFtZSBYIGNvbnRhaW5zIHZveGVscyBmb3Igc2VnbWVudGF0aW9uIEEuXHJcbiAgICogLSBGcmFtZSBZIGNvbnRhaW5zIHZveGVscyBmb3Igc2VnbWVudHRhdGlvbiBCLlxyXG4gICAqIC0gRnJhbWUgWCBhbmQgWSBhcmUgYXQgdGhlIHNhbWUgbG9jYXRpb24uXHJcbiAgICpcclxuICAgKiBXZSBjdXJyZW50bHkgbWVyZ2Ugb3ZlcmxhcGluZyBmcmFtZXMgaW50byAxLlxyXG4gICAqL1xyXG4gIHByZXBhcmVTZWdtZW50YXRpb24oKSB7XHJcbiAgICAvLyBzdG9yZSBmcmFtZSBhbmQgZG8gc3BlY2lhbCBwcmUtcHJvY2Vzc2luZ1xyXG4gICAgdGhpcy5fZnJhbWVTZWdtZW50ID0gdGhpcy5fZnJhbWU7XHJcbiAgICBsZXQgbWVyZ2VkRnJhbWVzID0gW107XHJcblxyXG4gICAgLy8gb3JkZXIgZnJhbWVzXHJcbiAgICB0aGlzLmNvbXB1dGVDb3NpbmVzKCk7XHJcbiAgICB0aGlzLl9mcmFtZS5tYXAodGhpcy5fY29tcHV0ZURpc3RhbmNlQXJyYXlNYXAuYmluZChudWxsLCB0aGlzLl96Q29zaW5lKSk7XHJcbiAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX3NvcnREaXN0YW5jZUFycmF5U29ydCk7XHJcblxyXG4gICAgLy8gbWVyZ2UgZnJhbWVzXHJcbiAgICBsZXQgcHJldkluZGV4ID0gLTE7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaTx0aGlzLl9mcmFtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIW1lcmdlZEZyYW1lc1twcmV2SW5kZXhdIHx8XHJcbiAgICAgICAgICBtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5fZGlzdCAhPSB0aGlzLl9mcmFtZVtpXS5fZGlzdCkge1xyXG4gICAgICAgIG1lcmdlZEZyYW1lcy5wdXNoKHRoaXMuX2ZyYW1lW2ldKTtcclxuICAgICAgICBwcmV2SW5kZXgrKztcclxuXHJcbiAgICAgICAgLy8gU2NhbGUgZnJhbWVcclxuICAgICAgICAvLyBieSBkZWZhdWx0IGVhY2ggZnJhbWUgY29udGFpbnMgYmluYXJ5IGRhdGEgYWJvdXQgYSBzZWdtZW50YXRpb24uXHJcbiAgICAgICAgLy8gd2Ugc2NhbGUgaXQgYnkgdGhlIHJlZmVyZW5jZVNlZ21lbnROdW1iZXIgaW4gb3JkZXIgdG8gaGF2ZSBhXHJcbiAgICAgICAgLy8gc2VnbWVudGF0aW9uIHNwZWNpZmljIHZveGVsIHZhbHVlIHJhdGhlciB0aGFuIDAgb3IgMS5cclxuICAgICAgICAvLyBUaGF0IGFsbG93cyB1cyB0byBtZXJnZSBmcmFtZXMgbGF0ZXIgb24uXHJcbiAgICAgICAgLy8gSWYgd2UgbWVyZ2UgZnJhbWVzIHdpdGhvdXQgc2NhbGluZywgdGhlbiB3ZSBjYW4gbm90IGRpZmZlcmVuY2lhdGVcclxuICAgICAgICAvLyB2b3hlbHMgZnJvbSBzZWdtZW50YXRpb24gQSBvciBCIGFzIHRoZSB2YWx1ZSBpcyAwIG9yIDEgaW4gYm90aCBjYXNlcy5cclxuICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgbGV0IGs9MDtcclxuICAgICAgICAgIGs8bWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX3Jvd3MgKiBtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5fY29sdW1ucztcclxuICAgICAgICAgIGsrKykge1xyXG4gICAgICAgICAgbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX3BpeGVsRGF0YVtrXSAqPVxyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZVtpXS5fcmVmZXJlbmNlZFNlZ21lbnROdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGZyYW1lIGFscmVhZHkgZXhzaXRzIGF0IHRoaXMgbG9jYXRpb24uXHJcbiAgICAgICAgLy8gbWVyZ2UgZGF0YSBmcm9tIHRoaXMgc2VnbWVudGF0aW9uIGludG8gZXhpc3RpbmcgZnJhbWVcclxuICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgbGV0IGs9MDtcclxuICAgICAgICAgIGs8bWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX3Jvd3MgKiBtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5fY29sdW1ucztcclxuICAgICAgICAgIGsrKykge1xyXG4gICAgICAgICAgbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX3BpeGVsRGF0YVtrXSArPVxyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZVtpXS5waXhlbERhdGFba10gKlxyXG4gICAgICAgICAgICAgIHRoaXMuX2ZyYW1lW2ldLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLm1pbk1heCA9XHJcbiAgICAgICAgQ29yZVV0aWxzLm1pbk1heChtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5fcGl4ZWxEYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBnZXQgaW5mb3JtYXRpb24gYWJvdXQgc2VnbWVudHNcclxuICAgIGxldCBkaWN0ID0ge307XHJcbiAgICBsZXQgbWF4ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpPHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG1heCA9XHJcbiAgICAgICAgTWF0aC5tYXgoXHJcbiAgICAgICAgICBtYXgsIHBhcnNlSW50KHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzW2ldLnNlZ21lbnROdW1iZXIsIDEwKSk7XHJcblxyXG4gICAgICBsZXQgY29sb3IgPSB0aGlzLl9zZWdtZW50YXRpb25TZWdtZW50c1tpXS5yZWNvbW1lbmRlZERpc3BsYXlDSUVMYWI7XHJcbiAgICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xyXG4gICAgICAgIGRpY3RbdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0uc2VnbWVudE51bWJlcl0gPVxyXG4gICAgICAgICAgdGhpcy5fc2VnbWVudGF0aW9uRGVmYXVsdENvbG9yO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpY3RbdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0uc2VnbWVudE51bWJlcl0gPVxyXG4gICAgICAgICAgQ29yZUNvbG9ycy5jaWVsYWIyUkdCKC4uLmNvbG9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGdlbmVyYXRlIExVVHNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heDsgaSsrKSB7XHJcbiAgICAgIGxldCBpbmRleCA9IGkgLyBtYXg7XHJcbiAgICAgIGxldCBvcGFjaXR5ID0gaSA/IDEgOiAwO1xyXG4gICAgICBsZXQgcmdiID0gWzAsIDAsIDBdO1xyXG4gICAgICBpZiAoZGljdC5oYXNPd25Qcm9wZXJ0eShpLnRvU3RyaW5nKCkpKSB7XHJcbiAgICAgICAgcmdiID0gZGljdFtpLnRvU3RyaW5nKCldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZ2JbMF0gLz0gMjU1O1xyXG4gICAgICByZ2JbMV0gLz0gMjU1O1xyXG4gICAgICByZ2JbMl0gLz0gMjU1O1xyXG5cclxuICAgICAgdGhpcy5fc2VnbWVudGF0aW9uTFVULnB1c2goW2luZGV4LCAuLi5yZ2JdKTtcclxuICAgICAgdGhpcy5fc2VnbWVudGF0aW9uTFVUTy5wdXNoKFtpbmRleCwgb3BhY2l0eV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2ZyYW1lID0gbWVyZ2VkRnJhbWVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBjb3NpbmVzXHJcbiAgICogT3JkZXIgZnJhbWVzXHJcbiAgICogY29tcHV0ZVNwYWNpbmdcclxuICAgKiBzYW5pdHlDaGVja1xyXG4gICAqIGluaXQgc29tZSB2YXJzXHJcbiAgICogY29tcHV0ZSBtaW4vbWF4XHJcbiAgICogY29tcHV0ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaWNlc1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwcmVwYXJlKCkge1xyXG4gICAgLy8gaWYgc2VnbWVudGF0aW9uLCBtZXJnZSBzb21lIGZyYW1lcy4uLlxyXG4gICAgaWYgKHRoaXMuX21vZGFsaXR5ID09PSAnU0VHJykge1xyXG4gICAgICB0aGlzLnByZXBhcmVTZWdtZW50YXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSBuZWVkIGF0IGxlYXN0IDEgZnJhbWVcclxuICAgIGlmICh0aGlzLl9mcmFtZSAmJiB0aGlzLl9mcmFtZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gdGhpcy5fZnJhbWUubGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdfZnJhbWUgZG9lc25cXCd0IGNvbnRhaW4gYW55dGhpbmcuLi4uJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzLl9mcmFtZSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwYXNzIHBhcmFtZXRlcnMgZnJvbSBmcmFtZSB0byBzdGFja1xyXG4gICAgdGhpcy5fcm93cyA9IHRoaXMuX2ZyYW1lWzBdLnJvd3M7XHJcbiAgICB0aGlzLl9jb2x1bW5zID0gdGhpcy5fZnJhbWVbMF0uY29sdW1ucztcclxuICAgIHRoaXMuX2RpbWVuc2lvbnNJSksgPVxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyh0aGlzLl9jb2x1bW5zLCB0aGlzLl9yb3dzLCB0aGlzLl9udW1iZXJPZkZyYW1lcyk7XHJcbiAgICB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSyA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnggLyAyLFxyXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnkgLyAyLFxyXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnogLyAyXHJcbiAgICApO1xyXG4gICAgdGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXMgPSB0aGlzLl9mcmFtZVswXS5zcGFjaW5nQmV0d2VlblNsaWNlcztcclxuICAgIHRoaXMuX3NsaWNlVGhpY2tuZXNzID0gdGhpcy5fZnJhbWVbMF0uc2xpY2VUaGlja25lc3M7XHJcblxyXG4gICAgLy8gY29tcHV0ZSBkaXJlY3Rpb24gY29zaW5lc1xyXG4gICAgdGhpcy5jb21wdXRlQ29zaW5lcygpO1xyXG5cclxuICAgIC8vIG9yZGVyIHRoZSBmcmFtZXNcclxuICAgIHRoaXMub3JkZXJGcmFtZXMoKTtcclxuXHJcbiAgICAvLyBjb21wdXRlL2d1ZXNzIHNwYWNpbmdcclxuICAgIHRoaXMuY29tcHV0ZVNwYWNpbmcoKTtcclxuICAgIC8vIHNldCBleHRyYSB2YXJzIGlmIG51bGxzXHJcbiAgICAvLyBkbyBpdCBub3cgYmVjYXVzZSBiZWZvcmUgd2Ugd291bGQgdGhpbmsgaW1hZ2UgcG9zaXRpb24vb3JpZW50YXRpb25cclxuICAgIC8vIGFyZSBkZWZpbmVkIGFuZCB3ZSB3b3VsZCB1c2UgaXQgdG8gY29tcHV0ZSBzcGFjaW5nLlxyXG4gICAgaWYgKCF0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uKSB7XHJcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmltYWdlUG9zaXRpb24gPSBbMCwgMCwgMF07XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuX2ZyYW1lWzBdLmltYWdlT3JpZW50YXRpb24pIHtcclxuICAgICAgdGhpcy5fZnJhbWVbMF0uaW1hZ2VPcmllbnRhdGlvbiA9IFsxLCAwLCAwLCAwLCAxLCAwXTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9vcmlnaW4gPSB0aGlzLl9hcnJheVRvVmVjdG9yMyh0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uLCAwKTtcclxuXHJcbiAgICAvLyBjb21wdXRlIHRyYW5zZm9ybXNcclxuICAgIHRoaXMuY29tcHV0ZUlKSzJMUFMoKTtcclxuXHJcbiAgICB0aGlzLmNvbXB1dGVMUFMyQUFCQigpO1xyXG4gICAgLy8gdGhpcy5wYWNrRWNob3MoKTtcclxuXHJcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSB0aGlzLl9mcmFtZVswXS5yZXNjYWxlU2xvcGUgfHwgMTtcclxuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSB0aGlzLl9mcmFtZVswXS5yZXNjYWxlSW50ZXJjZXB0IHx8IDA7XHJcblxyXG4gICAgLy8gcmVzY2FsZS9zbG9wZSBtaW4gbWF4XHJcbiAgICB0aGlzLmNvbXB1dGVNaW5NYXhJbnRlbnNpdGllcygpO1xyXG4gICAgdGhpcy5fbWluTWF4WzBdID0gTW9kZWxzU3RhY2sudmFsdWVSZXNjYWxlU2xvcGVJbnRlcmNlcHQoXHJcbiAgICAgIHRoaXMuX21pbk1heFswXSxcclxuICAgICAgdGhpcy5fcmVzY2FsZVNsb3BlLFxyXG4gICAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0KTtcclxuICAgIHRoaXMuX21pbk1heFsxXSA9IE1vZGVsc1N0YWNrLnZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0KFxyXG4gICAgICB0aGlzLl9taW5NYXhbMV0sXHJcbiAgICAgIHRoaXMuX3Jlc2NhbGVTbG9wZSxcclxuICAgICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCk7XHJcblxyXG4gICAgbGV0IHdpZHRoID0gdGhpcy5fZnJhbWVbMF0ud2luZG93V2lkdGggfHwgdGhpcy5fbWluTWF4WzFdIC0gdGhpcy5fbWluTWF4WzBdO1xyXG4gICAgdGhpcy5fd2luZG93V2lkdGggPSB0aGlzLl9yZXNjYWxlU2xvcGUgKiB3aWR0aCArIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQ7XHJcblxyXG4gICAgbGV0IGNlbnRlciA9IHRoaXMuX2ZyYW1lWzBdLndpbmRvd0NlbnRlciB8fCB0aGlzLl9taW5NYXhbMF0gKyB3aWR0aCAvIDI7XHJcbiAgICB0aGlzLl93aW5kb3dDZW50ZXIgPSB0aGlzLl9yZXNjYWxlU2xvcGUgKiBjZW50ZXIgKyB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0O1xyXG5cclxuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSB0aGlzLl9mcmFtZVswXS5iaXRzQWxsb2NhdGVkO1xyXG4gICAgdGhpcy5fcHJlcGFyZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcGFja0VjaG9zKCkge1xyXG4gICAgLy8gNCBlY2hvIHRpbWVzLi4uXHJcbiAgICBsZXQgZWNob3MgPSA0O1xyXG4gICAgbGV0IHBhY2tlZEVjaG8gPSBbXTtcclxuICAgIGZvciAobGV0IGk9MDsgaTwgdGhpcy5fZnJhbWUubGVuZ3RoOyBpKz1lY2hvcykge1xyXG4gICAgICBsZXQgZnJhbWUgPSB0aGlzLl9mcmFtZVtpXTtcclxuICAgICAgZm9yIChsZXQgaz0wOyBrPHRoaXMuX3Jvd3MgKiB0aGlzLl9jb2x1bW5zOyBrKyspIHtcclxuICAgICAgICBmb3IgKGxldCBqPTE7IGo8ZWNob3M7IGorKykge1xyXG4gICAgICAgICAgZnJhbWUucGl4ZWxEYXRhW2tdICs9IHRoaXMuX2ZyYW1lW2kral0ucGl4ZWxEYXRhW2tdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmcmFtZS5waXhlbERhdGFba10gLz0gZWNob3M7XHJcbiAgICAgIH1cclxuICAgICAgcGFja2VkRWNoby5wdXNoKGZyYW1lKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2ZyYW1lID0gcGFja2VkRWNobztcclxuICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gdGhpcy5fZnJhbWUubGVuZ3RoO1xyXG4gICAgdGhpcy5fZGltZW5zaW9uc0lKSyA9XHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKHRoaXMuX2NvbHVtbnMsIHRoaXMuX3Jvd3MsIHRoaXMuX251bWJlck9mRnJhbWVzKTtcclxuICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zSUpLID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueCAvIDIsXHJcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueSAvIDIsXHJcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueiAvIDJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBmcmFtZS5jb3NpbmVzIC0gcmV0dXJucyBhcnJheSBbeCwgeSwgel1cclxuICBjb21wdXRlQ29zaW5lcygpIHtcclxuICAgIGlmICh0aGlzLl9mcmFtZSAmJlxyXG4gICAgICB0aGlzLl9mcmFtZVswXSkge1xyXG4gICAgICBsZXQgY29zaW5lcyA9IHRoaXMuX2ZyYW1lWzBdLmNvc2luZXMoKTtcclxuICAgICAgdGhpcy5feENvc2luZSA9IGNvc2luZXNbMF07XHJcbiAgICAgIHRoaXMuX3lDb3NpbmUgPSBjb3NpbmVzWzFdO1xyXG4gICAgICB0aGlzLl96Q29zaW5lID0gY29zaW5lc1syXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9yZGVyRnJhbWVzKCkge1xyXG4gICAgLy8gb3JkZXIgdGhlIGZyYW1lcyBiYXNlZCBvbiB0aGVpcnMgZGltZW5zaW9uIGluZGljZXNcclxuICAgIC8vIGZpcnN0IGluZGV4IGlzIHRoZSBtb3N0IGltcG9ydGFudC5cclxuICAgIC8vIDEsMSwxLDEgd2lsbGwgYmUgZmlyc3RcclxuICAgIC8vIDEsMSwyLDEgd2lsbCBiZSBuZXh0XHJcbiAgICAvLyAxLDEsMiwzIHdpbGwgYmUgbmV4dFxyXG4gICAgLy8gMSwxLDMsMSB3aWwgYmUgbmV4dFxyXG4gICAgaWYgKHRoaXMuX2ZyYW1lWzBdLmRpbWVuc2lvbkluZGV4VmFsdWVzKSB7XHJcbiAgICAgIHRoaXMuX2ZyYW1lLnNvcnQodGhpcy5fb3JkZXJGcmFtZU9uRGltZW5zaW9uSW5kaWNlc0FycmF5U29ydCk7XHJcblxyXG4gICAgLy8gZWxzZSBvcmRlciB3aXRoIGltYWdlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvblxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdGhpcy5fZnJhbWVbMF0uaW1hZ2VQb3NpdGlvbiAmJiB0aGlzLl9mcmFtZVswXS5pbWFnZU9yaWVudGF0aW9uICYmXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzFdICYmXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzFdLmltYWdlUG9zaXRpb24gJiYgdGhpcy5fZnJhbWVbMV0uaW1hZ2VPcmllbnRhdGlvbiAmJlxyXG4gICAgICB0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uLmpvaW4oKSAhPT0gdGhpcy5fZnJhbWVbMV0uaW1hZ2VQb3NpdGlvbi5qb2luKCkpIHtcclxuICAgICAgLy8gY29tcHV0ZSBhbmQgc29ydCBieSBkaXN0IGluIHRoaXMgc2VyaWVzXHJcbiAgICAgIHRoaXMuX2ZyYW1lLm1hcCh0aGlzLl9jb21wdXRlRGlzdGFuY2VBcnJheU1hcC5iaW5kKG51bGwsIHRoaXMuX3pDb3NpbmUpKTtcclxuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0RGlzdGFuY2VBcnJheVNvcnQpO1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdGhpcy5fZnJhbWVbMF0uaW5zdGFuY2VOdW1iZXIgIT09IG51bGwgJiZcclxuICAgICAgdGhpcy5fZnJhbWVbMV0gJiYgdGhpcy5fZnJhbWVbMV0uaW5zdGFuY2VOdW1iZXIgIT09IG51bGwgJiZcclxuICAgICAgdGhpcy5fZnJhbWVbMF0uaW5zdGFuY2VOdW1iZXIgIT09IHRoaXMuX2ZyYW1lWzFdLmluc3RhbmNlTnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuX2ZyYW1lLnNvcnQodGhpcy5fc29ydEluc3RhbmNlTnVtYmVyQXJyYXlTb3J0KTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLnNvcEluc3RhbmNlVUlEICYmXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzFdICYmIHRoaXMuX2ZyYW1lWzFdLnNvcEluc3RhbmNlVUlEICYmXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLnNvcEluc3RhbmNlVUlEICE9PSB0aGlzLl9mcmFtZVsxXS5zb3BJbnN0YW5jZVVJRCkge1xyXG4gICAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX3NvcnRTb3BJbnN0YW5jZVVJREFycmF5U29ydCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZnJhbWVbMF0pO1xyXG4gICAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZnJhbWVbMV0pO1xyXG4gICAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZnJhbWVbMF0uaW5zdGFuY2VOdW1iZXIgIT09IG51bGwgJiYgdHJ1ZSk7XHJcbiAgICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyhcclxuICAgICAgLy8gdGhpcy5fZnJhbWVbMF0uaW5zdGFuY2VOdW1iZXIgIT09IHRoaXMuX2ZyYW1lWzFdLmluc3RhbmNlTnVtYmVyKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdkbyBub3Qga25vdyBob3cgdG8gb3JkZXIgdGhlIGZyYW1lcy4uLicpO1xyXG4gICAgICAvLyBlbHNlIHNsaWNlIGxvY2F0aW9uXHJcbiAgICAgIC8vIGltYWdlIG51bWJlclxyXG4gICAgICAvLyBPUkRFUklORyBCQVNFRCBPTiBpbnN0YW5jZSBudW1iZXJcclxuICAgICAgLy8gX29yZGVyaW5nID0gJ2luc3RhbmNlX251bWJlcic7XHJcbiAgICAgIC8vIGZpcnN0X2ltYWdlLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgLy8gcmV0dXJuIGFbXCJpbnN0YW5jZV9udW1iZXJcIl0tYltcImluc3RhbmNlX251bWJlclwiXX0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29tcHV0ZVNwYWNpbmcoKSB7XHJcbiAgICB0aGlzLnh5U3BhY2luZygpO1xyXG4gICAgdGhpcy56U3BhY2luZygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBzdGFjayB6IHNwYWNpbmdcclxuICAgKi9cclxuICB6U3BhY2luZygpIHtcclxuICAgIGlmICh0aGlzLl9udW1iZXJPZkZyYW1lcyA+IDEpIHtcclxuICAgICAgaWYgKHRoaXMuX2ZyYW1lWzBdLnBpeGVsU3BhY2luZyAmJiB0aGlzLl9mcmFtZVswXS5waXhlbFNwYWNpbmdbMl0pIHtcclxuICAgICAgICB0aGlzLl9zcGFjaW5nLnogPSB0aGlzLl9mcmFtZVswXS5waXhlbFNwYWNpbmdbMl07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gY29tcHV0ZSBhbmQgc29ydCBieSBkaXN0IGluIHRoaXMgc2VyaWVzXHJcbiAgICAgICAgdGhpcy5fZnJhbWUubWFwKFxyXG4gICAgICAgICAgdGhpcy5fY29tcHV0ZURpc3RhbmNlQXJyYXlNYXAuYmluZChudWxsLCB0aGlzLl96Q29zaW5lKSk7XHJcblxyXG4gICAgICAgIC8vIGlmIGRpc3RhbmNlcyBhcmUgZGlmZmVyZW50LCByZS1zb3J0IGFycmF5XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lWzFdLmRpc3QgIT09IHRoaXMuX2ZyYW1lWzBdLmRpc3QpIHtcclxuICAgICAgICAgIHRoaXMuX2ZyYW1lLnNvcnQodGhpcy5fc29ydERpc3RhbmNlQXJyYXlTb3J0KTtcclxuICAgICAgICAgIHRoaXMuX3NwYWNpbmcueiA9IHRoaXMuX2ZyYW1lWzFdLmRpc3QgLSB0aGlzLl9mcmFtZVswXS5kaXN0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXMpIHtcclxuICAgICAgICAgIHRoaXMuX3NwYWNpbmcueiA9IHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZnJhbWVbMF0uc2xpY2VUaGlja25lc3MpIHtcclxuICAgICAgICAgIHRoaXMuX3NwYWNpbmcueiA9IHRoaXMuX2ZyYW1lWzBdLnNsaWNlVGhpY2tuZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNwYWNpbmdcclxuICAgIC8vIGNhbiBub3QgYmUgMCBpZiBub3QgbWF0cml4IGNhbiBub3QgYmUgaW52ZXJ0ZWQuXHJcbiAgICBpZiAodGhpcy5fc3BhY2luZy56ID09PSAwKSB7XHJcbiAgICAgIHRoaXMuX3NwYWNpbmcueiA9IDE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAgRlJBTUUgQ0FOIERPIElUXHJcbiAgICovXHJcbiAgeHlTcGFjaW5nKCkge1xyXG4gICAgaWYgKHRoaXMuX2ZyYW1lICYmXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzBdKSB7XHJcbiAgICAgIGxldCBzcGFjaW5nWFkgPSB0aGlzLl9mcmFtZVswXS5zcGFjaW5nWFkoKTtcclxuICAgICAgdGhpcy5fc3BhY2luZy54ID0gc3BhY2luZ1hZWzBdO1xyXG4gICAgICB0aGlzLl9zcGFjaW5nLnkgPSBzcGFjaW5nWFlbMV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kIG1pbiBhbmQgbWF4IGludGVuc2l0aWVzIGFtb25nIGFsbCBmcmFtZXMuXHJcbiAgICovXHJcbiAgY29tcHV0ZU1pbk1heEludGVuc2l0aWVzKCkge1xyXG4gICAgLy8gd2hhdCBhYm91dCBjb2xvcnMhISEhP1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9mcmFtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAvLyBnZXQgbWluL21heFxyXG4gICAgICB0aGlzLl9taW5NYXhbMF0gPSBNYXRoLm1pbih0aGlzLl9taW5NYXhbMF0sIHRoaXMuX2ZyYW1lW2ldLm1pbk1heFswXSk7XHJcbiAgICAgIHRoaXMuX21pbk1heFsxXSA9IE1hdGgubWF4KHRoaXMuX21pbk1heFsxXSwgdGhpcy5fZnJhbWVbaV0ubWluTWF4WzFdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgSUpLIHRvIExQUyBhbmQgaW52ZXJ0IHRyYW5zZm9ybXNcclxuICAgKi9cclxuICBjb21wdXRlSUpLMkxQUygpIHtcclxuICAgIC8vIGlqayB0byBscHNcclxuICAgIHRoaXMuX2lqazJMUFMgPSBDb3JlVXRpbHMuaWprMkxQUyhcclxuICAgICAgdGhpcy5feENvc2luZSwgdGhpcy5feUNvc2luZSwgdGhpcy5fekNvc2luZSxcclxuICAgICAgdGhpcy5fc3BhY2luZywgdGhpcy5fb3JpZ2luLFxyXG4gICAgICB0aGlzLl9yZWdNYXRyaXhcclxuICAgICk7XHJcblxyXG4gICAgLy8gbHBzIDIgaWprXHJcbiAgICB0aGlzLl9scHMySUpLID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIHRoaXMuX2xwczJJSksuZ2V0SW52ZXJzZSh0aGlzLl9pamsyTFBTKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgTFBTIHRvIEFBQkIgYW5kIGludmVydCB0cmFuc2Zvcm1zXHJcbiAgICovXHJcbiAgY29tcHV0ZUxQUzJBQUJCKCkge1xyXG4gICAgdGhpcy5fYWFiYjJMUFMgPSBDb3JlVXRpbHMuYWFiYjJMUFMoXHJcbiAgICAgIHRoaXMuX3hDb3NpbmUsIHRoaXMuX3lDb3NpbmUsIHRoaXMuX3pDb3NpbmUsXHJcbiAgICAgIHRoaXMuX29yaWdpblxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLl9scHMyQUFCQiA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICB0aGlzLl9scHMyQUFCQi5nZXRJbnZlcnNlKHRoaXMuX2FhYmIyTFBTKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIHN0YWNrc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBzdGFja1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBtZXJnZShzdGFjaykge1xyXG4gICAgLy8gYWxzbyBtYWtlIHN1cmUgeC95L3ogY29zaW5lcyBhcmUgYSBtYXRjaCFcclxuICAgIGlmICh0aGlzLl9zdGFja0lEID09PSBzdGFjay5zdGFja0lEKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1lcmdlTW9kZWxzKHRoaXMuX2ZyYW1lLCBzdGFjay5mcmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYWNrIGN1cnJlbnQgc3RhY2sgcGl4ZWwgZGF0YSBpbnRvIDggYml0cyBhcnJheSBidWZmZXJzXHJcbiAgICovXHJcbiAgcGFjaygpIHtcclxuICAgIC8vIEdldCB0b3RhbCBudW1iZXIgb2Ygdm94ZWxzXHJcbiAgICBjb25zdCBuYlZveGVscyA9XHJcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueCAqIHRoaXMuX2RpbWVuc2lvbnNJSksueSAqIHRoaXMuX2RpbWVuc2lvbnNJSksuejtcclxuXHJcbiAgICAvLyBQYWNraW5nIHN0eWxlXHJcbiAgICBpZiAodGhpcy5fYml0c0FsbG9jYXRlZCA9PT0gMTYgJiYgdGhpcy5fbnVtYmVyT2ZDaGFubmVscyA9PT0gMSkge1xyXG4gICAgICB0aGlzLl9wYWNrZWRQZXJQaXhlbCA9IDI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgdGV4dHVyZXMgd2UgbmVlZFxyXG4gICAgY29uc3QgdGV4dHVyZURpbWVuc2lvbiA9IHRoaXMuX3RleHR1cmVTaXplICogdGhpcy5fdGV4dHVyZVNpemU7XHJcbiAgICBjb25zdCByZXF1aXJlZFRleHR1cmVzID1cclxuICAgICAgTWF0aC5jZWlsKG5iVm94ZWxzIC8gKHRleHR1cmVEaW1lbnNpb24gKiB0aGlzLl9wYWNrZWRQZXJQaXhlbCkpO1xyXG4gICAgbGV0IHZveGVsSW5kZXhTdGFydCA9IDA7XHJcbiAgICBsZXQgdm94ZWxJbmRleFN0b3AgPSB0aGlzLl9wYWNrZWRQZXJQaXhlbCAqIHRleHR1cmVEaW1lbnNpb247XHJcbiAgICBpZiAodm94ZWxJbmRleFN0b3AgPiBuYlZveGVscykge1xyXG4gICAgICB2b3hlbEluZGV4U3RvcCA9IG5iVm94ZWxzO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCByZXF1aXJlZFRleHR1cmVzOyBpaSsrKSB7XHJcbiAgICAgIGxldCBwYWNrZWQgPVxyXG4gICAgICAgIHRoaXMuX3BhY2tUbzhCaXRzKFxyXG4gICAgICAgICAgdGhpcy5fbnVtYmVyT2ZDaGFubmVscyxcclxuICAgICAgICAgIHRoaXMuX2ZyYW1lLFxyXG4gICAgICAgICAgdGhpcy5fdGV4dHVyZVNpemUsXHJcbiAgICAgICAgICB2b3hlbEluZGV4U3RhcnQsXHJcbiAgICAgICAgICB2b3hlbEluZGV4U3RvcCk7XHJcbiAgICAgIHRoaXMuX3RleHR1cmVUeXBlID0gcGFja2VkLnRleHR1cmVUeXBlO1xyXG4gICAgICB0aGlzLl9yYXdEYXRhLnB1c2gocGFja2VkLmRhdGEpO1xyXG5cclxuICAgICAgdm94ZWxJbmRleFN0YXJ0ICs9IHRoaXMuX3BhY2tlZFBlclBpeGVsICogdGV4dHVyZURpbWVuc2lvbjtcclxuICAgICAgdm94ZWxJbmRleFN0b3AgKz0gdGhpcy5fcGFja2VkUGVyUGl4ZWwgKiB0ZXh0dXJlRGltZW5zaW9uO1xyXG4gICAgICBpZiAodm94ZWxJbmRleFN0b3AgPiBuYlZveGVscykge1xyXG4gICAgICAgIHZveGVsSW5kZXhTdG9wID0gbmJWb3hlbHM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wYWNrZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFjayBmcmFtZSBkYXRhIHRvIDMyIGJpdHMgdGV4dHVyZVxyXG4gICAqIEBwYXJhbSB7Kn0gY2hhbm5lbHNcclxuICAgKiBAcGFyYW0geyp9IGZyYW1lXHJcbiAgICogQHBhcmFtIHsqfSB0ZXh0dXJlU2l6ZVxyXG4gICAqIEBwYXJhbSB7Kn0gc3RhcnRWb3hlbFxyXG4gICAqIEBwYXJhbSB7Kn0gc3RvcFZveGVsXHJcbiAgICovXHJcbiAgX3BhY2tUbzhCaXRzKGNoYW5uZWxzLCBmcmFtZSwgdGV4dHVyZVNpemUsIHN0YXJ0Vm94ZWwsIHN0b3BWb3hlbCkge1xyXG4gICAgY29uc3QgcGFja2VkID0ge1xyXG4gICAgICB0ZXh0dXJlVHlwZTogbnVsbCxcclxuICAgICAgZGF0YTogbnVsbCxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgYml0c0FsbG9jYXRlZCA9IGZyYW1lWzBdLmJpdHNBbGxvY2F0ZWQ7XHJcbiAgICBjb25zdCBwaXhlbFR5cGUgPSBmcmFtZVswXS5waXhlbFR5cGU7XHJcblxyXG4gICAgLy8gdHJhbnNmb3JtIHNpZ25lZCB0byB1bnNpZ25lZCBmb3IgY29udmVuaWVuY2VcclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgaWYgKHRoaXMuX21pbk1heFswXSA8IDApIHtcclxuICAgICAgb2Zmc2V0IC09IHRoaXMuX21pbk1heFswXTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcGFja0luZGV4ID0gMDtcclxuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcclxuICAgIGxldCBpbkZyYW1lSW5kZXggPSAwO1xyXG4gICAgLy8gZnJhbWUgc2hvdWxkIHJldHVybiBpdCFcclxuICAgIGNvbnN0IGZyYW1lRGltZW5zaW9uID0gZnJhbWVbMF0ucm93cyAqIGZyYW1lWzBdLmNvbHVtbnM7XHJcblxyXG4gICAgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDggJiYgY2hhbm5lbHMgPT09IDEgfHwgYml0c0FsbG9jYXRlZCA9PT0gMSkge1xyXG4gICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiAxKTtcclxuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xyXG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xyXG4gICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xyXG5cclxuICAgICAgICBkYXRhW3BhY2tJbmRleF0gPSBvZmZzZXQgKyBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcclxuICAgICAgICBwYWNrSW5kZXgrKztcclxuICAgICAgfVxyXG4gICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5MdW1pbmFuY2VGb3JtYXQ7XHJcbiAgICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcclxuICAgIH0gZWxzZSBpZiAoYml0c0FsbG9jYXRlZCA9PT0gMTYgJiYgY2hhbm5lbHMgPT09IDEpIHtcclxuICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlU2l6ZSAqIHRleHR1cmVTaXplICogNCk7XHJcbiAgICAgIGxldCBjb29yZGluYXRlID0gMDtcclxuICAgICAgbGV0IGNoYW5uZWxPZmZzZXQgPSAwO1xyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xyXG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xyXG4gICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xyXG5cclxuXHJcbiAgICAgICAgbGV0IHJhdyA9IG9mZnNldCArIGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdO1xyXG4gICAgICAgIGRhdGFbNCAqIGNvb3JkaW5hdGUgKyAyICogY2hhbm5lbE9mZnNldF0gPSByYXcgJiAweDAwRkY7XHJcbiAgICAgICAgZGF0YVs0ICogY29vcmRpbmF0ZSArIDIgKiBjaGFubmVsT2Zmc2V0ICsgMV0gPSAocmF3ID4+PiA4KSAmIDB4MDBGRjtcclxuXHJcbiAgICAgICAgcGFja0luZGV4Kys7XHJcbiAgICAgICAgY29vcmRpbmF0ZSA9IE1hdGguZmxvb3IocGFja0luZGV4IC8gMik7XHJcbiAgICAgICAgY2hhbm5lbE9mZnNldCA9IHBhY2tJbmRleCAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkFGb3JtYXQ7XHJcbiAgICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcclxuICAgIH0gZWxzZSBpZiAoYml0c0FsbG9jYXRlZCA9PT0gMzIgJiYgY2hhbm5lbHMgPT09IDEgJiYgcGl4ZWxUeXBlID09PSAwKSB7XHJcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDQpO1xyXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XHJcbiAgICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XHJcbiAgICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XHJcblxyXG4gICAgICAgIGxldCByYXcgPSBvZmZzZXQgKyBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcclxuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXhdID0gcmF3ICYgMHgwMDAwMDBGRjtcclxuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAxXSA9IChyYXcgPj4+IDgpICYgMHgwMDAwMDBGRjtcclxuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAyXSA9IChyYXcgPj4+IDE2KSAmIDB4MDAwMDAwRkY7XHJcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgM10gPSAocmF3ID4+PiAyNCkgJiAweDAwMDAwMEZGO1xyXG5cclxuICAgICAgICBwYWNrSW5kZXgrKztcclxuICAgICAgfVxyXG4gICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JBRm9ybWF0O1xyXG4gICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XHJcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDMyICYmIGNoYW5uZWxzID09PSAxICYmIHBpeGVsVHlwZSA9PT0gMSkge1xyXG4gICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiA0KTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcclxuICAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcclxuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcclxuXHJcbiAgICAgICAgbGV0IHJhdyA9IG9mZnNldCArIGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdO1xyXG4gICAgICAgIGxldCBiaXRTdHJpbmcgPSBiaW5hcnlTdHJpbmcocmF3KTtcclxuICAgICAgICBsZXQgYml0U3RyaW5nQXJyYXkgPSBiaXRTdHJpbmcubWF0Y2goLy57MSw4fS9nKTtcclxuXHJcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4XSA9IHBhcnNlSW50KGJpdFN0cmluZ0FycmF5WzBdLCAyKTtcclxuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAxXSA9IHBhcnNlSW50KGJpdFN0cmluZ0FycmF5WzFdLCAyKTtcclxuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAyXSA9IHBhcnNlSW50KGJpdFN0cmluZ0FycmF5WzJdLCAyKTtcclxuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAzXSA9IHBhcnNlSW50KGJpdFN0cmluZ0FycmF5WzNdLCAyKTtcclxuXHJcbiAgICAgICAgcGFja0luZGV4Kys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkFGb3JtYXQ7XHJcbiAgICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcclxuICAgIH0gZWxzZSBpZiAoYml0c0FsbG9jYXRlZCA9PT0gOCAmJiBjaGFubmVscyA9PT0gMykge1xyXG4gICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiAzKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcclxuICAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcclxuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcclxuXHJcbiAgICAgICAgZGF0YVszICogcGFja0luZGV4XSA9XHJcbiAgICAgICAgICBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleF07XHJcbiAgICAgICAgZGF0YVszICogcGFja0luZGV4ICsgMV0gPVxyXG4gICAgICAgICAgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXggKyAxXTtcclxuICAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXggKyAyXSA9XHJcbiAgICAgICAgICBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleCArIDJdO1xyXG4gICAgICAgIHBhY2tJbmRleCsrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JGb3JtYXQ7XHJcbiAgICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFja2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFjayB3b3JsZCBjZW50ZXJcclxuICAgKlxyXG4gICAqQHJldHVybiB7Kn1cclxuICAgKi9cclxuICB3b3JsZENlbnRlcigpIHtcclxuICAgIGxldCBjZW50ZXIgPSB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSy5jbG9uZSgpLmFkZFNjYWxhcigtMC41KVxyXG4gICAgICAuYXBwbHlNYXRyaXg0KHRoaXMuX2lqazJMUFMpO1xyXG4gICAgcmV0dXJuIGNlbnRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhY2sgd29ybGQgYm91bmRpbmcgYm94XHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICB3b3JsZEJvdW5kaW5nQm94KCkge1xyXG4gICAgbGV0IGJib3ggPSBbXHJcbiAgICAgIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NSU5fVkFMVUUsXHJcbiAgICAgIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NSU5fVkFMVUUsXHJcbiAgICAgIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NSU5fVkFMVUUsXHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnN0IGRpbXMgPSB0aGlzLl9kaW1lbnNpb25zSUpLO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRpbXMueDsgaSArPSBkaW1zLngpIHtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gZGltcy55OyBqICs9IGRpbXMueSkge1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDw9IGRpbXMuejsgayArPSBkaW1zLnopIHtcclxuICAgICAgICAgIGxldCB3b3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKGksIGosIGspLmFwcGx5TWF0cml4NCh0aGlzLl9pamsyTFBTKTtcclxuICAgICAgICAgIGJib3ggPSBbXHJcbiAgICAgICAgICAgIE1hdGgubWluKGJib3hbMF0sIHdvcmxkLngpLCBNYXRoLm1heChiYm94WzFdLCB3b3JsZC54KSwgLy8geCBtaW4vbWF4XHJcbiAgICAgICAgICAgIE1hdGgubWluKGJib3hbMl0sIHdvcmxkLnkpLCBNYXRoLm1heChiYm94WzNdLCB3b3JsZC55KSxcclxuICAgICAgICAgICAgTWF0aC5taW4oYmJveFs0XSwgd29ybGQueiksIE1hdGgubWF4KGJib3hbNV0sIHdvcmxkLnopLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiYm94O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IEFBQkIgc2l6ZSBpbiBMUFMgc3BhY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIEFBQkJveCgpIHtcclxuICAgIGxldCB3b3JsZDAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLmFkZFNjYWxhcigtMC41KVxyXG4gICAgICAuYXBwbHlNYXRyaXg0KHRoaXMuX2lqazJMUFMpXHJcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5fbHBzMkFBQkIpO1xyXG5cclxuICAgIGxldCB3b3JsZDcgPSB0aGlzLl9kaW1lbnNpb25zSUpLLmNsb25lKCkuYWRkU2NhbGFyKC0wLjUpXHJcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5faWprMkxQUylcclxuICAgICAgLmFwcGx5TWF0cml4NCh0aGlzLl9scHMyQUFCQik7XHJcblxyXG4gICAgbGV0IG1pbkJCb3ggPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgTWF0aC5hYnMod29ybGQwLnggLSB3b3JsZDcueCksXHJcbiAgICAgIE1hdGguYWJzKHdvcmxkMC55IC0gd29ybGQ3LnkpLFxyXG4gICAgICBNYXRoLmFicyh3b3JsZDAueiAtIHdvcmxkNy56KVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gbWluQkJveDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBBQUJCIGNlbnRlciBpbiBMUFMgc3BhY2VcclxuICAgKi9cclxuICBjZW50ZXJBQUJCb3goKSB7XHJcbiAgICBsZXQgY2VudGVyQkJveCA9IHRoaXMud29ybGRDZW50ZXIoKTtcclxuICAgIGNlbnRlckJCb3guYXBwbHlNYXRyaXg0KHRoaXMuX2xwczJBQUJCKTtcclxuICAgIHJldHVybiBjZW50ZXJCQm94O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGluZGV4SW5EaW1lbnNpb25zKGluZGV4LCBkaW1lbnNpb25zKSB7XHJcbiAgICBpZiAoaW5kZXgueCA+PSAwICYmXHJcbiAgICAgICAgIGluZGV4LnkgPj0gMCAmJlxyXG4gICAgICAgICBpbmRleC56ID49IDAgJiZcclxuICAgICAgICAgaW5kZXgueCA8IGRpbWVuc2lvbnMueCAmJlxyXG4gICAgICAgICBpbmRleC55IDwgZGltZW5zaW9ucy55ICYmXHJcbiAgICAgICAgIGluZGV4LnogPCBkaW1lbnNpb25zLnopIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgX2FycmF5VG9WZWN0b3IzKGFycmF5LCBpbmRleCkge1xyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICBhcnJheVtpbmRleF0sXHJcbiAgICAgIGFycmF5W2luZGV4ICsgMV0sXHJcbiAgICAgIGFycmF5W2luZGV4ICsgMl1cclxuICAgICAgKTtcclxuICB9XHJcblxyXG4gIF9vcmRlckZyYW1lT25EaW1lbnNpb25JbmRpY2VzQXJyYXlTb3J0KGEsIGIpIHtcclxuICAgIGlmICgnZGltZW5zaW9uSW5kZXhWYWx1ZXMnIGluIGEgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEuZGltZW5zaW9uSW5kZXhWYWx1ZXMpID09PSAnW29iamVjdCBBcnJheV0nICYmICdkaW1lbnNpb25JbmRleFZhbHVlcycgaW4gYiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYi5kaW1lbnNpb25JbmRleFZhbHVlcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmRpbWVuc2lvbkluZGV4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHBhcnNlSW50KGEuZGltZW5zaW9uSW5kZXhWYWx1ZXNbaV0sIDEwKSA+IHBhcnNlSW50KGIuZGltZW5zaW9uSW5kZXhWYWx1ZXNbaV0sIDEwKSkge1xyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJzZUludChhLmRpbWVuc2lvbkluZGV4VmFsdWVzW2ldLCAxMCkgPCBwYXJzZUludChiLmRpbWVuc2lvbkluZGV4VmFsdWVzW2ldLCAxMCkpIHtcclxuICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnT25lIG9mIHRoZSBmcmFtZXMgZG9lc25cXCd0IGhhdmUgYSBkaW1lbnNpb25JbmRleFZhbHVlcyBhcnJheS4nKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGEpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coYik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBfY29tcHV0ZURpc3RhbmNlQXJyYXlNYXAobm9ybWFsLCBmcmFtZSkge1xyXG4gICAgZnJhbWUuZGlzdCA9IGZyYW1lLmltYWdlUG9zaXRpb25bMF0gKiBub3JtYWwueCArXHJcbiAgICAgIGZyYW1lLmltYWdlUG9zaXRpb25bMV0gKiBub3JtYWwueSArXHJcbiAgICAgIGZyYW1lLmltYWdlUG9zaXRpb25bMl0gKiBub3JtYWwuejtcclxuICAgIHJldHVybiBmcmFtZTtcclxuICB9XHJcblxyXG4gIF9zb3J0RGlzdGFuY2VBcnJheVNvcnQoYSwgYikge1xyXG4gICAgcmV0dXJuIGEuZGlzdCAtIGIuZGlzdDtcclxuICB9XHJcbiAgX3NvcnRJbnN0YW5jZU51bWJlckFycmF5U29ydChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5pbnN0YW5jZU51bWJlciAtIGIuaW5zdGFuY2VOdW1iZXI7XHJcbiAgfVxyXG4gIF9zb3J0U29wSW5zdGFuY2VVSURBcnJheVNvcnQoYSwgYikge1xyXG4gICAgcmV0dXJuIGEuc29wSW5zdGFuY2VVSUQgLSBiLnNvcEluc3RhbmNlVUlEO1xyXG4gIH1cclxuXHJcbiAgc2V0IG51bWJlck9mQ2hhbm5lbHMobnVtYmVyT2ZDaGFubmVscykge1xyXG4gICAgdGhpcy5fbnVtYmVyT2ZDaGFubmVscyA9IG51bWJlck9mQ2hhbm5lbHM7XHJcbiAgfVxyXG5cclxuICBnZXQgbnVtYmVyT2ZDaGFubmVscygpIHtcclxuICAgIHJldHVybiB0aGlzLl9udW1iZXJPZkNoYW5uZWxzO1xyXG4gIH1cclxuXHJcbiAgc2V0IGZyYW1lKGZyYW1lKSB7XHJcbiAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGZyYW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xyXG4gIH1cclxuXHJcbiAgc2V0IHByZXBhcmVkKHByZXBhcmVkKSB7XHJcbiAgICB0aGlzLl9wcmVwYXJlZCA9IHByZXBhcmVkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHByZXBhcmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ByZXBhcmVkO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBhY2tlZChwYWNrZWQpIHtcclxuICAgIHRoaXMuX3BhY2tlZCA9IHBhY2tlZDtcclxuICB9XHJcblxyXG4gIGdldCBwYWNrZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFja2VkO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBhY2tlZFBlclBpeGVsKHBhY2tlZFBlclBpeGVsKSB7XHJcbiAgICB0aGlzLl9wYWNrZWRQZXJQaXhlbCA9IHBhY2tlZFBlclBpeGVsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBhY2tlZFBlclBpeGVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhY2tlZFBlclBpeGVsO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRpbWVuc2lvbnNJSksoZGltZW5zaW9uc0lKSykge1xyXG4gICAgdGhpcy5fZGltZW5zaW9uc0lKSyA9IGRpbWVuc2lvbnNJSks7XHJcbiAgfVxyXG5cclxuICBnZXQgZGltZW5zaW9uc0lKSygpIHtcclxuICAgIHJldHVybiB0aGlzLl9kaW1lbnNpb25zSUpLO1xyXG4gIH1cclxuXHJcbiAgc2V0IGhhbGZEaW1lbnNpb25zSUpLKGhhbGZEaW1lbnNpb25zSUpLKSB7XHJcbiAgICB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSyA9IGhhbGZEaW1lbnNpb25zSUpLO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhhbGZEaW1lbnNpb25zSUpLKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hhbGZEaW1lbnNpb25zSUpLO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJlZ01hdHJpeChyZWdNYXRyaXgpIHtcclxuICAgIHRoaXMuX3JlZ01hdHJpeCA9IHJlZ01hdHJpeDtcclxuICB9XHJcblxyXG4gIGdldCByZWdNYXRyaXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVnTWF0cml4O1xyXG4gIH1cclxuXHJcbiAgc2V0IGlqazJMUFMoaWprMkxQUykge1xyXG4gICAgdGhpcy5faWprMkxQUyA9IGlqazJMUFM7XHJcbiAgfVxyXG5cclxuICBnZXQgaWprMkxQUygpIHtcclxuICAgIHJldHVybiB0aGlzLl9pamsyTFBTO1xyXG4gIH1cclxuXHJcbiAgc2V0IGxwczJJSksobHBzMklKSykge1xyXG4gICAgdGhpcy5fbHBzMklKSyA9IGxwczJJSks7XHJcbiAgfVxyXG5cclxuICBnZXQgbHBzMklKSygpIHtcclxuICAgIHJldHVybiB0aGlzLl9scHMySUpLO1xyXG4gIH1cclxuXHJcbiAgc2V0IGxwczJBQUJCKGxwczJBQUJCKSB7XHJcbiAgICB0aGlzLl9scHMyQUFCQiA9IGxwczJBQUJCO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxwczJBQUJCKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xwczJBQUJCO1xyXG4gIH1cclxuXHJcbiAgc2V0IHRleHR1cmVTaXplKHRleHR1cmVTaXplKSB7XHJcbiAgICB0aGlzLl90ZXh0dXJlU2l6ZSA9IHRleHR1cmVTaXplO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHRleHR1cmVTaXplKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVTaXplO1xyXG4gIH1cclxuXHJcbiAgc2V0IHRleHR1cmVUeXBlKHRleHR1cmVUeXBlKSB7XHJcbiAgICB0aGlzLl90ZXh0dXJlVHlwZSA9IHRleHR1cmVUeXBlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVUeXBlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGJpdHNBbGxvY2F0ZWQoYml0c0FsbG9jYXRlZCkge1xyXG4gICAgdGhpcy5fYml0c0FsbG9jYXRlZCA9IGJpdHNBbGxvY2F0ZWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgYml0c0FsbG9jYXRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9iaXRzQWxsb2NhdGVkO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJhd0RhdGEocmF3RGF0YSkge1xyXG4gICAgdGhpcy5fcmF3RGF0YSA9IHJhd0RhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgcmF3RGF0YSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yYXdEYXRhO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHdpbmRvd1dpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd1dpZHRoO1xyXG4gIH1cclxuXHJcbiAgc2V0IHdpbmRvd1dpZHRoKHdpbmRvd1dpZHRoKSB7XHJcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IHdpbmRvd1dpZHRoO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHdpbmRvd0NlbnRlcigpIHtcclxuICAgIHJldHVybiB0aGlzLl93aW5kb3dDZW50ZXI7XHJcbiAgfVxyXG5cclxuICBzZXQgd2luZG93Q2VudGVyKHdpbmRvd0NlbnRlcikge1xyXG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gd2luZG93Q2VudGVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlc2NhbGVTbG9wZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNjYWxlU2xvcGU7XHJcbiAgfVxyXG5cclxuICBzZXQgcmVzY2FsZVNsb3BlKHJlc2NhbGVTbG9wZSkge1xyXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gcmVzY2FsZVNsb3BlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlc2NhbGVJbnRlcmNlcHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZUludGVyY2VwdDtcclxuICB9XHJcblxyXG4gIHNldCByZXNjYWxlSW50ZXJjZXB0KHJlc2NhbGVJbnRlcmNlcHQpIHtcclxuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSByZXNjYWxlSW50ZXJjZXB0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHhDb3NpbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5feENvc2luZTtcclxuICB9XHJcblxyXG4gIHNldCB4Q29zaW5lKHhDb3NpbmUpIHtcclxuICAgIHRoaXMuX3hDb3NpbmUgPSB4Q29zaW5lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHlDb3NpbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5feUNvc2luZTtcclxuICB9XHJcblxyXG4gIHNldCB5Q29zaW5lKHlDb3NpbmUpIHtcclxuICAgIHRoaXMuX3lDb3NpbmUgPSB5Q29zaW5lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHpDb3NpbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fekNvc2luZTtcclxuICB9XHJcblxyXG4gIHNldCB6Q29zaW5lKHpDb3NpbmUpIHtcclxuICAgIHRoaXMuX3pDb3NpbmUgPSB6Q29zaW5lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1pbk1heCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9taW5NYXg7XHJcbiAgfVxyXG5cclxuICBzZXQgbWluTWF4KG1pbk1heCkge1xyXG4gICAgdGhpcy5fbWluTWF4ID0gbWluTWF4O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YWNrSUQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tJRDtcclxuICB9XHJcblxyXG4gIHNldCBzdGFja0lEKHN0YWNrSUQpIHtcclxuICAgIHRoaXMuX3N0YWNrSUQgPSBzdGFja0lEO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBpeGVsVHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9waXhlbFR5cGU7XHJcbiAgfVxyXG5cclxuICBzZXQgcGl4ZWxUeXBlKHBpeGVsVHlwZSkge1xyXG4gICAgdGhpcy5fcGl4ZWxUeXBlID0gcGl4ZWxUeXBlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBpeGVsUmVwcmVzZW50YXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBwaXhlbFJlcHJlc2VudGF0aW9uKHBpeGVsUmVwcmVzZW50YXRpb24pIHtcclxuICAgIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb24gPSBwaXhlbFJlcHJlc2VudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IGludmVydChpbnZlcnQpIHtcclxuICAgIHRoaXMuX2ludmVydCA9IGludmVydDtcclxuICB9XHJcblxyXG4gIGdldCBpbnZlcnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW52ZXJ0O1xyXG4gIH1cclxuXHJcbiAgc2V0IG1vZGFsaXR5KG1vZGFsaXR5KSB7XHJcbiAgICB0aGlzLl9tb2RhbGl0eSA9IG1vZGFsaXR5O1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1vZGFsaXR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21vZGFsaXR5O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJpZ2h0SGFuZGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0SGFuZGVkO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJpZ2h0SGFuZGVkKHJpZ2h0SGFuZGVkKSB7XHJcbiAgICB0aGlzLl9yaWdodEhhbmRlZCA9IHJpZ2h0SGFuZGVkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNwYWNpbmdCZXR3ZWVuU2xpY2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNwYWNpbmdCZXR3ZWVuU2xpY2VzKHNwYWNpbmdCZXR3ZWVuU2xpY2VzKSB7XHJcbiAgICB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcyA9IHNwYWNpbmdCZXR3ZWVuU2xpY2VzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNlZ21lbnRhdGlvblNlZ21lbnRzKHNlZ21lbnRhdGlvblNlZ21lbnRzKSB7XHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25TZWdtZW50cyA9IHNlZ21lbnRhdGlvblNlZ21lbnRzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNlZ21lbnRhdGlvblNlZ21lbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNlZ21lbnRhdGlvblR5cGUoc2VnbWVudGF0aW9uVHlwZSkge1xyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IHNlZ21lbnRhdGlvblR5cGU7XHJcbiAgfVxyXG5cclxuICBnZXQgc2VnbWVudGF0aW9uVHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZWdtZW50YXRpb25UeXBlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNlZ21lbnRhdGlvbkxVVChzZWdtZW50YXRpb25MVVQpIHtcclxuICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVCA9IHNlZ21lbnRhdGlvbkxVVDtcclxuICB9XHJcblxyXG4gIGdldCBzZWdtZW50YXRpb25MVVQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uTFVUO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNlZ21lbnRhdGlvbkxVVE8oc2VnbWVudGF0aW9uTFVUTykge1xyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uTFVUTyA9IHNlZ21lbnRhdGlvbkxVVE87XHJcbiAgfVxyXG5cclxuICBnZXQgc2VnbWVudGF0aW9uTFVUTygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZWdtZW50YXRpb25MVVRPO1xyXG4gIH1cclxuXHJcbiAgLy8gREVQUkVDQVRFRCBGVU5DVElPTlxyXG5cclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZCBmb3IgY29yZS51dGlscy52YWx1ZVxyXG4gICAqXHJcbiAgICogR2V0IHZveGVsIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBzdGFja1xyXG4gICAqIEBwYXJhbSB7Kn0gY29vcmRpbmF0ZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdGF0aWMgdmFsdWUoc3RhY2ssIGNvb3JkaW5hdGUpIHtcclxuICAgIGNvbnNvbGUud2FybihcclxuICAgICAgYG1vZGVscy5zdGFjay52YWx1ZSBpcyBkZXByZWNhdGVkLlxyXG4gICAgICAgUGxlYXNlIHVzZSBjb3JlLnV0aWxzLnZhbHVlIGluc3RlYWQuYCk7XHJcbiAgICByZXR1cm4gQ29yZVV0aWxzLnZhbHVlKHN0YWNrLCBjb29yZGluYXRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXByZWNhdGVkIGZvciBjb3JlLnV0aWxzLnJlc2NhbGVTbG9wZUludGVyY2VwdFxyXG4gICAqXHJcbiAgICogQXBwbHkgc2xvcGUvaW50ZXJjZXB0IHRvIGEgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICogQHBhcmFtIHsqfSBzbG9wZVxyXG4gICAqIEBwYXJhbSB7Kn0gaW50ZXJjZXB0XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHN0YXRpYyB2YWx1ZVJlc2NhbGVTbG9wZUludGVyY2VwdCh2YWx1ZSwgc2xvcGUsIGludGVyY2VwdCkge1xyXG4gICAgY29uc29sZS53YXJuKFxyXG4gICAgICBgbW9kZWxzLnN0YWNrLnZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0IGlzIGRlcHJlY2F0ZWQuXHJcbiAgICAgICBQbGVhc2UgdXNlIGNvcmUudXRpbHMucmVzY2FsZVNsb3BlSW50ZXJjZXB0IGluc3RlYWQuYCk7XHJcbiAgICByZXR1cm4gQ29yZVV0aWxzLnJlc2NhbGVTbG9wZUludGVyY2VwdChcclxuICAgICAgdmFsdWUsIHNsb3BlLCBpbnRlcmNlcHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGRlcHJlY2F0ZWQgZm9yIGNvcmUudXRpbHMud29ybGRUb0RhdGFcclxuICAgKlxyXG4gICAqIFRyYW5zZm9ybSBjb29yZGluYXRlcyBmcm9tIHdvcmxkIGNvb3JkaW5hdGUgdG8gZGF0YVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBzdGFja1xyXG4gICAqIEBwYXJhbSB7Kn0gd29ybGRDb29yZGluYXRlc1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdGF0aWMgd29ybGRUb0RhdGEoc3RhY2ssIHdvcmxkQ29vcmRpbmF0ZXMpIHtcclxuICAgIGNvbnNvbGUud2FybihcclxuICAgICAgYG1vZGVscy5zdGFjay53b3JsZFRvRGF0YSBpcyBkZXByZWNhdGVkLlxyXG4gICAgICAgUGxlYXNlIHVzZSBjb3JlLnV0aWxzLndvcmxkVG9EYXRhIGluc3RlYWQuYCk7XHJcblxyXG4gICAgcmV0dXJuIENvcmVVdGlscy53b3JsZFRvRGF0YShzdGFjay5fbHBzMklKSywgd29ybGRDb29yZGluYXRlcyk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBTbGljZXIgd2F5IHRvIGhhbmRsZSBpbWFnZXNcclxuLy8gc2hvdWxkIGZvbGxvdyBpdC4uLlxyXG4gLy8gODk3ICAgaWYgKCAodGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gIT0gaWR4U2VyaWVzSW5zdGFuY2VVSUQgJiYgdGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gPj0gMCAmJiBpZHhTZXJpZXNJbnN0YW5jZVVJRCA+PSAwKSB8fFxyXG4gLy8gODk4ICAgICAgICAodGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSAhPSBpZHhDb250ZW50VGltZSAmJiB0aGlzLT5JbmRleENvbnRlbnRUaW1lW2tdID49IDAgJiYgaWR4Q29udGVudFRpbWUgPj0gMCkgfHxcclxuIC8vIDg5OSAgICAgICAgKHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gIT0gaWR4VHJpZ2dlclRpbWUgJiYgdGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSA+PSAwICYmIGlkeFRyaWdnZXJUaW1lID49IDApIHx8XHJcbiAvLyA5MDAgICAgICAgICh0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdICE9IGlkeEVjaG9OdW1iZXJzICYmIHRoaXMtPkluZGV4RWNob051bWJlcnNba10gPj0gMCAmJiBpZHhFY2hvTnVtYmVycyA+PSAwKSB8fFxyXG4gLy8gOTAxICAgICAgICAodGhpcy0+SW5kZXhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uW2tdICE9IGlkeERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb24gICYmIHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSA+PSAwICYmIGlkeERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb24gPj0gMCkgfHxcclxuIC8vIDkwMiAgICAgICAgKHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSAhPSBpZHhTbGljZUxvY2F0aW9uICYmIHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSA+PSAwICYmIGlkeFNsaWNlTG9jYXRpb24gPj0gMCkgfHxcclxuIC8vIDkwMyAgICAgICAgKHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gIT0gaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgJiYgdGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSA+PSAwICYmIGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ID49IDApIClcclxuIC8vIDkwNCAgICAge1xyXG4gLy8gOTA1ICAgICAgIGNvbnRpbnVlO1xyXG4gLy8gOTA2ICAgICB9XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIG1vZGVscy92b3hlbFxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc1ZveGVsIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX2lkID0gLTE7XHJcbiAgICB0aGlzLl93b3JsZENvb3JkaW5hdGVzID0gbnVsbDtcclxuICAgIHRoaXMuX2RhdGFDb29yZGluYXRlcyA9IG51bGw7XHJcbiAgICB0aGlzLl9zY3JlZW5Db29yZGluYXRlcyA9IG51bGw7XHJcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBzZXQgd29ybGRDb29yZGluYXRlcyh3b3JsZENvb3JkaW5hdGVzKSB7XHJcbiAgICB0aGlzLl93b3JsZENvb3JkaW5hdGVzID0gd29ybGRDb29yZGluYXRlcztcclxuICB9XHJcblxyXG4gIGdldCB3b3JsZENvb3JkaW5hdGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dvcmxkQ29vcmRpbmF0ZXM7XHJcbiAgfVxyXG5cclxuICBzZXQgZGF0YUNvb3JkaW5hdGVzKGRhdGFDb29yZGluYXRlcykge1xyXG4gICAgdGhpcy5fZGF0YUNvb3JkaW5hdGVzID0gZGF0YUNvb3JkaW5hdGVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRhdGFDb29yZGluYXRlcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhQ29vcmRpbmF0ZXM7XHJcbiAgfVxyXG5cclxuICBzZXQgc2NyZWVuQ29vcmRpbmF0ZXMoc2NyZWVuQ29vcmRpbmF0ZXMpIHtcclxuICAgIHRoaXMuX3NjcmVlbkNvb3JkaW5hdGVzID0gc2NyZWVuQ29vcmRpbmF0ZXM7XHJcbiAgfVxyXG5cclxuICBnZXQgc2NyZWVuQ29vcmRpbmF0ZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuQ29vcmRpbmF0ZXM7XHJcbiAgfVxyXG5cclxuICBzZXQgdmFsdWUodmFsdWUpIHtcclxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgfVxyXG5cclxuICBzZXQgaWQoaWQpIHtcclxuICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgfVxyXG59XHJcbiIsIi8vIGZ0cDovL21lZGljYWwubmVtYS5vcmcvTUVESUNBTC9EaWNvbS8yMDE0Yy9vdXRwdXQvY2h0bWwvcGFydDA1L3NlY3RfNi4yLmh0bWwvXHJcblxyXG4vLyBTbGljZXIgd2F5IHRvIGhhbmRsZSBpbWFnZXNcclxuLy8gc2hvdWxkIGZvbGxvdyBpdC4uLlxyXG4vLyA4OTcgICBpZiAoICh0aGlzLT5JbmRleFNlcmllc0luc3RhbmNlVUlEc1trXSAhPSBpZHhTZXJpZXNJbnN0YW5jZVVJRCAmJiB0aGlzLT5JbmRleFNlcmllc0luc3RhbmNlVUlEc1trXSA+PSAwICYmIGlkeFNlcmllc0luc3RhbmNlVUlEID49IDApIHx8XHJcbi8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XHJcbi8vIDg5OSAgICAgICAgKHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gIT0gaWR4VHJpZ2dlclRpbWUgJiYgdGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSA+PSAwICYmIGlkeFRyaWdnZXJUaW1lID49IDApIHx8XHJcbi8vIDkwMCAgICAgICAgKHRoaXMtPkluZGV4RWNob051bWJlcnNba10gIT0gaWR4RWNob051bWJlcnMgJiYgdGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSA+PSAwICYmIGlkeEVjaG9OdW1iZXJzID49IDApIHx8XHJcbi8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XHJcbi8vIDkwMiAgICAgICAgKHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSAhPSBpZHhTbGljZUxvY2F0aW9uICYmIHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSA+PSAwICYmIGlkeFNsaWNlTG9jYXRpb24gPj0gMCkgfHxcclxuLy8gOTAzICAgICAgICAodGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSAhPSBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCAmJiB0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdID49IDAgJiYgaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgPj0gMCkgKVxyXG4vLyA5MDQgICAgIHtcclxuLy8gOTA1ICAgICAgIGNvbnRpbnVlO1xyXG4vLyA5MDYgICAgIH1cclxuXHJcbi8qKiAqIEltcG9ydHMgKioqL1xyXG5pbXBvcnQgUGFyc2Vyc1ZvbHVtZSBmcm9tICcuL3BhcnNlcnMudm9sdW1lJztcclxuXHJcbmxldCBEaWNvbVBhcnNlciA9IHJlcXVpcmUoJ2RpY29tLXBhcnNlcicpO1xyXG5sZXQgSnBlZyA9IHJlcXVpcmUoJ2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcycpO1xyXG5sZXQgSnBlZ0Jhc2VsaW5lID0gcmVxdWlyZSgnLi4vLi4vZXh0ZXJuYWwvc2NyaXB0cy9qcGVnJyk7XHJcbmxldCBKcHggPSByZXF1aXJlKCcuLi8uLi9leHRlcm5hbC9zY3JpcHRzL2pweCcpO1xyXG5cclxuLyoqXHJcbiAqIERpY29tIHBhcnNlciBpcyBhIGNvbWJpbmF0aW9uIG9mIHV0aWxpdGllcyB0byBnZXQgYSBWSlMgaW1hZ2UgZnJvbSBkaWNvbSBmaWxlcy5cclxuICpzY3JpcHRzXHJcbiAqIFJlbGllcyBvbiBkY21qcywganF1ZXJ5LCBIVE1MNSBmZXRjaCBBUEksIEhUTUw1IHByb21pc2UgQVBJLlxyXG4gKlxyXG4gKiBAbW9kdWxlIHBhcnNlcnMvZGljb21cclxuICpcclxuICogQHBhcmFtIGFycmF5QnVmZmVyIHthcnJheWJ1ZmZlcn0gLSBMaXN0IG9mIGZpbGVzIHRvIGJlIHBhcnNlZC4gSXQgaXMgdXJscyBmcm9tIHdoaWNoXHJcbiAqIFZKUy5wYXJzZXJzLmRpY29tIGNhbiBwdWxsIHRoZSBkYXRhIGZyb20uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzRGljb20gZXh0ZW5kcyBQYXJzZXJzVm9sdW1lIHtcclxuXHJcbiAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5faWQgPSBpZDtcclxuXHJcbiAgICB0aGlzLl9hcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xyXG5cclxuICAgIGxldCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLl9hcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgLy8gY2F0Y2ggZXJyb3JcclxuICAgIC8vIHRocm93IGVycm9yIGlmIGFueSFcclxuICAgIHRoaXMuX2RhdGFTZXQgPSBudWxsO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuX2RhdGFTZXQgPSBEaWNvbVBhcnNlci5wYXJzZURpY29tKGJ5dGVBcnJheSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlKTtcclxuICAgICAgdGhyb3cgJ3BhcnNlcnMuZGljb20gY291bGQgbm90IHBhcnNlIHRoZSBmaWxlJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGltYWdlL2ZyYW1lIHNwZWNpZmljXHJcbiAgc2VyaWVzSW5zdGFuY2VVSUQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDIwMDAwZScpO1xyXG4gIH1cclxuXHJcbiAgc3R1ZHlJbnN0YW5jZVVJRCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMjAwMDBkJyk7XHJcbiAgfVxyXG5cclxuICBtb2RhbGl0eSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMDgwMDYwJyk7XHJcbiAgfVxyXG5cclxuICBzZWdtZW50YXRpb25UeXBlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDA2MjAwMDEnKTtcclxuICB9XHJcblxyXG4gIHNlZ21lbnRhdGlvblNlZ21lbnRzKCkge1xyXG4gICAgbGV0IHNlZ21lbnRhdGlvblNlZ21lbnRzID0gW107XHJcbiAgICBsZXQgc2VnbWVudFNlcXVlbmNlID0gdGhpcy5fZGF0YVNldC5lbGVtZW50cy54MDA2MjAwMDI7XHJcblxyXG4gICAgaWYgKCFzZWdtZW50U2VxdWVuY2UpIHtcclxuICAgICAgcmV0dXJuIHNlZ21lbnRhdGlvblNlZ21lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpPCBzZWdtZW50U2VxdWVuY2UuaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IHJlY29tbWVuZGVkRGlzcGxheUNJRUxhYiA9XHJcbiAgICAgICAgdGhpcy5fcmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiKHNlZ21lbnRTZXF1ZW5jZS5pdGVtc1tpXSk7XHJcbiAgICAgIGxldCBzZWdtZW50YXRpb25Db2RlID0gdGhpcy5fc2VnbWVudGF0aW9uQ29kZShzZWdtZW50U2VxdWVuY2UuaXRlbXNbaV0pO1xyXG4gICAgICBsZXQgc2VnbWVudE51bWJlciA9IHNlZ21lbnRTZXF1ZW5jZS5pdGVtc1tpXS5kYXRhU2V0LnVpbnQxNigneDAwNjIwMDA0Jyk7XHJcbiAgICAgIGxldCBzZWdtZW50TGFiZWwgPSBzZWdtZW50U2VxdWVuY2UuaXRlbXNbaV0uZGF0YVNldC5zdHJpbmcoJ3gwMDYyMDAwNScpO1xyXG4gICAgICBsZXQgc2VnbWVudEFsZ29yaXRobVR5cGUgPVxyXG4gICAgICAgIHNlZ21lbnRTZXF1ZW5jZS5pdGVtc1tpXS5kYXRhU2V0LnN0cmluZygneDAwNjIwMDA4Jyk7XHJcblxyXG4gICAgICBzZWdtZW50YXRpb25TZWdtZW50cy5wdXNoKHtcclxuICAgICAgICByZWNvbW1lbmRlZERpc3BsYXlDSUVMYWIsXHJcbiAgICAgICAgc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3I6XHJcbiAgICAgICAgICBzZWdtZW50YXRpb25Db2RlWydzZWdtZW50YXRpb25Db2RlRGVzaWduYXRvciddLFxyXG4gICAgICAgIHNlZ21lbnRhdGlvbkNvZGVWYWx1ZTogc2VnbWVudGF0aW9uQ29kZVsnc2VnbWVudGF0aW9uQ29kZVZhbHVlJ10sXHJcbiAgICAgICAgc2VnbWVudGF0aW9uQ29kZU1lYW5pbmc6IHNlZ21lbnRhdGlvbkNvZGVbJ3NlZ21lbnRhdGlvbkNvZGVNZWFuaW5nJ10sXHJcbiAgICAgICAgc2VnbWVudE51bWJlcixcclxuICAgICAgICBzZWdtZW50TGFiZWwsXHJcbiAgICAgICAgc2VnbWVudEFsZ29yaXRobVR5cGUsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzZWdtZW50YXRpb25TZWdtZW50cztcclxuICB9XHJcblxyXG4gIF9zZWdtZW50YXRpb25Db2RlKHNlZ21lbnQpIHtcclxuICAgIGxldCBzZWdtZW50YXRpb25Db2RlRGVzaWduYXRvciA9ICd1bmtub3duJztcclxuICAgIGxldCBzZWdtZW50YXRpb25Db2RlVmFsdWUgPSAndW5rbm93bic7XHJcbiAgICBsZXQgc2VnbWVudGF0aW9uQ29kZU1lYW5pbmcgPSAndW5rbm93bic7XHJcbiAgICBsZXQgZWxlbWVudCA9IHNlZ21lbnQuZGF0YVNldC5lbGVtZW50cy54MDAwODIyMTg7XHJcblxyXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5pdGVtcyAmJiBlbGVtZW50Lml0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3IgPSBlbGVtZW50Lml0ZW1zWzBdLmRhdGFTZXQuc3RyaW5nKCd4MDAwODAxMDInKTtcclxuICAgICAgc2VnbWVudGF0aW9uQ29kZVZhbHVlID0gZWxlbWVudC5pdGVtc1swXS5kYXRhU2V0LnN0cmluZygneDAwMDgwMTAwJyk7XHJcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVNZWFuaW5nID0gZWxlbWVudC5pdGVtc1swXS5kYXRhU2V0LnN0cmluZygneDAwMDgwMTA0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3IsXHJcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVWYWx1ZSxcclxuICAgICAgc2VnbWVudGF0aW9uQ29kZU1lYW5pbmcsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgX3JlY29tbWVuZGVkRGlzcGxheUNJRUxhYihzZWdtZW50KSB7XHJcbiAgICBpZiAoIXNlZ21lbnQuZGF0YVNldC5lbGVtZW50cy54MDA2MjAwMGQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG9mZnNldCA9IHNlZ21lbnQuZGF0YVNldC5lbGVtZW50cy54MDA2MjAwMGQuZGF0YU9mZnNldDtcclxuICAgIGxldCBsZW5ndGggPSBzZWdtZW50LmRhdGFTZXQuZWxlbWVudHMueDAwNjIwMDBkLmxlbmd0aDtcclxuICAgIGxldCBieXRlQXJyYXkgPSBzZWdtZW50LmRhdGFTZXQuYnl0ZUFycmF5LnNsaWNlKG9mZnNldCwgb2Zmc2V0KyBsZW5ndGgpO1xyXG5cclxuICAgIC8vIGh0dHBzOi8vd3d3LmRhYnNvZnQuY2gvZGljb20vMy9DLjEwLjcuMS4xL1xyXG4gICAgbGV0IENJRUxhYlNjYWxlZCA9IG5ldyBVaW50MTZBcnJheShsZW5ndGgvMik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaTxsZW5ndGgvMjsgaSsrKSB7XHJcbiAgICAgIENJRUxhYlNjYWxlZFtpXSA9IChieXRlQXJyYXlbMippICsgMV0gPDwgOCkgKyBieXRlQXJyYXlbMippXTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgQ0lFTGFiTm9ybWFsaXplZCA9IFtcclxuICAgICAgQ0lFTGFiU2NhbGVkWzBdIC8gNjU1MzUgKiAxMDAsXHJcbiAgICAgIENJRUxhYlNjYWxlZFsxXSAvIDY1NTM1ICogMjU1IC0gMTI4LFxyXG4gICAgICBDSUVMYWJTY2FsZWRbMl0gLyA2NTUzNSAqIDI1NSAtIDEyOCxcclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIENJRUxhYk5vcm1hbGl6ZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTT1AgSW5zdGFuY2UgVUlEXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGZyYW1lSW5kZXhcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgc29wSW5zdGFuY2VVSUQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBzb3BJbnN0YW5jZVVJRCA9XHJcbiAgICAgIHRoaXMuX2ZpbmRTdHJpbmdFdmVyeXdoZXJlKCd4MjAwNTE0MGYnLCAneDAwMDgwMDE4JywgZnJhbWVJbmRleCk7XHJcbiAgICByZXR1cm4gc29wSW5zdGFuY2VVSUQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2ZlciBzeW50YXggVUlEXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHRyYW5zZmVyU3ludGF4VUlEKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAwMjAwMTAnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0dWR5IGRlc2NyaXB0aW9uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHN0dWR5RGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDA4MTAzMCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VyaWVzIGRlc2NyaXB0aW9uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHNlcmllc0Rlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAwODEwM2UnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGllbnQgbmFtZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwYXRpZW50TmFtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAwMDEwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IElEXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHBhdGllbnRJRCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAwMDIwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IGJpcnRoZGF0ZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwYXRpZW50QmlydGhkYXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAxMDAwMzAnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGllbnQgc2V4XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHBhdGllbnRTZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDEwMDA0MCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF0aWVudCBhZ2VcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcGF0aWVudEFnZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAxMDEwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQaG90b21ldHJpYyBpbnRlcnByZXRhdGlvblxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAyODAwMDQnKTtcclxuICB9XHJcblxyXG4gIHBsYW5hckNvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICBsZXQgcGxhbmFyQ29uZmlndXJhdGlvbiA9IHRoaXMuX2RhdGFTZXQudWludDE2KCd4MDAyODAwMDYnKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHBsYW5hckNvbmZpZ3VyYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHBsYW5hckNvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwbGFuYXJDb25maWd1cmF0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2FtcGxlc1BlclBpeGVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQudWludDE2KCd4MDAyODAwMDInKTtcclxuICB9XHJcblxyXG4gIG51bWJlck9mRnJhbWVzKCkge1xyXG4gICAgbGV0IG51bWJlck9mRnJhbWVzID0gdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDI4MDAwOCcpO1xyXG5cclxuICAgIC8vIG5lZWQgc29tZXRoaW5nIHNtYXJ0ZXIhXHJcbiAgICBpZiAodHlwZW9mIG51bWJlck9mRnJhbWVzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBudW1iZXJPZkZyYW1lcyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bWJlck9mRnJhbWVzO1xyXG4gIH1cclxuXHJcbiAgbnVtYmVyT2ZDaGFubmVscygpIHtcclxuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gMTtcclxuICAgIGxldCBwaG90b21ldHJpY0ludGVycHJldGF0aW9uID0gdGhpcy5waG90b21ldHJpY0ludGVycHJldGF0aW9uKCk7XHJcblxyXG4gICAgaWYgKCEocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiAhPT0gJ1JHQicgJiZcclxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnUEFMRVRURSBDT0xPUicgJiZcclxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX0ZVTEwnICYmXHJcbiAgICAgICAgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiAhPT0gJ1lCUl9GVUxMXzQyMicgJiZcclxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX1BBUlRJQUxfNDIyJyAmJlxyXG4gICAgICAgIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gIT09ICdZQlJfUEFSVElBTF80MjAnICYmXHJcbiAgICAgICAgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiAhPT0gJ1lCUl9SQ1QnKSkge1xyXG4gICAgICBudW1iZXJPZkNoYW5uZWxzID0gMztcclxuICAgIH1cclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcclxuICAgIHJldHVybiBudW1iZXJPZkNoYW5uZWxzO1xyXG4gIH1cclxuXHJcbiAgaW52ZXJ0KCkge1xyXG4gICAgbGV0IHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gPSB0aGlzLnBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24oKTtcclxuXHJcbiAgICByZXR1cm4gKChwaG90b21ldHJpY0ludGVycHJldGF0aW9uID09PSAnTU9OT0NIUk9NRTEnKSA/IHRydWUgOiBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBpbWFnZU9yaWVudGF0aW9uKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyBleHBlY3QgZnJhbWUgaW5kZXggdG8gc3RhcnQgYXQgMCFcclxuICAgIGxldCBpbWFnZU9yaWVudGF0aW9uID0gdGhpcy5fZmluZFN0cmluZ0V2ZXJ5d2hlcmUoJ3gwMDIwOTExNicsICd4MDAyMDAwMzcnLCBmcmFtZUluZGV4KTtcclxuXHJcbiAgICAvLyBmb3JtYXQgaW1hZ2Ugb3JpZW50YXRpb24gKCcxXFwwXFwwXFwwXFwxXFwwJykgdG8gYXJyYXkgY29udGFpbmluZyA2IG51bWJlcnNcclxuICAgIGlmIChpbWFnZU9yaWVudGF0aW9uKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSByZXR1cm4gYSBudW1iZXIhIChub3QgYSBzdHJpbmchKVxyXG4gICAgICAvLyBtaWdodCBub3QgbmVlZCB0byBzcGxpdCAoZmxvYXRTdHJpbmcgKyBpbmRleClcclxuICAgICAgaW1hZ2VPcmllbnRhdGlvbiA9IGltYWdlT3JpZW50YXRpb24uc3BsaXQoJ1xcXFwnKS5tYXAoTnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW1hZ2VPcmllbnRhdGlvbjtcclxuICB9XHJcblxyXG4gIHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgcmVmZXJlbmNlZFNlZ21lbnROdW1iZXIgPSAtMTtcclxuICAgIGxldCByZWZlcmVuY2VkU2VnbWVudE51bWJlckVsZW1lbnQgPSB0aGlzLl9maW5kSW5Hcm91cFNlcXVlbmNlKCd4NTIwMDkyMzAnLCAneDAwNjIwMDBhJywgZnJhbWVJbmRleCk7XHJcblxyXG4gICAgaWYgKHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyRWxlbWVudCAhPT0gbnVsbCkge1xyXG4gICAgICByZWZlcmVuY2VkU2VnbWVudE51bWJlciA9IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyRWxlbWVudC51aW50MTYoJ3gwMDYyMDAwYicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZWZlcmVuY2VkU2VnbWVudE51bWJlcjtcclxuICB9XHJcblxyXG4gIHBpeGVsQXNwZWN0UmF0aW8oKSB7XHJcbiAgICBsZXQgcGl4ZWxBc3BlY3RSYXRpbyA9IFtcclxuICAgICAgdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDI4MDAzNCcsIDApLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LmludFN0cmluZygneDAwMjgwMDM0JywgMSksXHJcbiAgICBdO1xyXG5cclxuICAgIC8vIG5lZWQgc29tZXRoaW5nIHNtYXJ0ZXIhXHJcbiAgICBpZiAodHlwZW9mIHBpeGVsQXNwZWN0UmF0aW9bMF0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHBpeGVsQXNwZWN0UmF0aW8gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSB3ZSByZXR1cm4gYSBudW1iZXIhIChub3QgYSBzdHJpbmchKVxyXG4gICAgcmV0dXJuIHBpeGVsQXNwZWN0UmF0aW87XHJcbiAgfVxyXG5cclxuICBpbWFnZVBvc2l0aW9uKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgaW1hZ2VQb3NpdGlvbiA9IHRoaXMuX2ZpbmRTdHJpbmdFdmVyeXdoZXJlKCd4MDAyMDkxMTMnLCAneDAwMjAwMDMyJywgZnJhbWVJbmRleCk7XHJcblxyXG4gICAgLy8gZm9ybWF0IGltYWdlIG9yaWVudGF0aW9uICgnMVxcMFxcMFxcMFxcMVxcMCcpIHRvIGFycmF5IGNvbnRhaW5pbmcgNiBudW1iZXJzXHJcbiAgICBpZiAoaW1hZ2VQb3NpdGlvbikge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcclxuICAgICAgaW1hZ2VQb3NpdGlvbiA9IGltYWdlUG9zaXRpb24uc3BsaXQoJ1xcXFwnKS5tYXAoTnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW1hZ2VQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIGluc3RhbmNlTnVtYmVyKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xyXG4gICAgLy8gZmlyc3QgbG9vayBmb3IgZnJhbWUhXHJcbiAgICAvLyBwZXIgZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXAgc2VxdWVuY2VcclxuICAgIGxldCBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDUyMDA5MjMwO1xyXG5cclxuICAgIGlmICh0eXBlb2YgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGlmIChwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxyXG4gICAgICAgICAgICAgIC5pdGVtc1tmcmFtZUluZGV4XS5kYXRhU2V0LmVsZW1lbnRzLngyMDA1MTQwZikge1xyXG4gICAgICAgIGxldCBwbGFuZU9yaWVudGF0aW9uU2VxdWVuY2UgPSBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxyXG4gICAgICAgICAgICAuaXRlbXNbZnJhbWVJbmRleF0uZGF0YVNldC5lbGVtZW50cy54MjAwNTE0MGYuaXRlbXNbMF0uZGF0YVNldDtcclxuICAgICAgICBpbnN0YW5jZU51bWJlciA9IHBsYW5lT3JpZW50YXRpb25TZXF1ZW5jZS5pbnRTdHJpbmcoJ3gwMDIwMDAxMycpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlTnVtYmVyID0gdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDIwMDAxMycpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlTnVtYmVyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gc2hvdWxkIHdlIGRlZmF1bHQgdG8gdW5kZWZpbmVkPz9cclxuICAgICAgLy8gZGVmYXVsdCBvcmllbnRhdGlvblxyXG4gICAgICBpbnN0YW5jZU51bWJlciA9IHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyMDAwMTMnKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2VOdW1iZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluc3RhbmNlTnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgcGl4ZWxTcGFjaW5nKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyBleHBlY3QgZnJhbWUgaW5kZXggdG8gc3RhcnQgYXQgMCFcclxuICAgIGxldCBwaXhlbFNwYWNpbmcgPSB0aGlzLl9maW5kU3RyaW5nRXZlcnl3aGVyZSgneDAwMjg5MTEwJywgJ3gwMDI4MDAzMCcsIGZyYW1lSW5kZXgpO1xyXG5cclxuICAgIC8vIGZvcm1hdCBpbWFnZSBvcmllbnRhdGlvbiAoJzFcXDBcXDBcXDBcXDFcXDAnKSB0byBhcnJheSBjb250YWluaW5nIDYgbnVtYmVyc1xyXG4gICAgLy8gc2hvdWxkIHdlIGRlZmF1bHQgdG8gdW5kZWZpbmVkPz9cclxuICAgIGlmIChwaXhlbFNwYWNpbmcpIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhcnJheSBvZiBudW1iZXJzISAobm90IHN0cmluZ3MhKVxyXG4gICAgICBwaXhlbFNwYWNpbmcgPSBwaXhlbFNwYWNpbmcuc3BsaXQoJ1xcXFwnKS5tYXAoTnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGl4ZWxTcGFjaW5nO1xyXG4gIH1cclxuXHJcbiAgcm93cyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IHJvd3MgPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMDEwJyk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiByb3dzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByb3dzID0gbnVsbDtcclxuICAgICAgLy8gcHJpbnQgd2FybmluZyBhdCBsZWFzdC4uLlxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb3dzO1xyXG4gIH1cclxuXHJcbiAgY29sdW1ucyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGNvbHVtbnMgPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMDExJyk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjb2x1bW5zID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBjb2x1bW5zID0gbnVsbDtcclxuICAgICAgLy8gcHJpbnQgd2FybmluZyBhdCBsZWFzdC4uLlxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2x1bW5zO1xyXG4gIH1cclxuXHJcbiAgcGl4ZWxUeXBlKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyAwIGludGVnZXIsIDEgZmxvYXRcclxuICAgIC8vIGRpY29tIG9ubHkgc3VwcG9ydCBpbnRlZ2Vyc1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBwaXhlbFJlcHJlc2VudGF0aW9uKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgcGl4ZWxSZXByZXNlbnRhdGlvbiA9IHRoaXMuX2RhdGFTZXQudWludDE2KCd4MDAyODAxMDMnKTtcclxuICAgIHJldHVybiBwaXhlbFJlcHJlc2VudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gZXhwZWN0IGZyYW1lIGluZGV4IHRvIHN0YXJ0IGF0IDAhXHJcbiAgICBsZXQgYml0c0FsbG9jYXRlZCA9IHRoaXMuX2RhdGFTZXQudWludDE2KCd4MDAyODAxMDAnKTtcclxuICAgIHJldHVybiBiaXRzQWxsb2NhdGVkO1xyXG4gIH1cclxuXHJcbiAgaGlnaEJpdChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gZXhwZWN0IGZyYW1lIGluZGV4IHRvIHN0YXJ0IGF0IDAhXHJcbiAgICBsZXQgaGlnaEJpdCA9IHRoaXMuX2RhdGFTZXQudWludDE2KCd4MDAyODAxMDInKTtcclxuICAgIHJldHVybiBoaWdoQml0O1xyXG4gIH1cclxuXHJcbiAgcmVzY2FsZUludGVyY2VwdChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxyXG4gICAgICAneDAwMjg5MTQ1JywgJ3gwMDI4MTA1MicsIGZyYW1lSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgcmVzY2FsZVNsb3BlKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZEZsb2F0U3RyaW5nSW5GcmFtZUdyb3VwU2VxdWVuY2UoXHJcbiAgICAgICd4MDAyODkxNDUnLCAneDAwMjgxMDUzJywgZnJhbWVJbmRleCk7XHJcbiAgfVxyXG5cclxuICB3aW5kb3dDZW50ZXIoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9maW5kRmxvYXRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShcclxuICAgICAgJ3gwMDI4OTEzMicsICd4MDAyODEwNTAnLCBmcmFtZUluZGV4KTtcclxuICB9XHJcblxyXG4gIHdpbmRvd1dpZHRoKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZEZsb2F0U3RyaW5nSW5GcmFtZUdyb3VwU2VxdWVuY2UoXHJcbiAgICAgICd4MDAyODkxMzInLCAneDAwMjgxMDUxJywgZnJhbWVJbmRleCk7XHJcbiAgfVxyXG5cclxuICBzbGljZVRoaWNrbmVzcyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxyXG4gICAgICAneDAwMjg5MTEwJywgJ3gwMDE4MDA1MCcsIGZyYW1lSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgc3BhY2luZ0JldHdlZW5TbGljZXMoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBzcGFjaW5nID0gdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDE4MDA4OCcpO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygc3BhY2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgc3BhY2luZyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNwYWNpbmc7XHJcbiAgfVxyXG5cclxuICBkaW1lbnNpb25JbmRleFZhbHVlcyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGRpbWVuc2lvbkluZGV4VmFsdWVzID0gbnVsbDtcclxuXHJcbiAgICAvLyB0cnkgdG8gZ2V0IGl0IGZyb20gZW5oYW5jZWQgTVIgaW1hZ2VzXHJcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXAgc2VxdWVuY2VcclxuICAgIGxldCBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDUyMDA5MjMwO1xyXG5cclxuICAgIGlmICh0eXBlb2YgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGxldCBmcmFtZUNvbnRlbnRTZXF1ZW5jZSA9IHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlXHJcbiAgICAgICAgICAuaXRlbXNbZnJhbWVJbmRleF0uZGF0YVNldC5lbGVtZW50cy54MDAyMDkxMTE7XHJcbiAgICAgIGlmIChmcmFtZUNvbnRlbnRTZXF1ZW5jZSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICBmcmFtZUNvbnRlbnRTZXF1ZW5jZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZyYW1lQ29udGVudFNlcXVlbmNlID0gZnJhbWVDb250ZW50U2VxdWVuY2UuaXRlbXNbMF0uZGF0YVNldDtcclxuICAgICAgICBsZXQgZGltZW5zaW9uSW5kZXhWYWx1ZXNFbHQgPSBmcmFtZUNvbnRlbnRTZXF1ZW5jZS5lbGVtZW50cy54MDAyMDkxNTc7XHJcbiAgICAgICAgaWYgKGRpbWVuc2lvbkluZGV4VmFsdWVzRWx0ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgZGltZW5zaW9uSW5kZXhWYWx1ZXNFbHQgIT09IG51bGwpIHtcclxuICAgICAgICAgIC8vIC80IGJlY2F1c2UgVUxcclxuICAgICAgICAgIGxldCBuYlZhbHVlcyA9IGRpbWVuc2lvbkluZGV4VmFsdWVzRWx0Lmxlbmd0aCAvIDQ7XHJcbiAgICAgICAgICBkaW1lbnNpb25JbmRleFZhbHVlcyA9IFtdO1xyXG5cclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJWYWx1ZXM7IGkrKykge1xyXG4gICAgICAgICAgICBkaW1lbnNpb25JbmRleFZhbHVlcy5wdXNoKFxyXG4gICAgICAgICAgICAgIGZyYW1lQ29udGVudFNlcXVlbmNlLnVpbnQzMigneDAwMjA5MTU3JywgaSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkaW1lbnNpb25JbmRleFZhbHVlcztcclxuICB9XHJcblxyXG4gIGluU3RhY2tQb3NpdGlvbk51bWJlcihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGluU3RhY2tQb3NpdGlvbk51bWJlciA9IG51bGw7XHJcblxyXG4gICAgLy8gdHJ5IHRvIGdldCBpdCBmcm9tIGVuaGFuY2VkIE1SIGltYWdlc1xyXG4gICAgLy8gcGVyLWZyYW1lIGZ1bmN0aW9ubmFsIGdyb3VwIHNlcXVlbmNlXHJcbiAgICBsZXQgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng1MjAwOTIzMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAvLyBOT1QgQSBQSElMSVBTIFRSSUNLIVxyXG4gICAgICBsZXQgcGhpbGlwc1ByaXZhdGVTZXF1ZW5jZSA9IHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlXHJcbiAgICAgICAgICAuaXRlbXNbZnJhbWVJbmRleF0uZGF0YVNldC5lbGVtZW50cy54MDAyMDkxMTEuaXRlbXNbMF0uZGF0YVNldDtcclxuICAgICAgaW5TdGFja1Bvc2l0aW9uTnVtYmVyID0gcGhpbGlwc1ByaXZhdGVTZXF1ZW5jZS51aW50MzIoJ3gwMDIwOTA1NycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5TdGFja1Bvc2l0aW9uTnVtYmVyID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhgaW5zdGFjayBwb3NpdGlvbiAke2luU3RhY2tQb3NpdGlvbk51bWJlcn1gKTtcclxuXHJcbiAgICByZXR1cm4gaW5TdGFja1Bvc2l0aW9uTnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgc3RhY2tJRChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IHN0YWNrSUQgPSBudWxsO1xyXG5cclxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcclxuICAgIC8vIHBlci1mcmFtZSBmdW5jdGlvbm5hbCBncm91cCBzZXF1ZW5jZVxyXG4gICAgbGV0IHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlID0gdGhpcy5fZGF0YVNldC5lbGVtZW50cy54NTIwMDkyMzA7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gTk9UIEEgUEhJTElQUyBUUklDSyFcclxuICAgICAgbGV0IHBoaWxpcHNQcml2YXRlU2VxdWVuY2UgPSBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxyXG4gICAgICAgICAgLml0ZW1zW2ZyYW1lSW5kZXhdLmRhdGFTZXQuZWxlbWVudHMueDAwMjA5MTExLml0ZW1zWzBdLmRhdGFTZXQ7XHJcbiAgICAgIHN0YWNrSUQgPSBwaGlsaXBzUHJpdmF0ZVNlcXVlbmNlLmludFN0cmluZygneDAwMjA5MDU2Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGFja0lEID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RhY2tJRDtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RQaXhlbERhdGEoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIGRlY29tcHJlc3NcclxuICAgIGxldCBkZWNvbXByZXNzZWREYXRhID0gdGhpcy5fZGVjb2RlUGl4ZWxEYXRhKGZyYW1lSW5kZXgpO1xyXG5cclxuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKCk7XHJcblxyXG4gICAgaWYgKG51bWJlck9mQ2hhbm5lbHMgPiAxKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb3JTcGFjZShkZWNvbXByZXNzZWREYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBkZWNvbXByZXNzZWREYXRhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbWluTWF4UGl4ZWxEYXRhKHBpeGVsRGF0YSA9IFtdKSB7XHJcbiAgICBsZXQgbWluTWF4ID0gWzY1NTM1LCAtMzI3NjhdO1xyXG4gICAgbGV0IG51bVBpeGVscyA9IHBpeGVsRGF0YS5sZW5ndGg7XHJcblxyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVBpeGVsczsgaW5kZXgrKykge1xyXG4gICAgICBsZXQgc3B2ID0gcGl4ZWxEYXRhW2luZGV4XTtcclxuICAgICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCBzcHYpO1xyXG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIHNwdik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1pbk1heDtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gcHJpdmF0ZSBtZXRob2RzXHJcbiAgLy9cclxuXHJcbiAgX2ZpbmRJbkdyb3VwU2VxdWVuY2Uoc2VxdWVuY2UsIHN1YnNlcXVlbmNlLCBpbmRleCkge1xyXG4gICAgbGV0IGZ1bmN0aW9uYWxHcm91cFNlcXVlbmNlID0gdGhpcy5fZGF0YVNldC5lbGVtZW50c1tzZXF1ZW5jZV07XHJcblxyXG4gICAgaWYgKHR5cGVvZiBmdW5jdGlvbmFsR3JvdXBTZXF1ZW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgbGV0IGluU2VxdWVuY2UgPSBmdW5jdGlvbmFsR3JvdXBTZXF1ZW5jZS5pdGVtc1tpbmRleF0uZGF0YVNldC5lbGVtZW50c1tzdWJzZXF1ZW5jZV07XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGluU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGluU2VxdWVuY2UuaXRlbXNbMF0uZGF0YVNldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgX2ZpbmRTdHJpbmdJbkdyb3VwU2VxdWVuY2Uoc2VxdWVuY2UsIHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XHJcbiAgICAvLyBpbmRleCA9IDAgaWYgc2hhcmVkISEhXHJcbiAgICBsZXQgZGF0YVNldCA9IHRoaXMuX2ZpbmRJbkdyb3VwU2VxdWVuY2Uoc2VxdWVuY2UsIHN1YnNlcXVlbmNlLCBpbmRleCk7XHJcblxyXG4gICAgaWYgKGRhdGFTZXQgIT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGRhdGFTZXQuc3RyaW5nKHRhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBfZmluZFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjI5Jywgc3Vic2VxdWVuY2UsIHRhZywgMCkgfHxcclxuICAgICAgICB0aGlzLl9maW5kU3RyaW5nSW5Hcm91cFNlcXVlbmNlKCd4NTIwMDkyMzAnLCBzdWJzZXF1ZW5jZSwgdGFnLCBpbmRleCk7XHJcbiAgfVxyXG5cclxuICBfZmluZFN0cmluZ0V2ZXJ5d2hlcmUoc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpIHtcclxuICAgIGxldCB0YXJnZXRTdHJpbmcgPSB0aGlzLl9maW5kU3RyaW5nSW5GcmFtZUdyb3VwU2VxdWVuY2Uoc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpO1xyXG5cclxuICAgIGlmICh0YXJnZXRTdHJpbmcgPT09IG51bGwpIHtcclxuICAgICAgdGFyZ2V0U3RyaW5nID0gdGhpcy5fZGF0YVNldC5zdHJpbmcodGFnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHRhcmdldFN0cmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGFyZ2V0U3RyaW5nID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0U3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgX2ZpbmRGbG9hdFN0cmluZ0luR3JvdXBTZXF1ZW5jZShzZXF1ZW5jZSwgc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpIHtcclxuICAgIGxldCBkYXRhSW5Hcm91cFNlcXVlbmNlID0gdGhpcy5fZGF0YVNldC5mbG9hdFN0cmluZyh0YWcpO1xyXG5cclxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcclxuICAgIC8vIHBlci1mcmFtZSBmdW5jdGlvbm5hbCBncm91cFxyXG4gICAgaWYgKHR5cGVvZiBkYXRhSW5Hcm91cFNlcXVlbmNlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBkYXRhSW5Hcm91cFNlcXVlbmNlID0gdGhpcy5fZmluZEluR3JvdXBTZXF1ZW5jZShzZXF1ZW5jZSwgc3Vic2VxdWVuY2UsIGluZGV4KTtcclxuXHJcbiAgICAgIGlmIChkYXRhSW5Hcm91cFNlcXVlbmNlICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFJbkdyb3VwU2VxdWVuY2UuZmxvYXRTdHJpbmcodGFnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhSW5Hcm91cFNlcXVlbmNlO1xyXG4gIH1cclxuXHJcbiAgX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZEZsb2F0U3RyaW5nSW5Hcm91cFNlcXVlbmNlKCd4NTIwMDkyMjknLCBzdWJzZXF1ZW5jZSwgdGFnLCAwKSB8fFxyXG4gICAgICAgIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjMwJywgc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgX2RlY29kZVBpeGVsRGF0YShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gaWYgY29tcHJlc3NlZC4uP1xyXG4gICAgbGV0IHRyYW5zZmVyU3ludGF4VUlEID0gdGhpcy50cmFuc2ZlclN5bnRheFVJRCgpO1xyXG5cclxuICAgIC8vIGZpbmQgY29tcHJlc3Npb24gc2NoZW1lXHJcbiAgICBpZiAoXHJcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC45MCcgfHxcclxuICAgICAgLy8gSlBFRyAyMDAwIExvc3NsZXNzXHJcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC45MScpIHtcclxuICAgICAgLy8gSlBFRyAyMDAwIExvc3N5XHJcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVKMksoZnJhbWVJbmRleCk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjQuNTcnIHx8XHJcbiAgICAgIC8vIEpQRUcgTG9zc2xlc3MsIE5vbmhpZXJhcmNoaWNhbCAoUHJvY2Vzc2VzIDE0KVxyXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjQuNzAnKSB7XHJcbiAgICAgIC8vIEpQRUcgTG9zc2xlc3MsIE5vbmhpZXJhcmNoaWNhbCAoUHJvY2Vzc2VzIDE0IFtTZWxlY3Rpb24gMV0pXHJcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVKUEVHTG9zc2xlc3MoZnJhbWVJbmRleCk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjQuNTAnIHx8XHJcbiAgICAgIC8vIEpQRUcgQmFzZWxpbmUgbG9zc3kgcHJvY2VzcyAxICg4IGJpdClcclxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi40LjUxJykge1xyXG4gICAgICAvLyBKUEVHIEJhc2VsaW5lIGxvc3N5IHByb2Nlc3MgMiAmIDQgKDEyIGJpdClcclxuICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUpQRUdCYXNlbGluZShmcmFtZUluZGV4KTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjInIHx8XHJcbiAgICAgIC8vIEltcGxpY2l0IFZSIExpdHRsZSBFbmRpYW5cclxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi4xJykge1xyXG4gICAgICAvLyBFeHBsaWNpdCBWUiBMaXR0bGUgRW5kaWFuXHJcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVVbmNvbXByZXNzZWQoZnJhbWVJbmRleCk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjInKSB7XHJcbiAgICAgIC8vIEV4cGxpY2l0IFZSIEJpZyBFbmRpYW5cclxuICAgICAgbGV0IGZyYW1lID0gdGhpcy5fZGVjb2RlVW5jb21wcmVzc2VkKGZyYW1lSW5kZXgpO1xyXG4gICAgICAvLyBhbmQgc2F3cCBpdCFcclxuICAgICAgcmV0dXJuIHRoaXMuX3N3YXBGcmFtZShmcmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyB7XHJcbiAgICAgICAgZXJyb3I6IGBubyBkZWNvZGVyIGZvciB0cmFuc2ZlciBzeW50YXggJHt0cmFuc2ZlclN5bnRheFVJRH1gLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2RlY29kZUoySyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGVuY29kZWRQaXhlbERhdGEgPSBEaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhKHRoaXMuX2RhdGFTZXQsIHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwLCBmcmFtZUluZGV4KTtcclxuICAgIC8vIGxldCBwaXhlbERhdGFFbGVtZW50ID0gdGhpcy5fZGF0YVNldC5lbGVtZW50cy54N2ZlMDAwMTA7XHJcbiAgICAvLyBsZXQgcGl4ZWxEYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fZGF0YVNldC5ieXRlQXJyYXkuYnVmZmVyLCBwaXhlbERhdGFFbGVtZW50LmRhdGFPZmZzZXQsIHBpeGVsRGF0YUVsZW1lbnQubGVuZ3RoKTtcclxuICAgIGxldCBqcHhJbWFnZSA9IG5ldyBKcHgoKTtcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9PSElGL2ltYWdlLUpQRUcyMDAwL2lzc3Vlcy82XHJcbiAgICAvLyBJdCBjdXJyZW50bHkgcmV0dXJucyBlaXRoZXIgSW50MTYgb3IgVWludDE2IGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNvZGVzdHJlYW0gaXMgc2lnbmVkIG9yIG5vdC5cclxuICAgIGpweEltYWdlLnBhcnNlKGVuY29kZWRQaXhlbERhdGEpO1xyXG5cclxuICAgIC8vIGxldCBqMmtXaWR0aCA9IGpweEltYWdlLndpZHRoO1xyXG4gICAgLy8gbGV0IGoya0hlaWdodCA9IGpweEltYWdlLmhlaWdodDtcclxuXHJcbiAgICBsZXQgY29tcG9uZW50c0NvdW50ID0ganB4SW1hZ2UuY29tcG9uZW50c0NvdW50O1xyXG4gICAgaWYgKGNvbXBvbmVudHNDb3VudCAhPT0gMSkge1xyXG4gICAgICB0aHJvdyAnSlBFRzIwMDAgZGVjb2RlciByZXR1cm5lZCBhIGNvbXBvbmVudENvdW50IG9mICR7Y29tcG9uZW50c0NvdW50fSwgd2hlbiAxIGlzIGV4cGVjdGVkJztcclxuICAgIH1cclxuICAgIGxldCB0aWxlQ291bnQgPSBqcHhJbWFnZS50aWxlcy5sZW5ndGg7XHJcblxyXG4gICAgaWYgKHRpbGVDb3VudCAhPT0gMSkge1xyXG4gICAgICB0aHJvdyAnSlBFRzIwMDAgZGVjb2RlciByZXR1cm5lZCBhIHRpbGVDb3VudCBvZiAke3RpbGVDb3VudH0sIHdoZW4gMSBpcyBleHBlY3RlZCc7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRpbGVDb21wb25lbnRzID0ganB4SW1hZ2UudGlsZXNbMF07XHJcbiAgICBsZXQgcGl4ZWxEYXRhID0gdGlsZUNvbXBvbmVudHMuaXRlbXM7XHJcblxyXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGoya1dpZHRoLCBqMmtIZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiBwaXhlbERhdGE7XHJcbiAgfVxyXG5cclxuICAvLyBmcm9tIGNvcm5lcnN0b25lXHJcbiAgX2RlY29kZUpQRUdMb3NzbGVzcyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGVuY29kZWRQaXhlbERhdGEgPSBEaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhKHRoaXMuX2RhdGFTZXQsIHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwLCBmcmFtZUluZGV4KTtcclxuICAgIGxldCBwaXhlbFJlcHJlc2VudGF0aW9uID0gdGhpcy5waXhlbFJlcHJlc2VudGF0aW9uKGZyYW1lSW5kZXgpO1xyXG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCk7XHJcbiAgICBsZXQgYnl0ZU91dHB1dCA9IGJpdHNBbGxvY2F0ZWQgPD0gOCA/IDEgOiAyO1xyXG4gICAgbGV0IGRlY29kZXIgPSBuZXcgSnBlZy5sb3NzbGVzcy5EZWNvZGVyKCk7XHJcbiAgICBsZXQgZGVjb21wcmVzc2VkRGF0YSA9IGRlY29kZXIuZGVjb2RlKGVuY29kZWRQaXhlbERhdGEuYnVmZmVyLCBlbmNvZGVkUGl4ZWxEYXRhLmJ5dGVPZmZzZXQsIGVuY29kZWRQaXhlbERhdGEubGVuZ3RoLCBieXRlT3V0cHV0KTtcclxuXHJcbiAgICBpZiAocGl4ZWxSZXByZXNlbnRhdGlvbiA9PT0gMCkge1xyXG4gICAgICBpZiAoYnl0ZU91dHB1dCA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoZGVjb21wcmVzc2VkRGF0YS5idWZmZXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHVudGVzdGVkIVxyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWNvbXByZXNzZWREYXRhLmJ1ZmZlcik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShkZWNvbXByZXNzZWREYXRhLmJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZGVjb2RlSlBFR0Jhc2VsaW5lKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgZW5jb2RlZFBpeGVsRGF0YSA9IERpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGEodGhpcy5fZGF0YVNldCwgdGhpcy5fZGF0YVNldC5lbGVtZW50cy54N2ZlMDAwMTAsIGZyYW1lSW5kZXgpO1xyXG4gICAgbGV0IHJvd3MgPSB0aGlzLnJvd3MoZnJhbWVJbmRleCk7XHJcbiAgICBsZXQgY29sdW1ucyA9IHRoaXMuY29sdW1ucyhmcmFtZUluZGV4KTtcclxuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gdGhpcy5iaXRzQWxsb2NhdGVkKGZyYW1lSW5kZXgpO1xyXG4gICAgbGV0IGpwZWdCYXNlbGluZSA9IG5ldyBKcGVnQmFzZWxpbmUoKTtcclxuICAgIGpwZWdCYXNlbGluZS5wYXJzZShlbmNvZGVkUGl4ZWxEYXRhKTtcclxuXHJcbiAgICBpZiAoYml0c0FsbG9jYXRlZCA9PT0gOCkge1xyXG4gICAgICByZXR1cm4ganBlZ0Jhc2VsaW5lLmdldERhdGEoY29sdW1ucywgcm93cyk7XHJcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDE2KSB7XHJcbiAgICAgIHJldHVybiBqcGVnQmFzZWxpbmUuZ2V0RGF0YTE2KGNvbHVtbnMsIHJvd3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2RlY29kZVVuY29tcHJlc3NlZChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IHBpeGVsUmVwcmVzZW50YXRpb24gPSB0aGlzLnBpeGVsUmVwcmVzZW50YXRpb24oZnJhbWVJbmRleCk7XHJcbiAgICBsZXQgYml0c0FsbG9jYXRlZCA9IHRoaXMuYml0c0FsbG9jYXRlZChmcmFtZUluZGV4KTtcclxuICAgIGxldCBwaXhlbERhdGFFbGVtZW50ID0gdGhpcy5fZGF0YVNldC5lbGVtZW50cy54N2ZlMDAwMTA7XHJcbiAgICBsZXQgcGl4ZWxEYXRhT2Zmc2V0ID0gcGl4ZWxEYXRhRWxlbWVudC5kYXRhT2Zmc2V0O1xyXG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcclxuICAgIGxldCBudW1QaXhlbHMgPVxyXG4gICAgICB0aGlzLnJvd3MoZnJhbWVJbmRleCkgKiB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCkgKiBudW1iZXJPZkNoYW5uZWxzO1xyXG4gICAgbGV0IGZyYW1lT2Zmc2V0ID0gMDtcclxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9kYXRhU2V0LmJ5dGVBcnJheS5idWZmZXI7XHJcblxyXG4gICAgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDAgJiYgYml0c0FsbG9jYXRlZCA9PT0gOCkge1xyXG4gICAgICAvLyB1bnNpZ25lZCA4IGJpdFxyXG4gICAgICBmcmFtZU9mZnNldCA9IHBpeGVsRGF0YU9mZnNldCArIGZyYW1lSW5kZXggKiBudW1QaXhlbHM7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmIChwaXhlbFJlcHJlc2VudGF0aW9uID09PSAwICYmIGJpdHNBbGxvY2F0ZWQgPT09IDE2KSB7XHJcbiAgICAgIC8vIHVuc2lnbmVkIDE2IGJpdFxyXG4gICAgICBmcmFtZU9mZnNldCA9IHBpeGVsRGF0YU9mZnNldCArIGZyYW1lSW5kZXggKiBudW1QaXhlbHMgKiAyO1xyXG4gICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDEgJiYgYml0c0FsbG9jYXRlZCA9PT0gMTYpIHtcclxuICAgICAgLy8gc2lnbmVkIDE2IGJpdFxyXG4gICAgICBmcmFtZU9mZnNldCA9IHBpeGVsRGF0YU9mZnNldCArIGZyYW1lSW5kZXggKiBudW1QaXhlbHMgKiAyO1xyXG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAocGl4ZWxSZXByZXNlbnRhdGlvbiA9PT0gMCAmJiBiaXRzQWxsb2NhdGVkID09PSAzMikge1xyXG4gICAgICAvLyB1bnNpZ25lZCAzMiBiaXRcclxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICogNDtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmIChwaXhlbFJlcHJlc2VudGF0aW9uID09PSAwICYmIGJpdHNBbGxvY2F0ZWQgPT09IDEpIHtcclxuICAgICAgbGV0IG5ld0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihudW1QaXhlbHMpO1xyXG4gICAgICBsZXQgbmV3QXJyYXkgPSBuZXcgVWludDhBcnJheShuZXdCdWZmZXIpO1xyXG5cclxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xyXG4gICAgICBsZXQgaW5kZXggPSAwO1xyXG5cclxuICAgICAgbGV0IGJpdFN0YXJ0ID0gZnJhbWVJbmRleCAqIG51bVBpeGVscztcclxuICAgICAgbGV0IGJpdEVuZCA9IGZyYW1lSW5kZXggKiBudW1QaXhlbHMgKyBudW1QaXhlbHM7XHJcblxyXG4gICAgICBsZXQgYnl0ZVN0YXJ0ID0gTWF0aC5mbG9vcihiaXRTdGFydCAvIDgpO1xyXG4gICAgICBsZXQgYml0U3RhcnRPZmZzZXQgPSBiaXRTdGFydCAtIGJ5dGVTdGFydCAqIDg7XHJcbiAgICAgIGxldCBieXRlRW5kID0gTWF0aC5jZWlsKGJpdEVuZCAvIDgpO1xyXG5cclxuICAgICAgbGV0IHRhcmdldEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgcGl4ZWxEYXRhT2Zmc2V0KTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSBieXRlU3RhcnQ7IGkgPD0gYnl0ZUVuZDsgaSsrKSB7XHJcbiAgICAgICAgd2hpbGUgKGJpdFN0YXJ0T2Zmc2V0IDwgOCkge1xyXG4gICAgICAgICAgc3dpdGNoIChiaXRTdGFydE9mZnNldCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgbmV3QXJyYXlbaW5kZXhdID0gdGFyZ2V0QnVmZmVyW2ldICYgMHgwMDAxO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgbmV3QXJyYXlbaW5kZXhdID0gdGFyZ2V0QnVmZmVyW2ldID4+PiAxICYgMHgwMDAxO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgbmV3QXJyYXlbaW5kZXhdID0gdGFyZ2V0QnVmZmVyW2ldID4+PiAyICYgMHgwMDAxO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgbmV3QXJyYXlbaW5kZXhdID0gdGFyZ2V0QnVmZmVyW2ldID4+PiAzICYgMHgwMDAxO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgbmV3QXJyYXlbaW5kZXhdID0gdGFyZ2V0QnVmZmVyW2ldID4+PiA0ICYgMHgwMDAxO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgbmV3QXJyYXlbaW5kZXhdID0gdGFyZ2V0QnVmZmVyW2ldID4+PiA1ICYgMHgwMDAxO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgbmV3QXJyYXlbaW5kZXhdID0gdGFyZ2V0QnVmZmVyW2ldID4+PiA2ICYgMHgwMDAxO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgbmV3QXJyYXlbaW5kZXhdID0gdGFyZ2V0QnVmZmVyW2ldID4+PiA3ICYgMHgwMDAxO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJpdFN0YXJ0T2Zmc2V0Kys7XHJcbiAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgLy8gaWYgcmV0dXJuLi5cclxuICAgICAgICAgIGlmIChpbmRleCA+PSBudW1QaXhlbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBiaXRTdGFydE9mZnNldCA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jb252ZXJ0Q29sb3JTcGFjZSh1bmNvbXByZXNzZWREYXRhKSB7XHJcbiAgICBsZXQgcmdiRGF0YSA9IG51bGw7XHJcbiAgICBsZXQgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9IHRoaXMucGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbigpO1xyXG4gICAgbGV0IHBsYW5hckNvbmZpZ3VyYXRpb24gPSB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24oKTtcclxuXHJcbiAgICBpZiAocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9PT0gJ1JHQicgJiZcclxuICAgICAgICBwbGFuYXJDb25maWd1cmF0aW9uID09PSAwKSB7XHJcbiAgICAgIC8vIEFMTCBHT09ELCBBTFJFQURZIE9SREVSRURcclxuICAgICAgLy8gcGxhbmFyIG9yIG5vbiBwbGFuYXIgcGxhbmFyQ29uZmlndXJhdGlvblxyXG4gICAgICByZ2JEYXRhID0gdW5jb21wcmVzc2VkRGF0YTtcclxuICAgIH0gZWxzZSBpZiAocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9PT0gJ1JHQicgJiZcclxuICAgICAgICBwbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XHJcbiAgICAgIGlmICh1bmNvbXByZXNzZWREYXRhIGluc3RhbmNlb2YgSW50OEFycmF5KSB7XHJcbiAgICAgICAgcmdiRGF0YSA9IG5ldyBJbnQ4QXJyYXkodW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgICAgcmdiRGF0YSA9IG5ldyBVaW50OEFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIGlmICh1bmNvbXByZXNzZWREYXRhIGluc3RhbmNlb2YgSW50MTZBcnJheSkge1xyXG4gICAgICAgIHJnYkRhdGEgPSBuZXcgSW50MTZBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XHJcbiAgICAgICAgcmdiRGF0YSA9IG5ldyBVaW50MTZBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgJ3Vuc3Vwb3J0ZWQgdHlwZWQgYXJyYXk6ICR7dW5jb21wcmVzc2VkRGF0YX0nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgbnVtUGl4ZWxzID0gdW5jb21wcmVzc2VkRGF0YS5sZW5ndGggLyAzO1xyXG4gICAgICBsZXQgcmdiYUluZGV4ID0gMDtcclxuICAgICAgbGV0IHJJbmRleCA9IDA7XHJcbiAgICAgIGxldCBnSW5kZXggPSBudW1QaXhlbHM7XHJcbiAgICAgIGxldCBiSW5kZXggPSBudW1QaXhlbHMgKiAyO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBpeGVsczsgaSsrKSB7XHJcbiAgICAgICAgcmdiRGF0YVtyZ2JhSW5kZXgrK10gPSB1bmNvbXByZXNzZWREYXRhW3JJbmRleCsrXTsgLy8gcmVkXHJcbiAgICAgICAgcmdiRGF0YVtyZ2JhSW5kZXgrK10gPSB1bmNvbXByZXNzZWREYXRhW2dJbmRleCsrXTsgLy8gZ3JlZW5cclxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHVuY29tcHJlc3NlZERhdGFbYkluZGV4KytdOyAvLyBibHVlXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9PT0gJ1lCUl9GVUxMJykge1xyXG4gICAgICBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xyXG4gICAgICAgIHJnYkRhdGEgPSBuZXcgSW50OEFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIGlmICh1bmNvbXByZXNzZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgIHJnYkRhdGEgPSBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcclxuICAgICAgICByZ2JEYXRhID0gbmV3IEludDE2QXJyYXkodW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xyXG4gICAgICAgIHJnYkRhdGEgPSBuZXcgVWludDE2QXJyYXkodW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93ICd1bnN1cG9ydGVkIHR5cGVkIGFycmF5OiAke3VuY29tcHJlc3NlZERhdGF9JztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYWZleS9jb3JuZXJzdG9uZVdBRE9JbWFnZUxvYWRlci9ibG9iL21hc3Rlci9zcmMvZGVjb2RlWUJSRnVsbC5qc1xyXG4gICAgICBsZXQgblBpeGVscyA9IHVuY29tcHJlc3NlZERhdGEubGVuZ3RoIC8gMztcclxuICAgICAgbGV0IHlickluZGV4ID0gMDtcclxuICAgICAgbGV0IHJnYmFJbmRleCA9IDA7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblBpeGVsczsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHkgPSB1bmNvbXByZXNzZWREYXRhW3lickluZGV4KytdO1xyXG4gICAgICAgIGxldCBjYiA9IHVuY29tcHJlc3NlZERhdGFbeWJySW5kZXgrK107XHJcbiAgICAgICAgbGV0IGNyID0gdW5jb21wcmVzc2VkRGF0YVt5YnJJbmRleCsrXTtcclxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHkgKyAxLjQwMjAwICogKGNyIC0gMTI4KTsvLyByZWRcclxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHkgLSAwLjM0NDE0ICogKGNiIC0gMTI4KSAtIDAuNzE0MTQgKiAoY3IgLSAxMjgpOyAvLyBncmVlblxyXG4gICAgICAgIHJnYkRhdGFbcmdiYUluZGV4KytdID0geSArIDEuNzcyMDAgKiAoY2IgLSAxMjgpOyAvLyBibHVlXHJcbiAgICAgICAgLy8gcmdiRGF0YVtyZ2JhSW5kZXgrK10gPSAyNTU7IC8vYWxwaGFcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgJ3Bob3RvbWV0cmljIGludGVycG9sYXRpb24gbm90IHN1cHBvcnRlZDogJHtwaG90b21ldHJpY0ludGVycHJldGF0aW9ufSc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJnYkRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTd2FwIGJ5dGVzIGluIGZyYW1lLlxyXG4gICAqL1xyXG4gIF9zd2FwRnJhbWUoZnJhbWUpIHtcclxuICAgIC8vIHN3YXAgYnl0ZXMgKCBpZiA4Yml0cyAoMWJ5dGUpLCBub3RoaW5nIHRvIHN3YXApXHJcbiAgICBsZXQgYml0c0FsbG9jYXRlZCA9IHRoaXMuYml0c0FsbG9jYXRlZCgpO1xyXG5cclxuICAgIGlmIChiaXRzQWxsb2NhdGVkID09PSAxNikge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZnJhbWVbaV0gPSB0aGlzLl9zd2FwMTYoZnJhbWVbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDMyKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmcmFtZVtpXSA9IHRoaXMuX3N3YXAzMihmcmFtZVtpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnJhbWU7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuLy8gVkpTLnBhcnNlcnMuZGljb20ucHJvdG90eXBlLmZyYW1lT2ZSZWZlcmVuY2VVSUQgPSBmdW5jdGlvbihpbWFnZUpxdWVyeURvbSkge1xyXG4vLyAgIC8vIHRyeSB0byBhY2Nlc3MgZnJhbWUgb2YgcmVmZXJlbmNlIFVJRCB0aHJvdWdoIGl0cyBESUNPTSB0YWdcclxuLy8gICBsZXQgc2VyaWVzTnVtYmVyID0gaW1hZ2VKcXVlcnlEb20uZmluZCgnW3RhZz1cIjAwMjAwMDUyXCJdIFZhbHVlJykudGV4dCgpO1xyXG5cclxuLy8gICAvLyBpZiBub3QgYXZhaWxhYmxlLCBhc3N1bWUgd2Ugb25seSBoYXZlIDEgZnJhbWVcclxuLy8gICBpZiAoc2VyaWVzTnVtYmVyID09PSAnJykge1xyXG4vLyAgICAgc2VyaWVzTnVtYmVyID0gMTtcclxuLy8gICB9XHJcbi8vICAgcmV0dXJuIHNlcmllc051bWJlcjtcclxuLy8gfTtcclxuXHJcbi8vXHJcbi8vIEVORElBTiBORVNTIE5PVCBUQUtFTiBDQVJFIE9GXHJcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTMyMDQzOS9ob3ctZG8taS1zd2FwLWVuZGlhbi1uZXNzLWJ5dGUtb3JkZXItb2YtYS1sZXRpYWJsZS1pbi1qYXZhc2NyaXB0XHJcbi8vIGh0dHA6Ly93d3cuYmFycmUubm9tLmZyL21lZGljYWwvc2FtcGxlcy9cclxuLy9cclxuLy9cclxuIiwiaW1wb3J0IERpY29tIGZyb20gJy4vcGFyc2Vycy5kaWNvbSc7XHJcbmltcG9ydCBOaWZ0aSBmcm9tICcuL3BhcnNlcnMubmlmdGknO1xyXG5pbXBvcnQgTnJyZCBmcm9tICcuL3BhcnNlcnMubnJyZCc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBwYXJzZXJzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIERpY29tLFxyXG4gIE5pZnRpLFxyXG4gIE5ycmQsXHJcbn07XHJcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xyXG5pbXBvcnQgUGFyc2Vyc1ZvbHVtZSBmcm9tICcuL3BhcnNlcnMudm9sdW1lJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHBhcnNlcnMvbWhkXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzTUhEIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XHJcbiAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQG1lbWJlclxyXG4gICAgICAqIEB0eXBlIHthcnJheWJ1ZmZlcn1cclxuICAgICovXHJcbiAgICB0aGlzLl9pZCA9IGlkO1xyXG4gICAgdGhpcy5fdXJsID0gZGF0YS51cmw7XHJcbiAgICB0aGlzLl9oZWFkZXIgPSB7fTtcclxuICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gcGFyc2UgaGVhZGVyIChtaGQpIGRhdGFcclxuICAgICAgbGV0IGxpbmVzID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEubWhkQnVmZmVyKS5zcGxpdCgnXFxuJyk7XHJcbiAgICAgIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcclxuICAgICAgICAgIGxldCBrZXl2YWx1ZSA9IGxpbmUuc3BsaXQoJz0nKTtcclxuICAgICAgICAgIGlmIChrZXl2YWx1ZS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhZGVyW2tleXZhbHVlWzBdLnRyaW0oKV0gPSBrZXl2YWx1ZVsxXS50cmltKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5faGVhZGVyLkRpbVNpemUgPSB0aGlzLl9oZWFkZXIuRGltU2l6ZS5zcGxpdCgnICcpO1xyXG4gICAgICB0aGlzLl9oZWFkZXIuRWxlbWVudFNwYWNpbmcgPSB0aGlzLl9oZWFkZXIuRWxlbWVudFNwYWNpbmcuc3BsaXQoJyAnKTtcclxuICAgICAgdGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeCA9IHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXguc3BsaXQoJyAnKTtcclxuICAgICAgdGhpcy5faGVhZGVyLk9mZnNldCA9IHRoaXMuX2hlYWRlci5PZmZzZXQuc3BsaXQoJyAnKTtcclxuICAgICAgLy9cclxuICAgICAgdGhpcy5fYnVmZmVyID0gZGF0YS5yYXdCdWZmZXI7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ29vb3BzLi4uIDooJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByaWdodEhhbmRlZCgpIHtcclxuICAgIGxldCBhbmF0b21pY2FsT3JpZW50YXRpb24gPSB0aGlzLl9oZWFkZXIuQW5hdG9taWNhbE9yaWVudGF0aW9uO1xyXG4gICAgaWYgKGFuYXRvbWljYWxPcmllbnRhdGlvbiA9PT0gJ1JBUycgfHxcclxuICAgICAgICBhbmF0b21pY2FsT3JpZW50YXRpb24gPT09ICdSUEknIHx8XHJcbiAgICAgICAgYW5hdG9taWNhbE9yaWVudGF0aW9uID09PSAnTFBTJyB8fFxyXG4gICAgICAgIGFuYXRvbWljYWxPcmllbnRhdGlvbiA9PT0gJ0xBSScpIHtcclxuICAgICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fcmlnaHRIYW5kZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcmlnaHRIYW5kZWQ7XHJcbiAgfVxyXG5cclxuICBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcclxuICAgIC8vIHVzZSBmaWxlbmFtZSArIHRpbWVzdGFtcC4uP1xyXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICB9XHJcblxyXG4gIG51bWJlck9mRnJhbWVzKCkge1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2hlYWRlci5EaW1TaXplWzJdLCAxMCk7XHJcbiAgfVxyXG5cclxuICBzb3BJbnN0YW5jZVVJRChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIGZyYW1lSW5kZXg7XHJcbiAgfVxyXG5cclxuICByb3dzKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5faGVhZGVyLkRpbVNpemVbMV0sIDEwKTtcclxuICB9XHJcblxyXG4gIGNvbHVtbnMoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9oZWFkZXIuRGltU2l6ZVswXSwgMTApO1xyXG4gIH1cclxuXHJcbiAgcGl4ZWxUeXBlKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyAwIC0gaW50XHJcbiAgICAvLyAxIC0gZmxvYXRcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSAxO1xyXG5cclxuICAgIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVUNIQVInIHx8XHJcbiAgICAgICAgdGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX0NIQVInKSB7XHJcbiAgICAgIGJpdHNBbGxvY2F0ZWQgPSA4O1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgICB0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVVNIT1JUJyB8fFxyXG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9TSE9SVCcpIHtcclxuICAgICAgYml0c0FsbG9jYXRlZCA9IDE2O1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgICB0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVUZMT0FUJyB8fFxyXG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9GTE9BVCcpIHtcclxuICAgICAgYml0c0FsbG9jYXRlZCA9IDMyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiaXRzQWxsb2NhdGVkO1xyXG4gIH1cclxuXHJcbiAgcGl4ZWxTcGFjaW5nKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgeCA9IHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLkVsZW1lbnRTcGFjaW5nWzBdLCAxMCk7XHJcbiAgICBsZXQgeSA9IHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLkVsZW1lbnRTcGFjaW5nWzFdLCAxMCk7XHJcbiAgICBsZXQgeiA9IHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLkVsZW1lbnRTcGFjaW5nWzJdLCAxMCk7XHJcbiAgICByZXR1cm4gW3gsIHksIHpdO1xyXG4gIH1cclxuXHJcbiAgaW1hZ2VPcmllbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGludmVydFggPSB0aGlzLl9oZWFkZXIuQW5hdG9taWNhbE9yaWVudGF0aW9uLm1hdGNoKC9MLykgPyAtMSA6IDE7XHJcbiAgICBsZXQgaW52ZXJ0WSA9IHRoaXMuX2hlYWRlci5BbmF0b21pY2FsT3JpZW50YXRpb24ubWF0Y2goL1AvKSA/IC0xIDogMTtcclxuXHJcbiAgICBsZXQgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXhbMF0pICogaW52ZXJ0WCxcclxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4WzFdKSAqIGludmVydFksXHJcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeFsyXSkpO1xyXG4gICAgeC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICBsZXQgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXhbM10pICogaW52ZXJ0WCxcclxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4WzRdKSAqIGludmVydFksXHJcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeFs1XSkpO1xyXG4gICAgeS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB4LngsIHgueSwgeC56LFxyXG4gICAgICB5LngsIHkueSwgeS56LFxyXG4gICAgICBdO1xyXG4gIH1cclxuXHJcbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuT2Zmc2V0WzBdKSxcclxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuT2Zmc2V0WzFdKSxcclxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuT2Zmc2V0WzJdKSxcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICBtaW5NYXhQaXhlbERhdGEocGl4ZWxEYXRhID0gW10pIHtcclxuICAgIGxldCBtaW5NYXggPSBbNjU1MzUsIC0zMjc2OF07XHJcbiAgICBsZXQgbnVtUGl4ZWxzID0gcGl4ZWxEYXRhLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBudW1QaXhlbHM7IGluZGV4KyspIHtcclxuICAgICAgbGV0IHNwdiA9IHBpeGVsRGF0YVtpbmRleF07XHJcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcclxuICAgICAgbWluTWF4WzFdID0gTWF0aC5tYXgobWluTWF4WzFdLCBzcHYpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtaW5NYXg7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0UGl4ZWxEYXRhKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVjb21wcmVzc1VuY29tcHJlc3NlZChmcmFtZUluZGV4KTtcclxuICB9XHJcblxyXG4gIF9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xyXG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcclxuICAgIGxldCBudW1QaXhlbHMgPVxyXG4gICAgICB0aGlzLnJvd3MoZnJhbWVJbmRleCkgKiB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCkgKiBudW1iZXJPZkNoYW5uZWxzO1xyXG4gICAgaWYgKCF0aGlzLnJpZ2h0SGFuZGVkKCkpIHtcclxuICAgICAgZnJhbWVJbmRleCA9IHRoaXMubnVtYmVyT2ZGcmFtZXMoKSAtIDEgLSBmcmFtZUluZGV4O1xyXG4gICAgfVxyXG4gICAgbGV0IGZyYW1lT2Zmc2V0ID0gZnJhbWVJbmRleCAqIG51bVBpeGVscztcclxuXHJcbiAgICBpZiAodGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX0NIQVInKSB7XHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQ7XHJcbiAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9VQ0hBUicpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldDtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9TSE9SVCcpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDI7XHJcbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVVNIT1JUJykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfRkxPQVQnKSB7XHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQgKiA0O1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCIvLyB1c2UgbmlmdGktanMgYW5kIGp1c3QgcGFyc2UgaGVhZGVyLj8/P1xyXG5cclxuLy8gU2xpY2VyIHdheSB0byBoYW5kbGUgaW1hZ2VzXHJcbi8vIHNob3VsZCBmb2xsb3cgaXQuLi5cclxuIC8vIDg5NyAgIGlmICggKHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdICE9IGlkeFNlcmllc0luc3RhbmNlVUlEICYmIHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdID49IDAgJiYgaWR4U2VyaWVzSW5zdGFuY2VVSUQgPj0gMCkgfHxcclxuIC8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XHJcbiAvLyA4OTkgICAgICAgICh0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdICE9IGlkeFRyaWdnZXJUaW1lICYmIHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gPj0gMCAmJiBpZHhUcmlnZ2VyVGltZSA+PSAwKSB8fFxyXG4gLy8gOTAwICAgICAgICAodGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSAhPSBpZHhFY2hvTnVtYmVycyAmJiB0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdID49IDAgJiYgaWR4RWNob051bWJlcnMgPj0gMCkgfHxcclxuIC8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XHJcbiAvLyA5MDIgICAgICAgICh0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gIT0gaWR4U2xpY2VMb2NhdGlvbiAmJiB0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gPj0gMCAmJiBpZHhTbGljZUxvY2F0aW9uID49IDApIHx8XHJcbiAvLyA5MDMgICAgICAgICh0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdICE9IGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ICYmIHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gPj0gMCAmJiBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCA+PSAwKSApXHJcbiAvLyA5MDQgICAgIHtcclxuIC8vIDkwNSAgICAgICBjb250aW51ZTtcclxuIC8vIDkwNiAgICAgfVxyXG5cclxuLy8gaHR0cDovL2JyYWluZGVyLm9yZy8yMDEyLzA5LzIzL3RoZS1uaWZ0aS1maWxlLWZvcm1hdC9cclxuXHJcbi8qKiAqIEltcG9ydHMgKioqL1xyXG5pbXBvcnQgUGFyc2Vyc1ZvbHVtZSBmcm9tICcuL3BhcnNlcnMudm9sdW1lJztcclxuXHJcbmxldCBOaWZ0aVJlYWRlciA9IHJlcXVpcmUoJ25pZnRpLXJlYWRlci1qcycpO1xyXG4vKipcclxuICogQG1vZHVsZSBwYXJzZXJzL25pZnRpXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzTmlmdGkgZXh0ZW5kcyBQYXJzZXJzVm9sdW1lIHtcclxuICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBAbWVtYmVyXHJcbiAgICAgICogQHR5cGUge2FycmF5YnVmZmVyfVxyXG4gICAgKi9cclxuICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICB0aGlzLl9hcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xyXG4gICAgdGhpcy5fdXJsID0gZGF0YS51cmw7XHJcbiAgICB0aGlzLl9kYXRhU2V0ID0gbnVsbDtcclxuICAgIHRoaXMuX25pZnRpSGVhZGVyID0gbnVsbDtcclxuICAgIHRoaXMuX25pZnRpSW1hZ2UgPSBudWxsO1xyXG4gICAgdGhpcy5fb3JkZXJlZCA9IHRydWU7XHJcbiAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG51bGw7XHJcblxyXG4gICAgLy9cclxuICAgIHRoaXMuX3FmYWMgPSAxLjA7XHJcblxyXG4gICAgaWYgKE5pZnRpUmVhZGVyLmlzTklGVEkodGhpcy5fYXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFTZXQgPSBOaWZ0aVJlYWRlci5yZWFkSGVhZGVyKHRoaXMuX2FycmF5QnVmZmVyKTtcclxuICAgICAgdGhpcy5fbmlmdGlJbWFnZSA9XHJcbiAgICAgICAgTmlmdGlSZWFkZXIucmVhZEltYWdlKHRoaXMuX2RhdGFTZXQsIHRoaXMuX2FycmF5QnVmZmVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93ICdwYXJzZXJzLm5pZnRpIGNvdWxkIG5vdCBwYXJzZSB0aGUgZmlsZSc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcclxuICAgIC8vIHVzZSBmaWxlbmFtZSArIHRpbWVzdGFtcC4uP1xyXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICB9XHJcblxyXG4gIG51bWJlck9mRnJhbWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuZGltc1szXTtcclxuICB9XHJcblxyXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XHJcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IDE7XHJcblxyXG4gICAgLy8gY2FuIGRpbXNbMF0gPj0gNSBhbmQgbm90IG11bHRpIGNoYW5uZWxzIHdpdGggUkdCIGRhdGF0eXBlY29kZT9cclxuXHJcbiAgICBpZiAodGhpcy5fZGF0YVNldC5kaW1zWzBdID49IDUpIHtcclxuICAgICAgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMuX2RhdGFTZXQuZGltc1s1XTtcclxuICAgICAgdGhpcy5fb3JkZXJlZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMTI4KSB7XHJcbiAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSAzO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMjMwNCkge1xyXG4gICAgICBudW1iZXJPZkNoYW5uZWxzID0gNDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVtYmVyT2ZDaGFubmVscztcclxuICB9XHJcblxyXG4gIHNvcEluc3RhbmNlVUlEKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcclxuICB9XHJcblxyXG4gIHJvd3MoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LmRpbXNbMl07XHJcbiAgfVxyXG5cclxuICBjb2x1bW5zKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5kaW1zWzFdO1xyXG4gIH1cclxuXHJcbiAgcGl4ZWxUeXBlKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAgICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQ4ICAgICAgICAgICA9IDI7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UMTYgICAgICAgICAgID0gNDtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9JTlQzMiAgICAgICAgICAgPSA4O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUMzIgICAgICAgID0gMTY7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDY0ICAgICAgPSAzMjtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9GTE9BVDY0ICAgICAgICA9IDY0O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1JHQjI0ICAgICAgICAgPSAxMjg7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UOCAgICAgICAgICA9IDI1NjtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9VSU5UMTYgICAgICAgID0gNTEyO1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQzMiAgICAgICAgPSA3Njg7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UNjQgICAgICAgID0gMTAyNDtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9VSU5UNjQgICAgICAgPSAxMjgwO1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUMTI4ICAgICA9IDE1MzY7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDEyOCAgID0gMTc5MjtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9DT01QTEVYMjU2ICAgPSAyMDQ4O1xyXG5cclxuICAgIC8vIDAgaW50ZWdlciwgMSBmbG9hdFxyXG5cclxuICAgIGxldCBwaXhlbFR5cGUgPSAwO1xyXG4gICAgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAxNiB8fFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gNjQgfHxcclxuICAgICAgdGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDE1MzYpIHtcclxuICAgICAgcGl4ZWxUeXBlID0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBwaXhlbFR5cGU7XHJcbiAgfVxyXG5cclxuICBiaXRzQWxsb2NhdGVkKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5udW1CaXRzUGVyVm94ZWw7XHJcbiAgfVxyXG5cclxuICBwaXhlbFNwYWNpbmcoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQucGl4RGltc1sxXSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5waXhEaW1zWzJdLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnBpeERpbXNbM10sXHJcbiAgICAgIF07XHJcbiAgfVxyXG5cclxuICBzbGljZVRoaWNrbmVzcygpIHtcclxuICAgIC8vIHNob3VsZCBiZSBhIHN0cmluZy4uLlxyXG4gICAgcmV0dXJuIG51bGw7Ly8gdGhpcy5fZGF0YVNldC5waXhEaW1zWzNdLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICBpbWFnZU9yaWVudGF0aW9uKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZGF0YVNldCk7XHJcbiAgICAvLyBodHRwOi8vbmlmdGkubmltaC5uaWguZ292L3B1Yi9kaXN0L3NyYy9uaWZ0aWxpYi9uaWZ0aTEuaFxyXG4gICAgLy8gaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxX2lvLmNcclxuICAgIGlmICh0aGlzLl9kYXRhU2V0LnFmb3JtX2NvZGUgPiAwKSB7XHJcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaXR3YXJlL0lUSy9ibG9iL21hc3Rlci9Nb2R1bGVzL0lPL05JRlRJL3NyYy9pdGtOaWZ0aUltYWdlSU8uY3h4XHJcbiAgICAgIGxldCBhID0gMC4wO1xyXG4gICAgICBsZXQgYiA9IHRoaXMuX2RhdGFTZXQucXVhdGVybl9iO1xyXG4gICAgICBsZXQgYyA9IHRoaXMuX2RhdGFTZXQucXVhdGVybl9jO1xyXG4gICAgICBsZXQgZCA9IHRoaXMuX2RhdGFTZXQucXVhdGVybl9kO1xyXG4gICAgICAvLyBjb21wdXRlIGFcclxuICAgICAgYSA9IDEuMCAtIChiKmIgKyBjKmMgKyBkKmQpO1xyXG4gICAgICBpZiAoYSA8IDAuMDAwMDAwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgLyogc3BlY2lhbCBjYXNlICovXHJcblxyXG4gICAgICAgIGEgPSAxLjAgLyBNYXRoLnNxcnQoYipiK2MqYytkKmQpO1xyXG4gICAgICAgIGIgKj0gYTsgYyAqPSBhOyBkICo9IGE7ICAgICAgICAvKiBub3JtYWxpemUgKGIsYyxkKSB2ZWN0b3IgKi9cclxuICAgICAgICBhID0gMC4wOyAgICAgICAgICAgICAgICAgICAgICAgLyogYSA9IDAgPT0+IDE4MCBkZWdyZWUgcm90YXRpb24gKi9cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhID0gTWF0aC5zcXJ0KGEpOyAgICAgICAgICAgICAgICAgICAgIC8qIGFuZ2xlID0gMiphcmNjb3MoYSkgKi9cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2RhdGFTZXQucGl4RGltc1swXSA8IDAuMCkge1xyXG4gICAgICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgLShhKmErYipiLWMqYy1kKmQpLFxyXG4gICAgICAgICAgLTIqKGIqYythKmQpLFxyXG4gICAgICAgICAgMiooYipkLWEqYyksXHJcbiAgICAgICAgICAtMiooYipjLWEqZCksXHJcbiAgICAgICAgICAtKGEqYStjKmMtYipiLWQqZCksXHJcbiAgICAgICAgICAyKihjKmQrYSpiKSxcclxuICAgICAgICBdO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LnNmb3JtX2NvZGUgPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdzZm9ybSA+IDAnKTtcclxuXHJcbiAgICAgIGxldCBzeCA9IHRoaXMuX2RhdGFTZXQuc3Jvd194O1xyXG4gICAgICBsZXQgc3kgPSB0aGlzLl9kYXRhU2V0LnNyb3dfeTtcclxuICAgICAgbGV0IHN6ID0gdGhpcy5fZGF0YVNldC5zcm93X3o7XHJcbiAgICAgIC8vIGZpbGwgSUpLVG9SQVNcclxuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDAsIHN4WzBdLCBzeFsxXSwgc3hbMl0sIHN4WzNdKTtcclxuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDEsIHN5WzBdLCBzeVsxXSwgc3lbMl0sIHN5WzNdKTtcclxuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDIsIHN6WzBdLCBzelsxXSwgc3pbMl0sIHN6WzNdKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5xZm9ybV9jb2RlID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdxZm9ybSA9PT0gMCcpO1xyXG5cclxuXHJcbiAgICAgIC8vIGZpbGwgSUpLVG9SQVNcclxuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDAsIE1SSS5waXhkaW1bMV0sIDAsIDAsIDApO1xyXG4gICAgICAvLyBnb29nLnZlYy5NYXQ0LnNldFJvd1ZhbHVlcyhJSktUb1JBUywgMSwgMCwgTVJJLnBpeGRpbVsyXSwgMCwgMCk7XHJcbiAgICAgIC8vIGdvb2cudmVjLk1hdDQuc2V0Um93VmFsdWVzKElKS1RvUkFTLCAyLCAwLCAwLCBNUkkucGl4ZGltWzNdLCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbMSwgMCwgMCwgMCwgMSwgMF07XHJcbiAgfVxyXG5cclxuICBpbWFnZVBvc2l0aW9uKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyBxb2Zmc2V0IGlzIFJBU1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgLXRoaXMuX2RhdGFTZXQucW9mZnNldF94LFxyXG4gICAgICAtdGhpcy5fZGF0YVNldC5xb2Zmc2V0X3ksXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQucW9mZnNldF96LFxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIGRpbWVuc2lvbkluZGV4VmFsdWVzKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGluc3RhbmNlTnVtYmVyKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcclxuICB9XHJcblxyXG4gIHdpbmRvd0NlbnRlcihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gY2FsYyBtaW4gYW5kIGNhbGMgbWF4XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHdpbmRvd1dpZHRoKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyBjYWxjIG1pbiBhbmQgY2FsYyBtYXhcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgcmVzY2FsZVNsb3BlKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zY2xfc2xvcGU7XHJcbiAgfVxyXG5cclxuICByZXNjYWxlSW50ZXJjZXB0KGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zY2xfaW50ZXJjZXB0O1xyXG4gIH1cclxuXHJcbiAgbWluTWF4UGl4ZWxEYXRhKHBpeGVsRGF0YSA9IFtdKSB7XHJcbiAgICBsZXQgbWluTWF4ID0gWzY1NTM1LCAtMzI3NjhdO1xyXG4gICAgbGV0IG51bVBpeGVscyA9IHBpeGVsRGF0YS5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtUGl4ZWxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGxldCBzcHYgPSBwaXhlbERhdGFbaW5kZXhdO1xyXG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHNwdik7XHJcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgc3B2KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWluTWF4O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBpeGVsRGF0YShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoZnJhbWVJbmRleCk7XHJcbiAgICAvLyBsZXQgYnVmZmVyID0gdGhpcy5fZGF0YVNldC5pbWFnZURhdGE7XHJcbiAgICAvLyBpZiAodGhpcy5fZGF0YVNldC5jb21wcmVzc2VkKSB7XHJcbiAgICAvLyBsZXQgYnVmZmVyID0gdGhpcy5fZGF0YVNldC5yYXdEYXRhWzBdO1xyXG4gICAgLy8gdHJ5IHtcclxuICAgIC8vICAgbGV0IGRhdGEgPSBwYWtvLmluZmxhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XHJcbiAgICAvLyAgIGJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xyXG4gICAgLy8gfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAvLyAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGJ1ZmZlcik7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gaXMgaXQgY29tcHJlc3NlZD9cclxuICAgIC8vIHllcy9ub1xyXG5cclxuICAgIC8vICAgICB0cnkge1xyXG4gICAgLy8gICB2YXIgcmVzdWx0ID0gcGFrby5pbmZsYXRlKGNvbXByZXNzZWQpO1xyXG4gICAgLy8gfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAvLyAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9VSU5UOCAgICAgICAgICAgPSAyO1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDE2ICAgICAgICAgICA9IDQ7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UMzIgICAgICAgICAgID0gODtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9GTE9BVDMyICAgICAgICA9IDE2O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVg2NCAgICAgID0gMzI7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQ2NCAgICAgICAgPSA2NDtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9SR0IyNCAgICAgICAgID0gMTI4O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDggICAgICAgICAgPSAyNTY7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDE2ICAgICAgICA9IDUxMjtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9VSU5UMzIgICAgICAgID0gNzY4O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDY0ICAgICAgICA9IDEwMjQ7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDY0ICAgICAgID0gMTI4MDtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9GTE9BVDEyOCAgICAgPSAxNTM2O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVgxMjggICA9IDE3OTI7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDI1NiAgID0gMjA0ODtcclxuXHJcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMubnVtYmVyT2ZDaGFubmVscygpO1xyXG4gICAgbGV0IG51bVBpeGVscyA9XHJcbiAgICAgIHRoaXMucm93cyhmcmFtZUluZGV4KSAqIHRoaXMuY29sdW1ucyhmcmFtZUluZGV4KSAqIG51bWJlck9mQ2hhbm5lbHM7XHJcbiAgICAvLyBpZiggIXRoaXMucmlnaHRIYW5kZWQoKSApe1xyXG4gICAgLy8gICBmcmFtZUluZGV4ID0gdGhpcy5udW1iZXJPZkZyYW1lcygpIC0gMSAtIGZyYW1lSW5kZXg7XHJcbiAgICAvLyB9XHJcbiAgICBsZXQgZnJhbWVPZmZzZXQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xyXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX25pZnRpSW1hZ2U7XHJcblxyXG4gICAgLy8gdXNlIGJpdHMgYWxsb2NhdGVkICYmIHBpeGVsIHJlcHJlbnNlbnRhdGlvbiB0b29cclxuICAgIGlmICghdGhpcy5fb3JkZXJlZCAmJiB0aGlzLl9vcmRlcmVkRGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAvLyBvcmRlciB0aGVuXHJcbiAgICAgIHRoaXMuX3Jlb3JkZXJEYXRhKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX29yZGVyZWREYXRhICE9PSBudWxsKSB7XHJcbiAgICAgIC8vIGp1c3QgYSBzbGljZS4uLlxyXG4gICAgICByZXR1cm4gdGhpcy5fb3JkZXJlZERhdGEuc2xpY2UoZnJhbWVPZmZzZXQsIGZyYW1lT2Zmc2V0ICsgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDIpIHtcclxuICAgICAgLy8gdW5zaWduZWQgaW50IDggYml0XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMjU2KSB7XHJcbiAgICAgIC8vIHNpZ25lZCBpbnQgOCBiaXRcclxuICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDUxMikge1xyXG4gICAgICAvLyB1bnNpZ25lZCBpbnQgMTYgYml0XHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQgKiAyO1xyXG4gICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA0KSB7XHJcbiAgICAgIC8vIHNpZ25lZCBpbnQgMTYgYml0XHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQgKiAyO1xyXG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDgpIHtcclxuICAgICAgLy8gc2lnbmVkIGludCAzMiBiaXRcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XHJcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMTYpIHtcclxuICAgICAgLy8gc2lnbmVkIGZsb2F0IDMyIGJpdFxyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBVbmtub3duIGRhdGEgdHlwZTogZGF0YXR5cGVDb2RlIDogJHt0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9yZW9yZGVyRGF0YSgpIHtcclxuICAgIHdpbmRvdy5jb25zb2xlLmxvZygncmUtb3JkZXInKTtcclxuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKCk7XHJcbiAgICBsZXQgbnVtUGl4ZWxzID0gdGhpcy5yb3dzKCkgKiB0aGlzLmNvbHVtbnMoKSAqIG51bWJlck9mQ2hhbm5lbHM7XHJcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5fbmlmdGlJbWFnZTtcclxuXHJcbiAgICBsZXQgdG90YWxOdW1QaXhlbHMgPSBudW1QaXhlbHMgKiB0aGlzLm51bWJlck9mRnJhbWVzKCk7XHJcbiAgICBsZXQgdG1wID0gbnVsbDtcclxuICAgIHRoaXMuX29yZGVyZWREYXRhID0gbnVsbDtcclxuXHJcbiAgICBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDIpIHtcclxuICAgICAgLy8gdW5zaWduZWQgOCBiaXRcclxuICAgICAgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XHJcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkodG1wLmxlbmd0aCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAyNTYpIHtcclxuICAgICAgLy8gc2lnbmVkIDggYml0XHJcbiAgICAgIHRtcCA9IG5ldyBJbnQ4QXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XHJcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhID0gbmV3IEludDhBcnJheSh0bXAubGVuZ3RoKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDUxMikge1xyXG4gICAgICB0bXAgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XHJcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhID0gbmV3IFVpbnQxNkFycmF5KHRtcC5sZW5ndGgpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gNCkge1xyXG4gICAgICB0bXAgPSBuZXcgSW50MTZBcnJheShidWZmZXIsIDAsIHRvdGFsTnVtUGl4ZWxzKTtcclxuICAgICAgdGhpcy5fb3JkZXJlZERhdGEgPSBuZXcgSW50MTZBcnJheSh0bXAubGVuZ3RoKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDE2KSB7XHJcbiAgICAgIHRtcCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XHJcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0bXAubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZS1vcmRlciBwaXhlbHMuLi5cclxuICAgIGxldCBudW1QaXhlbHMyID0gdG1wLmxlbmd0aCAvIDM7XHJcbiAgICBsZXQgcmdiYUluZGV4ID0gMDtcclxuICAgIGxldCBySW5kZXggPSAwO1xyXG4gICAgbGV0IGdJbmRleCA9IG51bVBpeGVsczI7XHJcbiAgICBsZXQgYkluZGV4ID0gbnVtUGl4ZWxzMiAqIDI7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QaXhlbHMyOyBpKyspIHtcclxuICAgICAgdGhpcy5fb3JkZXJlZERhdGFbcmdiYUluZGV4KytdID0gdG1wW3JJbmRleCsrXTsgLy8gcmVkXHJcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhW3JnYmFJbmRleCsrXSA9IHRtcFtnSW5kZXgrK107IC8vIGdyZWVuXHJcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhW3JnYmFJbmRleCsrXSA9IHRtcFtiSW5kZXgrK107IC8vIGJsdWVcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9vcmRlcmVkID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuIiwiLy8gdXNlIG5pZnRpLWpzIGFuZCBqdXN0IHBhcnNlIGhlYWRlci4/Pz9cclxuXHJcbi8vIFNsaWNlciB3YXkgdG8gaGFuZGxlIGltYWdlc1xyXG4vLyBzaG91bGQgZm9sbG93IGl0Li4uXHJcbiAvLyA4OTcgICBpZiAoICh0aGlzLT5JbmRleFNlcmllc0luc3RhbmNlVUlEc1trXSAhPSBpZHhTZXJpZXNJbnN0YW5jZVVJRCAmJiB0aGlzLT5JbmRleFNlcmllc0luc3RhbmNlVUlEc1trXSA+PSAwICYmIGlkeFNlcmllc0luc3RhbmNlVUlEID49IDApIHx8XHJcbiAvLyA4OTggICAgICAgICh0aGlzLT5JbmRleENvbnRlbnRUaW1lW2tdICE9IGlkeENvbnRlbnRUaW1lICYmIHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gPj0gMCAmJiBpZHhDb250ZW50VGltZSA+PSAwKSB8fFxyXG4gLy8gODk5ICAgICAgICAodGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSAhPSBpZHhUcmlnZ2VyVGltZSAmJiB0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdID49IDAgJiYgaWR4VHJpZ2dlclRpbWUgPj0gMCkgfHxcclxuIC8vIDkwMCAgICAgICAgKHRoaXMtPkluZGV4RWNob051bWJlcnNba10gIT0gaWR4RWNob051bWJlcnMgJiYgdGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSA+PSAwICYmIGlkeEVjaG9OdW1iZXJzID49IDApIHx8XHJcbiAvLyA5MDEgICAgICAgICh0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gIT0gaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiAgJiYgdGhpcy0+SW5kZXhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uW2tdID49IDAgJiYgaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiA+PSAwKSB8fFxyXG4gLy8gOTAyICAgICAgICAodGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdICE9IGlkeFNsaWNlTG9jYXRpb24gJiYgdGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdID49IDAgJiYgaWR4U2xpY2VMb2NhdGlvbiA+PSAwKSB8fFxyXG4gLy8gOTAzICAgICAgICAodGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSAhPSBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCAmJiB0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdID49IDAgJiYgaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgPj0gMCkgKVxyXG4gLy8gOTA0ICAgICB7XHJcbiAvLyA5MDUgICAgICAgY29udGludWU7XHJcbiAvLyA5MDYgICAgIH1cclxuXHJcbi8vIGh0dHA6Ly9icmFpbmRlci5vcmcvMjAxMi8wOS8yMy90aGUtbmlmdGktZmlsZS1mb3JtYXQvXHJcblxyXG4vKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XHJcblxyXG5sZXQgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKTtcclxubGV0IE5ycmRSZWFkZXIgPSByZXF1aXJlKCducnJkLWpzJyk7XHJcbi8qKlxyXG4gKiBAbW9kdWxlIHBhcnNlcnMvbmlmdGlcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlcnNOaWZ0aSBleHRlbmRzIFBhcnNlcnNWb2x1bWUge1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIEBtZW1iZXJcclxuICAgICAgKiBAdHlwZSB7YXJyYXlidWZmZXJ9XHJcbiAgICAqL1xyXG4gICAgdGhpcy5faWQgPSBpZDtcclxuICAgIHRoaXMuX2FycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XHJcbiAgICB0aGlzLl91cmwgPSBkYXRhLnVybDtcclxuICAgIHRoaXMuX2RhdGFTZXQgPSBudWxsO1xyXG4gICAgdGhpcy5fdW5wYWNrZWREYXRhID0gbnVsbDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLl9kYXRhU2V0ID0gTnJyZFJlYWRlci5wYXJzZSh0aGlzLl9hcnJheUJ1ZmZlcik7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuX2RhdGFTZXQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdvb29wcy4uLiA6KCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzLl9kYXRhU2V0KTtcclxuICB9XHJcblxyXG4gIHJpZ2h0SGFuZGVkKCkge1xyXG4gICAgaWYgKHRoaXMuX2RhdGFTZXQuc3BhY2UubWF0Y2goL15yaWdodC1hbnRlcmlvci1zdXBlcmlvci8pIHx8XHJcbiAgICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvXmxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yLykpIHtcclxuICAgICB0aGlzLl9yaWdodEhhbmRlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9yaWdodEhhbmRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9yaWdodEhhbmRlZDtcclxuICB9XHJcblxyXG4gIHNlcmllc0luc3RhbmNlVUlEKCkge1xyXG4gICAgLy8gdXNlIGZpbGVuYW1lICsgdGltZXN0YW1wLi4/XHJcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xyXG4gIH1cclxuXHJcbiAgbnVtYmVyT2ZGcmFtZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zaXplc1syXTtcclxuICB9XHJcblxyXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XHJcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IDE7XHJcbiAgICByZXR1cm4gbnVtYmVyT2ZDaGFubmVscztcclxuICB9XHJcblxyXG4gIHNvcEluc3RhbmNlVUlEKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcclxuICB9XHJcblxyXG4gIHJvd3MoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnNpemVzWzFdO1xyXG4gIH1cclxuXHJcbiAgY29sdW1ucyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc2l6ZXNbMF07XHJcbiAgfVxyXG5cclxuICBwaXhlbFR5cGUoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIDAgLSBpbnRcclxuICAgIC8vIDEgLSBmbG9hdFxyXG4gICAgbGV0IHBpeGVsVHlwZSA9IDA7XHJcbiAgICBpZiAodGhpcy5fZGF0YVNldC50eXBlID09PSAnZmxvYXQnKSB7XHJcbiAgICAgIHBpeGVsVHlwZSA9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGl4ZWxUeXBlO1xyXG4gIH1cclxuXHJcbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSAxO1xyXG5cclxuICAgIGlmICh0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdpbnQ4JyB8fFxyXG4gICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAndWludDgnIHx8XHJcbiAgICAgICB0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdjaGFyJykge1xyXG4gICAgICBiaXRzQWxsb2NhdGVkID0gODtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC50eXBlID09PSAnaW50MTYnIHx8XHJcbiAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQxNicgfHxcclxuICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnc2hvcnQnKSB7XHJcbiAgICAgIGJpdHNBbGxvY2F0ZWQgPSAxNjtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC50eXBlID09PSAnaW50MzInIHx8XHJcbiAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQzMicgfHxcclxuICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnZmxvYXQnKSB7XHJcbiAgICAgIGJpdHNBbGxvY2F0ZWQgPSAzMjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYml0c0FsbG9jYXRlZDtcclxuICB9XHJcblxyXG4gIHBpeGVsU3BhY2luZyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IHggPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMF0sXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzBdWzFdLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1swXVsyXSk7XHJcblxyXG4gICAgbGV0IHkgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMF0sXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzFdWzFdLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1sxXVsyXSk7XHJcblxyXG4gICAgbGV0IHogPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMl1bMF0sXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzJdWzFdLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1syXVsyXSk7XHJcblxyXG4gICAgcmV0dXJuIFt4Lmxlbmd0aCgpLCB5Lmxlbmd0aCgpLCB6Lmxlbmd0aCgpXTtcclxuICB9XHJcblxyXG4gIHNsaWNlVGhpY2tuZXNzKCkge1xyXG4gICAgLy8gc2hvdWxkIGJlIGEgc3RyaW5nLi4uXHJcbiAgICByZXR1cm4gbnVsbDsvLyB0aGlzLl9kYXRhU2V0LnBpeERpbXNbM10udG9TdHJpbmcoKTtcclxuICB9XHJcblxyXG4gIGltYWdlT3JpZW50YXRpb24oZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBpbnZlcnRYID0gdGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvcmlnaHQvKSA/IC0xIDogMTtcclxuICAgIGxldCBpbnZlcnRZID0gdGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvYW50ZXJpb3IvKSA/IC0xIDogMTtcclxuXHJcbiAgICBsZXQgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1swXVswXSAqIGludmVydFgsXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzBdWzFdICogaW52ZXJ0WSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMl0pO1xyXG4gICAgeC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICBsZXQgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1sxXVswXSAqIGludmVydFgsXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzFdWzFdICogaW52ZXJ0WSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMl0pO1xyXG4gICAgeS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB4LngsIHgueSwgeC56LFxyXG4gICAgICB5LngsIHkueSwgeS56LFxyXG4gICAgICBdO1xyXG4gIH1cclxuXHJcbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZU9yaWdpblswXSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZU9yaWdpblsxXSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZU9yaWdpblsyXSxcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICBkaW1lbnNpb25JbmRleFZhbHVlcyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpbnN0YW5jZU51bWJlcihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIGZyYW1lSW5kZXg7XHJcbiAgfVxyXG5cclxuICB3aW5kb3dDZW50ZXIoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIGNhbGMgbWluIGFuZCBjYWxjIG1heFxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB3aW5kb3dXaWR0aChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gY2FsYyBtaW4gYW5kIGNhbGMgbWF4XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJlc2NhbGVTbG9wZShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIDE7Ly8gdGhpcy5fZGF0YVNldC5zY2xfc2xvcGU7XHJcbiAgfVxyXG5cclxuICByZXNjYWxlSW50ZXJjZXB0KGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gMDsvLyB0aGlzLl9kYXRhU2V0LnNjbF9pbnRlcmNlcHQ7XHJcbiAgfVxyXG5cclxuICBtaW5NYXhQaXhlbERhdGEocGl4ZWxEYXRhID0gW10pIHtcclxuICAgIGxldCBtaW5NYXggPSBbNjU1MzUsIC0zMjc2OF07XHJcbiAgICBsZXQgbnVtUGl4ZWxzID0gcGl4ZWxEYXRhLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBudW1QaXhlbHM7IGluZGV4KyspIHtcclxuICAgICAgbGV0IHNwdiA9IHBpeGVsRGF0YVtpbmRleF07XHJcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcclxuICAgICAgbWluTWF4WzFdID0gTWF0aC5tYXgobWluTWF4WzFdLCBzcHYpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtaW5NYXg7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0UGl4ZWxEYXRhKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVjb21wcmVzc1VuY29tcHJlc3NlZChmcmFtZUluZGV4KTtcclxuICB9XHJcblxyXG4gIF9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5fZGF0YVNldC5idWZmZXI7XHJcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMubnVtYmVyT2ZDaGFubmVscygpO1xyXG4gICAgbGV0IG51bVBpeGVscyA9IHRoaXMucm93cyhmcmFtZUluZGV4KSAqIHRoaXMuY29sdW1ucyhmcmFtZUluZGV4KSAqIG51bWJlck9mQ2hhbm5lbHM7XHJcbiAgICBpZiAoIXRoaXMucmlnaHRIYW5kZWQoKSkge1xyXG4gICAgICBmcmFtZUluZGV4ID0gdGhpcy5udW1iZXJPZkZyYW1lcygpIC0gMSAtIGZyYW1lSW5kZXg7XHJcbiAgICB9XHJcbiAgICBsZXQgZnJhbWVPZmZzZXQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xyXG5cclxuICAgIC8vIHVucGFjayBkYXRhIGlmIG5lZWRlZFxyXG4gICAgaWYgKHRoaXMuX3VucGFja2VkRGF0YSA9PT0gbnVsbCAmJlxyXG4gICAgICB0aGlzLl9kYXRhU2V0LmVuY29kaW5nID09PSAnZ3ppcCcpIHtcclxuICAgICAgbGV0IHVucGFja2VkRGF0YSA9IHBha28uaW5mbGF0ZSh0aGlzLl9kYXRhU2V0LmJ1ZmZlcik7XHJcbiAgICAgIHRoaXMuX3VucGFja2VkRGF0YSA9IHVucGFja2VkRGF0YS5idWZmZXI7XHJcbiAgICAgIGJ1ZmZlciA9IHRoaXMuX3VucGFja2VkRGF0YTtcclxuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LmVuY29kaW5nID09PSAnZ3ppcCcpIHtcclxuICAgICAgYnVmZmVyID0gdGhpcy5fdW5wYWNrZWREYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2ludDgnIHx8XHJcbiAgICAgICB0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdjaGFyJykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0O1xyXG4gICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQ4Jykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0O1xyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdpbnQxNicgfHxcclxuICAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3Nob3J0Jykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcclxuICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAndWludDE2Jykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2ludDMyJykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcclxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAndWludDMyJykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2Zsb2F0Jykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgcGFyc2Vycy92b2x1bWVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlcnNWb2x1bWUge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHBpeGVsUmVwcmVzZW50YXRpb24oKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIG1vZGFsaXR5KCkge1xyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcblxyXG4gIHNlZ21lbnRhdGlvblR5cGUoKSB7XHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gIH1cclxuXHJcbiAgc2VnbWVudGF0aW9uU2VnbWVudHMoKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICByZWZlcmVuY2VkU2VnbWVudE51bWJlcihmcmFtZUluZGV4KSB7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICByaWdodEhhbmRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yaWdodEhhbmRlZDtcclxuICB9XHJcblxyXG4gIHNwYWNpbmdCZXR3ZWVuU2xpY2VzKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBudW1iZXJPZkNoYW5uZWxzKCkge1xyXG4gICAgcmV0dXJuIDE7XHJcbiAgfVxyXG5cclxuICBzbGljZVRoaWNrbmVzcygpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcblxyXG4gIGRpbWVuc2lvbkluZGV4VmFsdWVzKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGluc3RhbmNlTnVtYmVyKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcclxuICB9XHJcblxyXG4gIHdpbmRvd0NlbnRlcihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB3aW5kb3dXaWR0aChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICByZXNjYWxlU2xvcGUoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgcmVzY2FsZUludGVyY2VwdChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBfZGVjb21wcmVzc1VuY29tcHJlc3NlZCgpIHtcclxuXHJcbiAgfVxyXG5cclxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzUzMjA0MzkvaG93LWRvLWktc3dhcC1lbmRpYW4tbmVzcy1ieXRlLW9yZGVyLW9mLWEtdmFyaWFibGUtaW4tamF2YXNjcmlwdFxyXG4gIF9zd2FwMTYodmFsKSB7XHJcbiAgICByZXR1cm4gKCh2YWwgJiAweEZGKSA8PCA4KVxyXG4gICAgICB8ICgodmFsID4+IDgpICYgMHhGRik7XHJcbiAgfVxyXG5cclxuICBfc3dhcDMyKHZhbCkge1xyXG4gICAgcmV0dXJuICgodmFsICYgMHhGRikgPDwgMjQpXHJcbiAgICAgICAgICAgfCAoKHZhbCAmIDB4RkYwMCkgPDwgOClcclxuICAgICAgICAgICB8ICgodmFsID4+IDgpICYgMHhGRjAwKVxyXG4gICAgICAgICAgIHwgKCh2YWwgPj4gMjQpICYgMHhGRik7XHJcbiAgfVxyXG5cclxuICBpbnZlcnQoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHRyYW5zZmVyIHN5bnRheCBVSUQuXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICB0cmFuc2ZlclN5bnRheFVJRCgpIHtcclxuICAgIHJldHVybiAnbm8gdmFsdWUgcHJvdmlkZWQnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdHVkeSBkZXNjaXB0aW9uLlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgc3R1ZHlEZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiAnbm8gdmFsdWUgcHJvdmlkZWQnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXJpZXMgZGVzY2lwdGlvbi5cclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHNlcmllc0Rlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhdGllbnQgSUQuXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwYXRpZW50SUQoKSB7XHJcbiAgICByZXR1cm4gJ25vIHZhbHVlIHByb3ZpZGVkJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGF0aWVudCBuYW1lLlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcGF0aWVudE5hbWUoKSB7XHJcbiAgICByZXR1cm4gJ25vIHZhbHVlIHByb3ZpZGVkJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGF0aWVudCBhZ2UuXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwYXRpZW50QWdlKCkge1xyXG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhdGllbnQgYmlydGhkYXRlLlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcGF0aWVudEJpcnRoZGF0ZSgpIHtcclxuICAgIHJldHVybiAnbm8gdmFsdWUgcHJvdmlkZWQnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRpZW50IHNleC5cclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHBhdGllbnRTZXgoKSB7XHJcbiAgICByZXR1cm4gJ25vIHZhbHVlIHByb3ZpZGVkJztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFNoYWRlcnNCYXNlIGZyb20gJy4uL3NoYWRlcnMuYmFzZSc7XHJcblxyXG5jbGFzcyBJbnRlcnNlY3RCb3ggZXh0ZW5kcyBTaGFkZXJzQmFzZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMubmFtZSA9ICdpbnRlcnNlY3RCb3gnO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgcHJvcGVydGllcyBuYW1lc1xyXG4gICAgdGhpcy5fcmF5T3JpZ2luID0gJ3JheU9yaWdpbic7XHJcbiAgICB0aGlzLl9yYXlEaXJlY3Rpb24gPSAncmF5RGlyZWN0aW9uJztcclxuICAgIHRoaXMuX2FhYmJNaW4gPSAnYWFiYk1pbic7XHJcbiAgICB0aGlzLl9hYWJiTWF4ID0gJ2FhYmJNYXgnO1xyXG4gICAgdGhpcy5fdE5lYXIgPSAndE5lYXInO1xyXG4gICAgdGhpcy5fdEZhciA9ICd0RmFyJztcclxuICAgIHRoaXMuX2ludGVyc2VjdCA9ICdpbnRlcnNlY3QnO1xyXG4gIH1cclxuXHJcbiAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsXHJcbiAgICAgICByYXlPcmlnaW4gPSB0aGlzLl9yYXlPcmlnaW4sIHJheURpcmVjdGlvbiA9IHRoaXMuX3JheURpcmVjdGlvbixcclxuICAgICAgIGFhYmJNaW4gPSB0aGlzLl9hYWJiTWluLCBhYWJiTWF4ID0gdGhpcy5fYWFiYk1heCxcclxuICAgICAgIHROZWFyID0gdGhpcy5fdE5lYXIsIHRGYXIgPSB0aGlzLl90RmFyLFxyXG4gICAgICAgaW50ZXJzZWN0ID0gdGhpcy5faW50ZXJzZWN0KSB7XHJcbiAgICB0aGlzLl9iYXNlID0gYmFzZUZyYWdtZW50O1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZShyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgYWFiYk1pbiwgYWFiYk1heCwgdE5lYXIsIHRGYXIsIGludGVyc2VjdCk7XHJcbiAgfVxyXG5cclxuICBjb21wdXRlKHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBhYWJiTWluLCBhYWJiTWF4LCB0TmVhciwgdEZhciwgaW50ZXJzZWN0KSB7XHJcbiAgICB0aGlzLmNvbXB1dGVEZWZpbml0aW9uKCk7XHJcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xyXG4gICAgcmV0dXJuIGAke3RoaXMuX25hbWV9KCR7cmF5T3JpZ2lufSwgJHtyYXlEaXJlY3Rpb259LCAke2FhYmJNaW59LCAke2FhYmJNYXh9LCAke3ROZWFyfSwgJHt0RmFyfSwgJHtpbnRlcnNlY3R9KTtgO1xyXG4gIH1cclxuXHJcblxyXG4gIGNvbXB1dGVEZWZpbml0aW9uKCkge1xyXG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcclxudm9pZCAke3RoaXMuX25hbWV9KHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbiwgdmVjMyBib3hNaW4sIHZlYzMgYm94TWF4LCBvdXQgZmxvYXQgdE5lYXIsIG91dCBmbG9hdCB0RmFyLCBvdXQgYm9vbCBpbnRlcnNlY3Qpe1xyXG4gIC8vIGNvbXB1dGUgaW50ZXJzZWN0aW9uIG9mIHJheSB3aXRoIGFsbCBzaXggYmJveCBwbGFuZXNcclxuICB2ZWMzIGludlJheSA9IHZlYzMoMS4pIC8gcmF5RGlyZWN0aW9uO1xyXG4gIHZlYzMgdEJvdCA9IGludlJheSAqIChib3hNaW4gLSByYXlPcmlnaW4pO1xyXG4gIHZlYzMgdFRvcCA9IGludlJheSAqIChib3hNYXggLSByYXlPcmlnaW4pO1xyXG4gIC8vIHJlLW9yZGVyIGludGVyc2VjdGlvbnMgdG8gZmluZCBzbWFsbGVzdCBhbmQgbGFyZ2VzdCBvbiBlYWNoIGF4aXNcclxuICB2ZWMzIHRNaW4gPSBtaW4odFRvcCwgdEJvdCk7XHJcbiAgdmVjMyB0TWF4ID0gbWF4KHRUb3AsIHRCb3QpO1xyXG4gIC8vIGZpbmQgdGhlIGxhcmdlc3QgdE1pbiBhbmQgdGhlIHNtYWxsZXN0IHRNYXhcclxuICBmbG9hdCBsYXJnZXN0X3RNaW4gPSBtYXgobWF4KHRNaW4ueCwgdE1pbi55KSwgbWF4KHRNaW4ueCwgdE1pbi56KSk7XHJcbiAgZmxvYXQgc21hbGxlc3RfdE1heCA9IG1pbihtaW4odE1heC54LCB0TWF4LnkpLCBtaW4odE1heC54LCB0TWF4LnopKTtcclxuICB0TmVhciA9IGxhcmdlc3RfdE1pbjtcclxuICB0RmFyID0gc21hbGxlc3RfdE1heDtcclxuICBpbnRlcnNlY3QgPSBzbWFsbGVzdF90TWF4ID4gbGFyZ2VzdF90TWluO1xyXG59XHJcblxyXG4gICAgYDtcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBuZXcgSW50ZXJzZWN0Qm94KCk7XHJcbiIsImltcG9ydCBTaGFkZXJzQmFzZSBmcm9tICcuLi9zaGFkZXJzLmJhc2UnO1xyXG5cclxuY2xhc3MgVGV4dHVyZTNkIGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSAndGV4dHVyZTNkJztcclxuXHJcbiAgICAvLyBkZWZhdWx0IHByb3BlcnRpZXMgbmFtZXNcclxuICAgIHRoaXMuX2RhdGFDb29yZGluYXRlcyA9ICdkYXRhQ29vcmRpbmF0ZXMnO1xyXG4gICAgdGhpcy5fZGF0YVZhbHVlID0gJ2RhdGFWYWx1ZSc7XHJcbiAgICB0aGlzLl9vZmZzZXQgPSAnb2Zmc2V0JztcclxuICB9XHJcblxyXG4gICAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsIGRhdGFDb29yZGluYXRlcyA9IHRoaXMuX2RhdGFDb29yZGluYXRlcywgZGF0YVZhbHVlID0gdGhpcy5fZGF0YVZhbHVlLCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQpIHtcclxuICAgIHRoaXMuX2Jhc2UgPSBiYXNlRnJhZ21lbnQ7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlKGRhdGFDb29yZGluYXRlcywgZGF0YVZhbHVlLCBvZmZzZXQpO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZShkYXRhQ29vcmRpbmF0ZXMsIGRhdGFWYWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICB0aGlzLmNvbXB1dGVEZWZpbml0aW9uKCk7XHJcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xyXG4gICAgcmV0dXJuIGAke3RoaXMuX25hbWV9KCR7ZGF0YUNvb3JkaW5hdGVzfSwgJHtkYXRhVmFsdWV9LCAke29mZnNldH0pO2A7XHJcbiAgfVxyXG5cclxuXHJcbiAgY29tcHV0ZURlZmluaXRpb24oKSB7XHJcbiAgICB0aGlzLl9kZWZpbml0aW9uID0gYFxyXG52b2lkICR7dGhpcy5fbmFtZX0oaW4gaXZlYzMgZGF0YUNvb3JkaW5hdGVzLCBvdXQgdmVjNCBkYXRhVmFsdWUsIG91dCBpbnQgb2Zmc2V0KXtcclxuICAgIFxyXG4gIGludCBpbmRleCA9IGRhdGFDb29yZGluYXRlcy54XHJcbiAgICAgICAgICAgICsgZGF0YUNvb3JkaW5hdGVzLnkgKiB1RGF0YURpbWVuc2lvbnMueFxyXG4gICAgICAgICAgICArIGRhdGFDb29yZGluYXRlcy56ICogdURhdGFEaW1lbnNpb25zLnkgKiB1RGF0YURpbWVuc2lvbnMueDtcclxuICBpbnQgaW5kZXhQID0gaW50KGluZGV4L3VQYWNrZWRQZXJQaXhlbCk7XHJcbiAgb2Zmc2V0ID0gaW5kZXggLSAyKmluZGV4UDtcclxuXHJcbiAgLy8gTWFwIGRhdGEgaW5kZXggdG8gcmlnaHQgc2FtcGxlcjJEIHRleHR1cmVcclxuICBpbnQgdm94ZWxzUGVyVGV4dHVyZSA9IHVUZXh0dXJlU2l6ZSp1VGV4dHVyZVNpemU7XHJcbiAgaW50IHRleHR1cmVJbmRleCA9IGludChmbG9vcihmbG9hdChpbmRleFApIC8gZmxvYXQodm94ZWxzUGVyVGV4dHVyZSkpKTtcclxuICAvLyBtb2R1bG8gc2VlbXMgaW5jb3JyZWN0IHNvbWV0aW1lcy4uLlxyXG4gIC8vIGludCBpblRleHR1cmVJbmRleCA9IGludChtb2QoZmxvYXQoaW5kZXgpLCBmbG9hdCh0ZXh0dXJlU2l6ZSp0ZXh0dXJlU2l6ZSkpKTtcclxuICBpbnQgaW5UZXh0dXJlSW5kZXggPSBpbmRleFAgLSB2b3hlbHNQZXJUZXh0dXJlKnRleHR1cmVJbmRleDtcclxuXHJcbiAgLy8gR2V0IHJvdyBhbmQgY29sdW1uIGluIHRoZSB0ZXh0dXJlXHJcbiAgaW50IGNvbEluZGV4ID0gaW50KG1vZChmbG9hdChpblRleHR1cmVJbmRleCksIGZsb2F0KHVUZXh0dXJlU2l6ZSkpKTtcclxuICBpbnQgcm93SW5kZXggPSBpbnQoZmxvb3IoZmxvYXQoaW5UZXh0dXJlSW5kZXgpL2Zsb2F0KHVUZXh0dXJlU2l6ZSkpKTtcclxuXHJcbiAgLy8gTWFwIHJvdyBhbmQgY29sdW1uIHRvIHV2XHJcbiAgdmVjMiB1diA9IHZlYzIoMCwwKTtcclxuICB1di54ID0gKDAuNSArIGZsb2F0KGNvbEluZGV4KSkgLyBmbG9hdCh1VGV4dHVyZVNpemUpO1xyXG4gIHV2LnkgPSAxLiAtICgwLjUgKyBmbG9hdChyb3dJbmRleCkpIC8gZmxvYXQodVRleHR1cmVTaXplKTtcclxuXHJcbiAgLy9cclxuICBpZih0ZXh0dXJlSW5kZXggPT0gMCl7IGRhdGFWYWx1ZSA9IHRleHR1cmUyRCh1VGV4dHVyZUNvbnRhaW5lclswXSwgdXYpOyB9XHJcbiAgZWxzZSBpZih0ZXh0dXJlSW5kZXggPT0gMSl7ZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzFdLCB1dik7fVxyXG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDIpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbMl0sIHV2KTsgfVxyXG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDMpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbM10sIHV2KTsgfVxyXG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDQpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbNF0sIHV2KTsgfVxyXG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDUpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbNV0sIHV2KTsgfVxyXG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDYpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbNl0sIHV2KTsgfVxyXG5cclxufVxyXG4gICAgYDtcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBuZXcgVGV4dHVyZTNkKCk7XHJcbiIsImltcG9ydCBTaGFkZXJzQmFzZSBmcm9tICcuLi9zaGFkZXJzLmJhc2UnO1xyXG5cclxuY2xhc3MgVW5wYWNrIGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSAndW5wYWNrJztcclxuXHJcbiAgICAvLyBkZWZhdWx0IHByb3BlcnRpZXMgbmFtZXNcclxuICAgIHRoaXMuX3BhY2tlZERhdGEgPSAncGFja2VkRGF0YSc7XHJcbiAgICB0aGlzLl9vZmZzZXQgPSAnb2Zmc2V0JztcclxuICAgIHRoaXMuX3VucGFja2VkRGF0YSA9ICd1bnBhY2tlZERhdGEnO1xyXG5cclxuICAgIHRoaXMuX2Jhc2UuX3VuaWZvcm1zID17XHJcbiAgICAgIHVOdW1iZXJPZkNoYW5uZWxzOiB7XHJcbiAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgIH0sXHJcbiAgICAgIHVCaXRzQWxsb2NhdGVkOiB7XHJcbiAgICAgICAgdmFsdWU6IDE2LFxyXG4gICAgICB9LFxyXG4gICAgICB1UGl4ZWxUeXBlOiB7XHJcbiAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsIHBhY2tlZERhdGEgPSB0aGlzLl9wYWNrZWREYXRhLCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQsIHVucGFja2VkRGF0YSA9IHRoaXMuX3VucGFja2VkRGF0YSkge1xyXG4gICAgdGhpcy5fYmFzZSA9IGJhc2VGcmFnbWVudDtcclxuICAgIHJldHVybiB0aGlzLmNvbXB1dGUocGFja2VkRGF0YSwgb2Zmc2V0LCB1bnBhY2tlZERhdGEpO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZShwYWNrZWREYXRhLCBvZmZzZXQsIHVucGFja2VkRGF0YSkge1xyXG4gICAgdGhpcy5jb21wdXRlRGVmaW5pdGlvbigpO1xyXG4gICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zW3RoaXMuX25hbWVdID0gdGhpcy5fZGVmaW5pdGlvbjtcclxuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke3BhY2tlZERhdGF9LCAke29mZnNldH0sICR7dW5wYWNrZWREYXRhfSk7YDtcclxuICB9XHJcblxyXG4gIGNvbXB1dGVEZWZpbml0aW9uKCkge1xyXG4gICAgLy8gZnVuIHN0dWZmXHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgaWYgKHRoaXMuX2Jhc2UuX3VuaWZvcm1zLnVOdW1iZXJPZkNoYW5uZWxzLnZhbHVlID09PSAxKSB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5fYmFzZS5fdW5pZm9ybXMudUJpdHNBbGxvY2F0ZWQudmFsdWUpIHtcclxuXHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrOCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICBjb250ZW50ID0gdGhpcy51cGFjazE2KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAzMjpcclxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrMzIoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29udGVudCA9IHRoaXMudXBhY2tEZWZhdWx0KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrSWRlbnRpdHkoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9kZWZpbml0aW9uID0gYFxyXG52b2lkICR7dGhpcy5fbmFtZX0oaW4gdmVjNCBwYWNrZWREYXRhLCBpbiBpbnQgb2Zmc2V0LCBvdXQgdmVjNCB1bnBhY2tlZERhdGEpe1xyXG5cclxuJHtjb250ZW50fVxyXG5cclxufSAgXHJcbiAgICBgO1xyXG4gIH1cclxuXHJcbiAgdXBhY2s4KCkge1xyXG4gICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zWyd1SW50OCddID0gdGhpcy51SW50OCgpO1xyXG5cclxuICAgIHJldHVybiBgXHJcbnVJbnQ4KFxyXG4gIHBhY2tlZERhdGEucixcclxuICB1bnBhY2tlZERhdGEueCk7XHJcbiAgICBgO1xyXG4gIH1cclxuXHJcbiAgdXBhY2sxNigpIHtcclxuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUludDE2J10gPSB0aGlzLnVJbnQxNigpO1xyXG5cclxuICAgIHJldHVybiBgXHJcbnVJbnQxNihcclxuICBwYWNrZWREYXRhLnIgKiBmbG9hdCggMSAtIG9mZnNldCkgKyBwYWNrZWREYXRhLmIgKiBmbG9hdChvZmZzZXQpLFxyXG4gIHBhY2tlZERhdGEuZyAqIGZsb2F0KCAxIC0gb2Zmc2V0KSArIHBhY2tlZERhdGEuYSAqIGZsb2F0KG9mZnNldCksXHJcbiAgdW5wYWNrZWREYXRhLngpO1xyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIHVwYWNrMzIoKSB7XHJcbiAgICBpZiAodGhpcy5fYmFzZS5fdW5pZm9ybXMudVBpeGVsVHlwZS52YWx1ZSA9PT0gMCkge1xyXG4gICAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbJ3VJbnQzMiddID0gdGhpcy51SW50MzIoKTtcclxuXHJcbiAgICAgIHJldHVybiBgXHJcbnVJbnQzMihcclxuICBwYWNrZWREYXRhLnIsXHJcbiAgcGFja2VkRGF0YS5nLFxyXG4gIHBhY2tlZERhdGEuYixcclxuICBwYWNrZWREYXRhLmEsXHJcbiAgdW5wYWNrZWREYXRhLngpO1xyXG4gICAgICBgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zWyd1RmxvYXQzMiddID0gdGhpcy51RmxvYXQzMigpO1xyXG5cclxuICAgICAgcmV0dXJuIGBcclxudUZsb2F0MzIoXHJcbiAgcGFja2VkRGF0YS5yLFxyXG4gIHBhY2tlZERhdGEuZyxcclxuICBwYWNrZWREYXRhLmIsXHJcbiAgcGFja2VkRGF0YS5hLFxyXG4gIHVucGFja2VkRGF0YS54KTtcclxuICAgICAgYDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwYWNrSWRlbnRpdHkoKSB7XHJcbiAgICByZXR1cm4gYFxyXG5cclxudW5wYWNrZWREYXRhID0gcGFja2VkRGF0YTtcclxuXHJcbiAgICAgIGA7XHJcbiAgfVxyXG5cclxuICB1SW50OCgpIHtcclxuICAgIHJldHVybiBgXHJcbnZvaWQgdUludDgoaW4gZmxvYXQgciwgb3V0IGZsb2F0IHZhbHVlKXtcclxuICB2YWx1ZSA9IHIgKiAyNTYuO1xyXG59XHJcbiAgICBgO1xyXG4gIH1cclxuXHJcbiAgdUludDE2KCkge1xyXG4gICAgcmV0dXJuIGBcclxudm9pZCB1SW50MTYoaW4gZmxvYXQgciwgaW4gZmxvYXQgYSwgb3V0IGZsb2F0IHZhbHVlKXtcclxuICB2YWx1ZSA9IHIgKiAyNTYuICsgYSAqIDY1NTM2LjtcclxufVxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIHVJbnQzMigpIHtcclxuICAgIHJldHVybiBgXHJcbnZvaWQgdUludDMyKGluIGZsb2F0IHIsIGluIGZsb2F0IGcsIGluIGZsb2F0IGIsIGluIGZsb2F0IGEsIG91dCBmbG9hdCB2YWx1ZSl7XHJcbiAgdmFsdWUgPSByICogMjU2LiArIGcgKiA2NTUzNi4gKyBiICogMTY3NzcyMTYuICsgYSAqIDQyOTQ5NjcyOTYuO1xyXG59XHJcbiAgICBgO1xyXG4gIH1cclxuXHJcbiAgdUZsb2F0MzIoKSB7XHJcbiAgICByZXR1cm4gYFxyXG52b2lkIHVGbG9hdDMyKGluIGZsb2F0IHIsIGluIGZsb2F0IGcsIGluIGZsb2F0IGIsIGluIGZsb2F0IGEsIG91dCBmbG9hdCB2YWx1ZSl7XHJcblxyXG4gIC8vIGNyZWF0ZSBhcnJheXMgY29udGFpbmluZyBiaXRzIGZvciByZ2JhIHZhbHVlc1xyXG4gIC8vIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XHJcbiAgdmFsdWUgPSByICogMjU1LjtcclxuICBpbnQgYnl0ZW1lUls4XTtcclxuICBieXRlbWVSWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbMF0gKiAxMjgpO1xyXG4gIGJ5dGVtZVJbMV0gPSBpbnQoZmxvb3IodmFsdWUgLyA2NC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzFdICogNjQpO1xyXG4gIGJ5dGVtZVJbMl0gPSBpbnQoZmxvb3IodmFsdWUgLyAzMi4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzJdICogMzIpO1xyXG4gIGJ5dGVtZVJbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzNdICogMTYpO1xyXG4gIGJ5dGVtZVJbNF0gPSBpbnQoZmxvb3IodmFsdWUgLyA4LikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbNF0gKiA4KTtcclxuICBieXRlbWVSWzVdID0gaW50KGZsb29yKHZhbHVlIC8gNC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzVdICogNCk7XHJcbiAgYnl0ZW1lUls2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lUls2XSAqIDIpO1xyXG4gIGJ5dGVtZVJbN10gPSBpbnQoZmxvb3IodmFsdWUpKTtcclxuXHJcbiAgdmFsdWUgPSBnICogMjU1LjtcclxuICBpbnQgYnl0ZW1lR1s4XTtcclxuICBieXRlbWVHWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbMF0gKiAxMjgpO1xyXG4gIGJ5dGVtZUdbMV0gPSBpbnQoZmxvb3IodmFsdWUgLyA2NC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzFdICogNjQpO1xyXG4gIGJ5dGVtZUdbMl0gPSBpbnQoZmxvb3IodmFsdWUgLyAzMi4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzJdICogMzIpO1xyXG4gIGJ5dGVtZUdbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzNdICogMTYpO1xyXG4gIGJ5dGVtZUdbNF0gPSBpbnQoZmxvb3IodmFsdWUgLyA4LikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbNF0gKiA4KTtcclxuICBieXRlbWVHWzVdID0gaW50KGZsb29yKHZhbHVlIC8gNC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzVdICogNCk7XHJcbiAgYnl0ZW1lR1s2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lR1s2XSAqIDIpO1xyXG4gIGJ5dGVtZUdbN10gPSBpbnQoZmxvb3IodmFsdWUpKTtcclxuXHJcbiAgdmFsdWUgPSBiICogMjU1LjtcclxuICBpbnQgYnl0ZW1lQls4XTtcclxuICBieXRlbWVCWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbMF0gKiAxMjgpO1xyXG4gIGJ5dGVtZUJbMV0gPSBpbnQoZmxvb3IodmFsdWUgLyA2NC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzFdICogNjQpO1xyXG4gIGJ5dGVtZUJbMl0gPSBpbnQoZmxvb3IodmFsdWUgLyAzMi4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzJdICogMzIpO1xyXG4gIGJ5dGVtZUJbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzNdICogMTYpO1xyXG4gIGJ5dGVtZUJbNF0gPSBpbnQoZmxvb3IodmFsdWUgLyA4LikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbNF0gKiA4KTtcclxuICBieXRlbWVCWzVdID0gaW50KGZsb29yKHZhbHVlIC8gNC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzVdICogNCk7XHJcbiAgYnl0ZW1lQls2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQls2XSAqIDIpO1xyXG4gIGJ5dGVtZUJbN10gPSBpbnQoZmxvb3IodmFsdWUpKTtcclxuXHJcbiAgdmFsdWUgPSBhICogMjU1LjtcclxuICBpbnQgYnl0ZW1lQVs4XTtcclxuICBieXRlbWVBWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbMF0gKiAxMjgpO1xyXG4gIGJ5dGVtZUFbMV0gPSBpbnQoZmxvb3IodmFsdWUgLyA2NC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzFdICogNjQpO1xyXG4gIGJ5dGVtZUFbMl0gPSBpbnQoZmxvb3IodmFsdWUgLyAzMi4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzJdICogMzIpO1xyXG4gIGJ5dGVtZUFbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzNdICogMTYpO1xyXG4gIGJ5dGVtZUFbNF0gPSBpbnQoZmxvb3IodmFsdWUgLyA4LikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbNF0gKiA4KTtcclxuICBieXRlbWVBWzVdID0gaW50KGZsb29yKHZhbHVlIC8gNC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzVdICogNCk7XHJcbiAgYnl0ZW1lQVs2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQVs2XSAqIDIpO1xyXG4gIGJ5dGVtZUFbN10gPSBpbnQoZmxvb3IodmFsdWUpKTtcclxuXHJcbiAgLy8gY29tcHV0ZSBmbG9hdDMyIHZhbHVlIGZyb20gYml0IGFycmF5c1xyXG5cclxuICAvLyBzaWduXHJcbiAgaW50IGlzc2lnbmVkID0gMSAtIDIgKiBieXRlbWVSWzBdO1xyXG4gIC8vICAgaXNzaWduZWQgPSBpbnQocG93KC0xLiwgZmxvYXQoYnl0ZW1lUlswXSkpKTtcclxuXHJcbiAgLy8gZXhwb25lbnRcclxuICBpbnQgZXhwb25lbnQgPSAwO1xyXG5cclxuICBleHBvbmVudCArPSBieXRlbWVSWzFdICogaW50KHBvdygyLiwgNy4pKTtcclxuICBleHBvbmVudCArPSBieXRlbWVSWzJdICogaW50KHBvdygyLiwgNi4pKTtcclxuICBleHBvbmVudCArPSBieXRlbWVSWzNdICogaW50KHBvdygyLiwgNS4pKTtcclxuICBleHBvbmVudCArPSBieXRlbWVSWzRdICogaW50KHBvdygyLiwgNC4pKTtcclxuICBleHBvbmVudCArPSBieXRlbWVSWzVdICogaW50KHBvdygyLiwgMy4pKTtcclxuICBleHBvbmVudCArPSBieXRlbWVSWzZdICogaW50KHBvdygyLiwgMi4pKTtcclxuICBleHBvbmVudCArPSBieXRlbWVSWzddICogaW50KHBvdygyLiwgMS4pKTtcclxuXHJcbiAgZXhwb25lbnQgKz0gYnl0ZW1lR1swXTtcclxuXHJcblxyXG4gIC8vIGZyYWN0aW9uXHJcbiAgZmxvYXQgZnJhY3Rpb24gPSAwLjtcclxuXHJcbiAgZnJhY3Rpb24gPSBmbG9hdChieXRlbWVHWzFdKSAqIHBvdygyLiwgLTEuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzJdKSAqIHBvdygyLiwgLTIuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzNdKSAqIHBvdygyLiwgLTMuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzRdKSAqIHBvdygyLiwgLTQuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzVdKSAqIHBvdygyLiwgLTUuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzZdKSAqIHBvdygyLiwgLTYuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzddKSAqIHBvdygyLiwgLTcuKTtcclxuXHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQlswXSkgKiBwb3coMi4sIC04Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQlsxXSkgKiBwb3coMi4sIC05Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQlsyXSkgKiBwb3coMi4sIC0xMC4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbM10pICogcG93KDIuLCAtMTEuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzRdKSAqIHBvdygyLiwgLTEyLik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQls1XSkgKiBwb3coMi4sIC0xMy4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbNl0pICogcG93KDIuLCAtMTQuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzddKSAqIHBvdygyLiwgLTE1Lik7XHJcblxyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbMF0pICogcG93KDIuLCAtMTYuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzFdKSAqIHBvdygyLiwgLTE3Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVsyXSkgKiBwb3coMi4sIC0xOC4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbM10pICogcG93KDIuLCAtMTkuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzRdKSAqIHBvdygyLiwgLTIwLik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVs1XSkgKiBwb3coMi4sIC0yMS4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbNl0pICogcG93KDIuLCAtMjIuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzddKSAqIHBvdygyLiwgLTIzLik7XHJcblxyXG4gIHZhbHVlID0gZmxvYXQoaXNzaWduZWQpICogcG93KCAyLiwgZmxvYXQoZXhwb25lbnQgLSAxMjcpKSAqICgxLiArIGZyYWN0aW9uKTtcclxufVxyXG4gICAgYDtcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBuZXcgVW5wYWNrKCk7XHJcbiIsImltcG9ydCBTaGFkZXJzQmFzZSBmcm9tICcuLi9zaGFkZXJzLmJhc2UnO1xyXG5pbXBvcnQgVW5wYWNrIGZyb20gJy4uL2hlbHBlcnMvc2hhZGVycy5oZWxwZXJzLnVucGFjayc7XHJcbmltcG9ydCBUZXh0dXJlM2QgZnJvbSAnLi4vaGVscGVycy9zaGFkZXJzLmhlbHBlcnMudGV4dHVyZTNkJztcclxuXHJcblxyXG5jbGFzcyBJbnRlcnBvbGF0aW9uSWRlbnRpdHkgZXh0ZW5kcyBTaGFkZXJzQmFzZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMubmFtZSA9ICdpbnRlcnBvbGF0aW9uSWRlbnRpdHknO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgcHJvcGVydGllcyBuYW1lc1xyXG4gICAgdGhpcy5fY3VycmVudFZveGVsID0gJ2N1cnJlbnRWb3hlbCc7XHJcbiAgICB0aGlzLl9kYXRhVmFsdWUgPSAnZGF0YVZhbHVlJztcclxuICB9XHJcblxyXG4gICAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsIGN1cnJlbnRWb3hlbCA9IHRoaXMuX2N1cnJlbnRWb3hlbCwgZGF0YVZhbHVlID0gdGhpcy5fZGF0YVZhbHVlKSB7XHJcbiAgICB0aGlzLl9iYXNlID0gYmFzZUZyYWdtZW50O1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZShjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSk7XHJcbiAgfVxyXG5cclxuICBjb21wdXRlKGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlKSB7XHJcbiAgICB0aGlzLmNvbXB1dGVEZWZpbml0aW9uKCk7XHJcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xyXG4gICAgcmV0dXJuIGAke3RoaXMuX25hbWV9KCR7Y3VycmVudFZveGVsfSwgJHtkYXRhVmFsdWV9KTtgO1xyXG4gIH1cclxuXHJcblxyXG4gIGNvbXB1dGVEZWZpbml0aW9uKCkge1xyXG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcclxudm9pZCAke3RoaXMuX25hbWV9KGluIHZlYzMgY3VycmVudFZveGVsLCBvdXQgdmVjNCBkYXRhVmFsdWUpe1xyXG4gIC8vIGxvd2VyIGJvdW5kXHJcbiAgdmVjMyByY3VycmVudFZveGVsID0gdmVjMyhmbG9vcihjdXJyZW50Vm94ZWwueCArIDAuNSApLCBmbG9vcihjdXJyZW50Vm94ZWwueSArIDAuNSApLCBmbG9vcihjdXJyZW50Vm94ZWwueiArIDAuNSApKTtcclxuICBpdmVjMyB2b3hlbCA9IGl2ZWMzKGludChyY3VycmVudFZveGVsLngpLCBpbnQocmN1cnJlbnRWb3hlbC55KSwgaW50KHJjdXJyZW50Vm94ZWwueikpO1xyXG5cclxuICB2ZWM0IHRtcCA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xyXG4gIGludCBvZmZzZXQgPSAwO1xyXG5cclxuICAke1RleHR1cmUzZC5hcGkodGhpcy5fYmFzZSwgJ3ZveGVsJywgJ3RtcCcsICdvZmZzZXQnKX1cclxuICAke1VucGFjay5hcGkodGhpcy5fYmFzZSwgJ3RtcCcsICdvZmZzZXQnLCAnZGF0YVZhbHVlJyl9XHJcbn1cclxuICAgIGA7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IEludGVycG9sYXRpb25JZGVudGl0eSgpO1xyXG4iLCJpbXBvcnQgSW50ZXJwb2xhdGlvbklkZW50aXR5IGZyb20gJy4vc2hhZGVycy5pbnRlcnBvbGF0aW9uLmlkZW50aXR5JztcclxuaW1wb3J0IEludGVycG9sYXRpb25UcmlsaW5lYXIgZnJvbSAnLi9zaGFkZXJzLmludGVycG9sYXRpb24udHJpbGluZWFyJztcclxuXHJcbmZ1bmN0aW9uIHNoYWRlcnNJbnRlcnBvbGF0aW9uKGJhc2VGcmFnbWVudCwgY3VycmVudFZveGVsLCBkYXRhVmFsdWUsIGdyYWRpZW50KSB7XHJcbiAgc3dpdGNoKGJhc2VGcmFnbWVudC5fdW5pZm9ybXMudUludGVycG9sYXRpb24udmFsdWUpIHtcclxuXHJcbiAgICBjYXNlIDA6XHJcbiAgICAgIC8vIG5vIGludGVycG9sYXRpb25cclxuICAgICAgcmV0dXJuIEludGVycG9sYXRpb25JZGVudGl0eS5hcGkoYmFzZUZyYWdtZW50LCBjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSk7XHJcblxyXG4gICAgY2FzZSAxOlxyXG4gICAgICAvLyB0cmlsaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvblRyaWxpbmVhci5hcGkoYmFzZUZyYWdtZW50LCBjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSwgZ3JhZGllbnQpO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKGJhc2VGcmFnbWVudCwgY3VycmVudFZveGVsLCBkYXRhVmFsdWUpO1xyXG5cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNoYWRlcnNJbnRlcnBvbGF0aW9uO1xyXG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcclxuaW1wb3J0IEludGVycG9sYXRpb25JZGVudGl0eSBmcm9tICcuL3NoYWRlcnMuaW50ZXJwb2xhdGlvbi5pZGVudGl0eSc7XHJcblxyXG5jbGFzcyBJbnRlcnBvbGF0aW9uVHJpbGluZWFyIGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSAnaW50ZXJwb2xhdGlvblRyaWxpbmVhcic7XHJcblxyXG4gICAgLy8gZGVmYXVsdCBwcm9wZXJ0aWVzIG5hbWVzXHJcbiAgICB0aGlzLl9jdXJyZW50Vm94ZWwgPSAnY3VycmVudFZveGVsJztcclxuICAgIHRoaXMuX2RhdGFWYWx1ZSA9ICdkYXRhVmFsdWUnO1xyXG4gICAgdGhpcy5fZ3JhZGllbnQgPSAnZ3JhZGllbnQnO1xyXG4gIH1cclxuXHJcbiAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsIGN1cnJlbnRWb3hlbCA9IHRoaXMuX2N1cnJlbnRWb3hlbCwgZGF0YVZhbHVlID0gdGhpcy5fZGF0YVZhbHVlLCBncmFkaWVudCA9IHRoaXMuX2dyYWRpZW50KSB7XHJcbiAgICB0aGlzLl9iYXNlID0gYmFzZUZyYWdtZW50O1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZShjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSwgZ3JhZGllbnQpO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZShjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSwgZ3JhZGllbnQpIHtcclxuICAgIHRoaXMuY29tcHV0ZURlZmluaXRpb24oKTtcclxuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1t0aGlzLl9uYW1lXSA9IHRoaXMuX2RlZmluaXRpb247XHJcbiAgICByZXR1cm4gYCR7dGhpcy5fbmFtZX0oJHtjdXJyZW50Vm94ZWx9LCAke2RhdGFWYWx1ZX0sICR7Z3JhZGllbnR9KTtgO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZURlZmluaXRpb24oKSB7XHJcbiAgICB0aGlzLl9kZWZpbml0aW9uID0gYFxyXG52b2lkICR7dGhpcy5fbmFtZX0oaW4gdmVjMyBjdXJyZW50Vm94ZWwsIG91dCB2ZWM0IGRhdGFWYWx1ZSwgb3V0IHZlYzMgZ3JhZGllbnQpe1xyXG5cclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmlsaW5lYXJfaW50ZXJwb2xhdGlvblxyXG4gIHZlYzMgbG93ZXJfYm91bmQgPSB2ZWMzKGZsb29yKGN1cnJlbnRWb3hlbC54KSwgZmxvb3IoY3VycmVudFZveGVsLnkpLCBmbG9vcihjdXJyZW50Vm94ZWwueikpO1xyXG4gIGlmKGxvd2VyX2JvdW5kLnggPCAwLil7XHJcbiAgICBsb3dlcl9ib3VuZC54ID0gMC47XHJcbiAgfVxyXG4gIGlmKGxvd2VyX2JvdW5kLnkgPCAwLil7XHJcbiAgICBsb3dlcl9ib3VuZC55ID0gMC47XHJcbiAgfVxyXG4gIGlmKGxvd2VyX2JvdW5kLnogPCAwLil7XHJcbiAgICBsb3dlcl9ib3VuZC56ID0gMC47XHJcbiAgfVxyXG4gIFxyXG4gIHZlYzMgaGlnaGVyX2JvdW5kID0gbG93ZXJfYm91bmQgKyB2ZWMzKDEpO1xyXG5cclxuICBmbG9hdCB4ZCA9ICggY3VycmVudFZveGVsLnggLSBsb3dlcl9ib3VuZC54ICkgLyAoIGhpZ2hlcl9ib3VuZC54IC0gbG93ZXJfYm91bmQueCApO1xyXG4gIGZsb2F0IHlkID0gKCBjdXJyZW50Vm94ZWwueSAtIGxvd2VyX2JvdW5kLnkgKSAvICggaGlnaGVyX2JvdW5kLnkgLSBsb3dlcl9ib3VuZC55ICk7XHJcbiAgZmxvYXQgemQgPSAoIGN1cnJlbnRWb3hlbC56IC0gbG93ZXJfYm91bmQueiApIC8gKCBoaWdoZXJfYm91bmQueiAtIGxvd2VyX2JvdW5kLnogKTtcclxuXHJcbiAgLy9cclxuICAvLyBjMDBcclxuICAvL1xyXG5cclxuICAvL1xyXG5cclxuICB2ZWM0IHYwMDAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XHJcbiAgdmVjMyBjMDAwID0gdmVjMyhsb3dlcl9ib3VuZC54LCBsb3dlcl9ib3VuZC55LCBsb3dlcl9ib3VuZC56KTtcclxuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MwMDAnLCAndjAwMCcpfVxyXG4gIHZlYzMgZzAwMCA9IHYwMDAuciAqIHZlYzMoLTEuLCAtMS4sIC0xLik7XHJcblxyXG4gIC8vXHJcblxyXG4gIHZlYzQgdjEwMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcclxuICB2ZWMzIGMxMDAgPSB2ZWMzKGhpZ2hlcl9ib3VuZC54LCBsb3dlcl9ib3VuZC55LCBsb3dlcl9ib3VuZC56KTtcclxuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MxMDAnLCAndjEwMCcpfVxyXG4gIHZlYzMgZzEwMCA9IHYxMDAuciAqIHZlYzMoMS4sIC0xLiwgLTEuKTtcclxuXHJcbiAgdmVjNCBjMDAgPSB2MDAwICogKCAxLjAgLSB4ZCApICsgdjEwMCAqIHhkO1xyXG5cclxuICAvL1xyXG4gIC8vIGMwMVxyXG4gIC8vXHJcbiAgdmVjNCB2MDAxID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xyXG4gIHZlYzMgYzAwMSA9IHZlYzMobG93ZXJfYm91bmQueCwgbG93ZXJfYm91bmQueSwgaGlnaGVyX2JvdW5kLnopO1xyXG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzAwMScsICd2MDAxJyl9XHJcbiAgdmVjMyBnMDAxID0gdjAwMS5yICogdmVjMygtMS4sIC0xLiwgMS4pO1xyXG5cclxuICB2ZWM0IHYxMDEgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XHJcbiAgdmVjMyBjMTAxID0gdmVjMyhoaWdoZXJfYm91bmQueCwgbG93ZXJfYm91bmQueSwgaGlnaGVyX2JvdW5kLnopO1xyXG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzEwMScsICd2MTAxJyl9XHJcbiAgdmVjMyBnMTAxID0gdjEwMS5yICogdmVjMygxLiwgLTEuLCAxLik7XHJcblxyXG4gIHZlYzQgYzAxID0gdjAwMSAqICggMS4wIC0geGQgKSArIHYxMDEgKiB4ZDtcclxuXHJcbiAgLy9cclxuICAvLyBjMTBcclxuICAvL1xyXG4gIHZlYzQgdjAxMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcclxuICB2ZWMzIGMwMTAgPSB2ZWMzKGxvd2VyX2JvdW5kLngsIGhpZ2hlcl9ib3VuZC55LCBsb3dlcl9ib3VuZC56KTtcclxuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MwMTAnLCAndjAxMCcpfVxyXG4gIHZlYzMgZzAxMCA9IHYwMTAuciAqIHZlYzMoLTEuLCAxLiwgLTEuKTtcclxuXHJcbiAgdmVjNCB2MTEwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xyXG4gIHZlYzMgYzExMCA9IHZlYzMoaGlnaGVyX2JvdW5kLngsIGhpZ2hlcl9ib3VuZC55LCBsb3dlcl9ib3VuZC56KTtcclxuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MxMTAnLCAndjExMCcpfVxyXG4gIHZlYzMgZzExMCA9IHYxMTAuciAqIHZlYzMoMS4sIDEuLCAtMS4pO1xyXG5cclxuICB2ZWM0IGMxMCA9IHYwMTAgKiAoIDEuMCAtIHhkICkgKyB2MTEwICogeGQ7XHJcblxyXG4gIC8vXHJcbiAgLy8gYzExXHJcbiAgLy9cclxuICB2ZWM0IHYwMTEgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XHJcbiAgdmVjMyBjMDExID0gdmVjMyhsb3dlcl9ib3VuZC54LCBoaWdoZXJfYm91bmQueSwgaGlnaGVyX2JvdW5kLnopO1xyXG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzAxMScsICd2MDExJyl9XHJcbiAgdmVjMyBnMDExID0gdjAxMS5yICogdmVjMygtMS4sIDEuLCAxLik7XHJcblxyXG4gIHZlYzQgdjExMSA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcclxuICB2ZWMzIGMxMTEgPSB2ZWMzKGhpZ2hlcl9ib3VuZC54LCBoaWdoZXJfYm91bmQueSwgaGlnaGVyX2JvdW5kLnopO1xyXG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzExMScsICd2MTExJyl9XHJcbiAgdmVjMyBnMTExID0gdjExMS5yICogdmVjMygxLiwgMS4sIDEuKTtcclxuXHJcbiAgdmVjNCBjMTEgPSB2MDExICogKCAxLjAgLSB4ZCApICsgdjExMSAqIHhkO1xyXG5cclxuICAvLyBjMCBhbmQgYzFcclxuICB2ZWM0IGMwID0gYzAwICogKCAxLjAgLSB5ZCkgKyBjMTAgKiB5ZDtcclxuICB2ZWM0IGMxID0gYzAxICogKCAxLjAgLSB5ZCkgKyBjMTEgKiB5ZDtcclxuXHJcbiAgLy8gY1xyXG4gIHZlYzQgYyA9IGMwICogKCAxLjAgLSB6ZCkgKyBjMSAqIHpkO1xyXG4gIGRhdGFWYWx1ZSA9IGM7XHJcblxyXG4gIC8vIGNvbXB1dGUgZ3JhZGllbnRcclxuICBncmFkaWVudCA9IGcwMDAgKyBnMTAwICsgZzAxMCArIGcxMTAgKyBnMDExICsgZzExMSArIGcxMTAgKyBnMDExO1xyXG4gIC8vIGdyYWRpZW50TWFnbml0dWRlID0gbGVuZ3RoKGdyYWRpZW50KTtcclxuICAvLyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ob3JtYWxfKGdlb21ldHJ5KSNUcmFuc2Zvcm1pbmdfbm9ybWFsc1xyXG4gIC8vIHZlYzMgbG9jYWxOb3JtYWwgPSAoLTEuIC8gZ3JhZGllbnRNYWduaXR1ZGUpICogZ3JhZGllbnQ7XHJcbiAgLy8gbm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbFBpeGVsVG9QYXRpZW50JHt0aGlzLmlkfSAqIGxvY2FsTm9ybWFsKTtcclxuICAvL25vcm1hbCA9IGdyYWRpZW50O1xyXG5cclxufVxyXG4gICAgYDtcclxuICB9XHJcblxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IEludGVycG9sYXRpb25UcmlsaW5lYXIoKTtcclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0Jhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX25hbWUgPSAnc2hhZGVyc0Jhc2UnO1xyXG4gICAgdGhpcy5fYmFzZSA9IHtcclxuICAgICAgX2Z1bmN0aW9uczoge30sXHJcbiAgICAgIF91bmlmb3Jtczoge30sXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9ICcnO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG5hbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICB9XHJcblxyXG4gIHNldCBuYW1lKG5hbWUpIHtcclxuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzRnJhZ21lbnQge1xyXG5cclxuICAvLyBwYXNzIHVuaWZvcm1zIG9iamVjdFxyXG4gIGNvbnN0cnVjdG9yKHVuaWZvcm1zKSB7XHJcbiAgICB0aGlzLl91bmlmb3JtcyA9IHVuaWZvcm1zO1xyXG4gICAgdGhpcy5fZnVuY3Rpb25zID0ge307XHJcbiAgICB0aGlzLl9tYWluID0gJyc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbnMoKSB7XHJcbiAgICBpZih0aGlzLl9tYWluID09PSAnJykge1xyXG4gICAgICAvLyBpZiBtYWluIGlzIGVtcHR5LCBmdW5jdGlvbnMgY2FuIG5vdCBoYXZlIGJlZW4gY29tcHV0ZWRcclxuICAgICAgdGhpcy5tYWluKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX2Z1bmN0aW9ucykge1xyXG4gICAgICBjb250ZW50ICs9IHRoaXMuX2Z1bmN0aW9uc1twcm9wZXJ0eV0gKyAnXFxuJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGVudDtcclxuICB9XHJcblxyXG4gIHVuaWZvcm1zKCkge1xyXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX3VuaWZvcm1zKSB7XHJcbiAgICAgIGxldCB1bmlmb3JtID0gdGhpcy5fdW5pZm9ybXNbcHJvcGVydHldO1xyXG4gICAgICBjb250ZW50ICs9IGB1bmlmb3JtICR7dW5pZm9ybS50eXBlR0xTTH0gJHtwcm9wZXJ0eX1gO1xyXG5cclxuICAgICAgaWYodW5pZm9ybSAmJiB1bmlmb3JtLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRlbnQgKz0gYFske3VuaWZvcm0ubGVuZ3RofV1gO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb250ZW50ICs9ICc7XFxuJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGVudDtcclxuICB9XHJcblxyXG4gIG1haW4oKSB7XHJcbiAgICAvLyBuZWVkIHRvIHByZS1jYWxsIG1haW4gdG8gZmlsbCB1cCB0aGUgZnVuY3Rpb25zIGxpc3RcclxuICAgIHRoaXMuX21haW4gPSBgXHJcblxyXG4gICAgZmxvYXQgbHVtYSAodmVjMyByZ2IpIHtcclxuXHRyZXR1cm4gKHJnYi5yICsgcmdiLmcgKyByZ2IuYikvMy4wO1xyXG59XHJcblxyXG5jb25zdCBmbG9hdCBUID0gMC4wNDtcclxuY29uc3QgZmxvYXQgTSA9IDEuMDtcclxuY29uc3QgZmxvYXQgTCA9IDAuMDAyO1xyXG5cclxudm9pZCBtYWluKHZvaWQpIHtcclxuXHJcbiAgdmVjMiB0ZXhDb29yZCA9IHZlYzIoKCh2UHJvamVjdGVkQ29vcmRzLnggLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAsXHJcbiAgICAgICAgICAgICAgICAoKHZQcm9qZWN0ZWRDb29yZHMueSAvIHZQcm9qZWN0ZWRDb29yZHMudykgKyAxLjAgKSAvIDIuMCApO1xyXG5cclxuICBmbG9hdCBib3JkZXJXaWR0aCA9IHVXaWR0aDsgLy8gaW4gcHhcclxuICBmbG9hdCBzdGVwX3UgPSBib3JkZXJXaWR0aCAqIDEuMCAvIHVDYW52YXNXaWR0aDtcclxuICBmbG9hdCBzdGVwX3YgPSBib3JkZXJXaWR0aCAqIDEuMCAvIHVDYW52YXNIZWlnaHQ7XHJcbiAgdmVjNCBjZW50ZXJQaXhlbCA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQpO1xyXG5cclxuICB2ZWM0IHJpZ2h0UGl4ZWwgID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoc3RlcF91LCAwLjApKTtcclxuICB2ZWM0IGJvdHRvbVBpeGVsID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoMC4wLCBzdGVwX3YpKTtcclxuXHJcbiAgLy8gbm93IG1hbnVhbGx5IGNvbXB1dGUgdGhlIGRlcml2YXRpdmVzXHJcbiAgZmxvYXQgX2RGZFggPSBsZW5ndGgocmlnaHRQaXhlbCAtIGNlbnRlclBpeGVsKSAvIHN0ZXBfdTtcclxuICBmbG9hdCBfZEZkWSA9IGxlbmd0aChib3R0b21QaXhlbCAtIGNlbnRlclBpeGVsKSAvIHN0ZXBfdjtcclxuXHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLnIgPSBfZEZkWDtcclxuICAvLyBnbF9GcmFnQ29sb3IuZyA9IF9kRmRZO1xyXG4gIGdsX0ZyYWdDb2xvci5yID0gbWF4KG1heChjZW50ZXJQaXhlbC5yLCByaWdodFBpeGVsLnIpLCBib3R0b21QaXhlbC5yKTtcclxuICBnbF9GcmFnQ29sb3IuZyA9IG1heChtYXgoY2VudGVyUGl4ZWwuZywgcmlnaHRQaXhlbC5nKSwgYm90dG9tUGl4ZWwuZyk7XHJcbiAgZ2xfRnJhZ0NvbG9yLmIgPSBtYXgobWF4KGNlbnRlclBpeGVsLmIsIHJpZ2h0UGl4ZWwuYiksIGJvdHRvbVBpeGVsLmIpO1xyXG4gIGdsX0ZyYWdDb2xvci5hID0gbWF4KF9kRmRYLCBfZEZkWSk7XHJcblxyXG4gIHJldHVybjtcclxuICBmbG9hdCBoID0gMS4vdUNhbnZhc0hlaWdodDtcclxuICBmbG9hdCB3ID0gMS4vdUNhbnZhc1dpZHRoO1xyXG4gIHZlYzQgbls5XTtcclxuICBuWzBdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3JkcyArIHZlYzIoIC13LCAtaCkpO1xyXG4gIG5bMV0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMigwLjAsIC1oKSk7XHJcbiAgblsyXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAgdywgLWgpKTtcclxuICBuWzNdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3JkcyArIHZlYzIoIC13LCAwLjApKTtcclxuICBuWzRdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3Jkcyk7XHJcbiAgbls1XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAgdywgMC4wKSk7XHJcbiAgbls2XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAtdywgaCkpO1xyXG4gIG5bN10gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMigwLjAsIGgpKTtcclxuICBuWzhdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoICB3LCBoKSk7XHJcbiAgdmVjNCBzb2JlbF9ob3JpekVkZ2UgPSBuWzJdICsgKDIuMCpuWzVdKSArIG5bOF0gLSAoblswXSArICgyLjAqblszXSkgKyBuWzZdKTtcclxuICB2ZWM0IHNvYmVsX3ZlcnRFZGdlICA9IG5bMF0gKyAoMi4wKm5bMV0pICsgblsyXSAtIChuWzZdICsgKDIuMCpuWzddKSArIG5bOF0pO1xyXG4gIHZlYzMgc29iZWwgPSBzcXJ0KChzb2JlbF9ob3JpekVkZ2UucmdiICogc29iZWxfaG9yaXpFZGdlLnJnYikgKyAoc29iZWxfdmVydEVkZ2UucmdiICogc29iZWxfdmVydEVkZ2UucmdiKSk7XHJcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggc29iZWwsIG1heChtYXgoc29iZWwuciwgc29iZWwuZyksIHNvYmVsLmIpICk7XHJcblxyXG5cclxuICByZXR1cm47XHJcblxyXG4gIGdsX0ZyYWdDb2xvci5yID0gKHRleENvb3JkICsgdmVjMigwLjAsIHN0ZXBfdikpLnI7XHJcbiAgZ2xfRnJhZ0NvbG9yLmcgPSAodGV4Q29vcmQgKyB2ZWMyKHN0ZXBfdSwgMC4wKSkuZztcclxuICBnbF9GcmFnQ29sb3IgPSBjZW50ZXJQaXhlbDtcclxuICBnbF9GcmFnQ29sb3IuciA9IHRleENvb3JkLng7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmcgPSAodGV4Q29vcmQgKyB2ZWMyKDAuMCwgc3RlcF92KSkueDtcclxuICBnbF9GcmFnQ29sb3IuYiA9ICh0ZXhDb29yZCArIHZlYzIoc3RlcF91LCAwLjApKS54O1xyXG4gIGdsX0ZyYWdDb2xvci5yZyA9ICh0ZXhDb29yZCArIHZlYzIoMC4wLCBzdGVwX3YpKTtcclxuICBnbF9GcmFnQ29sb3IuYiA9IDAuO1xyXG4gIHJldHVybjtcclxuICB2ZWMyIHRleENvb3JkU2xvcGUgPSBmd2lkdGgodGV4Q29vcmQpO1xyXG4gIHZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3Jkcyk7XHJcbiAgLy8gZGZkeCB0aGF0IHZQcm9qZWN0ZWRUZXh0Q29vcmRzXHJcbiAgZmxvYXQgbCA9IGx1bWEgKGNvbG9yMi5yZ2IpIDtcclxuICAgIGZsb2F0IGx1bWluYW5jZSA9IGRvdChjb2xvcjIucmdiLHZlYzMoMC4yMTI2LCAwLjcxNTIsIDAuMDcyMikpO1xyXG5cclxuICBcdGZsb2F0IHEwID0gZndpZHRoIChsdW1pbmFuY2UpO1xyXG4gICAgaWYocTAgPiAwLjAxKXtcclxuICAgICAgcTAgPSAxLjA7XHJcbiAgICB9XHJcblx0ZmxvYXQgcTEgPSBhYnMgKGRGZHggKGwpKTsgXHJcblx0ZmxvYXQgcTIgPSBhYnMgKGRGZHkgKGwpKTtcclxuXHJcbiAgXHR2ZWM0IGN0ID0gdmVjNCAoMS4wLCAxLjAsIDEuMCwgMC4wKTtcclxuXHR2ZWM0IGMwID0gbWl4IChjdCwgdmVjNCAoMS4wLCAwLjAsIDAuMCwgMS4wKSwgXHJcblx0XHRzbW9vdGhzdGVwIChUICogKDEuMCAtIE0pLCBUICogKDEuMCArIE0pLCBxMCkpO1xyXG5cclxuZ2xfRnJhZ0NvbG9yLnIgPSBmd2lkdGgoY29sb3IyLnIpOy8vYWJzKGRGZHgoY29sb3IyLmIpKTsvL3RleENvb3JkOy8vY29sb3IyLnJnYjtcclxuZ2xfRnJhZ0NvbG9yLmcgPSBmd2lkdGgoY29sb3IyLmcpO1xyXG5nbF9GcmFnQ29sb3IuYiA9IGZ3aWR0aChjb2xvcjIuYik7XHJcbmdsX0ZyYWdDb2xvci5hID0gMS47XHJcbi8vIGdsX0ZyYWdDb2xvci5hID0gcTA7XHJcbi8vIGdsX0ZyYWdDb2xvciA9IGNvbG9yMjtcclxuLy9yZXR1cm47XHJcblxyXG5cclxuICAvL1RoZSBiYWNrIHBvc2l0aW9uIGlzIHRoZSB3b3JsZCBzcGFjZSBwb3NpdGlvbiBzdG9yZWQgaW4gdGhlIHRleHR1cmUuXHJcbiAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQpO1xyXG4gIGZsb2F0IGxDb2xvciA9IGxlbmd0aChjb2xvci5yZ2IpO1xyXG4gIGZsb2F0IG1heENvbG9yID0gbGVuZ3RoKGNvbG9yLnJnYik7Ly9tYXgobWF4KGNvbG9yLnIsIGNvbG9yLmcpLCBjb2xvci5iKTtcclxuICAvLyBpZihtYXhDb2xvciA+IDAuMSl7XHJcbiAgLy8gICBtYXhDb2xvciA9IDEuMDtcclxuICAvLyB9XHJcblxyXG5cclxuXHJcbiAgLy8gZ2xfRnJhZ0NvbG9yID0gY29sb3I7Ly92ZWM0KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIDEpO1xyXG4gIC8vIHJldHVybjtcclxuICAvLyBmbG9hdCB0bXB4eCAgPSBhYnMoZEZkeChsQ29sb3IpKTtcclxuICAvLyBmbG9hdCB0bXB4eSAgPSBhYnMoZEZkeShsQ29sb3IpKTtcclxuICAvLyBmbG9hdCB0bXB4ID0gbWF4KHRtcHh4LHRtcHh5KTtcclxuXHJcbiAgLy8gZmxvYXQgdG1weXggID0gYWJzKGRGZHgoY29sb3IueSkpO1xyXG4gIC8vIGZsb2F0IHRtcHl5ICA9IGFicyhkRmR5KGNvbG9yLnkpKTtcclxuICAvLyBmbG9hdCB0bXB5ID0gbWF4KHRtcHl4LHRtcHl5KTtcclxuXHJcbiAgLy8gZmxvYXQgdG1wenggID0gYWJzKGRGZHgoY29sb3IueikpO1xyXG4gIC8vIGZsb2F0IHRtcHp5ICA9IGFicyhkRmR5KGNvbG9yLnopKTtcclxuICAvLyBmbG9hdCB0bXB6ID0gbWF4KHRtcHp4LHRtcHp5KTtcclxuXHJcbiAgLy8gZmxvYXQgdG1wbWF4ID0gbWF4KG1heCh0bXB4LCB0bXB5KSwgdG1weik7XHJcbiAgLy8gaWYodG1wbWF4ID4gMC4wMSl7XHJcbiAgLy8gICB0bXBtYXggPSAxLjA7XHJcbiAgLy8gfVxyXG4gIC8vIGdsX0ZyYWdDb2xvci5yID0gdG1weDsvL3Ntb290aHN0ZXAodG1weC01LiwgdG1weCs1LiwgbENvbG9yKTtcclxuICAvLyBnbF9GcmFnQ29sb3IuZyA9IHRtcHg7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmIgPSB0bXB4O1xyXG5cclxuICAvLyB2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdmVjMih0ZXhjWCwgdGV4Y1kpKTtcclxuXHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLnIgPSBjb2xvci5yIC0gdGV4Y1g7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmcgPSBjb2xvci5nIC0gdGV4Y1k7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmIgPSBjb2xvci5iIC0gY29sb3IyLmI7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmEgPSAxLjtcclxuXHJcbiAgLy8gZmxvYXQgdGhyZXNob2xkID0gMC43O1xyXG4gIC8vIGZsb2F0IGFmd2lkdGggPSBsZW5ndGgodmVjMihkRmR4KG1heENvbG9yKSwgZEZkeShtYXhDb2xvcikpKTtcclxuICAvLyBnbF9GcmFnQ29sb3IuYSA9IGFmd2lkdGg7XHJcbiAgLy8gZmxvYXQgb3BhY2l0eSA9XHJcbiAgLy8gICBzbW9vdGhzdGVwKGFmd2lkdGggLSB0aHJlc2hvbGQsIGFmd2lkdGggKyB0aHJlc2hvbGQsIG1heENvbG9yKTtcclxuXHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmEgPSBtYXhDb2xvcjtcclxuXHJcbi8vIGZsb2F0IGFhZiA9IGZ3aWR0aChtYXhDb2xvcik7XHJcbi8vIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCguMDEsIC44LCBhYWYpO1xyXG4vLyBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgYWxwaGEpO1xyXG5cclxuICAvLyBmbG9hdCBoID0gMS4vdUNhbnZhc0hlaWdodDtcclxuICAvLyBmbG9hdCB3ID0gMS4vdUNhbnZhc1dpZHRoO1xyXG4gIC8vIHZlYzQgbls5XTtcclxuICAvLyBuWzBdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3JkcyArIHZlYzIoIC13LCAtaCkpO1xyXG4gIC8vIG5bMV0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMigwLjAsIC1oKSk7XHJcbiAgLy8gblsyXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAgdywgLWgpKTtcclxuICAvLyBuWzNdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3JkcyArIHZlYzIoIC13LCAwLjApKTtcclxuICAvLyBuWzRdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3Jkcyk7XHJcbiAgLy8gbls1XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAgdywgMC4wKSk7XHJcbiAgLy8gbls2XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAtdywgaCkpO1xyXG4gIC8vIG5bN10gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMigwLjAsIGgpKTtcclxuICAvLyBuWzhdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoICB3LCBoKSk7XHJcbiAgLy8gdmVjNCBzb2JlbF9ob3JpekVkZ2UgPSBuWzJdICsgKDIuMCpuWzVdKSArIG5bOF0gLSAoblswXSArICgyLjAqblszXSkgKyBuWzZdKTtcclxuICAvLyB2ZWM0IHNvYmVsX3ZlcnRFZGdlICA9IG5bMF0gKyAoMi4wKm5bMV0pICsgblsyXSAtIChuWzZdICsgKDIuMCpuWzddKSArIG5bOF0pO1xyXG4gIC8vIHZlYzMgc29iZWwgPSBzcXJ0KChzb2JlbF9ob3JpekVkZ2UucmdiICogc29iZWxfaG9yaXpFZGdlLnJnYikgKyAoc29iZWxfdmVydEVkZ2UucmdiICogc29iZWxfdmVydEVkZ2UucmdiKSk7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yID0gdmVjNCggblsxXS5yZ2IsIDEuMCApO1xyXG4gIC8vIGdsX0ZyYWdDb2xvci5yID0gMS4wO1xyXG5cclxuICByZXR1cm47XHJcbn1cclxuICAgYDtcclxuICB9XHJcblxyXG4gIGNvbXB1dGUoKSB7XHJcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xyXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5pbmxpbmUoYXJncykgLy90cnVlL2ZhbHNlXHJcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmZ1bmN0aW9ucyhhcmdzKVxyXG5cclxuICAgIHJldHVybiBgXHJcbi8vIHVuaWZvcm1zXHJcbiR7dGhpcy51bmlmb3JtcygpfVxyXG5cclxuLy8gdmFyeWluZyAoc2hvdWxkIGZldGNoIGl0IGZyb20gdmVydGV4IGRpcmVjdGx5KVxyXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xyXG52YXJ5aW5nIHZlYzQgICAgICB2UHJvamVjdGVkQ29vcmRzO1xyXG52YXJ5aW5nIHZlYzIgICAgICB2UHJvamVjdGVkVGV4dENvb3JkcztcclxudmFyeWluZyBtYXQ0ICAgICAgdlByb2plY3Rpb25WaWV3TWF0cml4O1xyXG5cclxuLy8gdGFpbG9yZWQgZnVuY3Rpb25zXHJcbiR7dGhpcy5mdW5jdGlvbnMoKX1cclxuXHJcbi8vIG1haW4gbG9vcFxyXG4ke3RoaXMuX21haW59XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIlxyXG4vKipcclxuICogQG1vZHVsZSBzaGFkZXJzL2RhdGFcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNVbmlmb3JtIHtcclxuICBzdGF0aWMgdW5pZm9ybXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAndUNhbnZhc1dpZHRoJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMC4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1Q2FudmFzSGVpZ2h0Jzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMC4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1V2lkdGgnOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAxLixcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VUZXh0dXJlRmlsbGVkJzoge1xyXG4gICAgICAgIHR5cGU6ICd0JyxcclxuICAgICAgICB2YWx1ZTogW10sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdzYW1wbGVyMkQnLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc1ZlcnRleCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcclxudmFyeWluZyB2ZWM0IHZQb3M7XHJcbnZhcnlpbmcgdmVjNCB2UHJvamVjdGVkQ29vcmRzO1xyXG52YXJ5aW5nIG1hdDQgdlByb2plY3Rpb25WaWV3TWF0cml4O1xyXG52YXJ5aW5nIHZlYzIgdlByb2plY3RlZFRleHRDb29yZHM7XHJcblxyXG4vL1xyXG4vLyBtYWluXHJcbi8vXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcbiAgdlBvcyA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XHJcbiAgdlByb2plY3Rpb25WaWV3TWF0cml4ID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXg7XHJcbiAgdlByb2plY3RlZENvb3JkcyA9ICBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xyXG4gIHZQcm9qZWN0ZWRUZXh0Q29vcmRzID0gdmVjMigoKHZQcm9qZWN0ZWRDb29yZHMueCAvIHZQcm9qZWN0ZWRDb29yZHMudykgKyAxLjAgKSAvIDIuMCxcclxuICAgICAgICAgICAgICAgICgodlByb2plY3RlZENvb3Jkcy55IC8gdlByb2plY3RlZENvb3Jkcy53KSArIDEuMCApIC8gMi4wICk7XHJcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XHJcblxyXG59XHJcbiAgICAgICAgYDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHNoYWRlcnNJbnRlcnBvbGF0aW9uIGZyb20gJy4vaW50ZXJwb2xhdGlvbi9zaGFkZXJzLmludGVycG9sYXRpb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0ZyYWdtZW50IHtcclxuXHJcbiAgLy8gcGFzcyB1bmlmb3JtcyBvYmplY3RcclxuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSB1bmlmb3JtcztcclxuICAgIHRoaXMuX2Z1bmN0aW9ucyA9IHt9O1xyXG4gICAgdGhpcy5fbWFpbiA9ICcnO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb25zKCkge1xyXG4gICAgaWYgKHRoaXMuX21haW4gPT09ICcnKSB7XHJcbiAgICAgIC8vIGlmIG1haW4gaXMgZW1wdHksIGZ1bmN0aW9ucyBjYW4gbm90IGhhdmUgYmVlbiBjb21wdXRlZFxyXG4gICAgICB0aGlzLm1haW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fZnVuY3Rpb25zKSB7XHJcbiAgICAgIGNvbnRlbnQgKz0gdGhpcy5fZnVuY3Rpb25zW3Byb3BlcnR5XSArICdcXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgdW5pZm9ybXMoKSB7XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fdW5pZm9ybXMpIHtcclxuICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1twcm9wZXJ0eV07XHJcbiAgICAgIGNvbnRlbnQgKz0gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGVHTFNMfSAke3Byb3BlcnR5fWA7XHJcblxyXG4gICAgICBpZiAodW5pZm9ybSAmJiB1bmlmb3JtLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRlbnQgKz0gYFske3VuaWZvcm0ubGVuZ3RofV1gO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb250ZW50ICs9ICc7XFxuJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGVudDtcclxuICB9XHJcblxyXG4gIG1haW4oKSB7XHJcbiAgICAvLyBuZWVkIHRvIHByZS1jYWxsIG1haW4gdG8gZmlsbCB1cCB0aGUgZnVuY3Rpb25zIGxpc3RcclxuICAgIHRoaXMuX21haW4gPSBgXHJcbnZvaWQgbWFpbih2b2lkKSB7XHJcblxyXG4gIC8vIGRyYXcgYm9yZGVyIGlmIHNsaWNlIGlzIGNyb3BwZWRcclxuICAvLyBmbG9hdCB1Qm9yZGVyRGFzaExlbmd0aCA9IDEwLjtcclxuXHJcbiAgaWYoIHVDYW52YXNXaWR0aCA+IDAuICYmXHJcbiAgICAgICgoZ2xfRnJhZ0Nvb3JkLnggPiB1Qm9yZGVyTWFyZ2luICYmIChnbF9GcmFnQ29vcmQueCAtIHVCb3JkZXJNYXJnaW4pIDwgdUJvcmRlcldpZHRoKSB8fFxyXG4gICAgICAgKGdsX0ZyYWdDb29yZC54IDwgKHVDYW52YXNXaWR0aCAtIHVCb3JkZXJNYXJnaW4pICYmIChnbF9GcmFnQ29vcmQueCArIHVCb3JkZXJNYXJnaW4pID4gKHVDYW52YXNXaWR0aCAtIHVCb3JkZXJXaWR0aCkgKSkpe1xyXG4gICAgZmxvYXQgdmFsdWVZID0gbW9kKGdsX0ZyYWdDb29yZC55LCAyLiAqIHVCb3JkZXJEYXNoTGVuZ3RoKTtcclxuICAgIGlmKCB2YWx1ZVkgPCB1Qm9yZGVyRGFzaExlbmd0aCAmJiBnbF9GcmFnQ29vcmQueSA+IHVCb3JkZXJNYXJnaW4gJiYgZ2xfRnJhZ0Nvb3JkLnkgPCAodUNhbnZhc0hlaWdodCAtIHVCb3JkZXJNYXJnaW4pICl7XHJcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodUJvcmRlckNvbG9yLCAxLik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmKCB1Q2FudmFzSGVpZ2h0ID4gMC4gJiZcclxuICAgICAgKChnbF9GcmFnQ29vcmQueSA+IHVCb3JkZXJNYXJnaW4gJiYgKGdsX0ZyYWdDb29yZC55IC0gdUJvcmRlck1hcmdpbikgPCB1Qm9yZGVyV2lkdGgpIHx8XHJcbiAgICAgICAoZ2xfRnJhZ0Nvb3JkLnkgPCAodUNhbnZhc0hlaWdodCAtIHVCb3JkZXJNYXJnaW4pICYmIChnbF9GcmFnQ29vcmQueSArIHVCb3JkZXJNYXJnaW4pID4gKHVDYW52YXNIZWlnaHQgLSB1Qm9yZGVyV2lkdGgpICkpKXtcclxuICAgIGZsb2F0IHZhbHVlWCA9IG1vZChnbF9GcmFnQ29vcmQueCwgMi4gKiB1Qm9yZGVyRGFzaExlbmd0aCk7XHJcbiAgICBpZiggdmFsdWVYIDwgdUJvcmRlckRhc2hMZW5ndGggJiYgZ2xfRnJhZ0Nvb3JkLnggPiB1Qm9yZGVyTWFyZ2luICYmIGdsX0ZyYWdDb29yZC54IDwgKHVDYW52YXNXaWR0aCAtIHVCb3JkZXJNYXJnaW4pICl7XHJcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodUJvcmRlckNvbG9yLCAxLik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGdldCB0ZXh0dXJlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcGl4ZWxcclxuICB2ZWM0IGRhdGFDb29yZGluYXRlcyA9IHVXb3JsZFRvRGF0YSAqIHZQb3M7XHJcbiAgdmVjMyBjdXJyZW50Vm94ZWwgPSB2ZWMzKGRhdGFDb29yZGluYXRlcy54LCBkYXRhQ29vcmRpbmF0ZXMueSwgZGF0YUNvb3JkaW5hdGVzLnopO1xyXG4gIHZlYzQgZGF0YVZhbHVlID0gdmVjNCgwLiwgMC4sIDAuLCAwLik7XHJcbiAgdmVjMyBncmFkaWVudCA9IHZlYzMoMC4sIDAuLCAwLik7XHJcbiAgJHtzaGFkZXJzSW50ZXJwb2xhdGlvbih0aGlzLCAnY3VycmVudFZveGVsJywgJ2RhdGFWYWx1ZScsICdncmFkaWVudCcpfVxyXG5cclxuICAvLyBob3cgZG8gd2UgZGVhbCB3aWwgbW9yZSB0aGFuIDEgY2hhbm5lbD9cclxuICBpZih1TnVtYmVyT2ZDaGFubmVscyA9PSAxKXtcclxuICAgIGZsb2F0IGludGVuc2l0eSA9IGRhdGFWYWx1ZS5yO1xyXG5cclxuICAgIC8vIHJlc2NhbGUvc2xvcGVcclxuICAgIGludGVuc2l0eSA9IGludGVuc2l0eSp1UmVzY2FsZVNsb3BlSW50ZXJjZXB0WzBdICsgdVJlc2NhbGVTbG9wZUludGVyY2VwdFsxXTtcclxuXHJcbiAgICBmbG9hdCB3aW5kb3dNaW4gPSB1V2luZG93Q2VudGVyV2lkdGhbMF0gLSB1V2luZG93Q2VudGVyV2lkdGhbMV0gKiAwLjU7XHJcbiAgICBmbG9hdCB3aW5kb3dNYXggPSB1V2luZG93Q2VudGVyV2lkdGhbMF0gKyB1V2luZG93Q2VudGVyV2lkdGhbMV0gKiAwLjU7XHJcbiAgICBpbnRlbnNpdHkgPSAoIGludGVuc2l0eSAtIHdpbmRvd01pbiApIC8gdVdpbmRvd0NlbnRlcldpZHRoWzFdO1xyXG5cclxuICAgIGRhdGFWYWx1ZS5yID0gZGF0YVZhbHVlLmcgPSBkYXRhVmFsdWUuYiA9IGludGVuc2l0eTtcclxuICAgIGRhdGFWYWx1ZS5hID0gMS4wO1xyXG4gIH1cclxuXHJcbiAgLy8gQXBwbHkgTFVUIHRhYmxlLi4uXHJcbiAgLy9cclxuICBpZih1THV0ID09IDEpe1xyXG4gICAgLy8gc2hvdWxkIG9wYWNpdHkgYmUgZ3JhYmJlZCB0aGVyZT9cclxuICAgIGRhdGFWYWx1ZSA9IHRleHR1cmUyRCggdVRleHR1cmVMVVQsIHZlYzIoIGRhdGFWYWx1ZS5yICwgMS4wKSApO1xyXG4gIH1cclxuXHJcbiAgaWYodUludmVydCA9PSAxKXtcclxuICAgIGRhdGFWYWx1ZSA9IHZlYzQoMS4pIC0gZGF0YVZhbHVlO1xyXG4gICAgLy8gaG93IGRvIHdlIGRlYWwgd2l0aCB0aGF0IGFuZCBvcGFjaXR5P1xyXG4gICAgZGF0YVZhbHVlLmEgPSAxLjtcclxuICB9XHJcblxyXG4gIGdsX0ZyYWdDb2xvciA9IGRhdGFWYWx1ZTtcclxuXHJcbiAgICAvLyBpZiBvbiBlZGdlLCBkcmF3IGxpbmVcclxuICAvLyBmbG9hdCB4UG9zID0gZ2xfRnJhZ0Nvb3JkLngvNTEyLjtcclxuICAvLyBmbG9hdCB5UG9zID0gZ2xfRnJhZ0Nvb3JkLnkvNTEyLjtcclxuICAvLyBpZiggeFBvcyA8IDAuMDUgfHwgeFBvcyA+IC45NSB8fCB5UG9zIDwgMC4wNSB8fCB5UG9zID4gLjk1KXtcclxuICAvLyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoeFBvcywgeVBvcywgMC4sIDEuKTsvL2RhdGFWYWx1ZTtcclxuICAvLyAgIC8vcmV0dXJuO1xyXG4gIC8vIH1cclxuXHJcbn1cclxuICAgYDtcclxuICB9XHJcblxyXG4gIGNvbXB1dGUoKSB7XHJcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xyXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5pbmxpbmUoYXJncykgLy90cnVlL2ZhbHNlXHJcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmZ1bmN0aW9ucyhhcmdzKVxyXG5cclxuICAgIHJldHVybiBgXHJcbi8vIHVuaWZvcm1zXHJcbiR7dGhpcy51bmlmb3JtcygpfVxyXG5cclxuLy8gdmFyeWluZyAoc2hvdWxkIGZldGNoIGl0IGZyb20gdmVydGV4IGRpcmVjdGx5KVxyXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xyXG5cclxuLy8gdGFpbG9yZWQgZnVuY3Rpb25zXHJcbiR7dGhpcy5mdW5jdGlvbnMoKX1cclxuXHJcbi8vIG1haW4gbG9vcFxyXG4ke3RoaXMuX21haW59XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIlxyXG4vKipcclxuICogQG1vZHVsZSBzaGFkZXJzL2RhdGFcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNVbmlmb3JtIHtcclxuICAvKipcclxuICAgKiBTaGFkZXJzIGRhdGEgdW5pZm9ybXNcclxuICAgKi9cclxuICBzdGF0aWMgdW5pZm9ybXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAndVRleHR1cmVTaXplJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1VGV4dHVyZUNvbnRhaW5lcic6IHtcclxuICAgICAgICB0eXBlOiAndHYnLFxyXG4gICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXHJcbiAgICAgICAgbGVuZ3RoOiA3LFxyXG4gICAgICB9LFxyXG4gICAgICAndURhdGFEaW1lbnNpb25zJzoge1xyXG4gICAgICAgIHR5cGU6ICdpdicsXHJcbiAgICAgICAgdmFsdWU6IFswLCAwLCAwXSxcclxuICAgICAgICB0eXBlR0xTTDogJ2l2ZWMzJyxcclxuICAgICAgfSxcclxuICAgICAgJ3VXb3JsZFRvRGF0YSc6IHtcclxuICAgICAgICB0eXBlOiAnbTQnLFxyXG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnbWF0NCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1V2luZG93Q2VudGVyV2lkdGgnOiB7XHJcbiAgICAgICAgdHlwZTogJ2Z2MScsXHJcbiAgICAgICAgdmFsdWU6IFswLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgICAgbGVuZ3RoOiAyLFxyXG4gICAgICB9LFxyXG4gICAgICAndVJlc2NhbGVTbG9wZUludGVyY2VwdCc6IHtcclxuICAgICAgICB0eXBlOiAnZnYxJyxcclxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgICBsZW5ndGg6IDIsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1TnVtYmVyT2ZDaGFubmVscyc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUJpdHNBbGxvY2F0ZWQnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiA4LFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VJbnZlcnQnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VMdXQnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VUZXh0dXJlTFVUJzoge1xyXG4gICAgICAgIHR5cGU6ICd0JyxcclxuICAgICAgICB2YWx1ZTogW10sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdzYW1wbGVyMkQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBpeGVsVHlwZSc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBhY2tlZFBlclBpeGVsJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMSxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1SW50ZXJwb2xhdGlvbic6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUNhbnZhc1dpZHRoJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMC4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1Q2FudmFzSGVpZ2h0Jzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMC4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1Qm9yZGVyQ29sb3InOiB7XHJcbiAgICAgICAgdHlwZTogJ3YzJyxcclxuICAgICAgICB2YWx1ZTogWzEuMCwgMC4wLCAwLjVdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAndmVjMycsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1Qm9yZGVyV2lkdGgnOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAyLixcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VCb3JkZXJNYXJnaW4nOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAyLixcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VCb3JkZXJEYXNoTGVuZ3RoJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMTAuLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc1ZlcnRleCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcclxudmFyeWluZyB2ZWM0IHZQb3M7XHJcblxyXG4vL1xyXG4vLyBtYWluXHJcbi8vXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcbiAgdlBvcyA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XHJcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XHJcblxyXG59XHJcbiAgICAgICAgYDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IENvbnRvdXJVbmlmb3JtIGZyb20gJy4vc2hhZGVycy5jb250b3VyLnVuaWZvcm0nO1xyXG5pbXBvcnQgQ29udG91ckZyYWdtZW50IGZyb20gJy4vc2hhZGVycy5jb250b3VyLmZyYWdtZW50JztcclxuaW1wb3J0IENvbnRvdXJWZXJ0ZXggZnJvbSAnLi9zaGFkZXJzLmNvbnRvdXIudmVydGV4JztcclxuXHJcbmltcG9ydCBEYXRhVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMuZGF0YS51bmlmb3JtJztcclxuaW1wb3J0IERhdGFGcmFnbWVudCBmcm9tICcuL3NoYWRlcnMuZGF0YS5mcmFnbWVudCc7XHJcbmltcG9ydCBEYXRhVmVydGV4IGZyb20gJy4vc2hhZGVycy5kYXRhLnZlcnRleCc7XHJcblxyXG5pbXBvcnQgVlJVbmlmb3JtIGZyb20gJy4vc2hhZGVycy52ci51bmlmb3JtJztcclxuaW1wb3J0IFZSRnJhZ21lbnQgZnJvbSAnLi9zaGFkZXJzLnZyLmZyYWdtZW50JztcclxuaW1wb3J0IFZSVmVydGV4IGZyb20gJy4vc2hhZGVycy52ci52ZXJ0ZXgnO1xyXG5cclxuaW1wb3J0IExheWVyVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMubGF5ZXIudW5pZm9ybSc7XHJcbmltcG9ydCBMYXllckZyYWdtZW50IGZyb20gJy4vc2hhZGVycy5sYXllci5mcmFnbWVudCc7XHJcbmltcG9ydCBMYXllclZlcnRleCBmcm9tICcuL3NoYWRlcnMubGF5ZXIudmVydGV4JztcclxuXHJcbmltcG9ydCBMb2NhbGl6ZXJVbmlmb3JtIGZyb20gJy4vc2hhZGVycy5sb2NhbGl6ZXIudW5pZm9ybSc7XHJcbmltcG9ydCBMb2NhbGl6ZXJGcmFnbWVudCBmcm9tICcuL3NoYWRlcnMubG9jYWxpemVyLmZyYWdtZW50JztcclxuaW1wb3J0IExvY2FsaXplclZlcnRleCBmcm9tICcuL3NoYWRlcnMubG9jYWxpemVyLnZlcnRleCc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBzaGFkZXJzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIENvbnRvdXJVbmlmb3JtLFxyXG4gIENvbnRvdXJGcmFnbWVudCxcclxuICBDb250b3VyVmVydGV4LFxyXG5cclxuICBEYXRhVW5pZm9ybSxcclxuICBEYXRhRnJhZ21lbnQsXHJcbiAgRGF0YVZlcnRleCxcclxuXHJcbiAgVlJVbmlmb3JtLFxyXG4gIFZSRnJhZ21lbnQsXHJcbiAgVlJWZXJ0ZXgsXHJcblxyXG4gIExheWVyVW5pZm9ybSxcclxuICBMYXllckZyYWdtZW50LFxyXG4gIExheWVyVmVydGV4LFxyXG5cclxuICBMb2NhbGl6ZXJVbmlmb3JtLFxyXG4gIExvY2FsaXplckZyYWdtZW50LFxyXG4gIExvY2FsaXplclZlcnRleCxcclxufTtcclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0ZyYWdtZW50IHtcclxuXHJcbiAgLy8gcGFzcyB1bmlmb3JtcyBvYmplY3RcclxuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSB1bmlmb3JtcztcclxuICAgIHRoaXMuX2Z1bmN0aW9ucyA9IHt9O1xyXG4gICAgdGhpcy5fbWFpbiA9ICcnO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb25zKCkge1xyXG4gICAgaWYodGhpcy5fbWFpbiA9PT0gJycpIHtcclxuICAgICAgLy8gaWYgbWFpbiBpcyBlbXB0eSwgZnVuY3Rpb25zIGNhbiBub3QgaGF2ZSBiZWVuIGNvbXB1dGVkXHJcbiAgICAgIHRoaXMubWFpbigpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl9mdW5jdGlvbnMpIHtcclxuICAgICAgY29udGVudCArPSB0aGlzLl9mdW5jdGlvbnNbcHJvcGVydHldICsgJ1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICB1bmlmb3JtcygpIHtcclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl91bmlmb3Jtcykge1xyXG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMuX3VuaWZvcm1zW3Byb3BlcnR5XTtcclxuICAgICAgY29udGVudCArPSBgdW5pZm9ybSAke3VuaWZvcm0udHlwZUdMU0x9ICR7cHJvcGVydHl9YDtcclxuXHJcbiAgICAgIGlmKHVuaWZvcm0gJiYgdW5pZm9ybS5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZW50ICs9IGBbJHt1bmlmb3JtLmxlbmd0aH1dYDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGVudCArPSAnO1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICBtYWluKCkge1xyXG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XHJcbiAgICB0aGlzLl9tYWluID0gYFxyXG52b2lkIG1haW4odm9pZCkge1xyXG5cclxuICB2ZWMyIHRleGMgPSB2ZWMyKCgodlByb2plY3RlZENvb3Jkcy54IC8gdlByb2plY3RlZENvb3Jkcy53KSArIDEuMCApIC8gMi4wLFxyXG4gICAgICAgICAgICAgICAgKCh2UHJvamVjdGVkQ29vcmRzLnkgLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAgKTtcclxuXHJcbiAgLy8ganVzdCBzaWxlbmNlIHdhcm5pbmcgZm9yXHJcbiAgdmVjNCBkdW1teSA9IHZQb3M7XHJcblxyXG4gIC8vVGhlIGJhY2sgcG9zaXRpb24gaXMgdGhlIHdvcmxkIHNwYWNlIHBvc2l0aW9uIHN0b3JlZCBpbiB0aGUgdGV4dHVyZS5cclxuICB2ZWM0IGJhc2VDb2xvcjAgPSB0ZXh0dXJlMkQodVRleHR1cmVCYWNrVGVzdDAsIHRleGMpO1xyXG4gIHZlYzQgYmFzZUNvbG9yMSA9IHRleHR1cmUyRCh1VGV4dHVyZUJhY2tUZXN0MSwgdGV4Yyk7XHJcblxyXG4gIGlmKCB1VHJhY2tNb3VzZSA9PSAxICl7XHJcblxyXG4gICAgICBpZiggdlByb2plY3RlZENvb3Jkcy54IDwgdU1vdXNlLnggKXtcclxuXHJcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gYmFzZUNvbG9yMDtcclxuXHJcbiAgICAgIH1cclxuICAgICAgZWxzZXtcclxuXHJcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KCBiYXNlQ29sb3IwLCBiYXNlQ29sb3IxLCB1T3BhY2l0eTEgKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgfVxyXG4gIGVsc2V7XHJcblxyXG4gICAgaWYoIHVUeXBlMSA9PSAwICl7XHJcblxyXG4gICAgICAvL21lcmdlIGFuIGltYWdlIGludG9cclxuICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KCBiYXNlQ29sb3IwLCBiYXNlQ29sb3IxLCB1T3BhY2l0eTEgKTtcclxuXHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG5cclxuICAgICAgZmxvYXQgb3BhY2l0eSA9IGJhc2VDb2xvcjEuYTtcclxuICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KCBiYXNlQ29sb3IwLCBiYXNlQ29sb3IxLCBvcGFjaXR5ICogdU9wYWNpdHkxICk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIHJldHVybjtcclxufVxyXG4gICBgO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZSgpIHtcclxuICAgIGxldCBzaGFkZXJJbnRlcnBvbGF0aW9uID0gJyc7XHJcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmlubGluZShhcmdzKSAvL3RydWUvZmFsc2VcclxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXHJcblxyXG4gICAgcmV0dXJuIGBcclxuLy8gdW5pZm9ybXNcclxuJHt0aGlzLnVuaWZvcm1zKCl9XHJcblxyXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXHJcbnZhcnlpbmcgdmVjNCAgICAgIHZQb3M7XHJcbnZhcnlpbmcgdmVjNCAgICAgIHZQcm9qZWN0ZWRDb29yZHM7XHJcblxyXG4vLyB0YWlsb3JlZCBmdW5jdGlvbnNcclxuJHt0aGlzLmZ1bmN0aW9ucygpfVxyXG5cclxuLy8gbWFpbiBsb29wXHJcbiR7dGhpcy5fbWFpbn1cclxuICAgICAgYDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHNoYWRlcnMvZGF0YVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc1VuaWZvcm0ge1xyXG4gIHN0YXRpYyB1bmlmb3JtcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAndVRleHR1cmVCYWNrVGVzdDAnOiB7XHJcbiAgICAgICAgdHlwZTogJ3QnLFxyXG4gICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1VGV4dHVyZUJhY2tUZXN0MSc6IHtcclxuICAgICAgICB0eXBlOiAndCcsXHJcbiAgICAgICAgdmFsdWU6IFtdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcclxuICAgICAgfSxcclxuICAgICAgJ3VPcGFjaXR5MCc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDEuMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VPcGFjaXR5MSc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDEuMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VUeXBlMCc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVR5cGUxJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMSxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1VHJhY2tNb3VzZSc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndU1vdXNlJzoge1xyXG4gICAgICAgIHR5cGU6ICd2MicsXHJcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWMyJyxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlKCkge1xyXG4gICAgICAgIHJldHVybiBgXHJcbnZhcnlpbmcgdmVjNCB2UG9zO1xyXG52YXJ5aW5nIHZlYzQgdlByb2plY3RlZENvb3JkcztcclxuXHJcbi8vXHJcbi8vIG1haW5cclxuLy9cclxudm9pZCBtYWluKCkge1xyXG5cclxuICB2UG9zID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcclxuICB2UHJvamVjdGVkQ29vcmRzID0gIHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XHJcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XHJcblxyXG59XHJcbiAgICAgICAgYDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHNoYWRlcnNJbnRlcnBvbGF0aW9uIGZyb20gJy4vaW50ZXJwb2xhdGlvbi9zaGFkZXJzLmludGVycG9sYXRpb24nO1xyXG5cclxuLyoqXHJcbiAqIExvY2FsaXplciBmcmFnbWVudCBzaGFkZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcclxuXHJcbiAgLyoqXHJcbiAgICogXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodW5pZm9ybXMpIHtcclxuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XHJcbiAgICB0aGlzLl9mdW5jdGlvbnMgPSB7fTtcclxuICAgIHRoaXMuX21haW4gPSAnJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9ucygpIHtcclxuICAgIGlmKHRoaXMuX21haW4gPT09ICcnKSB7XHJcbiAgICAgIC8vIGlmIG1haW4gaXMgZW1wdHksIGZ1bmN0aW9ucyBjYW4gbm90IGhhdmUgYmVlbiBjb21wdXRlZFxyXG4gICAgICB0aGlzLm1haW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgZm9yKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl9mdW5jdGlvbnMpIHtcclxuICAgICAgY29udGVudCArPSB0aGlzLl9mdW5jdGlvbnNbcHJvcGVydHldICsgJ1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBcclxuICAgKi9cclxuICB1bmlmb3JtcygpIHtcclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl91bmlmb3Jtcykge1xyXG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMuX3VuaWZvcm1zW3Byb3BlcnR5XTtcclxuICAgICAgY29udGVudCArPSBgdW5pZm9ybSAke3VuaWZvcm0udHlwZUdMU0x9ICR7cHJvcGVydHl9YDtcclxuXHJcbiAgICAgIGlmKHVuaWZvcm0gJiYgdW5pZm9ybS5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZW50ICs9IGBbJHt1bmlmb3JtLmxlbmd0aH1dYDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGVudCArPSAnO1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBcclxuICAgKi9cclxuICBtYWluKCkge1xyXG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XHJcbiAgICB0aGlzLl9tYWluID0gYFxyXG52b2lkIGludGVyc2VjdGlvblByb2plY3Rpb24oXHJcbiAgaW4gdmVjNCBwbGFuZSxcclxuICBpbiB2ZWM0IHNsaWNlLFxyXG4gIG91dCB2ZWMzIGludGVyc2VjdGlvblByb2plY3Rpb24pe1xyXG5cclxuICAgICAgdmVjMyBpbnRlcnNlY3Rpb25EaXJlY3Rpb24gPSBub3JtYWxpemUoY3Jvc3MocGxhbmUueHl6LCBzbGljZS54eXopKTtcclxuICAgICAgdmVjMyBpbnRlcnNlY3Rpb25Qb2ludCA9IFxyXG4gICAgICAgIGNyb3NzKGludGVyc2VjdGlvbkRpcmVjdGlvbixzbGljZS54eXopICogcGxhbmUudyArXHJcbiAgICAgICAgY3Jvc3MocGxhbmUueHl6LCBpbnRlcnNlY3Rpb25EaXJlY3Rpb24pICogc2xpY2UudztcclxuXHJcbiAgICAgIGludGVyc2VjdGlvblByb2plY3Rpb24gPVxyXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50Lnh5eiArXHJcbiAgICAgICAgKGRvdCh2UG9zLnh5eiAtIGludGVyc2VjdGlvblBvaW50LCBpbnRlcnNlY3Rpb25EaXJlY3Rpb24pXHJcbiAgICAgICAgICAqIGludGVyc2VjdGlvbkRpcmVjdGlvbik7XHJcblxyXG59XHJcblxyXG52b2lkIG1haW4odm9pZCkge1xyXG4gICAgICB2ZWM0IGMxID0gdmVjNCgwLiwgMC4sIDAuLCAwLik7XHJcbiAgICAgIHZlYzQgYzIgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcclxuICAgICAgdmVjNCBjMyA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xyXG5cclxuICAgICAgLy8gbG9jYWxpemVyICMxXHJcbiAgICAgIC8vIG11c3QgYmUgbm9ybWFsaXplZCFcclxuICAgICAgaWYobGVuZ3RoKHVQbGFuZTEueHl6KSA+IDAuNSkge1xyXG4gICAgICAgIHZlYzMgcHJvamVjdGlvbjEgPSB2ZWMzKDEuKTtcclxuICAgICAgICBpbnRlcnNlY3Rpb25Qcm9qZWN0aW9uKFxyXG4gICAgICAgICAgdVBsYW5lMSxcclxuICAgICAgICAgIHVTbGljZSxcclxuICAgICAgICAgIHByb2plY3Rpb24xXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdmVjNCBwcm9qSW50ZXIxID0gKHZQcm9qZWN0aW9uVmlld01hdHJpeCAqIHZlYzQocHJvamVjdGlvbjEsIDEuKSk7XHJcbiAgICAgICAgdmVjMyBuZGMxID0gcHJvakludGVyMS54eXogLyBwcm9qSW50ZXIxLnc7XHJcbiAgICAgICAgdmVjMiBzY3JlZW5TcGFjZTEgPSAobmRjMS54eSAqIC41ICsgLjUpICogdmVjMih1Q2FudmFzV2lkdGgsIHVDYW52YXNIZWlnaHQpO1xyXG5cclxuICAgICAgICBmbG9hdCBkMSA9IGRpc3RhbmNlKGdsX0ZyYWdDb29yZC54eSwgc2NyZWVuU3BhY2UxLnh5KTtcclxuICAgICAgICBjMSA9IHZlYzQodVBsYW5lQ29sb3IxLCAxLiAtIHNtb290aHN0ZXAoLjUsIC43LCBkMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBsb2NhbGl6ZXIgIzJcclxuICAgICAgaWYobGVuZ3RoKHVQbGFuZTIueHl6KSA+IDAuNSkge1xyXG4gICAgICAgIHZlYzMgcHJvamVjdGlvbjIgPSB2ZWMzKDEuKTtcclxuICAgICAgICBpbnRlcnNlY3Rpb25Qcm9qZWN0aW9uKFxyXG4gICAgICAgICAgdVBsYW5lMixcclxuICAgICAgICAgIHVTbGljZSxcclxuICAgICAgICAgIHByb2plY3Rpb24yXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdmVjNCBwcm9qSW50ZXIyID0gKHZQcm9qZWN0aW9uVmlld01hdHJpeCAqIHZlYzQocHJvamVjdGlvbjIsIDEuKSk7XHJcbiAgICAgICAgdmVjMyBuZGMyID0gcHJvakludGVyMi54eXogLyBwcm9qSW50ZXIyLnc7XHJcbiAgICAgICAgdmVjMiBzY3JlZW5TcGFjZTIgPSAobmRjMi54eSAqIC41ICsgLjUpICogdmVjMih1Q2FudmFzV2lkdGgsIHVDYW52YXNIZWlnaHQpO1xyXG5cclxuICAgICAgICBmbG9hdCBkMiA9IGRpc3RhbmNlKGdsX0ZyYWdDb29yZC54eSwgc2NyZWVuU3BhY2UyLnh5KTtcclxuICAgICAgICBjMiA9IHZlYzQodVBsYW5lQ29sb3IyLCAxLiAtIHNtb290aHN0ZXAoLjUsIC43LCBkMikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBsb2NhbGl6ZXIgIzNcclxuICAgICAgaWYobGVuZ3RoKHVQbGFuZTMueHl6KSA+IDAuNSkge1xyXG4gICAgICAgIHZlYzMgcHJvamVjdGlvbjMgPSB2ZWMzKDEuKTtcclxuICAgICAgICBpbnRlcnNlY3Rpb25Qcm9qZWN0aW9uKFxyXG4gICAgICAgICAgdVBsYW5lMyxcclxuICAgICAgICAgIHVTbGljZSxcclxuICAgICAgICAgIHByb2plY3Rpb24zXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdmVjNCBwcm9qSW50ZXIzID0gKHZQcm9qZWN0aW9uVmlld01hdHJpeCAqIHZlYzQocHJvamVjdGlvbjMsIDEuKSk7XHJcbiAgICAgICAgdmVjMyBuZGMzID0gcHJvakludGVyMy54eXogLyBwcm9qSW50ZXIzLnc7XHJcbiAgICAgICAgdmVjMiBzY3JlZW5TcGFjZTMgPSAobmRjMy54eSAqIC41ICsgLjUpICogdmVjMih1Q2FudmFzV2lkdGgsIHVDYW52YXNIZWlnaHQpO1xyXG5cclxuICAgICAgICBmbG9hdCBkMyA9IGRpc3RhbmNlKGdsX0ZyYWdDb29yZC54eSwgc2NyZWVuU3BhY2UzLnh5KTtcclxuICAgICAgICBjMyA9IHZlYzQodVBsYW5lQ29sb3IzLCAxLiAtIHNtb290aHN0ZXAoLjUsIC43LCBkMykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2ZWMzIGNvbG9yTWl4ID0gYzEueHl6KmMxLncgKyBjMi54eXoqYzIudyArIGMzLnh5eipjMy53O1xyXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yTWl4LCBtYXgobWF4KGMxLncsIGMyLncpLGMzLncpKTtcclxufVxyXG4gICBgO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogXHJcbiAgICovXHJcbiAgY29tcHV0ZSgpIHtcclxuICAgIGxldCBzaGFkZXJJbnRlcnBvbGF0aW9uID0gJyc7XHJcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmlubGluZShhcmdzKSAvL3RydWUvZmFsc2VcclxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXHJcblxyXG4gICAgcmV0dXJuIGBcclxuLy8gdW5pZm9ybXNcclxuJHt0aGlzLnVuaWZvcm1zKCl9XHJcblxyXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXHJcbnZhcnlpbmcgdmVjNCB2UG9zO1xyXG52YXJ5aW5nIG1hdDQgdlByb2plY3Rpb25WaWV3TWF0cml4O1xyXG5cclxuLy8gdGFpbG9yZWQgZnVuY3Rpb25zXHJcbiR7dGhpcy5mdW5jdGlvbnMoKX1cclxuXHJcbi8vIG1haW4gbG9vcFxyXG4ke3RoaXMuX21haW59XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIHNoYWRlcnMvbG9jYWxpemVyL3VuaWZvcm1zXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xyXG4gIC8qKlxyXG4gICAqIFNoYWRlcnMgZGF0YSB1bmlmb3Jtc1xyXG4gICAqL1xyXG4gIHN0YXRpYyB1bmlmb3JtcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICd1Q2FudmFzV2lkdGgnOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAwLixcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VDYW52YXNIZWlnaHQnOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAwLixcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VTbGljZSc6IHtcclxuICAgICAgICB0eXBlOiAndjQnLFxyXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBsYW5lMSc6IHtcclxuICAgICAgICB0eXBlOiAndjQnLFxyXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBsYW5lQ29sb3IxJzoge1xyXG4gICAgICAgIHR5cGU6ICd2MycsXHJcbiAgICAgICAgdmFsdWU6IFsxLjAsIDEuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzMnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBsYW5lMic6IHtcclxuICAgICAgICB0eXBlOiAndjQnLFxyXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBsYW5lQ29sb3IyJzoge1xyXG4gICAgICAgIHR5cGU6ICd2MycsXHJcbiAgICAgICAgdmFsdWU6IFsxLjAsIDEuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzMnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBsYW5lMyc6IHtcclxuICAgICAgICB0eXBlOiAndjQnLFxyXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBsYW5lQ29sb3IzJzoge1xyXG4gICAgICAgIHR5cGU6ICd2MycsXHJcbiAgICAgICAgdmFsdWU6IFsxLjAsIDEuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzMnLFxyXG4gICAgICB9LFxyXG5cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBjb21wdXRlKCkge1xyXG4gICAgICAgIHJldHVybiBgXHJcbnZhcnlpbmcgdmVjNCB2UG9zO1xyXG52YXJ5aW5nIG1hdDQgdlByb2plY3Rpb25WaWV3TWF0cml4O1xyXG5cclxuLy9cclxuLy8gbWFpblxyXG4vL1xyXG52b2lkIG1haW4oKSB7XHJcblxyXG4gIHZQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG4gIHZQcm9qZWN0aW9uVmlld01hdHJpeCA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4O1xyXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG5cclxufVxyXG4gICAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBzaGFkZXJzSW50ZXJwb2xhdGlvbiBmcm9tICcuL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uJztcclxuaW1wb3J0IHNoYWRlcnNJbnRlcnNlY3RCb3ggZnJvbSAnLi9oZWxwZXJzL3NoYWRlcnMuaGVscGVycy5pbnRlcnNlY3RCb3gnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0ZyYWdtZW50IHtcclxuXHJcbiAgLy8gcGFzcyB1bmlmb3JtcyBvYmplY3RcclxuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSB1bmlmb3JtcztcclxuICAgIHRoaXMuX2Z1bmN0aW9ucyA9IHt9O1xyXG4gICAgdGhpcy5fbWFpbiA9ICcnO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb25zKCkge1xyXG4gICAgaWYodGhpcy5fbWFpbiA9PT0gJycpIHtcclxuICAgICAgLy8gaWYgbWFpbiBpcyBlbXB0eSwgZnVuY3Rpb25zIGNhbiBub3QgaGF2ZSBiZWVuIGNvbXB1dGVkXHJcbiAgICAgIHRoaXMubWFpbigpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl9mdW5jdGlvbnMpIHtcclxuICAgICAgY29udGVudCArPSB0aGlzLl9mdW5jdGlvbnNbcHJvcGVydHldICsgJ1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICB1bmlmb3JtcygpIHtcclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl91bmlmb3Jtcykge1xyXG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMuX3VuaWZvcm1zW3Byb3BlcnR5XTtcclxuICAgICAgY29udGVudCArPSBgdW5pZm9ybSAke3VuaWZvcm0udHlwZUdMU0x9ICR7cHJvcGVydHl9YDtcclxuXHJcbiAgICAgIGlmKHVuaWZvcm0gJiYgdW5pZm9ybS5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZW50ICs9IGBbJHt1bmlmb3JtLmxlbmd0aH1dYDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGVudCArPSAnO1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICBtYWluKCkge1xyXG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XHJcbiAgICB0aGlzLl9tYWluID0gYFxyXG52b2lkIGdldEludGVuc2l0eShpbiB2ZWMzIGRhdGFDb29yZGluYXRlcywgb3V0IGZsb2F0IGludGVuc2l0eSwgb3V0IHZlYzMgZ3JhZGllbnQpe1xyXG5cclxuICB2ZWM0IGRhdGFWYWx1ZSA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xyXG4gICR7c2hhZGVyc0ludGVycG9sYXRpb24odGhpcywgJ2RhdGFDb29yZGluYXRlcycsICdkYXRhVmFsdWUnLCAnZ3JhZGllbnQnKX1cclxuXHJcbiAgaW50ZW5zaXR5ID0gZGF0YVZhbHVlLnI7XHJcblxyXG4gIC8vIHJlc2NhbGUvc2xvcGVcclxuICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkqdVJlc2NhbGVTbG9wZUludGVyY2VwdFswXSArIHVSZXNjYWxlU2xvcGVJbnRlcmNlcHRbMV07XHJcbiAgLy8gd2luZG93IGxldmVsXHJcbiAgZmxvYXQgd2luZG93TWluID0gdVdpbmRvd0NlbnRlcldpZHRoWzBdIC0gdVdpbmRvd0NlbnRlcldpZHRoWzFdICogMC41O1xyXG4gIGludGVuc2l0eSA9ICggaW50ZW5zaXR5IC0gd2luZG93TWluICkgLyB1V2luZG93Q2VudGVyV2lkdGhbMV07XHJcbn1cclxuXHJcbnZvaWQgbWFpbih2b2lkKSB7XHJcbiAgY29uc3QgaW50IG1heFN0ZXBzID0gMTAyNDtcclxuXHJcbiAgLy8gdGhlIHJheVxyXG4gIHZlYzMgcmF5T3JpZ2luID0gY2FtZXJhUG9zaXRpb247XHJcbiAgdmVjMyByYXlEaXJlY3Rpb24gPSBub3JtYWxpemUodlBvcy54eXogLSByYXlPcmlnaW4pO1xyXG5cclxuICAvLyB0aGUgQXhlLUFsaWduZWQgQi1Cb3hcclxuICB2ZWMzIEFBQkJNaW4gPSB2ZWMzKHVXb3JsZEJCb3hbMF0sIHVXb3JsZEJCb3hbMl0sIHVXb3JsZEJCb3hbNF0pO1xyXG4gIHZlYzMgQUFCQk1heCA9IHZlYzModVdvcmxkQkJveFsxXSwgdVdvcmxkQkJveFszXSwgdVdvcmxkQkJveFs1XSk7XHJcblxyXG4gIC8vIEludGVyc2VjdGlvbiByYXkvYmJveFxyXG4gIGZsb2F0IHROZWFyLCB0RmFyO1xyXG4gIGJvb2wgaW50ZXJzZWN0ID0gZmFsc2U7XHJcbiAgJHtzaGFkZXJzSW50ZXJzZWN0Qm94LmFwaSh0aGlzLCAncmF5T3JpZ2luJywgJ3JheURpcmVjdGlvbicsICdBQUJCTWluJywgJ0FBQkJNYXgnLCAndE5lYXInLCAndEZhcicsICdpbnRlcnNlY3QnKX1cclxuICBpZiAodE5lYXIgPCAwLjApIHROZWFyID0gMC4wO1xyXG5cclxuICAvLyBpbml0IHRoZSByYXkgbWFyY2hpbmdcclxuICBmbG9hdCB0Q3VycmVudCA9IHROZWFyO1xyXG4gIGZsb2F0IHRTdGVwID0gKHRGYXIgLSB0TmVhcikgLyBmbG9hdCh1U3RlcHMpO1xyXG4gIHZlYzQgYWNjdW11bGF0ZWRDb2xvciA9IHZlYzQoMC4wKTtcclxuICBmbG9hdCBhY2N1bXVsYXRlZEFscGhhID0gMC4wO1xyXG5cclxuICBmb3IoaW50IHJheVN0ZXAgPSAwOyByYXlTdGVwIDwgbWF4U3RlcHM7IHJheVN0ZXArKyl7XHJcbiAgICB2ZWMzIGN1cnJlbnRQb3NpdGlvbiA9IHJheU9yaWdpbiArIHJheURpcmVjdGlvbiAqIHRDdXJyZW50O1xyXG4gICAgLy8gc29tZSBub24tbGluZWFyIEZVTlxyXG4gICAgLy8gc29tZSBvY2NsdXNpb24gaXNzdWUgdG8gYmUgZml4ZWRcclxuICAgIHZlYzMgdHJhbnNmb3JtZWRQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbjsgLy90cmFuc2Zvcm1Qb2ludChjdXJyZW50UG9zaXRpb24sIHVBbXBsaXR1ZGUsIHVGcmVxdWVuY2UpO1xyXG4gICAgLy8gd29ybGQgdG8gZGF0YSBjb29yZGluYXRlc1xyXG4gICAgLy8gcm91bmRpbmcgdHJpY2tcclxuICAgIC8vIGZpcnN0IGNlbnRlciBvZiBmaXJzdCB2b3hlbCBpbiBkYXRhIHNwYWNlIGlzIENFTlRFUkVEIG9uICgwLDAsMClcclxuICAgIHZlYzQgZGF0YUNvb3JkaW5hdGVzUmF3ID0gdVdvcmxkVG9EYXRhICogdmVjNCh0cmFuc2Zvcm1lZFBvc2l0aW9uLCAxLjApO1xyXG4gICAgdmVjMyBjdXJyZW50Vm94ZWwgPSB2ZWMzKGRhdGFDb29yZGluYXRlc1Jhdy54LCBkYXRhQ29vcmRpbmF0ZXNSYXcueSwgZGF0YUNvb3JkaW5hdGVzUmF3LnopO1xyXG4gICAgZmxvYXQgaW50ZW5zaXR5ID0gMC4wO1xyXG4gICAgdmVjMyBncmFkaWVudCA9IHZlYzMoMC4sIDAuLCAwLik7XHJcbiAgICBnZXRJbnRlbnNpdHkoY3VycmVudFZveGVsLCBpbnRlbnNpdHksIGdyYWRpZW50KTtcclxuXHJcbiAgICB2ZWM0IGNvbG9yU2FtcGxlO1xyXG4gICAgZmxvYXQgYWxwaGFTYW1wbGU7XHJcbiAgICBpZih1THV0ID09IDEpe1xyXG4gICAgICB2ZWM0IGNvbG9yRnJvbUxVVCA9IHRleHR1cmUyRCggdVRleHR1cmVMVVQsIHZlYzIoIGludGVuc2l0eSwgMS4wKSApO1xyXG4gICAgICAvLyAyNTYgY29sb3JzXHJcbiAgICAgIGNvbG9yU2FtcGxlID0gY29sb3JGcm9tTFVUO1xyXG4gICAgICBhbHBoYVNhbXBsZSA9IGNvbG9yRnJvbUxVVC5hO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgYWxwaGFTYW1wbGUgPSBpbnRlbnNpdHk7XHJcbiAgICAgIGNvbG9yU2FtcGxlLnIgPSBjb2xvclNhbXBsZS5nID0gY29sb3JTYW1wbGUuYiA9IGludGVuc2l0eSAqIGFscGhhU2FtcGxlO1xyXG4gICAgfVxyXG5cclxuICAgIGFscGhhU2FtcGxlID0gYWxwaGFTYW1wbGUgKiB1QWxwaGFDb3JyZWN0aW9uO1xyXG4gICAgYWxwaGFTYW1wbGUgKj0gKDEuMCAtIGFjY3VtdWxhdGVkQWxwaGEpO1xyXG5cclxuICAgIGFjY3VtdWxhdGVkQ29sb3IgKz0gYWxwaGFTYW1wbGUgKiBjb2xvclNhbXBsZTtcclxuICAgIGFjY3VtdWxhdGVkQWxwaGEgKz0gYWxwaGFTYW1wbGU7XHJcblxyXG4gICAgdEN1cnJlbnQgKz0gdFN0ZXA7XHJcblxyXG4gICAgaWYodEN1cnJlbnQgPiB0RmFyIHx8IGFjY3VtdWxhdGVkQWxwaGEgPj0gMS4wICkgYnJlYWs7XHJcbiAgfVxyXG5cclxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGFjY3VtdWxhdGVkQ29sb3IueHl6LCBhY2N1bXVsYXRlZEFscGhhKTtcclxufVxyXG4gICBgO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZSgpIHtcclxuICAgIGxldCBzaGFkZXJJbnRlcnBvbGF0aW9uID0gJyc7XHJcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmlubGluZShhcmdzKSAvL3RydWUvZmFsc2VcclxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXHJcblxyXG4gICAgcmV0dXJuIGBcclxuLy8gdW5pZm9ybXNcclxuJHt0aGlzLnVuaWZvcm1zKCl9XHJcblxyXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXHJcbnZhcnlpbmcgdmVjNCAgICAgIHZQb3M7XHJcblxyXG4vLyB0YWlsb3JlZCBmdW5jdGlvbnNcclxuJHt0aGlzLmZ1bmN0aW9ucygpfVxyXG5cclxuLy8gbWFpbiBsb29wXHJcbiR7dGhpcy5fbWFpbn1cclxuICAgICAgYDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHNoYWRlcnMvZGF0YVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc1VuaWZvcm0ge1xyXG4gIHN0YXRpYyB1bmlmb3JtcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICd1VGV4dHVyZVNpemUnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VUZXh0dXJlQ29udGFpbmVyJzoge1xyXG4gICAgICAgIHR5cGU6ICd0dicsXHJcbiAgICAgICAgdmFsdWU6IFtdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcclxuICAgICAgICBsZW5ndGg6IDcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1RGF0YURpbWVuc2lvbnMnOiB7XHJcbiAgICAgICAgdHlwZTogJ2l2JyxcclxuICAgICAgICB2YWx1ZTogWzAsIDAsIDBdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaXZlYzMnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVdvcmxkVG9EYXRhJzoge1xyXG4gICAgICAgIHR5cGU6ICdtNCcsXHJcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcbiAgICAgICAgdHlwZUdMU0w6ICdtYXQ0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VXaW5kb3dDZW50ZXJXaWR0aCc6IHtcclxuICAgICAgICB0eXBlOiAnZnYxJyxcclxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgICBsZW5ndGg6IDIsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1UmVzY2FsZVNsb3BlSW50ZXJjZXB0Jzoge1xyXG4gICAgICAgIHR5cGU6ICdmdjEnLFxyXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjBdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICAgIGxlbmd0aDogMixcclxuICAgICAgfSxcclxuICAgICAgJ3VOdW1iZXJPZkNoYW5uZWxzJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMSxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1Qml0c0FsbG9jYXRlZCc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDgsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUludmVydCc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUx1dCc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVRleHR1cmVMVVQnOiB7XHJcbiAgICAgICAgdHlwZTogJ3QnLFxyXG4gICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1UGl4ZWxUeXBlJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1UGFja2VkUGVyUGl4ZWwnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAxLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VJbnRlcnBvbGF0aW9uJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMSxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1V29ybGRCQm94Jzoge1xyXG4gICAgICAgIHR5cGU6ICdmdjEnLFxyXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgICAgbGVuZ3RoOiA2LFxyXG4gICAgICB9LFxyXG4gICAgICAndVN0ZXBzJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMjU2LFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VBbHBoYUNvcnJlY3Rpb24nOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAwLjUsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1RnJlcXVlbmNlJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMC4wLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUFtcGxpdHVkZSc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDAuMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlKCkge1xyXG4gICAgICAgIHJldHVybiBgXHJcbnZhcnlpbmcgdmVjNCB2UG9zO1xyXG5cclxuLy9cclxuLy8gbWFpblxyXG4vL1xyXG52b2lkIG1haW4oKSB7XHJcblxyXG4gIHZQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG5cclxufVxyXG4gICAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XHJcbmltcG9ydCBXaWRnZXRzSGFuZGxlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5oYW5kbGUnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzQW5ub3RhdGlvbiBleHRlbmRzIFdpZGdldHNCYXNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IodGFyZ2V0TWVzaCwgY29udHJvbHMsIGNhbWVyYSwgY29udGFpbmVyKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX3RhcmdldE1lc2ggPSB0YXJnZXRNZXNoO1xyXG4gICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcclxuICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgaWYodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gdGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuXHJcbiAgICAvLyBkb20gc3R1ZmZcclxuICAgIHRoaXMuX2xpbmUgPSBudWxsO1xyXG4gICAgdGhpcy5fbGFiZWwgPSBudWxsO1xyXG4gICAgdGhpcy5fY29uZSA9IG51bGw7XHJcbiAgICB0aGlzLl9sYWJlbHRleHQgPSBudWxsO1xyXG5cclxuICAgIC8vYm9vbGVhbnNcclxuICAgIHRoaXMuX2FscmVhZHljcmVhdGVkID0gbnVsbDsgLy9ib29sIHRoYXQgdHVybnMgdHJ1ZSB3aGVuIHRoZSB1c2VyIGVudGVyIHRoZSBuYW1lIG9mIHRoZSBsYWJlbFxyXG4gICAgdGhpcy5fbW92aW5nbGFiZWwgPSBudWxsOyAvL2Jvb2wgdGhhdCB0dXJucyB0cnVlIHdoZW4gdGhlIGxhYmVsIGlzIG1vdmluZyB3aXRoIHRoZSBtb3VzZVxyXG4gICAgdGhpcy5fbGFiZWxtb3ZlZCA9IGZhbHNlOyAvL2Jvb2wgdGhhdCB0dXJucyB0cnVlIG9uY2UgdGhlIGxhYmVsIGlzIG1vdmVkIGJ5IHRoZSB1c2VyIChhdCBsZWFzdCBvbmNlKVxyXG5cclxuICAgIHRoaXMuX2xhYmVsaG92ZXJlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5faG92ZXJlZCA9IHRydWU7XHJcblxyXG4gICAgLy92YXJcclxuICAgIHRoaXMuX2xhYmVscG9zaXRpb254ID0gbnVsbDsgLy9wb3NpdGlvbiBvZiBsYWJlbCAodG9wIGxlZnQgY29ybmVyKVxyXG4gICAgdGhpcy5fbGFiZWxwb3NpdGlvbnkgPSBudWxsOyAvL3Bvc2l0aW9uIG9mIGxhYmVsICh0b3AgbGVmdCBjb3JuZXIpXHJcbiAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHggPSAwOyAvL2RpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSBwb3NpdGlvbiBpbiB0aGUgbGFiZWwgYW5kIHBvc2l0aW9uIG9mIGxhYmVsICh0b3AgbGVmdCBjb3JuZXIpXHJcbiAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHkgPSAwOyAvL2RpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSBwb3NpdGlvbiBpbiB0aGUgbGFiZWwgYW5kIHBvc2l0aW9uIG9mIGxhYmVsICh0b3AgbGVmdCBjb3JuZXIpXHJcblxyXG4gICAgLy8gYWRkIGhhbmRsZXNcclxuICAgIHRoaXMuX2hhbmRsZXMgPSBbXTtcclxuXHJcbiAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvLyBmaXJzdCBoYW5kbGVcclxuICAgIGxldCBmaXJzdEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICBmaXJzdEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgIGZpcnN0SGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xyXG5cclxuICAgIHRoaXMuX2hhbmRsZXMucHVzaChmaXJzdEhhbmRsZSk7XHJcblxyXG4gICAgbGV0IHNlY29uZEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICBzZWNvbmRIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICBzZWNvbmRIYW5kbGUuaG92ZXJlZCA9IHRydWU7XHJcbiAgICAvLyBhY3RpdmUgYW5kIHRyYWNraW5nIG1pZ2h0IGJlIHJlZHVuZGFudFxyXG4gICAgc2Vjb25kSGFuZGxlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICBzZWNvbmRIYW5kbGUudHJhY2tpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5hZGQoc2Vjb25kSGFuZGxlKTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzLnB1c2goc2Vjb25kSGFuZGxlKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYW5ub3RhdGlvblxyXG5cclxuICAgIHRoaXMuY3JlYXRlKCk7XHJcblxyXG4gICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbkhvdmVybGFiZWwgPSB0aGlzLm9uSG92ZXJsYWJlbC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5ub3RvbkhvdmVybGFiZWwgPSB0aGlzLm5vdG9uSG92ZXJsYWJlbC5iaW5kKHRoaXMpOyAgXHJcbiAgICB0aGlzLmNoYW5nZWxhYmVsdGV4dCA9IHRoaXMuY2hhbmdlbGFiZWx0ZXh0LmJpbmQodGhpcyk7IFxyXG4gICAgdGhpcy5tb3ZlbGFiZWwgPSB0aGlzLm1vdmVsYWJlbC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5ub3Rtb3ZlbGFiZWwgPSB0aGlzLm5vdG1vdmVsYWJlbC5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuXHJcbiAgfVxyXG5cclxuICBhZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgIHRoaXMuX2xhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXJsYWJlbCk7XHJcbiAgICB0aGlzLl9sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5ub3RvbkhvdmVybGFiZWwpO1xyXG4gICAgdGhpcy5fbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLmNoYW5nZWxhYmVsdGV4dCk7XHJcbiAgICB0aGlzLl9sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdmVsYWJlbCk7XHJcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubm90bW92ZWxhYmVsKTtcclxuXHJcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcclxuICB9XHJcblxyXG4gIG1vdmVsYWJlbCgpIHsgLy9mdW5jdGlvbiBjYWxsZWQgd2hlbiBtb3VzZWRvd25cclxuICAgIGlmICh0aGlzLl9sYWJlbGhvdmVyZWQgPSB0cnVlKXsgLy9pZiBsYWJlbCBob2JlcmVkIHdlIHdpbGwgbW92ZSB0aGUgbGFiZWxcclxuICAgICAgICB0aGlzLl9tb3ZpbmdsYWJlbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fbGFiZWxtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgbGV0IG1vdXNleSA9ICAtICgtZXZlbnQuY2xpZW50WSArIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQpO1xyXG4gICAgICAgIGxldCBtb3VzZXggPSBldmVudC5jbGllbnRYO1xyXG4gICAgICAgIC8vY2FsY3VsYXRlIGRpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVsIChkaWZmZXJlbmNlIGJldHdlZW4gcmVmIHBvc2l0aW9uIG9mIHRoZSBsYWJlbCAodG9wLWxlZnQgY29ybmVyKSBhbmQgbW91c2UgcG9zaXRpb24gaW4gdGhlIGxhYmVsKVxyXG4gICAgICAgIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseCA9IE1hdGguYWJzKE1hdGguYWJzKG1vdXNleCkgLSBNYXRoLmFicyh0aGlzLl9sYWJlbHBvc2l0aW9ueCkpO1xyXG4gICAgICAgIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseSA9IE1hdGguYWJzKE1hdGguYWJzKG1vdXNleSkgLSBNYXRoLmFicyh0aGlzLl9sYWJlbHBvc2l0aW9ueSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbm90bW92ZWxhYmVsKCkgeyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gbW91c2V1cFxyXG4gICAgdGhpcy5fbW92aW5nbGFiZWwgPSBmYWxzZTtcclxuICAgIHRoaXMuX2hhbmRsZXNbMF0uX2NvbnRyb2xzLmVuYWJsZWQgPSB0cnVlOyAvL21vdmUgdGhlIGNhbWVyYSB3aGVuIG1vdXNlZG93biBhbmQgbW91c2Vkb3duIGFnYWluXHJcbiAgICB0aGlzLl9oYW5kbGVzWzFdLl9jb250cm9scy5lbmFibGVkID0gdHJ1ZTsgXHJcbiAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHggPSAwOyAvL3Jlc3RhcnQgdGhlIHZhbHVlIG9mIGRpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVsLiBOZWNlc3Nhcnk/XHJcbiAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHkgPSAwO1xyXG4gIH1cclxuXHJcbiAgb25Ib3ZlcmxhYmVsKCkgeyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gbW91c2UgZW50ZXJzIHRoZSBsYWJlbCB3aXRoIFwibW91c2VlbnRlclwiIGV2ZW50XHJcbiAgICB0aGlzLl9sYWJlbGhvdmVyZWQgPSB0cnVlO1xyXG4gIH1cclxuIFxyXG4gIG5vdG9uSG92ZXJsYWJlbCgpIHsgLy90aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIG1vdXNlIGxlYXZlcyB0aGUgbGFiZWwgd2l0aCBcIm1vdXNlbGVhdmVcIiBldmVudFxyXG4gICAgdGhpcy5fbGFiZWxob3ZlcmVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBvbk1vdmUoZXZ0KSB7XHJcblxyXG4gICAgaWYgKHRoaXMuX21vdmluZ2xhYmVsID09IHRydWUpe1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMF0uX2NvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLl9jb250cm9scy5lbmFibGVkID0gZmFsc2U7IFxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2RyYWdnZWQgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuX2hhbmRsZXNbMF0ub25Nb3ZlKGV2dCk7XHJcbiAgICB0aGlzLl9oYW5kbGVzWzFdLm9uTW92ZShldnQpO1xyXG5cclxuICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9oYW5kbGVzWzBdLmhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1sxXS5ob3ZlcmVkIHx8IHRoaXMuX2xhYmVsaG92ZXJlZDtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICB9XHJcblxyXG5cclxuICBvblN0YXJ0KGV2dCkge1xyXG5cclxuICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLm9uU3RhcnQoZXZ0KTtcclxuICAgIHRoaXMuX2hhbmRsZXNbMV0ub25TdGFydChldnQpO1xyXG5cclxuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2hhbmRsZXNbMF0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMV0uYWN0aXZlO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgc2V0bGFiZWx0ZXh0KCkge1xyXG4gICAgdGhpcy5fbGFiZWx0ZXh0ID0gcHJvbXB0KFwiUGxlYXNlIGVudGVyIHRoZSBuYW1lIG9mIHRoZSBsYWJlbFwiLCBcIlwiKTsgLy90aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNyZWF0ZXMgYSBuZXcgYXJyb3dcclxuICAgIGlmICh0eXBlb2YgdGhpcy5fbGFiZWx0ZXh0ID09ICdzdHJpbmcnKXsgLy9hdm9pZCBlcnJvclxyXG4gICAgICAgIGlmICh0aGlzLl9sYWJlbHRleHQubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLmlubmVySFRNTCA9IHRoaXMuX2xhYmVsdGV4dDtcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICcnOyAvL2luIGNzcyBhbiBlbXB0eSBzdHJpbmcgaXMgdXNlZCB0byByZXZlcnQgZGlzcGxheT1ub25lLiBTaG93IHRoZSBsYWJlbCBvbmNlIHdlIGtub3cgdGhlIGNvbnRlbnRcclxuICAgICAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICcnOyAvL2luIGNzcyBhbiBlbXB0eSBzdHJpbmcgaXMgdXNlZCB0byByZXZlcnQgZGlzcGxheT1ub25lLiBTaG93IHRoZSBsYWJlbCBvbmNlIHdlIGtub3cgdGhlIGNvbnRlbnRcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvL2hpZGUgdGhlIGxhYmVsXHJcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vaGlkZSB0aGUgbGFiZWxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjaGFuZ2VsYWJlbHRleHQoKSB7IC8vdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkb2VzIGRvdWJsZSBjbGljayBpbiB0aGUgbGFiZWxcclxuICAgIHRoaXMuX2xhYmVsdGV4dCA9IHByb21wdChcIlBsZWFzZSBlbnRlciBuZXcgbmFtZSBvZiB0aGUgbGFiZWxcIiwgdGhpcy5fbGFiZWwuaW5uZXJIVE1MKTtcclxuICAgIGlmICh0eXBlb2YgdGhpcy5fbGFiZWx0ZXh0ID09ICdzdHJpbmcnKXsgLy9hdm9pZCBlcnJvclxyXG4gICAgICAgIGlmICh0aGlzLl9sYWJlbHRleHQubGVuZ3RoID4gMCl7IFxyXG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5pbm5lckhUTUwgPSB0aGlzLl9sYWJlbHRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWxcclxuICAgICAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICcnOyAvL2luIGNzcyBhbiBlbXB0eSBzdHJpbmcgaXMgdXNlZCB0byByZXZlcnQgZGlzcGxheT1ub25lLiBTaG93IHRoZSBsYWJlbFxyXG4gICAgICAgIH1lbHNleyAvLyBpZiB0aGUgbGVuZ3RoIGlzIDAgdGhlIHVzZXIgcHJlc3NlZCBDYW5jZWxcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvL2hpZGUgdGhlIGxhYmVsXHJcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vaGlkZSB0aGUgbGFiZWxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkVuZChldnQpIHtcclxuICAgIC8vIEZpcnN0IEhhbmRsZVxyXG4gICAgdGhpcy5faGFuZGxlc1swXS5vbkVuZChldnQpO1xyXG5cclxuICAgIC8vIFNlY29uZCBIYW5kbGVcclxuICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcpIHtcclxuICAgICAgdGhpcy5faGFuZGxlc1sxXS50cmFja2luZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9oYW5kbGVzWzFdLm9uRW5kKGV2dCk7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgdGhpcy5faGFuZGxlc1sxXS50cmFja2luZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWxmLl9hbHJlYWR5Y3JlYXRlZCAhPSB0cnVlKXtcclxuICAgICAgdGhpcy5zZXRsYWJlbHRleHQoKTtcclxuICAgICAgc2VsZi5fYWxyZWFkeWNyZWF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRlIG9mIGFubm90YXRpb24gd2lkZ2V0XHJcbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gIH1cclxuXHJcblxyXG4gIGNyZWF0ZSgpIHtcclxuICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xyXG4gICAgdGhpcy5jcmVhdGVET00oKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZSgpIHtcclxuICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcclxuXHJcbiAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG4gICAgdGhpcy51cGRhdGVNZXNoUG9zaXRpb24oKTtcclxuXHJcbiAgICAvLyBET00gc3R1ZmZcclxuICAgIHRoaXMudXBkYXRlRE9NUG9zaXRpb24oKTtcclxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZU1lc2goKSB7XHJcbiAgICAvLyBnZW9tZXRyeVxyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uKTtcclxuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uKTtcclxuXHJcbiAgICAvLyBtYXRlcmlhbFxyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcclxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XHJcblxyXG4gICAgLy8gbWVzaFxyXG4gICAgdGhpcy5fbWVzaGxpbmUgPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgdGhpcy5fbWVzaGxpbmUudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgLy8gYWRkIGl0IVxyXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaGxpbmUpO1xyXG5cclxuICAgIC8vY3JlYXRlIGNvbmUgYW5kIGFkZCBpdFxyXG4gICAgdGhpcy5fY29uZWdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDIsIDEwICk7XHJcbiAgICB0aGlzLl9jb25lZ2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtNSwgMCApO1xyXG4gICAgdGhpcy5fY29uZWdlb21ldHJ5LnJvdGF0ZVgoIC0gTWF0aC5QSSAvIDIgKTtcclxuICAgIHRoaXMuX2NvbmUgPSBuZXcgVEhSRUUuTWVzaCggdGhpcy5fY29uZWdlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCApO1xyXG4gICAgdGhpcy5fY29uZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgIHRoaXMuYWRkKHRoaXMuX2NvbmUpO1xyXG5cclxuICB9XHJcblxyXG4gIHVwZGF0ZU1lc2hDb2xvcigpIHtcclxuICAgIGlmKHRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVNZXNoUG9zaXRpb24oKSB7XHJcbiAgICBpZih0aGlzLl9nZW9tZXRyeSkge1xyXG4gICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY3JlYXRlRE9NKCkge1xyXG4gICAgLy8gYWRkIGxpbmUhXHJcbiAgICB0aGlzLl9saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICB0aGlzLl9saW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XHJcbiAgICB0aGlzLl9saW5lLnN0eWxlLmhlaWdodCA9ICcycHgnOy8vMlxyXG4gICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9ICczcHgnOy8vM1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xpbmUpO1xyXG5cclxuICAgIC8vIGFkZCBkYXNoIGxpbmVcclxuICAgIHRoaXMuX2Rhc2hsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGRhc2hsaW5lJyk7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5ib3JkZXJUb3AgPSAnMi41cHggZGFzaGVkICNGOUY5RjknO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5oZWlnaHQgPSAnMXB4JztcclxuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLndpZHRoID0gJzUwJSc7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Rhc2hsaW5lKTtcclxuXHJcbiAgICAvLyBhZGQgbGFiZWwhXHJcbiAgICB0aGlzLl9sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGhpcy5fbGFiZWwuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMudXVpZCk7XHJcbiAgICB0aGlzLl9sYWJlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGxhYmVsJyk7XHJcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICNGOUY5RjknO1xyXG4gICAgdGhpcy5fbGFiZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xyXG4gICAgLy8gdGhpcy5fbGFiZWwuc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xyXG4gICAgdGhpcy5fbGFiZWwuc3R5bGUuY29sb3IgPSAnIzM1MzUzNSc7XHJcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5wYWRkaW5nID0gJzRweCc7XHJcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgIHRoaXMuX2xhYmVsLmlubmVySFRNTCA9ICdIZWxsbywgd29ybGQhJztcclxuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGFiZWwpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcclxuICB9XHJcblxyXG5cclxuICB1cGRhdGVET01Qb3NpdGlvbigpIHtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnZnVuY3Rpb24gdXBkYXRlRE9NUG9zaXRpb24nKTtcclxuICAgIC8vIHVwZGF0ZSBhbm5vdGF0aW9uIGxpbmVzIGFuZCB0ZXh0IVxyXG4gICAgbGV0IHgxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54O1xyXG4gICAgbGV0IHkxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG4gICAgbGV0IHgyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54O1xyXG4gICAgbGV0IHkyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG5cclxuICAgIGxldCB4MCA9IHgxICsgKHgyIC0geDEpLzI7XHJcbiAgICBsZXQgeTAgPSB5MSArICh5MiAtIHkxKS8yO1xyXG5cclxuICAgIGxldCBsZW5ndGggPSBNYXRoLnNxcnQoKHgxLXgyKSooeDEteDIpICsgKHkxLXkyKSooeTEteTIpKTtcclxuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiAxODAgLyBNYXRoLlBJOyAvL3Jlc3VsdCBpbiBkZWdcclxuXHJcbiAgICBsZXQgcG9zWSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAvLyB1cGRhdGUgbGluZVxyXG4gICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCR7cG9zWX1weCwgMClgO1xyXG4gICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XHJcblxyXG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICB0aGlzLl9saW5lLnN0eWxlLndpZHRoID0gbGVuZ3RoICsgJ3B4JztcclxuXHJcblxyXG4gICAgLy8gdXBkYXRlIGxhYmVsIHBvc2l0aW9uXHJcbiAgICB2YXIgbW91c2V4ID0gMDtcclxuICAgIHZhciBtb3VzZXkgPSAwO1xyXG5cclxuICAgIGxldCBwb3NZMDtcclxuXHJcbiAgICBwb3NZMCA9IHkwIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCAtIHRoaXMuX2xhYmVsLm9mZnNldEhlaWdodC8yO1xyXG4gICAgeDAgLT0gdGhpcy5fbGFiZWwub2Zmc2V0V2lkdGgvMjtcclxuXHJcbiAgICB2YXIgeDtcclxuICAgIHZhciB5O1xyXG5cclxuICAgIGlmICh0aGlzLl9sYWJlbG1vdmVkID09IGZhbHNlKXsgLy9pZiB0aGUgdXNlciBoYXNudCBtb3ZlZCB0aGUgbGFiZWwsIHRoZSBwb3NpdGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgYXJyb3dcclxuICAgICAgICBsZXQgdHJhbnNmb3JtMiA9IGB0cmFuc2xhdGUzRCgke01hdGgucm91bmQoeDApfXB4LCR7TWF0aC5yb3VuZChwb3NZMCl9cHgsIDApYDtcclxuICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0yO1xyXG4gICAgICAgIHRoaXMuX2xhYmVscG9zaXRpb254ID0gTWF0aC5yb3VuZCh4MCk7XHJcbiAgICAgICAgdGhpcy5fbGFiZWxwb3NpdGlvbnkgPSBNYXRoLnJvdW5kKHBvc1kwKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHRoaXMuX21vdmluZ2xhYmVsKSB7IC8vaWYgdGhlIHVzZXIgaGFzIG1vdmVkIHRoZSBsYWJlbCwgdGhlIHBvc2l0aW9uIGlzIGRlZmluZWQgYnkgdGhlIG1vdXNlXHJcbiAgICAgICAgbW91c2V4ID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICBtb3VzZXkgPSAgLSgtZXZlbnQuY2xpZW50WSArIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX2xhYmVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke21vdXNleCAtIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseH1weCwke21vdXNleSAtIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseX1weCwgMClgOyBcclxuICAgICAgICAvL3dlIHVzZSBkaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbCB0byBjaGVjayB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxhYmVsIGFuZCB0aGUgcmVmZXJlbmNlIHBvc2l0aW9uIG9mIHRoZSBsYWJlbCAodG9wLWxlZnQgY29ybmVyKVxyXG4gICAgICAgIHRoaXMuX2xhYmVscG9zaXRpb254ID0gbW91c2V4IC0gdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx4O1xyXG4gICAgICAgIHRoaXMuX2xhYmVscG9zaXRpb255ID0gbW91c2V5IC0gdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vdXBkYXRlIGNvbmVcclxuICAgIGxldCB3MCA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbjtcclxuICAgIGxldCB3MSA9IHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbjtcclxuXHJcbiAgICAvL3Bvc2l0aW9uIGFuZCByb3RhdGlvbiBvZiBjb25lXHJcbiAgICB0aGlzLl9jb25lLnBvc2l0aW9uLnNldCh3MS54LHcxLnksdzEueik7XHJcbiAgICB0aGlzLl9jb25lLmxvb2tBdCh3MCk7XHJcblxyXG4gICAgLy8gdXBkYXRlIGRhc2ggbGluZVxyXG5cclxuICAgIC8vY2FsY3VsYXRlIHRoZSBwbGFjZSBpbiB0aGUgbGFiZWw6IGNlbnRlciBvZiB0aGUgbGFiZWxcclxuICAgIHgxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54O1xyXG4gICAgeTEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XHJcbiAgICB4MiA9IHRoaXMuX2xhYmVscG9zaXRpb254O1xyXG4gICAgeTIgPSB0aGlzLl9sYWJlbHBvc2l0aW9ueSArIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7IC8vcmV2ZXJ0IHRoZSBvcGVyYXRpb24gaW4gJ21vdXNleScgdG8gZ2V0IHRoZSBwcmV2aW91cyBldmVudFlcclxuXHJcbiAgICAvL2dldCB0aGUgc2l6ZSBvZiB0aGUgbGFiZWwgc28gd2UgY2FuIHBsYWNlIHRoZSBkYXNoZWQgbGluZSBpbiB0aGUgY2VudGVyIG9mIGl0XHJcbiAgICB2YXIgbGFiZWxoZWlnaHQgPSB0aGlzLl9sYWJlbC5vZmZzZXRIZWlnaHQ7XHJcbiAgICB2YXIgbGFiZWx3aWR0aCA9IHRoaXMuX2xhYmVsLm9mZnNldFdpZHRoO1xyXG5cclxuICAgIHZhciBjZW50ZXJsYWJlbHggPSAwO1xyXG4gICAgdmFyIGNlbnRlcmxhYmVseSA9IDA7XHJcblxyXG4gICAgaWYgKGlzRmluaXRlKGxhYmVsd2lkdGgpICYmIGlzRmluaXRlKGxhYmVsaGVpZ2h0KSl7IC8vaWYgdGhlIGV4dHJhY3Rpb24gaGFzIGJlZW4gc3VjY2VzZnVsbCwgd2UgY2FsY3VsYXRlIHRoZSBjZW50ZXIgb2YgdGhlIGxhYmVsIHdpdGggdG90YWwgc2l6ZVxyXG4gICAgICAgIGNlbnRlcmxhYmVseCA9IGxhYmVsd2lkdGgvMjtcclxuICAgICAgICBjZW50ZXJsYWJlbHkgPSBsYWJlbGhlaWdodC8yO1xyXG4gICAgfVxyXG5cclxuICAgIHgyICs9IGNlbnRlcmxhYmVseDtcclxuICAgIHkyICs9IGNlbnRlcmxhYmVseTtcclxuXHJcbiAgICAvL2NhbGN1bGF0ZSB0aGUgcGxhY2UgaW4gdGhlIGFycm93OiBjbG9zZXN0IHBhcnQgb2YgdGhlIGxpbmUgdG8gcGxhY2UgdGhlIGRhc2hlZCBsaW5lXHJcbiAgICB2YXIgeDFfdGFpbCA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueDsgLy9maXJzdCBwb3NpdGlvbjogdGFpbCBvZiBhcnJvd1xyXG4gICAgdmFyIHkxX3RhaWwgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XHJcbiAgICB2YXIgeDFfYm9keSA9ICh0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnggKyB0aGlzLl9oYW5kbGVzWzFdLnNjcmVlblBvc2l0aW9uLngpLzI7IC8vc2Vjb25kIHBvc2l0aW9uOiBjZW50ZXIgb2YgYXJyb3dcclxuICAgIHZhciB5MV9ib2R5ID0gKHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueSArIHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueSkvMjtcclxuICAgIHZhciB4MV9ub3NlID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54OyAvL3RoaXJkIHBvc2l0aW9uOiBwZWFrIG9mIGFycm93XHJcbiAgICB2YXIgeTFfbm9zZSA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueTtcclxuXHJcbiAgICAvL2NhbGN1bGF0ZSBhbGwgdGhlIGxlbmd0aHMgdG8gdGhlIGxhYmVsLCBzbyB3ZSBjYW4gY2hvb3NlIHRoZSBtaW5cclxuICAgIHZhciBsZW5ndGh0YWlsbGFiZWwgPSBNYXRoLnNxcnQoKHgxX3RhaWwteDIpKih4MV90YWlsLXgyKSArICh5MV90YWlsLXkyKSooeTFfdGFpbC15MikpO1xyXG4gICAgdmFyIGxlbmd0aGJvZHlsYWJlbCA9IE1hdGguc3FydCgoeDFfYm9keS14MikqKHgxX2JvZHkteDIpICsgKHkxX2JvZHkteTIpKih5MV9ib2R5LXkyKSk7XHJcbiAgICB2YXIgbGVuZ3Robm9zZWxhYmVsID0gTWF0aC5zcXJ0KCh4MV9ub3NlLXgyKSooeDFfbm9zZS14MikgKyAoeTFfbm9zZS15MikqKHkxX25vc2UteTIpKTtcclxuXHJcbiAgICB2YXIgbGVuZ3RocyA9IFtsZW5ndGh0YWlsbGFiZWwsIGxlbmd0aGJvZHlsYWJlbCwgbGVuZ3Robm9zZWxhYmVsXTtcclxuICAgIHZhciBtaW5sZW5ndGggPSBNYXRoLm1pbihsZW5ndGh0YWlsbGFiZWwsIGxlbmd0aGJvZHlsYWJlbCwgbGVuZ3Robm9zZWxhYmVsKTtcclxuICAgIHZhciBtaW5sZW5ndGhpbmRleCA9IGxlbmd0aHMuaW5kZXhPZihtaW5sZW5ndGgpO1xyXG5cclxuICAgIGlmIChtaW5sZW5ndGhpbmRleCA9PSAwKXtcclxuICAgICAgICB4MSA9IHgxX3RhaWw7XHJcbiAgICAgICAgeTEgPSB5MV90YWlsO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pbmxlbmd0aGluZGV4ID09IDEpe1xyXG4gICAgICAgIHgxID0geDFfYm9keTtcclxuICAgICAgICB5MSA9IHkxX2JvZHk7XHJcbiAgICB9XHJcbiAgICBpZiAobWlubGVuZ3RoaW5kZXggPT0gMil7XHJcbiAgICAgICAgeDEgPSB4MV9ub3NlO1xyXG4gICAgICAgIHkxID0geTFfbm9zZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPbmNlIHdlIGZvdW5kIHRoZSBjbG9zZXN0IHBvaW50IHRvIHRoZSBsYWJlbCwgd2UgY3JlYXRlIHRoZSBkYXNoZWQgbGluZSBmcm9tIHRoYXQgcG9pbnRcclxuICAgIGxldCBsZW5ndGhkYXNobGluZSA9IE1hdGguc3FydCgoeDEteDIpKih4MS14MikgKyAoeTEteTIpKih5MS15MikpO1xyXG4gICAgbGV0IGFuZ2xlZGFzaGxpbmUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTsgLy9yZXN1bHQgaW4gZGVnXHJcblxyXG4gICAgbGV0IHBvc1lkYXNobGluZSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAvLyB1cGRhdGUgZGFzaGVkIGxpbmVcclxuICAgIGxldCB0cmFuc2Zvcm1kYXNobGluZSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCR7cG9zWWRhc2hsaW5lfXB4LCAwKWA7XHJcbiAgICB0cmFuc2Zvcm1kYXNobGluZSArPSBgIHJvdGF0ZSgke2FuZ2xlZGFzaGxpbmV9ZGVnKWA7XHJcblxyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtZGFzaGxpbmU7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aGRhc2hsaW5lICsgJ3B4JztcclxuICB9XHJcblxyXG4gIHVwZGF0ZURPTUNvbG9yKCkge1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyVG9wID0gJzIuNXB4IGRhc2hlZCAnICsgYCR7dGhpcy5fY29sb3J9YDtcclxuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcclxuICB9XHJcblxyXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcclxuICAgIHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBoaWRlRE9NKCkge1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgfVxyXG5cclxuICBzaG93RE9NKCkge1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgfVxyXG5cclxuICBoaWRlTWVzaCgpIHtcclxuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc2hvd01lc2goKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc2hvdygpIHtcclxuICAgIHRoaXMuc2hvd0RPTSgpO1xyXG4gICAgdGhpcy5zaG93TWVzaCgpO1xyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIHRoaXMuaGlkZURPTSgpO1xyXG4gICAgdGhpcy5oaWRlTWVzaCgpO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzQmFzZSBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcclxuXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAvLyBpbml0IFRIUkVFIE9iamVjdCAzRFxyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvLyBpcyB3aWRnZXQgZW5hYmxlZD9cclxuICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIC8vIFNUQVRFLCBFTlVNIG1pZ2h0IGJlIGJldHRlclxyXG4gICAgdGhpcy5fc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2hvdmVyZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgLy8gdGhvcy5fc3RhdGUgPSAnU0VMRUNURUQnO1xyXG5cclxuICAgIHRoaXMuX2NvbG9ycyA9IHtcclxuICAgICAgZGVmYXVsdDogJyMwMEIwRkYnLFxyXG4gICAgICBhY3RpdmU6ICcjRkZFQjNCJyxcclxuICAgICAgaG92ZXI6ICcjRjUwMDU3JyxcclxuICAgICAgc2VsZWN0OiAnIzc2RkYwMycsXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuZGVmYXVsdDtcclxuXHJcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XHJcbiAgICAvLyBjYW4gbm90IGNhbGwgaXQgdmlzaWJsZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aXRoIFRIUkVFLk9iamVjdDNEXHJcbiAgICB0aGlzLl9kaXNwbGF5ZWQgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIGluaXRPZmZzZXRzKCkge1xyXG4gICAgY29uc3QgYm94ID0gdGhpcy5fY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgY29uc3QgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcclxuICAgIGNvbnN0IHNjcm9sbExlZnQgPVxyXG4gICAgICB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWwuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XHJcblxyXG4gICAgY29uc3QgY2xpZW50VG9wID0gZG9jRWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XHJcbiAgICBjb25zdCBjbGllbnRMZWZ0ID0gZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcclxuXHJcbiAgICBjb25zdCB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xyXG4gICAgY29uc3QgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XHJcblxyXG4gICAgdGhpcy5fb2Zmc2V0cyA9IHtcclxuICAgICAgdG9wOiBNYXRoLnJvdW5kKHRvcCksXHJcbiAgICAgIGxlZnQ6IE1hdGgucm91bmQobGVmdCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgb2Zmc2V0Q2hhbmdlZCgpIHtcclxuICAgIHRoaXMuaW5pdE9mZnNldHMoKTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXRNb3VzZU9mZnNldHMoZXZlbnQsIGNvbnRhaW5lcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogKGV2ZW50LmNsaWVudFggLSB0aGlzLl9vZmZzZXRzLmxlZnQpIC8gY29udGFpbmVyLm9mZnNldFdpZHRoICogMiAtIDEsXHJcbiAgICAgIHk6IC0oKGV2ZW50LmNsaWVudFkgLSB0aGlzLl9vZmZzZXRzLnRvcCkgLyBjb250YWluZXIub2Zmc2V0SGVpZ2h0KVxyXG4gICAgICAgICogMiArIDEsXHJcbiAgICAgIHNjcmVlblg6IGV2ZW50LmNsaWVudFggLSB0aGlzLl9vZmZzZXRzLmxlZnQsXHJcbiAgICAgIHNjcmVlblk6IGV2ZW50LmNsaWVudFkgLSB0aGlzLl9vZmZzZXRzLnRvcCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoKSB7XHJcbiAgICAvLyB0byBiZSBvdmVybG9hZGVkXHJcbiAgICB3aW5kb3cuY29uc29sZS5sb2coJ3VwZGF0ZSgpIHNob3VsZCBiZSBvdmVybG9hZGVkIScpO1xyXG4gIH1cclxuXHJcbiAgZnJlZSgpIHtcclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVDb2xvcigpIHtcclxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcclxuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuYWN0aXZlO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ob3ZlcmVkKSB7XHJcbiAgICAgIHRoaXMuX2NvbG9yID0gdGhpcy5fY29sb3JzLmhvdmVyO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZWxlY3RlZCkge1xyXG4gICAgICB0aGlzLl9jb2xvciA9IHRoaXMuX2NvbG9ycy5zZWxlY3Q7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9jb2xvciA9IHRoaXMuX2NvbG9ycy5kZWZhdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IGVuYWJsZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcclxuICB9XHJcblxyXG4gIHNldCBlbmFibGVkKGVuYWJsZWQpIHtcclxuICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGVkO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBzZWxlY3RlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcclxuICB9XHJcblxyXG4gIHNldCBzZWxlY3RlZChzZWxlY3RlZCkge1xyXG4gICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgaG92ZXJlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9ob3ZlcmVkO1xyXG4gIH1cclxuXHJcbiAgc2V0IGhvdmVyZWQoaG92ZXJlZCkge1xyXG4gICAgdGhpcy5faG92ZXJlZCA9IGhvdmVyZWQ7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRyYWdnZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZHJhZ2dlZDtcclxuICB9XHJcblxyXG4gIHNldCBkcmFnZ2VkKGRyYWdnZWQpIHtcclxuICAgIHRoaXMuX2RyYWdnZWQgPSBkcmFnZ2VkO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBkaXNwbGF5ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheWVkO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRpc3BsYXllZChkaXNwbGF5ZWQpIHtcclxuICAgIHRoaXMuX2Rpc3BsYXllZCA9IGRpc3BsYXllZDtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgYWN0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcclxuICB9XHJcblxyXG4gIHNldCBhY3RpdmUoYWN0aXZlKSB7XHJcbiAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yKGNvbG9yKSB7XHJcbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XHJcbmltcG9ydCBXaWRnZXRzSGFuZGxlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5oYW5kbGUnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzQmlSdWxlciBleHRlbmRzIFdpZGdldHNCYXNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcclxuICAgICAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcblxyXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faW5pdE9ydGhvID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIGlmKHRoaXMuX3RhcmdldE1lc2ggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gZG9tIHN0dWZmXHJcbiAgICAgICAgdGhpcy5fbGluZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBhZGQgaGFuZGxlc1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gZmlyc3QgaGFuZGxlXHJcbiAgICAgICAgbGV0IGZpcnN0SGFuZGxlID0gbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgICAgICBmaXJzdEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICBmaXJzdEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFkZChmaXJzdEhhbmRsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaChmaXJzdEhhbmRsZSk7XHJcblxyXG4gICAgICAgIGxldCBzZWNvbmRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgICAgIHNlY29uZEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICBzZWNvbmRIYW5kbGUuaG92ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgLy8gYWN0aXZlIGFuZCB0cmFja2luZyBtaWdodCBiZSByZWR1bmRhbnRcclxuICAgICAgICBzZWNvbmRIYW5kbGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBzZWNvbmRIYW5kbGUudHJhY2tpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWRkKHNlY29uZEhhbmRsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaChzZWNvbmRIYW5kbGUpO1xyXG5cclxuICAgICAgICAvLyB0aGlyZCBoYW5kbGVcclxuICAgICAgICBsZXQgdGhpcmRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgICAgIHRoaXJkSGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXJkSGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXJkSGFuZGxlKTtcclxuXHJcbiAgICAgICAgdGhpcy5faGFuZGxlcy5wdXNoKHRoaXJkSGFuZGxlKTtcclxuXHJcbiAgICAgICAgLy8gZm91cnRoIGhhbmRsZVxyXG4gICAgICAgIGxldCBmb3VydGhIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgICAgIGZvdXJ0aEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICBmb3VydGhIYW5kbGUuaG92ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hZGQoZm91cnRoSGFuZGxlKTtcclxuXHJcbiAgICAgICAgdGhpcy5faGFuZGxlcy5wdXNoKGZvdXJ0aEhhbmRsZSk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBydWxlclxyXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zbGljZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uTW92ZShldnQpIHtcclxuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS5vbk1vdmUoZXZ0KTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLm9uTW92ZShldnQpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMl0ub25Nb3ZlKGV2dCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS5vbk1vdmUoZXZ0KTtcclxuXHJcbiAgICAgICAgdGhpcy5faG92ZXJlZCA9IHRoaXMuX2hhbmRsZXNbMF0uaG92ZXJlZCB8fCB0aGlzLl9oYW5kbGVzWzFdLmhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1syXS5ob3ZlcmVkIHx8IHRoaXMuX2hhbmRsZXNbM10uaG92ZXJlZDtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBvblN0YXJ0KGV2dCkge1xyXG4gICAgICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS5vblN0YXJ0KGV2dCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1sxXS5vblN0YXJ0KGV2dCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1syXS5vblN0YXJ0KGV2dCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS5vblN0YXJ0KGV2dCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2hhbmRsZXNbMF0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMV0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMl0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbM10uYWN0aXZlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25FbmQoZXZ0KSB7XHJcbiAgICAgICAgLy8gRmlyc3QgSGFuZGxlXHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS5vbkVuZChldnQpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMl0ub25FbmQoZXZ0KTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLm9uRW5kKGV2dCk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gU2Vjb25kIEhhbmRsZVxyXG4gICAgICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1sxXS50cmFja2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLm9uRW5kKGV2dCk7XHJcbiAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdGF0ZSBvZiBydWxlciB3aWRnZXRcclxuICAgICAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzJdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzNdLmFjdGl2ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZSgpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZU1lc2goKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZGVET00oKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5faGFuZGxlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5oaWRlRE9NKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgfVxyXG5cclxuICAgIHNob3dET00oKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLnNob3dET00oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICBoaWRlTWVzaCgpe1xyXG4gICAgICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX21lc2gyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLnZpc2libGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93TWVzaCgpIHtcclxuICAgICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX21lc2gyLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMF0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1sxXS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbM10udmlzaWJsZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdygpIHtcclxuICAgICAgICB0aGlzLnNob3dET00oKTtcclxuICAgICAgICB0aGlzLnNob3dNZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgICB0aGlzLmhpZGVET00oKTtcclxuICAgICAgICB0aGlzLmhpZGVNZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcclxuXHJcbiAgICAgICAgLy8gbWVzaCBzdHVmZlxyXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNZXNoUG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgLy8gRE9NIHN0dWZmXHJcbiAgICAgICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVNZXNoKCkge1xyXG4gICAgICAgIC8vIGdlb21ldHJ5XHJcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24pO1xyXG5cclxuICAgICAgICAvLyBnZW9tZXRyeVxyXG4gICAgICAgIHRoaXMuX2dlb21ldHJ5MiA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgICAgIHRoaXMuX2dlb21ldHJ5Mi52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkyLnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1szXS53b3JsZFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gbWF0ZXJpYWxcclxuICAgICAgICB0aGlzLl9tYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgpO1xyXG4gICAgICAgIHRoaXMuX21hdGVyaWFsMiA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XHJcblxyXG4gICAgICAgIC8vIG1lc2hcclxuICAgICAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLkxpbmUodGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX21lc2gyID0gbmV3IFRIUkVFLkxpbmUodGhpcy5fZ2VvbWV0cnkyLCB0aGlzLl9tYXRlcmlhbDIpO1xyXG4gICAgICAgIHRoaXMuX21lc2gyLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBhZGQgaXQhXHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5fbWVzaDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU1lc2hDb2xvcigpIHtcclxuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbDIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWwyLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcclxuICAgICAgICBpZih0aGlzLl9nZW9tZXRyeSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLl9nZW9tZXRyeTIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkyLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZURPTSgpIHtcclxuICAgICAgICAvLyBhZGQgbGluZSFcclxuICAgICAgICB0aGlzLl9saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGxpbmUnKTtcclxuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9ICczcHgnO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9saW5lKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGRpc3RhbmNlIVxyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkaXN0YW5jZScpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlciA9ICcycHggc29saWQnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcclxuICAgICAgICAvLyB0aGlzLl9kaXN0YW5jZS5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuY29sb3IgPSAnIzM1MzUzNSc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5pbm5lckhUTUwgPSAnSGVsbG8sIHdvcmxkISc7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Rpc3RhbmNlKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGxpbmUhXHJcbiAgICAgICAgdGhpcy5fbGluZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0aGlzLl9saW5lMi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGxpbmUnKTtcclxuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLmhlaWdodCA9ICcycHgnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLndpZHRoID0gJzNweCc7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xpbmUyKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGRpc3RhbmNlIVxyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGRpc3RhbmNlJyk7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xyXG4gICAgICAgIC8vIHRoaXMuX2Rpc3RhbmNlMi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLmNvbG9yID0gJyMzNTM1MzUnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5zdHlsZS5wYWRkaW5nID0gJzRweCc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLmlubmVySFRNTCA9ICdIZWxsbywgd29ybGQhJztcclxuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGlzdGFuY2UyKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGRhc2ggbGluZVxyXG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkYXNobGluZScpO1xyXG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XHJcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyVG9wID0gJzIuNXB4IGRhc2hlZCAjRjlGOUY5JztcclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5oZWlnaHQgPSAnMXB4JztcclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9ICc1MCUnO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kYXNobGluZSk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVET01Qb3NpdGlvbigpIHtcclxuICAgICAgICAvLyB1cGRhdGUgcnVsZXJzIGxpbmVzIGFuZCB0ZXh0IVxyXG4gICAgICAgIGxldCB4MSA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgICAgICBsZXQgeTEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XHJcbiAgICAgICAgbGV0IHgyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54O1xyXG4gICAgICAgIGxldCB5MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueTtcclxuXHJcbiAgICAgICAgLy9sZXQgeDAgPSB4MSArICh4MiAtIHgxKS8yO1xyXG4gICAgICAgIC8vbGV0IHkwID0geTEgKyAoeTIgLSB5MSkvMjtcclxuICAgICAgICBsZXQgeDAgPSB4MjtcclxuICAgICAgICBsZXQgeTAgPSB5MjtcclxuXHJcbiAgICAgICAgaWYgKHkxID49IHkyKSB7XHJcbiAgICAgICAgICAgIHkwID0geTIgLSAzMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5MCA9IHkyICsgMzA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XHJcbiAgICAgICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEk7XHJcblxyXG4gICAgICAgIGxldCBwb3NZID0geTEgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgbGluZVxyXG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM0QoJHt4MX1weCwke3Bvc1l9cHgsIDApYDtcclxuICAgICAgICB0cmFuc2Zvcm0gKz0gYCByb3RhdGUoJHthbmdsZX1kZWcpYDtcclxuXHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGRpc3RhbmNlXHJcbiAgICAgICAgbGV0IHcwID0gdGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgIGxldCB3MSA9IHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UuaW5uZXJIVE1MID0gYCR7TWF0aC5zcXJ0KCh3MC54LXcxLngpKih3MC54LXcxLngpICsgKHcwLnktdzEueSkqKHcwLnktdzEueSkgKyAodzAuei13MS56KSoodzAuei13MS56KSkudG9GaXhlZCgyKX0gbW1gO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlVmFsdWUgPSBNYXRoLnNxcnQoKHcwLngtdzEueCkqKHcwLngtdzEueCkgKyAodzAueS13MS55KSoodzAueS13MS55KSArICh3MC56LXcxLnopKih3MC56LXcxLnopKS50b0ZpeGVkKDIpO1xyXG4gICAgICAgIGxldCBwb3NZMCA9IHkwIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCAtIHRoaXMuX2Rpc3RhbmNlLm9mZnNldEhlaWdodC8yO1xyXG4gICAgICAgIHgwIC09IHRoaXMuX2Rpc3RhbmNlLm9mZnNldFdpZHRoLzI7XHJcblxyXG4gICAgICAgIGxldCB0cmFuc2Zvcm0yID0gYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MCl9cHgsJHtNYXRoLnJvdW5kKHBvc1kwKX1weCwgMClgO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTI7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBydWxlcnMgbGluZXMgMiBhbmQgdGV4dCFcclxuICAgICAgICBsZXQgeDMgPSB0aGlzLl9oYW5kbGVzWzJdLnNjcmVlblBvc2l0aW9uLng7XHJcbiAgICAgICAgbGV0IHkzID0gdGhpcy5faGFuZGxlc1syXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG4gICAgICAgIGxldCB4NCA9IHRoaXMuX2hhbmRsZXNbM10uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgICAgICBsZXQgeTQgPSB0aGlzLl9oYW5kbGVzWzNdLnNjcmVlblBvc2l0aW9uLnk7XHJcblxyXG4gICAgICAgIC8vbGV0IHgwID0geDEgKyAoeDIgLSB4MSkvMjtcclxuICAgICAgICAvL2xldCB5MCA9IHkxICsgKHkyIC0geTEpLzI7XHJcbiAgICAgICAgbGV0IHgwMiA9IHg0O1xyXG4gICAgICAgIGxldCB5MDIgPSB5NDtcclxuXHJcbiAgICAgICAgaWYgKHkzID49IHk0KSB7XHJcbiAgICAgICAgICAgIHkwMiA9IHk0IC0gMzA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeTAyID0geTQgKyAzMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxlbmd0aCA9IE1hdGguc3FydCgoeDMteDQpKih4My14NCkgKyAoeTMteTQpKih5My15NCkpO1xyXG4gICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAqIDE4MCAvIE1hdGguUEk7XHJcblxyXG4gICAgICAgIHBvc1kgPSB5MyAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBsaW5lXHJcbiAgICAgICAgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNEKCR7eDN9cHgsJHtwb3NZfXB4LCAwKWA7XHJcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XHJcblxyXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS53aWR0aCA9IGxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGRpc3RhbmNlXHJcbiAgICAgICAgbGV0IHcwMiA9IHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbjtcclxuICAgICAgICBsZXQgdzEyID0gdGhpcy5faGFuZGxlc1szXS53b3JsZFBvc2l0aW9uO1xyXG5cclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuaW5uZXJIVE1MID0gYCR7TWF0aC5zcXJ0KCh3MDIueC13MTIueCkqKHcwMi54LXcxMi54KSArICh3MDIueS13MTIueSkqKHcwMi55LXcxMi55KSArICh3MDIuei13MTIueikqKHcwMi56LXcxMi56KSkudG9GaXhlZCgyKX0gbW1gO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMlZhbHVlID0gTWF0aC5zcXJ0KCh3MDIueC13MTIueCkqKHcwMi54LXcxMi54KSArICh3MDIueS13MTIueSkqKHcwMi55LXcxMi55KSArICh3MDIuei13MTIueikqKHcwMi56LXcxMi56KSkudG9GaXhlZCgyKTtcclxuICAgICAgICBsZXQgcG9zWTAyID0geTAyIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCAtIHRoaXMuX2Rpc3RhbmNlMi5vZmZzZXRIZWlnaHQvMjtcclxuICAgICAgICB4MDIgLT0gdGhpcy5fZGlzdGFuY2UyLm9mZnNldFdpZHRoLzI7XHJcblxyXG4gICAgICAgIHRyYW5zZm9ybTIgPSBgdHJhbnNsYXRlM0QoJHtNYXRoLnJvdW5kKHgwMil9cHgsJHtNYXRoLnJvdW5kKHBvc1kwMil9cHgsIDApYDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtMjtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGRhc2ggbGluZVxyXG5cclxuICAgICAgICBsZXQgbDFjZW50ZXIgPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uLCAwLjUpO1xyXG4gICAgICAgIGxldCBsMmNlbnRlciA9IHRoaXMuZ2V0UG9pbnRJbkJldHdlZW5CeVBlcmModGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLCB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24sIDAuNSk7XHJcblxyXG4gICAgICAgIGxldCBzY3JlZW4xID0gdGhpcy5faGFuZGxlc1swXS53b3JsZFRvU2NyZWVuKGwxY2VudGVyLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgbGV0IHNjcmVlbjIgPSB0aGlzLl9oYW5kbGVzWzBdLndvcmxkVG9TY3JlZW4obDJjZW50ZXIsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgeDEgPSBzY3JlZW4xLng7XHJcbiAgICAgICAgeTEgPSBzY3JlZW4xLnk7XHJcbiAgICAgICAgeDIgPSBzY3JlZW4yLng7XHJcbiAgICAgICAgeTIgPSBzY3JlZW4yLnk7XHJcblxyXG4gICAgICAgIGxlbmd0aCA9IE1hdGguc3FydCgoeDEteDIpKih4MS14MikgKyAoeTEteTIpKih5MS15MikpO1xyXG4gICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEk7XHJcblxyXG4gICAgICAgIHBvc1kgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBsaW5lXHJcbiAgICAgICAgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNEKCR7eDF9cHgsJHtwb3NZfXB4LCAwKWA7XHJcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XHJcblxyXG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVET01Db2xvcigpIHtcclxuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG5cclxuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5zdHlsZS5ib3JkZXJDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UG9pbnRJbkJldHdlZW5CeVBlcmMocG9pbnRBLCBwb2ludEIsIHBlcmNlbnRhZ2UpIHtcclxuXHJcbiAgICAgICAgdmFyIGRpciA9IHBvaW50Qi5jbG9uZSgpLnN1Yihwb2ludEEpO1xyXG4gICAgICAgIHZhciBsZW4gPSBkaXIubGVuZ3RoKCk7XHJcbiAgICAgICAgZGlyID0gZGlyLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbipwZXJjZW50YWdlKTtcclxuICAgICAgICByZXR1cm4gcG9pbnRBLmNsb25lKCkuYWRkKGRpcik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGluaXRPcnRobyAoKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdE9ydGhvID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgbGV0IHBjZW50ZXIgPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uLCAwLjUpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRJbkJldHdlZW5CeVBlcmModGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uLCB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24sIDAuMjUpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRJbkJldHdlZW5CeVBlcmModGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uLCB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24sIDAuNzUpO1xyXG5cclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueCA9IHBjZW50ZXIueCAtIE1hdGguc3FydCgocGNlbnRlci55IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkpKihwY2VudGVyLnkgLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueSkpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi55ID0gcGNlbnRlci55ICsgTWF0aC5zcXJ0KChwY2VudGVyLnggLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueCkqKHBjZW50ZXIueCAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi54KSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbi54ID0gcGNlbnRlci54ICsgTWF0aC5zcXJ0KChwY2VudGVyLnkgLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueSkqKHBjZW50ZXIueSAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi55KSk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS53b3JsZFBvc2l0aW9uLnkgPSBwY2VudGVyLnkgLSBNYXRoLnNxcnQoKHBjZW50ZXIueCAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi54KSoocGNlbnRlci54IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLngpKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgd29ybGRQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2hvdGVzdERpc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuX2Rpc3RhbmNlVmFsdWUgPCB0aGlzLl9kaXN0YW5jZTJWYWx1ZSkgPyB0aGlzLl9kaXN0YW5jZVZhbHVlIDogdGhpcy5fZGlzdGFuY2UyVmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBsb25nZXN0RGlzdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5fZGlzdGFuY2VWYWx1ZSA+IHRoaXMuX2Rpc3RhbmNlMlZhbHVlKSA/IHRoaXMuX2Rpc3RhbmNlVmFsdWUgOiB0aGlzLl9kaXN0YW5jZTJWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XHJcbmltcG9ydCBDb3JlSW50ZXJzZWN0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuaW50ZXJzZWN0aW9ucyc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzSGFuZGxlIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgdGhpcy5fdGFyZ2V0TWVzaCA9IHRhcmdldE1lc2g7XHJcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG5cclxuICAgIC8vIGlmIG5vIHRhcmdldCBtZXNoLCB1c2UgcGxhbmUgZm9yIEZSRUUgZHJhZ2dpbmcuXHJcbiAgICB0aGlzLl9wbGFuZSA9IHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICBkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHRoaXMuX3JheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKTtcclxuXHJcbiAgICB0aGlzLl90cmFja2luZyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX21vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XHJcblxyXG4gICAgLy8gd29ybGQgKExQUykgcG9zaXRpb24gb2YgdGhpcyBoYW5kbGVcclxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIC8vIHNjcmVlbiBwb3NpdGlvbiBvZiB0aGlzIGhhbmRsZVxyXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuICAgIC8vIG1lc2ggc3R1ZmZcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcclxuICAgIHRoaXMuX21lc2ggPSBudWxsO1xyXG4gICAgdGhpcy5fbWVzaERpc3BsYXllZCA9IHRydWU7XHJcbiAgICB0aGlzLl9tZXNoSG92ZXJlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbWVzaFN0eWxlID0gJ3NwaGVyZSc7IC8vIGN1YmUsIGV0Yy5cclxuXHJcbiAgICAvLyBkb20gc3R1ZmZcclxuICAgIHRoaXMuX2RvbSA9IG51bGw7XHJcbiAgICB0aGlzLl9kb21EaXNwbGF5ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZG9tU3R5bGUgPSAnY2lyY2xlJzsgLy8gc3F1YXJlLCB0cmlhbmdsZVxyXG5cclxuICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weSh0aGlzLl90YXJnZXRNZXNoLnBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zY3JlZW5Qb3NpdGlvbiA9XHJcbiAgICAgIHRoaXMud29ybGRUb1NjcmVlbih0aGlzLl93b3JsZFBvc2l0aW9uLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gICAgLy8gY3JlYXRlIGhhbmRsZVxyXG4gICAgdGhpcy5jcmVhdGUoKTtcclxuICAgIHRoaXMuaW5pdE9mZnNldHMoKTtcclxuXHJcbiAgICAvLyBldmVudCBsaXN0ZW5lcnNcclxuICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25Ib3ZlciA9IHRoaXMub25Ib3Zlci5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbkVuZENvbnRyb2wgPSB0aGlzLm9uRW5kQ29udHJvbC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xyXG4gIH1cclxuXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB0aGlzLl9kb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Ib3Zlcik7XHJcbiAgICB0aGlzLl9kb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Ib3Zlcik7XHJcblxyXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XHJcblxyXG4gICAgdGhpcy5fY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB0aGlzLl9kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Ib3Zlcik7XHJcbiAgICB0aGlzLl9kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Ib3Zlcik7XHJcblxyXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XHJcblxyXG4gICAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlKCkge1xyXG4gICAgdGhpcy5jcmVhdGVNZXNoKCk7XHJcbiAgICB0aGlzLmNyZWF0ZURPTSgpO1xyXG4gIH1cclxuXHJcbiAgb25TdGFydChldnQpIHtcclxuICAgIGNvbnNvbGUubG9nKGV2dCk7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5nZXRNb3VzZU9mZnNldHMoZXZ0LCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgdGhpcy5fbW91c2Uuc2V0KG9mZnNldHMueCwgb2Zmc2V0cy55KTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMuX21vdXNlKTtcclxuXHJcbiAgICAvLyB1cGRhdGUgcmF5Y2FzdGVyXHJcbiAgICB0aGlzLl9yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLl9tb3VzZSwgdGhpcy5fY2FtZXJhKTtcclxuICAgIHRoaXMuX3JheWNhc3Rlci5yYXkucG9zaXRpb24gPSB0aGlzLl9yYXljYXN0ZXIucmF5Lm9yaWdpbjtcclxuXHJcbiAgICBpZiAodGhpcy5faG92ZXJlZCkge1xyXG4gICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9jb250cm9scy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCkge1xyXG4gICAgICAgIGxldCBpbnRlcnNlY3RzVGFyZ2V0ID1cclxuICAgICAgICAgIHRoaXMuX3JheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QodGhpcy5fdGFyZ2V0TWVzaCk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdHNUYXJnZXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkoaW50ZXJzZWN0c1RhcmdldFswXS5wb2ludCkuc3ViKHRoaXMuX3dvcmxkUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9wbGFuZS5wb3NpdGlvbi5jb3B5KHRoaXMuX3dvcmxkUG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcclxuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID1cclxuICAgICAgICAgIENvcmVJbnRlcnNlY3Rpb25zLnJheVBsYW5lKHRoaXMuX3JheWNhc3Rlci5yYXksIHRoaXMuX3BsYW5lKTtcclxuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICB0aGlzLl9vZmZzZXQuY29weShpbnRlcnNlY3Rpb24pLnN1Yih0aGlzLl9wbGFuZS5wb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25FbmQoZXZ0KSB7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAvLyBzdGF5IGFjdGl2ZSBhbmQga2VlcCBjb250cm9scyBkaXNhYmxlZFxyXG4gICAgaWYgKHRoaXMuX3RyYWNraW5nID09PSB0cnVlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1bnNlbGVjdCBpZiBnbyB1cCB3aXRob3V0IG1vdmluZ1xyXG4gICAgaWYgKCF0aGlzLl9kcmFnZ2VkICYmIHRoaXMuX2FjdGl2ZSkge1xyXG4gICAgICAvLyBjaGFuZ2Ugc3RhdGUgaWYgd2FzIG5vdCBkcmFnZ2luZ1xyXG4gICAgICB0aGlzLl9zZWxlY3RlZCA9ICF0aGlzLl9zZWxlY3RlZDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcclxuICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2NvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBvbkVuZENvbnRyb2woKSB7XHJcbiAgICBpZiAoIXRoaXMuX2xhc3RFdmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMub25Nb3ZlKHRoaXMuX2xhc3RFdmVudCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqXHJcbiAgICpcclxuICAgKi9cclxuICBvbk1vdmUoZXZ0KSB7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5nZXRNb3VzZU9mZnNldHMoZXZ0LCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgdGhpcy5fbW91c2Uuc2V0KG9mZnNldHMueCwgb2Zmc2V0cy55KTtcclxuXHJcbiAgICAvLyB1cGRhdGUgcmF5Y2FzdGVyXHJcbiAgICAvLyBzZXQgcmF5LnBvc2l0aW9uIHRvIHNhdGlzZnkgQ29yZUludGVyc2VjdGlvbnM6OnJheVBsYW5lIEFQSVxyXG4gICAgdGhpcy5fcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5fbW91c2UsIHRoaXMuX2NhbWVyYSk7XHJcbiAgICB0aGlzLl9yYXljYXN0ZXIucmF5LnBvc2l0aW9uID0gdGhpcy5fcmF5Y2FzdGVyLnJheS5vcmlnaW47XHJcblxyXG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xyXG4gICAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XHJcbiAgICAgICAgbGV0IGludGVyc2VjdHNUYXJnZXQgPVxyXG4gICAgICAgICAgdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl90YXJnZXRNZXNoKTtcclxuICAgICAgICBpZiAoaW50ZXJzZWN0c1RhcmdldC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkoaW50ZXJzZWN0c1RhcmdldFswXS5wb2ludC5zdWIodGhpcy5fb2Zmc2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh0aGlzLl9wbGFuZS5kaXJlY3Rpb24ubGVuZ3RoKCkgPT09IDApIHtcclxuICAgICAgICAgIC8vIGZyZWUgbW9kZSF0aGlzLl90YXJnZXRNZXNoXHJcbiAgICAgICAgICB0aGlzLl9wbGFuZS5wb3NpdGlvbi5jb3B5KHRoaXMuX3dvcmxkUG9zaXRpb24pO1xyXG4gICAgICAgICAgdGhpcy5fcGxhbmUuZGlyZWN0aW9uLmNvcHkodGhpcy5fY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKCkpO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPVxyXG4gICAgICAgICAgQ29yZUludGVyc2VjdGlvbnMucmF5UGxhbmUodGhpcy5fcmF5Y2FzdGVyLnJheSwgdGhpcy5fcGxhbmUpO1xyXG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT09IG51bGwpIHtcclxuICAgICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weShpbnRlcnNlY3Rpb24uc3ViKHRoaXMuX29mZnNldCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vbkhvdmVyKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBvbkhvdmVyKGV2dCkge1xyXG4gICAgaWYgKGV2dCkge1xyXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB0aGlzLmhvdmVyRG9tKGV2dCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5ob3Zlck1lc2goKTtcclxuXHJcbiAgICB0aGlzLl9ob3ZlcmVkID0gdGhpcy5fbWVzaEhvdmVyZWQgfHwgdGhpcy5fZG9tSG92ZXJlZDtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSB0aGlzLl9ob3ZlcmVkID8gJ3BvaW50ZXInIDogJ2RlZmF1bHQnO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgLy8gZ2VuZXJhbCB1cGRhdGVcclxuICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcclxuXHJcbiAgICAvLyB1cGRhdGUgc2NyZWVuIHBvc2l0aW9uIG9mIGhhbmRsZVxyXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPVxyXG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW4odGhpcy5fd29ybGRQb3NpdGlvbiwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICAgIC8vIG1lc2ggc3R1ZmZcclxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XHJcbiAgICB0aGlzLnVwZGF0ZU1lc2hQb3NpdGlvbigpO1xyXG5cclxuICAgIC8vIERPTSBzdHVmZlxyXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xyXG4gICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgLy9cclxuICB1cGRhdGVNZXNoQ29sb3IoKSB7XHJcbiAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcclxuICAgIGlmICh0aGlzLl9tZXNoKSB7XHJcbiAgICAgIHRoaXMuX21lc2gucG9zaXRpb24ueCA9IHRoaXMuX3dvcmxkUG9zaXRpb24ueDtcclxuICAgICAgdGhpcy5fbWVzaC5wb3NpdGlvbi55ID0gdGhpcy5fd29ybGRQb3NpdGlvbi55O1xyXG4gICAgICB0aGlzLl9tZXNoLnBvc2l0aW9uLnogPSB0aGlzLl93b3JsZFBvc2l0aW9uLno7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBob3Zlck1lc2goKSB7XHJcbiAgICAvLyBjaGVjayByYXljYXN0IGludGVyc2VjdGlvbiwgZG8gd2Ugd2FudCB0byBob3ZlciBvbiBtZXNoIG9yIGp1c3QgY3NzP1xyXG4gICAgbGV0IGludGVyc2VjdHNIYW5kbGUgPSB0aGlzLl9yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KHRoaXMuX21lc2gpO1xyXG4gICAgdGhpcy5fbWVzaEhvdmVyZWQgPSAoaW50ZXJzZWN0c0hhbmRsZS5sZW5ndGggPiAwKTtcclxuICB9XHJcblxyXG4gIGhvdmVyRG9tKGV2dCkge1xyXG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IChldnQudHlwZSA9PT0gJ21vdXNlZW50ZXInKTtcclxuICB9XHJcblxyXG4gIHdvcmxkVG9TY3JlZW4od29ybGRDb29yZGluYXRlLCBjYW1lcmEsIGNhbnZhcykge1xyXG4gICAgbGV0IHNjcmVlbkNvb3JkaW5hdGVzID0gd29ybGRDb29yZGluYXRlLmNsb25lKCk7XHJcbiAgICBzY3JlZW5Db29yZGluYXRlcy5wcm9qZWN0KGNhbWVyYSk7XHJcblxyXG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueCA9XHJcbiAgICAgIE1hdGgucm91bmQoKHNjcmVlbkNvb3JkaW5hdGVzLnggKyAxKSAqIGNhbnZhcy5vZmZzZXRXaWR0aCAvIDIpO1xyXG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueSA9XHJcbiAgICAgIE1hdGgucm91bmQoKC1zY3JlZW5Db29yZGluYXRlcy55ICsgMSkgKiBjYW52YXMub2Zmc2V0SGVpZ2h0IC8gMik7XHJcbiAgICBzY3JlZW5Db29yZGluYXRlcy56ID0gMDtcclxuXHJcbiAgICByZXR1cm4gc2NyZWVuQ29vcmRpbmF0ZXM7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVNZXNoKCkge1xyXG4gICAgLy8gZ2VvbWV0cnlcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEsIDE2LCAxNik7XHJcblxyXG4gICAgLy8gbWF0ZXJpYWxcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcclxuICAgICAgICB3aXJlZnJhbWU6IHRydWUsXHJcbiAgICAgICAgd2lyZWZyYW1lTGluZXdpZHRoOiAyLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyBtZXNoXHJcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgIHRoaXMuX21lc2gucG9zaXRpb24ueCA9IHRoaXMuX3dvcmxkUG9zaXRpb24ueDtcclxuICAgIHRoaXMuX21lc2gucG9zaXRpb24ueSA9IHRoaXMuX3dvcmxkUG9zaXRpb24ueTtcclxuICAgIHRoaXMuX21lc2gucG9zaXRpb24ueiA9IHRoaXMuX3dvcmxkUG9zaXRpb24uejtcclxuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcclxuXHJcbiAgICAvLyBhZGQgaXQhXHJcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcclxuICB9XHJcblxyXG5cclxuICBjcmVhdGVET00oKSB7XHJcbiAgICAvLyBkb21cclxuICAgIHRoaXMuX2RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGhpcy5fZG9tLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnV1aWQpO1xyXG4gICAgdGhpcy5fZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnQU1JIFdpZGdldCBIYW5kbGUnKTtcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkJztcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuY29sb3IgPSAnI0Y5RjlGOSc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLndpZHRoID0gJzEycHgnO1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLmhlaWdodCA9ICcxMnB4JztcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5tYXJnaW4gPSAnLTZweCc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuYm9yZGVyUmFkaXVzID0gJzUwJSc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcblxyXG4gICAgbGV0IHBvc1kgPSB0aGlzLl9zY3JlZW5Qb3NpdGlvbi55IC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuICAgIHRoaXMuX2RvbS5zdHlsZS50cmFuc2Zvcm0gPVxyXG4gICAgICBgdHJhbnNsYXRlM0QoJHt0aGlzLl9zY3JlZW5Qb3NpdGlvbi54fXB4LCAke3Bvc1l9cHgsIDApYDtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XHJcblxyXG4gICAgLy8gYWRkIGl0IVxyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RvbSk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVET01Qb3NpdGlvbigpIHtcclxuICAgIGlmICh0aGlzLl9kb20pIHtcclxuICAgICAgbGV0IHBvc1kgPSB0aGlzLl9zY3JlZW5Qb3NpdGlvbi55IC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuICAgICAgdGhpcy5fZG9tLnN0eWxlLnRyYW5zZm9ybSA9XHJcbiAgICAgICAgYHRyYW5zbGF0ZTNEKCR7dGhpcy5fc2NyZWVuUG9zaXRpb24ueH1weCwgJHtwb3NZfXB4LCAwKWA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVET01Db2xvcigpIHtcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5ib3JkZXJDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XHJcbiAgfVxyXG5cclxuICBmcmVlKCkge1xyXG4gICAgLy8gdGhyZWVqcyBzdHVmZlxyXG5cclxuICAgIC8vIGRvbVxyXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSk7XHJcbiAgICAvLyBldmVudFxyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xyXG5cclxuICAgIHN1cGVyLmZyZWUoKTtcclxuICB9XHJcblxyXG4gIHNldCB3b3JsZFBvc2l0aW9uKHdvcmxkUG9zaXRpb24pIHtcclxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weSh3b3JsZFBvc2l0aW9uKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHdvcmxkUG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBzY3JlZW5Qb3NpdGlvbihzY3JlZW5Qb3NpdGlvbikge1xyXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPSBzY3JlZW5Qb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIGdldCBzY3JlZW5Qb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9zY3JlZW5Qb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIGdldCBhY3RpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGFjdGl2ZShhY3RpdmUpIHtcclxuICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcclxuICAgIC8vIHRoaXMuX3RyYWNraW5nID0gdGhpcy5fYWN0aXZlO1xyXG4gICAgdGhpcy5fY29udHJvbHMuZW5hYmxlZCA9ICF0aGlzLl9hY3RpdmU7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCB0cmFja2luZygpIHtcclxuICAgIHJldHVybiB0aGlzLl90cmFja2luZztcclxuICB9XHJcblxyXG4gIHNldCB0cmFja2luZyh0cmFja2luZykge1xyXG4gICAgdGhpcy5fdHJhY2tpbmcgPSB0cmFja2luZztcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBoaWRlRE9NKCkge1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgfVxyXG5cclxuICBzaG93RE9NKCkge1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICB9XHJcblxyXG4gIGhpZGVNZXNoKCkge1xyXG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzaG93TWVzaCgpIHtcclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBzaG93KCkge1xyXG4gICAgdGhpcy5zaG93RE9NKCk7XHJcbiAgICB0aGlzLnNob3dNZXNoKCk7XHJcbiAgfVxyXG5cclxuICBoaWRlKCkge1xyXG4gICAgdGhpcy5oaWRlRE9NKCk7XHJcbiAgICB0aGlzLmhpZGVNZXNoKCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBBbm5vdGF0aW9uIGZyb20gJy4vd2lkZ2V0cy5hbm5vdGF0aW9uJztcclxuaW1wb3J0IEJpUnVsZXIgZnJvbSAnLi93aWRnZXRzLmJpcnVsZXInO1xyXG5pbXBvcnQgSGFuZGxlIGZyb20gJy4vd2lkZ2V0cy5oYW5kbGUnO1xyXG5pbXBvcnQgUm9pIGZyb20gJy4vd2lkZ2V0cy5yb2knO1xyXG5pbXBvcnQgUnVsZXIgZnJvbSAnLi93aWRnZXRzLnJ1bGVyJztcclxuaW1wb3J0IFZveGVsUHJvYmUgZnJvbSAnLi93aWRnZXRzLnZveGVsUHJvYmUnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgd2lkZ2V0c1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIEFubm90YXRpb24sXHJcbiAgICBCaVJ1bGVyLFxyXG5cdEhhbmRsZSxcclxuICAgIFJvaSxcclxuICAgIFJ1bGVyLFxyXG4gICAgVm94ZWxQcm9iZSxcclxufTtcclxuIiwiaW1wb3J0IFdpZGdldHNCYXNlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5iYXNlJztcclxuaW1wb3J0IFdpZGdldHNIYW5kbGUgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmhhbmRsZSc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSB3aWRnZXRzL2hhbmRsZVxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpZGdldHNSb2kgZXh0ZW5kcyBXaWRnZXRzQmFzZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0TWVzaCwgY29udHJvbHMsIGNhbWVyYSwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0TWVzaCA9IHRhcmdldE1lc2g7XHJcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2luaXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgaWYodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gdGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1lc2ggc3R1ZmZcclxuICAgICAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBkb20gc3R1ZmZcclxuICAgICAgICB0aGlzLl9saW5lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FyZWEgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBhZGQgaGFuZGxlc1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gZmlyc3QgaGFuZGxlXHJcbiAgICAgICAgbGV0IGZpcnN0SGFuZGxlID0gbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgICAgICBmaXJzdEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICBmaXJzdEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFkZChmaXJzdEhhbmRsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaChmaXJzdEhhbmRsZSk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBydWxlclxyXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zbGljZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uTW92ZShldnQpIHtcclxuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcclxuICAgICAgICBsZXQgbnVtSGFuZGxlcyA9ICB0aGlzLl9oYW5kbGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICF0aGlzLl9pbml0KSB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0SGFuZGxlID0gdGhpcy5faGFuZGxlc1tudW1IYW5kbGVzLTFdO1xyXG4gICAgICAgICAgICBsYXN0SGFuZGxlLmhvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGFzdEhhbmRsZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGFzdEhhbmRsZS50cmFja2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgbGV0IG5leHRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgICAgICAgICBuZXh0SGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBuZXh0SGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZXh0SGFuZGxlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG5leHRIYW5kbGUudHJhY2tpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChuZXh0SGFuZGxlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaChuZXh0SGFuZGxlKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBuZXdMaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIG5ld0xpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsaW5lJyk7XHJcbiAgICAgICAgICAgIG5ld0xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS53aWR0aCA9ICczcHgnO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3TGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdMaW5lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBob3ZlcmVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0ub25Nb3ZlKGV2dCk7XHJcbiAgICAgICAgICAgIGhvdmVyZWQgPSBob3ZlcmVkIHx8IHRoaXMuX2hhbmRsZXNbaW5kZXhdLmhvdmVyZWRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSBob3ZlcmVkO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUgJiYgbnVtSGFuZGxlcyA+IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoUG9wSGFuZGxlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uU3RhcnQoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0ub25TdGFydChldnQpO1xyXG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5faGFuZGxlc1tpbmRleF0uYWN0aXZlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkVuZChldnQpIHtcclxuICAgICAgICAvLyBGaXJzdCBIYW5kbGVcclxuICAgICAgICB2YXIgYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5faGFuZGxlcy5zbGljZSgwLCB0aGlzLl9oYW5kbGVzLmxlbmd0aC0yKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5vbkVuZChldnQpO1xyXG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5faGFuZGxlc1tpbmRleF0uYWN0aXZlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZWNvbmQgSGFuZGxlXHJcbiAgICAgICAgaWYodGhpcy5fZHJhZ2dlZCB8fCAhdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0xXS50cmFja2luZykge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTFdLnRyYWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0ub25FbmQoZXZ0KTtcclxuICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0udHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFjdGl2ZSA9IGFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTFdLmFjdGl2ZVxyXG4gICAgICAgIC8vIFN0YXRlIG9mIHJ1bGVyIHdpZGdldFxyXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVzLmxlbmd0aCA8IHRoaXMuX2hhbmRsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdMaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIG5ld0xpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsaW5lJyk7XHJcbiAgICAgICAgICAgIG5ld0xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS53aWR0aCA9ICczcHgnO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3TGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdMaW5lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2luaXQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlKCkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRE9NKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZURPTSgpIHtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLmhpZGVET00oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2xpbmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzW2luZGV4XS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaG93RE9NKCkge1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0uc2hvd0RPTSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5fbGluZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGluZXNbaW5kZXhdLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZU1lc2goKXtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93TWVzaCgpIHtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHNob3coKSB7XHJcbiAgICAgICAgdGhpcy5zaG93RE9NKCk7XHJcbiAgICAgICAgdGhpcy5zaG93TWVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlRE9NKCk7XHJcbiAgICAgICAgdGhpcy5oaWRlTWVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0udXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICAgICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICAvLyBET00gc3R1ZmZcclxuICAgICAgICB0aGlzLnVwZGF0ZURPTVBvc2l0aW9uKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU1lc2goKSB7XHJcbiAgICAgICAgLy8gZ2VvbWV0cnlcclxuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzW2luZGV4XS53b3JsZFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1hdGVyaWFsXHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG5cclxuICAgICAgICAvLyBtZXNoXHJcbiAgICAgICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5MaW5lKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XHJcbiAgICAgICAgdGhpcy5fbWVzaC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGl0IVxyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU1lc2hDb2xvcigpIHtcclxuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNZXNoUG9zaXRpb24oKSB7XHJcbiAgICAgICAgaWYodGhpcy5fZ2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlRE9NKCkge1xyXG4gICAgICAgIC8vIGFkZCBsaW5lIVxyXG4gICAgICAgIHRoaXMuX2xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JztcclxuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLndpZHRoID0gJzNweCc7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xpbmUpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQb2ludE9uTGluZSAocG9pbnRBLCBwb2ludEIsIHBvaW50VG9DaGVjaykge1xyXG4gICAgICAgIHZhciBjID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICBjLmNyb3NzVmVjdG9ycyhwb2ludEEuY2xvbmUoKS5zdWIocG9pbnRUb0NoZWNrKSwgcG9pbnRCLmNsb25lKCkuc3ViKHBvaW50VG9DaGVjaykpO1xyXG4gICAgICAgIHJldHVybiAhYy5sZW5ndGgoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdXNoUG9wSGFuZGxlICgpIHtcclxuICAgICAgICBsZXQgaGFuZGxlMCA9IHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtM107XHJcbiAgICAgICAgbGV0IGhhbmRsZTEgPSB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTJdO1xyXG4gICAgICAgIGxldCBuZXdoYW5kbGUgPSB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTFdO1xyXG5cclxuICAgICAgICB2YXIgaXNPbkxpbmUgPSB0aGlzLmlzUG9pbnRPbkxpbmUoaGFuZGxlMC53b3JsZFBvc2l0aW9uLCBoYW5kbGUxLndvcmxkUG9zaXRpb24sIG5ld2hhbmRsZS53b3JsZFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgaWYgKGlzT25MaW5lKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZTEuX2RvbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShoYW5kbGUxKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMl0gPSBuZXdoYW5kbGU7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXMucG9wKCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdGVtcExpbmUgPSB0aGlzLl9saW5lcy5wb3AoKTtcclxuICAgICAgICAgICAgdGVtcExpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRlbXBMaW5lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpc09uTGluZTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVMaW5lRE9NIChsaW5lSW5kZXgsIGhhbmRsZTBJbmRleCwgaGFuZGxlMUluZGV4KSB7XHJcbiAgICAgICAgLy8gdXBkYXRlIHJ1bGVycyBsaW5lcyBhbmQgdGV4dCFcclxuICAgICAgICBsZXQgeDEgPSB0aGlzLl9oYW5kbGVzW2hhbmRsZTBJbmRleF0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgICAgICBsZXQgeTEgPSB0aGlzLl9oYW5kbGVzW2hhbmRsZTBJbmRleF0uc2NyZWVuUG9zaXRpb24ueTtcclxuICAgICAgICBsZXQgeDIgPSB0aGlzLl9oYW5kbGVzW2hhbmRsZTFJbmRleF0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgICAgICBsZXQgeTIgPSB0aGlzLl9oYW5kbGVzW2hhbmRsZTFJbmRleF0uc2NyZWVuUG9zaXRpb24ueTtcclxuXHJcbiAgICAgICAgbGV0IHgwID0geDI7XHJcbiAgICAgICAgbGV0IHkwID0geTI7XHJcblxyXG4gICAgICAgIGlmICh5MSA+PSB5Mikge1xyXG4gICAgICAgICAgICB5MCA9IHkyIC0gMzA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeTAgPSB5MiArIDMwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IE1hdGguc3FydCgoeDEgLSB4MikgKiAoeDEgLSB4MikgKyAoeTEgLSB5MikgKiAoeTEgLSB5MikpO1xyXG4gICAgICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgICBsZXQgcG9zWSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGxpbmVcclxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNEKCR7eDF9cHgsICR7cG9zWX1weCwgMClgO1xyXG4gICAgICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xyXG5cclxuICAgICAgICAvL3RoaXMuX2xpbmVzW2xpbmVJbmRleF0uc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgIHRoaXMuX2xpbmVzW2xpbmVJbmRleF0uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuX2xpbmVzW2xpbmVJbmRleF0uc3R5bGUud2lkdGggPSBsZW5ndGggKyAncHgnO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZURPTVBvc2l0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2xpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmVET00oaW5kZXgsIGluZGV4LCBwYXJzZUludChpbmRleCkgKyAxID09IHRoaXMuX2hhbmRsZXMubGVuZ3RoID8gMCA6IHBhcnNlSW50KGluZGV4KSArIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRE9NQ29sb3IoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5fbGluZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVzW2luZGV4XS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHBvaW50QSwgcG9pbnRCLCBwZXJjZW50YWdlKSB7XHJcblxyXG4gICAgICAgIHZhciBkaXIgPSBwb2ludEIuY2xvbmUoKS5zdWIocG9pbnRBKTtcclxuICAgICAgICB2YXIgbGVuID0gZGlyLmxlbmd0aCgpO1xyXG4gICAgICAgIGRpciA9IGRpci5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW4qcGVyY2VudGFnZSk7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50QS5jbG9uZSgpLmFkZChkaXIpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXQgd29ybGRQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0uX3dvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxufSIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XHJcbmltcG9ydCBXaWRnZXRzSGFuZGxlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5oYW5kbGUnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzUnVsZXIgZXh0ZW5kcyBXaWRnZXRzQmFzZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHRhcmdldE1lc2gsIGNvbnRyb2xzLCBjYW1lcmEsIGNvbnRhaW5lcikge1xyXG4gICAgc3VwZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcclxuICAgIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcclxuICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gdGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuXHJcbiAgICAvLyBkb20gc3R1ZmZcclxuICAgIHRoaXMuX2xpbmUgPSBudWxsO1xyXG4gICAgdGhpcy5fZGlzdGFuY2UgPSBudWxsO1xyXG5cclxuICAgIC8vIGFkZCBoYW5kbGVzXHJcbiAgICB0aGlzLl9oYW5kbGVzID0gW107XHJcblxyXG4gICAgLy8gZmlyc3QgaGFuZGxlXHJcbiAgICBsZXQgZmlyc3RIYW5kbGUgPVxyXG4gICAgICBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgZmlyc3RIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICBmaXJzdEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgIHRoaXMuYWRkKGZpcnN0SGFuZGxlKTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzLnB1c2goZmlyc3RIYW5kbGUpO1xyXG5cclxuICAgIGxldCBzZWNvbmRIYW5kbGUgPVxyXG4gICAgICBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgc2Vjb25kSGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgc2Vjb25kSGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xyXG4gICAgLy8gYWN0aXZlIGFuZCB0cmFja2luZyBtaWdodCBiZSByZWR1bmRhbnRcclxuICAgIHNlY29uZEhhbmRsZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgc2Vjb25kSGFuZGxlLnRyYWNraW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuYWRkKHNlY29uZEhhbmRsZSk7XHJcblxyXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKHNlY29uZEhhbmRsZSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHJ1bGVyXHJcbiAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgdGhpcy5pbml0T2Zmc2V0cygpO1xyXG5cclxuICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25FbmRDb250cm9sID0gdGhpcy5vbkVuZENvbnRyb2wuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XHJcblxyXG4gICAgdGhpcy5fY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcclxuXHJcbiAgICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLm9uRW5kQ29udHJvbCk7XHJcbiAgfVxyXG5cclxuICBvbk1vdmUoZXZ0KSB7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLm9uTW92ZShldnQpO1xyXG4gICAgdGhpcy5faGFuZGxlc1sxXS5vbk1vdmUoZXZ0KTtcclxuXHJcbiAgICB0aGlzLl9ob3ZlcmVkID0gdGhpcy5faGFuZGxlc1swXS5ob3ZlcmVkIHx8IHRoaXMuX2hhbmRsZXNbMV0uaG92ZXJlZDtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBvblN0YXJ0KGV2dCkge1xyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX2hhbmRsZXNbMF0ub25TdGFydChldnQpO1xyXG4gICAgdGhpcy5faGFuZGxlc1sxXS5vblN0YXJ0KGV2dCk7XHJcblxyXG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcy5faGFuZGxlc1swXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1sxXS5hY3RpdmU7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgb25FbmQoZXZ0KSB7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICAvLyBGaXJzdCBIYW5kbGVcclxuICAgIHRoaXMuX2hhbmRsZXNbMF0ub25FbmQoZXZ0KTtcclxuXHJcbiAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcyk7XHJcblxyXG4gICAgLy8gU2Vjb25kIEhhbmRsZVxyXG4gICAgaWYgKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcpIHtcclxuICAgICAgdGhpcy5faGFuZGxlc1sxXS50cmFja2luZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9oYW5kbGVzWzFdLm9uRW5kKGV2dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGUgb2YgcnVsZXIgd2lkZ2V0XHJcbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBvbkVuZENvbnRyb2woKSB7XHJcbiAgICBpZiAoIXRoaXMuX2xhc3RFdmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMub25Nb3ZlKHRoaXMuX2xhc3RFdmVudCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZSgpIHtcclxuICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xyXG4gICAgdGhpcy5jcmVhdGVET00oKTtcclxuICB9XHJcblxyXG4gIGhpZGVET00oKSB7XHJcbiAgICB0aGlzLl9saW5lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5faGFuZGxlcykge1xyXG4gICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5oaWRlRE9NKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzaG93RE9NKCkge1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLnNob3dET00oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhpZGVNZXNoKCkge1xyXG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzaG93TWVzaCgpIHtcclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBzaG93KCkge1xyXG4gICAgdGhpcy5zaG93RE9NKCk7XHJcbiAgICB0aGlzLnNob3dNZXNoKCk7XHJcbiAgfVxyXG5cclxuICBoaWRlKCkge1xyXG4gICAgdGhpcy5oaWRlRE9NKCk7XHJcbiAgICB0aGlzLmhpZGVNZXNoKCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XHJcblxyXG4gICAgLy8gdXBkYXRlIGhhbmRsZXNcclxuICAgIHRoaXMuX2hhbmRsZXNbMF0udXBkYXRlKCk7XHJcbiAgICB0aGlzLl9oYW5kbGVzWzFdLnVwZGF0ZSgpO1xyXG5cclxuICAgIC8vIG1lc2ggc3R1ZmZcclxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XHJcbiAgICB0aGlzLnVwZGF0ZU1lc2hQb3NpdGlvbigpO1xyXG5cclxuICAgIC8vIERPTSBzdHVmZlxyXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xyXG4gICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlTWVzaCgpIHtcclxuICAgIC8vIGdlb21ldHJ5XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24pO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24pO1xyXG5cclxuICAgIC8vIG1hdGVyaWFsXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgpO1xyXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcclxuXHJcbiAgICAvLyBtZXNoXHJcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLkxpbmUodGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgLy8gYWRkIGl0IVxyXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVNZXNoQ29sb3IoKSB7XHJcbiAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcclxuICAgIGlmICh0aGlzLl9nZW9tZXRyeSkge1xyXG4gICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY3JlYXRlRE9NKCkge1xyXG4gICAgLy8gYWRkIGxpbmUhXHJcbiAgICB0aGlzLl9saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnV1aWQpO1xyXG4gICAgdGhpcy5fbGluZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ0FNSSBXaWRnZXQgUnVsZXInKTtcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JztcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSAnM3B4JztcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9saW5lKTtcclxuXHJcbiAgICAvLyBhZGQgZGlzdGFuY2UhXHJcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGhpcy5fZGlzdGFuY2Uuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkaXN0YW5jZScpO1xyXG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCc7XHJcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XHJcbiAgICAvLyB0aGlzLl9kaXN0YW5jZS5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XHJcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5jb2xvciA9ICcjMzUzNTM1JztcclxuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnBhZGRpbmcgPSAnNHB4JztcclxuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgdGhpcy5fZGlzdGFuY2UuaW5uZXJIVE1MID0gJ0hlbGxvLCB3b3JsZCEnO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Rpc3RhbmNlKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVET01Qb3NpdGlvbigpe1xyXG4gICAgLy8gdXBkYXRlIHJ1bGVycyBsaW5lcyBhbmQgdGV4dCFcclxuICAgIGxldCB4MSA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgIGxldCB5MSA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueTtcclxuICAgIGxldCB4MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgIGxldCB5MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueTtcclxuXHJcbiAgICBsZXQgeDAgPSB4MSArICh4MiAtIHgxKS8yO1xyXG4gICAgbGV0IHkwID0geTEgKyAoeTIgLSB5MSkvMjtcclxuXHJcbiAgICBsZXQgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XHJcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTsgLy9yZXN1bHQgaW4gZGVnXHJcblxyXG4gICAgbGV0IHBvc1kgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgLy8gdXBkYXRlIGxpbmVcclxuICAgIGxldCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM0QoJHt4MX1weCwke3Bvc1l9cHgsIDApYDtcclxuICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xyXG5cclxuICAgIHRoaXMuX2xpbmUuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aCArICdweCc7XHJcblxyXG4gICAgLy8gdXBkYXRlIGRpc3RhbmNlXHJcbiAgICBsZXQgdzAgPSB0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb247XHJcbiAgICBsZXQgdzEgPSB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb247XHJcblxyXG4gICAgdGhpcy5fZGlzdGFuY2UuaW5uZXJIVE1MID1cclxuICAgICAgYCR7XHJcbiAgICAgICAgTWF0aC5zcXJ0KFxyXG4gICAgICAgICAgKHcwLngtdzEueCkqKHcwLngtdzEueCkgK1xyXG4gICAgICAgICAgKHcwLnktdzEueSkqKHcwLnktdzEueSkgK1xyXG4gICAgICAgICAgKHcwLnotdzEueikqKHcwLnotdzEueilcclxuICAgICAgICApLnRvRml4ZWQoMil9IG1tYDtcclxuICAgIGxldCBwb3NZMCA9XHJcbiAgICAgIHkwIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCAtIHRoaXMuX2Rpc3RhbmNlLm9mZnNldEhlaWdodC8yO1xyXG4gICAgeDAgLT0gdGhpcy5fZGlzdGFuY2Uub2Zmc2V0V2lkdGgvMjtcclxuXHJcbiAgICBsZXQgdHJhbnNmb3JtMiA9XHJcbiAgICAgIGB0cmFuc2xhdGUzRCgke01hdGgucm91bmQoeDApfXB4LCR7TWF0aC5yb3VuZChwb3NZMCl9cHgsIDApYDtcclxuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTI7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVET01Db2xvcigpIHtcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcclxuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcclxuICB9XHJcblxyXG4gIGZyZWUoKSB7XHJcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzLmZvckVhY2goKGgpID0+IHtcclxuICAgICAgaC5mcmVlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzID0gW107XHJcblxyXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2xpbmUpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2Rpc3RhbmNlKTtcclxuXHJcbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9tZXNoKTtcclxuXHJcbiAgICBzdXBlci5mcmVlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgd29ybGRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xyXG4gICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiXHJcbmltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XHJcbmltcG9ydCBHZW9tZXRyaWVzVm94ZWwgZnJvbSAnLi4vZ2VvbWV0cmllcy9nZW9tZXRyaWVzLnZveGVsJztcclxuaW1wb3J0IE1vZGVsc1N0YWNrIGZyb20gJy4uL21vZGVscy9tb2RlbHMuc3RhY2snO1xyXG5pbXBvcnQgTW9kZWxzVm94ZWwgZnJvbSAnLi4vbW9kZWxzL21vZGVscy52b3hlbCc7XHJcbmltcG9ydCBDb3JlSW50ZXJzZWN0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuaW50ZXJzZWN0aW9ucyc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSB3aWRnZXRzL3ZveGVsUHJvYmVcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzVm94ZWxQcm9iZSBleHRlbmRzIFdpZGdldHNCYXNlIHtcclxuICBjb25zdHJ1Y3RvcihzdGFjaywgdGFyZ2V0TWVzaCwgY29udHJvbHMsIGNhbWVyYSwgY29udGFpbmVyKSB7XHJcbiAgICBzdXBlcihjb250YWluZXIpO1xyXG5cclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcblxyXG4gICAgdGhpcy5fdGFyZ2V0TWVzaCA9IHRhcmdldE1lc2g7XHJcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG5cclxuICAgIC8vIGlmIG5vIHRhcmdldCBtZXNoLCB1c2UgcGxhbmUgZm9yIEZSRUUgZHJhZ2dpbmcuXHJcbiAgICB0aGlzLl9wbGFuZSA9IHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICBkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX29mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLl9yYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCk7XHJcblxyXG4gICAgdGhpcy5fdHJhY2tpbmcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9tb3VzZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xyXG5cclxuICAgIC8vIHdvcmxkIChMUFMpIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXJcclxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIC8vIHNjcmVlbiBwb3NpdGlvbiBvZiB0aGUgY2VudGVyXHJcbiAgICB0aGlzLl9zY3JlZW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgLy8gbWVzaCBzdHVmZlxyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoRGlzcGxheWVkID0gdHJ1ZTtcclxuICAgIHRoaXMuX21lc2hIb3ZlcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9tZXNoU3R5bGUgPSAnc3BoZXJlJzsgLy8gY3ViZSwgZXRjLlxyXG5cclxuICAgIC8vIGRvbSBzdHVmZlxyXG4gICAgdGhpcy5fZG9tID0gbnVsbDtcclxuICAgIHRoaXMuX2RvbURpc3BsYXllZCA9IHRydWU7XHJcbiAgICB0aGlzLl9kb21Ib3ZlcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9kb21TdHlsZSA9ICdjaXJjbGUnOyAvLyBzcXVhcmUsIHRyaWFuZ2xlXHJcblxyXG4gICAgaWYgKHRoaXMuX3RhcmdldE1lc2ggIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID1cclxuICAgICAgdGhpcy53b3JsZFRvU2NyZWVuKHRoaXMuX3dvcmxkUG9zaXRpb24sIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgaGFuZGxlXHJcbiAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgdGhpcy5pbml0T2Zmc2V0cygpO1xyXG5cclxuICAgIC8vIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbkhvdmVyID0gdGhpcy5vbkhvdmVyLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uRW5kQ29udHJvbCA9IHRoaXMub25FbmRDb250cm9sLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgfVxyXG5cclxuICBhZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgIHRoaXMuX2RvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkhvdmVyKTtcclxuICAgIHRoaXMuX2RvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbkhvdmVyKTtcclxuXHJcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcclxuXHJcbiAgICB0aGlzLl9jb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLm9uRW5kQ29udHJvbCk7XHJcbiAgfVxyXG5cclxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcclxuICAgIHRoaXMuX2RvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkhvdmVyKTtcclxuICAgIHRoaXMuX2RvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbkhvdmVyKTtcclxuXHJcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcclxuXHJcbiAgICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLm9uRW5kQ29udHJvbCk7XHJcbiAgfVxyXG5cclxuICBvblN0YXJ0KGV2dCkge1xyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuZ2V0TW91c2VPZmZzZXRzKGV2dCwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgIHRoaXMuX21vdXNlLnNldChvZmZzZXRzLngsIG9mZnNldHMueSk7XHJcblxyXG4gICAgLy8gdXBkYXRlIHJheWNhc3RlclxyXG4gICAgdGhpcy5fcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5fbW91c2UsIHRoaXMuX2NhbWVyYSk7XHJcbiAgICB0aGlzLl9yYXljYXN0ZXIucmF5LnBvc2l0aW9uID0gdGhpcy5fcmF5Y2FzdGVyLnJheS5vcmlnaW47XHJcblxyXG4gICAgaWYgKHRoaXMuX2hvdmVyZWQpIHtcclxuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fY29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3RhcmdldE1lc2gpIHtcclxuICAgICAgICBsZXQgaW50ZXJzZWN0c1RhcmdldCA9XHJcbiAgICAgICAgICB0aGlzLl9yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KHRoaXMuX3RhcmdldE1lc2gpO1xyXG4gICAgICAgIGlmIChpbnRlcnNlY3RzVGFyZ2V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRoaXMuX29mZnNldC5jb3B5KGludGVyc2VjdHNUYXJnZXRbMF0ucG9pbnQpLnN1Yih0aGlzLl93b3JsZFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fcGxhbmUucG9zaXRpb24uY29weSh0aGlzLl93b3JsZFBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl9wbGFuZS5kaXJlY3Rpb24uY29weSh0aGlzLl9jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oKSk7XHJcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XHJcbiAgICAgICAgICBDb3JlSW50ZXJzZWN0aW9ucy5yYXlQbGFuZSh0aGlzLl9yYXljYXN0ZXIucmF5LCB0aGlzLl9wbGFuZSk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkoaW50ZXJzZWN0aW9uKS5zdWIodGhpcy5fcGxhbmUucG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRW5kKGV2dCkge1xyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgLy8gc3RheSBhY3RpdmUgYW5kIGtlZXAgY29udHJvbHMgZGlzYWJsZWRcclxuICAgIGlmICh0aGlzLl90cmFja2luZyA9PT0gdHJ1ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdW5zZWxlY3QgaWYgZ28gdXAgd2l0aG91dCBtb3ZpbmdcclxuICAgIGlmICghdGhpcy5fZHJhZ2dlZCAmJiB0aGlzLl9hY3RpdmUpIHtcclxuICAgICAgLy8gY2hhbmdlIHN0YXRlIGlmIHdhcyBub3QgZHJhZ2dpbmdcclxuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSAhdGhpcy5fc2VsZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XHJcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jb250cm9scy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgb25FbmRDb250cm9sKCkge1xyXG4gICAgaWYgKCF0aGlzLl9sYXN0RXZlbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBvbk1vdmUoZXZ0KSB7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5nZXRNb3VzZU9mZnNldHMoZXZ0LCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgdGhpcy5fbW91c2Uuc2V0KG9mZnNldHMueCwgb2Zmc2V0cy55KTtcclxuXHJcbiAgICAvLyB1cGRhdGUgcmF5Y2FzdGVyXHJcbiAgICAvLyBzZXQgcmF5LnBvc2l0aW9uIHRvIHNhdGlzZnkgQ29yZUludGVyc2VjdGlvbnM6OnJheVBsYW5lIEFQSVxyXG4gICAgdGhpcy5fcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5fbW91c2UsIHRoaXMuX2NhbWVyYSk7XHJcbiAgICB0aGlzLl9yYXljYXN0ZXIucmF5LnBvc2l0aW9uID0gdGhpcy5fcmF5Y2FzdGVyLnJheS5vcmlnaW47XHJcblxyXG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xyXG4gICAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XHJcbiAgICAgICAgbGV0IGludGVyc2VjdHNUYXJnZXQgPVxyXG4gICAgICAgICAgdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl90YXJnZXRNZXNoKTtcclxuICAgICAgICBpZiAoaW50ZXJzZWN0c1RhcmdldC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkoaW50ZXJzZWN0c1RhcmdldFswXS5wb2ludC5zdWIodGhpcy5fb2Zmc2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh0aGlzLl9wbGFuZS5kaXJlY3Rpb24ubGVuZ3RoKCkgPT09IDApIHtcclxuICAgICAgICAgIC8vIGZyZWUgbW9kZSF0aGlzLl90YXJnZXRNZXNoXHJcbiAgICAgICAgICB0aGlzLl9wbGFuZS5wb3NpdGlvbi5jb3B5KHRoaXMuX3dvcmxkUG9zaXRpb24pO1xyXG4gICAgICAgICAgdGhpcy5fcGxhbmUuZGlyZWN0aW9uLmNvcHkodGhpcy5fY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKCkpO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPVxyXG4gICAgICAgICAgQ29yZUludGVyc2VjdGlvbnMucmF5UGxhbmUodGhpcy5fcmF5Y2FzdGVyLnJheSwgdGhpcy5fcGxhbmUpO1xyXG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT09IG51bGwpIHtcclxuICAgICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weShpbnRlcnNlY3Rpb24uc3ViKHRoaXMuX29mZnNldCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vbkhvdmVyKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBvbkhvdmVyKGV2dCkge1xyXG4gICAgaWYgKGV2dCkge1xyXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB0aGlzLmhvdmVyRG9tKGV2dCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5ob3Zlck1lc2goKTtcclxuXHJcbiAgICB0aGlzLl9ob3ZlcmVkID0gdGhpcy5fbWVzaEhvdmVyZWQgfHwgdGhpcy5fZG9tSG92ZXJlZDtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSB0aGlzLl9ob3ZlcmVkID8gJ3BvaW50ZXInIDogJ2RlZmF1bHQnO1xyXG4gIH1cclxuXHJcbiAgaG92ZXJNZXNoKCkge1xyXG4gICAgLy8gY2hlY2sgcmF5Y2FzdCBpbnRlcnNlY3Rpb24sIGRvIHdlIHdhbnQgdG8gaG92ZXIgb24gbWVzaCBvciBqdXN0IGNzcz9cclxuICAgIGxldCBpbnRlcnNlY3RzSGFuZGxlID0gdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl9tZXNoKTtcclxuICAgIHRoaXMuX21lc2hIb3ZlcmVkID0gKGludGVyc2VjdHNIYW5kbGUubGVuZ3RoID4gMCk7XHJcbiAgfVxyXG5cclxuICBob3ZlckRvbShldnQpIHtcclxuICAgIHRoaXMuX2RvbUhvdmVyZWQgPSAoZXZ0LnR5cGUgPT09ICdtb3VzZWVudGVyJyk7XHJcbiAgfVxyXG5cclxuICB3b3JsZFRvU2NyZWVuKHdvcmxkQ29vcmRpbmF0ZSwgY2FtZXJhLCBjYW52YXMpIHtcclxuICAgIGxldCBzY3JlZW5Db29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZS5jbG9uZSgpO1xyXG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMucHJvamVjdChjYW1lcmEpO1xyXG5cclxuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnggPVxyXG4gICAgICBNYXRoLnJvdW5kKChzY3JlZW5Db29yZGluYXRlcy54ICsgMSkgKiBjYW52YXMub2Zmc2V0V2lkdGggLyAyKTtcclxuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnkgPVxyXG4gICAgICBNYXRoLnJvdW5kKCgtc2NyZWVuQ29vcmRpbmF0ZXMueSArIDEpICogY2FudmFzLm9mZnNldEhlaWdodCAvIDIpO1xyXG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueiA9IDA7XHJcblxyXG4gICAgcmV0dXJuIHNjcmVlbkNvb3JkaW5hdGVzO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlKCkge1xyXG4gICAgdGhpcy5jcmVhdGVWb3hlbCgpO1xyXG4gICAgdGhpcy5jcmVhdGVNZXNoKCk7XHJcbiAgICB0aGlzLmNyZWF0ZURPTSgpO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlVm94ZWwoKSB7XHJcbiAgICB0aGlzLl92b3hlbCA9IG5ldyBNb2RlbHNWb3hlbCgpO1xyXG4gICAgdGhpcy5fdm94ZWwuaWQgPSB0aGlzLmlkO1xyXG4gICAgdGhpcy5fdm94ZWwud29ybGRDb29yZGluYXRlcyA9IHRoaXMuX3dvcmxkQ29vcmRpbmF0ZXM7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVNZXNoKCkge1xyXG4gICAgY29uc3QgZGF0YUNvb3JkaW5hdGVzID0gTW9kZWxzU3RhY2sud29ybGRUb0RhdGEoXHJcbiAgICAgIHRoaXMuX3N0YWNrLFxyXG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzVm94ZWwoZGF0YUNvb3JkaW5hdGVzKTtcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcclxuICAgICAgICB3aXJlZnJhbWU6IHRydWUsXHJcbiAgICAgICAgd2lyZWZyYW1lTGluZXdpZHRoOiAxLFxyXG4gICAgICB9KTtcclxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTWVzaCh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9zdGFjay5pamsyTFBTKTtcclxuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcclxuXHJcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZU1lc2hDb2xvcigpIHtcclxuICAgIGlmICh0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY3JlYXRlRE9NKCkge1xyXG4gICAgLy8gZG9tXHJcbiAgICB0aGlzLl9kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHRoaXMuX2RvbS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy51dWlkKTtcclxuICAgIHRoaXMuX2RvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ0FNSSBXaWRnZXQgVm94ZWxQcm9iZScpO1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlciA9ICcycHggc29saWQgIzAwMCc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYigyNDksIDI0OSwgMjQ5KSc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuY29sb3IgPSAnIzIxMjEyMSc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwcHggMTAwJSAwcHgnO1xyXG5cclxuICAgIC8vIG1lYXN1cmVuZW50c1xyXG4gICAgbGV0IG1lYXN1cmVtZW50c0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgLy8gTFBTXHJcbiAgICBsZXQgbHBzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBscHNDb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdscHNQb3NpdGlvbicpO1xyXG4gICAgbWVhc3VyZW1lbnRzQ29udGFpbmVyLmFwcGVuZENoaWxkKGxwc0NvbnRhaW5lcik7XHJcbiAgICAvLyBJSktcclxuICAgIGxldCBpamtDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGlqa0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2lqa1Bvc2l0aW9uJyk7XHJcbiAgICBtZWFzdXJlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQoaWprQ29udGFpbmVyKTtcclxuICAgIC8vIFZhbHVlXHJcbiAgICBsZXQgdmFsdWVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHZhbHVlQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAndmFsdWUnKTtcclxuICAgIG1lYXN1cmVtZW50c0NvbnRhaW5lci5hcHBlbmRDaGlsZCh2YWx1ZUNvbnRhaW5lcik7XHJcblxyXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xyXG4gICAgdGhpcy5fZG9tLmFwcGVuZENoaWxkKG1lYXN1cmVtZW50c0NvbnRhaW5lcik7XHJcblxyXG4gICAgLy8gYWRkIGl0IVxyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RvbSk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVET01Db250ZW50KCkge1xyXG4gICAgY29uc3QgcmFzQ29udGFpbmVyID0gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IoJyNscHNQb3NpdGlvbicpO1xyXG4gICAgcmFzQ29udGFpbmVyLmlubmVySFRNTCA9IGBMUFM6IFxyXG4gICAgICAke3RoaXMuX3ZveGVsLndvcmxkQ29vcmRpbmF0ZXMueC50b0ZpeGVkKDIpfSA6XHJcbiAgICAgICR7dGhpcy5fdm94ZWwud29ybGRDb29yZGluYXRlcy55LnRvRml4ZWQoMil9IDpcclxuICAgICAgJHt0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzLnoudG9GaXhlZCgyKX1gO1xyXG5cclxuICAgIGNvbnN0IGlqa0NvbnRhaW5lciA9IHRoaXMuX2RvbS5xdWVyeVNlbGVjdG9yKCcjaWprUG9zaXRpb24nKTtcclxuICAgIGlqa0NvbnRhaW5lci5pbm5lckhUTUwgPSBgSUpLOiBcclxuICAgICAgJHt0aGlzLl92b3hlbC5kYXRhQ29vcmRpbmF0ZXMueH0gOlxyXG4gICAgICAke3RoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcy55fSA6XHJcbiAgICAgICR7dGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzLnp9YDtcclxuXHJcbiAgICBjb25zdCB2YWx1ZUNvbnRhaW5lciA9IHRoaXMuX2RvbS5xdWVyeVNlbGVjdG9yKCcjdmFsdWUnKTtcclxuICAgIHZhbHVlQ29udGFpbmVyLmlubmVySFRNTCA9IGBWYWx1ZTogJHt0aGlzLl92b3hlbC52YWx1ZX1gO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgLy8gZ2VuZXJhbCB1cGRhdGVcclxuICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcclxuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID1cclxuICAgICAgdGhpcy53b3JsZFRvU2NyZWVuKHRoaXMuX3dvcmxkUG9zaXRpb24sIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgICAvLyBzZXQgZGF0YSBjb29yZGluYXRlcyAmJiB2YWx1ZVxyXG4gICAgdGhpcy51cGRhdGVWb3hlbCh0aGlzLl93b3JsZFBvc2l0aW9uKTtcclxuXHJcbiAgICAvLyB1cGRhdGUgbWVzaCBwb3NpdGlvblxyXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcclxuICAgIGlmICh0aGlzLl9tZXNoICYmIHRoaXMuX21lc2guZ2VvbWV0cnkpIHtcclxuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5sb2NhdGlvbiA9IHRoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcztcclxuICAgICAgdGhpcy5fbWVzaC51cGRhdGVNYXRyaXgoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgZG9tXHJcbiAgICB0aGlzLnVwZGF0ZURPTUNvbnRlbnQoKTtcclxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcclxuICAgIHRoaXMudXBkYXRlRE9NUG9zaXRpb24oKTtcclxuICB9XHJcblxyXG5cclxuICB1cGRhdGVWb3hlbCh3b3JsZENvb3JkaW5hdGVzKSB7XHJcbiAgICAvLyB1cGRhdGUgd29ybGQgY29vcmRpbmF0ZXNcclxuICAgIHRoaXMuX3ZveGVsLndvcmxkQ29vcmRpbmF0ZXMgPSB3b3JsZENvb3JkaW5hdGVzO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBkYXRhIGNvb3JkaW5hdGVzXHJcbiAgICB0aGlzLl92b3hlbC5kYXRhQ29vcmRpbmF0ZXMgPSBNb2RlbHNTdGFjay53b3JsZFRvRGF0YShcclxuICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2ssXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3ZveGVsLndvcmxkQ29vcmRpbmF0ZXMpO1xyXG5cclxuICAgIC8vIHVwZGF0ZSB2YWx1ZVxyXG4gICAgbGV0IHZhbHVlID0gTW9kZWxzU3RhY2sudmFsdWUoXHJcbiAgICAgIHRoaXMuX3N0YWNrLFxyXG4gICAgICB0aGlzLl92b3hlbC5kYXRhQ29vcmRpbmF0ZXMpO1xyXG5cclxuICAgIHRoaXMuX3ZveGVsLnZhbHVlID0gTW9kZWxzU3RhY2sudmFsdWVSZXNjYWxlU2xvcGVJbnRlcmNlcHQoXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICB0aGlzLl9zdGFjay5yZXNjYWxlU2xvcGUsXHJcbiAgICAgIHRoaXMuX3N0YWNrLnJlc2NhbGVJbnRlcmNlcHQpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fZG9tKSB7XHJcbiAgICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgIHRoaXMuX2RvbS5zdHlsZS50cmFuc2Zvcm0gPVxyXG4gICAgICAgIGB0cmFuc2xhdGUzRCgke3RoaXMuX3NjcmVlblBvc2l0aW9uLnh9cHgsICR7cG9zWX1weCwgMClgO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlRE9NQ29sb3IoKSB7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gIH1cclxuXHJcbiAgZnJlZSgpIHtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5cclxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwSGFuZGxlciwgZmFsc2UpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLlxyXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlSGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lci5cclxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3VzZU1vdmVIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICB0aGlzLl9jb250YWluZXIuXHJcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdXNlTW92ZUhhbmRsZXIsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLl92b3hlbC5yZW1vdmVUZXN0KCk7XHJcbiAgICB0aGlzLnJlbW92ZSh0aGlzLl92b3hlbCk7XHJcbiAgICB0aGlzLl92b3hlbCA9IG51bGw7XHJcblxyXG4gICAgc3VwZXIuZnJlZSgpO1xyXG4gIH1cclxuXHJcbiAgaG92ZXJWb3hlbChtb3VzZVNjcmVlbkNvb3JkaW5hdGVzLCBjdXJyZW50RGF0YUNvb3JkaW5hdGVzKSB7XHJcbiAgICAvLyB1cGRhdGUgZGlzdGFuY2UgbW91c2UvdGhpcy5fdm94ZWxcclxuICAgIGxldCBkeCA9XHJcbiAgICAgIG1vdXNlU2NyZWVuQ29vcmRpbmF0ZXMuc2NyZWVuWCAtIHRoaXMuX3ZveGVsLnZveGVsLnNjcmVlbkNvb3JkaW5hdGVzLng7XHJcbiAgICBsZXQgZHkgPVxyXG4gICAgICBtb3VzZVNjcmVlbkNvb3JkaW5hdGVzLnNjcmVlblkgLSB0aGlzLl92b3hlbC52b3hlbC5zY3JlZW5Db29yZGluYXRlcy55O1xyXG4gICAgbGV0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgIHRoaXMuX3ZveGVsLmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICBpZiAoZGlzdGFuY2UgPj0gMCAmJiBkaXN0YW5jZSA8IDEwKSB7XHJcbiAgICAgIHRoaXMuX2hvdmVyID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2hvdmVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkod29ybGRQb3NpdGlvbik7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRlZmF1bHRDb2xvcihkZWZhdWx0Q29sb3IpIHtcclxuICAgIHRoaXMuX2RlZmF1bHRDb2xvciA9IGRlZmF1bHRDb2xvcjtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgZGVmYXVsdENvbG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRDb2xvcjtcclxuICB9XHJcblxyXG4gIHNldCBhY3RpdmVDb2xvcihhY3RpdmVDb2xvcikge1xyXG4gICAgdGhpcy5fYWN0aXZlQ29sb3IgPSBhY3RpdmVDb2xvcjtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgYWN0aXZlQ29sb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlQ29sb3I7XHJcbiAgfVxyXG5cclxuICBzZXQgaG92ZXJDb2xvcihob3ZlckNvbG9yKSB7XHJcbiAgICB0aGlzLl9ob3ZlckNvbG9yID0gaG92ZXJDb2xvcjtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgaG92ZXJDb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9ob3ZlckNvbG9yO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNlbGVjdGVkQ29sb3Ioc2VsZWN0ZWRDb2xvcikge1xyXG4gICAgdGhpcy5fc2VsZWN0ZWRDb2xvciA9IHNlbGVjdGVkQ29sb3I7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNlbGVjdGVkQ29sb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRDb2xvcjtcclxuICB9XHJcblxyXG4gIHNldCBzaG93Vm94ZWwoc2hvd1ZveGVsKSB7XHJcbiAgICB0aGlzLl9zaG93Vm94ZWwgPSBzaG93Vm94ZWw7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNob3dWb3hlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zaG93Vm94ZWw7XHJcbiAgfVxyXG5cclxuICBzZXQgc2hvd0RvbVNWRyhzaG93RG9tU1ZHKSB7XHJcbiAgICB0aGlzLl9zaG93RG9tU1ZHID0gc2hvd0RvbVNWRztcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2hvd0RvbVNWRygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zaG93RG9tU1ZHO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNob3dEb21NZWFzdXJlbWVudHMoc2hvd0RvbU1lYXN1cmVtZW50cykge1xyXG4gICAgdGhpcy5fc2hvd0RvbU1lYXN1cmVtZW50cyA9IHNob3dEb21NZWFzdXJlbWVudHM7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNob3dEb21NZWFzdXJlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2hvd0RvbU1lYXN1cmVtZW50cztcclxuICB9XHJcblxyXG4gIGhpZGVET00oKSB7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICB9XHJcblxyXG4gIHNob3dET00oKSB7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gIH1cclxuXHJcbiAgaGlkZU1lc2goKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHNob3dNZXNoKCkge1xyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHNob3coKSB7XHJcbiAgICB0aGlzLnNob3dET00oKTtcclxuICAgIHRoaXMuc2hvd01lc2goKTtcclxuICB9XHJcblxyXG4gIGhpZGUoKSB7XHJcbiAgICB0aGlzLmhpZGVET00oKTtcclxuICAgIHRoaXMuaGlkZU1lc2goKTtcclxuICB9XHJcbn1cclxuIl19
