(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AMI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// jshint ignore: start

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
 /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
 Copyright 2011 notmasteryet

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var ColorSpace = {Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4};
var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
    0,
    1, 8,
    16, 9, 2,
    3, 10, 17, 24,
    32, 25, 18, 11, 4,
    5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13, 6,
    7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1 = 4017;   // cos(pi/16)
  var dctSin1 = 799;   // sin(pi/16)
  var dctCos3 = 3406;   // cos(3*pi/16)
  var dctSin3 = 2276;   // sin(3*pi/16)
  var dctCos6 = 1567;   // cos(6*pi/16)
  var dctSin6 = 3784;   // sin(6*pi/16)
  var dctSqrt2 = 5793;   // sqrt(2)
  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;

    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }

    function decodeHuffman(tree) {
      var node = tree;
      var bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw "invalid huffman sequence";
      }
      return null;
    }

    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null)
          return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }

    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }

    function decodeBaseline(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[offset] = (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      component.blockData[offset] = (component.pred += diff);
    }

    function decodeDCSuccessive(component, offset) {
      component.blockData[offset] |= readBit() << successive;
    }

    var eobrun = 0;
    function decodeACFirst(component, offset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }

    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, offset) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
          case 0: // initial state
            var rs = decodeHuffman(component.huffmanTableAC);
            var s = rs & 15;
            r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1)
                throw "invalid ACn encoding";
              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }
            continue;
          case 1: // skipping r zero items
          case 2:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              r--;
              if (r === 0)
                successiveACState = successiveACState == 2 ? 3 : 0;
            }
            break;
          case 3: // set value for a zero item
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              component.blockData[offset + z] = successiveACNextValue << successive;
              successiveACState = 0;
            }
            break;
          case 4: // eob
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            }
            break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) {
      resetInterval = mcuExpected;
    }

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker <= 0xFF00) {
        throw "marker was not found";
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  }

  // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable;
    var v0, v1, v2, v3, v4, v5, v6, v7, t;
    var i;

    // dequant
    for (i = 0; i < 64; i++) {
      p[i] = component.blockData[blockBufferOffset + i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i < 8; ++i) {
      var row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 &&
        p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 &&
        p[7 + row] === 0) {
        t = (dctSqrt2 * p[0 + row] + 512) >> 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
      v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
      v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
      v5 = p[3 + row] << 4;
      v6 = p[5 + row] << 4;

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i < 8; ++i) {
      var col = i;

      // check for all-zero AC coefficients
      if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 &&
        p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 &&
        p[7 * 8 + col] === 0) {
        t = (dctSqrt2 * p[i + 0] + 8192) >> 14;
        p[0 * 8 + col] = t;
        p[1 * 8 + col] = t;
        p[2 * 8 + col] = t;
        p[3 * 8 + col] = t;
        p[4 * 8 + col] = t;
        p[5 * 8 + col] = t;
        p[6 * 8 + col] = t;
        p[7 * 8 + col] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;
      v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;
      v2 = p[2 * 8 + col];
      v3 = p[6 * 8 + col];
      v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;
      v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;
      v5 = p[3 * 8 + col];
      v6 = p[5 * 8 + col];

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 * 8 + col] = v0 + v7;
      p[7 * 8 + col] = v0 - v7;
      p[1 * 8 + col] = v1 + v6;
      p[6 * 8 + col] = v1 - v6;
      p[2 * 8 + col] = v2 + v5;
      p[5 * 8 + col] = v2 - v5;
      p[3 * 8 + col] = v3 + v4;
      p[4 * 8 + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i < 64; ++i) {
      var index = blockBufferOffset + i;
      var q = p[i];
      q = (q <= -2056 / component.bitConversion) ? 0 :
        (q >= 2024 / component.bitConversion) ? 255 / component.bitConversion :
        (q + 2056 / component.bitConversion) >> 4;
      component.blockData[index] = q;
    }
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    var computationBuffer = new Int32Array(64);

    var i, j, ll = 0;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }
    return component.blockData;
  }

  function clampToUint8(a) {
    return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;
  }

  constructor.prototype = {
    load: function load(path) {
      var handleData = (function (data) {
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);

      if (path.indexOf("data:") > -1) {
        var offset = path.indexOf("base64,") + 7;
        var data = atob(path.substring(offset));
        var arr = new Uint8Array(data.length);
        for (var i = data.length - 1; i >= 0; i--) {
          arr[i] = data.charCodeAt(i);
        }
        handleData(data);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = (function () {
          // TODO catch parse error
          var data = new Uint8Array(xhr.response);
          handleData(data);
        }).bind(this);
        xhr.send(null);
      }
    },
    parse: function parse(data) {

      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }

      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
        for (var i = 0; i < frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;

          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0, length = data.length;
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw "SOI not found";
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch (fileMarker) {
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: {major: appData[5], minor: appData[6]},
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var zz = dctZigZag[j];
                  tableData[zz] = readUint16();
                }
              } else
                throw "DQT: invalid table spec";
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            if (frame) {
              throw "Only single frame JPEGs supported";
            }
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              if (maxH < h)
                maxH = h;
              if (maxV < v)
                maxV = v;
              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationTable: quantizationTables[qId],
                quantizationTableId: qId,
                bitConversion: 255 / ((1 << frame.precision) - 1)
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength; ) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              var componentIndex = frame.componentIds[data[offset++]];
              component = frame.components[componentIndex];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;
          default:
            if (data[offset - 3] == 0xFF &&
              data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw "unknown JPEG marker " + fileMarker.toString(16);
        }
        fileMarker = readUint16();
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      switch (frame.components.length)
      {
        case 1:
          this.colorspace = ColorSpace.Grayscale;
          break;
        case 3:
          if (this.adobe)
            this.colorspace = ColorSpace.AdobeRGB;
          else
            this.colorspace = ColorSpace.RGB;
          break;
        case 4:
          this.colorspace = ColorSpace.CYMK;
          break;
        default:
          this.colorspace = ColorSpace.Unknown;
      }
      for (var i = 0; i < frame.components.length; i++) {
        var component = frame.components[i];
        if (!component.quantizationTable && component.quantizationTableId !== null)
          component.quantizationTable = quantizationTables[component.quantizationTableId];
        this.components.push({
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn,
          bitConversion: component.bitConversion
        });
      }
    },
    getData16: function getData16(width, height) {
      if (this.components.length !== 1)
        throw 'Unsupported color mode';
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint16Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++];
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }
      return data;
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++] * component.bitConversion;
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }

      // ... then transform colors, if necessary
      switch (numComponents) {
        case 1:
        case 2:
          break;
        // no color conversion for one or two compoenents

        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i    ];
              Cb = data[i + 1];
              Cr = data[i + 2];

              R = clampToUint8(Y - 179.456 + 1.402 * Cr);
              G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
              B = clampToUint8(Y - 226.816 + 1.772 * Cb);

              data[i    ] = R;
              data[i + 1] = G;
              data[i + 2] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw 'Unsupported color mode (4 components)';
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i];
              Cb = data[i + 1];
              Cr = data[i + 2];

              C = clampToUint8(434.456 - Y - 1.402 * Cr);
              M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
              Y = clampToUint8(481.816 - Y - 1.772 * Cb);

              data[i    ] = C;
              data[i + 1] = M;
              data[i + 2] = Y;
              // K is unchanged
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
      return data;
    }
  };

  return constructor;
})();

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = JpegImage;
}
},{}],2:[function(require,module,exports){
/*! image-JPEG2000 - v0.3.1 - 2015-08-26 | https://github.com/OHIF/image-JPEG2000 */
/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals ArithmeticDecoder, globalScope, log2, readUint16, readUint32,
           info, warn */

'use strict';

var JpxImage = (function JpxImageClosure() {
  // Table E.1
  var SubbandsGainLog2 = {
    'LL': 0,
    'LH': 1,
    'HL': 1,
    'HH': 2
  };
  function JpxImage() {
    this.failOnCorruptedImage = false;
  }
  JpxImage.prototype = {
    parse: function JpxImage_parse(data) {

      var head = readUint16(data, 0);
      // No box header, immediate start of codestream (SOC)
      if (head === 0xFF4F) {
        this.parseCodestream(data, 0, data.length);
        return;
      }

      var position = 0, length = data.length;
      while (position < length) {
        var headerSize = 8;
        var lbox = readUint32(data, position);
        var tbox = readUint32(data, position + 4);
        position += headerSize;
        if (lbox === 1) {
          // XLBox: read UInt64 according to spec.
          // JavaScript's int precision of 53 bit should be sufficient here.
          lbox = readUint32(data, position) * 4294967296 +
                 readUint32(data, position + 4);
          position += 8;
          headerSize += 8;
        }
        if (lbox === 0) {
          lbox = length - position + headerSize;
        }
        if (lbox < headerSize) {
          throw new Error('JPX Error: Invalid box field size');
        }
        var dataLength = lbox - headerSize;
        var jumpDataLength = true;
        switch (tbox) {
          case 0x6A703268: // 'jp2h'
            jumpDataLength = false; // parsing child boxes
            break;
          case 0x636F6C72: // 'colr'
            // Colorspaces are not used, the CS from the PDF is used.
            var method = data[position];
            var precedence = data[position + 1];
            var approximation = data[position + 2];
            if (method === 1) {
              // enumerated colorspace
              var colorspace = readUint32(data, position + 3);
              switch (colorspace) {
                case 16: // this indicates a sRGB colorspace
                case 17: // this indicates a grayscale colorspace
                case 18: // this indicates a YUV colorspace
                  break;
                default:
                  warn('Unknown colorspace ' + colorspace);
                  break;
              }
            } else if (method === 2) {
              info('ICC profile not supported');
            }
            break;
          case 0x6A703263: // 'jp2c'
            this.parseCodestream(data, position, position + dataLength);
            break;
          case 0x6A502020: // 'jP\024\024'
            if (0x0d0a870a !== readUint32(data, position)) {
              warn('Invalid JP2 signature');
            }
            break;
          // The following header types are valid but currently not used:
          case 0x6A501A1A: // 'jP\032\032'
          case 0x66747970: // 'ftyp'
          case 0x72726571: // 'rreq'
          case 0x72657320: // 'res '
          case 0x69686472: // 'ihdr'
            break;
          default:
            var headerType = String.fromCharCode((tbox >> 24) & 0xFF,
                                                 (tbox >> 16) & 0xFF,
                                                 (tbox >> 8) & 0xFF,
                                                 tbox & 0xFF);
            warn('Unsupported header type ' + tbox + ' (' + headerType + ')');
            break;
        }
        if (jumpDataLength) {
          position += dataLength;
        }
      }
    },
    parseImageProperties: function JpxImage_parseImageProperties(stream) {
      var newByte = stream.getByte();
      while (newByte >= 0) {
        var oldByte = newByte;
        newByte = stream.getByte();
        var code = (oldByte << 8) | newByte;
        // Image and tile size (SIZ)
        if (code === 0xFF51) {
          stream.skip(4);
          var Xsiz = stream.getInt32() >>> 0; // Byte 4
          var Ysiz = stream.getInt32() >>> 0; // Byte 8
          var XOsiz = stream.getInt32() >>> 0; // Byte 12
          var YOsiz = stream.getInt32() >>> 0; // Byte 16
          stream.skip(16);
          var Csiz = stream.getUint16(); // Byte 36
          this.width = Xsiz - XOsiz;
          this.height = Ysiz - YOsiz;
          this.componentsCount = Csiz;
          // Results are always returned as Uint8Arrays
          this.bitsPerComponent = 8;
          return;
        }
      }
      throw new Error('JPX Error: No size marker found in JPX stream');
    },
    parseCodestream: function JpxImage_parseCodestream(data, start, end) {
      var context = {};
      try {
        var doNotRecover = false;
        var position = start;
        while (position + 1 < end) {
          var code = readUint16(data, position);
          position += 2;

          var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
          switch (code) {
            case 0xFF4F: // Start of codestream (SOC)
              context.mainHeader = true;
              break;
            case 0xFFD9: // End of codestream (EOC)
              break;
            case 0xFF51: // Image and tile size (SIZ)
              length = readUint16(data, position);
              var siz = {};
              siz.Xsiz = readUint32(data, position + 4);
              siz.Ysiz = readUint32(data, position + 8);
              siz.XOsiz = readUint32(data, position + 12);
              siz.YOsiz = readUint32(data, position + 16);
              siz.XTsiz = readUint32(data, position + 20);
              siz.YTsiz = readUint32(data, position + 24);
              siz.XTOsiz = readUint32(data, position + 28);
              siz.YTOsiz = readUint32(data, position + 32);
              var componentsCount = readUint16(data, position + 36);
              siz.Csiz = componentsCount;
              var components = [];
              j = position + 38;
              for (var i = 0; i < componentsCount; i++) {
                var component = {
                  precision: (data[j] & 0x7F) + 1,
                  isSigned: !!(data[j] & 0x80),
                  XRsiz: data[j + 1],
                  YRsiz: data[j + 1]
                };
                calculateComponentDimensions(component, siz);
                components.push(component);
              }
              context.SIZ = siz;
              context.components = components;
              calculateTileGrids(context, components);
              context.QCC = [];
              context.COC = [];
              break;
            case 0xFF5C: // Quantization default (QCD)
              length = readUint16(data, position);
              var qcd = {};
              j = position + 2;
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcd.noQuantization = (spqcdSize === 8);
              qcd.scalarExpounded = scalarExpounded;
              qcd.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < length + position) {
                var spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcd.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCD = qcd;
              } else {
                context.currentTile.QCD = qcd;
                context.currentTile.QCC = [];
              }
              break;
            case 0xFF5D: // Quantization component (QCC)
              length = readUint16(data, position);
              var qcc = {};
              j = position + 2;
              var cqcc;
              if (context.SIZ.Csiz < 257) {
                cqcc = data[j++];
              } else {
                cqcc = readUint16(data, j);
                j += 2;
              }
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcc.noQuantization = (spqcdSize === 8);
              qcc.scalarExpounded = scalarExpounded;
              qcc.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < (length + position)) {
                spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcc.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCC[cqcc] = qcc;
              } else {
                context.currentTile.QCC[cqcc] = qcc;
              }
              break;
            case 0xFF52: // Coding style default (COD)
              length = readUint16(data, position);
              var cod = {};
              j = position + 2;
              var scod = data[j++];
              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
              cod.sopMarkerUsed = !!(scod & 2);
              cod.ephMarkerUsed = !!(scod & 4);
              cod.progressionOrder = data[j++];
              cod.layersCount = readUint16(data, j);
              j += 2;
              cod.multipleComponentTransform = data[j++];

              cod.decompositionLevelsCount = data[j++];
              cod.xcb = (data[j++] & 0xF) + 2;
              cod.ycb = (data[j++] & 0xF) + 2;
              var blockStyle = data[j++];
              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
              cod.resetContextProbabilities = !!(blockStyle & 2);
              cod.terminationOnEachCodingPass = !!(blockStyle & 4);
              cod.verticalyStripe = !!(blockStyle & 8);
              cod.predictableTermination = !!(blockStyle & 16);
              cod.segmentationSymbolUsed = !!(blockStyle & 32);
              cod.reversibleTransformation = data[j++];
              if (cod.entropyCoderWithCustomPrecincts) {
                var precinctsSizes = [];
                while (j < length + position) {
                  var precinctsSize = data[j++];
                  precinctsSizes.push({
                    PPx: precinctsSize & 0xF,
                    PPy: precinctsSize >> 4
                  });
                }
                cod.precinctsSizes = precinctsSizes;
              }
              var unsupported = [];
              if (cod.selectiveArithmeticCodingBypass) {
                unsupported.push('selectiveArithmeticCodingBypass');
              }
              if (cod.resetContextProbabilities) {
                unsupported.push('resetContextProbabilities');
              }
              if (cod.terminationOnEachCodingPass) {
                unsupported.push('terminationOnEachCodingPass');
              }
              if (cod.verticalyStripe) {
                unsupported.push('verticalyStripe');
              }
              if (cod.predictableTermination) {
                unsupported.push('predictableTermination');
              }
              if (unsupported.length > 0) {
                doNotRecover = true;
                throw new Error('JPX Error: Unsupported COD options (' +
                                unsupported.join(', ') + ')');
              }
              if (context.mainHeader) {
                context.COD = cod;
              } else {
                context.currentTile.COD = cod;
                context.currentTile.COC = [];
              }
              break;
            case 0xFF90: // Start of tile-part (SOT)
              length = readUint16(data, position);
              tile = {};
              tile.index = readUint16(data, position + 2);
              tile.length = readUint32(data, position + 4);
              tile.dataEnd = tile.length + position - 2;
              tile.partIndex = data[position + 8];
              tile.partsCount = data[position + 9];

              context.mainHeader = false;
              if (tile.partIndex === 0) {
                // reset component specific settings
                tile.COD = context.COD;
                tile.COC = context.COC.slice(0); // clone of the global COC
                tile.QCD = context.QCD;
                tile.QCC = context.QCC.slice(0); // clone of the global COC
              }
              context.currentTile = tile;
              break;
            case 0xFF93: // Start of data (SOD)
              tile = context.currentTile;
              if (tile.partIndex === 0) {
                initializeTile(context, tile.index);
                buildPackets(context);
              }

              // moving to the end of the data
              length = tile.dataEnd - position;
              parseTilePackets(context, data, position, length);
              break;
            case 0xFF55: // Tile-part lengths, main header (TLM)
            case 0xFF57: // Packet length, main header (PLM)
            case 0xFF58: // Packet length, tile-part header (PLT)
            case 0xFF64: // Comment (COM)
              length = readUint16(data, position);
              // skipping content
              break;
            case 0xFF53: // Coding style component (COC)
              throw new Error('JPX Error: Codestream code 0xFF53 (COC) is ' +
                              'not implemented');
            default:
              throw new Error('JPX Error: Unknown codestream code: ' +
                              code.toString(16));
          }
          position += length;
        }
      } catch (e) {
        if (doNotRecover || this.failOnCorruptedImage) {
          throw e;
        } else {
          warn('Trying to recover from ' + e.message);
        }
      }
      this.tiles = transformComponents(context);
      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
      this.componentsCount = context.SIZ.Csiz;
    }
  };
  function calculateComponentDimensions(component, siz) {
    // Section B.2 Component mapping
    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
    component.width = component.x1 - component.x0;
    component.height = component.y1 - component.y0;
  }
  function calculateTileGrids(context, components) {
    var siz = context.SIZ;
    // Section B.3 Division into tile and tile-components
    var tile, tiles = [];
    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
    for (var q = 0; q < numYtiles; q++) {
      for (var p = 0; p < numXtiles; p++) {
        tile = {};
        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
        tile.width = tile.tx1 - tile.tx0;
        tile.height = tile.ty1 - tile.ty0;
        tile.components = [];
        tiles.push(tile);
      }
    }
    context.tiles = tiles;

    var componentsCount = siz.Csiz;
    for (var i = 0, ii = componentsCount; i < ii; i++) {
      var component = components[i];
      for (var j = 0, jj = tiles.length; j < jj; j++) {
        var tileComponent = {};
        tile = tiles[j];
        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
        tile.components[i] = tileComponent;
      }
    }
  }
  function getBlocksDimensions(context, component, r) {
    var codOrCoc = component.codingStyleParameters;
    var result = {};
    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
      result.PPx = 15;
      result.PPy = 15;
    } else {
      result.PPx = codOrCoc.precinctsSizes[r].PPx;
      result.PPy = codOrCoc.precinctsSizes[r].PPy;
    }
    // calculate codeblock size as described in section B.7
    result.xcb_ = (r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :
                   Math.min(codOrCoc.xcb, result.PPx));
    result.ycb_ = (r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :
                   Math.min(codOrCoc.ycb, result.PPy));
    return result;
  }
  function buildPrecincts(context, resolution, dimensions) {
    // Section B.6 Division resolution to precincts
    var precinctWidth = 1 << dimensions.PPx;
    var precinctHeight = 1 << dimensions.PPy;
    // Jasper introduces codeblock groups for mapping each subband codeblocks
    // to precincts. Precinct partition divides a resolution according to width
    // and height parameters. The subband that belongs to the resolution level
    // has a different size than the level, unless it is the zero resolution.

    // From Jasper documentation: jpeg2000.pdf, section K: Tier-2 coding:
    // The precinct partitioning for a particular subband is derived from a
    // partitioning of its parent LL band (i.e., the LL band at the next higher
    // resolution level)... The LL band associated with each resolution level is
    // divided into precincts... Each of the resulting precinct regions is then
    // mapped into its child subbands (if any) at the next lower resolution
    // level. This is accomplished by using the coordinate transformation
    // (u, v) = (ceil(x/2), ceil(y/2)) where (x, y) and (u, v) are the
    // coordinates of a point in the LL band and child subband, respectively.
    var isZeroRes = resolution.resLevel === 0;
    var precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));
    var precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));
    var numprecinctswide = (resolution.trx1 > resolution.trx0 ?
      Math.ceil(resolution.trx1 / precinctWidth) -
      Math.floor(resolution.trx0 / precinctWidth) : 0);
    var numprecinctshigh = (resolution.try1 > resolution.try0 ?
      Math.ceil(resolution.try1 / precinctHeight) -
      Math.floor(resolution.try0 / precinctHeight) : 0);
    var numprecincts = numprecinctswide * numprecinctshigh;

    resolution.precinctParameters = {
      precinctWidth: precinctWidth,
      precinctHeight: precinctHeight,
      numprecinctswide: numprecinctswide,
      numprecinctshigh: numprecinctshigh,
      numprecincts: numprecincts,
      precinctWidthInSubband: precinctWidthInSubband,
      precinctHeightInSubband: precinctHeightInSubband
    };
  }
  function buildCodeblocks(context, subband, dimensions) {
    // Section B.7 Division sub-band into code-blocks
    var xcb_ = dimensions.xcb_;
    var ycb_ = dimensions.ycb_;
    var codeblockWidth = 1 << xcb_;
    var codeblockHeight = 1 << ycb_;
    var cbx0 = subband.tbx0 >> xcb_;
    var cby0 = subband.tby0 >> ycb_;
    var cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;
    var cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;
    var precinctParameters = subband.resolution.precinctParameters;
    var codeblocks = [];
    var precincts = [];
    var i, j, codeblock, precinctNumber;
    for (j = cby0; j < cby1; j++) {
      for (i = cbx0; i < cbx1; i++) {
        codeblock = {
          cbx: i,
          cby: j,
          tbx0: codeblockWidth * i,
          tby0: codeblockHeight * j,
          tbx1: codeblockWidth * (i + 1),
          tby1: codeblockHeight * (j + 1)
        };

        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);

        // Calculate precinct number for this codeblock, codeblock position
        // should be relative to its subband, use actual dimension and position
        // See comment about codeblock group width and height
        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) /
          precinctParameters.precinctWidthInSubband);
        var pj = Math.floor((codeblock.tby0_ - subband.tby0) /
          precinctParameters.precinctHeightInSubband);
        precinctNumber = pi + (pj * precinctParameters.numprecinctswide);

        codeblock.precinctNumber = precinctNumber;
        codeblock.subbandType = subband.type;
        codeblock.Lblock = 3;

        if (codeblock.tbx1_ <= codeblock.tbx0_ ||
            codeblock.tby1_ <= codeblock.tby0_) {
          continue;
        }
        codeblocks.push(codeblock);
        // building precinct for the sub-band
        var precinct = precincts[precinctNumber];
        if (precinct !== undefined) {
          if (i < precinct.cbxMin) {
            precinct.cbxMin = i;
          } else if (i > precinct.cbxMax) {
            precinct.cbxMax = i;
          }
          if (j < precinct.cbyMin) {
            precinct.cbxMin = j;
          } else if (j > precinct.cbyMax) {
            precinct.cbyMax = j;
          }
        } else {
          precincts[precinctNumber] = precinct = {
            cbxMin: i,
            cbyMin: j,
            cbxMax: i,
            cbyMax: j
          };
        }
        codeblock.precinct = precinct;
      }
    }
    subband.codeblockParameters = {
      codeblockWidth: xcb_,
      codeblockHeight: ycb_,
      numcodeblockwide: cbx1 - cbx0 + 1,
      numcodeblockhigh: cby1 - cby0 + 1
    };
    subband.codeblocks = codeblocks;
    subband.precincts = precincts;
  }
  function createPacket(resolution, precinctNumber, layerNumber) {
    var precinctCodeblocks = [];
    // Section B.10.8 Order of info in packet
    var subbands = resolution.subbands;
    // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence
    for (var i = 0, ii = subbands.length; i < ii; i++) {
      var subband = subbands[i];
      var codeblocks = subband.codeblocks;
      for (var j = 0, jj = codeblocks.length; j < jj; j++) {
        var codeblock = codeblocks[j];
        if (codeblock.precinctNumber !== precinctNumber) {
          continue;
        }
        precinctCodeblocks.push(codeblock);
      }
    }
    return {
      layerNumber: layerNumber,
      codeblocks: precinctCodeblocks
    };
  }
  function LayerResolutionComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var l = 0, r = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.1 Layer-resolution-component-position
      for (; l < layersCount; l++) {
        for (; r <= maxDecompositionLevelsCount; r++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        r = 0;
      }
    };
  }
  function ResolutionLayerComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var r = 0, l = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.2 Resolution-layer-component-position
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; l < layersCount; l++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        l = 0;
      }
    };
  }
  function ResolutionPositionComponentLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var l, r, c, p;
    var maxDecompositionLevelsCount = 0;
    for (c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        component.codingStyleParameters.decompositionLevelsCount);
    }
    var maxNumPrecinctsInLevel = new Int32Array(
      maxDecompositionLevelsCount + 1);
    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
      var maxNumPrecincts = 0;
      for (c = 0; c < componentsCount; ++c) {
        var resolutions = tile.components[c].resolutions;
        if (r < resolutions.length) {
          maxNumPrecincts = Math.max(maxNumPrecincts,
            resolutions[r].precinctParameters.numprecincts);
        }
      }
      maxNumPrecinctsInLevel[r] = maxNumPrecincts;
    }
    l = 0;
    r = 0;
    c = 0;
    p = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.3 Resolution-position-component-layer
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; p < maxNumPrecinctsInLevel[r]; p++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }
            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            if (p >= numprecincts) {
              continue;
            }
            for (; l < layersCount;) {
              var packet = createPacket(resolution, p, l);
              l++;
              return packet;
            }
            l = 0;
          }
          c = 0;
        }
        p = 0;
      }
    };
  }
  function PositionComponentResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var precinctsIterationSizes = precinctsSizes;
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.4 Position-component-resolution-layer
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            var decompositionLevelsCount =
              component.codingStyleParameters.decompositionLevelsCount;
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale =
                precinctsSizes.components[c].resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          c = 0;
        }
        px = 0;
      }
    };
  }
  function ComponentPositionResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.5 Component-position-resolution-layer
      for (; c < componentsCount; ++c) {
        var component = tile.components[c];
        var precinctsIterationSizes = precinctsSizes.components[c];
        var decompositionLevelsCount =
          component.codingStyleParameters.decompositionLevelsCount;
        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
          for (; px < precinctsIterationSizes.maxNumWide; px++) {
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsIterationSizes.resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          px = 0;
        }
        py = 0;
      }
    };
  }
  function getPrecinctIndexIfExist(
    pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
    var posX = pxIndex * precinctIterationSizes.minWidth;
    var posY = pyIndex * precinctIterationSizes.minHeight;
    if (posX % sizeInImageScale.width !== 0 ||
        posY % sizeInImageScale.height !== 0) {
      return null;
    }
    var startPrecinctRowIndex =
      (posY / sizeInImageScale.width) *
      resolution.precinctParameters.numprecinctswide;
    return (posX / sizeInImageScale.height) + startPrecinctRowIndex;
  }
  function getPrecinctSizesInImageScale(tile) {
    var componentsCount = tile.components.length;
    var minWidth = Number.MAX_VALUE;
    var minHeight = Number.MAX_VALUE;
    var maxNumWide = 0;
    var maxNumHigh = 0;
    var sizePerComponent = new Array(componentsCount);
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      var sizePerResolution = new Array(decompositionLevelsCount + 1);
      var minWidthCurrentComponent = Number.MAX_VALUE;
      var minHeightCurrentComponent = Number.MAX_VALUE;
      var maxNumWideCurrentComponent = 0;
      var maxNumHighCurrentComponent = 0;
      var scale = 1;
      for (var r = decompositionLevelsCount; r >= 0; --r) {
        var resolution = component.resolutions[r];
        var widthCurrentResolution =
          scale * resolution.precinctParameters.precinctWidth;
        var heightCurrentResolution =
          scale * resolution.precinctParameters.precinctHeight;
        minWidthCurrentComponent = Math.min(
          minWidthCurrentComponent,
          widthCurrentResolution);
        minHeightCurrentComponent = Math.min(
          minHeightCurrentComponent,
          heightCurrentResolution);
        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent,
          resolution.precinctParameters.numprecinctswide);
        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent,
          resolution.precinctParameters.numprecinctshigh);
        sizePerResolution[r] = {
          width: widthCurrentResolution,
          height: heightCurrentResolution
        };
        scale <<= 1;
      }
      minWidth = Math.min(minWidth, minWidthCurrentComponent);
      minHeight = Math.min(minHeight, minHeightCurrentComponent);
      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
      sizePerComponent[c] = {
        resolutions: sizePerResolution,
        minWidth: minWidthCurrentComponent,
        minHeight: minHeightCurrentComponent,
        maxNumWide: maxNumWideCurrentComponent,
        maxNumHigh: maxNumHighCurrentComponent
      };
    }
    return {
      components: sizePerComponent,
      minWidth: minWidth,
      minHeight: minHeight,
      maxNumWide: maxNumWide,
      maxNumHigh: maxNumHigh
    };
  }
  function buildPackets(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var componentsCount = siz.Csiz;
    // Creating resolutions and sub-bands for each component
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      // Section B.5 Resolution levels and sub-bands
      var resolutions = [];
      var subbands = [];
      for (var r = 0; r <= decompositionLevelsCount; r++) {
        var blocksDimensions = getBlocksDimensions(context, component, r);
        var resolution = {};
        var scale = 1 << (decompositionLevelsCount - r);
        resolution.trx0 = Math.ceil(component.tcx0 / scale);
        resolution.try0 = Math.ceil(component.tcy0 / scale);
        resolution.trx1 = Math.ceil(component.tcx1 / scale);
        resolution.try1 = Math.ceil(component.tcy1 / scale);
        resolution.resLevel = r;
        buildPrecincts(context, resolution, blocksDimensions);
        resolutions.push(resolution);

        var subband;
        if (r === 0) {
          // one sub-band (LL) with last decomposition
          subband = {};
          subband.type = 'LL';
          subband.tbx0 = Math.ceil(component.tcx0 / scale);
          subband.tby0 = Math.ceil(component.tcy0 / scale);
          subband.tbx1 = Math.ceil(component.tcx1 / scale);
          subband.tby1 = Math.ceil(component.tcy1 / scale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolution.subbands = [subband];
        } else {
          var bscale = 1 << (decompositionLevelsCount - r + 1);
          var resolutionSubbands = [];
          // three sub-bands (HL, LH and HH) with rest of decompositions
          subband = {};
          subband.type = 'HL';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'LH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'HH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          resolution.subbands = resolutionSubbands;
        }
      }
      component.resolutions = resolutions;
      component.subbands = subbands;
    }
    // Generate the packets sequence
    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
    switch (progressionOrder) {
      case 0:
        tile.packetsIterator =
          new LayerResolutionComponentPositionIterator(context);
        break;
      case 1:
        tile.packetsIterator =
          new ResolutionLayerComponentPositionIterator(context);
        break;
      case 2:
        tile.packetsIterator =
          new ResolutionPositionComponentLayerIterator(context);
        break;
      case 3:
        tile.packetsIterator =
          new PositionComponentResolutionLayerIterator(context);
        break;
      case 4:
        tile.packetsIterator =
          new ComponentPositionResolutionLayerIterator(context);
        break;
      default:
        throw new Error('JPX Error: Unsupported progression order ' +
                        progressionOrder);
    }
  }
  function parseTilePackets(context, data, offset, dataLength) {
    var position = 0;
    var buffer, bufferSize = 0, skipNextBit = false;
    function readBits(count) {
      while (bufferSize < count) {
        if(offset + position  >= data.length){
          throw new Error("Unexpected EOF");
        }
        var b = data[offset + position];
        position++;
        if (skipNextBit) {
          buffer = (buffer << 7) | b;
          bufferSize += 7;
          skipNextBit = false;
        } else {
          buffer = (buffer << 8) | b;
          bufferSize += 8;
        }
        if (b === 0xFF) {
          skipNextBit = true;
        }
      }
      bufferSize -= count;
      return (buffer >>> bufferSize) & ((1 << count) - 1);
    }
    function skipMarkerIfEqual(value) {
      if (data[offset + position - 1] === 0xFF &&
          data[offset + position] === value) {
        skipBytes(1);
        return true;
      } else if (data[offset + position] === 0xFF &&
                 data[offset + position + 1] === value) {
        skipBytes(2);
        return true;
      }
      return false;
    }
    function skipBytes(count) {
      position += count;
    }
    function alignToByte() {
      bufferSize = 0;
      if (skipNextBit) {
        position++;
        skipNextBit = false;
      }
    }
    function readCodingpasses() {
      if (readBits(1) === 0) {
        return 1;
      }
      if (readBits(1) === 0) {
        return 2;
      }
      var value = readBits(2);
      if (value < 3) {
        return value + 3;
      }
      value = readBits(5);
      if (value < 31) {
        return value + 6;
      }
      value = readBits(7);
      return value + 37;
    }
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var sopMarkerUsed = context.COD.sopMarkerUsed;
    var ephMarkerUsed = context.COD.ephMarkerUsed;
    var packetsIterator = tile.packetsIterator;
    while (position < dataLength) {
      try{
        alignToByte();
        if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
          // Skip also marker segment length and packet sequence ID
          skipBytes(4);
        }
        var packet = packetsIterator.nextPacket();
        if (packet === undefined) {
          //No more packets. Stream is probably truncated.
          return;
        }
        if (!readBits(1)) {
          continue;
        }
        var layerNumber = packet.layerNumber;
        var queue = [], codeblock;
        for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
          codeblock = packet.codeblocks[i];
          var precinct = codeblock.precinct;
          var codeblockColumn = codeblock.cbx - precinct.cbxMin;
          var codeblockRow = codeblock.cby - precinct.cbyMin;
          var codeblockIncluded = false;
          var firstTimeInclusion = false;
          var valueReady;
          if (codeblock['included'] !== undefined) {
            codeblockIncluded = !!readBits(1);
          } else {
            // reading inclusion tree
            precinct = codeblock.precinct;
            var inclusionTree, zeroBitPlanesTree;
            if (precinct['inclusionTree'] !== undefined) {
              inclusionTree = precinct.inclusionTree;
            } else {
              // building inclusion and zero bit-planes trees
              var width = precinct.cbxMax - precinct.cbxMin + 1;
              var height = precinct.cbyMax - precinct.cbyMin + 1;
              inclusionTree = new InclusionTree(width, height);
              zeroBitPlanesTree = new TagTree(width, height);
              precinct.inclusionTree = inclusionTree;
              precinct.zeroBitPlanesTree = zeroBitPlanesTree;
            }

            inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber);
            while (true) {
              if (position >= data.length) {
                return;
              }
              if (inclusionTree.isAboveThreshold()){
                break;
              }
              if (inclusionTree.isKnown()) {
                inclusionTree.nextLevel();
                continue;
              }
              if (readBits(1)) {
                inclusionTree.setKnown();
                if (inclusionTree.isLeaf()) {
                  codeblock.included = true;
                  codeblockIncluded = firstTimeInclusion = true;
                  break;
                } else {
                  inclusionTree.nextLevel();
                }
              } else {
                inclusionTree.incrementValue();
              }
            }
          }
          if (!codeblockIncluded) {
            continue;
          }
          if (firstTimeInclusion) {
            zeroBitPlanesTree = precinct.zeroBitPlanesTree;
            zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
            while (true) {
              if (position >= data.length) {
                return;
              }
              if (readBits(1)) {
                valueReady = !zeroBitPlanesTree.nextLevel();
                if (valueReady) {
                  break;
                }
              } else {
                zeroBitPlanesTree.incrementValue();
              }
            }
            codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
          }
          var codingpasses = readCodingpasses();
          while (readBits(1)) {
            codeblock.Lblock++;
          }
          var codingpassesLog2 = log2(codingpasses);
          // rounding down log2
          var bits = ((codingpasses < (1 << codingpassesLog2)) ?
                      codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
          var codedDataLength = readBits(bits);
          queue.push({
            codeblock: codeblock,
            codingpasses: codingpasses,
            dataLength: codedDataLength
          });
        }
        alignToByte();
        if (ephMarkerUsed) {
          skipMarkerIfEqual(0x92);
        }
        while (queue.length > 0) {
          var packetItem = queue.shift();
          codeblock = packetItem.codeblock;
          if (codeblock['data'] === undefined) {
            codeblock.data = [];
          }
          codeblock.data.push({
            data: data,
            start: offset + position,
            end: offset + position + packetItem.dataLength,
            codingpasses: packetItem.codingpasses
          });
          position += packetItem.dataLength;
        }
      } catch (e) {
        return;
      }
    }
    return position;
  }
  function copyCoefficients(coefficients, levelWidth, levelHeight, subband,
                            delta, mb, reversible, segmentationSymbolUsed) {
    var x0 = subband.tbx0;
    var y0 = subband.tby0;
    var width = subband.tbx1 - subband.tbx0;
    var codeblocks = subband.codeblocks;
    var right = subband.type.charAt(0) === 'H' ? 1 : 0;
    var bottom = subband.type.charAt(1) === 'H' ? levelWidth : 0;

    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
      var codeblock = codeblocks[i];
      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
      var blockHeight = codeblock.tby1_ - codeblock.tby0_;
      if (blockWidth === 0 || blockHeight === 0) {
        continue;
      }
      if (codeblock['data'] === undefined) {
        continue;
      }

      var bitModel, currentCodingpassType;
      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,
                              codeblock.zeroBitPlanes, mb);
      currentCodingpassType = 2; // first bit plane starts from cleanup

      // collect data
      var data = codeblock.data, totalLength = 0, codingpasses = 0;
      var j, jj, dataItem;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        totalLength += dataItem.end - dataItem.start;
        codingpasses += dataItem.codingpasses;
      }
      var encodedData = new Int16Array(totalLength);
      var position = 0;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
        encodedData.set(chunk, position);
        position += chunk.length;
      }
      // decoding the item
      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
      bitModel.setDecoder(decoder);

      for (j = 0; j < codingpasses; j++) {
        switch (currentCodingpassType) {
          case 0:
            bitModel.runSignificancePropogationPass();
            break;
          case 1:
            bitModel.runMagnitudeRefinementPass();
            break;
          case 2:
            bitModel.runCleanupPass();
            if (segmentationSymbolUsed) {
              bitModel.checkSegmentationSymbol();
            }
            break;
        }
        currentCodingpassType = (currentCodingpassType + 1) % 3;
      }

      var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;
      var sign = bitModel.coefficentsSign;
      var magnitude = bitModel.coefficentsMagnitude;
      var bitsDecoded = bitModel.bitsDecoded;
      var magnitudeCorrection = reversible ? 0 : 0.5;
      var k, n, nb;
      position = 0;
      // Do the interleaving of Section F.3.3 here, so we do not need
      // to copy later. LL level is not interleaved, just copied.
      var interleave = (subband.type !== 'LL');
      for (j = 0; j < blockHeight; j++) {
        var row = (offset / width) | 0; // row in the non-interleaved subband
        var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
        for (k = 0; k < blockWidth; k++) {
          n = magnitude[position];
          if (n !== 0) {
            n = (n + magnitudeCorrection) * delta;
            if (sign[position] !== 0) {
              n = -n;
            }
            nb = bitsDecoded[position];
            var pos = interleave ? (levelOffset + (offset << 1)) : offset;
            if (reversible && (nb >= mb)) {
              coefficients[pos] = n;
            } else {
              coefficients[pos] = n * (1 << (mb - nb));
            }
          }
          offset++;
          position++;
        }
        offset += width - blockWidth;
      }
    }
  }
  function transformTile(context, tile, c) {
    var component = tile.components[c];
    var codingStyleParameters = component.codingStyleParameters;
    var quantizationParameters = component.quantizationParameters;
    var decompositionLevelsCount =
      codingStyleParameters.decompositionLevelsCount;
    var spqcds = quantizationParameters.SPqcds;
    var scalarExpounded = quantizationParameters.scalarExpounded;
    var guardBits = quantizationParameters.guardBits;
    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
    var precision = context.components[c].precision;

    var reversible = codingStyleParameters.reversibleTransformation;
    var transform = (reversible ? new ReversibleTransform() :
                                  new IrreversibleTransform());

    var subbandCoefficients = [];
    var b = 0;
    for (var i = 0; i <= decompositionLevelsCount; i++) {
      var resolution = component.resolutions[i];

      var width = resolution.trx1 - resolution.trx0;
      var height = resolution.try1 - resolution.try0;
      // Allocate space for the whole sublevel.
      var coefficients = new Float32Array(width * height);

      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
        var mu, epsilon;
        if (!scalarExpounded) {
          // formula E-5
          mu = spqcds[0].mu;
          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
        } else {
          mu = spqcds[b].mu;
          epsilon = spqcds[b].epsilon;
          b++;
        }

        var subband = resolution.subbands[j];
        var gainLog2 = SubbandsGainLog2[subband.type];

        // calulate quantization coefficient (Section E.1.1.1)
        var delta = (reversible ? 1 :
          Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048));
        var mb = (guardBits + epsilon - 1);

        // In the first resolution level, copyCoefficients will fill the
        // whole array with coefficients. In the succeding passes,
        // copyCoefficients will consecutively fill in the values that belong
        // to the interleaved positions of the HL, LH, and HH coefficients.
        // The LL coefficients will then be interleaved in Transform.iterate().
        copyCoefficients(coefficients, width, height, subband, delta, mb,
                         reversible, segmentationSymbolUsed);
      }
      subbandCoefficients.push({
        width: width,
        height: height,
        items: coefficients
      });
    }

    var result = transform.calculate(subbandCoefficients,
                                     component.tcx0, component.tcy0);
    return {
      left: component.tcx0,
      top: component.tcy0,
      width: result.width,
      height: result.height,
      items: result.items
    };
  }
  function transformComponents(context) {
    var siz = context.SIZ;
    var components = context.components;
    var componentsCount = siz.Csiz;
    var resultImages = [];
    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
      var tile = context.tiles[i];
      var transformedTiles = [];
      var c;
      for (c = 0; c < componentsCount; c++) {
        transformedTiles[c] = transformTile(context, tile, c);
      }
      var tile0 = transformedTiles[0];
      var isSigned = components[0].isSigned;
      if (isSigned) {
        var out = new Int16Array(tile0.items.length * componentsCount);
      } else {
        var out = new Uint16Array(tile0.items.length * componentsCount);
      }
      var result = {
        left: tile0.left,
        top: tile0.top,
        width: tile0.width,
        height: tile0.height,
        items: out
      };

      // Section G.2.2 Inverse multi component transform
      var shift, offset, max, min, maxK;
      var pos = 0, j, jj, y0, y1, y2, r, g, b, k, val;
      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
        var fourComponents = componentsCount === 4;
        var y0items = transformedTiles[0].items;
        var y1items = transformedTiles[1].items;
        var y2items = transformedTiles[2].items;
        var y3items = fourComponents ? transformedTiles[3].items : null;

        // HACK: The multiple component transform formulas below assume that
        // all components have the same precision. With this in mind, we
        // compute shift and offset only once.
        shift = components[0].precision - 8;
        offset = (128 << shift) + 0.5;
        max = 255 * (1 << shift);
        maxK = max * 0.5;
        min = -maxK;

        var component0 = tile.components[0];
        var alpha01 = componentsCount - 3;
        jj = y0items.length;
        if (!component0.codingStyleParameters.reversibleTransformation) {
          // inverse irreversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            r = y0 + 1.402 * y2;
            g = y0 - 0.34413 * y1 - 0.71414 * y2;
            b = y0 + 1.772 * y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        } else {
          // inverse reversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            g = y0 - ((y2 + y1) >> 2);
            r = g + y2;
            b = g + y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        }
        if (fourComponents) {
          for (j = 0, pos = 3; j < jj; j++, pos += 4) {
            k = y3items[j];
            out[pos] = k <= min ? 0 : k >= maxK ? 255 : (k + offset) >> shift;
          }
        }
      } else { // no multi-component transform
        for (c = 0; c < componentsCount; c++) {
          if (components[c].precision === 8){
            var items = transformedTiles[c].items;
            shift = components[c].precision - 8;
            offset = (128 << shift) + 0.5;
            max = (127.5 * (1 << shift));
            min = -max;
            for (pos = c, j = 0, jj = items.length; j < jj; j++) {
              val = items[j];
              out[pos] = val <= min ? 0 :
                         val >= max ? 255 : (val + offset) >> shift;
              pos += componentsCount;
            }
          }else{
            var isSigned = components[c].isSigned;
            var items = transformedTiles[c].items;

            if(isSigned){
              for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                out[pos] = items[j];
                pos += componentsCount;
              }
            }else{
              shift = components[c].precision - 8;
              offset = (128 << shift) + 0.5;
              var precisionMax = Math.pow(2,components[c].precision)-1;
              for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                val = items[j];
                out[pos] = Math.max(Math.min((val + offset),precisionMax),0);
                pos += componentsCount;
              }
            }
          }
        }
      }
      resultImages.push(result);
    }
    return resultImages;
  }
  function initializeTile(context, tileIndex) {
    var siz = context.SIZ;
    var componentsCount = siz.Csiz;
    var tile = context.tiles[tileIndex];
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var qcdOrQcc = (context.currentTile.QCC[c] !== undefined ?
        context.currentTile.QCC[c] : context.currentTile.QCD);
      component.quantizationParameters = qcdOrQcc;
      var codOrCoc = (context.currentTile.COC[c] !== undefined  ?
        context.currentTile.COC[c] : context.currentTile.COD);
      component.codingStyleParameters = codOrCoc;
    }
    tile.codingStyleDefaultParameters = context.currentTile.COD;
  }

  // Section B.10.2 Tag trees
  var TagTree = (function TagTreeClosure() {
    function TagTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var level = {
          width: width,
          height: height,
          items: []
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    TagTree.prototype = {
      reset: function TagTree_reset(i, j) {
        var currentLevel = 0, value = 0, level;
        while (currentLevel < this.levels.length) {
          level = this.levels[currentLevel];
          var index = i + j * level.width;
          if (level.items[index] !== undefined) {
            value = level.items[index];
            break;
          }
          level.index = index;
          i >>= 1;
          j >>= 1;
          currentLevel++;
        }
        currentLevel--;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        this.currentLevel = currentLevel;
        delete this.value;
      },
      incrementValue: function TagTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index]++;
      },
      nextLevel: function TagTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        currentLevel--;
        if (currentLevel < 0) {
          this.value = value;
          return false;
        }

        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return TagTree;
  })();

  var InclusionTree = (function InclusionTreeClosure() {
    function InclusionTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var items = new Uint8Array(width * height);
        var status = new Uint8Array(width * height);
        for (var j = 0, jj = items.length; j < jj; j++) {
          items[j] = 0;
          status[j] = 0;
        }

        var level = {
          width: width,
          height: height,
          items: items,
          status: status
        };
        this.levels.push(level);

        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    InclusionTree.prototype = {
      reset: function InclusionTree_reset(i, j, stopValue) {
        this.currentStopValue = stopValue;
        var currentLevel = 0;
        while (currentLevel < this.levels.length) {
          var level = this.levels[currentLevel];
          var index = i + j * level.width;
          level.index = index;

          i >>= 1;
          j >>= 1;
          currentLevel++;
        }

        this.currentLevel = this.levels.length - 1;
        this.minValue =this.levels[this.currentLevel].items[0];
        return;
      },
      incrementValue: function InclusionTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index] = level.items[level.index] + 1;
        if(level.items[level.index] > this.minValue) {
          this.minValue = level.items[level.index];
        }
      },
      nextLevel: function InclusionTree_nextLevel() {
        var currentLevel = this.currentLevel;
        currentLevel--;
        if (currentLevel < 0) {
          return false;
        } else {
          this.currentLevel = currentLevel;
          var level = this.levels[currentLevel];
          if(level.items[level.index] < this.minValue) {
            level.items[level.index] = this.minValue;
          }else if (level.items[level.index] > this.minValue) {
            this.minValue = level.items[level.index];
          }
          return true;
        }
      },
    isLeaf: function InclusionTree_isLeaf(){
      return (this.currentLevel === 0);
    },
    isAboveThreshold: function InclusionTree_isAboveThreshold(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      return (level.items[level.index] > this.currentStopValue);
    },
    isKnown: function InclusionTree_isKnown(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      return (level.status[level.index] > 0);
    },
    setKnown: function InclusionTree_setKnown(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      level.status[level.index] = 1;
      return;
    }

    };
    return InclusionTree;
  })();

  // Section D. Coefficient bit modeling
  var BitModel = (function BitModelClosure() {
    var UNIFORM_CONTEXT = 17;
    var RUNLENGTH_CONTEXT = 18;
    // Table D-1
    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),
    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)
    var LLAndLHContextsLabel = new Uint8Array([
      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,
      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,
      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8
    ]);
    var HLContextLabel = new Uint8Array([
      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,
      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,
      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8
    ]);
    var HHContextLabel = new Uint8Array([
      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,
      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,
      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8
    ]);

    function BitModel(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;

      this.contextLabelTable = (subband === 'HH' ? HHContextLabel :
        (subband === 'HL' ? HLContextLabel : LLAndLHContextsLabel));

      var coefficientCount = width * height;

      // coefficients outside the encoding region treated as insignificant
      // add border state cells for significanceState
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) :
                                  mb > 6 ? new Uint16Array(coefficientCount) :
                                  new Uint8Array(coefficientCount);
      this.processingFlags = new Uint8Array(coefficientCount);

      var bitsDecoded = new Uint8Array(coefficientCount);
      if (zeroBitPlanes !== 0) {
        for (var i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }
      this.bitsDecoded = bitsDecoded;

      this.reset();
    }

    BitModel.prototype = {
      setDecoder: function BitModel_setDecoder(decoder) {
        this.decoder = decoder;
      },
      reset: function BitModel_reset() {
        // We have 17 contexts that are accessed via context labels,
        // plus the uniform and runlength context.
        this.contexts = new Int8Array(19);

        // Contexts are packed into 1 byte:
        // highest 7 bits carry the index, lowest bit carries mps
        this.contexts[0] = (4 << 1) | 0;
        this.contexts[UNIFORM_CONTEXT] = (46 << 1) | 0;
        this.contexts[RUNLENGTH_CONTEXT] = (3 << 1) | 0;
      },
      setNeighborsSignificance:
        function BitModel_setNeighborsSignificance(row, column, index) {
        var neighborsSignificance = this.neighborsSignificance;
        var width = this.width, height = this.height;
        var left = (column > 0);
        var right = (column + 1 < width);
        var i;

        if (row > 0) {
          i = index - width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (row + 1 < height) {
          i = index + width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (left) {
          neighborsSignificance[index - 1] += 0x01;
        }
        if (right) {
          neighborsSignificance[index + 1] += 0x01;
        }
        neighborsSignificance[index] |= 0x80;
      },
      runSignificancePropogationPass:
        function BitModel_runSignificancePropogationPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var neighborsSignificance = this.neighborsSignificance;
        var processingFlags = this.processingFlags;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processedInverseMask = ~1;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;

        for (var i0 = 0; i0 < height; i0 += 4) {
          for (var j = 0; j < width; j++) {
            var index = i0 * width + j;
            for (var i1 = 0; i1 < 4; i1++, index += width) {
              var i = i0 + i1;
              if (i >= height) {
                break;
              }
              // clear processed flag first
              processingFlags[index] &= processedInverseMask;

              if (coefficentsMagnitude[index] ||
                  !neighborsSignificance[index]) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision) {
                var sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contribution, sign0, sign1, significance1;
        var contextLabel, decoded;

        // calculate horizontal contribution
        significance1 = (column > 0 && coefficentsMagnitude[index - 1] !== 0);
        if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
          sign1 = coefficentsSign[index + 1];
          if (significance1) {
            sign0 = coefficentsSign[index - 1];
            contribution = 1 - sign1 - sign0;
          } else {
            contribution = 1 - sign1 - sign1;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign0 - sign0;
        } else {
          contribution = 0;
        }
        var horizontalContribution = 3 * contribution;

        // calculate vertical contribution and combine with the horizontal
        significance1 = (row > 0 && coefficentsMagnitude[index - width] !== 0);
        if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
          sign1 = coefficentsSign[index + width];
          if (significance1) {
            sign0 = coefficentsSign[index - width];
            contribution = 1 - sign1 - sign0 + horizontalContribution;
          } else {
            contribution = 1 - sign1 - sign1 + horizontalContribution;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign0 - sign0 + horizontalContribution;
        } else {
          contribution = horizontalContribution;
        }

        if (contribution >= 0) {
          contextLabel = 9 + contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel);
        } else {
          contextLabel = 9 - contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
        }
        return decoded;
      },
      runMagnitudeRefinementPass:
        function BitModel_runMagnitudeRefinementPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var neighborsSignificance = this.neighborsSignificance;
        var contexts = this.contexts;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var length = width * height;
        var width4 = width * 4;

        for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
          indexNext = Math.min(length, index0 + width4);
          for (var j = 0; j < width; j++) {
            for (var index = index0 + j; index < indexNext; index += width) {

              // significant but not those that have just become
              if (!coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = 16;
              if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                processingFlags[index] ^= firstMagnitudeBitMask;
                // first refinement
               var significance = neighborsSignificance[index] & 127;
               contextLabel = significance === 0 ? 15 : 14;
              }

              var bit = decoder.readBit(contexts, contextLabel);
              coefficentsMagnitude[index] =
                (coefficentsMagnitude[index] << 1) | bit;
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      runCleanupPass: function BitModel_runCleanupPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var neighborsSignificance = this.neighborsSignificance;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var oneRowDown = width;
        var twoRowsDown = width * 2;
        var threeRowsDown = width * 3;
        var iNext;
        for (var i0 = 0; i0 < height; i0 = iNext) {
          iNext = Math.min(i0 + 4, height);
          var indexBase = i0 * width;
          var checkAllEmpty = i0 + 3 < height;
          for (var j = 0; j < width; j++) {
            var index0 = indexBase + j;
            // using the property: labels[neighborsSignificance[index]] === 0
            // when neighborsSignificance[index] === 0
            var allEmpty = (checkAllEmpty &&
              processingFlags[index0] === 0 &&
              processingFlags[index0 + oneRowDown] === 0 &&
              processingFlags[index0 + twoRowsDown] === 0 &&
              processingFlags[index0 + threeRowsDown] === 0 &&
              neighborsSignificance[index0] === 0 &&
              neighborsSignificance[index0 + oneRowDown] === 0 &&
              neighborsSignificance[index0 + twoRowsDown] === 0 &&
              neighborsSignificance[index0 + threeRowsDown] === 0);
            var i1 = 0, index = index0;
            var i = i0, sign;
            if (allEmpty) {
              var hasSignificantCoefficent =
                decoder.readBit(contexts, RUNLENGTH_CONTEXT);
              if (!hasSignificantCoefficent) {
                bitsDecoded[index0]++;
                bitsDecoded[index0 + oneRowDown]++;
                bitsDecoded[index0 + twoRowsDown]++;
                bitsDecoded[index0 + threeRowsDown]++;
                continue; // next column
              }
              i1 = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                    decoder.readBit(contexts, UNIFORM_CONTEXT);
              if (i1 !== 0) {
                i = i0 + i1;
                index += i1 * width;
              }

              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;

              index = index0;
              for (var i2 = i0; i2 <= i; i2++, index += width) {
                bitsDecoded[index]++;
              }

              i1++;
            }
            for (i = i0 + i1; i < iNext; i++, index += width) {
              if (coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision === 1) {
                sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
            }
          }
        }
      },
      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
        var decoder = this.decoder;
        var contexts = this.contexts;
        var symbol = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 3) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 2) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                      decoder.readBit(contexts, UNIFORM_CONTEXT);
        if (symbol !== 0xA) {
          throw new Error('JPX Error: Invalid segmentation symbol');
        }
      }
    };

    return BitModel;
  })();

  // Section F, Discrete wavelet transformation
  var Transform = (function TransformClosure() {
    function Transform() {}

    Transform.prototype.calculate =
      function transformCalculate(subbands, u0, v0) {
      var ll = subbands[0];
      for (var i = 1, ii = subbands.length; i < ii; i++) {
        ll = this.iterate(ll, subbands[i], u0, v0);
      }
      return ll;
    };
    Transform.prototype.extend = function extend(buffer, offset, size) {
      // Section F.3.7 extending... using max extension of 4
      var i1 = offset - 1, j1 = offset + 1;
      var i2 = offset + size - 2, j2 = offset + size;
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1] = buffer[j1];
      buffer[j2] = buffer[i2];
    };
    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh,
                                                             u0, v0) {
      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;
      var width = hl_lh_hh.width;
      var height = hl_lh_hh.height;
      var items = hl_lh_hh.items;
      var i, j, k, l, u, v;

      // Interleave LL according to Section F.3.3
      for (k = 0, i = 0; i < llHeight; i++) {
        l = i * 2 * width;
        for (j = 0; j < llWidth; j++, k++, l += 2) {
          items[l] = llItems[k];
        }
      }
      // The LL band is not needed anymore.
      llItems = ll.items = null;

      var bufferPadding = 4;
      var rowBuffer = new Float32Array(width + 2 * bufferPadding);

      // Section F.3.4 HOR_SR
      if (width === 1) {
        // if width = 1, when u0 even keep items as is, when odd divide by 2
        if ((u0 & 1) !== 0) {
          for (v = 0, k = 0; v < height; v++, k += width) {
            items[k] *= 0.5;
          }
        }
      } else {
        for (v = 0, k = 0; v < height; v++, k += width) {
          rowBuffer.set(items.subarray(k, k + width), bufferPadding);

          this.extend(rowBuffer, bufferPadding, width);
          this.filter(rowBuffer, bufferPadding, width);

          items.set(
            rowBuffer.subarray(bufferPadding, bufferPadding + width),
            k);
        }
      }

      // Accesses to the items array can take long, because it may not fit into
      // CPU cache and has to be fetched from main memory. Since subsequent
      // accesses to the items array are not local when reading columns, we
      // have a cache miss every time. To reduce cache misses, get up to
      // 'numBuffers' items at a time and store them into the individual
      // buffers. The colBuffers should be small enough to fit into CPU cache.
      var numBuffers = 16;
      var colBuffers = [];
      for (i = 0; i < numBuffers; i++) {
        colBuffers.push(new Float32Array(height + 2 * bufferPadding));
      }
      var b, currentBuffer = 0;
      ll = bufferPadding + height;

      // Section F.3.5 VER_SR
      if (height === 1) {
          // if height = 1, when v0 even keep items as is, when odd divide by 2
        if ((v0 & 1) !== 0) {
          for (u = 0; u < width; u++) {
            items[u] *= 0.5;
          }
        }
      } else {
        for (u = 0; u < width; u++) {
          // if we ran out of buffers, copy several image columns at once
          if (currentBuffer === 0) {
            numBuffers = Math.min(width - u, numBuffers);
            for (k = u, l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                colBuffers[b][l] = items[k + b];
              }
            }
            currentBuffer = numBuffers;
          }

          currentBuffer--;
          var buffer = colBuffers[currentBuffer];
          this.extend(buffer, bufferPadding, height);
          this.filter(buffer, bufferPadding, height);

          // If this is last buffer in this group of buffers, flush all buffers.
          if (currentBuffer === 0) {
            k = u - numBuffers + 1;
            for (l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                items[k + b] = colBuffers[b][l];
              }
            }
          }
        }
      }

      return {
        width: width,
        height: height,
        items: items
      };
    };
    return Transform;
  })();

  // Section 3.8.2 Irreversible 9-7 filter
  var IrreversibleTransform = (function IrreversibleTransformClosure() {
    function IrreversibleTransform() {
      Transform.call(this);
    }

    IrreversibleTransform.prototype = Object.create(Transform.prototype);
    IrreversibleTransform.prototype.filter =
      function irreversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n, current, next;

      var alpha = -1.586134342059924;
      var beta = -0.052980118572961;
      var gamma = 0.882911075530934;
      var delta = 0.443506852043971;
      var K = 1.230174104914001;
      var K_ = 1 / K;

      // step 1 is combined with step 3

      // step 2
      j = offset - 3;
      for (n = len + 4; n--; j += 2) {
        x[j] *= K_;
      }

      // step 1 & 3
      j = offset - 2;
      current = delta * x[j -1];
      for (n = len + 3; n--; j += 2) {
        next = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
        if (n--) {
          j += 2;
          current = delta * x[j + 1];
          x[j] = K * x[j] - current - next;
        } else {
          break;
        }
      }

      // step 4
      j = offset - 1;
      current = gamma * x[j - 1];
      for (n = len + 2; n--; j += 2) {
        next = gamma * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = gamma * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 5
      j = offset;
      current = beta * x[j - 1];
      for (n = len + 1; n--; j += 2) {
        next = beta * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = beta * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 6
      if (len !== 0) {
        j = offset + 1;
        current = alpha * x[j - 1];
        for (n = len; n--; j += 2) {
          next = alpha * x[j + 1];
          x[j] -= current + next;
          if (n--) {
            j += 2;
            current = alpha * x[j + 1];
            x[j] -= current + next;
          } else {
            break;
          }
        }
      }
    };

    return IrreversibleTransform;
  })();

  // Section 3.8.1 Reversible 5-3 filter
  var ReversibleTransform = (function ReversibleTransformClosure() {
    function ReversibleTransform() {
      Transform.call(this);
    }

    ReversibleTransform.prototype = Object.create(Transform.prototype);
    ReversibleTransform.prototype.filter =
      function reversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n;

      for (j = offset, n = len + 1; n--; j += 2) {
        x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;
      }

      for (j = offset + 1, n = len; n--; j += 2) {
        x[j] += (x[j - 1] + x[j + 1]) >> 1;
      }
    };

    return ReversibleTransform;
  })();

  return JpxImage;
})();


/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

/* This class implements the QM Coder decoding as defined in
 *   JPEG 2000 Part I Final Committee Draft Version 1.0
 *   Annex C.3 Arithmetic decoding procedure 
 * available at http://www.jpeg.org/public/fcd15444-1.pdf
 * 
 * The arithmetic decoder is used in conjunction with context models to decode
 * JPEG2000 and JBIG2 streams.
 */
var ArithmeticDecoder = (function ArithmeticDecoderClosure() {
  // Table C-2
  var QeTable = [
    {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},
    {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},
    {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},
    {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},
    {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},
    {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},
    {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},
    {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},
    {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},
    {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},
    {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},
    {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},
    {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},
    {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},
    {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},
    {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},
    {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},
    {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},
    {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},
    {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},
    {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},
    {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},
    {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},
    {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},
    {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},
    {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},
    {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},
    {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},
    {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},
    {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},
    {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},
    {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},
    {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},
    {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},
    {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},
    {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},
    {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},
    {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},
    {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},
    {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},
    {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},
    {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},
    {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},
    {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},
    {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},
    {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},
    {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}
  ];

  // C.3.5 Initialisation of the decoder (INITDEC)
  function ArithmeticDecoder(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;

    this.chigh = data[start];
    this.clow = 0;

    this.byteIn();

    this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);
    this.clow = (this.clow << 7) & 0xFFFF;
    this.ct -= 7;
    this.a = 0x8000;
  }

  ArithmeticDecoder.prototype = {
    // C.3.4 Compressed data input (BYTEIN)
    byteIn: function ArithmeticDecoder_byteIn() {
      var data = this.data;
      var bp = this.bp;
      if (data[bp] === 0xFF) {
        var b1 = data[bp + 1];
        if (b1 > 0x8F) {
          this.clow += 0xFF00;
          this.ct = 8;
        } else {
          bp++;
          this.clow += (data[bp] << 9);
          this.ct = 7;
          this.bp = bp;
        }
      } else {
        bp++;
        this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;
        this.ct = 8;
        this.bp = bp;
      }
      if (this.clow > 0xFFFF) {
        this.chigh += (this.clow >> 16);
        this.clow &= 0xFFFF;
      }
    },
    // C.3.2 Decoding a decision (DECODE)
    readBit: function ArithmeticDecoder_readBit(contexts, pos) {
      // contexts are packed into 1 byte:
      // highest 7 bits carry cx.index, lowest bit carries cx.mps
      var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
      var qeTableIcx = QeTable[cx_index];
      var qeIcx = qeTableIcx.qe;
      var d;
      var a = this.a - qeIcx;

      if (this.chigh < qeIcx) {
        // exchangeLps
        if (a < qeIcx) {
          a = qeIcx;
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        } else {
          a = qeIcx;
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        }
      } else {
        this.chigh -= qeIcx;
        if ((a & 0x8000) !== 0) {
          this.a = a;
          return cx_mps;
        }
        // exchangeMps
        if (a < qeIcx) {
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        } else {
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        }
      }
      // C.3.3 renormD;
      do {
        if (this.ct === 0) {
          this.byteIn();
        }

        a <<= 1;
        this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);
        this.clow = (this.clow << 1) & 0xFFFF;
        this.ct--;
      } while ((a & 0x8000) === 0);
      this.a = a;

      contexts[pos] = cx_index << 1 | cx_mps;
      return d;
    }
  };

  return ArithmeticDecoder;
})();

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals Cmd, ColorSpace, Dict, MozBlobBuilder, Name, PDFJS, Ref, URL,
           Promise */

'use strict';

var globalScope = (typeof window === 'undefined') ? this : window;

var isWorker = (typeof window === 'undefined');

var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];

var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};

var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};

var AnnotationType = {
  WIDGET: 1,
  TEXT: 2,
  LINK: 3
};

var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};

var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};

// The global PDFJS object exposes the API
// In production, it will be declared outside a global wrapper
// In development, it will be declared here
if (!globalScope.PDFJS) {
  globalScope.PDFJS = {};
}

globalScope.PDFJS.pdfBug = false;

PDFJS.VERBOSITY_LEVELS = {
  errors: 0,
  warnings: 1,
  infos: 5
};

// All the possible operations for an operator list.
var OPS = PDFJS.OPS = {
  // Intentionally start from 1 so it is easy to spot bad operators that will be
  // 0's.
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};

// A notice for devs. These are good for things that are helpful to devs, such
// as warning that Workers were disabled, which is important to devs but not
// end users.
function info(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {
    console.log('Info: ' + msg);
  }
}

// Non-fatal warnings.
function warn(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {
    console.log('Warning: ' + msg);
  }
}

// Fatal errors that should trigger the fallback UI and halt execution by
// throwing an exception.
function error(msg) {
  // If multiple arguments were passed, pass them all to the log function.
  if (arguments.length > 1) {
    var logArguments = ['Error:'];
    logArguments.push.apply(logArguments, arguments);
    console.log.apply(console, logArguments);
    // Join the arguments into a single string for the lines below.
    msg = [].join.call(arguments, ' ');
  } else {
    console.log('Error: ' + msg);
  }
  console.log(backtrace());
  UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown);
  throw new Error(msg);
}

function backtrace() {
  try {
    throw new Error();
  } catch (e) {
    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
  }
}

function assert(cond, msg) {
  if (!cond) {
    error(msg);
  }
}

var UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};

var UnsupportedManager = PDFJS.UnsupportedManager =
  (function UnsupportedManagerClosure() {
  var listeners = [];
  return {
    listen: function (cb) {
      listeners.push(cb);
    },
    notify: function (featureId) {
      warn('Unsupported feature "' + featureId + '"');
      for (var i = 0, ii = listeners.length; i < ii; i++) {
        listeners[i](featureId);
      }
    }
  };
})();

// Combines two URLs. The baseUrl shall be absolute URL. If the url is an
// absolute URL, it will be returned as is.
function combineUrl(baseUrl, url) {
  if (!url) {
    return baseUrl;
  }
  if (/^[a-z][a-z0-9+\-.]*:/i.test(url)) {
    return url;
  }
  var i;
  if (url.charAt(0) === '/') {
    // absolute path
    i = baseUrl.indexOf('://');
    if (url.charAt(1) === '/') {
      ++i;
    } else {
      i = baseUrl.indexOf('/', i + 3);
    }
    return baseUrl.substring(0, i) + url;
  } else {
    // relative path
    var pathLength = baseUrl.length;
    i = baseUrl.lastIndexOf('#');
    pathLength = i >= 0 ? i : pathLength;
    i = baseUrl.lastIndexOf('?', pathLength);
    pathLength = i >= 0 ? i : pathLength;
    var prefixLength = baseUrl.lastIndexOf('/', pathLength);
    return baseUrl.substring(0, prefixLength + 1) + url;
  }
}

// Validates if URL is safe and allowed, e.g. to avoid XSS.
function isValidUrl(url, allowRelative) {
  if (!url) {
    return false;
  }
  // RFC 3986 (http://tools.ietf.org/html/rfc3986#section-3.1)
  // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
  var protocol = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(url);
  if (!protocol) {
    return allowRelative;
  }
  protocol = protocol[0].toLowerCase();
  switch (protocol) {
    case 'http':
    case 'https':
    case 'ftp':
    case 'mailto':
    case 'tel':
      return true;
    default:
      return false;
  }
}
PDFJS.isValidUrl = isValidUrl;

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, { value: value,
                                     enumerable: true,
                                     configurable: true,
                                     writable: false });
  return value;
}
PDFJS.shadow = shadow;

var PasswordResponses = PDFJS.PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};

var PasswordException = (function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }

  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;

  return PasswordException;
})();
PDFJS.PasswordException = PasswordException;

var UnknownErrorException = (function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }

  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;

  return UnknownErrorException;
})();
PDFJS.UnknownErrorException = UnknownErrorException;

var InvalidPDFException = (function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }

  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;

  return InvalidPDFException;
})();
PDFJS.InvalidPDFException = InvalidPDFException;

var MissingPDFException = (function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }

  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;

  return MissingPDFException;
})();
PDFJS.MissingPDFException = MissingPDFException;

var UnexpectedResponseException =
    (function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }

  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;

  return UnexpectedResponseException;
})();
PDFJS.UnexpectedResponseException = UnexpectedResponseException;

var NotImplementedException = (function NotImplementedExceptionClosure() {
  function NotImplementedException(msg) {
    this.message = msg;
  }

  NotImplementedException.prototype = new Error();
  NotImplementedException.prototype.name = 'NotImplementedException';
  NotImplementedException.constructor = NotImplementedException;

  return NotImplementedException;
})();

var MissingDataException = (function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }

  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;

  return MissingDataException;
})();

var XRefParseException = (function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }

  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;

  return XRefParseException;
})();


function bytesToString(bytes) {
  assert(bytes !== null && typeof bytes === 'object' &&
         bytes.length !== undefined, 'Invalid argument for bytesToString');
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  var strBuf = [];
  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join('');
}

function stringToBytes(str) {
  assert(typeof str === 'string', 'Invalid argument for stringToBytes');
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}

function string32(value) {
  return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff,
                             (value >> 8) & 0xff, value & 0xff);
}

function log2(x) {
  var n = 1, i = 0;
  while (x > n) {
    n <<= 1;
    i++;
  }
  return i;
}

function readInt8(data, start) {
  return (data[start] << 24) >> 24;
}

function readUint16(data, offset) {
  return (data[offset] << 8) | data[offset + 1];
}

function readUint32(data, offset) {
  return ((data[offset] << 24) | (data[offset + 1] << 16) |
         (data[offset + 2] << 8) | data[offset + 3]) >>> 0;
}

// Lazy test the endianness of the platform
// NOTE: This will be 'true' for simulated TypedArrays
function isLittleEndian() {
  var buffer8 = new Uint8Array(2);
  buffer8[0] = 1;
  var buffer16 = new Uint16Array(buffer8.buffer);
  return (buffer16[0] === 1);
}

Object.defineProperty(PDFJS, 'isLittleEndian', {
  configurable: true,
  get: function PDFJS_isLittleEndian() {
    return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
  }
});

//#if !(FIREFOX || MOZCENTRAL || B2G || CHROME)
//// Lazy test if the userAgant support CanvasTypedArrays
function hasCanvasTypedArrays() {
  var canvas = document.createElement('canvas');
  canvas.width = canvas.height = 1;
  var ctx = canvas.getContext('2d');
  var imageData = ctx.createImageData(1, 1);
  return (typeof imageData.data.buffer !== 'undefined');
}

Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {
  configurable: true,
  get: function PDFJS_hasCanvasTypedArrays() {
    return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());
  }
});

var Uint32ArrayView = (function Uint32ArrayViewClosure() {

  function Uint32ArrayView(buffer, length) {
    this.buffer = buffer;
    this.byteLength = buffer.length;
    this.length = length === undefined ? (this.byteLength >> 2) : length;
    ensureUint32ArrayViewProps(this.length);
  }
  Uint32ArrayView.prototype = Object.create(null);

  var uint32ArrayViewSetters = 0;
  function createUint32ArrayProp(index) {
    return {
      get: function () {
        var buffer = this.buffer, offset = index << 2;
        return (buffer[offset] | (buffer[offset + 1] << 8) |
          (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;
      },
      set: function (value) {
        var buffer = this.buffer, offset = index << 2;
        buffer[offset] = value & 255;
        buffer[offset + 1] = (value >> 8) & 255;
        buffer[offset + 2] = (value >> 16) & 255;
        buffer[offset + 3] = (value >>> 24) & 255;
      }
    };
  }

  function ensureUint32ArrayViewProps(length) {
    while (uint32ArrayViewSetters < length) {
      Object.defineProperty(Uint32ArrayView.prototype,
        uint32ArrayViewSetters,
        createUint32ArrayProp(uint32ArrayViewSetters));
      uint32ArrayViewSetters++;
    }
  }

  return Uint32ArrayView;
})();
//#else
//PDFJS.hasCanvasTypedArrays = true;
//#endif

var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];

var Util = PDFJS.Util = (function UtilClosure() {
  function Util() {}

  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];

  // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids
  // creating many intermediate strings.
  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };

  // Concatenates two transformation matrices together and returns the result.
  Util.transform = function Util_transform(m1, m2) {
    return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
    ];
  };

  // For 2d affine transforms
  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };

  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };

  // Applies the transform to the rectangle and finds the minimum axially
  // aligned bounding box.
  Util.getAxialAlignedBoundingBox =
    function Util_getAxialAlignedBoundingBox(r, m) {

    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [
      Math.min(p1[0], p2[0], p3[0], p4[0]),
      Math.min(p1[1], p2[1], p3[1], p4[1]),
      Math.max(p1[0], p2[0], p3[0], p4[0]),
      Math.max(p1[1], p2[1], p3[1], p4[1])
    ];
  };

  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d,
      (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };

  // Apply a generic 3d matrix M on a 3-vector v:
  //   | a b c |   | X |
  //   | d e f | x | Y |
  //   | g h i |   | Z |
  // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],
  // with v as [X,Y,Z]
  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [
      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
      m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
    ];
  };

  // This calculation uses Singular Value Decomposition.
  // The SVD can be represented with formula A = USV. We are interested in the
  // matrix S here because it represents the scale values.
  Util.singularValueDecompose2dScale =
    function Util_singularValueDecompose2dScale(m) {

    var transpose = [m[0], m[2], m[1], m[3]];

    // Multiply matrix m with its transpose.
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];

    // Solve the second degree polynomial to get roots.
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;

    // Scale values are the square roots of the eigenvalues.
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };

  // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)
  // For coordinate systems whose origin lies in the bottom-left, this
  // means normalization to (BL,TR) ordering. For systems with origin in the
  // top-left, this means (TL,BR) ordering.
  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0); // clone rect
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  };

  // Returns a rectangle [x1, y1, x2, y2] corresponding to the
  // intersection of rect1 and rect2. If no intersection, returns 'false'
  // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]
  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    // Order points along the axes
    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];

    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    // X: first and second points belong to different rectangles?
    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) ||
        (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {
      // Intersection must be between second and third points
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }

    // Y: first and second points belong to different rectangles?
    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) ||
        (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {
      // Intersection must be between second and third points
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }

    return result;
  };

  Util.sign = function Util_sign(num) {
    return num < 0 ? -1 : 1;
  };

  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };

  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };

  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };

  Util.getInheritableProperty = function Util_getInheritableProperty(dict,
                                                                     name) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }
    if (!dict) {
      return null;
    }
    return dict.get(name);
  };

  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };

  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);
    if (callback) {
      script.onload = function() {
        if (!loaded) {
          callback();
        }
        loaded = true;
      };
    }
    document.getElementsByTagName('head')[0].appendChild(script);
  };

  return Util;
})();

/**
 * PDF page viewport created based on scale, rotation and offset.
 * @class
 * @alias PDFJS.PageViewport
 */
var PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {
  /**
   * @constructor
   * @private
   * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.
   * @param scale {number} scale of the viewport.
   * @param rotation {number} rotations of the viewport in degrees.
   * @param offsetX {number} offset X
   * @param offsetY {number} offset Y
   * @param dontFlip {boolean} if true, axis Y will not be flipped.
   */
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;

    // creating transform to convert pdf coordinate system to the normal
    // canvas like coordinates taking in account scale and rotation
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;
    switch (rotation) {
      case 180:
        rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1;
        break;
      case 90:
        rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0;
        break;
      case 270:
        rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0;
        break;
      //case 0:
      default:
        rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1;
        break;
    }

    if (dontFlip) {
      rotateC = -rotateC; rotateD = -rotateD;
    }

    var offsetCanvasX, offsetCanvasY;
    var width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }
    // creating transform for the following operations:
    // translate(-centerX, -centerY), rotate and flip vertically,
    // scale, and translate(offsetCanvasX, offsetCanvasY)
    this.transform = [
      rotateA * scale,
      rotateB * scale,
      rotateC * scale,
      rotateD * scale,
      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,
      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY
    ];

    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }
  PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {
    /**
     * Clones viewport with additional properties.
     * @param args {Object} (optional) If specified, may contain the 'scale' or
     * 'rotation' properties to override the corresponding properties in
     * the cloned viewport.
     * @returns {PDFJS.PageViewport} Cloned viewport.
     */
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation,
                              this.offsetX, this.offsetY, args.dontFlip);
    },
    /**
     * Converts PDF point to the viewport coordinates. For examples, useful for
     * converting PDF location into canvas pixel coordinates.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the viewport coordinate space.
     * @see {@link convertToPdfPoint}
     * @see {@link convertToViewportRectangle}
     */
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    /**
     * Converts PDF rectangle to the viewport coordinates.
     * @param rect {Array} xMin, yMin, xMax and yMax coordinates.
     * @returns {Array} Contains corresponding coordinates of the rectangle
     * in the viewport coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToViewportRectangle:
      function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    /**
     * Converts viewport coordinates to the PDF location. For examples, useful
     * for converting canvas pixel location into PDF one.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the PDF coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
})();

var PDFStringTranslateTable = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014,
  0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C,
  0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160,
  0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC
];

function stringToPDFString(str) {
  var i, n = str.length, strBuf = [];
  if (str[0] === '\xFE' && str[1] === '\xFF') {
    // UTF16BE BOM
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(
        (str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }
  return strBuf.join('');
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

function isBool(v) {
  return typeof v === 'boolean';
}

function isInt(v) {
  return typeof v === 'number' && ((v | 0) === v);
}

function isNum(v) {
  return typeof v === 'number';
}

function isString(v) {
  return typeof v === 'string';
}

function isNull(v) {
  return v === null;
}

function isName(v) {
  return v instanceof Name;
}

function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}

function isDict(v, type) {
  if (!(v instanceof Dict)) {
    return false;
  }
  if (!type) {
    return true;
  }
  var dictType = v.get('Type');
  return isName(dictType) && dictType.name === type;
}

function isArray(v) {
  return v instanceof Array;
}

function isStream(v) {
  return typeof v === 'object' && v !== null && v.getBytes !== undefined;
}

function isArrayBuffer(v) {
  return typeof v === 'object' && v !== null && v.byteLength !== undefined;
}

function isRef(v) {
  return v instanceof Ref;
}

/**
 * Promise Capability object.
 *
 * @typedef {Object} PromiseCapability
 * @property {Promise} promise - A promise object.
 * @property {function} resolve - Fullfills the promise.
 * @property {function} reject - Rejects the promise.
 */

/**
 * Creates a promise capability object.
 * @alias PDFJS.createPromiseCapability
 *
 * @return {PromiseCapability} A capability object contains:
 * - a Promise, resolve and reject methods.
 */
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}

PDFJS.createPromiseCapability = createPromiseCapability;

/**
 * Polyfill for Promises:
 * The following promise implementation tries to generally implement the
 * Promise/A+ spec. Some notable differences from other promise libaries are:
 * - There currently isn't a seperate deferred and promise object.
 * - Unhandled rejections eventually show an error if they aren't handled.
 *
 * Based off of the work in:
 * https://bugzilla.mozilla.org/show_bug.cgi?id=810490
 */
(function PromiseClosure() {
  if (globalScope.Promise) {
    // Promises existing in the DOM/Worker, checking presence of all/resolve
    if (typeof globalScope.Promise.all !== 'function') {
      globalScope.Promise.all = function (iterable) {
        var count = 0, results = [], resolve, reject;
        var promise = new globalScope.Promise(function (resolve_, reject_) {
          resolve = resolve_;
          reject = reject_;
        });
        iterable.forEach(function (p, i) {
          count++;
          p.then(function (result) {
            results[i] = result;
            count--;
            if (count === 0) {
              resolve(results);
            }
          }, reject);
        });
        if (count === 0) {
          resolve(results);
        }
        return promise;
      };
    }
    if (typeof globalScope.Promise.resolve !== 'function') {
      globalScope.Promise.resolve = function (value) {
        return new globalScope.Promise(function (resolve) { resolve(value); });
      };
    }
    if (typeof globalScope.Promise.reject !== 'function') {
      globalScope.Promise.reject = function (reason) {
        return new globalScope.Promise(function (resolve, reject) {
          reject(reason);
        });
      };
    }
    if (typeof globalScope.Promise.prototype.catch !== 'function') {
      globalScope.Promise.prototype.catch = function (onReject) {
        return globalScope.Promise.prototype.then(undefined, onReject);
      };
    }
    return;
  }
//#if !MOZCENTRAL
  var STATUS_PENDING = 0;
  var STATUS_RESOLVED = 1;
  var STATUS_REJECTED = 2;

  // In an attempt to avoid silent exceptions, unhandled rejections are
  // tracked and if they aren't handled in a certain amount of time an
  // error is logged.
  var REJECTION_TIMEOUT = 500;

  var HandlerManager = {
    handlers: [],
    running: false,
    unhandledRejections: [],
    pendingRejectionCheck: false,

    scheduleHandlers: function scheduleHandlers(promise) {
      if (promise._status === STATUS_PENDING) {
        return;
      }

      this.handlers = this.handlers.concat(promise._handlers);
      promise._handlers = [];

      if (this.running) {
        return;
      }
      this.running = true;

      setTimeout(this.runHandlers.bind(this), 0);
    },

    runHandlers: function runHandlers() {
      var RUN_TIMEOUT = 1; // ms
      var timeoutAt = Date.now() + RUN_TIMEOUT;
      while (this.handlers.length > 0) {
        var handler = this.handlers.shift();

        var nextStatus = handler.thisPromise._status;
        var nextValue = handler.thisPromise._value;

        try {
          if (nextStatus === STATUS_RESOLVED) {
            if (typeof handler.onResolve === 'function') {
              nextValue = handler.onResolve(nextValue);
            }
          } else if (typeof handler.onReject === 'function') {
              nextValue = handler.onReject(nextValue);
              nextStatus = STATUS_RESOLVED;

              if (handler.thisPromise._unhandledRejection) {
                this.removeUnhandeledRejection(handler.thisPromise);
              }
          }
        } catch (ex) {
          nextStatus = STATUS_REJECTED;
          nextValue = ex;
        }

        handler.nextPromise._updateStatus(nextStatus, nextValue);
        if (Date.now() >= timeoutAt) {
          break;
        }
      }

      if (this.handlers.length > 0) {
        setTimeout(this.runHandlers.bind(this), 0);
        return;
      }

      this.running = false;
    },

    addUnhandledRejection: function addUnhandledRejection(promise) {
      this.unhandledRejections.push({
        promise: promise,
        time: Date.now()
      });
      this.scheduleRejectionCheck();
    },

    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
      promise._unhandledRejection = false;
      for (var i = 0; i < this.unhandledRejections.length; i++) {
        if (this.unhandledRejections[i].promise === promise) {
          this.unhandledRejections.splice(i);
          i--;
        }
      }
    },

    scheduleRejectionCheck: function scheduleRejectionCheck() {
      if (this.pendingRejectionCheck) {
        return;
      }
      this.pendingRejectionCheck = true;
      setTimeout(function rejectionCheck() {
        this.pendingRejectionCheck = false;
        var now = Date.now();
        for (var i = 0; i < this.unhandledRejections.length; i++) {
          if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
            var unhandled = this.unhandledRejections[i].promise._value;
            var msg = 'Unhandled rejection: ' + unhandled;
            if (unhandled.stack) {
              msg += '\n' + unhandled.stack;
            }
            warn(msg);
            this.unhandledRejections.splice(i);
            i--;
          }
        }
        if (this.unhandledRejections.length) {
          this.scheduleRejectionCheck();
        }
      }.bind(this), REJECTION_TIMEOUT);
    }
  };

  function Promise(resolver) {
    this._status = STATUS_PENDING;
    this._handlers = [];
    try {
      resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
    } catch (e) {
      this._reject(e);
    }
  }
  /**
   * Builds a promise that is resolved when all the passed in promises are
   * resolved.
   * @param {array} array of data and/or promises to wait for.
   * @return {Promise} New dependant promise.
   */
  Promise.all = function Promise_all(promises) {
    var resolveAll, rejectAll;
    var deferred = new Promise(function (resolve, reject) {
      resolveAll = resolve;
      rejectAll = reject;
    });
    var unresolved = promises.length;
    var results = [];
    if (unresolved === 0) {
      resolveAll(results);
      return deferred;
    }
    function reject(reason) {
      if (deferred._status === STATUS_REJECTED) {
        return;
      }
      results = [];
      rejectAll(reason);
    }
    for (var i = 0, ii = promises.length; i < ii; ++i) {
      var promise = promises[i];
      var resolve = (function(i) {
        return function(value) {
          if (deferred._status === STATUS_REJECTED) {
            return;
          }
          results[i] = value;
          unresolved--;
          if (unresolved === 0) {
            resolveAll(results);
          }
        };
      })(i);
      if (Promise.isPromise(promise)) {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
    return deferred;
  };

  /**
   * Checks if the value is likely a promise (has a 'then' function).
   * @return {boolean} true if value is thenable
   */
  Promise.isPromise = function Promise_isPromise(value) {
    return value && typeof value.then === 'function';
  };

  /**
   * Creates resolved promise
   * @param value resolve value
   * @returns {Promise}
   */
  Promise.resolve = function Promise_resolve(value) {
    return new Promise(function (resolve) { resolve(value); });
  };

  /**
   * Creates rejected promise
   * @param reason rejection value
   * @returns {Promise}
   */
  Promise.reject = function Promise_reject(reason) {
    return new Promise(function (resolve, reject) { reject(reason); });
  };

  Promise.prototype = {
    _status: null,
    _value: null,
    _handlers: null,
    _unhandledRejection: null,

    _updateStatus: function Promise__updateStatus(status, value) {
      if (this._status === STATUS_RESOLVED ||
          this._status === STATUS_REJECTED) {
        return;
      }

      if (status === STATUS_RESOLVED &&
          Promise.isPromise(value)) {
        value.then(this._updateStatus.bind(this, STATUS_RESOLVED),
                   this._updateStatus.bind(this, STATUS_REJECTED));
        return;
      }

      this._status = status;
      this._value = value;

      if (status === STATUS_REJECTED && this._handlers.length === 0) {
        this._unhandledRejection = true;
        HandlerManager.addUnhandledRejection(this);
      }

      HandlerManager.scheduleHandlers(this);
    },

    _resolve: function Promise_resolve(value) {
      this._updateStatus(STATUS_RESOLVED, value);
    },

    _reject: function Promise_reject(reason) {
      this._updateStatus(STATUS_REJECTED, reason);
    },

    then: function Promise_then(onResolve, onReject) {
      var nextPromise = new Promise(function (resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
      });
      this._handlers.push({
        thisPromise: this,
        onResolve: onResolve,
        onReject: onReject,
        nextPromise: nextPromise
      });
      HandlerManager.scheduleHandlers(this);
      return nextPromise;
    },

    catch: function Promise_catch(onReject) {
      return this.then(undefined, onReject);
    }
  };

  globalScope.Promise = Promise;
//#else
//throw new Error('DOM Promise is not present');
//#endif
})();

var StatTimer = (function StatTimerClosure() {
  function rpad(str, pad, length) {
    while (str.length < length) {
      str += pad;
    }
    return str;
  }
  function StatTimer() {
    this.started = {};
    this.times = [];
    this.enabled = true;
  }
  StatTimer.prototype = {
    time: function StatTimer_time(name) {
      if (!this.enabled) {
        return;
      }
      if (name in this.started) {
        warn('Timer is already running for ' + name);
      }
      this.started[name] = Date.now();
    },
    timeEnd: function StatTimer_timeEnd(name) {
      if (!this.enabled) {
        return;
      }
      if (!(name in this.started)) {
        warn('Timer has not been started for ' + name);
      }
      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      // Remove timer from started so it can be called again.
      delete this.started[name];
    },
    toString: function StatTimer_toString() {
      var i, ii;
      var times = this.times;
      var out = '';
      // Find the longest name for padding purposes.
      var longest = 0;
      for (i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];
        if (name.length > longest) {
          longest = name.length;
        }
      }
      for (i = 0, ii = times.length; i < ii; ++i) {
        var span = times[i];
        var duration = span.end - span.start;
        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
      }
      return out;
    }
  };
  return StatTimer;
})();

PDFJS.createBlob = function createBlob(data, contentType) {
  if (typeof Blob !== 'undefined') {
    return new Blob([data], { type: contentType });
  }
  // Blob builder is deprecated in FF14 and removed in FF18.
  var bb = new MozBlobBuilder();
  bb.append(data);
  return bb.getBlob(contentType);
};

PDFJS.createObjectURL = (function createObjectURLClosure() {
  // Blob/createObjectURL is not available, falling back to data schema.
  var digits =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  return function createObjectURL(data, contentType) {
    if (!PDFJS.disableCreateObjectURL &&
        typeof URL !== 'undefined' && URL.createObjectURL) {
      var blob = PDFJS.createBlob(data, contentType);
      return URL.createObjectURL(blob);
    }

    var buffer = 'data:' + contentType + ';base64,';
    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2, d2 = ((b1 & 3) << 4) | (b2 >> 4);
      var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;
      var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }
    return buffer;
  };
})();

function MessageHandler(name, comObj) {
  this.name = name;
  this.comObj = comObj;
  this.callbackIndex = 1;
  this.postMessageTransfers = true;
  var callbacksCapabilities = this.callbacksCapabilities = {};
  var ah = this.actionHandler = {};

  ah['console_log'] = [function ahConsoleLog(data) {
    console.log.apply(console, data);
  }];
  ah['console_error'] = [function ahConsoleError(data) {
    console.error.apply(console, data);
  }];
  ah['_unsupported_feature'] = [function ah_unsupportedFeature(data) {
    UnsupportedManager.notify(data);
  }];

  comObj.onmessage = function messageHandlerComObjOnMessage(event) {
    var data = event.data;
    if (data.isReply) {
      var callbackId = data.callbackId;
      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];
        if ('error' in data) {
          callback.reject(data.error);
        } else {
          callback.resolve(data.data);
        }
      } else {
        error('Cannot resolve callback ' + callbackId);
      }
    } else if (data.action in ah) {
      var action = ah[data.action];
      if (data.callbackId) {
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            error: reason
          });
        });
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      error('Unknown action from worker: ' + data.action);
    }
  };
}

MessageHandler.prototype = {
  on: function messageHandlerOn(actionName, handler, scope) {
    var ah = this.actionHandler;
    if (ah[actionName]) {
      error('There is already an actionName called "' + actionName + '"');
    }
    ah[actionName] = [handler, scope];
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers
   */
  send: function messageHandlerSend(actionName, data, transfers) {
    var message = {
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * Expects that other side will callback with the response.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.
   * @returns {Promise} Promise to be resolved with response data.
   */
  sendWithPromise:
    function messageHandlerSendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackIndex++;
    var message = {
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = createPromiseCapability();
    this.callbacksCapabilities[callbackId] = capability;
    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }
    return capability.promise;
  },
  /**
   * Sends raw message to the comObj.
   * @private
   * @param message {Object} Raw message.
   * @param transfers List of transfers/ArrayBuffers, or undefined.
   */
  postMessage: function (message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }
};

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = JpxImage;
}

function loadJpegStream(id, imageUrl, objs) {
  var img = new Image();
  img.onload = (function loadJpegStream_onloadClosure() {
    objs.resolve(id, img);
  });
  img.onerror = (function loadJpegStream_onerrorClosure() {
    objs.resolve(id, null);
    warn('Error during JPEG image loading');
  });
  img.src = imageUrl;
}
},{}],3:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":86}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){

},{}],6:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],7:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],8:[function(require,module,exports){
'use strict';


module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],9:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],10:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":6,"./adler32":7,"./crc32":9,"./messages":14,"./trees":15}],11:[function(require,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],12:[function(require,module,exports){
'use strict';


var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":6,"./adler32":7,"./crc32":9,"./inffast":11,"./inftrees":13}],13:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i = 0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":6}],14:[function(require,module,exports){
'use strict';

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],15:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":6}],16:[function(require,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],17:[function(require,module,exports){
(function (process,Buffer){
var msg = require('pako/lib/zlib/messages');
var zstream = require('pako/lib/zlib/zstream');
var zlib_deflate = require('pako/lib/zlib/deflate.js');
var zlib_inflate = require('pako/lib/zlib/inflate.js');
var constants = require('pako/lib/zlib/constants');

for (var key in constants) {
  exports[key] = constants[key];
}

// zlib modes
exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;

/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */
function Zlib(mode) {
  if (mode < exports.DEFLATE || mode > exports.UNZIP)
    throw new TypeError("Bad argument");
    
  this.mode = mode;
  this.init_done = false;
  this.write_in_progress = false;
  this.pending_close = false;
  this.windowBits = 0;
  this.level = 0;
  this.memLevel = 0;
  this.strategy = 0;
  this.dictionary = null;
}

Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
  this.windowBits = windowBits;
  this.level = level;
  this.memLevel = memLevel;
  this.strategy = strategy;
  // dictionary not supported.
  
  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
    this.windowBits += 16;
    
  if (this.mode === exports.UNZIP)
    this.windowBits += 32;
    
  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
    this.windowBits = -this.windowBits;
    
  this.strm = new zstream();
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateInit2(
        this.strm,
        this.level,
        exports.Z_DEFLATED,
        this.windowBits,
        this.memLevel,
        this.strategy
      );
      break;
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      var status  = zlib_inflate.inflateInit2(
        this.strm,
        this.windowBits
      );
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
    return;
  }
  
  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype.params = function() {
  throw new Error("deflateParams Not supported");
};

Zlib.prototype._writeCheck = function() {
  if (!this.init_done)
    throw new Error("write before init");
    
  if (this.mode === exports.NONE)
    throw new Error("already finalized");
    
  if (this.write_in_progress)
    throw new Error("write already in progress");
    
  if (this.pending_close)
    throw new Error("close is pending");
};

Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
  this._writeCheck();
  this.write_in_progress = true;
  
  var self = this;
  process.nextTick(function() {
    self.write_in_progress = false;
    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
    self.callback(res[0], res[1]);
    
    if (self.pending_close)
      self.close();
  });
  
  return this;
};

// set method for Node buffers, used by pako
function bufferSet(data, offset) {
  for (var i = 0; i < data.length; i++) {
    this[offset + i] = data[i];
  }
}

Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this._writeCheck();
  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this.write_in_progress = true;
  
  if (flush !== exports.Z_NO_FLUSH &&
      flush !== exports.Z_PARTIAL_FLUSH &&
      flush !== exports.Z_SYNC_FLUSH &&
      flush !== exports.Z_FULL_FLUSH &&
      flush !== exports.Z_FINISH &&
      flush !== exports.Z_BLOCK) {
    throw new Error("Invalid flush value");
  }
  
  if (input == null) {
    input = new Buffer(0);
    in_len = 0;
    in_off = 0;
  }
  
  if (out._set)
    out.set = out._set;
  else
    out.set = bufferSet;
  
  var strm = this.strm;
  strm.avail_in = in_len;
  strm.input = input;
  strm.next_in = in_off;
  strm.avail_out = out_len;
  strm.output = out;
  strm.next_out = out_off;
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflate(strm, flush);
      break;
    case exports.UNZIP:
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflate(strm, flush);
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
    this._error(status);
  }
  
  this.write_in_progress = false;
  return [strm.avail_in, strm.avail_out];
};

Zlib.prototype.close = function() {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }
  
  this.pending_close = false;
  
  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else {
    zlib_inflate.inflateEnd(this.strm);
  }
  
  this.mode = exports.NONE;
};

Zlib.prototype.reset = function() {
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateReset(this.strm);
      break;
    case exports.INFLATE:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflateReset(this.strm);
      break;
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
  }
};

Zlib.prototype._error = function(status) {
  this.onerror(msg[status] + ': ' + this.strm.msg, status);
  
  this.write_in_progress = false;
  if (this.pending_close)
    this.close();
};

exports.Zlib = Zlib;

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":68,"buffer":20,"pako/lib/zlib/constants":8,"pako/lib/zlib/deflate.js":10,"pako/lib/zlib/inflate.js":12,"pako/lib/zlib/messages":14,"pako/lib/zlib/zstream":16}],18:[function(require,module,exports){
(function (process,Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Transform = require('_stream_transform');

var binding = require('./binding');
var util = require('util');
var assert = require('assert').ok;

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = (16 * 1024);

binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;

binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

// expose all the zlib constants
Object.keys(binding).forEach(function(k) {
  if (k.match(/^Z/)) exports[k] = binding[k];
});

// translation table for return codes.
exports.codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

Object.keys(exports.codes).forEach(function(k) {
  exports.codes[exports.codes[k]] = k;
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function(o) {
  return new Deflate(o);
};

exports.createInflate = function(o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function(o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function(o) {
  return new InflateRaw(o);
};

exports.createGzip = function(o) {
  return new Gzip(o);
};

exports.createGunzip = function(o) {
  return new Gunzip(o);
};

exports.createUnzip = function(o) {
  return new Unzip(o);
};


// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;

  engine.on('error', onError);
  engine.on('end', onEnd);

  engine.end(buffer);
  flow();

  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf = Buffer.concat(buffers, nread);
    buffers = [];
    callback(null, buf);
    engine.close();
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string')
    buffer = new Buffer(buffer);
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('Not a string or buffer');

  var flushFlag = binding.Z_FINISH;

  return engine._processChunk(buffer, flushFlag);
}

// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}



// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}



// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}


// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}


// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.

function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush) {
    if (opts.flush !== binding.Z_NO_FLUSH &&
        opts.flush !== binding.Z_PARTIAL_FLUSH &&
        opts.flush !== binding.Z_SYNC_FLUSH &&
        opts.flush !== binding.Z_FULL_FLUSH &&
        opts.flush !== binding.Z_FINISH &&
        opts.flush !== binding.Z_BLOCK) {
      throw new Error('Invalid flush flag: ' + opts.flush);
    }
  }
  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
        opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL ||
        opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &&
        opts.strategy != exports.Z_HUFFMAN_ONLY &&
        opts.strategy != exports.Z_RLE &&
        opts.strategy != exports.Z_FIXED &&
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._binding = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._binding.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    self._binding = null;
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                     level,
                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                     strategy,
                     opts.dictionary);

  this._buffer = new Buffer(this._chunkSize);
  this._offset = 0;
  this._closed = false;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function(level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL ||
      level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED &&
      strategy != exports.Z_HUFFMAN_ONLY &&
      strategy != exports.Z_RLE &&
      strategy != exports.Z_FIXED &&
      strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function() {
      self._binding.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function() {
  return this._binding.reset();
};

// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function(callback) {
  this._transform(new Buffer(0), '', callback);
};

Zlib.prototype.flush = function(kind, callback) {
  var ws = this._writableState;

  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback)
      process.nextTick(callback);
  } else if (ws.ending) {
    if (callback)
      this.once('end', callback);
  } else if (ws.needDrain) {
    var self = this;
    this.once('drain', function() {
      self.flush(callback);
    });
  } else {
    this._flushFlag = kind;
    this.write(new Buffer(0), '', callback);
  }
};

Zlib.prototype.close = function(callback) {
  if (callback)
    process.nextTick(callback);

  if (this._closed)
    return;

  this._closed = true;

  this._binding.close();

  var self = this;
  process.nextTick(function() {
    self.emit('close');
  });
};

Zlib.prototype._transform = function(chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);

  if (!chunk === null && !Buffer.isBuffer(chunk))
    return cb(new Error('invalid input'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last)
    flushFlag = binding.Z_FINISH;
  else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  var self = this;
  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function(er) {
      error = er;
    });

    do {
      var res = this._binding.writeSync(flushFlag,
                                        chunk, // in
                                        inOff, // in_off
                                        availInBefore, // in_len
                                        this._buffer, // out
                                        this._offset, //out_off
                                        availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    var buf = Buffer.concat(buffers, nread);
    this.close();

    return buf;
  }

  var req = this._binding.write(flushFlag,
                                chunk, // in
                                inOff, // in_off
                                availInBefore, // in_len
                                this._buffer, // out
                                this._offset, //out_off
                                availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    if (self._hadError)
      return;

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = new Buffer(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      if (!async)
        return true;

      var newReq = self._binding.write(flushFlag,
                                       chunk,
                                       inOff,
                                       availInBefore,
                                       self._buffer,
                                       self._offset,
                                       self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async)
      return false;

    // finished with the chunk.
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);

}).call(this,require('_process'),require("buffer").Buffer)

},{"./binding":17,"_process":68,"_stream_transform":79,"assert":3,"buffer":20,"util":86}],19:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":20}],20:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":4,"ieee754":27,"isarray":21}],21:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],22:[function(require,module,exports){
'use strict';

// VARIABLES //

var FLOAT32_VIEW = new Float32Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT32_VIEW.buffer );

// 1 11111111 00000000000000000000000 => 4286578688 => 0xff800000 (see IEEE 754-2008)
var NINF = 0xff800000;

// Set the ArrayBuffer bit sequence:
UINT32_VIEW[ 0 ] = NINF;


// EXPORTS //

module.exports = FLOAT32_VIEW[ 0 ];

},{}],23:[function(require,module,exports){
'use strict';

// VARIABLES //

var FLOAT32_VIEW = new Float32Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT32_VIEW.buffer );

// 0 11111111 00000000000000000000000 => 2139095040 => 0x7f800000 (see IEEE 754-2008)
var PINF = 0x7f800000;

// Set the ArrayBuffer bit sequence:
UINT32_VIEW[ 0 ] = PINF;


// EXPORTS //

module.exports = FLOAT32_VIEW[ 0 ];

},{}],24:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":29}],25:[function(require,module,exports){
(function (Buffer){
/*! dicom-parser - v1.7.3 - 2016-08-18 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */
(function (root, factory) {

    // node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else {
        // Browser globals
        if(typeof cornerstone === 'undefined'){
            dicomParser = {};

            // meteor
            if (typeof Package !== 'undefined') {
                root.dicomParser = dicomParser;
            }
        }
        dicomParser = factory();
    }
}(this, function () {

/**
 * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options
 * argument is supplied and it contains the untilTag property, parsing will stop once that
 * tag is encoutered.  This can be used to parse partial byte streams.
 *
 * @param byteArray the byte array
 * @param options object to control parsing behavior (optional)
 * @returns {DataSet}
 * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the
 *         elements successfully parsed before the error.
 */
var dicomParser = (function(dicomParser) {
    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.parseDicom = function(byteArray, options) {

        if(byteArray === undefined)
        {
            throw "dicomParser.parseDicom: missing required parameter 'byteArray'";
        }

        function readTransferSyntax(metaHeaderDataSet) {
            if(metaHeaderDataSet.elements.x00020010 === undefined) {
                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';
            }
            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;
            return dicomParser.readFixedString(byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);
        }

        function isExplicit(transferSyntax) {
            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian
            {
                return false;
            }
            // all other transfer syntaxes should be explicit
            return true;
        }

        function getDataSetByteStream(transferSyntax, position) {
            if(transferSyntax === '1.2.840.10008.1.2.1.99')
            {
                // if an infalter callback is registered, use it
                if (options && options.inflater) {
                    var fullByteArrayCallback = options.inflater(byteArray, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArrayCallback, 0);
                }
                // if running on node, use the zlib library to inflate
                // http://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js
                else if (typeof module !== 'undefined' && this.module !== module) {
                    // inflate it
                    var zlib = require('zlib');
                    var deflatedBuffer = dicomParser.sharedCopy(byteArray, position, byteArray.length - position);
                    var inflatedBuffer = zlib.inflateRawSync(deflatedBuffer);

                    // create a single byte array with the full header bytes and the inflated bytes
                    var fullByteArrayBuffer = dicomParser.alloc(byteArray, inflatedBuffer.length + position);
                    byteArray.copy(fullByteArrayBuffer, 0, 0, position);
                    inflatedBuffer.copy(fullByteArrayBuffer, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArrayBuffer, 0);
                }
                // if pako is defined - use it.  This is the web browser path
                // https://github.com/nodeca/pako
                else if(typeof pako !== "undefined") {
                    // inflate it
                    var deflated = byteArray.slice(position);
                    var inflated = pako.inflateRaw(deflated);

                    // create a single byte array with the full header bytes and the inflated bytes
                    var fullByteArray = dicomParser.alloc(byteArray, inflated.length + position);
                    fullByteArray.set(byteArray.slice(0, position), 0);
                    fullByteArray.set(inflated, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArray, 0);
                }
                // throw exception since no inflater is available
                else {
                    throw 'dicomParser.parseDicom: no inflater available to handle deflate transfer syntax';
                }
            }
            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian
            {
                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, position);
            }
            else
            {
                // all other transfer syntaxes are little endian; only the pixel encoding differs
                // make a new stream so the metaheader warnings don't come along for the ride
                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, position);
            }
        }

        function mergeDataSets(metaHeaderDataSet, instanceDataSet)
        {
            for (var propertyName in metaHeaderDataSet.elements)
            {
                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))
                {
                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];
                }
            }
            if (metaHeaderDataSet.warnings !== undefined) {
                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);
            }
            return instanceDataSet;
        }

        function readDataSet(metaHeaderDataSet)
        {
            var transferSyntax = readTransferSyntax(metaHeaderDataSet);
            var explicit = isExplicit(transferSyntax);
            var dataSetByteStream = getDataSetByteStream(transferSyntax, metaHeaderDataSet.position);

            var elements = {};
            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);
            dataSet.warnings = dataSetByteStream.warnings;

            try{
                if(explicit) {
                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);
                }
                else
                {
                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);
                }
            }
            catch(e) {
                var ex = {
                    exception: e,
                    dataSet: dataSet
                };
                throw ex;
            }
            return dataSet;
        }

        // main function here
        function parseTheByteStream() {
            var metaHeaderDataSet = dicomParser.readPart10Header(byteArray, options);

            var dataSet = readDataSet(metaHeaderDataSet);

            return mergeDataSets(metaHeaderDataSet, dataSet);
        }

        // This is where we actually start parsing
        return parseTheByteStream();
    };

    return dicomParser;
})(dicomParser);

/**
 * Utility function for creating a basic offset table for JPEG transfer syntaxes
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  // Each JPEG image has an end of image marker 0xFFD9
  function isEndOfImageMarker(dataSet, position) {
    return (dataSet.byteArray[position] === 0xFF &&
    dataSet.byteArray[position + 1] === 0xD9);
  }

  function isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex) {
    var fragment = pixelDataElement.fragments[fragmentIndex];
    // Need to check the last two bytes and the last three bytes for marker since odd length
    // fragments are zero padded
    if(isEndOfImageMarker(dataSet, fragment.position + fragment.length - 2) ||
      isEndOfImageMarker(dataSet, fragment.position + fragment.length - 3)) {
      return true;
    }
    return false;
  }

  function findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragment) {
    for(var fragmentIndex=startFragment; fragmentIndex < pixelDataElement.fragments.length; fragmentIndex++) {
      if(isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex)) {
        return fragmentIndex;
      }
    }
  }

  /**
   * Creates a basic offset table by scanning fragments for JPEG start of image and end Of Image markers
   * @param {object} dataSet - the parsed dicom dataset
   * @param {object} pixelDataElement - the pixel data element
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {Array} basic offset table (array of offsets to beginning of each frame)
   */
  dicomParser.createJPEGBasicOffsetTable = function(dataSet, pixelDataElement, fragments) {
    // Validate parameters
    if(dataSet === undefined) {
      throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter dataSet';
    }
    if(pixelDataElement === undefined) {
      throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter pixelDataElement';
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.basicOffsetTable === undefined) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments.length <= 0) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(fragments && fragments.length <=0) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'fragments' must not be zero length";
    }

    // Default values
    fragments = fragments || pixelDataElement.fragments;

    var basicOffsetTable = [];

    var startFragmentIndex = 0;

    while(true) {
      // Add the offset for the start fragment
      basicOffsetTable.push(pixelDataElement.fragments[startFragmentIndex].offset);
      var endFragmentIndex = findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragmentIndex);
      if(endFragmentIndex === undefined || endFragmentIndex === pixelDataElement.fragments.length -1) {
        return basicOffsetTable;
      }
      startFragmentIndex = endFragmentIndex + 1;
    }
  };

  return dicomParser;
}(dicomParser));
var dicomParser = (function (dicomParser) {
    "use strict";

    if (dicomParser === undefined) {
        dicomParser = {};
    }

    /**
     * converts an explicit dataSet to a javascript object
     * @param dataSet
     * @param options
     */
    dicomParser.explicitDataSetToJS = function (dataSet, options) {

        if(dataSet === undefined) {
            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';
        }

        options = options || {
            omitPrivateAttibutes: true, // true if private elements should be omitted
            maxElementLength : 128      // maximum element length to try and convert to string format
        };

        var result = {

        };

        for(var tag in dataSet.elements) {
            var element = dataSet.elements[tag];

            // skip this element if it a private element and our options specify that we should
            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))
            {
                continue;
            }

            if(element.items) {
                // handle sequences
                var sequenceItems = [];
                for(var i=0; i < element.items.length; i++) {
                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));
                }
                result[tag] = sequenceItems;
            } else {
                var asString;
                asString = undefined;
                if(element.length < options.maxElementLength) {
                    asString = dicomParser.explicitElementToString(dataSet, element);
                }

                if(asString !== undefined) {
                    result[tag] = asString;
                }  else {
                    result[tag] = {
                        dataOffset: element.dataOffset,
                        length : element.length
                    };
                }
            }
        }

        return result;
    };


    return dicomParser;
}(dicomParser));
var dicomParser = (function (dicomParser) {
    "use strict";

    if (dicomParser === undefined) {
        dicomParser = {};
    }

    /**
     * Converts an explicit VR element to a string or undefined if it is not possible to convert.
     * Throws an error if an implicit element is supplied
     * @param dataSet
     * @param element
     * @returns {*}
     */
    dicomParser.explicitElementToString = function(dataSet, element)
    {
        if(dataSet === undefined || element === undefined) {
            throw 'dicomParser.explicitElementToString: missing required parameters';
        }
        if(element.vr === undefined) {
            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';
        }
        var vr = element.vr;
        var tag = element.tag;

        var textResult;

        function multiElementToString(numItems, func) {
            var result = "";
            for(var i=0; i < numItems; i++) {
                if(i !== 0) {
                    result += '/';
                }
                result += func.call(dataSet, tag, i).toString();
            }
            return result;
        }

        if(dicomParser.isStringVr(vr) === true)
        {
            textResult = dataSet.string(tag);
        }
        else if (vr == 'AT') {
            var num = dataSet.uint32(tag);
            if(num === undefined) {
                return undefined;
            }
            if (num < 0)
            {
                num = 0xFFFFFFFF + num + 1;
            }

            return 'x' + num.toString(16).toUpperCase();
        }
        else if (vr == 'US')
        {
            textResult = multiElementToString(element.length / 2, dataSet.uint16);
        }
        else if(vr === 'SS')
        {
            textResult = multiElementToString(element.length / 2, dataSet.int16);
        }
        else if (vr == 'UL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.uint32);
        }
        else if(vr === 'SL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.int32);
        }
        else if(vr == 'FD')
        {
            textResult = multiElementToString(element.length / 8, dataSet.double);
        }
        else if(vr == 'FL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.float);
        }

        return textResult;
    };
    return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  // algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month
  function daysInMonth(m, y) { // m is 0 indexed: 0-11
    switch (m) {
      case 2 :
        return (y % 4 == 0 && y % 100) || y % 400 == 0 ? 29 : 28;
      case 9 : case 4 : case 6 : case 11 :
      return 30;
      default :
        return 31
    }
  }

  function isValidDate(d, m, y) {
    // make year is a number
    if(isNaN(y)) {
      return false;
    }
    return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);
  }


  /**
   * Parses a DA formatted string into a Javascript object
   * @param {string} date a string in the DA VR format
   * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
   * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long
   */
  dicomParser.parseDA = function(date, validate)
  {
    if(date && date.length === 8)
    {
      var yyyy = parseInt(date.substring(0, 4), 10);
      var mm = parseInt(date.substring(4, 6), 10);
      var dd = parseInt(date.substring(6, 8), 10);

      if(validate) {
        if (isValidDate(dd, mm, yyyy) !== true) {
          throw "invalid DA '" + date + "'";
        }
      }
      return {
        year: yyyy,
        month: mm,
        day: dd
      };
    }
    if(validate) {
      throw "invalid DA '" + date + "'";
    }
    return undefined;
  };

  return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds
   * @param {string} time - a string in the TM VR format
   * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
   * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined
   */
  dicomParser.parseTM = function(time, validate) {

    if (time.length >= 2) // must at least have HH
    {
      // 0123456789
      // HHMMSS.FFFFFF
      var hh = parseInt(time.substring(0, 2), 10);
      var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;
      var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;
      var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;

      if(validate) {
        if((isNaN(hh)) ||
          (mm !== undefined && isNaN(mm)) ||
          (ss !== undefined && isNaN(ss)) ||
          (ffffff !== undefined && isNaN(ffffff)) ||
          (hh < 0 || hh > 23) ||
          (mm && (mm <0 || mm > 59))  ||
          (ss && (ss <0 || ss > 59))  ||
          (ffffff && (ffffff <0 || ffffff > 999999)))
        {
          throw "invalid TM '" + time + "'";
        }
      }

      return {
        hours: hh,
        minutes: mm,
        seconds: ss,
        fractionalSeconds: ffffff
      };
    }

    if(validate) {
      throw "invalid TM '" + time + "'";
    }

    return undefined;
  };

  return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    var stringVrs = {
        AE: true,
        AS: true,
        AT: false,
        CS: true,
        DA: true,
        DS: true,
        DT: true,
        FL: false,
        FD: false,
        IS: true,
        LO: true,
        LT: true,
        OB: false,
        OD: false,
        OF: false,
        OW: false,
        PN: true,
        SH: true,
        SL: false,
        SQ: false,
        SS: false,
        ST: true,
        TM: true,
        UI: true,
        UL: false,
        UN: undefined, // dunno
        UR: true,
        US: false,
        UT: true
    };

    /**
     * Tests to see if vr is a string or not.
     * @param vr
     * @returns true if string, false it not string, undefined if unknown vr or UN type
     */
    dicomParser.isStringVr = function(vr)
    {
        return stringVrs[vr];
    };

    /**
     * Tests to see if a given tag in the format xggggeeee is a private tag or not
     * @param tag
     * @returns {boolean}
     */
    dicomParser.isPrivateTag = function(tag)
    {
        var lastGroupDigit = parseInt(tag[4]);
        var groupIsOdd = (lastGroupDigit % 2) === 1;
        return groupIsOdd;
    };

    /**
     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix
     * @param personName a string in the PN VR format
     * @param index
     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data
     */
    dicomParser.parsePN = function(personName) {
        if(personName === undefined) {
            return undefined;
        }
        var stringValues = personName.split('^');
        return {
            familyName: stringValues[0],
            givenName: stringValues[1],
            middleName: stringValues[2],
            prefix: stringValues[3],
            suffix: stringValues[4]
        };
    };



    return dicomParser;
}(dicomParser));
/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    var deprecatedNoticeLogged = false;

    /**
     * Returns the pixel data for the specified frame in an encapsulated pixel data element.  If no basic offset
     * table is present, it assumes that all fragments are for one frame.  Note that this assumption/logic is not
     * valid for multi-frame instances so this function has been deprecated and will eventually be removed.  Code
     * should be updated to use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()
     *
     * @deprecated since version 1.6 - use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()
     * @param dataSet - the dataSet containing the encapsulated pixel data
     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from
     * @param frame - the zero based frame index
     * @returns {object} with the encapsulated pixel data
     */


    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)
    {
        if(!deprecatedNoticeLogged) {
            deprecatedNoticeLogged = true;
            if(console && console.log) {
                console.log("WARNING: dicomParser.readEncapsulatedPixelData() has been deprecated");
            }
        }

        if(dataSet === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'";
        }
        if(pixelDataElement === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'element'";
        }
        if(frame === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'";
        }
        if(pixelDataElement.tag !== 'x7fe00010') {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'";
        }
        if(pixelDataElement.encapsulatedPixelData !== true) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.hadUndefinedLength !== true) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.basicOffsetTable === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.fragments === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(frame < 0) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0";
        }

        // If the basic offset table is not empty, we can extract the frame
        if(pixelDataElement.basicOffsetTable.length !== 0)
        {
            return dicomParser.readEncapsulatedImageFrame(dataSet, pixelDataElement, frame);
        }
        else
        {
            // No basic offset table, assume all fragments are for one frame - NOTE that this is NOT a valid
            // assumption but is the original behavior so we are keeping it for now
            return dicomParser.readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, 0, pixelDataElement.fragments.length);
        }
    };

    return dicomParser;
}(dicomParser));

/**
 *
 * Internal helper function to allocate new byteArray buffers
 */
var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Creates a new byteArray of the same type (Uint8Array or Buffer) of the specified length.
   * @param byteArray the underlying byteArray (either Uint8Array or Buffer)
   * @param length number of bytes of the Byte Array
   * @returns {object} Uint8Array or Buffer depending on the type of byteArray
   */
  dicomParser.alloc = function(byteArray, length) {
    if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {
      return Buffer.alloc(length);
    }
    else if(byteArray instanceof Uint8Array) {
      return new Uint8Array(length);
    } else {
      throw 'dicomParser.alloc: unknown type for byteArray';
    }
  };

  return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing different types from a big-endian byte array
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.bigEndianByteArrayParser = {
        /**
         *
         * Parses an unsigned int 16 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint16: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';
            }
            return (byteArray[position] << 8) + byteArray[position + 1];
        },

        /**
         *
         * Parses a signed int 16 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt16: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';
            }
            var int16 = (byteArray[position] << 8) + byteArray[position + 1];
            // fix sign
            if (int16 & 0x8000) {
                int16 = int16 - 0xFFFF - 1;
            }
            return int16;
        },

        /**
         * Parses an unsigned int 32 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint32: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';
            }

            var uint32 = (256 * (256 * (256 * byteArray[position] +
                                              byteArray[position + 1]) +
                                              byteArray[position + 2]) +
                                              byteArray[position + 3]);

            return uint32;
        },

        /**
         * Parses a signed int 32 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt32: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';
            }

            var int32 = ((byteArray[position] << 24) +
                         (byteArray[position + 1] << 16) +
                         (byteArray[position + 2] << 8) +
                          byteArray[position + 3]);

            return int32;
        },

        /**
         * Parses 32-bit float from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 32-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readFloat: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(4);
            byteArrayForParsingFloat[3] = byteArray[position];
            byteArrayForParsingFloat[2] = byteArray[position + 1];
            byteArrayForParsingFloat[1] = byteArray[position + 2];
            byteArrayForParsingFloat[0] = byteArray[position + 3];
            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        },

        /**
         * Parses 64-bit float from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 64-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readDouble: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';
            }

            if (position + 8 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(8);
            byteArrayForParsingFloat[7] = byteArray[position];
            byteArrayForParsingFloat[6] = byteArray[position + 1];
            byteArrayForParsingFloat[5] = byteArray[position + 2];
            byteArrayForParsingFloat[4] = byteArray[position + 3];
            byteArrayForParsingFloat[3] = byteArray[position + 4];
            byteArrayForParsingFloat[2] = byteArray[position + 5];
            byteArrayForParsingFloat[1] = byteArray[position + 6];
            byteArrayForParsingFloat[0] = byteArray[position + 7];
            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions common to parsing byte arrays of any type
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads a string of 8-bit characters from an array of bytes and advances
     * the position by length bytes.  A null terminator will end the string
     * but will not effect advancement of the position.  Trailing and leading
     * spaces are preserved (not trimmed)
     * @param byteArray the byteArray to read from
     * @param position the position in the byte array to read from
     * @param length the maximum number of bytes to parse
     * @returns {string} the parsed string
     * @throws error if buffer overread would occur
     * @access private
     */
    dicomParser.readFixedString = function(byteArray, position, length)
    {
        if(length < 0)
        {
            throw 'dicomParser.readFixedString - length cannot be less than 0';
        }

        if(position + length > byteArray.length) {
            throw 'dicomParser.readFixedString: attempt to read past end of buffer';
        }

        var result = "";
        var byte;
        for(var i=0; i < length; i++)
        {
            byte = byteArray[position + i];
            if(byte === 0) {
                position +=  length;
                return result;
            }
            result += String.fromCharCode(byte);
        }

        return result;
    };


    return dicomParser;
}(dicomParser));
/**
 *
 * Internal helper class to assist with parsing. Supports reading from a byte
 * stream contained in a Uint8Array.  Example usage:
 *
 *  var byteArray = new Uint8Array(32);
 *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);
 *
 * */
var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Constructor for ByteStream objects.
     * @param byteArrayParser a parser for parsing the byte array
     * @param byteArray a Uint8Array containing the byte stream
     * @param position (optional) the position to start reading from.  0 if not specified
     * @constructor
     * @throws will throw an error if the byteArrayParser parameter is not present
     * @throws will throw an error if the byteArray parameter is not present or invalid
     * @throws will throw an error if the position parameter is not inside the byte array
     */
    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {
        if(byteArrayParser === undefined)
        {
            throw "dicomParser.ByteStream: missing required parameter 'byteArrayParser'";
        }
        if(byteArray === undefined)
        {
            throw "dicomParser.ByteStream: missing required parameter 'byteArray'";
        }
        if((byteArray instanceof Uint8Array) === false &&
          (byteArray instanceof Buffer) === false ) {
            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array or Buffer';
        }
        if(position < 0)
        {
            throw "dicomParser.ByteStream: parameter 'position' cannot be less than 0";
        }
        if(position >= byteArray.length)
        {
            throw "dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length";

        }
        this.byteArrayParser = byteArrayParser;
        this.byteArray = byteArray;
        this.position = position ? position : 0;
        this.warnings = []; // array of string warnings encountered while parsing
    };

    /**
     * Safely seeks through the byte stream.  Will throw an exception if an attempt
     * is made to seek outside of the byte array.
     * @param offset the number of bytes to add to the position
     * @throws error if seek would cause position to be outside of the byteArray
     */
    dicomParser.ByteStream.prototype.seek = function(offset)
    {
        if(this.position + offset < 0)
        {
            throw "dicomParser.ByteStream.prototype.seek: cannot seek to position < 0";
        }
        this.position += offset;
    };

    /**
     * Returns a new ByteStream object from the current position and of the requested number of bytes
     * @param numBytes the length of the byte array for the ByteStream to contain
     * @returns {dicomParser.ByteStream}
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)
    {
        if(this.position + numBytes > this.byteArray.length) {
            throw 'dicomParser.ByteStream.prototype.readByteStream: readByteStream - buffer overread';
        }
        var byteArrayView = dicomParser.sharedCopy(this.byteArray, this.position, numBytes);
        this.position += numBytes;
        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);
    };

    /**
     *
     * Parses an unsigned int 16 from a byte array and advances
     * the position by 2 bytes
     *
     * @returns {*} the parsed unsigned int 16
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readUint16 = function()
    {
        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);
        this.position += 2;
        return result;
    };

    /**
     * Parses an unsigned int 32 from a byte array and advances
     * the position by 2 bytes
     *
     * @returns {*} the parse unsigned int 32
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readUint32 = function()
    {
        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);
        this.position += 4;
        return result;
    };

    /**
     * Reads a string of 8-bit characters from an array of bytes and advances
     * the position by length bytes.  A null terminator will end the string
     * but will not effect advancement of the position.
     * @param length the maximum number of bytes to parse
     * @returns {string} the parsed string
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readFixedString = function(length)
    {
        var result = dicomParser.readFixedString(this.byteArray, this.position, length);
        this.position += length;
        return result;
    };

    return dicomParser;
}(dicomParser));
/**
 *
 * The DataSet class encapsulates a collection of DICOM Elements and provides various functions
 * to access the data in those elements
 *
 * Rules for handling padded spaces:
 * DS = Strip leading and trailing spaces
 * DT = Strip trailing spaces
 * IS = Strip leading and trailing spaces
 * PN = Strip trailing spaces
 * TM = Strip trailing spaces
 * AE = Strip leading and trailing spaces
 * CS = Strip leading and trailing spaces
 * SH = Strip leading and trailing spaces
 * LO = Strip leading and trailing spaces
 * LT = Strip trailing spaces
 * ST = Strip trailing spaces
 * UT = Strip trailing spaces
 *
 */
var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function getByteArrayParser(element, defaultParser)
    {
        return (element.parser !== undefined ? element.parser : defaultParser);
    }

    /**
     * Constructs a new DataSet given byteArray and collection of elements
     * @param byteArrayParser
     * @param byteArray
     * @param elements
     * @constructor
     */
    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)
    {
        this.byteArrayParser = byteArrayParser;
        this.byteArray = byteArray;
        this.elements = elements;
    };

    /**
     * Finds the element for tag and returns an unsigned int 16 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.uint16 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an signed int 16 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.int16 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an unsigned int 32 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.uint32 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an signed int 32 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.int32 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} float or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.float = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0
     */
    dicomParser.DataSet.prototype.double = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));
        }
        return undefined;
    };

    /**
     * Returns the number of string values for the element
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data
     */
    dicomParser.DataSet.prototype.numStringValues = function(tag)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            var numMatching = fixedString.match(/\\/g);
            if(numMatching === null)
            {
                return 1;
            }
            return numMatching.length + 1;
        }
        return undefined;
    };

    /**
     * Returns a string for the element.  If index is provided, the element is assumed to be
     * multi-valued and will return the component specified by index.  Undefined is returned
     * if there is no component with the specified index, the element does not exist or is zero length.
     *
     * Use this function for VR types of AE, CS, SH and LO
     *
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the entire string
     * @returns {*}
     */
    dicomParser.DataSet.prototype.string = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            if(index >= 0)
            {
                var values = fixedString.split('\\');
                // trim trailing spaces
                return values[index].trim();
            }
            else
            {
                // trim trailing spaces
                return fixedString.trim();
            }
        }
        return undefined;
    };

    /**
     * Returns a string with the leading spaces preserved and trailing spaces removed.
     *
     * Use this function to access data for VRs of type UT, ST and LT
     *
     * @param tag
     * @param index
     * @returns {*}
     */
    dicomParser.DataSet.prototype.text = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            if(index >= 0)
            {
                var values = fixedString.split('\\');
                return values[index].replace(/ +$/, '');
            }
            else
            {
                return fixedString.replace(/ +$/, '');
            }
        }
        return undefined;
    };

    /**
     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,
     * the first value in a multi-valued VR will be parsed if present.
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the first value
     * @returns {*} a floating point number or undefined if not present or data not long enough
     */
    dicomParser.DataSet.prototype.floatString = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            index = (index !== undefined) ? index : 0;
            var value = this.string(tag, index);
            if(value !== undefined) {
                return parseFloat(value);
            }
        }
        return undefined;
    };

    /**
     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,
     * the first value in a multi-valued VR will be parsed if present.
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the first value
     * @returns {*} an integer or undefined if not present or data not long enough
     */
    dicomParser.DataSet.prototype.intString = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0) {
            index = (index !== undefined) ? index : 0;
            var value = this.string(tag, index);
            if(value !== undefined) {
                return parseInt(value);
            }
        }
        return undefined;
    };

    //dicomParser.DataSet = DataSet;

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * reads from the byte stream until it finds the magic number for the Sequence Delimitation Item item
   * and then sets the length of the element
   * @param byteStream
   * @param element
   */
  dicomParser.findAndSetUNElementLength = function(byteStream, element)
  {
    if(byteStream === undefined)
    {
      throw "dicomParser.findAndSetUNElementLength: missing required parameter 'byteStream'";
    }

    var itemDelimitationItemLength = 8; // group, element, length
    var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;
    while(byteStream.position <= maxPosition)
    {
      var groupNumber;
      groupNumber = byteStream.readUint16();
      if(groupNumber === 0xfffe)
      {
        var elementNumber;
        elementNumber = byteStream.readUint16();
        if(elementNumber === 0xe0dd)
        {
          // NOTE: It would be better to also check for the length to be 0 as part of the check above
          // but we will just log a warning for now
          var itemDelimiterLength;
          itemDelimiterLength = byteStream.readUint32(); // the length
          if(itemDelimiterLength !== 0) {
            byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + " while reading element of undefined length with tag ' + element.tag");
          }
          element.length = byteStream.position - element.dataOffset;
          return;
        }
      }
    }

    // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer
    element.length = byteStream.byteArray.length - element.dataOffset;
    byteStream.seek(byteStream.byteArray.length - byteStream.position);
  };


  return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads an encapsulated pixel data element and adds an array of fragments to the element
     * containing the offset and length of each fragment and any offsets from the basic offset
     * table
     * @param byteStream
     * @param element
     */
    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'";
        }

        element.encapsulatedPixelData = true;
        element.basicOffsetTable = [];
        element.fragments = [];
        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);
        if(basicOffsetTableItemTag !== 'xfffee000') {
            throw "dicomParser.findEndOfEncapsulatedElement: basic offset table not found";
        }
        var basicOffsetTableItemlength = byteStream.readUint32();
        var numFragments = basicOffsetTableItemlength / 4;
        for(var i =0; i < numFragments; i++) {
            var offset = byteStream.readUint32();
            element.basicOffsetTable.push(offset);
        }
        var baseOffset = byteStream.position;

        while(byteStream.position < byteStream.byteArray.length)
        {
            var tag = dicomParser.readTag(byteStream);
            var length = byteStream.readUint32();
            if(tag === 'xfffee0dd')
            {
                byteStream.seek(length);
                element.length = byteStream.position - element.dataOffset;
                return;
            }
            else if(tag === 'xfffee000')
            {
                element.fragments.push({
                    offset: byteStream.position - baseOffset - 8,
                    position : byteStream.position,
                    length : length
                });
            }
            else {
                if(warnings) {
                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');
                }
                if(length > byteStream.byteArray.length - byteStream.position)
                {
                    // fix length
                    length = byteStream.byteArray.length - byteStream.position;
                }
                element.fragments.push({
                    offset: byteStream.position - baseOffset - 8,
                    position : byteStream.position,
                    length : length
                });
                byteStream.seek(length);
                element.length = byteStream.position - element.dataOffset;
                return;
            }

            byteStream.seek(length);
        }

        if(warnings) {
            warnings.push("pixel data element " + element.tag + " missing sequence delimiter tag xfffee0dd");
        }
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * reads from the byte stream until it finds the magic numbers for the item delimitation item
     * and then sets the length of the element
     * @param byteStream
     * @param element
     */
    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
        }

        var itemDelimitationItemLength = 8; // group, element, length
        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;
        while(byteStream.position <= maxPosition)
        {
            var groupNumber = byteStream.readUint16();
            if(groupNumber === 0xfffe)
            {
                var elementNumber = byteStream.readUint16();
                if(elementNumber === 0xe00d)
                {
                    // NOTE: It would be better to also check for the length to be 0 as part of the check above
                    // but we will just log a warning for now
                    var itemDelimiterLength = byteStream.readUint32(); // the length
                    if(itemDelimiterLength !== 0) {
                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + " while reading element of undefined length with tag ' + element.tag");
                    }
                    element.length = byteStream.position - element.dataOffset;
                    return;
                }
            }
        }

        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer
        element.length = byteStream.byteArray.length - element.dataOffset;
        byteStream.seek(byteStream.byteArray.length - byteStream.position);
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing different types from a little-endian byte array
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.littleEndianByteArrayParser = {
        /**
         *
         * Parses an unsigned int 16 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint16: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';
            }
            return byteArray[position] + (byteArray[position + 1] * 256);
        },

        /**
         *
         * Parses a signed int 16 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt16: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';
            }
            var int16 = byteArray[position] + (byteArray[position + 1] << 8);
            // fix sign
            if (int16 & 0x8000) {
                int16 = int16 - 0xFFFF - 1;
            }
            return int16;
        },


        /**
         * Parses an unsigned int 32 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint32: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';
            }

            var uint32 = (byteArray[position] +
            (byteArray[position + 1] * 256) +
            (byteArray[position + 2] * 256 * 256) +
            (byteArray[position + 3] * 256 * 256 * 256 ));

            return uint32;
        },

        /**
         * Parses a signed int 32 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt32: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';
            }

            var int32 = (byteArray[position] +
            (byteArray[position + 1] << 8) +
            (byteArray[position + 2] << 16) +
            (byteArray[position + 3] << 24));

            return int32;

        },

        /**
         * Parses 32-bit float from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 32-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readFloat: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(4);
            byteArrayForParsingFloat[0] = byteArray[position];
            byteArrayForParsingFloat[1] = byteArray[position + 1];
            byteArrayForParsingFloat[2] = byteArray[position + 2];
            byteArrayForParsingFloat[3] = byteArray[position + 3];
            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        },

        /**
         * Parses 64-bit float from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 64-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readDouble: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';
            }

            if (position + 8 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(8);
            byteArrayForParsingFloat[0] = byteArray[position];
            byteArrayForParsingFloat[1] = byteArray[position + 1];
            byteArrayForParsingFloat[2] = byteArray[position + 2];
            byteArrayForParsingFloat[3] = byteArray[position + 3];
            byteArrayForParsingFloat[4] = byteArray[position + 4];
            byteArrayForParsingFloat[5] = byteArray[position + 5];
            byteArrayForParsingFloat[6] = byteArray[position + 6];
            byteArrayForParsingFloat[7] = byteArray[position + 7];
            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing implicit and explicit DICOM data sets
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * reads an explicit data set
     * @param byteStream the byte stream to read from
     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)
     */
    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {

        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;
        options = options || {};

        if(byteStream === undefined)
        {
            throw "dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'";
        }
        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)
        {
            throw "dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'";
        }
        var elements = dataSet.elements;

        while(byteStream.position < maxPosition)
        {
            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);
            elements[element.tag] = element;
            if(element.tag === options.untilTag) {
                return;
            }
        }
        if(byteStream.position > maxPosition) {
            throw "dicomParser:parseDicomDataSetExplicit: buffer overrun";
        }
    };

    /**
     * reads an implicit data set
     * @param byteStream the byte stream to read from
     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)
     */
    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)
    {
        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;
        options = options || {};

        if(byteStream === undefined)
        {
            throw "dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'";
        }
        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)
        {
            throw "dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'";
        }

        var elements = dataSet.elements;

        while(byteStream.position < maxPosition)
        {
            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag, options.vrCallback);
            elements[element.tag] = element;
            if(element.tag === options.untilTag) {
                return;
            }
        }
    };

    return dicomParser;
}(dicomParser));

/**
 * Internal helper functions for for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function getDataLengthSizeInBytesForVR(vr)
    {
        if( vr === 'OB' ||
            vr === 'OW' ||
            vr === 'SQ' ||
            vr === 'OF' ||
            vr === 'UT' ||
            vr === 'UN')
        {
            return 4;
        }
        else
        {
            return 2;
        }
    }

    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            vr : byteStream.readFixedString(2)
            // length set below based on VR
            // dataOffset set below based on VR and size of length
        };

        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);
        if(dataLengthSizeBytes === 2)
        {
            element.length = byteStream.readUint16();
            element.dataOffset = byteStream.position;
        }
        else
        {
            byteStream.seek(2);
            element.length = byteStream.readUint32();
            element.dataOffset = byteStream.position;
        }

        if(element.length === 4294967295)
        {
            element.hadUndefinedLength = true;
        }

        if(element.tag === untilTag) {
            return element;
        }

        // if VR is SQ, parse the sequence items
        if(element.vr === 'SQ')
        {
            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);
            return element;
        }


        if(element.length === 4294967295)
        {
            if(element.tag === 'x7fe00010') {
                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);
                return element;
            }   else if(element.vr === 'UN') {
                dicomParser.findAndSetUNElementLength(byteStream, element);
                return element;
            } else {
                dicomParser.readSequenceItemsImplicit(byteStream, element);
                //dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);
                return element;
            }
        }

        byteStream.seek(element.length);
        return element;
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function isSequence(element, byteStream, vrCallback) {
        // if a data dictionary callback was provided, use that to verify that the element is a sequence.
        if (typeof vrCallback !== 'undefined') {
            return (vrCallback(element.tag) === 'SQ');
        }
        if ((byteStream.position + 4) <= byteStream.byteArray.length) {
            var nextTag = dicomParser.readTag(byteStream);
            byteStream.seek(-4);
            // Item start tag (fffe,e000) or sequence delimiter (i.e. end of sequence) tag (0fffe,e0dd)
            // These are the tags that could potentially be found directly after a sequence start tag (the delimiter
            // is found in the case of an empty sequence). This is not 100% safe because a non-sequence item
            // could have data that has these bytes, but this is how to do it without a data dictionary.
            return (nextTag === 'xfffee000') || (nextTag === 'xfffee0dd');
        }
        byteStream.warnings.push('eof encountered before finding sequence item tag or sequence delimiter tag in peeking to determine VR');
        return false;
    }

    dicomParser.readDicomElementImplicit = function(byteStream, untilTag, vrCallback)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            length: byteStream.readUint32(),
            dataOffset :  byteStream.position
        };

        if(element.length === 4294967295) {
            element.hadUndefinedLength = true;
        }

        if(element.tag === untilTag) {
            return element;
        }

        if (isSequence(element, byteStream, vrCallback)) {
            // parse the sequence
            dicomParser.readSequenceItemsImplicit(byteStream, element);
            return element;
        }

        // if element is not a sequence and has undefined length, we have to
        // scan the data for a magic number to figure out when it ends.
        if(element.hadUndefinedLength)
        {
            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);
            return element;
        }

        // non sequence element with known length, skip over the data part
        byteStream.seek(element.length);
        return element;
    };


    return dicomParser;
}(dicomParser));
/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  function findFragmentIndexWithOffset(fragments, offset) {
    for(var i=0; i < fragments.length; i++) {
      if(fragments[i].offset === offset) {
        return i;
      }
    }
  }

  function calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex) {
    // special case for last frame
    if(frameIndex === basicOffsetTable.length -1) {
      return fragments.length - startFragmentIndex;
    }

    // iterate through each fragment looking for the one matching the offset for the next frame
    var nextFrameOffset = basicOffsetTable[frameIndex + 1];
    for(var i=startFragmentIndex + 1; i < fragments.length; i++) {
      if(fragments[i].offset === nextFrameOffset) {
        return i - startFragmentIndex;
      }
    }

    throw "dicomParser.calculateNumberOfFragmentsForFrame: could not find fragment with offset matching basic offset table";
  }

  /**
   * Returns the pixel data for the specified frame in an encapsulated pixel data element that has a non
   * empty basic offset table.  Note that this function will fail if the basic offset table is empty - in that
   * case you need to determine which fragments map to which frames and read them using
   * readEncapsulatedPixelDataFromFragments().  Also see the function createJEPGBasicOffsetTable() to see
   * how a basic offset table can be created for JPEG images
   *
   * @param dataSet - the dataSet containing the encapsulated pixel data
   * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from
   * @param frameIndex - the zero based frame index
   * @param [basicOffsetTable] - optional array of starting offsets for frames
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {object} with the encapsulated pixel data
   */
  dicomParser.readEncapsulatedImageFrame = function(dataSet, pixelDataElement, frameIndex, basicOffsetTable, fragments)
  {
    // default parameters
    basicOffsetTable = basicOffsetTable || pixelDataElement.basicOffsetTable;
    fragments = fragments || pixelDataElement.fragments;

    // Validate parameters
    if(dataSet === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'dataSet'";
    }
    if(pixelDataElement === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'pixelDataElement'";
    }
    if(frameIndex === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'frameIndex'";
    }
    if(basicOffsetTable === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' does not have basicOffsetTable";
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have undefined length";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have fragments";
    }
    if(basicOffsetTable.length === 0) {
      throw "dicomParser.readEncapsulatedImageFrame: basicOffsetTable has zero entries";
    }
    if(frameIndex < 0) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be >= 0";
    }
    if(frameIndex >= basicOffsetTable.length) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be < basicOffsetTable.length";
    }

    // find starting fragment based on the offset for the frame in the basic offset table
    var offset = basicOffsetTable[frameIndex];
    var startFragmentIndex = findFragmentIndexWithOffset(fragments, offset);
    if(startFragmentIndex === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: unable to find fragment that matches basic offset table entry";
    }

    // calculate the number of fragments for this frame
    var numFragments = calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex);

    // now extract the frame from the fragments
    return dicomParser.readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments);
  };

  return dicomParser;
}(dicomParser));

/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  function calculateBufferSize(fragments, startFragment, numFragments) {
    var bufferSize = 0;
    for(var i=startFragment; i < startFragment + numFragments; i++) {
      bufferSize += fragments[i].length;
    }
    return bufferSize;
  }

  /**
   * Returns the encapsulated pixel data from the specified fragments.  Use this function when you know
   * the fragments you want to extract data from.  See
   *
   * @param dataSet - the dataSet containing the encapsulated pixel data
   * @param pixelDataElement - the pixel data element (x7fe00010) to extract the fragment data from
   * @param startFragmentIndex - zero based index of the first fragment to extract from
   * @param [numFragments] - the number of fragments to extract from, default is 1
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {object} byte array with the encapsulated pixel data
   */
  dicomParser.readEncapsulatedPixelDataFromFragments = function(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments)
  {
    // default values
    numFragments = numFragments || 1;
    fragments = fragments || pixelDataElement.fragments;

    // check parameters
    if(dataSet === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'dataSet'";
    }
    if(pixelDataElement === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'pixelDataElement'";
    }
    if(startFragmentIndex === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'startFragmentIndex'";
    }
    if(numFragments === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'numFragments'";
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.basicOffsetTable === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments.length <= 0) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(startFragmentIndex < 0) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be >= 0";
    }
    if(startFragmentIndex >= pixelDataElement.fragments.length) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be < number of fragments";
    }
    if(numFragments < 1) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'numFragments' must be > 0";
    }
    if(startFragmentIndex + numFragments > pixelDataElement.fragments.length) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragment' + 'numFragments' < number of fragments";
    }

    // create byte stream on the data for this pixel data element
    var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);

    // seek past the basic offset table (no need to parse it again since we already have)
    var basicOffsetTable = dicomParser.readSequenceItem(byteStream);
    if(basicOffsetTable.tag !== 'xfffee000')
    {
      throw "dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000";
    }
    byteStream.seek(basicOffsetTable.length);

    var fragmentZeroPosition = byteStream.position;
    var fragmentHeaderSize = 8; // tag + length

    // if there is only one fragment, return a view on this array to avoid copying
    if(numFragments === 1) {
      return dicomParser.sharedCopy(byteStream.byteArray, fragmentZeroPosition + fragments[startFragmentIndex].offset + fragmentHeaderSize, fragments[startFragmentIndex].length);
    }

    // more than one fragment, combine all of the fragments into one buffer
    var bufferSize = calculateBufferSize(fragments, startFragmentIndex, numFragments);

    var pixelData = dicomParser.alloc(byteStream.byteArray, bufferSize);

    var pixelDataIndex = 0;
    for(var i=startFragmentIndex; i < startFragmentIndex + numFragments; i++) {
      var fragmentOffset = fragmentZeroPosition + fragments[i].offset + fragmentHeaderSize;
      for(var j=0; j < fragments[i].length; j++) {
        pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];
      }
    }

    return pixelData;
  };

  return dicomParser;
}(dicomParser));

/**
 * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options
 * argument is supplied and it contains the untilTag property, parsing will stop once that
 * tag is encoutered.  This can be used to parse partial byte streams.
 *
 * @param byteArray the byte array
 * @param options object to control parsing behavior (optional)
 * @returns {DataSet}
 * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the
 *         elements successfully parsed before the error.
 */
var dicomParser = (function(dicomParser) {
  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  dicomParser.readPart10Header = function(byteArray, options) {

    if(byteArray === undefined)
    {
      throw "dicomParser.readPart10Header: missing required parameter 'byteArray'";
    }

    var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);

    function readPrefix()
    {
      littleEndianByteStream.seek(128);
      var prefix = littleEndianByteStream.readFixedString(4);
      if(prefix !== "DICM")
      {
        throw "dicomParser.readPart10Header: DICM prefix not found at location 132 - this is not a valid DICOM P10 file.";
      }
    }

    // main function here
    function readTheHeader() {
      // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)
      // so use littleEndianByteStream throughout this method regardless of the transfer syntax
      readPrefix();

      var warnings = [];
      var elements = {};
      while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {
        var position = littleEndianByteStream.position;
        var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);
        if(element.tag > 'x0002ffff') {
          littleEndianByteStream.position = position;
          break;
        }
        // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian
        // and this parser will be needed later if the meta header values are to be read.
        element.parser = dicomParser.littleEndianByteArrayParser;
        elements[element.tag] = element;
      }
      var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);
      metaHeaderDataSet.warnings = littleEndianByteStream.warnings;
      metaHeaderDataSet.position = littleEndianByteStream.position;
      return metaHeaderDataSet;
    }

    // This is where we actually start parsing
    return readTheHeader();
  };

  return dicomParser;
})(dicomParser);

/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)
    {
        var elements = {};

        while(byteStream.position < byteStream.byteArray.length)
        {
            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);
            elements[element.tag] = element;

            // we hit an item delimiter tag, return the current offset to mark
            // the end of this sequence item
            if(element.tag === 'xfffee00d')
            {
                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
            }

        }

        // eof encountered - log a warning and return what we have for the element
        warnings.push('eof encountered before finding item delimiter tag while reading sequence item of undefined length');
        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
    }

    function readSequenceItemExplicit(byteStream, warnings)
    {
        var item = dicomParser.readSequenceItem(byteStream);

        if(item.length === 4294967295)
        {
            item.hadUndefinedLength = true;
            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);
            item.length = byteStream.position - item.dataOffset;
        }
        else
        {
            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});
            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);
        }
        return item;
    }

    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)
    {
        while((byteStream.position + 4) <= byteStream.byteArray.length)
        {
          // end reading this sequence if the next tag is the sequence delimitation item
          var nextTag = dicomParser.readTag(byteStream);
          byteStream.seek(-4);
          if (nextTag === 'xfffee0dd') {
            // set the correct length
            element.length = byteStream.position - element.dataOffset;
            byteStream.seek(8);
            return element;
          }

            var item = readSequenceItemExplicit(byteStream, warnings);
            element.items.push(item);
        }
        warnings.push('eof encountered before finding sequence delimitation tag while reading sequence of undefined length');
        element.length = byteStream.position - element.dataOffset;
    }

    function readSQElementKnownLengthExplicit(byteStream, element, warnings)
    {
        var maxPosition = element.dataOffset + element.length;
        while(byteStream.position < maxPosition)
        {
            var item = readSequenceItemExplicit(byteStream, warnings);
            element.items.push(item);
        }
    }

    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'element'";
        }

        element.items = [];

        if(element.length === 4294967295)
        {
            readSQElementUndefinedLengthExplicit(byteStream, element, warnings);
        }
        else
        {
            readSQElementKnownLengthExplicit(byteStream, element, warnings);
        }
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback)
    {
        var elements = {};

        while(byteStream.position < byteStream.byteArray.length)
        {
            var element = dicomParser.readDicomElementImplicit(byteStream, undefined, vrCallback);
            elements[element.tag] = element;

            // we hit an item delimiter tag, return the current offset to mark
            // the end of this sequence item
            if(element.tag === 'xfffee00d')
            {
                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
            }
        }
        // eof encountered - log a warning and return what we have for the element
        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');
        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
    }

    function readSequenceItemImplicit(byteStream, vrCallback)
    {
        var item = dicomParser.readSequenceItem(byteStream);

        if(item.length === 4294967295)
        {
            item.hadUndefinedLength = true;
            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback);
            item.length = byteStream.position - item.dataOffset;
        }
        else
        {
            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});
            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length, {vrCallback: vrCallback});
        }
        return item;
    }

    function readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback)
    {
        while((byteStream.position + 4) <= byteStream.byteArray.length)
        {
          // end reading this sequence if the next tag is the sequence delimitation item
          var nextTag = dicomParser.readTag(byteStream);
          byteStream.seek(-4);
          if (nextTag === 'xfffee0dd') {
            // set the correct length
            element.length = byteStream.position - element.dataOffset;
            byteStream.seek(8);
            return element;
          }

          var item = readSequenceItemImplicit(byteStream, vrCallback);
          element.items.push(item);
        }
        byteStream.warnings.push('eof encountered before finding sequence delimiter in sequence of undefined length');
        element.length = byteStream.byteArray.length - element.dataOffset;
    }

    function readSQElementKnownLengthImplicit(byteStream, element, vrCallback)
    {
        var maxPosition = element.dataOffset + element.length;
        while(byteStream.position < maxPosition)
        {
            var item = readSequenceItemImplicit(byteStream, vrCallback);
            element.items.push(item);
        }
    }

    /**
     * Reads sequence items for an element in an implicit little endian byte stream
     * @param byteStream the implicit little endian byte stream
     * @param element the element to read the sequence items for
     * @param vrCallback an optional method that returns a VR string given a tag
     */
    dicomParser.readSequenceItemsImplicit = function(byteStream, element, vrCallback)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'element'";
        }

        element.items = [];

        if(element.length === 4294967295)
        {
            readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback);
        }
        else
        {
            readSQElementKnownLengthImplicit(byteStream, element, vrCallback);
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads the tag and length of a sequence item and returns them as an object with the following properties
     *  tag : string for the tag of this element in the format xggggeeee
     *  length: the number of bytes in this item or 4294967295 if undefined
     *  dataOffset: the offset into the byteStream of the data for this item
     * @param byteStream the byte
     * @returns {{tag: string, length: integer, dataOffset: integer}}
     */
    dicomParser.readSequenceItem = function(byteStream)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItem: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            length : byteStream.readUint32(),
            dataOffset :  byteStream.position
        };

        if (element.tag !== 'xfffee000') {
            var startPosition = byteStream.position;
            throw "dicomParser.readSequenceItem: item tag (FFFE,E000) not found at offset " + startPosition;
        }

        return element;
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads a tag (group number and element number) from a byteStream
     * @param byteStream the byte stream to read from
     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number
     * and eeee is the lower case hex value of the element number
     */
    dicomParser.readTag = function(byteStream)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readTag: missing required parameter 'byteStream'";
        }

        var groupNumber =  byteStream.readUint16() * 256 * 256;
        var elementNumber = byteStream.readUint16();
        var tag = "x" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);
        return tag;
    };

    return dicomParser;
}(dicomParser));
/**
 *
 * Internal helper function to create a shared copy of a byteArray
 *
 */
var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Creates a view of the underlying byteArray.  The view is of the same type as the byteArray (e.g.
   * Uint8Array or Buffer) and shares the same underlying memory (changing one changes the other)
   * @param byteArray the underlying byteArray (either Uint8Array or Buffer)
   * @param byteOffset offset into the underlying byteArray to create the view of
   * @param length number of bytes in the view
   * @returns {object} Uint8Array or Buffer depending on the type of byteArray
   */
  dicomParser.sharedCopy = function(byteArray, byteOffset, length) {
    if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {
      return byteArray.slice(byteOffset, byteOffset + length);
    }
    else if(byteArray instanceof Uint8Array) {
      return new Uint8Array(byteArray.buffer, byteArray.byteOffset + byteOffset, length);
    } else {
      throw 'dicomParser.from: unknown type for byteArray';
    }
  };

  return dicomParser;
}(dicomParser));
/**
 * Version
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  dicomParser.version = "1.7.3";

  return dicomParser;
}(dicomParser));
    return dicomParser;
}));

}).call(this,require("buffer").Buffer)

},{"buffer":20,"zlib":18}],26:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],27:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],28:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],29:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],30:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || function () {
    this.hSamp = 0; // Horizontal sampling factor
    this.quantTableSel = 0; // Quantization table destination selector
    this.vSamp = 0; // Vertical
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ComponentSpec;
}

},{}],31:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.DataStream = jpeg.lossless.DataStream || function (data, offset, length) {
    this.buffer = new DataView(data, offset, length);
    this.index = 0;
};



jpeg.lossless.DataStream.prototype.get16 = function () {
    var value = this.buffer.getUint16(this.index, false);
    this.index += 2;
    return value;
};



jpeg.lossless.DataStream.prototype.get8 = function () {
    var value = this.buffer.getUint8(this.index);
    this.index += 1;
    return value;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.DataStream;
}

},{}],32:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.Decoder = jpeg.lossless.Decoder || function (buffer, numBytes) {
    this.buffer = buffer;
    this.frame = new jpeg.lossless.FrameHeader();
    this.huffTable = new jpeg.lossless.HuffmanTable();
    this.quantTable = new jpeg.lossless.QuantizationTable();
    this.scan = new jpeg.lossless.ScanHeader();
    this.DU = jpeg.lossless.Utils.createArray(10, 4, 64); // at most 10 data units in a MCU, at most 4 data units in one component
    this.HuffTab = jpeg.lossless.Utils.createArray(4, 2, 50 * 256);
    this.IDCT_Source = [];
    this.nBlock = []; // number of blocks in the i-th Comp in a scan
    this.acTab = jpeg.lossless.Utils.createArray(10, 1); // ac HuffTab for the i-th Comp in a scan
    this.dcTab = jpeg.lossless.Utils.createArray(10, 1); // dc HuffTab for the i-th Comp in a scan
    this.qTab = jpeg.lossless.Utils.createArray(10, 1); // quantization table for the i-th Comp in a scan
    this.marker = 0;
    this.markerIndex = 0;
    this.numComp = 0;
    this.restartInterval = 0;
    this.selection = 0;
    this.xDim = 0;
    this.yDim = 0;
    this.xLoc = 0;
    this.yLoc = 0;
    this.numBytes = 0;
    this.outputData = null;
    this.restarting = false;
    this.mask = 0;

    if (typeof numBytes !== "undefined") {
        this.numBytes = numBytes;
    }
};


/*** Static Pseudo-constants ***/

jpeg.lossless.Decoder.IDCT_P = [0, 5, 40, 16, 45, 2, 7, 42, 21, 56, 8, 61, 18, 47, 1, 4, 41, 23, 58, 13, 32, 24, 37, 10, 63, 17, 44, 3, 6, 43, 20,
    57, 15, 34, 29, 48, 53, 26, 39, 9, 60, 19, 46, 22, 59, 12, 33, 31, 50, 55, 25, 36, 11, 62, 14, 35, 28, 49, 52, 27, 38, 30, 51, 54];
jpeg.lossless.Decoder.TABLE = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];
jpeg.lossless.Decoder.MAX_HUFFMAN_SUBTREE = 50;
jpeg.lossless.Decoder.MSB = 0x80000000;
jpeg.lossless.Decoder.RESTART_MARKER_BEGIN = 0xFFD0;
jpeg.lossless.Decoder.RESTART_MARKER_END = 0xFFD7;

/*** Prototype Methods ***/

jpeg.lossless.Decoder.prototype.decompress = function (buffer, offset, length) {
    return this.decode(buffer, offset, length).buffer;
};



jpeg.lossless.Decoder.prototype.decode = function (buffer, offset, length, numBytes) {
    /*jslint bitwise: true */

    var current, scanNum = 0, pred = [], i, compN, temp = [], index = [], mcuNum;

    if (typeof buffer !== "undefined") {
        this.buffer = buffer;
    }

    if (typeof numBytes !== "undefined") {
        this.numBytes = numBytes;
    }

    this.stream = new jpeg.lossless.DataStream(this.buffer, offset, length);
    this.buffer = null;

    this.xLoc = 0;
    this.yLoc = 0;
    current = this.stream.get16();

    if (current !== 0xFFD8) { // SOI
        throw new Error("Not a JPEG file");
    }

    current = this.stream.get16();

    while ((((current >> 4) !== 0x0FFC) || (current === 0xFFC4))) { // SOF 0~15
        switch (current) {
            case 0xFFC4: // DHT
                this.huffTable.read(this.stream, this.HuffTab);
                break;
            case 0xFFCC: // DAC
                throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
            case 0xFFDB:
                this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
                break;
            case 0xFFDD:
                this.restartInterval = this.readNumber();
                break;
            case 0xFFE0:
            case 0xFFE1:
            case 0xFFE2:
            case 0xFFE3:
            case 0xFFE4:
            case 0xFFE5:
            case 0xFFE6:
            case 0xFFE7:
            case 0xFFE8:
            case 0xFFE9:
            case 0xFFEA:
            case 0xFFEB:
            case 0xFFEC:
            case 0xFFED:
            case 0xFFEE:
            case 0xFFEF:
                this.readApp();
                break;
            case 0xFFFE:
                this.readComment();
                break;
            default:
                if ((current >> 8) !== 0xFF) {
                    throw new Error("ERROR: format throw new IOException! (decode)");
                }
        }

        current = this.stream.get16();
    }

    if ((current < 0xFFC0) || (current > 0xFFC7)) {
        throw new Error("ERROR: could not handle arithmetic code!");
    }

    this.frame.read(this.stream);
    current = this.stream.get16();

    do {
        while (current !== 0x0FFDA) { // SOS
            switch (current) {
                case 0xFFC4: // DHT
                    this.huffTable.read(this.stream, this.HuffTab);
                    break;
                case 0xFFCC: // DAC
                    throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
                case 0xFFDB:
                    this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
                    break;
                case 0xFFDD:
                    this.restartInterval = this.readNumber();
                    break;
                case 0xFFE0:
                case 0xFFE1:
                case 0xFFE2:
                case 0xFFE3:
                case 0xFFE4:
                case 0xFFE5:
                case 0xFFE6:
                case 0xFFE7:
                case 0xFFE8:
                case 0xFFE9:
                case 0xFFEA:
                case 0xFFEB:
                case 0xFFEC:
                case 0xFFED:
                case 0xFFEE:
                case 0xFFEF:
                    this.readApp();
                    break;
                case 0xFFFE:
                    this.readComment();
                    break;
                default:
                    if ((current >> 8) !== 0xFF) {
                        throw new Error("ERROR: format throw new IOException! (Parser.decode)");
                    }
            }

            current = this.stream.get16();
        }

        this.precision = this.frame.precision;
        this.components = this.frame.components;

        if (!this.numBytes) {
            this.numBytes = parseInt(Math.ceil(this.precision / 8));
        }

        if (this.numBytes == 1) {
            this.mask = 0xFF;
        } else {
            this.mask = 0xFFFF;
        }

        this.scan.read(this.stream);
        this.numComp = this.scan.numComp;
        this.selection = this.scan.selection;

        if (this.numBytes === 1) {
            if (this.numComp === 3) {
                this.getter = this.getValueRGB;
                this.setter = this.setValueRGB;
                this.output = this.outputRGB;
            } else {
                this.getter = this.getValue8;
                this.setter = this.setValue8;
                this.output = this.outputSingle;
            }
        } else {
            this.getter = this.getValue16;
            this.setter = this.setValue16;
            this.output = this.outputSingle;
        }

        switch (this.selection) {
            case 2:
                this.selector = this.select2;
                break;
            case 3:
                this.selector = this.select3;
                break;
            case 4:
                this.selector = this.select4;
                break;
            case 5:
                this.selector = this.select5;
                break;
            case 6:
                this.selector = this.select6;
                break;
            case 7:
                this.selector = this.select7;
                break;
            default:
                this.selector = this.select1;
                break;
        }

        this.scanComps = this.scan.components;
        this.quantTables = this.quantTable.quantTables;

        for (i = 0; i < this.numComp; i+=1) {
            compN = this.scanComps[i].scanCompSel;
            this.qTab[i] = this.quantTables[this.components[compN].quantTableSel];
            this.nBlock[i] = this.components[compN].vSamp * this.components[compN].hSamp;
            this.dcTab[i] = this.HuffTab[this.scanComps[i].dcTabSel][0];
            this.acTab[i] = this.HuffTab[this.scanComps[i].acTabSel][1];
        }

        this.xDim = this.frame.dimX;
        this.yDim = this.frame.dimY;
        this.outputData = new DataView(new ArrayBuffer(this.xDim * this.yDim * this.numBytes * this.numComp));

        scanNum+=1;

        while (true) { // Decode one scan
            temp[0] = 0;
            index[0] = 0;

            for (i = 0; i < 10; i+=1) {
                pred[i] = (1 << (this.precision - 1));
            }

            if (this.restartInterval === 0) {
                current = this.decodeUnit(pred, temp, index);

                while ((current === 0) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim))) {
                    this.output(pred);
                    current = this.decodeUnit(pred, temp, index);
                }

                break; //current=MARKER
            }

            for (mcuNum = 0; mcuNum < this.restartInterval; mcuNum+=1) {
                this.restarting = (mcuNum == 0);
                current = this.decodeUnit(pred, temp, index);
                this.output(pred);

                if (current !== 0) {
                    break;
                }
            }

            if (current === 0) {
                if (this.markerIndex !== 0) {
                    current = (0xFF00 | this.marker);
                    this.markerIndex = 0;
                } else {
                    current = this.stream.get16();
                }
            }

            if (!((current >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) &&
                (current <= jpeg.lossless.Decoder.RESTART_MARKER_END))) {
                break; //current=MARKER
            }
        }

        if ((current === 0xFFDC) && (scanNum === 1)) { //DNL
            this.readNumber();
            current = this.stream.get16();
        }
    } while ((current !== 0xFFD9) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) && (scanNum === 0));

    return this.outputData;
};



jpeg.lossless.Decoder.prototype.decodeUnit = function (prev, temp, index) {
    if (this.numComp == 1) {
        return this.decodeSingle(prev, temp, index);
    } else if (this.numComp == 3) {
        return this.decodeRGB(prev, temp, index);
    } else {
        return -1;
    }
};



jpeg.lossless.Decoder.prototype.select1 = function (compOffset) {
    return this.getPreviousX(compOffset);
};



jpeg.lossless.Decoder.prototype.select2 = function (compOffset) {
    return this.getPreviousY(compOffset);
};



jpeg.lossless.Decoder.prototype.select3 = function (compOffset) {
    return this.getPreviousXY(compOffset);
};



jpeg.lossless.Decoder.prototype.select4 = function (compOffset) {
    return (this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) - this.getPreviousXY(compOffset);
};



jpeg.lossless.Decoder.prototype.select5 = function (compOffset) {
    return this.getPreviousX(compOffset) + ((this.getPreviousY(compOffset) - this.getPreviousXY(compOffset)) >> 1);
};



jpeg.lossless.Decoder.prototype.select6 = function (compOffset) {
    return this.getPreviousY(compOffset) + ((this.getPreviousX(compOffset) - this.getPreviousXY(compOffset)) >> 1);
};



jpeg.lossless.Decoder.prototype.select7 = function (compOffset) {
    return ((this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) / 2);
};



jpeg.lossless.Decoder.prototype.decodeRGB = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, actab, dctab, qtab, ctrC, i, k, j;

    prev[0] = this.selector(0);
    prev[1] = this.selector(1);
    prev[2] = this.selector(2);

    for (ctrC = 0; ctrC < this.numComp; ctrC+=1) {
        qtab = this.qTab[ctrC];
        actab = this.acTab[ctrC];
        dctab = this.dcTab[ctrC];
        for (i = 0; i < this.nBlock[ctrC]; i+=1) {
            for (k = 0; k < this.IDCT_Source.length; k+=1) {
                this.IDCT_Source[k] = 0;
            }

            value = this.getHuffmanValue(dctab, temp, index);

            if (value >= 0xFF00) {
                return value;
            }

            prev[ctrC] = this.IDCT_Source[0] = prev[ctrC] + this.getn(index, value, temp, index);
            this.IDCT_Source[0] *= qtab[0];

            for (j = 1; j < 64; j+=1) {
                value = this.getHuffmanValue(actab, temp, index);

                if (value >= 0xFF00) {
                    return value;
                }

                j += (value >> 4);

                if ((value & 0x0F) === 0) {
                    if ((value >> 4) === 0) {
                        break;
                    }
                } else {
                    this.IDCT_Source[jpeg.lossless.Decoder.IDCT_P[j]] = this.getn(index, value & 0x0F, temp, index) * qtab[j];
                }
            }
        }
    }

    return 0;
};



jpeg.lossless.Decoder.prototype.decodeSingle = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, i, n, nRestart;

    if (this.restarting) {
        this.restarting = false;
        prev[0] = (1 << (this.frame.precision - 1));
    } else {
        prev[0] = this.selector();
    }

    for (i = 0; i < this.nBlock[0]; i+=1) {
        value = this.getHuffmanValue(this.dcTab[0], temp, index);
        if (value >= 0xFF00) {
            return value;
        }

        n = this.getn(prev, value, temp, index);
        nRestart = (n >> 8);

        if ((nRestart >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) && (nRestart <= jpeg.lossless.Decoder.RESTART_MARKER_END)) {
            return nRestart;
        }

        prev[0] += n;
    }

    return 0;
};



//	Huffman table for fast search: (HuffTab) 8-bit Look up table 2-layer search architecture, 1st-layer represent 256 node (8 bits) if codeword-length > 8
//	bits, then the entry of 1st-layer = (# of 2nd-layer table) | MSB and it is stored in the 2nd-layer Size of tables in each layer are 256.
//	HuffTab[*][*][0-256] is always the only 1st-layer table.
//
//	An entry can be: (1) (# of 2nd-layer table) | MSB , for code length > 8 in 1st-layer (2) (Code length) << 8 | HuffVal
//
//	HuffmanValue(table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                ):
//	    return: Huffman Value of table
//	            0xFF?? if it receives a MARKER
//	    Parameter:  table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                temp    temp storage for remainded bits
//	                index   index to bit of temp
//	                in      FILE pointer
//	    Effect:
//	        temp  store new remainded bits
//	        index change to new index
//	        in    change to new position
//	    NOTE:
//	      Initial by   temp=0; index=0;
//	    NOTE: (explain temp and index)
//	      temp: is always in the form at calling time or returning time
//	       |  byte 4  |  byte 3  |  byte 2  |  byte 1  |
//	       |     0    |     0    | 00000000 | 00000??? |  if not a MARKER
//	                                               ^index=3 (from 0 to 15)
//	                                               321
//	    NOTE (marker and marker_index):
//	      If get a MARKER from 'in', marker=the low-byte of the MARKER
//	        and marker_index=9
//	      If marker_index=9 then index is always > 8, or HuffmanValue()
//	        will not be called
jpeg.lossless.Decoder.prototype.getHuffmanValue = function (table, temp, index) {
    /*jslint bitwise: true */

    var code, input, mask;
    mask = 0xFFFF;

    if (index[0] < 8) {
        temp[0] <<= 8;
        input = this.stream.get8();
        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }
        temp[0] |= input;
    } else {
        index[0] -= 8;
    }

    code = table[temp[0] >> index[0]];

    if ((code & jpeg.lossless.Decoder.MSB) !== 0) {
        if (this.markerIndex !== 0) {
            this.markerIndex = 0;
            return 0xFF00 | this.marker;
        }

        temp[0] &= (mask >> (16 - index[0]));
        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }

        temp[0] |= input;
        code = table[((code & 0xFF) * 256) + (temp[0] >> index[0])];
        index[0] += 8;
    }

    index[0] += 8 - (code >> 8);

    if (index[0] < 0) {
        throw new Error("index=" + index[0] + " temp=" + temp[0] + " code=" + code + " in HuffmanValue()");
    }

    if (index[0] < this.markerIndex) {
        this.markerIndex = 0;
        return 0xFF00 | this.marker;
    }

    temp[0] &= (mask >> (16 - index[0]));
    return code & 0xFF;
};



jpeg.lossless.Decoder.prototype.getn = function (PRED, n, temp, index) {
    /*jslint bitwise: true */

    var result, one, n_one, mask, input;
    one = 1;
    n_one = -1;
    mask = 0xFFFF;

    if (n === 0) {
        return 0;
    }

    if (n === 16) {
        if (PRED[0] >= 0) {
            return -32768;
        } else {
            return 32768;
        }
    }

    index[0] -= n;

    if (index[0] >= 0) {
        if ((index[0] < this.markerIndex) && !this.isLastPixel()) { // this was corrupting the last pixel in some cases
            this.markerIndex = 0;
            return (0xFF00 | this.marker) << 8;
        }

        result = temp[0] >> index[0];
        temp[0] &= (mask >> (16 - index[0]));
    } else {
        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }

        temp[0] |= input;
        index[0] += 8;

        if (index[0] < 0) {
            if (this.markerIndex !== 0) {
                this.markerIndex = 0;
                return (0xFF00 | this.marker) << 8;
            }

            temp[0] <<= 8;
            input = this.stream.get8();

            if (input === 0xFF) {
                this.marker = this.stream.get8();
                if (this.marker !== 0) {
                    this.markerIndex = 9;
                }
            }

            temp[0] |= input;
            index[0] += 8;
        }

        if (index[0] < 0) {
            throw new Error("index=" + index[0] + " in getn()");
        }

        if (index[0] < this.markerIndex) {
            this.markerIndex = 0;
            return (0xFF00 | this.marker) << 8;
        }

        result = temp[0] >> index[0];
        temp[0] &= (mask >> (16 - index[0]));
    }

    if (result < (one << (n - 1))) {
        result += (n_one << n) + 1;
    }

    return result;
};



jpeg.lossless.Decoder.prototype.getPreviousX = function (compOffset) {
    /*jslint bitwise: true */

    if (this.xLoc > 0) {
        return this.getter((((this.yLoc * this.xDim) + this.xLoc) - 1), compOffset);
    } else if (this.yLoc > 0) {
        return this.getPreviousY(compOffset);
    } else {
        return (1 << (this.frame.precision - 1));
    }
};



jpeg.lossless.Decoder.prototype.getPreviousXY = function (compOffset) {
    /*jslint bitwise: true */

    if ((this.xLoc > 0) && (this.yLoc > 0)) {
        return this.getter(((((this.yLoc - 1) * this.xDim) + this.xLoc) - 1), compOffset);
    } else {
        return this.getPreviousY(compOffset);
    }
};



jpeg.lossless.Decoder.prototype.getPreviousY = function (compOffset) {
    /*jslint bitwise: true */

    if (this.yLoc > 0) {
        return this.getter((((this.yLoc - 1) * this.xDim) + this.xLoc), compOffset);
    } else {
        return this.getPreviousX(compOffset);
    }
};



jpeg.lossless.Decoder.prototype.isLastPixel = function () {
    return (this.xLoc === (this.xDim - 1)) && (this.yLoc === (this.yDim - 1));
};



jpeg.lossless.Decoder.prototype.outputSingle = function (PRED) {
    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
        this.setter((((this.yLoc * this.xDim) + this.xLoc)), this.mask & PRED[0]);

        this.xLoc+=1;

        if (this.xLoc >= this.xDim) {
            this.yLoc+=1;
            this.xLoc = 0;
        }
    }
};



jpeg.lossless.Decoder.prototype.outputRGB = function (PRED) {
    var offset = ((this.yLoc * this.xDim) + this.xLoc);

    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
        this.setter(offset, PRED[0], 0);
        this.setter(offset, PRED[1], 1);
        this.setter(offset, PRED[2], 2);

        this.xLoc+=1;

        if (this.xLoc >= this.xDim) {
            this.yLoc+=1;
            this.xLoc = 0;
        }
    }
};



jpeg.lossless.Decoder.prototype.setValue16 = function (index, val) {
    this.outputData.setInt16(index * 2, val, true);
};



jpeg.lossless.Decoder.prototype.getValue16 = function (index) {
    return this.outputData.getInt16(index * 2, true);
};



jpeg.lossless.Decoder.prototype.setValue8 = function (index, val) {
    this.outputData.setInt8(index, val);
};



jpeg.lossless.Decoder.prototype.getValue8 = function (index) {
    return this.outputData.getInt8(index);
};



jpeg.lossless.Decoder.prototype.setValueRGB = function (index, val, compOffset) {
    this.outputData.setUint8(index * 3 + compOffset, val);
};



jpeg.lossless.Decoder.prototype.getValueRGB = function (index, compOffset) {
    return this.outputData.getUint8(index * 3 + compOffset);
};



jpeg.lossless.Decoder.prototype.readApp = function() {
    var count = 0, length = this.stream.get16();
    count += 2;

    while (count < length) {
        this.stream.get8();
        count+=1;
    }

    return length;
};



jpeg.lossless.Decoder.prototype.readComment = function () {
    var sb = "", count = 0, length;

    length = this.stream.get16();
    count += 2;

    while (count < length) {
        sb += this.stream.get8();
        count+=1;
    }

    return sb;
};



jpeg.lossless.Decoder.prototype.readNumber = function() {
    var Ld = this.stream.get16();

    if (Ld !== 4) {
        throw new Error("ERROR: Define number format throw new IOException [Ld!=4]");
    }

    return this.stream.get16();
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Decoder;
}

},{"./data-stream.js":31,"./frame-header.js":33,"./huffman-table.js":34,"./quantization-table.js":36,"./scan-header.js":38,"./utils.js":39}],33:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);


/*** Constructor ***/
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || function () {
    this.components = []; // Components
    this.dimX = 0; // Number of samples per line
    this.dimY = 0; // Number of lines
    this.numComp = 0; // Number of component in the frame
    this.precision = 0; // Sample Precision (from the original image)
};



/*** Prototype Methods ***/

jpeg.lossless.FrameHeader.prototype.read = function (data) {
    /*jslint bitwise: true */

    var count = 0, length, i, c, temp;

    length = data.get16();
    count += 2;

    this.precision = data.get8();
    count+=1;

    this.dimY = data.get16();
    count += 2;

    this.dimX = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;
    for (i = 1; i <= this.numComp; i+=1) {
        if (count > length) {
            throw new Error("ERROR: frame format error");
        }

        c = data.get8();
        count+=1;

        if (count >= length) {
            throw new Error("ERROR: frame format error [c>=Lf]");
        }

        temp = data.get8();
        count+=1;

        if (!this.components[c]) {
            this.components[c] = new jpeg.lossless.ComponentSpec();
        }

        this.components[c].hSamp = temp >> 4;
        this.components[c].vSamp = temp & 0x0F;
        this.components[c].quantTableSel = data.get8();
        count+=1;
    }

    if (count !== length) {
        throw new Error("ERROR: frame format error [Lf!=count]");
    }

    return 1;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.FrameHeader;
}

},{"./component-spec.js":30,"./data-stream.js":31}],34:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || function () {
    this.l = jpeg.lossless.Utils.createArray(4, 2, 16);
    this.th = [];
    this.v = jpeg.lossless.Utils.createArray(4, 2, 16, 200);
    this.tc = jpeg.lossless.Utils.createArray(4, 2);

    this.tc[0][0] = 0;
    this.tc[1][0] = 0;
    this.tc[2][0] = 0;
    this.tc[3][0] = 0;
    this.tc[0][1] = 0;
    this.tc[1][1] = 0;
    this.tc[2][1] = 0;
    this.tc[3][1] = 0;
    this.th[0] = 0;
    this.th[1] = 0;
    this.th[2] = 0;
    this.th[3] = 0;
};



/*** Static Pseudo-constants ***/

jpeg.lossless.HuffmanTable.MSB = 0x80000000;


/*** Prototype Methods ***/

jpeg.lossless.HuffmanTable.prototype.read = function(data, HuffTab) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, c, i, j;

    length = data.get16();
    count += 2;

    while (count < length) {
        temp = data.get8();
        count+=1;
        t = temp & 0x0F;
        if (t > 3) {
            throw new Error("ERROR: Huffman table ID > 3");
        }

        c = temp >> 4;
        if (c > 2) {
            throw new Error("ERROR: Huffman table [Table class > 2 ]");
        }

        this.th[t] = 1;
        this.tc[t][c] = 1;

        for (i = 0; i < 16; i+=1) {
            this.l[t][c][i] = data.get8();
            count+=1;
        }

        for (i = 0; i < 16; i+=1) {
            for (j = 0; j < this.l[t][c][i]; j+=1) {
                if (count > length) {
                    throw new Error("ERROR: Huffman table format error [count>Lh]");
                }

                this.v[t][c][i][j] = data.get8();
                count+=1;
            }
        }
    }

    if (count !== length) {
        throw new Error("ERROR: Huffman table format error [count!=Lf]");
    }

    for (i = 0; i < 4; i+=1) {
        for (j = 0; j < 2; j+=1) {
            if (this.tc[i][j] !== 0) {
                this.buildHuffTable(HuffTab[i][j], this.l[i][j], this.v[i][j]);
            }
        }
    }

    return 1;
};



//	Build_HuffTab()
//	Parameter:  t       table ID
//	            c       table class ( 0 for DC, 1 for AC )
//	            L[i]    # of codewords which length is i
//	            V[i][j] Huffman Value (length=i)
//	Effect:
//	    build up HuffTab[t][c] using L and V.
jpeg.lossless.HuffmanTable.prototype.buildHuffTable = function(tab, L, V) {
    /*jslint bitwise: true */

    var currentTable, temp, k, i, j, n;
    temp = 256;
    k = 0;

    for (i = 0; i < 8; i+=1) { // i+1 is Code length
        for (j = 0; j < L[i]; j+=1) {
            for (n = 0; n < (temp >> (i + 1)); n+=1) {
                tab[k] = V[i][j] | ((i + 1) << 8);
                k+=1;
            }
        }
    }

    for (i = 1; k < 256; i+=1, k+=1) {
        tab[k] = i | jpeg.lossless.HuffmanTable.MSB;
    }

    currentTable = 1;
    k = 0;

    for (i = 8; i < 16; i+=1) { // i+1 is Code length
        for (j = 0; j < L[i]; j+=1) {
            for (n = 0; n < (temp >> (i - 7)); n+=1) {
                tab[(currentTable * 256) + k] = V[i][j] | ((i + 1) << 8);
                k+=1;
            }

            if (k >= 256) {
                if (k > 256) {
                    throw new Error("ERROR: Huffman table error(1)!");
                }

                k = 0;
                currentTable+=1;
            }
        }
    }
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.HuffmanTable;
}

},{"./data-stream.js":31,"./utils.js":39}],35:[function(require,module,exports){
/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Decoder = jpeg.lossless.Decoder || ((typeof require !== 'undefined') ? require('./decoder.js') : null);
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Exports ***/
var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg;
}

},{"./component-spec.js":30,"./data-stream.js":31,"./decoder.js":32,"./frame-header.js":33,"./huffman-table.js":34,"./quantization-table.js":36,"./scan-component.js":37,"./scan-header.js":38,"./utils.js":39}],36:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || function () {
    this.precision = []; // Quantization precision 8 or 16
    this.tq = []; // 1: this table is presented
    this.quantTables = jpeg.lossless.Utils.createArray(4, 64); // Tables

    this.tq[0] = 0;
    this.tq[1] = 0;
    this.tq[2] = 0;
    this.tq[3] = 0;
};



/*** Static Methods ***/

jpeg.lossless.QuantizationTable.enhanceQuantizationTable = function(qtab, table) {
    /*jslint bitwise: true */

    var i;

    for (i = 0; i < 8; i+=1) {
        qtab[table[(0 * 8) + i]] *= 90;
        qtab[table[(4 * 8) + i]] *= 90;
        qtab[table[(2 * 8) + i]] *= 118;
        qtab[table[(6 * 8) + i]] *= 49;
        qtab[table[(5 * 8) + i]] *= 71;
        qtab[table[(1 * 8) + i]] *= 126;
        qtab[table[(7 * 8) + i]] *= 25;
        qtab[table[(3 * 8) + i]] *= 106;
    }

    for (i = 0; i < 8; i+=1) {
        qtab[table[0 + (8 * i)]] *= 90;
        qtab[table[4 + (8 * i)]] *= 90;
        qtab[table[2 + (8 * i)]] *= 118;
        qtab[table[6 + (8 * i)]] *= 49;
        qtab[table[5 + (8 * i)]] *= 71;
        qtab[table[1 + (8 * i)]] *= 126;
        qtab[table[7 + (8 * i)]] *= 25;
        qtab[table[3 + (8 * i)]] *= 106;
    }

    for (i = 0; i < 64; i+=1) {
        qtab[i] >>= 6;
    }
};


/*** Prototype Methods ***/

jpeg.lossless.QuantizationTable.prototype.read = function (data, table) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, i;

    length = data.get16();
    count += 2;

    while (count < length) {
        temp = data.get8();
        count+=1;
        t = temp & 0x0F;

        if (t > 3) {
            throw new Error("ERROR: Quantization table ID > 3");
        }

        this.precision[t] = temp >> 4;

        if (this.precision[t] === 0) {
            this.precision[t] = 8;
        } else if (this.precision[t] === 1) {
            this.precision[t] = 16;
        } else {
            throw new Error("ERROR: Quantization table precision error");
        }

        this.tq[t] = 1;

        if (this.precision[t] === 8) {
            for (i = 0; i < 64; i+=1) {
                if (count > length) {
                    throw new Error("ERROR: Quantization table format error");
                }

                this.quantTables[t][i] = data.get8();
                count+=1;
            }

            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
        } else {
            for (i = 0; i < 64; i+=1) {
                if (count > length) {
                    throw new Error("ERROR: Quantization table format error");
                }

                this.quantTables[t][i] = data.get16();
                count += 2;
            }

            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
        }
    }

    if (count !== length) {
        throw new Error("ERROR: Quantization table error [count!=Lq]");
    }

    return 1;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.QuantizationTable;
}

},{"./data-stream.js":31,"./utils.js":39}],37:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || function () {
    this.acTabSel = 0; // AC table selector
    this.dcTabSel = 0; // DC table selector
    this.scanCompSel = 0; // Scan component selector
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanComponent;
}

},{}],38:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);


/*** Constructor ***/
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || function () {
    this.ah = 0;
    this.al = 0;
    this.numComp = 0; // Number of components in the scan
    this.selection = 0; // Start of spectral or predictor selection
    this.spectralEnd = 0; // End of spectral selection
    this.components = [];
};


/*** Prototype Methods ***/

jpeg.lossless.ScanHeader.prototype.read = function(data) {
    /*jslint bitwise: true */

    var count = 0, length, i, temp;

    length = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;

    for (i = 0; i < this.numComp; i+=1) {
        this.components[i] = new jpeg.lossless.ScanComponent();

        if (count > length) {
            throw new Error("ERROR: scan header format error");
        }

        this.components[i].scanCompSel = data.get8();
        count+=1;

        temp = data.get8();
        count+=1;

        this.components[i].dcTabSel = (temp >> 4);
        this.components[i].acTabSel = (temp & 0x0F);
    }

    this.selection = data.get8();
    count+=1;

    this.spectralEnd = data.get8();
    count+=1;

    temp = data.get8();
    this.ah = (temp >> 4);
    this.al = (temp & 0x0F);
    count+=1;

    if (count !== length) {
        throw new Error("ERROR: scan header format error [count!=Ns]");
    }

    return 1;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanHeader;
}

},{"./data-stream.js":31,"./scan-component.js":37}],39:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.Utils = jpeg.lossless.Utils || {};


/*** Static methods ***/

// http://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
jpeg.lossless.Utils.createArray = function (length) {
    var arr = new Array(length || 0),
        i = length;

    if (arguments.length > 1) {
        var args = Array.prototype.slice.call(arguments, 1);
        while(i--) arr[length-1 - i] = jpeg.lossless.Utils.createArray.apply(this, args);
    }

    return arr;
};


// http://stackoverflow.com/questions/18638900/javascript-crc32
jpeg.lossless.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};

jpeg.lossless.Utils.crc32 = function(dataView) {
    var crcTable = jpeg.lossless.Utils.crcTable || (jpeg.lossless.Utils.crcTable = jpeg.lossless.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Utils;
}

},{}],40:[function(require,module,exports){
'use strict';

/**
* FUNCTION: abs( x )
*	Computes the absolute value of `x`.
*
* @param {Number} x - input value
* @returns {Number} absolute value
*/
function abs( x ) {
	if ( x < 0 ) {
		return -x;
	}
	if ( x === 0 ) {
		return 0; // handle negative zero
	}
	return x;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{}],41:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.ceil;

},{}],42:[function(require,module,exports){
'use strict';

// MODULES //

var floor = require( 'math-floor' );


// DIV2 //

/**
* FUNCTION: div2( x )
*	Converts a nonnegative integer to a literal bit representation using the divide-by-2 algorithm.
*
* @param {Number} x - nonnegative integer
* @returns {String} bit representation
*/
function div2( x ) {
	var str = '';
	var y;

	// We repeatedly divide by 2 and check for a remainder. If a remainder exists, the number is odd and we add a '1' bit...
	while ( x > 0 ) {
		y = x / 2;
		x = floor( y );
		if ( y === x ) {
			str = '0' + str;
		} else {
			str = '1' + str;
		}
	}
	return str;
} // end FUNCTION div2()


// EXPORTS //

module.exports = div2;

},{"math-floor":45}],43:[function(require,module,exports){
'use strict';

// MODULES //

var pinf = require( 'const-pinf-float32' );
var ninf = require( 'const-ninf-float32' );
var abs = require( 'math-abs' );
var floor = require( 'math-floor' );
var rpad = require( 'utils-right-pad-string' );
var lpad = require( 'utils-left-pad-string' );
var repeat = require( 'utils-repeat-string' );
var div2 = require( './div2.js' );
var mult2 = require( './mult2.js' );


// CONSTANTS //

var BIAS = 127; // exponent bias => (2**8)/2 - 1


// BINARY STRING //

/**
* FUNCTION: binaryString( x )
*	Returns a string giving the literal bit representation of a single-precision floating-point number.
*
* @param {Number} x - input value
* @returns {String} bit representation
*/
function binaryString( x ) {
	var nbits;
	var sign;
	var str;
	var exp;
	var n;
	var f;
	var i;

	// Check for a negative value or negative zero...
	if ( x < 0 || 1/x === ninf ) {
		sign = '1';
	} else {
		sign = '0';
	}
	// Special case: +-infinity
	if ( x === pinf || x === ninf ) {
		// Based on IEEE 754-2008...
		exp = repeat( '1', 8 ); // all 1s
		str = repeat( '0', 23 ); // all 0s
		return sign + exp + str;
	}
	// Special case: NaN
	if ( x !== x ) {
		// Based on IEEE 754-2008...
		exp = repeat( '1', 8 ); // all 1s
		str = '1' + repeat( '0', 22 ); // can't be all 0s
		return sign + exp + str;
	}
	// Special case: +-0
	if ( x === 0 ) {
		// Based on IEEE 754-2008...
		exp = repeat( '0', 8 ); // all 0s
		str = repeat( '0', 23 ); // all 0s
		return sign + exp + str;
	}
	x = abs( x );

	// Isolate the integer part (digits before the decimal):
	n = floor( x );

	// Isolate the fractional part (digits after the decimal):
	f = x - n;

	// Convert the integer and fractional parts to bit strings:
	n = div2( n );
	f = mult2( f );

	// Determine the exponent needed to normalize the integer+fractional parts...
	if ( n ) {
		// Move the decimal `d` digits to the left:
		exp = n.length - 1;
	} else {
		// Find the first '1' bit...
		for ( i = 0; i < f.length; i++ ) {
			if ( f[ i ] === '1' ) {
				nbits = i + 1;
				break;
			}
		}
		// Move the decimal `d` digits to the right:
		exp = -nbits;
	}
	// Normalize the combined integer+fractional string...
	str = n + f;
	if ( exp < 0 ) {
		// Handle subnormals...
		if ( exp <= -BIAS ) {
			// Cap the number of bits removed:
			nbits = BIAS - 1;
		}
		// Remove all leading zeros and the first '1' for normal values, and, for subnormals, remove at most BIAS-1 leading bits:
		str = str.substring( nbits );
	} else {
		// Remove the leading '1' (implicit/hidden bit):
		str = str.substring( 1 );
	}
	// Convert the exponent to a bit string:
	exp = div2( exp + BIAS );
	exp = lpad( exp, 8, '0' );

	// Fill in any trailing zeros and ensure we have only 23 fraction bits:
	str = rpad( str, 23, '0' ).substring( 0, 23 );

	// Return a bit representation:
	return sign + exp + str;
} // end FUNCTION binaryString()


// EXPORTS //

module.exports = binaryString;

},{"./div2.js":42,"./mult2.js":44,"const-ninf-float32":22,"const-pinf-float32":23,"math-abs":40,"math-floor":45,"utils-left-pad-string":87,"utils-repeat-string":88,"utils-right-pad-string":89}],44:[function(require,module,exports){
'use strict';

// VARIABLES //

var MAX_ITER = 149; // 127+22 (subnormals)
var MAX_BITS = 24; // only 23 bits for fraction


// MULT2 //

/**
* FUNCTION: mult2( x )
*	Converts a fraction to a literal bit representation using the multiply-by-2 algorithm.
*
* @param {Number} x - number less than 1
* @returns {String} bit representation
*/
function mult2( x ) {
	var str;
	var y;
	var i;
	var j;

	str = '';
	if ( x === 0 ) {
		return str;
	}
	j = MAX_ITER;

	// Each time we multiply by 2 and find a ones digit, add a '1'; otherwise, add a '0'..
	for ( i = 0; i < MAX_ITER; i++ ) {
		y = x * 2;
		if ( y >= 1 ) {
			x = y - 1;
			str += '1';
			if ( j === MAX_ITER ) {
				j = i; // first '1'
			}
		} else {
			x = y;
			str += '0';
		}
		// Stop when we have no more decimals to process or in the event we found a fraction which cannot be represented in a finite number of bits...
		if ( y === 1 || i-j > MAX_BITS ) {
			break;
		}
	}
	return str;
} // end FUNCTION mult2()


// EXPORTS //

module.exports = mult2;

},{}],45:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.floor;

},{}],46:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/

/**
 * nifti
 * @type {*|{}}
 */
var nifti = nifti || {};
nifti.NIFTI1 = nifti.NIFTI1 || ((typeof require !== 'undefined') ? require('./nifti1.js') : null);
nifti.NIFTI2 = nifti.NIFTI2 || ((typeof require !== 'undefined') ? require('./nifti2.js') : null);
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);

var pako = pako || ((typeof require !== 'undefined') ? require('pako') : null);



/*** Static Methods ***/

/**
 * Returns true if this data represents a NIFTI-1 header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI1 = function (data) {
    var buf, mag1, mag2, mag3;

    buf = new DataView(data);
    mag1 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION);
    mag2 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 1);
    mag3 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 2);

    return !!((mag1 === nifti.NIFTI1.MAGIC_NUMBER[0]) && (mag2 === nifti.NIFTI1.MAGIC_NUMBER[1]) &&
        (mag3 === nifti.NIFTI1.MAGIC_NUMBER[2]));
};


/**
 * Returns true if this data represents a NIFTI-2 header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI2 = function (data) {
    var buf, mag1, mag2, mag3;

    buf = new DataView(data);
    mag1 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION);
    mag2 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 1);
    mag3 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 2);

    return !!((mag1 === nifti.NIFTI2.MAGIC_NUMBER[0]) && (mag2 === nifti.NIFTI2.MAGIC_NUMBER[1]) &&
    (mag3 === nifti.NIFTI2.MAGIC_NUMBER[2]));
};



/**
 * Returns true if this data represents a NIFTI header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI = function (data) {
    return (nifti.isNIFTI1(data) || nifti.isNIFTI2(data));
};



/**
 * Returns true if this data is GZIP compressed.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isCompressed = function (data) {
    var buf, magicCookie1, magicCookie2;

    if (data) {
        buf = new DataView(data);

        magicCookie1 = buf.getUint8(0);
        magicCookie2 = buf.getUint8(1);

        if (magicCookie1 === nifti.Utils.GUNZIP_MAGIC_COOKIE1) {
            return true;
        }

        if (magicCookie2 === nifti.Utils.GUNZIP_MAGIC_COOKIE2) {
            return true;
        }
    }

    return false;
};



/**
 * Returns decompressed data.
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.decompress = function (data) {
    return pako.inflate(data).buffer;
};



/**
 * Reads and returns the header object.
 * @param {ArrayBuffer} data
 * @returns {nifti.NIFTI1|nifti.NIFTI2|null}
 */
nifti.readHeader = function (data) {
    var header = null;

    if (nifti.isCompressed(data)) {
        data = nifti.decompress(data);
    }

    if (nifti.isNIFTI1(data)) {
        header = new nifti.NIFTI1();
    } else if (nifti.isNIFTI2(data)) {
        header = new nifti.NIFTI2();
    }

    if (header) {
        header.readHeader(data);
    } else {
        console.error("That file does not appear to be NIFTI!");
    }

    return header;
};



/**
 * Returns true if this header contains an extension.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @returns {boolean}
 */
nifti.hasExtension = function (header) {
    return (header.extensionFlag[0] != 0);
};



/**
 * Returns the image data.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readImage = function (header, data) {
    var imageOffset = header.vox_offset,
        timeDim = 1,
        statDim = 1;

    if (header.dims[4]) {
        timeDim = header.dims[4];
    }

    if (header.dims[5]) {
        statDim = header.dims[5];
    }

    var imageSize = header.dims[1] * header.dims[2] * header.dims[3] * timeDim * statDim * (header.numBitsPerVoxel / 8);
    return data.slice(imageOffset, imageOffset + imageSize);
};



/**
 * Returns the extension data (including extension header).
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readExtension = function (header, data) {
    var loc = header.getExtensionLocation(),
        size = header.extensionSize;

    return data.slice(loc, loc + size);
};



/**
 * Returns the extension data.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readExtensionData = function (header, data) {
    var loc = header.getExtensionLocation(),
        size = header.extensionSize;

    return data.slice(loc + 8, loc + size - 8);
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti;
}

},{"./nifti1.js":47,"./nifti2.js":48,"./utilities.js":49,"pako":51}],47:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);



/*** Constructor ***/

/**
 * The NIFTI1 constructor.
 * @constructor
 * @property {boolean} littleEndian
 * @property {number} dim_info
 * @property {number[]} dims - image dimensions
 * @property {number} intent_p1
 * @property {number} intent_p2
 * @property {number} intent_p3
 * @property {number} intent_code
 * @property {number} datatypeCode
 * @property {number} numBitsPerVoxel
 * @property {number} slice_start
 * @property {number} slice_end
 * @property {number} slice_code
 * @property {number[]} pixDims - voxel dimensions
 * @property {number} vox_offset
 * @property {number} scl_slope
 * @property {number} scl_inter
 * @property {number} xyzt_units
 * @property {number} cal_max
 * @property {number} cal_min
 * @property {number} slice_duration
 * @property {number} toffset
 * @property {string} description
 * @property {string} aux_file
 * @property {string} intent_name
 * @property {number} qform_code
 * @property {number} sform_code
 * @property {number} quatern_b
 * @property {number} quatern_c
 * @property {number} quatern_d
 * @property {number} quatern_x
 * @property {number} quatern_y
 * @property {number} quatern_z
 * @property {Array.<Array.<number>>} affine
 * @property {string} magic
 * @property {boolean} isHDR - if hdr/img format
 * @property {number[]} extensionFlag
 * @property {number} extensionSize
 * @property {number} extensionCode
 * @type {Function}
 */
nifti.NIFTI1 = nifti.NIFTI1 || function () {
    this.littleEndian = false;
    this.dim_info = 0;
    this.dims = [];
    this.intent_p1 = 0;
    this.intent_p2 = 0;
    this.intent_p3 = 0;
    this.intent_code = 0;
    this.datatypeCode = 0;
    this.numBitsPerVoxel = 0;
    this.slice_start = 0;
    this.slice_end = 0;
    this.slice_code = 0;
    this.pixDims = [];
    this.vox_offset = 0;
    this.scl_slope = 1;
    this.scl_inter = 0;
    this.xyzt_units = 0;
    this.cal_max = 0;
    this.cal_min = 0;
    this.slice_duration = 0;
    this.toffset = 0;
    this.description = "";
    this.aux_file = "";
    this.intent_name = "";
    this.qform_code = 0;
    this.sform_code = 0;
    this.quatern_b = 0;
    this.quatern_c = 0;
    this.quatern_d = 0;
    this.qoffset_x = 0;
    this.qoffset_y = 0;
    this.qoffset_z = 0;
    this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    this.magic = 0;
    this.isHDR = false;
    this.extensionFlag = [0, 0, 0, 0];
    this.extensionSize = 0;
    this.extensionCode = 0;
};



/*** Static Pseudo-constants ***/

// datatype codes
nifti.NIFTI1.TYPE_NONE            = 0;
nifti.NIFTI1.TYPE_BINARY          = 1;
nifti.NIFTI1.TYPE_UINT8           = 2;
nifti.NIFTI1.TYPE_INT16           = 4;
nifti.NIFTI1.TYPE_INT32           = 8;
nifti.NIFTI1.TYPE_FLOAT32        = 16;
nifti.NIFTI1.TYPE_COMPLEX64      = 32;
nifti.NIFTI1.TYPE_FLOAT64        = 64;
nifti.NIFTI1.TYPE_RGB24         = 128;
nifti.NIFTI1.TYPE_INT8          = 256;
nifti.NIFTI1.TYPE_UINT16        = 512;
nifti.NIFTI1.TYPE_UINT32        = 768;
nifti.NIFTI1.TYPE_INT64        = 1024;
nifti.NIFTI1.TYPE_UINT64       = 1280;
nifti.NIFTI1.TYPE_FLOAT128     = 1536;
nifti.NIFTI1.TYPE_COMPLEX128   = 1792;
nifti.NIFTI1.TYPE_COMPLEX256   = 2048;

// transform codes
nifti.NIFTI1.XFORM_UNKNOWN        = 0;
nifti.NIFTI1.XFORM_SCANNER_ANAT   = 1;
nifti.NIFTI1.XFORM_ALIGNED_ANAT   = 2;
nifti.NIFTI1.XFORM_TALAIRACH      = 3;
nifti.NIFTI1.XFORM_MNI_152        = 4;

// unit codes
nifti.NIFTI1.SPATIAL_UNITS_MASK = 0x07;
nifti.NIFTI1.TEMPORAL_UNITS_MASK = 0x38;
nifti.NIFTI1.UNITS_UNKNOWN        = 0;
nifti.NIFTI1.UNITS_METER          = 1;
nifti.NIFTI1.UNITS_MM             = 2;
nifti.NIFTI1.UNITS_MICRON         = 3;
nifti.NIFTI1.UNITS_SEC            = 8;
nifti.NIFTI1.UNITS_MSEC          = 16;
nifti.NIFTI1.UNITS_USEC          = 24;
nifti.NIFTI1.UNITS_HZ            = 32;
nifti.NIFTI1.UNITS_PPM           = 40;
nifti.NIFTI1.UNITS_RADS          = 48;

// nifti1 codes
nifti.NIFTI1.MAGIC_COOKIE = 348;
nifti.NIFTI1.MAGIC_NUMBER_LOCATION = 344;
nifti.NIFTI1.MAGIC_NUMBER = [0x6E, 0x2B, 0x31];  // n+1 (.nii)
nifti.NIFTI1.MAGIC_NUMBER2 = [0x6E, 0x69, 0x31];  // ni1 (.hdr/.img)
nifti.NIFTI1.EXTENSION_HEADER_SIZE = 8;


/*** Prototype Methods ***/

/**
 * Reads the header data.
 * @param {ArrayBuffer} data
 */
nifti.NIFTI1.prototype.readHeader = function (data) {
    var rawData = new DataView(data),
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian),
        ctr,
        ctrOut,
        ctrIn,
        index;

    if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {  // try as little endian
        this.littleEndian = true;
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
    }

    if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {
        throw new Error("This does not appear to be a NIFTI file!");
    }

    this.dim_info = nifti.Utils.getByteAt(rawData, 39);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 40 + (ctr * 2);
        this.dims[ctr] = nifti.Utils.getShortAt(rawData, index, this.littleEndian);
    }

    this.intent_p1 = nifti.Utils.getFloatAt(rawData, 56, this.littleEndian);
    this.intent_p2 = nifti.Utils.getFloatAt(rawData, 60, this.littleEndian);
    this.intent_p3 = nifti.Utils.getFloatAt(rawData, 64, this.littleEndian);
    this.intent_code = nifti.Utils.getShortAt(rawData, 68, this.littleEndian);

    this.datatypeCode = nifti.Utils.getShortAt(rawData, 70, this.littleEndian);
    this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 72, this.littleEndian);

    this.slice_start = nifti.Utils.getShortAt(rawData, 74, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 76 + (ctr * 4);
        this.pixDims[ctr] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
    }

    this.vox_offset = nifti.Utils.getFloatAt(rawData, 108, this.littleEndian);

    this.scl_slope = nifti.Utils.getFloatAt(rawData, 112, this.littleEndian);
    this.scl_inter = nifti.Utils.getFloatAt(rawData, 116, this.littleEndian);

    this.slice_end = nifti.Utils.getShortAt(rawData, 120, this.littleEndian);
    this.slice_code = nifti.Utils.getByteAt(rawData, 122);

    this.xyzt_units = nifti.Utils.getByteAt(rawData, 123);

    this.cal_max = nifti.Utils.getFloatAt(rawData, 124, this.littleEndian);
    this.cal_min = nifti.Utils.getFloatAt(rawData, 128, this.littleEndian);

    this.slice_duration = nifti.Utils.getFloatAt(rawData, 132, this.littleEndian);
    this.toffset = nifti.Utils.getFloatAt(rawData, 136, this.littleEndian);

    this.description = nifti.Utils.getStringAt(rawData, 148, 228);
    this.aux_file = nifti.Utils.getStringAt(rawData, 228, 252);

    this.qform_code = nifti.Utils.getShortAt(rawData, 252, this.littleEndian);
    this.sform_code = nifti.Utils.getShortAt(rawData, 254, this.littleEndian);

    this.quatern_b = nifti.Utils.getFloatAt(rawData, 256, this.littleEndian);
    this.quatern_c = nifti.Utils.getFloatAt(rawData, 260, this.littleEndian);
    this.quatern_d = nifti.Utils.getFloatAt(rawData, 264, this.littleEndian);
    this.qoffset_x = nifti.Utils.getFloatAt(rawData, 268, this.littleEndian);
    this.qoffset_y = nifti.Utils.getFloatAt(rawData, 272, this.littleEndian);
    this.qoffset_z = nifti.Utils.getFloatAt(rawData, 276, this.littleEndian);

    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 280 + (((ctrOut * 4) + ctrIn) * 4);
            this.affine[ctrOut][ctrIn] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
        }
    }

    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;

    this.intent_name = nifti.Utils.getStringAt(rawData, 328, 344);
    this.magic = nifti.Utils.getStringAt(rawData, 344, 348);

    this.isHDR = (this.magic === nifti.NIFTI1.MAGIC_NUMBER2);

    if (rawData.byteLength > nifti.NIFTI1.MAGIC_COOKIE) {
        this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 348);
        this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 348 + 1);
        this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 348 + 2);
        this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 348 + 3);

        if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
        }
    }
};


/**
 * Returns a formatted string of header fields.
 * @returns {string}
 */
nifti.NIFTI1.prototype.toFormattedString = function () {
    var fmt = nifti.Utils.formatNumber,
        string = "";

    string += ("Dim Info = " + this.dim_info + "\n");

    string += ("Image Dimensions (1-8): " +
        this.dims[0] + ", " +
        this.dims[1] + ", " +
        this.dims[2] + ", " +
        this.dims[3] + ", " +
        this.dims[4] + ", " +
        this.dims[5] + ", " +
        this.dims[6] + ", " +
        this.dims[7] + "\n");

    string += ("Intent Parameters (1-3): " +
        this.intent_p1 + ", " +
        this.intent_p2 + ", " +
        this.intent_p3) + "\n";

    string += ("Intent Code = " + this.intent_code + "\n");
    string += ("Datatype = " + this.datatypeCode +  " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n");
    string += ("Bits Per Voxel = " + this.numBitsPerVoxel + "\n");
    string += ("Slice Start = " + this.slice_start + "\n");
    string += ("Voxel Dimensions (1-8): " +
        fmt(this.pixDims[0]) + ", " +
        fmt(this.pixDims[1]) + ", " +
        fmt(this.pixDims[2]) + ", " +
        fmt(this.pixDims[3]) + ", " +
        fmt(this.pixDims[4]) + ", " +
        fmt(this.pixDims[5]) + ", " +
        fmt(this.pixDims[6]) + ", " +
        fmt(this.pixDims[7]) + "\n");

    string += ("Image Offset = " + this.vox_offset + "\n");
    string += ("Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n");
    string += ("Slice End = " + this.slice_end + "\n");
    string += ("Slice Code = " + this.slice_code + "\n");
    string += ("Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n");
    string += ("Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n");
    string += ("Slice Duration = " + this.slice_duration + "\n");
    string += ("Time Axis Shift = " + this.toffset + "\n");
    string += ("Description: \"" + this.description + "\"\n");
    string += ("Auxiliary File: \"" + this.aux_file + "\"\n");
    string += ("Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n");
    string += ("S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n");
    string += ("Quaternion Parameters:  " +
        "b = " + fmt(this.quatern_b) + "  " +
        "c = " + fmt(this.quatern_c) + "  " +
        "d = " + fmt(this.quatern_d) + "\n");

    string += ("Quaternion Offsets:  " +
        "x = " + this.qoffset_x + "  " +
        "y = " + this.qoffset_y + "  " +
        "z = " + this.qoffset_z + "\n");

    string += ("S-Form Parameters X: " +
        fmt(this.affine[0][0]) + ", " +
        fmt(this.affine[0][1]) + ", " +
        fmt(this.affine[0][2]) + ", " +
        fmt(this.affine[0][3]) + "\n");

    string += ("S-Form Parameters Y: " +
        fmt(this.affine[1][0]) + ", " +
        fmt(this.affine[1][1]) + ", " +
        fmt(this.affine[1][2]) + ", " +
        fmt(this.affine[1][3]) + "\n");

    string += ("S-Form Parameters Z: " +
        fmt(this.affine[2][0]) + ", " +
        fmt(this.affine[2][1]) + ", " +
        fmt(this.affine[2][2]) + ", " +
        fmt(this.affine[2][3]) + "\n");

    string += ("Intent Name: \"" + this.intent_name + "\"\n");

    if (this.extensionFlag[0]) {
        string += ("Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + "\n");

    }

    return string;
};


/**
 * Returns a human-readable string of datatype.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getDatatypeCodeString = function (code) {
    if (code === nifti.NIFTI1.TYPE_UINT8) {
        return "1-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT16) {
        return "2-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT32) {
        return "4-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_FLOAT32) {
        return "4-Byte Float";
    } else if (code === nifti.NIFTI1.TYPE_FLOAT64) {
        return "8-Byte Float";
    } else if (code === nifti.NIFTI1.TYPE_RGB24) {
        return "RGB";
    } else if (code === nifti.NIFTI1.TYPE_INT8) {
        return "1-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT16) {
        return "2-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT32) {
        return "4-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT64) {
        return "8-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT64) {
        return "8-Byte Unsigned Integer";
    } else {
        return "Unknown";
    }
};


/**
 * Returns a human-readable string of transform type.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getTransformCodeString = function (code) {
    if (code === nifti.NIFTI1.XFORM_SCANNER_ANAT) {
        return "Scanner";
    } else if (code === nifti.NIFTI1.XFORM_ALIGNED_ANAT) {
        return "Aligned";
    } else if (code === nifti.NIFTI1.XFORM_TALAIRACH) {
        return "Talairach";
    } else if (code === nifti.NIFTI1.XFORM_MNI_152) {
        return "MNI";
    } else {
        return "Unknown";
    }
};


/**
 * Returns a human-readable string of spatial and temporal units.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getUnitsCodeString = function (code) {
    if (code === nifti.NIFTI1.UNITS_METER) {
        return "Meters";
    } else if (code === nifti.NIFTI1.UNITS_MM) {
        return "Millimeters";
    } else if (code === nifti.NIFTI1.UNITS_MICRON) {
        return "Microns";
    } else if (code === nifti.NIFTI1.UNITS_SEC) {
        return "Seconds";
    } else if (code === nifti.NIFTI1.UNITS_MSEC) {
        return "Milliseconds";
    } else if (code === nifti.NIFTI1.UNITS_USEC) {
        return "Microseconds";
    } else if (code === nifti.NIFTI1.UNITS_HZ) {
        return "Hz";
    } else if (code === nifti.NIFTI1.UNITS_PPM) {
        return "PPM";
    } else if (code === nifti.NIFTI1.UNITS_RADS) {
        return "Rads";
    } else {
        return "Unknown";
    }
};


/**
 * Returns the qform matrix.
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI1.prototype.getQformMat = function () {
    return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x,
        this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
};



/**
 * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {number} qb
 * @param {number} qc
 * @param {number} qd
 * @param {number} qx
 * @param {number} qy
 * @param {number} qz
 * @param {number} dx
 * @param {number} dy
 * @param {number} dz
 * @param {number} qfac
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm = function (qb, qc, qd, qx, qy, qz, dx, dy, dz,
                                                qfac) {
    var R = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
        a,
        b = qb,
        c = qc,
        d = qd,
        xd,
        yd,
        zd;

    // last row is always [ 0 0 0 1 ]
    R[3][0] = R[3][1] = R[3][2] = 0.0;
    R[3][3] = 1.0;

    // compute a parameter from b,c,d
    a = 1.0 - (b * b + c * c + d * d);
    if (a < 0.0000001) {                   /* special case */

        a = 1.0 / Math.sqrt(b * b + c * c + d * d);
        b *= a;
        c *= a;
        d *= a;        /* normalize (b,c,d) vector */
        a = 0.0;                        /* a = 0 ==> 180 degree rotation */
    } else {

        a = Math.sqrt(a);                     /* angle = 2*arccos(a) */
    }

    // load rotation matrix, including scaling factors for voxel sizes
    xd = (dx > 0.0) ? dx : 1.0;       /* make sure are positive */
    yd = (dy > 0.0) ? dy : 1.0;
    zd = (dz > 0.0) ? dz : 1.0;

    if (qfac < 0.0) {
        zd = -zd;         /* left handedness? */
    }

    R[0][0] =       (a * a + b * b - c * c - d * d) * xd;
    R[0][1] = 2.0 * (b * c - a * d) * yd;
    R[0][2] = 2.0 * (b * d + a * c) * zd;
    R[1][0] = 2.0 * (b * c + a * d) * xd;
    R[1][1] =       (a * a + c * c - b * b - d * d) * yd;
    R[1][2] = 2.0 * (c * d - a * b) * zd;
    R[2][0] = 2.0 * (b * d - a * c) * xd;
    R[2][1] = 2.0 * (c * d + a * b) * yd;
    R[2][2] =       (a * a + d * d - c * c - b * b) * zd;

    // load offsets
    R[0][3] = qx;
    R[1][3] = qy;
    R[2][3] = qz;

    return R;
};



/**
 * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {Array.<Array.<number>>} R
 * @returns {string}
 */
nifti.NIFTI1.prototype.convertNiftiSFormToNEMA = function (R) {
    var xi, xj, xk, yi, yj, yk, zi, zj, zk, val, detQ, detP, i, j, k, p, q, r, ibest, jbest, kbest, pbest, qbest, rbest,
        M, vbest, Q, P, iChar, jChar, kChar, iSense, jSense, kSense;
    k = 0;

    Q = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    P = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

    //if( icod == NULL || jcod == NULL || kcod == NULL ) return ; /* bad */

    //*icod = *jcod = *kcod = 0 ; /* this.errorMessage returns, if sh*t happens */

    /* load column vectors for each (i,j,k) direction from matrix */

    /*-- i axis --*/ /*-- j axis --*/ /*-- k axis --*/

    xi = R[0][0];
    xj = R[0][1];
    xk = R[0][2];

    yi = R[1][0];
    yj = R[1][1];
    yk = R[1][2];

    zi = R[2][0];
    zj = R[2][1];
    zk = R[2][2];

    /* normalize column vectors to get unit vectors along each ijk-axis */

    /* normalize i axis */
    val = Math.sqrt(xi * xi + yi * yi + zi * zi);
    if (val === 0.0) {  /* stupid input */
        return null;
    }

    xi /= val;
    yi /= val;
    zi /= val;

    /* normalize j axis */
    val = Math.sqrt(xj * xj + yj * yj + zj * zj);
    if (val === 0.0) {  /* stupid input */
        return null;
    }

    xj /= val;
    yj /= val;
    zj /= val;

    /* orthogonalize j axis to i axis, if needed */
    val = xi * xj + yi * yj + zi * zj;    /* dot product between i and j */
    if (Math.abs(val) > 1.E-4) {
        xj -= val * xi;
        yj -= val * yi;
        zj -= val * zi;
        val = Math.sqrt(xj * xj + yj * yj + zj * zj);  /* must renormalize */
        if (val === 0.0) {              /* j was parallel to i? */
            return null;
        }
        xj /= val;
        yj /= val;
        zj /= val;
    }

    /* normalize k axis; if it is zero, make it the cross product i x j */
    val = Math.sqrt(xk * xk + yk * yk + zk * zk);
    if (val === 0.0) {
        xk = yi * zj - zi * yj;
        yk = zi * xj - zj * xi;
        zk = xi * yj - yi * xj;
    } else {
        xk /= val;
        yk /= val;
        zk /= val;
    }

    /* orthogonalize k to i */
    val = xi * xk + yi * yk + zi * zk;    /* dot product between i and k */
    if (Math.abs(val) > 1.E-4) {
        xk -= val * xi;
        yk -= val * yi;
        zk -= val * zi;
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0.0) {    /* bad */
            return null;
        }
        xk /= val;
        yk /= val;
        zk /= val;
    }

    /* orthogonalize k to j */
    val = xj * xk + yj * yk + zj * zk;    /* dot product between j and k */
    if (Math.abs(val) > 1.e-4) {
        xk -= val * xj;
        yk -= val * yj;
        zk -= val * zj;
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0.0) {     /* bad */
            return null;
        }
        xk /= val;
        yk /= val;
        zk /= val;
    }

    Q[0][0] = xi;
    Q[0][1] = xj;
    Q[0][2] = xk;
    Q[1][0] = yi;
    Q[1][1] = yj;
    Q[1][2] = yk;
    Q[2][0] = zi;
    Q[2][1] = zj;
    Q[2][2] = zk;

    /* at this point, Q is the rotation matrix from the (i,j,k) to (x,y,z) axes */

    detQ = this.nifti_mat33_determ(Q);
    if (detQ === 0.0) { /* shouldn't happen unless user is a DUFIS */
        return null;
    }

    /* Build and test all possible +1/-1 coordinate permutation matrices P;
     then find the P such that the rotation matrix M=PQ is closest to the
     identity, in the sense of M having the smallest total rotation angle. */

    /* Despite the formidable looking 6 nested loops, there are
     only 3*3*3*2*2*2 = 216 passes, which will run very quickly. */

    vbest = -666.0;
    ibest = pbest = qbest = rbest = 1;
    jbest = 2;
    kbest = 3;

    for (i = 1; i <= 3; i += 1) {     /* i = column number to use for row #1 */
        for (j = 1; j <= 3; j += 1) {    /* j = column number to use for row #2 */
            if (i !== j) {
                for (k = 1; k <= 3; k += 1) {  /* k = column number to use for row #3 */
                    if (!(i === k || j === k)) {
                        P[0][0] = P[0][1] = P[0][2] = P[1][0] = P[1][1] = P[1][2] = P[2][0] = P[2][1] = P[2][2] = 0.0;
                        for (p = -1; p <= 1; p += 2) {    /* p,q,r are -1 or +1      */
                            for (q = -1; q <= 1; q += 2) {   /* and go into rows #1,2,3 */
                                for (r = -1; r <= 1; r += 2) {
                                    P[0][i - 1] = p;
                                    P[1][j - 1] = q;
                                    P[2][k - 1] = r;
                                    detP = this.nifti_mat33_determ(P);           /* sign of permutation */
                                    if ((detP * detQ) > 0.0) {
                                        M = this.nifti_mat33_mul(P, Q);

                                        /* angle of M rotation = 2.0*acos(0.5*sqrt(1.0+trace(M)))       */
                                        /* we want largest trace(M) == smallest angle == M nearest to I */

                                        val = M[0][0] + M[1][1] + M[2][2]; /* trace */
                                        if (val > vbest) {
                                            vbest = val;
                                            ibest = i;
                                            jbest = j;
                                            kbest = k;
                                            pbest = p;
                                            qbest = q;
                                            rbest = r;
                                        }
                                    }  /* doesn't match sign of Q */
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /* At this point ibest is 1 or 2 or 3; pbest is -1 or +1; etc.

     The matrix P that corresponds is the best permutation approximation
     to Q-inverse; that is, P (approximately) takes (x,y,z) coordinates
     to the (i,j,k) axes.

     For example, the first row of P (which contains pbest in column ibest)
     determines the way the i axis points relative to the anatomical
     (x,y,z) axes.  If ibest is 2, then the i axis is along the y axis,
     which is direction P2A (if pbest > 0) or A2P (if pbest < 0).

     So, using ibest and pbest, we can assign the output code for
     the i axis.  Mutatis mutandis for the j and k axes, of course. */

    iChar = jChar = kChar = iSense = jSense = kSense = 0;

    switch (ibest * pbest) {
        case 1: /*i = NIFTI_L2R*/
            iChar = 'X';
            iSense = '+';
            break;
        case -1: /*i = NIFTI_R2L*/
            iChar = 'X';
            iSense = '-';
            break;
        case 2: /*i = NIFTI_P2A*/
            iChar = 'Y';
            iSense = '+';
            break;
        case -2: /*i = NIFTI_A2P*/
            iChar = 'Y';
            iSense = '-';
            break;
        case 3: /*i = NIFTI_I2S*/
            iChar = 'Z';
            iSense = '+';
            break;
        case -3: /*i = NIFTI_S2I*/
            iChar = 'Z';
            iSense = '-';
            break;
    }

    switch (jbest * qbest) {
        case 1: /*j = NIFTI_L2R*/
            jChar = 'X';
            jSense = '+';
            break;
        case -1: /*j = NIFTI_R2L*/
            jChar = 'X';
            jSense = '-';
            break;
        case 2: /*j = NIFTI_P2A*/
            jChar = 'Y';
            jSense = '+';
            break;
        case -2: /*j = NIFTI_A2P*/
            jChar = 'Y';
            jSense = '-';
            break;
        case 3: /*j = NIFTI_I2S*/
            jChar = 'Z';
            jSense = '+';
            break;
        case -3: /*j = NIFTI_S2I*/
            jChar = 'Z';
            jSense = '-';
            break;
    }

    switch (kbest * rbest) {
        case 1: /*k = NIFTI_L2R*/
            kChar = 'X';
            kSense = '+';
            break;
        case -1: /*k = NIFTI_R2L*/
            kChar = 'X';
            kSense = '-';
            break;
        case 2: /*k = NIFTI_P2A*/
            kChar = 'Y';
            kSense = '+';
            break;
        case -2: /*k = NIFTI_A2P*/
            kChar = 'Y';
            kSense = '-';
            break;
        case 3: /*k = NIFTI_I2S*/
            kChar = 'Z';
            kSense = '+';
            break;
        case -3: /*k = NIFTI_S2I*/
            kChar = 'Z';
            kSense = '-';
            break;
    }

    return (iChar + jChar + kChar + iSense + jSense + kSense);
};



nifti.NIFTI1.prototype.nifti_mat33_mul = function (A, B) {
    var C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
        i,
        j;

    for (i = 0; i < 3; i += 1) {
        for (j = 0; j < 3; j += 1) {
            C[i][j] =  A[i][0] * B[0][j]  + A[i][1] * B[1][j] + A[i][2] * B[2][j];
        }
    }

    return C;
};



nifti.NIFTI1.prototype.nifti_mat33_determ = function (R) {
    var r11, r12, r13, r21, r22, r23, r31, r32, r33;
    /*  INPUT MATRIX:  */
    r11 = R[0][0];
    r12 = R[0][1];
    r13 = R[0][2];
    r21 = R[1][0];
    r22 = R[1][1];
    r23 = R[1][2];
    r31 = R[2][0];
    r32 = R[2][1];
    r33 = R[2][2];

    return (r11 * r22 * r33 - r11 * r32 * r23 - r21 * r12 * r33 + r21 * r32 * r13 + r31 * r12 * r23 - r31 * r22 * r13);
};


/**
 * Returns the byte index of the extension.
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionLocation = function() {
    return nifti.NIFTI1.MAGIC_COOKIE + 4;
};


/**
 * Returns the extension size.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionSize = function(data) {
    return nifti.Utils.getIntAt(data, this.getExtensionLocation(), this.littleEndian);
};



/**
 * Returns the extension code.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionCode = function(data) {
    return nifti.Utils.getIntAt(data, this.getExtensionLocation() + 4, this.littleEndian);
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.NIFTI1;
}

},{"./utilities.js":49}],48:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);
nifti.NIFTI1 = nifti.NIFTI1 || ((typeof require !== 'undefined') ? require('./nifti1.js') : null);


/*** Constructor ***/

/**
 * The NIFTI2 constructor.
 * @constructor
 * @property {boolean} littleEndian
 * @property {number} dim_info
 * @property {number[]} dims - image dimensions
 * @property {number} intent_p1
 * @property {number} intent_p2
 * @property {number} intent_p3
 * @property {number} intent_code
 * @property {number} datatypeCode
 * @property {number} numBitsPerVoxel
 * @property {number} slice_start
 * @property {number} slice_end
 * @property {number} slice_code
 * @property {number[]} pixDims - voxel dimensions
 * @property {number} vox_offset
 * @property {number} scl_slope
 * @property {number} scl_inter
 * @property {number} xyzt_units
 * @property {number} cal_max
 * @property {number} cal_min
 * @property {number} slice_duration
 * @property {number} toffset
 * @property {string} description
 * @property {string} aux_file
 * @property {string} intent_name
 * @property {number} qform_code
 * @property {number} sform_code
 * @property {number} quatern_b
 * @property {number} quatern_c
 * @property {number} quatern_d
 * @property {number} quatern_x
 * @property {number} quatern_y
 * @property {number} quatern_z
 * @property {Array.<Array.<number>>} affine
 * @property {string} magic
 * @property {number[]} extensionFlag
 * @type {Function}
 */
nifti.NIFTI2 = nifti.NIFTI2 || function () {
    this.littleEndian = false;
    this.dim_info = 0;
    this.dims = [];
    this.intent_p1 = 0;
    this.intent_p2 = 0;
    this.intent_p3 = 0;
    this.intent_code = 0;
    this.datatypeCode = 0;
    this.numBitsPerVoxel = 0;
    this.slice_start = 0;
    this.slice_end = 0;
    this.slice_code = 0;
    this.pixDims = [];
    this.vox_offset = 0;
    this.scl_slope = 1;
    this.scl_inter = 0;
    this.xyzt_units = 0;
    this.cal_max = 0;
    this.cal_min = 0;
    this.slice_duration = 0;
    this.toffset = 0;
    this.description = "";
    this.aux_file = "";
    this.intent_name = "";
    this.qform_code = 0;
    this.sform_code = 0;
    this.quatern_b = 0;
    this.quatern_c = 0;
    this.quatern_d = 0;
    this.qoffset_x = 0;
    this.qoffset_y = 0;
    this.qoffset_z = 0;
    this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    this.magic = 0;
    this.extensionFlag = [0, 0, 0, 0];
};



/*** Static Pseudo-constants ***/

nifti.NIFTI2.MAGIC_COOKIE = 540;
nifti.NIFTI2.MAGIC_NUMBER_LOCATION = 4;
nifti.NIFTI2.MAGIC_NUMBER = [0x6E, 0x2B, 0x32, 0, 0x0D, 0x0A, 0x1A, 0x0A];  // n+2\0



/*** Prototype Methods ***/

/**
 * Reads the header data.
 * @param {ArrayBuffer} data
 */
nifti.NIFTI2.prototype.readHeader = function (data) {
    var rawData = new DataView(data),
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian),
        ctr,
        ctrOut,
        ctrIn,
        index,
        array;

    if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {  // try as little endian
        this.littleEndian = true;
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
    }

    if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {
        throw new Error("This does not appear to be a NIFTI file!");
    }

    this.datatypeCode = nifti.Utils.getShortAt(rawData, 12, this.littleEndian);
    this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 14, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 16 + (ctr * 8);
        this.dims[ctr] = nifti.Utils.getLongAt(rawData, index, this.littleEndian);
    }

    this.intent_p1 = nifti.Utils.getDoubleAt(rawData, 80, this.littleEndian);
    this.intent_p2 = nifti.Utils.getDoubleAt(rawData, 88, this.littleEndian);
    this.intent_p3 = nifti.Utils.getDoubleAt(rawData, 96, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 104 + (ctr * 8);
        this.pixDims[ctr] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
    }

    this.vox_offset = nifti.Utils.getLongAt(rawData, 168, this.littleEndian);

    this.scl_slope = nifti.Utils.getDoubleAt(rawData, 176, this.littleEndian);
    this.scl_inter = nifti.Utils.getDoubleAt(rawData, 184, this.littleEndian);

    this.cal_max = nifti.Utils.getDoubleAt(rawData, 192, this.littleEndian);
    this.cal_min = nifti.Utils.getDoubleAt(rawData, 200, this.littleEndian);

    this.slice_duration = nifti.Utils.getDoubleAt(rawData, 208, this.littleEndian);

    this.toffset = nifti.Utils.getDoubleAt(rawData, 216, this.littleEndian);

    this.slice_start = nifti.Utils.getLongAt(rawData, 224, this.littleEndian);
    this.slice_end = nifti.Utils.getLongAt(rawData, 232, this.littleEndian);

    this.description = nifti.Utils.getStringAt(rawData, 240, 240 + 80);
    this.aux_file = nifti.Utils.getStringAt(rawData, 320, 320 + 24);

    this.qform_code = nifti.Utils.getIntAt(rawData, 344, this.littleEndian);
    this.sform_code = nifti.Utils.getIntAt(rawData, 348, this.littleEndian);

    this.quatern_b = nifti.Utils.getDoubleAt(rawData, 352, this.littleEndian);
    this.quatern_c = nifti.Utils.getDoubleAt(rawData, 360, this.littleEndian);
    this.quatern_d = nifti.Utils.getDoubleAt(rawData, 368, this.littleEndian);
    this.qoffset_x = nifti.Utils.getDoubleAt(rawData, 376, this.littleEndian);
    this.qoffset_y = nifti.Utils.getDoubleAt(rawData, 384, this.littleEndian);
    this.qoffset_z = nifti.Utils.getDoubleAt(rawData, 392, this.littleEndian);

    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 400 + (((ctrOut * 4) + ctrIn) * 8);
            this.affine[ctrOut][ctrIn] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
        }
    }

    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;

    this.slice_code = nifti.Utils.getIntAt(rawData, 496, this.littleEndian);
    this.xyzt_units = nifti.Utils.getIntAt(rawData, 500, this.littleEndian);
    this.intent_code = nifti.Utils.getIntAt(rawData, 504, this.littleEndian);
    this.intent_name = nifti.Utils.getStringAt(rawData, 508, 508 + 16);

    this.dim_info = nifti.Utils.getByteAt(rawData, 524);

    if (rawData.byteLength > nifti.NIFTI2.MAGIC_COOKIE) {
        this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 540);
        this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 540 + 1);
        this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 540 + 2);
        this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 540 + 3);

        if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
        }
    }
};



/**
 * Returns a formatted string of header fields.
 * @returns {string}
 */
nifti.NIFTI2.prototype.toFormattedString = function () {
    var fmt = nifti.Utils.formatNumber,
        string = "";

    string += ("Datatype = " +  + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n");
    string += ("Bits Per Voxel = " + " = " + this.numBitsPerVoxel + "\n");
    string += ("Image Dimensions" + " (1-8): " +
        this.dims[0] + ", " +
        this.dims[1] + ", " +
        this.dims[2] + ", " +
        this.dims[3] + ", " +
        this.dims[4] + ", " +
        this.dims[5] + ", " +
        this.dims[6] + ", " +
        this.dims[7] + "\n");

    string += ("Intent Parameters (1-3): " +
        this.intent_p1 + ", " +
        this.intent_p2 + ", " +
        this.intent_p3) + "\n";

    string += ("Voxel Dimensions (1-8): " +
        fmt(this.pixDims[0]) + ", " +
        fmt(this.pixDims[1]) + ", " +
        fmt(this.pixDims[2]) + ", " +
        fmt(this.pixDims[3]) + ", " +
        fmt(this.pixDims[4]) + ", " +
        fmt(this.pixDims[5]) + ", " +
        fmt(this.pixDims[6]) + ", " +
        fmt(this.pixDims[7]) + "\n");

    string += ("Image Offset = " + this.vox_offset + "\n");
    string += ("Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n");
    string += ("Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n");
    string += ("Slice Duration = " + this.slice_duration + "\n");
    string += ("Time Axis Shift = " + this.toffset + "\n");
    string += ("Slice Start = " + this.slice_start + "\n");
    string += ("Slice End = " + this.slice_end + "\n");
    string += ("Description: \"" + this.description + "\"\n");
    string += ("Auxiliary File: \"" + this.aux_file + "\"\n");
    string += ("Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n");
    string += ("S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n");
    string += ("Quaternion Parameters:  " +
    "b = " + fmt(this.quatern_b) + "  " +
    "c = " + fmt(this.quatern_c) + "  " +
    "d = " + fmt(this.quatern_d) + "\n");

    string += ("Quaternion Offsets:  " +
    "x = " + this.qoffset_x + "  " +
    "y = " + this.qoffset_y + "  " +
    "z = " + this.qoffset_z + "\n");

    string += ("S-Form Parameters X: " +
    fmt(this.affine[0][0]) + ", " +
    fmt(this.affine[0][1]) + ", " +
    fmt(this.affine[0][2]) + ", " +
    fmt(this.affine[0][3]) + "\n");

    string += ("S-Form Parameters Y: " +
    fmt(this.affine[1][0]) + ", " +
    fmt(this.affine[1][1]) + ", " +
    fmt(this.affine[1][2]) + ", " +
    fmt(this.affine[1][3]) + "\n");

    string += ("S-Form Parameters Z: " +
    fmt(this.affine[2][0]) + ", " +
    fmt(this.affine[2][1]) + ", " +
    fmt(this.affine[2][2]) + ", " +
    fmt(this.affine[2][3]) + "\n");

    string += ("Slice Code = " + this.slice_code + "\n");
    string += ("Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n");
    string += ("Intent Code = " + this.intent_code + "\n");
    string += ("Intent Name: \"" + this.intent_name + "\"\n");

    string += ("Dim Info = " + this.dim_info + "\n");

    return string;
};



/**
 * Returns the byte index of the extension.
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionLocation = function() {
    return nifti.NIFTI2.MAGIC_COOKIE + 4;
};



/**
 * Returns the extension size.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionSize = nifti.NIFTI1.prototype.getExtensionSize;



/**
 * Returns the extension code.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionCode = nifti.NIFTI1.prototype.getExtensionCode;



/**
 * Returns a human-readable string of datatype.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getDatatypeCodeString = nifti.NIFTI1.prototype.getDatatypeCodeString;



/**
 * Returns a human-readable string of transform type.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getTransformCodeString = nifti.NIFTI1.prototype.getTransformCodeString;



/**
 * Returns a human-readable string of spatial and temporal units.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getUnitsCodeString = nifti.NIFTI1.prototype.getUnitsCodeString;



/**
 * Returns the qform matrix.
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI2.prototype.getQformMat = nifti.NIFTI1.prototype.getQformMat;



/**
 * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {number} qb
 * @param {number} qc
 * @param {number} qd
 * @param {number} qx
 * @param {number} qy
 * @param {number} qz
 * @param {number} dx
 * @param {number} dy
 * @param {number} dz
 * @param {number} qfac
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI2.prototype.convertNiftiQFormToNiftiSForm = nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm;



/**
 * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {Array.<Array.<number>>} R
 * @returns {string}
 */
nifti.NIFTI2.prototype.convertNiftiSFormToNEMA = nifti.NIFTI1.prototype.convertNiftiSFormToNEMA;



nifti.NIFTI2.prototype.nifti_mat33_mul = nifti.NIFTI1.prototype.nifti_mat33_mul;



nifti.NIFTI2.prototype.nifti_mat33_determ = nifti.NIFTI1.prototype.nifti_mat33_determ;



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.NIFTI2;
}

},{"./nifti1.js":47,"./utilities.js":49}],49:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || {};



/*** Static Pseudo-constants ***/

nifti.Utils.crcTable = null;
nifti.Utils.GUNZIP_MAGIC_COOKIE1 = 31;
nifti.Utils.GUNZIP_MAGIC_COOKIE2 = 139;



/*** Static methods ***/

nifti.Utils.getStringAt = function (data, start, end) {
    var str = "", ctr, ch;

    for (ctr = start; ctr < end; ctr += 1) {
        ch = data.getUint8(ctr);

        if (ch !== 0) {
            str += String.fromCharCode(ch);
        }
    }

    return str;
};



nifti.Utils.getByteAt = function (data, start) {
    return data.getInt8(start);
};



nifti.Utils.getShortAt = function (data, start, littleEndian) {
    return data.getInt16(start, littleEndian);
};



nifti.Utils.getIntAt = function (data, start, littleEndian) {
    return data.getInt32(start, littleEndian);
};



nifti.Utils.getFloatAt = function (data, start, littleEndian) {
    return data.getFloat32(start, littleEndian);
};



nifti.Utils.getDoubleAt = function (data, start, littleEndian) {
    return data.getFloat64(start, littleEndian);
};



nifti.Utils.getLongAt = function (data, start, littleEndian) {
    var ctr, array = [], value = 0;

    for (ctr = 0; ctr < 8; ctr += 1) {
        array[ctr] = nifti.Utils.getByteAt(data, start + ctr, littleEndian);
    }

    for (ctr = array.length - 1; ctr >= 0; ctr--) {
        value = (value * 256) + array[ctr];
    }

    return value;
};



nifti.Utils.toArrayBuffer = function (buffer) {
    var ab, view, i;

    ab = new ArrayBuffer(buffer.length);
    view = new Uint8Array(ab);
    for (i = 0; i < buffer.length; i += 1) {
        view[i] = buffer[i];
    }
    return ab;
};



nifti.Utils.isString = function (obj) {
    return (typeof obj === "string" || obj instanceof String);
};


nifti.Utils.formatNumber = function (num, shortFormat) {
    var val = 0;

    if (nifti.Utils.isString(num)) {
        val = Number(num);
    } else {
        val = num;
    }

    if (shortFormat) {
        val = val.toPrecision(5);
    } else {
        val = val.toPrecision(7);
    }

    return parseFloat(val);
};



// http://stackoverflow.com/questions/18638900/javascript-crc32
nifti.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};



nifti.Utils.crc32 = function(dataView) {
    var crcTable = nifti.Utils.crcTable || (nifti.Utils.crcTable = nifti.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.Utils;
}

},{}],50:[function(require,module,exports){
"use strict";
var assert = require('assert');

var lineSeparatorRE = /[ \f\t\v]*\r?\n/;
var NRRDMagicRE = /^NRRD\d{4}$/;
var lineRE = /^([^:]*)(:[ =])(.*)$/;
var dataFileListRE = /^LIST(?: (\d+))?$/;

// The minimal object this accepts is formed like this:
//   {data: SomeTypedArray, sizes: [...]}
// On the other hand, if data is not given it must have a form like this:
//   {buffer: SomeArrayBuffer, type: ..., endian: ..., sizes: [...]}
// Of course, if 'type' is an 8-bit type, endian is not needed, and if 'type' equals 'block', 'blockSize' should be set instead of 'endian'. In this case, no interpretation of buffer is done (at all, it is written serialized directly to the buffer).
// TODO: For now this only supports serializing "inline" files, or files for which you have already prepared the data.
module.exports.serialize = function (nrrdOrg) {
    var i, buffer, arr, totalLen = 1, nrrd = {}, prop, nativeType, nativeSize, bufferData, arrData, line, lines = [], header;
    
    // Copy nrrdOrg to nrrd to allow modifications without altering the original
    for(prop in nrrdOrg) {
        nrrd[prop] = nrrdOrg[prop];
    }
    
    // For saving files we allow inferring certain information if it is not explicitly given.
    // Also we normalize some fields to make our own lives easier.
    if (nrrd.sizes===undefined) { // 'sizes' should ALWAYS be given
        throw new Error("Sizes missing from NRRD file!");
    } else if (nrrd.dimension===undefined) {
        nrrd.dimension = nrrd.sizes.length;
    }
    if (nrrd.data instanceof Int8Array) {
        nativeType = "int8";
    } else if (nrrd.data instanceof Uint8Array) {
        nativeType = "uint8";
    } else if (nrrd.data instanceof Int16Array) {
        nativeType = "int16";
    } else if (nrrd.data instanceof Uint16Array) {
        nativeType = "uint16";
    } else if (nrrd.data instanceof Int32Array) {
        nativeType = "int32";
    } else if (nrrd.data instanceof Uint32Array) {
        nativeType = "uint32";
    //} else if (nrrd.data instanceof Int64Array) {
    //    nativeType = "int64";
    //} else if (nrrd.data instanceof Uint64Array) {
    //    nativeType = "uint64";
    } else if (nrrd.data instanceof Float32Array) {
        nativeType = "float";
    } else if (nrrd.data instanceof Float64Array) {
        nativeType = "double";
    }
    if (nrrd.type===undefined && nativeType!==undefined) {
        nrrd.type = nativeType;
    } else if (nrrd.type===undefined) {
        throw new Error("Type of data is not given and cannot be inferred!");
    } else if ((typeof nrrd.type) == "string" || nrrd.type instanceof String) {
        nrrd.type = parseNRRDType(nrrd.type);
    }
    if (nrrd.encoding===undefined) {
        nrrd.encoding = "raw";
    } else if ((typeof nrrd.encoding) == "string" || nrrd.encoding instanceof String) {
        nrrd.encoding = parseNRRDEncoding(nrrd.encoding);
    }
    if (nrrd.data && nrrd.type != 'block' && nrrd.type != 'int8' && nrrd.type != 'uint8' && nrrd.encoding != 'ascii') {
        nrrd.endian = systemEndianness;
    } else if (nrrd.type == 'block' || nrrd.type == 'int8' || nrrd.type == 'uint8' || nrrd.encoding == 'ascii') {
        nrrd.endian = undefined;
    } else if ((typeof nrrd.endian) == "string" || nrrd.endian instanceof String) {
        nrrd.endian = parseNRRDEndian(nrrd.endian);
    }
    
    // Try to infer spatial dimension
    var spaceDimension = undefined;
    if (nrrd.spaceDimension!==undefined) {
        spaceDimension = nrrd.spaceDimension;
    } else if (nrrd.space!==undefined) {
        switch(nrrd.space) {
        case "right-anterior-superior":
        case "RAS":
            spaceDimension = 3;
            break;
        case "left-anterior-superior":
        case "LAS":
            spaceDimension = 3;
            break;
        case "left-posterior-superior":
        case "LPS":
            spaceDimension = 3;
            break;
     	  case "right-anterior-superior-time":
     	  case "RAST":
     	      spaceDimension = 4;
     	      break;
        case "left-anterior-superior-time":
        case "LAST":
            spaceDimension = 4;
            break;
        case "left-posterior-superior-time":
        case "LPST":
            spaceDimension = 4;
            break;
        case "scanner-xyz":
            spaceDimension = 3;
            break;
        case "scanner-xyz-time":
            spaceDimension = 4;
            break;
        case "3D-right-handed":
            spaceDimension = 3;
            break;
        case "3D-left-handed":
            spaceDimension = 3;
            break;
        case "3D-right-handed-time":
            spaceDimension = 4;
            break;
        case "3D-left-handed-time":
            spaceDimension = 4;
            break;
        default:
            console.warn("Unrecognized space: " + nrrd.space);
        }
    }
    
    // Now check that we have a valid nrrd structure.
    checkNRRD(nrrd);

    // Determine number of elements and check that we have enough data (if possible)
    for(i=0; i<nrrd.sizes.length; i++) {
        if (nrrd.sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= nrrd.sizes[i];
    }
    if (nrrd.data) {
        if (nrrd.data.length < totalLen) {
            throw new Error("Missing data to serialize!");
        }
    } else if (nrrd.buffer) {
        if (nrrd.encoding == "raw") {
            if (nrrd.type=="block" && nrrd.blockSize!==undefined) {
                nativeSize = nrrd.blockSize;
            } else {
                nativeSize = getNRRDTypeSize(nrrd.type);
            }
            if (nrrd.buffer.byteLength < totalLen*nativeSize) {
                throw new Error("Missing data to serialize!");
            }
        }
    } else if (nrrd.dataFile) {
        // Okay, if you have your data ready, we'll just write a header.
    } else {
        throw new Error("Will not serialize an empty NRRD file!");
    }
    
    // Make sure we have the correct buffer in bufferData.
    if (nrrd.data) {
        switch(nrrd.encoding) {
        case 'raw':
            if (nrrd.type == nativeType && nrrd.endian == systemEndianness) {
                bufferData = nrrd.data.buffer.slice(nrrd.data.byteOffset, nrrd.data.byteOffset+nrrd.data.byteLength);
            } else if (nrrd.endian == systemEndianness) {
                bufferData = castTypedArray(nrrd.data, nrrd.type);
                bufferData = bufferData.buffer.slice(bufferData.byteOffset, bufferData.byteOffset+bufferData.byteLength);
            } else {
                bufferData = serializeToBuffer(nrrd.data, nrrd.type, nrrd.endian);
            }
            break;
        case 'ascii':
            if (nrrd.type == nativeType) {
                bufferData = serializeToTextBuffer(nrrd.data);
            } else {
                bufferData = serializeToTextBuffer(castTypedArray(nrrd.data, nrrd.type));
            }
            break;
        default:
            throw new Error("Unsupported NRRD encoding: " + nrrd.encoding);
        }
    } else if (nrrd.buffer) {
        bufferData = nrrd.buffer;
    }
    
    // Start header
    lines.push("NRRD0005"); // TODO: Adjust version based on features that are actually used and/or the version specified by the user (if any).
    lines.push("# Generated by nrrd-js");
    
    // Put in dimension and space dimension (the NRRD spec requires that these are present before any lists whose length depends on them)
    var firstProps = ['dimension', 'spaceDimension', 'space'];
    for(i=0; i<firstProps.length; i++) {
        prop = firstProps[i];
        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.
        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);
        if (line!==undefined) lines.push(line);
    }
    
    // Put in field specifications
    for(prop in nrrd) {
        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.
        if (firstProps.indexOf(prop)>=0) continue; // Skip the fields we already output.
        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);
        if (line!==undefined) lines.push(line);
    }
    
    // Put in keys (if any)
    if (nrrd.keys) for(prop in nrrd.keys) {
        if (prop.indexOf(":=")>=0) throw new Error("The combination ':=' is not allowed in an NRRD key!");
        lines.push(prop + ":=" + escapeValue(nrrd[prop]));
    }
    
    // Put in data file list (if any)
    if (nrrd.dataFile && nrrd.dataFile.length) {
        lines.push("data file: LIST");
        Array.prototype.push.apply(lines, nrrd.dataFile);
    } else if (nrrd.dataFile && nrrd.dataFile.files && 'subdim' in nrrd.dataFile) {
        lines.push("data file: LIST " + nrrd.dataFile.subdim);
        Array.prototype.push.apply(lines, nrrd.dataFile.files);
    }
    
    // Put in empty line and inline data (if we have inline data) and convert lines to buffer
    if (bufferData && !('dataFile' in nrrd)) {
        lines.push("");
        lines.push(""); // We actually need an extra blank line to make sure the previous is terminated.
        header = lines.join("\n");
        buffer = new ArrayBuffer(header.length + bufferData.byteLength);
        arr = new Uint8Array(buffer);
        for(i=0; i<header.length; i++) {
            arr[i] = header.charCodeAt(i);
        }
        arrData = new Uint8Array(bufferData);
        arr.set(arrData, header.length);
    } else {
        lines.push(""); // Blank line to at least terminate the last line.
        header = lines.join("\n");
        buffer = new ArrayBuffer(header.length);
        arr = new Uint8Array(buffer);
        for(i=0; i<header.length; i++) {
            arr[i] = header.charCodeAt(i);
        }
    }
    
    return buffer;
};

// This expects an ArrayBuffer.
module.exports.parse = function (buffer) {
    var i, header, dataStart, ret = {data: undefined/* parsed data */, buffer: undefined/* raw buffer holding data */, keys: {}, version: undefined},
        lines, match, match2,
        buf8 = new Uint8Array(buffer);

    // A work-around for incompatibilities between Node's Buffer and ArrayBuffer.
    if (buf8.buffer !== buffer) buffer = buf8.buffer;

    // First find the separation between the header and the data (if there is one)
    // Note that we need to deal with with LF and CRLF as possible line endings.
    // Luckily this means the line always ends with LF, so we only need to consider
    // LFLF and LFCRLF as patterns for the separating empty line.
    i=2; // It is safe to start at position 2 (in fact, we could start even later), as the file HAS to start with a magic word.
    while(i<buf8.length) {
        if (buf8[i] == 10) { // We hit an LF
            if (buf8[i-1] == 10 || (buf8[i-1] == 13 && buf8[i-2] == 10)) { // Safe because we start at position 2 and never move backwards
                dataStart = i+1;
                break;
            } else {
                i++; // Move forward just once
            }
        } else if (buf8[i] == 13) { // We hit a CR
            i++; // Move forward just once
        } else {
            i += 2; // Move forward two places, 
        }
    }
    
    // Now split up the header and data
    if (dataStart === undefined) {
        header = String.fromCharCode.apply(null, buf8);
    } else {
        header = String.fromCharCode.apply(null, buf8.subarray(0,dataStart));
        ret.buffer = buffer.slice(dataStart);
    }
    
    // Split header into lines, remove comments (and blank lines) and check magic.
    // All remaining lines except the first should be field specifications or key/value pairs.
    // TODO: This explicitly removes any whitespace at the end of lines, however, I am not sure that this is actually desired behaviour for all kinds of lines.
    lines = header.split(lineSeparatorRE);
    lines = lines.filter(function (l) { return l.length>0 && l[0] != '#'; }); // Remove comment lines
    if (!NRRDMagicRE.test(lines[0])) {
        throw new Error("File is not an NRRD file!");
    }
    ret.version = parseInt(lines[0].substring(4, 8), 10);
    if (ret.version>5) {
        console.warn("Reading an unsupported version of the NRRD format; things may go haywire.");
    }

    // Parse lines
    for(i=1; i<lines.length; i++) {
        match = lineRE.exec(lines[i]);
        if (!match) {
            console.warn("Unrecognized line in NRRD header: " + lines[i]);
            continue;
        }
        if (match[2] == ': ') { // Field specification
            match[1] = mapNRRDToJavascript(match[1]);
            if ( match[1] == 'dataFile' &&
                 (match2 = dataFileListRE.exec(match[3]))) {
                // This should be the last field specification,
                // and the rest of the lines should contain file names.
                if (match2.length == 2 && match2[1]) { // subdim specification
                    ret[match[1]] = {
                        files: lines.slice(i+1),
                        subdim: parseNRRDInteger(match2[1])
                    };
                } else {
                    ret[match[1]] = lines.slice(i+1);
                }
                lines.length = i;
            } else {
                ret[match[1]] = parseField(match[1], match[3]);
            }
        } else if (match[2] == ':=') { // Key/value pair
            ret.keys[match[1]] = unescapeValue(match[3]);
        } else {
            throw new Error("Logic error in NRRD parser."); // This should never happen (unless the NRRD syntax is extended and the regexp is updated, but this section is not, or some other programmer error).
        }
    }

    // Make sure the file satisfies the requirements of the NRRD format
    checkNRRD(ret);
    
    // "Parse" data
    if ('dataFile' in ret) {
        console.warn("No support for external data yet!");
    } else {
        switch(ret.encoding) {
        case 'raw':
            ret.data = parseNRRDRawData(ret.buffer, ret.type, ret.sizes, {
                endian: ret.endian, blockSize: ret.blockSize
            });
            break;
        case 'ascii':
            ret.data = parseNRRDTextData(ret.buffer, ret.type, ret.sizes);
            break;
        default:
            console.warn("Unsupported NRRD encoding: " + ret.encoding);
        }
    }
    
    return ret;
};

function escapeValue(val) {
    return val.replace('\\', '\\\\').replace('\n', '\\n');
}

function unescapeValue(val) {
    return val.split('\\\\').map(
        function(s) { return s.replace('\\n', '\n'); }
        ).join('\\');
}

// Serializes NRRD fields
function serializeField(prop, value, dimension, spaceDimension) {
    var line;
    var propNRRD = mapJavascriptToNRRD(prop);
    switch(prop) {
    // nrrd-js stuff: skip
    case 'data':
    case 'buffer':
    case 'keys':
    case 'version':
        break;
    // Literal (uninterpreted) fields
    case 'content':
    case 'number':
    case 'sampleUnits':
    case 'space':
        line = propNRRD + ": " + value;
        break;
    // Integers (no infinity or whatever, just a plain integer, so the default serialization is good enough)
    case 'blockSize':
    case 'lineSkip':
    case 'byteSkip':
    case 'dimension':
    case 'spaceDimension':
        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should at least contain a number!");
        line = propNRRD + ": " + value;
        break;
    // Floats (default serialization is good enough, as NaN contains nan, ignoring case, and similarly for Infinity inf)
    case 'min':
    case 'max':
    case 'oldMin':
    case 'oldMax':
        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should contain a number!");
        line = propNRRD + ": " + value;
        break;
    // Vectors
    case 'spaceOrigin':
        assert(value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": (" + value.join(",") + ")";
        break;
    // Lists of strings
    case 'labels':
    case 'units':
    case 'spaceUnits':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "string" || val instanceof String, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.map(serializeNRRDQuotedString).join(" ");
        break;
    // Lists of integers
    case 'sizes':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.join(" ");
        break;
    // Lists of floats
    case 'spacings':
    case 'thicknesses':
    case 'axisMins':
    case 'axisMaxs':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.join(" ");
        break;
    // Lists of vectors (dimension sized)
    case 'spaceDirections':
        assert(value.length !== undefined && value.length === dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (vec) {
          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");
          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });
        });
        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");
        break;
    // Lists of vectors (space dimension sized)
    case 'measurementFrame':
        assert(value.length !== undefined && value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");
        value.forEach(function (vec) {
          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");
          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });
        });
        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");
        break;
    // One-of-a-kind fields
    case 'type':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'encoding':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'endian':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'dataFile':
        if (value.length || (value.files && 'subdim' in value)) {
            // List of data files: skip for now
        } else {
            line = propNRRD + ": " + serializeNRRDDataFile(value);
        }
        break;
    case 'centers':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");
        break;
    case 'kinds':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");
        break;
    // Something unknown
    default:
        console.warn("Unrecognized NRRD field: " + prop + ", skipping.");
    }
    return line;
}

// Parses and normalizes NRRD fields, assumes the field names are already lower case.
function parseField(identifier, descriptor) {
    switch(identifier) {
    // Literal (uninterpreted) fields
    case 'content':
    case 'number':
    case 'sampleUnits':
        break;
    // Integers
    case 'dimension':
    case 'blockSize':
    case 'lineSkip':
    case 'byteSkip':
    case 'spaceDimension':
        descriptor = parseNRRDInteger(descriptor);
        break;
    // Floats
    case 'min':
    case 'max':
    case 'oldMin':
    case 'oldMax':
        descriptor = parseNRRDFloat(descriptor);
        break;
    // Vectors
    case 'spaceOrigin':
        descriptor = parseNRRDVector(descriptor);
        break;
    // Lists of strings
    case 'labels':
    case 'units':
    case 'spaceUnits':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDQuotedString);
        break;
    // Lists of integers
    case 'sizes':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDInteger);
        break;
    // Lists of floats
    case 'spacings':
    case 'thicknesses':
    case 'axisMins':
    case 'axisMaxs':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDFloat);
        break;
    // Lists of vectors
    case 'spaceDirections':
    case 'measurementFrame':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDVector);
        break;
    // One-of-a-kind fields
    case 'type':
        descriptor = parseNRRDType(descriptor);
        break;
    case 'encoding':
        descriptor = parseNRRDEncoding(descriptor);
        break;
    case 'endian':
        descriptor = parseNRRDEndian(descriptor);
        break;
    case 'dataFile':
        descriptor = parseNRRDDataFile(descriptor);
        break;
    case 'centers':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDCenter);
        break;
    case 'kinds':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDKind);
        break;
    case 'space':
        descriptor = parseNRRDSpace(descriptor);
        break;
    // Something unknown
    default:
        console.warn("Unrecognized NRRD field: " + identifier);
    }
    return descriptor;
}

// This only includes names whose lower case form is different from the Javascript form.
var mapNRRDToJavascriptStatic = {
    'block size': 'blockSize',
    'blocksize': 'blockSize',
    'old min': 'oldMin',
    'oldmin': 'oldMin',
    'old max': 'oldMax',
    'oldmax': 'oldMax',
    'data file': 'dataFile',
    'datafile': 'dataFile',
    'line skip': 'lineSkip',
    'lineskip': 'lineSkip',
    'byte skip': 'byteSkip',
    'byteskip': 'byteSkip',
    'sample units': 'sampleUnits',
    'sampleunits': 'sampleUnits',
    'axis mins': 'axisMins',
    'axis maxs': 'axisMaxs',
    'centers': 'centers', // Not different, just included so it is clear why centerings maps to centers
    'centerings': 'centers',
    'space dimension': 'spaceDimension',
    'space units': 'spaceUnits',
    'space origin': 'spaceOrigin',
    'space directions': 'spaceDirections',
    'measurement frame': 'measurementFrame'
};
var mapJavascriptToNRRDStatic = function() {
  var id, m = {};
  for(id in mapNRRDToJavascriptStatic) {
    m[mapNRRDToJavascriptStatic[id]] = id;
  }
  return m;
}();
function mapNRRDToJavascript(id) {
    // In any case, use the lower case version of the id
    id = id.toLowerCase();
    // Filter out any fields for which we have an explicit Javascript name
    if (id in mapNRRDToJavascriptStatic) return mapNRRDToJavascriptStatic[id];
    // Otherwise, just return the (lower case) id
    return id;
}
function mapJavascriptToNRRD(id) {
    // Filter out any fields for which we have an explicit NRRD name
    if (id in mapJavascriptToNRRDStatic) return mapJavascriptToNRRDStatic[id];
    // Otherwise, just return the id
    return id;
}

function parseNRRDInteger(str) {
    var val = parseInt(str, 10);
    if (Number.isNaN(val)) throw new Error("Malformed NRRD integer: " + str);
    return val;
}

function parseNRRDFloat(str) {
    str = str.toLowerCase();
    if (str.indexOf('nan')>=0) return NaN;
    if (str.indexOf('-inf')>=0) return -Infinity;
    if (str.indexOf('inf')>=0) return Infinity;
    var val = parseFloat(str);
    if (Number.isNaN(val)) throw new Error("Malformed NRRD float: " + str);
    return val;
}

function parseNRRDVector(str) {
    if (str == "none") return null;
    if (str.length<2 || str[0]!=="(" || str[str.length-1]!==")") throw new Error("Malformed NRRD vector: " + str);
    return str.slice(1, -1).split(",").map(parseNRRDFloat);
}

function parseNRRDQuotedString(str) {
    if (length<2 || str[0]!='"' || str[str.length-1]!='"') {
        throw new Error("Invalid NRRD quoted string: " + str);
    }
    return str.slice(1, -1).replace('\\"', '"');
}

function serializeNRRDQuotedString(str) {
    return '"' + str.replace('"', '\\"') + '"';
}

var whitespaceListSeparator = /[ \t]+/; // Note that this excludes other types of whitespace on purpose!
function parseNRRDWhitespaceSeparatedList(str, parseElement) {
    return str.split(whitespaceListSeparator).map(parseElement);
}

function parseNRRDType(descriptor) {
    switch(descriptor.toLowerCase()) {
    case "signed char":
    case "int8":
    case "int8_t":
        return 'int8';
    case "uchar":
    case "unsigned char":
    case "uint8":
    case "uint8_t":
        return 'uint8';
    case "short":
    case "short int":
    case "signed short":
    case "signed short int":
    case "int16":
    case "int16_t":
        return 'int16';
    case "ushort":
    case "unsigned short":
    case "unsigned short int":
    case "uint16":
    case "uint16_t":
        return 'uint16';
    case "int":
    case "signed int":
    case "int32":
    case "int32_t":
        return 'int32';
    case "uint":
    case "unsigned int":
    case "uint32":
    case "uint32_t":
        return 'uint32';
    case "longlong":
    case "long long":
    case "long long int":
    case "signed long long":
    case "signed long long int":
    case "int64":
    case "int64_t":
        return 'int64';
    case "ulonglong":
    case "unsigned long long":
    case "unsigned long long int":
    case "uint64":
    case "uint64_t":
        return 'uint64';
    case "float":
        return 'float';
    case "double":
        return 'double';
    case "block":
        return 'block';
    default:
        console.warn("Unrecognized NRRD type: " + descriptor);
        return descriptor;
    }
}

function parseNRRDEncoding(encoding) {
    switch(encoding.toLowerCase()) {
    case "raw":
        return "raw";
    case "txt":
    case "text":
    case "ascii":
        return "ascii";
    case "hex":
        return "hex";
    case "gz":
    case "gzip":
        return "gzip";
    case "bz2":
    case "bzip2":
        return "bzip2";
    default:
        console.warn("Unrecognized NRRD encoding: " + encoding);
        return encoding;
    }
}

function parseNRRDSpace(space) {
    switch(space.toLowerCase()) {
    case "right-anterior-superior":
    case "ras":
        return "right-anterior-superior";
    case "left-anterior-superior":
    case "las":
        return "left-anterior-superior";
    case "left-posterior-superior":
    case "lps":
        return "left-posterior-superior";
 	  case "right-anterior-superior-time":
 	  case "rast":
        return "right-anterior-superior-time";
    case "left-anterior-superior-time":
    case "last":
        return "left-anterior-superior-time";
    case "left-posterior-superior-time":
    case "lpst":
        return "left-posterior-superior-time";
    case "scanner-xyz":
        return "scanner-xyz";
    case "scanner-xyz-time":
        return "scanner-xyz-time";
    case "3d-right-handed":
        return "3D-right-handed";
    case "3d-left-handed":
        return "3D-left-handed";
    case "3d-right-handed-time":
        return "3D-right-handed-time";
    case "3d-left-handed-time":
        return "3D-left-handed-time";
    default:
        console.warn("Unrecognized space: " + space);
        return space;
    }
}

function parseNRRDEndian(endian) {
    switch(endian.toLowerCase()) {
    case 'little':
        return 'little';
    case 'big':
        return 'big';
    default:
        console.warn("Unrecognized NRRD endianness: " + endian);
        return endian;
    }
}

// Note that this function will never encounter the LIST data file specification format, as this is handled elsewhere.
var dataFileFormatRE = / (-?\d+) (-?\d+) (-?\d+)(?: (\d+))?$/;
function parseNRRDDataFile(dataFile) {
    var match = dataFileFormatRE.exec(dataFile);
    if (match) { // We have a format specification
        if (match.length == 5 && match[4]) { // subdim specification
            return {
                format: dataFile.substring(0, match.index),
                min: parseNRRDInteger(match[1]),
                max: parseNRRDInteger(match[2]),
                step: parseNRRDInteger(match[3]),
                subdim: parseNRRDInteger(match[4])
            };
        } else {
            return {
                format: dataFile.substring(0, match.index),
                min: parseNRRDInteger(match[1]),
                max: parseNRRDInteger(match[2]),
                step: parseNRRDInteger(match[3])
            };
        }
    } else { // Just a file
        return dataFile;
    }
}

function serializeNRRDDataFile(dataFile) {
    if ((typeof dataFile) == "string" || dataFile instanceof String) {
        return dataFile;
    } else if ('format' in dataFile && 'min' in dataFile && 'max' in dataFile && 'step' in dataFile) {
        if ('subdim' in dataFile) {
            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step + " " + dataFile.subdim;
        } else {
            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step;
        }
    } else {
        throw new Error("Unrecognized data file format!");
    }
}

function parseNRRDCenter(center) {
    switch(center.toLowerCase()) {
    case "cell":
        return "cell";
    case "node":
        return "node";
    case "???":
    case "none":
        return null;
    default:
        console.warn("Unrecognized NRRD center: " + center);
        return center;
    }
}

var NRRDKinds = {
    "domain": "domain",
    "space": "space",
    "time": "time",
    "list": "list",
    "point": "point",
    "vector": "vector",
    "covariant-vector": "covariant-vector",
    "normal": "normal",
    "stub": "stub",
    "scalar": "scalar",
    "complex": "complex",
    "2-vector": "2-vector",
    "3-color": "3-color",
    "rgb-color": "RGB-color",
    "hsv-color": "HSV-color",
    "xyz-color": "XYZ-color",
    "4-color": "4-color",
    "rgba-color": "RGBA-color",
    "3-vector": "3-vector",
    "3-gradient": "3-gradient",
    "3-normal": "3-normal",
    "4-vector": "4-vector",
    "quaternion": "quaternion",
    "2d-symmetric-matrix": "2D-symmetric-matrix",
    "2d-masked-symmetric-matrix": "2D-masked-symmetric-matrix",
    "2d-matrix": "2D-matrix",
    "2d-masked-matrix": "2D-masked-matrix",
    "3d-symmetric-matrix": "3D-symmetric-matrix",
    "3d-masked-symmetric-matrix": "3D-masked-symmetric-matrix",
    "3d-matrix": "3D-matrix",
    "3d-masked-matrix": "3D-masked-matrix",
    "???": null,
    "none": null
};
function parseNRRDKind(kind) {
    var kindLC = kind.toLowerCase();
    if (kindLC in NRRDKinds) return NRRDKinds[kindLC];
    console.warn("Unrecognized NRRD kind: " + kind);
    return kind;
}

function serializeNRRDOptional(a) {
    return a===null ? "???" : a;
}

var systemEndianness = (function() {
    var buf = new ArrayBuffer(4),
        intArr = new Uint32Array(buf),
        byteArr = new Uint8Array(buf);
    intArr[0] = 0x01020304;
    if (byteArr[0]==1 && byteArr[1]==2 && byteArr[2]==3 && byteArr[3]==4) {
        return 'big';
    } else if (byteArr[0]==4 && byteArr[1]==3 && byteArr[2]==2 && byteArr[3]==1) {
        return 'little';
    }
    console.warn("Unrecognized system endianness!");
    return undefined;
})();

function parseNRRDRawData(buffer, type, sizes, options) {
    var i, arr, view, totalLen = 1, endianFlag;
    for(i=0; i<sizes.length; i++) {
        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= sizes[i];
    }
    if (type == 'block') {
        // Don't do anything special, just return the slice containing all blocks.
        return buffer.slice(0,totalLen*options.blockSize);
    } else if (type == 'int8' || type == 'uint8' || options.endian == systemEndianness) {
        switch(type) {
        case "int8":
            checkSize(1);
            return new Int8Array(buffer.slice(0,totalLen));
        case "uint8":
            checkSize(1);
            return new Uint8Array(buffer.slice(0,totalLen));
        case "int16":
            checkSize(2);
            return new Int16Array(buffer.slice(0,totalLen*2));
        case "uint16":
            checkSize(2);
            return new Uint16Array(buffer.slice(0,totalLen*2));
        case "int32":
            checkSize(4);
            return new Int32Array(buffer.slice(0,totalLen*4));
        case "uint32":
            checkSize(4);
            return new Uint32Array(buffer.slice(0,totalLen*4));
        //case "int64":
        //    checkSize(8);
        //    return new Int64Array(buffer.slice(0,totalLen*8));
        //case "uint64":
        //    checkSize(8);
        //    return new Uint64Array(buffer.slice(0,totalLen*8));
        case "float":
            checkSize(4);
            return new Float32Array(buffer.slice(0,totalLen*4));
        case "double":
            checkSize(8);
            return new Float64Array(buffer.slice(0,totalLen*8));
        default:
            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");
            return undefined;
        }
    } else {
        switch(options.endian) {
        case 'big':
            endianFlag = false;
            break;
        case 'little':
            endianFlag = true;
            break;
        default:
            console.warn("Unsupported endianness in NRRD file: " + options.endian);
            return undefined;
        }
        view = new DataView(buffer);
        switch(type) {
        case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.
            arr = new Int8Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt8(i);
            }
            return arr;
        case "uint8":
            arr = new Uint8Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint8(i);
            }
            return arr;
        case "int16":
            arr = new Int16Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt16(i*2);
            }
            return arr;
        case "uint16":
            arr = new Uint16Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint16(i*2);
            }
            return arr;
        case "int32":
            arr = new Int32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt32(i*4);
            }
            return arr;
        case "uint32":
            arr = new Uint32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint32(i*4);
            }
            return arr;
        //case "int64":
        //    arr = new Int64Array(totalLen);
        //    for(i=0; i<totalLen; i++) {
        //        arr[i] = view.getInt64(i*8);
        //    }
        //    return arr;
        //case "uint64":
        //    arr = new Uint64Array(totalLen);
        //    for(i=0; i<totalLen; i++) {
        //        arr[i] = view.getUint64(i*8);
        //    }
        //    return arr;
        case "float":
            arr = new Float32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getFloat32(i*4);
            }
            return arr;
        case "double":
            arr = new Float64Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getFloat64(i*8);
            }
            return arr;
        default:
            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");
            return undefined;
        }
    }
    function checkSize(sizeOfType) {
        if (buffer.byteLength<totalLen*sizeOfType) throw new Error("NRRD file does not contain enough data!");
    }
}

var whitespaceDataValueListSeparatorRE = /[ \t\n\r\v\f]+/;
function parseNRRDTextData(buffer, type, sizes) {
    var i, buf8, str, strList, totalLen = 1;
    for(i=0; i<sizes.length; i++) {
        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= sizes[i];
    }
    buf8 = new Uint8Array(buffer);
    str = String.fromCharCode.apply(null, buf8);
    strList = str.split(whitespaceDataValueListSeparatorRE);
    if (strList.length<totalLen) {
        throw new Error("Not enough data in NRRD file!");
    } else if (strList.length>totalLen) {
        if (strList[0] === '') strList = strList.slice(1); // Strictly speaking the spec doesn't (explicitly) allow whitespace in front of the first number, but let's be lenient.
        strList = strList.slice(0, totalLen);
    }
    switch(type) {
    case "int8":
        return new Int8Array(strList.map(parseNRRDInteger));
    case "uint8":
        return new Uint8Array(strList.map(parseNRRDInteger));
    case "int16":
        return new Int16Array(strList.map(parseNRRDInteger));
    case "uint16":
        return new Uint16Array(strList.map(parseNRRDInteger));
    case "int32":
        return new Int32Array(strList.map(parseNRRDInteger));
    case "uint32":
        return new Uint32Array(strList.map(parseNRRDInteger));
    //case "int64":
    //    return new Int64Array(strList.map(parseNRRDInteger));
    //case "uint64":
    //    return new Uint64Array(strList.map(parseNRRDInteger));
    case "float":
        return new Float32Array(strList.map(parseNRRDFloat));
    case "double":
        return new Float64Array(strList.map(parseNRRDFloat));
    default:
        console.warn("Unsupported NRRD type: " + type + ".");
        return undefined;
    }
}

// This ALWAYS returns an integer, or throws an exception.
function getNRRDTypeSize(type) {
    switch(type) {
    case "int8":
        return 1;
    case "uint8":
        return 1;
    case "int16":
        return 2;
    case "uint16":
        return 2;
    case "int32":
        return 4;
    case "uint32":
        return 4;
    case "int64":
        return 8;
    case "uint64":
        return 8;
    case "float":
        return 4;
    case "double":
        return 8;
    default:
        throw new Error("Do not know the size of NRRD type: " + type);
    }
}

function checkNRRD(ret) {
    // Always necessary fields
    if (ret.dimension===undefined) {
        throw new Error("Dimension missing from NRRD file!");
    } else if (ret.type===undefined) {
        throw new Error("Type missing from NRRD file!");
    } else if (ret.encoding===undefined) {
        throw new Error("Encoding missing from NRRD file!");
    } else if (ret.sizes===undefined) {
        throw new Error("Sizes missing from NRRD file!");
    }
    
    // Sometimes necessary fields
    if (ret.type != 'block' && ret.type != 'int8' && ret.type != 'uint8' &&
          ret.encoding != 'ascii' && ret.endian === undefined) {
        throw new Error("Endianness missing from NRRD file!");
    } else if (ret.type == 'block' && ret.blockSize === undefined) {
        throw new Error("Missing block size in NRRD file!");
    }
    
    // Check dimension and per-axis field lengths
    if (ret.dimension === 0) {
        throw new Error("Zero-dimensional NRRD file?");
    } else if (ret.dimension != ret.sizes.length) {
        throw new Error("Length of 'sizes' is different from 'dimension' in an NRRD file!");
    } else if (ret.spacings && ret.dimension != ret.spacings.length) {
        throw new Error("Length of 'spacings' is different from 'dimension' in an NRRD file!");
    } else if (ret.thicknesses && ret.dimension != ret.thicknesses.length) {
        throw new Error("Length of 'thicknesses' is different from 'dimension' in an NRRD file!");
    } else if (ret.axisMins && ret.dimension != ret.axisMins.length) {
        throw new Error("Length of 'axis mins' is different from 'dimension' in an NRRD file!");
    } else if (ret.axisMaxs && ret.dimension != ret.axisMaxs.length) {
        throw new Error("Length of 'axis maxs' is different from 'dimension' in an NRRD file!");
    } else if (ret.centers && ret.dimension != ret.centers.length) {
        throw new Error("Length of 'centers' is different from 'dimension' in an NRRD file!");
    } else if (ret.labels && ret.dimension != ret.labels.length) {
        throw new Error("Length of 'labels' is different from 'dimension' in an NRRD file!");
    } else if (ret.units && ret.dimension != ret.units.length) {
        throw new Error("Length of 'units' is different from 'dimension' in an NRRD file!");
    } else if (ret.kinds && ret.dimension != ret.kinds.length) {
        throw new Error("Length of 'kinds' is different from 'dimension' in an NRRD file!");
    }
    
    // TODO: Check space/orientation fields.
    
    // We should either have inline data or external data
    if ((ret.data === undefined || ret.data.length === 0) && (ret.buffer === undefined || ret.buffer.byteLength === 0) && ret.dataFile === undefined) {
        throw new Error("NRRD file has neither inline or external data!");
    }
}

function castTypedArray(data, type) {
    switch(type) {
    case "int8":
        return new Int8Array(data);
    case "uint8":
        return new Uint8Array(data);
    case "int16":
        return new Int16Array(data);
    case "uint16":
        return new Uint16Array(data);
    case "int32":
        return new Int32Array(data);
    case "uint32":
        return new Uint32Array(data);
    //case "int64":
    //    return new Int64Array(data);
    //case "uint64":
    //    return new Uint64Array(data);
    case "float":
        return new Float32Array(data);
    case "double":
        return new Float64Array(data);
    default:
        throw new Error("Cannot cast to NRRD type: " + type);
    }
}

function serializeToBuffer(data, type, endian) {
    var i, endianFlag, view, nativeSize = getNRRDTypeSize(type), buffer = new ArrayBuffer(data.length*nativeSize);
    switch(endian) {
    case 'big':
        endianFlag = false;
        break;
    case 'little':
        endianFlag = true;
        break;
    default:
        console.warn("Unsupported endianness in NRRD file: " + endian);
        return undefined;
    }
    view = new DataView(buffer);
    switch(type) {
    case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.
        for(i=0; i<data.length; i++) {
            view.setInt8(i, data[i], endianFlag);
        }
        return buffer;
    case "uint8":
        for(i=0; i<data.length; i++) {
            view.setUint8(i, data[i], endianFlag);
        }
        return buffer;
    case "int16":
        for(i=0; i<data.length; i++) {
            view.setInt16(i*2, data[i], endianFlag);
        }
        return buffer;
    case "uint16":
        for(i=0; i<data.length; i++) {
            view.setUint16(i*2, data[i], endianFlag);
        }
        return buffer;
    case "int32":
        for(i=0; i<data.length; i++) {
            view.setInt32(i*4, data[i], endianFlag);
        }
        return buffer;
    case "uint32":
        for(i=0; i<data.length; i++) {
            view.setUint32(i*4, data[i], endianFlag);
        }
        return buffer;
    //case "int64":
    //    for(i=0; i<data.length; i++) {
    //        view.setInt64(i*8, data[i], endianFlag);
    //    }
    //    return buffer;
    //case "uint64":
    //    for(i=0; i<data.length; i++) {
    //        view.setUint64(i*8, data[i], endianFlag);
    //    }
    //    return buffer;
    case "float":
        for(i=0; i<data.length; i++) {
            view.setFloat32(i*4, data[i], endianFlag);
        }
        return buffer;
    case "double":
        for(i=0; i<data.length; i++) {
            view.setFloat64(i*8, data[i], endianFlag);
        }
        return buffer;
    default:
        console.warn("Cannot serialize NRRD type: " + type + ".");
        return undefined;
    }
}

function serializeToTextBuffer(data) {
    var i, strs = new Array(data.length), str, buffer, arr;
    for(i=0; i<data.length; i++) {
        strs[i] = '' + data[i];
    }
    str = strs.join(" ");
    buffer = new ArrayBuffer(str.length);
    arr = new Uint8Array(buffer);
    for(i=0; i<arr.length; i++) {
        arr[i] = str.charCodeAt(i);
    }
    return buffer;
}

},{"assert":3}],51:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":52,"./lib/inflate":53,"./lib/utils/common":54,"./lib/zlib/constants":57}],52:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":54,"./utils/strings":55,"./zlib/deflate":59,"./zlib/messages":64,"./zlib/zstream":66}],53:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":54,"./utils/strings":55,"./zlib/constants":57,"./zlib/gzheader":60,"./zlib/inflate":62,"./zlib/messages":64,"./zlib/zstream":66}],54:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],55:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":54}],56:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],57:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],58:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],59:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  s.d_buf = s.lit_bufsize >> 1;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":54,"./adler32":56,"./crc32":58,"./messages":64,"./trees":65}],60:[function(require,module,exports){
'use strict';


function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],61:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],62:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"../utils/common":54,"./adler32":56,"./crc32":58,"./inffast":61,"./inftrees":63,"dup":12}],63:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../utils/common":54,"dup":13}],64:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],65:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"../utils/common":54,"dup":15}],66:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],67:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":68}],68:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],69:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],70:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],71:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],72:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":70,"./encode":71}],73:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":74,"./_stream_writable":76,"core-util-is":24,"inherits":28,"process-nextick-args":67}],74:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":73,"./internal/streams/BufferList":77,"_process":68,"buffer":20,"buffer-shims":19,"core-util-is":24,"events":26,"inherits":28,"isarray":78,"process-nextick-args":67,"string_decoder/":80,"util":5}],75:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":73,"core-util-is":24,"inherits":28}],76:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = Buffer.isBuffer(chunk);

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":73,"_process":68,"buffer":20,"buffer-shims":19,"core-util-is":24,"events":26,"inherits":28,"process-nextick-args":67,"util-deprecate":83}],77:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
},{"buffer":20,"buffer-shims":19}],78:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],79:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":75}],80:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":20}],81:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":82,"punycode":69,"querystring":72}],82:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],83:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],84:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],85:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],86:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":85,"_process":68,"inherits":84}],87:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );
var ceil = require( 'math-ceil' );
var repeat = require( 'utils-repeat-string' );


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// LEFT PAD //

/**
* FUNCTION: lpad( str, len[, pad] )
*	Left pads a string such that the padded string has a length of at least `len`.
*
* @param {String} str - string to pad
* @param {Number} len - minimum string length
* @param {String} [pad=' '] - string used to pad
* @returns {String} padded string
*/
function lpad( str, len, pad ) {
	var n;
	var p;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( arguments.length > 2 ) {
		p = pad;
		if ( !isString( p ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a string. Value: `' + p + '`.' );
		}
		if ( p.length === 0 ) {
			throw new RangeError( 'invalid input argument. Pad string must not be an empty string.' );
		}
	} else {
		p = ' ';
	}
	if ( len > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	n = ( len - str.length ) / p.length;
	if ( n <= 0 ) {
		return str;
	}
	n = ceil( n );
	return repeat( p, n ) + str;
} // end FUNCTION lpad()


// EXPORTS //

module.exports = lpad;

},{"math-ceil":41,"utils-repeat-string":88,"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],88:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );


// NOTES //

/**
* The algorithmic trick used in the implementation is to treat string concatenation the same as binary addition (i.e., any natural number (nonnegative integer) can be expressed as a sum of powers of two).
*
* For example,
*
*  n = 10 => 1010 => 2^3 + 2^0 + 2^1 + 2^0
*
* We can produce a 10-repeat string by "adding" the results of a 8-repeat string and a 2-repeat string.
*
* The implementation is then as follows:
*  : Let `s` be the string to be repeated and `o` be an output string.
*  0) Initialize an output string `o`.
*  1) Check the least significant bit to determine if the current `s` string should be "added" to the output "total".
*     - if the bit is a one, add
*     - otherwise, move on
*  2) Double the string `s` by adding `s` to `s`.
*  3) Right-shift the bits of `n`.
*  4) Check if we have shifted off all bits.
*     - if yes, done.
*     - otherwise, move on
*  5) Repeat 1-4.
*
* The result is that, as the string is repeated, we continually check to see if the doubled string is one which we want to add to our "total".
*
* The algorithm runs in O(log_2(n)) compared to O(n).
*/


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// REPEAT //

/**
* FUNCTION: repeat( str, n )
*	Repeats a string a specified number of times and returns the concatenated result.
*
* @param {String} str - string to repeat
* @param {Number} n - number of times to repeat the string
* @returns {String}
*/
function repeat( str, n ) {
	var rpt;
	var cnt;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( n ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + n + '`.' );
	}
	if ( str.length === 0 || n === 0 ) {
		return '';
	}
	// Check that output string will not exceed the maximum string length:
	if ( str.length * n > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	rpt = '';
	cnt = n;
	for( ; ; ) {
		// If the count is odd, append the current concatenated string:
		if ( (cnt&1) === 1 ) {
			rpt += str;
		}
		// Right-shift the bits:
		cnt >>>= 1;
		if ( cnt === 0 ) {
			break;
		}
		// Double the string:
		str += str;
	}
	return rpt;
} // end FUNCTION repeat()


// EXPORTS //

module.exports = repeat;

},{"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],89:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );
var ceil = require( 'math-ceil' );
var repeat = require( 'utils-repeat-string' );


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// RIGHT PAD //

/**
* FUNCTION: rpad( str, len[, pad] )
*	Right pads a string such that the padded string has a length of at least `len`.
*
* @param {String} str - string to pad
* @param {Number} len - minimum string length
* @param {String} [pad=' '] - string used to pad
* @returns {String} padded string
*/
function rpad( str, len, pad ) {
	var n;
	var p;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( arguments.length > 2 ) {
		p = pad;
		if ( !isString( p ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a string. Value: `' + p + '`.' );
		}
		if ( p.length === 0 ) {
			throw new RangeError( 'invalid input argument. Pad string must not be an empty string.' );
		}
	} else {
		p = ' ';
	}
	if ( len > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	n = ( len - str.length ) / p.length;
	if ( n <= 0 ) {
		return str;
	}
	n = ceil( n );
	return str + repeat( p, n );
} // end FUNCTION rpad()


// EXPORTS //

module.exports = rpad;

},{"math-ceil":41,"utils-repeat-string":88,"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],90:[function(require,module,exports){
/**
*
*	VALIDATE: integer
*
*
*	DESCRIPTION:
*		- Validates if a value is an integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isNumber = require( 'validate.io-number' );


// ISINTEGER //

/**
* FUNCTION: isInteger( value )
*	Validates if a value is an integer.
*
* @param {Number} value - value to be validated
* @returns {Boolean} boolean indicating whether value is an integer
*/
function isInteger( value ) {
	return isNumber( value ) && value%1 === 0;
} // end FUNCTION isInteger()


// EXPORTS //

module.exports = isInteger;

},{"validate.io-number":92}],91:[function(require,module,exports){
/**
*
*	VALIDATE: nonnegative-integer
*
*
*	DESCRIPTION:
*		- Validates if a value is a nonnegative integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// IS NONNEGATIVE INTEGER //

/**
* FUNCTION: isNonNegativeInteger( value )
*	Validates if a value is a nonnegative integer.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a nonnegative integer
*/
function isNonNegativeInteger( value ) {
	return isInteger( value ) && value >= 0;
} // end FUNCTION isNonNegativeInteger()


// EXPORTS //

module.exports = isNonNegativeInteger;

},{"validate.io-integer":90}],92:[function(require,module,exports){
/**
*
*	VALIDATE: number
*
*
*	DESCRIPTION:
*		- Validates if a value is a number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isNumber( value )
*	Validates if a value is a number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a number
*/
function isNumber( value ) {
	return ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) && value.valueOf() === value.valueOf();
} // end FUNCTION isNumber()


// EXPORTS //

module.exports = isNumber;

},{}],93:[function(require,module,exports){
'use strict';

/**
* Tests if a value is a string primitive.
*
* @param {*} value - value to test
* @returns {Boolean} boolean indicating if a value is a string primitive
*/
function isString( value ) {
	return typeof value === 'string';
} // end FUNCTION isString()


// EXPORTS //

module.exports = isString;

},{}],94:[function(require,module,exports){
module.exports={
  "name": "ami.js",
  "version": "0.0.16-dev",
  "main": "lib/ami.js",
  "keywords": [
    "ami",
    "ami.js",
    "three.js",
    "webgl",
    "dicom",
    "nifti",
    "awesome",
    "medical",
    "imaging",
    "xtk",
    "nrrd",
    "vtk",
    "stl",
    "trk"
  ],
  "author": {
    "name": "Nicolas Rannou",
    "email": "nicolas@eunate.ch",
    "url": "https://eunate.ch"
  },
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://fnndsc.github.io/ami"
  },
  "config": {
    "threeVersion": "r83",
    "amiCDN": "https://cdnjs.cloudflare.com/ajax/libs/ami.js/",
    "gaKey": "UA-39303022-3",
    "transforms": "-t [babelify --presets [ es2015 ] ]"
  },
  "dependencies": {
    "dicom-parser": "1.7.3",
    "image-JPEG2000": "OHIF/image-JPEG2000#master",
    "jpeg-lossless-decoder-js": "1.2.3",
    "math-float32-to-binary-string": "^1.0.0",
    "nifti-reader-js": "v0.5.3",
    "nrrd-js": "^0.2.1",
    "pako": "1.0.1"
  },
  "scripts": {
    "dist:prepare": "node ./scripts/$npm_package_config_mode.js --dist",
    "dist:watchAmi": "watchify -d src/ami $npm_package_config_transforms --standalone AMI -o dist/build/ami.js -v",
    "dist:watch": "watchify $npm_package_config_target -d $npm_package_config_transforms -o dist/$npm_package_config_target -v",
    "dist": "npm run dist:prepare --ami.js:mode=$npm_package_config_mode && (live-server dist --open=$npm_package_config_open & npm run dist:watch --ami.js:target=$npm_package_config_target)",
    "example": "npm run clean && node ./scripts/router.js examples ",
    "lesson": "npm run clean && mkdir dist/build && touch dist/build/ami.js && node ./scripts/router.js lessons ",
    "demo": "node ./scripts/lessons.js --demo",
    "lint": "eslint **/*.js --quiet",
    "build:examples": "npm run dist:prepare --ami.js:mode=examples && find examples -name '*.js' -print0 | xargs -0 -n1 -I{} bash -c \"echo Building {}; browserify {} -d -v $npm_package_config_transforms > dist/{} \"",
    "build:ami": "browserify src/ami.js -d -v $npm_package_config_transforms --standalone AMI > build/ami.js && uglifyjs build/ami.js -o build/ami.min.js",
    "build": "npm run clean && cp index.html dist/index.html && npm run build:examples && npm run doc",
    "build-cjs": "rimraf lib && cross-env BABEL_ENV=cjs babel ./src -d lib",
    "clean": "rm -rf dist/*",
    "test": "karma start",
    "doc": "jsdoc -p -r -R README.md -c jsdoc.conf -d dist/doc src",
    "ami": "npm run lint && npm run demo && npm run build:ami && npm run test",
    "deploy": "npm run build && gh-pages -d dist"
  },
  "devDependencies": {
    "babel-cli": "latest",
    "babel-plugin-add-module-exports": "^0.2.1",
    "babel-polyfill": "^6.13.0",
    "babel-preset-es2015": "^6.13.2",
    "babelify": "7.3.0",
    "browserify": "^13.1.0",
    "cross-env": "^3.2.3",
    "eslint": "latest",
    "eslint-config-google": "latest",
    "gh-pages": "latest",
    "glslify": "5.1.0",
    "jasmine-core": "latest",
    "jsdoc": "jsdoc3/jsdoc#master",
    "karma": "latest",
    "karma-browserify": "latest",
    "karma-jasmine": "latest",
    "karma-phantomjs-launcher": "1.0.4",
    "karma-sinon": "^1.0.5",
    "karma-spec-reporter": "latest",
    "live-server": "^1.1.0",
    "phantomjs-prebuilt": "2.1.14",
    "rimraf": "^2.6.1",
    "shelljs": "latest",
    "sinon": "^2.0.0",
    "uglify-js": "^2.7.3",
    "watchify": "3.7.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "browserify": {
    "transform": [
      "babelify"
    ]
  }
}

},{}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cameras = require('./cameras/cameras');

var _cameras2 = _interopRequireDefault(_cameras);

var _controls = require('./controls/controls');

var _controls2 = _interopRequireDefault(_controls);

var _core = require('./core/core');

var _core2 = _interopRequireDefault(_core);

var _geometries = require('./geometries/geometries');

var _geometries2 = _interopRequireDefault(_geometries);

var _helpers = require('./helpers/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _loaders = require('./loaders/loaders');

var _loaders2 = _interopRequireDefault(_loaders);

var _models = require('./models/models');

var _models2 = _interopRequireDefault(_models);

var _parsers = require('./parsers/parsers');

var _parsers2 = _interopRequireDefault(_parsers);

var _shaders = require('./shaders/shaders');

var _shaders2 = _interopRequireDefault(_shaders);

var _widgets = require('./widgets/widgets');

var _widgets2 = _interopRequireDefault(_widgets);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var pckg = require('../package.json');

exports.default = {
  Cameras: _cameras2.default,
  Controls: _controls2.default,
  Core: _core2.default,
  Geometries: _geometries2.default,
  Helpers: _helpers2.default,
  Loaders: _loaders2.default,
  Models: _models2.default,
  Parsers: _parsers2.default,
  Shaders: _shaders2.default,
  Widgets: _widgets2.default
};

window.console.log('AMI ' + pckg.version + ' ( ThreeJS ' + pckg.config.threeVersion + ')');

},{"../package.json":94,"./cameras/cameras":96,"./controls/controls":98,"./core/core":103,"./geometries/geometries":107,"./helpers/helpers":112,"./loaders/loaders":128,"./models/models":132,"./parsers/parsers":137,"./shaders/shaders":155,"./widgets/widgets":169}],96:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cameras = require('./cameras.orthographic');

var _cameras2 = _interopRequireDefault(_cameras);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module cameras
 */
exports.default = {
  Orthographic: _cameras2.default
};

},{"./cameras.orthographic":97}],97:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('../core/core.validators');

var _core4 = _interopRequireDefault(_core3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * Orthographic camera from THREE.JS with some extra convenience
 * functionalities.
 *
 * @example
 * //
 * //
 *
 * @module cameras/orthographic
 */
var CamerasOrthographic = function (_THREE$OrthographicCa) {
  _inherits(CamerasOrthographic, _THREE$OrthographicCa);

  function CamerasOrthographic(left, right, top, bottom, near, far) {
    _classCallCheck(this, CamerasOrthographic);

    var _this = _possibleConstructorReturn(this, (CamerasOrthographic.__proto__ || Object.getPrototypeOf(CamerasOrthographic)).call(this, left, right, top, bottom, near, far));

    _this._front = null;
    _this._back = null;

    _this._directions = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];

    _this._directionsLabel = ['A', 'P', // TOP/BOTTOM
    'L', 'R', // LEFT/RIGHT
    'I', 'S'];

    _this._orientation = 'default';
    _this._convention = 'radio';
    _this._stackOrientation = 0;

    _this._right = null;
    _this._up = null;
    _this._direction = null;

    _this._controls = null;
    _this._box = null;
    _this._canvas = {
      width: null,
      height: null
    };

    _this._fromFront = true;
    _this._angle = 0;
    return _this;
  }

  /**
   * Initialize orthographic camera variables
   */

  _createClass(CamerasOrthographic, [{
    key: 'init',
    value: function init(xCosine, yCosine, zCosine, controls, box, canvas) {
      // DEPRECATED
      console.warn('cameras.orthographic.init(...) is deprecated.\n      Use .cosines, .controls, .box and .canvas instead.');

      //
      if (!(_core4.default.vector3(xCosine) && _core4.default.vector3(yCosine) && _core4.default.vector3(zCosine) && _core4.default.box(box) && controls)) {
        window.console.log('Invalid input provided.');

        return false;
      }

      this._right = xCosine;
      this._up = this._adjustTopDirection(xCosine, yCosine);
      this._direction = new THREE.Vector3().crossVectors(this._right, this._up);
      this._controls = controls;
      this._box = box;
      this._canvas = canvas;

      var ray = {
        position: this._box.center,
        direction: this._direction
      };

      var intersections = this._orderIntersections(_core2.default.rayBox(ray, this._box), this._direction);
      this._front = intersections[0];
      this._back = intersections[1];

      // set default values
      this.up.set(this._up.x, this._up.y, this._up.z);
      this._updateCanvas();
      this._updatePositionAndTarget(this._front, this._back);
      this._updateMatrices();
      this._updateDirections();
    }
  }, {
    key: 'update',
    value: function update() {
      // http://www.grahamwideman.com/gw/brain/orientation/orientterms.htm
      // do magics depending on orientation and convention
      // also needs a default mode

      if (this._orientation === 'default') {
        switch (this._getMaxIndex(this._directions[2])) {

          case 0:
            this._orientation = 'sagittal';
            break;

          case 1:
            this._orientation = 'coronal';
            break;

          case 2:
            this._orientation = 'axial';
            break;

          default:
            this._orientation = 'free';
            break;
        }
      }

      if (this._orientation === 'free') {
        this._right = this._directions[0];
        this._up = this._directions[1];
        this._direction = this._directions[2];
      } else {
        var leftIndex = this.leftDirection();
        var leftDirection = this._directions[leftIndex];
        var posteriorIndex = this.posteriorDirection();
        var posteriorDirection = this._directions[posteriorIndex];
        var superiorIndex = this.superiorDirection();
        var superiorDirection = this._directions[superiorIndex];

        if (this._convention === 'radio') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards superior
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards posterior
              if (posteriorDirection.y < 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn('"' + this._orientation + '" orientation is not valid.\n                (choices: axial, coronal, sagittal)');
              break;

          }
        } else if (this._convention === 'neuro') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards inferior
              if (superiorDirection.z > 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards anterior
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn('"' + this._orientation + '" orientation is not valid.\n                (choices: axial, coronal, sagittal)');
              break;
          }
        } else {
          console.warn(this._convention + ' is not valid (choices: radio, neuro)');
        }
      }

      // that is what determines left/right
      var ray = {
        position: this._box.center,
        direction: this._direction
      };

      var intersections = this._orderIntersections(_core2.default.rayBox(ray, this._box), this._direction);
      this._front = intersections[0];
      this._back = intersections[1];

      // set default values
      this.up.set(this._up.x, this._up.y, this._up.z);
      this._updateCanvas();
      this._updatePositionAndTarget(this._front, this._back);
      this._updateMatrices();
      this._updateDirections();
    }
  }, {
    key: 'leftDirection',
    value: function leftDirection() {
      return this._findMaxIndex(this._directions, 0);
    }
  }, {
    key: 'posteriorDirection',
    value: function posteriorDirection() {
      return this._findMaxIndex(this._directions, 1);
    }
  }, {
    key: 'superiorDirection',
    value: function superiorDirection() {
      return this._findMaxIndex(this._directions, 2);
    }

    /**
     * Invert rows in the current slice.
     * Inverting rows in 2 steps:
     *   * Flip the "up" vector
     *   * Look at the slice from the other side
     */

  }, {
    key: 'invertRows',
    value: function invertRows() {
      // flip "up" vector
      // we flip up first because invertColumns update projectio matrices
      this.up.multiplyScalar(-1);
      this.invertColumns();

      this._updateDirections();
    }

    /**
     * Invert rows in the current slice.
     * Inverting rows in 1 step:
     *   * Look at the slice from the other side
     */

  }, {
    key: 'invertColumns',
    value: function invertColumns() {
      this.center();
      // rotate 180 degrees around the up vector...
      var oppositePosition = this._oppositePosition(this.position);

      // update posistion and target
      // clone is needed because this.position is overwritten in method
      this._updatePositionAndTarget(oppositePosition, this.position.clone());
      this._updateMatrices();
      this._fromFront = !this._fromFront;

      this._angle %= 360;
      this._angle = 360 - this._angle;

      this._updateDirections();
    }

    /**
     * Center slice in the camera FOV.
     * It also updates the controllers properly.
     * We can center a camera from the front or from the back.
     */

  }, {
    key: 'center',
    value: function center() {
      if (this._fromFront) {
        this._updatePositionAndTarget(this._front, this._back);
      } else {
        this._updatePositionAndTarget(this._back, this._front);
      }

      this._updateMatrices();
      this._updateDirections();
    }

    /**
     * Pi/2 rotation around the zCosine axis.
     * Clock-wise rotation from the user point of view.
     */

  }, {
    key: 'rotate',
    value: function rotate() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.center();

      var computedAngle = 90;

      var clockwise = 1;
      if (!this._fromFront) {
        clockwise = -1;
      }

      if (angle === null) {
        computedAngle *= -clockwise;
        this._angle += 90;
      } else {
        computedAngle = 360 - clockwise * (angle - this._angle);
        this._angle = angle;
      }

      this._angle %= 360;

      // Rotate the up vector around the "zCosine"
      var rotation = new THREE.Matrix4().makeRotationAxis(this._direction, computedAngle * Math.PI / 180);
      this.up.applyMatrix4(rotation);

      this._updateMatrices();
      this._updateDirections();
    }

    // dimensions[0] // width
    // dimensions[1] // height
    // direction= 0 width, 1 height, 2 best
    // factor

  }, {
    key: 'fitBox',
    value: function fitBox() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.5;

      //
      // if (!(dimensions && dimensions.length >= 2)) {
      //   window.console.log('Invalid dimensions container.');
      //   window.console.log(dimensions);

      //   return false;
      // }

      //
      var zoom = 1;

      // update zoom
      switch (direction) {
        case 0:
          zoom = factor * this._computeZoom(this._canvas.width, this._right);
          break;
        case 1:
          zoom = factor * this._computeZoom(this._canvas.height, this._up);
          break;
        case 2:
          zoom = factor * Math.min(this._computeZoom(this._canvas.width, this._right), this._computeZoom(this._canvas.height, this._up));
          break;
        default:
          break;
      }

      if (!zoom) {
        return false;
      }

      this.zoom = zoom;

      this.center();
    }
  }, {
    key: '_adjustTopDirection',
    value: function _adjustTopDirection(horizontalDirection, verticalDirection) {
      var vMaxIndex = this._getMaxIndex(verticalDirection);

      // should handle vMax index === 0
      if (vMaxIndex === 2 && verticalDirection.getComponent(vMaxIndex) < 0 || vMaxIndex === 1 && verticalDirection.getComponent(vMaxIndex) > 0 || vMaxIndex === 0 && verticalDirection.getComponent(vMaxIndex) > 0) {
        verticalDirection.negate();
      }

      return verticalDirection;
    }
  }, {
    key: '_getMaxIndex',
    value: function _getMaxIndex(vector) {
      // init with X value
      var maxValue = Math.abs(vector.x);
      var index = 0;

      if (Math.abs(vector.y) > maxValue) {
        maxValue = Math.abs(vector.y);
        index = 1;
      }

      if (Math.abs(vector.z) > maxValue) {
        index = 2;
      }

      return index;
    }
  }, {
    key: '_findMaxIndex',
    value: function _findMaxIndex(directions, target) {
      // get index of the most superior direction
      var maxIndices = this._getMaxIndices(directions);

      for (var i = 0; i < maxIndices.length; i++) {
        if (maxIndices[i] === target) {
          return i;
        }
      }
    }
  }, {
    key: '_getMaxIndices',
    value: function _getMaxIndices(directions) {
      var indices = [];
      indices.push(this._getMaxIndex(directions[0]));
      indices.push(this._getMaxIndex(directions[1]));
      indices.push(this._getMaxIndex(directions[2]));

      return indices;
    }
  }, {
    key: '_orderIntersections',
    value: function _orderIntersections(intersections, direction) {
      var ordered = intersections[0].dot(direction) < intersections[1].dot(direction);

      if (!ordered) {
        return [intersections[1], intersections[0]];
      }

      return intersections;
    }
  }, {
    key: '_updateCanvas',
    value: function _updateCanvas() {
      var camFactor = 2;
      this.left = -this._canvas.width / camFactor;
      this.right = this._canvas.width / camFactor;
      this.top = this._canvas.height / camFactor;
      this.bottom = -this._canvas.height / camFactor;

      this._updateMatrices();
      this.controls.handleResize();
    }
  }, {
    key: '_oppositePosition',
    value: function _oppositePosition(position) {
      var oppositePosition = position.clone();
      // center world postion around box center
      oppositePosition.sub(this._box.center);
      // rotate
      var rotation = new THREE.Matrix4().makeRotationAxis(this.up, Math.PI);

      oppositePosition.applyMatrix4(rotation);
      // translate back to world position
      oppositePosition.add(this._box.center);
      return oppositePosition;
    }
  }, {
    key: '_computeZoom',
    value: function _computeZoom(dimension, direction) {
      if (!(dimension && dimension > 0)) {
        window.console.log('Invalid dimension provided.');
        window.console.log(dimension);
        return false;
      }

      // ray
      var ray = {
        position: this._box.center.clone(),
        direction: direction
      };

      var intersections = _core2.default.rayBox(ray, this._box);
      if (intersections.length < 2) {
        window.console.log('Can not adjust the camera ( < 2 intersections).');
        window.console.log(ray);
        window.console.log(this._box);
        return false;
      }

      return dimension / intersections[0].distanceTo(intersections[1]);
    }
  }, {
    key: '_updatePositionAndTarget',
    value: function _updatePositionAndTarget(position, target) {
      // position
      this.position.set(position.x, position.y, position.z);

      // targets
      this.lookAt(target.x, target.y, target.z);
      this._controls.target.set(target.x, target.y, target.z);
    }
  }, {
    key: '_updateMatrices',
    value: function _updateMatrices() {
      this._controls.update();
      // THEN camera
      this.updateProjectionMatrix();
      this.updateMatrixWorld();
    }
  }, {
    key: '_updateLabels',
    value: function _updateLabels() {
      this._directionsLabel = [this._vector2Label(this._up), this._vector2Label(this._up.clone().negate()), this._vector2Label(this._right), this._vector2Label(this._right.clone().negate()), this._vector2Label(this._direction), this._vector2Label(this._direction.clone().negate())];
    }
  }, {
    key: '_vector2Label',
    value: function _vector2Label(direction) {
      var index = this._getMaxIndex(direction);
      // set vector max value to 1
      var scaledDirection = direction.clone().divideScalar(Math.abs(direction.getComponent(index)));
      var delta = 0.2;
      var label = '';

      // loop through components of the vector
      for (var i = 0; i < 3; i++) {
        if (i === 0) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'L';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'R';
          }
        }

        if (i === 1) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'P';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'A';
          }
        }

        if (i === 2) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'S';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'I';
          }
        }
      }

      return label;
    }
  }, {
    key: '_updateDirections',
    value: function _updateDirections() {
      // up is correct
      this._up = this.up.clone();

      // direction
      var pLocal = new THREE.Vector3(0, 0, -1);
      var pWorld = pLocal.applyMatrix4(this.matrixWorld);
      this._direction = pWorld.sub(this.position).normalize();

      // right
      this._right = new THREE.Vector3().crossVectors(this._direction, this.up);

      // update labels accordingly
      this._updateLabels();
    }
  }, {
    key: 'controls',
    set: function set(controls) {
      this._controls = controls;
    },
    get: function get() {
      return this._controls;
    }
  }, {
    key: 'box',
    set: function set(box) {
      this._box = box;
    },
    get: function get() {
      return this._box;
    }
  }, {
    key: 'canvas',
    set: function set(canvas) {
      this._canvas = canvas;
      this._updateCanvas();
    },
    get: function get() {
      return this._canvas;
    }
  }, {
    key: 'angle',
    set: function set(angle) {
      this.rotate(angle);
    },
    get: function get() {
      return this._angle;
    }
  }, {
    key: 'directions',
    set: function set(directions) {
      this._directions = directions;
    },
    get: function get() {
      return this._directions;
    }
  }, {
    key: 'convention',
    set: function set(convention) {
      this._convention = convention;
    },
    get: function get() {
      return this._convention;
    }
  }, {
    key: 'orientation',
    set: function set(orientation) {
      this._orientation = orientation;
    },
    get: function get() {
      return this._orientation;
    }
  }, {
    key: 'directionsLabel',
    set: function set(directionsLabel) {
      this._directionsLabel = directionsLabel;
    },
    get: function get() {
      return this._directionsLabel;
    }
  }, {
    key: 'stackOrientation',
    set: function set(stackOrientation) {
      this._stackOrientation = stackOrientation;

      if (this._stackOrientation === 0) {
        this._orientation = 'default';
      } else {
        var maxIndex = this._getMaxIndex(this._directions[(this._stackOrientation + 2) % 3]);

        if (maxIndex === 0) {
          this._orientation = 'sagittal';
        } else if (maxIndex === 1) {
          this._orientation = 'coronal';
        } else if (maxIndex === 2) {
          this._orientation = 'axial';
        }
      }
    },
    get: function get() {
      //
      if (this._orientation === 'default') {
        this._stackOrientation = 0;
      } else {
        var maxIndex = this._getMaxIndex(this._direction);

        if (maxIndex === this._getMaxIndex(this._directions[2])) {
          this._stackOrientation = 0;
        } else if (maxIndex === this._getMaxIndex(this._directions[0])) {
          this._stackOrientation = 1;
        } else if (maxIndex === this._getMaxIndex(this._directions[1])) {
          this._stackOrientation = 2;
        }
      }

      return this._stackOrientation;
    }
  }]);

  return CamerasOrthographic;
}(THREE.OrthographicCamera);

exports.default = CamerasOrthographic;

},{"../core/core.intersections":102,"../core/core.validators":106}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _controls = require('./controls.trackball');

var _controls2 = _interopRequireDefault(_controls);

var _controls3 = require('./controls.trackballortho');

var _controls4 = _interopRequireDefault(_controls3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = {
  Trackball: _controls2.default,
  TrackballOrtho: _controls4.default
};

},{"./controls.trackball":99,"./controls.trackballortho":100}],99:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * Original authors from THREEJS repo
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Simone Manini / http://daron1337.github.io
 * @author Luca Antiga  / http://lantiga.github.io
 */

var Trackball = function (_THREE$EventDispatche) {
  _inherits(Trackball, _THREE$EventDispatche);

  function Trackball(object, domElement) {
    _classCallCheck(this, Trackball);

    var _this2 = _possibleConstructorReturn(this, (Trackball.__proto__ || Object.getPrototypeOf(Trackball)).call(this));

    var _this = _this2;
    var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5, CUSTOM: 99 };

    _this2.object = object;
    _this2.domElement = domElement !== undefined ? domElement : document;

    // API

    _this2.enabled = true;

    _this2.screen = { left: 0, top: 0, width: 0, height: 0 };

    _this2.rotateSpeed = 1.0;
    _this2.zoomSpeed = 1.2;
    _this2.panSpeed = 0.3;

    _this2.noRotate = false;
    _this2.noZoom = false;
    _this2.noPan = false;
    _this2.noCustom = false;

    _this2.forceState = -1;

    _this2.staticMoving = false;
    _this2.dynamicDampingFactor = 0.2;

    _this2.minDistance = 0;
    _this2.maxDistance = Infinity;

    _this2.keys = [65 /* A*/, 83 /* S*/, 68];

    // internals

    _this2.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _movePrev = new THREE.Vector2(),
        _moveCurr = new THREE.Vector2(),
        _lastAxis = new THREE.Vector3(),
        _lastAngle = 0,
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2(),
        _customStart = new THREE.Vector2(),
        _customEnd = new THREE.Vector2();

    // for reset

    _this2.target0 = _this2.target.clone();
    _this2.position0 = _this2.object.position.clone();
    _this2.up0 = _this2.object.up.clone();

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    // methods

    _this2.handleResize = function () {
      if (this.domElement === document) {
        this.screen.left = 0;
        this.screen.top = 0;
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
      } else {
        var box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
      }
    };

    _this2.handleEvent = function (event) {
      if (typeof this[event.type] == 'function') {
        this[event.type](event);
      }
    };

    var getMouseOnScreen = function () {
      var vector = new THREE.Vector2();

      return function (pageX, pageY) {
        vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

        return vector;
      };
    }();

    var getMouseOnCircle = function () {
      var vector = new THREE.Vector2();

      return function (pageX, pageY) {
        vector.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5), (_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width);

        return vector;
      };
    }();

    _this2.rotateCamera = function () {
      var axis = new THREE.Vector3(),
          quaternion = new THREE.Quaternion(),
          eyeDirection = new THREE.Vector3(),
          objectUpDirection = new THREE.Vector3(),
          objectSidewaysDirection = new THREE.Vector3(),
          moveDirection = new THREE.Vector3(),
          angle = void 0;

      return function () {
        moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
        angle = moveDirection.length();

        if (angle) {
          _eye.copy(_this.object.position).sub(_this.target);

          eyeDirection.copy(_eye).normalize();
          objectUpDirection.copy(_this.object.up).normalize();
          objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();

          objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
          objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);

          moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));

          axis.crossVectors(moveDirection, _eye).normalize();

          angle *= _this.rotateSpeed;
          quaternion.setFromAxisAngle(axis, angle);

          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);

          _lastAxis.copy(axis);
          _lastAngle = angle;
        } else if (!_this.staticMoving && _lastAngle) {
          _lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);
          _eye.copy(_this.object.position).sub(_this.target);
          quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);
        }

        _movePrev.copy(_moveCurr);
      };
    }();

    _this2.zoomCamera = function () {
      var factor = void 0;

      if (_state === STATE.TOUCH_ZOOM) {
        factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;
        _eye.multiplyScalar(factor);
      } else {
        factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

        if (factor !== 1.0 && factor > 0.0) {
          _eye.multiplyScalar(factor);

          if (_this.staticMoving) {
            _zoomStart.copy(_zoomEnd);
          } else {
            _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
          }
        }
      }
    };

    _this2.panCamera = function () {
      var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();

      return function () {
        mouseChange.copy(_panEnd).sub(_panStart);

        if (mouseChange.lengthSq()) {
          mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

          pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

          _this.object.position.add(pan);
          _this.target.add(pan);

          if (_this.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
          }
        }
      };
    }();

    _this2.checkDistances = function () {
      if (!_this.noZoom || !_this.noPan) {
        if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {
          _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));
        }

        if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {
          _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));
        }
      }
    };

    _this2.update = function () {
      _eye.subVectors(_this.object.position, _this.target);

      if (!_this.noRotate) {
        _this.rotateCamera();
      }

      if (!_this.noZoom) {
        _this.zoomCamera();
      }

      if (!_this.noPan) {
        _this.panCamera();
      }

      if (!_this.noCustom) {
        _this.custom(_customStart, _customEnd);
      }

      _this.object.position.addVectors(_this.target, _eye);

      _this.checkDistances();

      _this.object.lookAt(_this.target);

      if (lastPosition.distanceToSquared(_this.object.position) > EPS) {
        _this.dispatchEvent(changeEvent);

        lastPosition.copy(_this.object.position);
      }
    };

    _this2.reset = function () {
      _state = STATE.NONE;
      _prevState = STATE.NONE;

      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.up.copy(_this.up0);

      _eye.subVectors(_this.object.position, _this.target);

      _this.object.lookAt(_this.target);

      _this.dispatchEvent(changeEvent);

      lastPosition.copy(_this.object.position);
    };

    _this2.setState = function (targetState) {
      _this.forceState = targetState;
      _prevState = targetState;
      _state = targetState;
    };

    _this2.custom = function (customStart, customEnd) {};

    // listeners

    function keydown(event) {
      if (_this.enabled === false) return;

      window.removeEventListener('keydown', keydown);

      _prevState = _state;

      if (_state !== STATE.NONE) {
        return;
      } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
        _state = STATE.ROTATE;
      } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
        _state = STATE.ZOOM;
      } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
        _state = STATE.PAN;
      }
    }

    function keyup(event) {
      if (_this.enabled === false) return;

      _state = _prevState;

      window.addEventListener('keydown', keydown, false);
    }

    function mousedown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.NONE) {
        _state = event.button;
      }

      if (_state === STATE.ROTATE && !_this.noRotate) {
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
        _movePrev.copy(_moveCurr);
      } else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      } else if (_state === STATE.CUSTOM && !_this.noCustom) {
        _customStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _customEnd.copy(_panStart);
      }

      document.addEventListener('mousemove', mousemove, false);
      document.addEventListener('mouseup', mouseup, false);

      _this.dispatchEvent(startEvent);
    }

    function mousemove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.ROTATE && !_this.noRotate) {
        _movePrev.copy(_moveCurr);
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
      } else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.CUSTOM && !_this.noCustom) {
        _customEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }

    function mouseup(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_this.forceState === -1) {
        _state = STATE.NONE;
      }

      document.removeEventListener('mousemove', mousemove);
      document.removeEventListener('mouseup', mouseup);
      _this.dispatchEvent(endEvent);
    }

    function mousewheel(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta / 40;
      } else if (event.detail) {
        // Firefox

        delta = -event.detail / 3;
      }

      if (_state !== STATE.CUSTOM) {
        _zoomStart.y += delta * 0.01;
      } else if (_state === STATE.CUSTOM) {
        _customStart.y += delta * 0.01;
      }

      _this.dispatchEvent(startEvent);
      _this.dispatchEvent(endEvent);
    }

    function touchstart(event) {
      if (_this.enabled === false) return;

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;

          case 2:
            _state = STATE.TOUCH_ZOOM;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panStart.copy(getMouseOnScreen(x, y));
            _panEnd.copy(_panStart);
            break;

          default:
            _state = STATE.NONE;

        }
      } else {
        // { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, CUSTOM: 99 };
        switch (_state) {

          case 0:
            // 1 or 2 fingers, smae behavior
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;

          case 1:
          case 4:
            if (event.touches.length >= 2) {
              _state = STATE.TOUCH_ZOOM;
              var dx = event.touches[0].pageX - event.touches[1].pageX;
              var dy = event.touches[0].pageY - event.touches[1].pageY;
              _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
            } else {
              _state = STATE.ZOOM;
              _zoomStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
              _zoomEnd.copy(_zoomStart);
            }
            break;

          case 2:
          case 5:
            if (event.touches.length >= 2) {
              _state = STATE.TOUCH_PAN;
              var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
              _panStart.copy(getMouseOnScreen(x, y));
              _panEnd.copy(_panStart);
            } else {
              _state = STATE.PAN;
              _panStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
              _panEnd.copy(_panStart);
            }
            break;

          case 99:
            _state = STATE.CUSTOM;
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customStart.copy(getMouseOnScreen(x, y));
            _customEnd.copy(_customStart);
            break;

          default:
            _state = STATE.NONE;

        }
      }

      _this.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;

          default:
            _state = STATE.NONE;
        }
      } else {
        // { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, CUSTOM: 99 };
        switch (_state) {

          case 0:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 1:
            _zoomEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            _panEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 4:
            // 2 fingers!
            // TOUCH ZOOM
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
            break;

          case 5:
            // 2 fingers
            // TOUCH_PAN
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;

          case 99:
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customEnd.copy(getMouseOnScreen(x, y));
            break;

          default:
            _state = STATE.NONE;

        }
      }
    }

    function touchend(event) {
      if (_this.enabled === false) return;

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            _panStart.copy(_panEnd);
            break;

        }

        _state = STATE.NONE;
      } else {
        switch (_state) {

          case 0:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 1:
          case 2:
            break;

          case 4:
            // TOUCH ZOOM
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
            _state = STATE.ZOOM;
            break;

          case 5:
            // TOUCH ZOOM
            if (event.touches.length >= 2) {
              var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
              _panEnd.copy(getMouseOnScreen(x, y));
              _panStart.copy(_panEnd);
            }
            _state = STATE.PAN;
            break;

          case 99:
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customEnd.copy(getMouseOnScreen(x, y));
            _customStart.copy(_customEnd);
            break;

          default:
            _state = STATE.NONE;

        }
      }

      _this.dispatchEvent(endEvent);
    }

    _this2.domElement.addEventListener('contextmenu', function (event) {
      event.preventDefault();
    }, false);

    _this2.domElement.addEventListener('mousedown', mousedown, false);

    _this2.domElement.addEventListener('mousewheel', mousewheel, false);
    _this2.domElement.addEventListener('DOMMouseScroll', mousewheel, false); // firefox

    _this2.domElement.addEventListener('touchstart', touchstart, false);
    _this2.domElement.addEventListener('touchend', touchend, false);
    _this2.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    _this2.handleResize();

    // force an update at start
    _this2.update();
    return _this2;
  }

  return Trackball;
}(THREE.EventDispatcher);

exports.default = Trackball;

},{}],100:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Patrick Fuller / http://patrick-fuller.com
 * @author Max Smolens / https://github.com/msmolens
 */

var Trackballortho = function (_THREE$EventDispatche) {
  _inherits(Trackballortho, _THREE$EventDispatche);

  function Trackballortho(object, domElement) {
    var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { NONE: -1, ROTATE: 1, ZOOM: 2, PAN: 0, SCROLL: 4, TOUCH_ROTATE: 4, TOUCH_ZOOM_PAN: 5 };

    _classCallCheck(this, Trackballortho);

    var _this2 = _possibleConstructorReturn(this, (Trackballortho.__proto__ || Object.getPrototypeOf(Trackballortho)).call(this));

    var _this = _this2;
    var STATE = state;

    _this2.object = object;
    _this2.domElement = domElement !== undefined ? domElement : document;

    // API

    _this2.enabled = true;

    _this2.screen = { left: 0, top: 0, width: 0, height: 0 };

    _this2.radius = 0;

    _this2.zoomSpeed = 1.2;

    _this2.noZoom = false;
    _this2.noPan = false;

    _this2.staticMoving = false;
    _this2.dynamicDampingFactor = 0.2;

    _this2.keys = [65 /* A*/, 83 /* S*/, 68];

    // internals

    _this2.target = new THREE.Vector3();

    var EPS = 0.000001;

    var _changed = true;

    var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2();

    // window level fire after...

    // for reset

    _this2.target0 = _this2.target.clone();
    _this2.position0 = _this2.object.position.clone();
    _this2.up0 = _this2.object.up.clone();

    _this2.left0 = _this2.object.left;
    _this2.right0 = _this2.object.right;
    _this2.top0 = _this2.object.top;
    _this2.bottom0 = _this2.object.bottom;

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    // methods

    _this2.handleResize = function () {
      if (this.domElement === document) {
        this.screen.left = 0;
        this.screen.top = 0;
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
      } else {
        var box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
      }

      this.radius = 0.5 * Math.min(this.screen.width, this.screen.height);

      this.left0 = this.object.left;
      this.right0 = this.object.right;
      this.top0 = this.object.top;
      this.bottom0 = this.object.bottom;
    };

    _this2.handleEvent = function (event) {
      if (typeof this[event.type] == 'function') {
        this[event.type](event);
      }
    };

    var getMouseOnScreen = function () {
      var vector = new THREE.Vector2();

      return function getMouseOnScreen(pageX, pageY) {
        vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

        return vector;
      };
    }();

    _this2.zoomCamera = function () {
      if (_state === STATE.TOUCH_ZOOM_PAN) {
        var factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;

        _this.object.zoom *= factor;

        _changed = true;
      } else {
        var factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

        if (Math.abs(factor - 1.0) > EPS && factor > 0.0) {
          _this.object.zoom /= factor;

          if (_this.staticMoving) {
            _zoomStart.copy(_zoomEnd);
          } else {
            _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
          }

          _changed = true;
        }
      }
    };

    _this2.panCamera = function () {
      var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();

      return function panCamera() {
        mouseChange.copy(_panEnd).sub(_panStart);

        if (mouseChange.lengthSq()) {
          // Scale movement to keep clicked/dragged position under cursor
          var scale_x = (_this.object.right - _this.object.left) / _this.object.zoom;
          var scale_y = (_this.object.top - _this.object.bottom) / _this.object.zoom;
          mouseChange.x *= scale_x;
          mouseChange.y *= scale_y;

          pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

          _this.object.position.add(pan);
          _this.target.add(pan);

          if (_this.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
          }

          _changed = true;
        }
      };
    }();

    _this2.update = function () {
      _eye.subVectors(_this.object.position, _this.target);

      if (!_this.noZoom) {
        _this.zoomCamera();

        if (_changed) {
          _this.object.updateProjectionMatrix();
        }
      }

      if (!_this.noPan) {
        _this.panCamera();
      }

      _this.object.position.addVectors(_this.target, _eye);

      _this.object.lookAt(_this.target);

      if (_changed) {
        _this.dispatchEvent(changeEvent);

        _changed = false;
      }
    };

    _this2.reset = function () {
      _state = STATE.NONE;
      _prevState = STATE.NONE;

      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.up.copy(_this.up0);

      _eye.subVectors(_this.object.position, _this.target);

      _this.object.left = _this.left0;
      _this.object.right = _this.right0;
      _this.object.top = _this.top0;
      _this.object.bottom = _this.bottom0;

      _this.object.lookAt(_this.target);

      _this.dispatchEvent(changeEvent);

      _changed = false;
    };

    // listeners

    function keydown(event) {
      if (_this.enabled === false) return;

      window.removeEventListener('keydown', keydown);

      _prevState = _state;

      if (_state !== STATE.NONE) {
        return;
      } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
        _state = STATE.ROTATE;
      } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
        _state = STATE.ZOOM;
      } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
        _state = STATE.PAN;
      }
    }

    function keyup(event) {
      if (_this.enabled === false) return;

      _state = _prevState;

      window.addEventListener('keydown', keydown, false);
    }

    function mousedown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.NONE) {
        _state = event.button;
      }

      if (_state === STATE.ROTATE && !_this.noRotate) {} else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      }

      document.addEventListener('mousemove', mousemove, false);
      document.addEventListener('mouseup', mouseup, false);

      _this.dispatchEvent(startEvent);
    }

    function mousemove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.ROTATE && !_this.noRotate) {} else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }

    function mouseup(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      _state = STATE.NONE;

      document.removeEventListener('mousemove', mousemove);
      document.removeEventListener('mouseup', mouseup);
      _this.dispatchEvent(endEvent);
    }

    function mousewheel(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta / 40;
      } else if (event.detail) {
        // Firefox

        delta = -event.detail / 3;
      }

      // FIRE SCROLL EVENT

      _this.dispatchEvent({
        type: 'OnScroll',
        delta: delta
      });

      // _zoomStart.y += delta * 0.01;
      _this.dispatchEvent(startEvent);
      _this.dispatchEvent(endEvent);
    }

    function touchstart(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {

        case 1:
          _state = STATE.TOUCH_ROTATE;

          break;

        case 2:
          _state = STATE.TOUCH_ZOOM_PAN;
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panStart.copy(getMouseOnScreen(x, y));
          _panEnd.copy(_panStart);
          break;

        default:
          _state = STATE.NONE;

      }
      _this.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      switch (event.touches.length) {

        case 1:

          break;

        case 2:
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          break;

        default:
          _state = STATE.NONE;

      }
    }

    function touchend(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {

        case 1:

          break;

        case 2:
          _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          _panStart.copy(_panEnd);
          break;

      }

      _state = STATE.NONE;
      _this.dispatchEvent(endEvent);
    }

    function contextmenu(event) {
      event.preventDefault();
    }

    _this2.dispose = function () {
      this.domElement.removeEventListener('contextmenu', contextmenu, false);
      this.domElement.removeEventListener('mousedown', mousedown, false);
      this.domElement.removeEventListener('mousewheel', mousewheel, false);
      this.domElement.removeEventListener('MozMousePixelScroll', mousewheel, false); // firefox

      this.domElement.removeEventListener('touchstart', touchstart, false);
      this.domElement.removeEventListener('touchend', touchend, false);
      this.domElement.removeEventListener('touchmove', touchmove, false);

      document.removeEventListener('mousemove', mousemove, false);
      document.removeEventListener('mouseup', mouseup, false);

      window.removeEventListener('keydown', keydown, false);
      window.removeEventListener('keyup', keyup, false);
    };

    _this2.domElement.addEventListener('contextmenu', contextmenu, false);
    _this2.domElement.addEventListener('mousedown', mousedown, false);
    _this2.domElement.addEventListener('mousewheel', mousewheel, false);
    _this2.domElement.addEventListener('MozMousePixelScroll', mousewheel, false); // firefox

    _this2.domElement.addEventListener('touchstart', touchstart, false);
    _this2.domElement.addEventListener('touchend', touchend, false);
    _this2.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    _this2.handleResize();

    // force an update at start
    _this2.update();
    return _this2;
  }

  return Trackballortho;
}(THREE.EventDispatcher);

exports.default = Trackballortho;

},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Colors = function () {
  function Colors() {
    _classCallCheck(this, Colors);
  }

  _createClass(Colors, null, [{
    key: "cielab2XYZ",

    // http://www.easyrgb.com/index.php?X=MATH&H=08#text8
    value: function cielab2XYZ(l, a, b) {
      var refX = 95.047;
      var refY = 100.00;
      var refZ = 108.883;

      var y = (l + 16) / 116;
      var x = a / 500 + y;
      var z = y - b / 200;

      if (Math.pow(y, 3) > 0.008856) {
        y = Math.pow(y, 3);
      } else {
        y = (y - 16 / 116) / 7.787;
      }

      if (Math.pow(x, 3) > 0.008856) {
        x = Math.pow(x, 3);
      } else {
        x = (x - 16 / 116) / 7.787;
      }

      if (Math.pow(z, 3) > 0.008856) {
        z = Math.pow(z, 3);
      } else {
        z = (z - 16 / 116) / 7.787;
      }

      return [refX * x, refY * y, refZ * z];
    }
  }, {
    key: "xyz2RGB",
    value: function xyz2RGB(x, y, z) {
      x /= 100;
      y /= 100;
      z /= 100;
      var r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      var g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      var b = x * 0.0557 + y * -0.2040 + z * 1.0570;

      if (r > 0.0031308) {
        r = 1.055 * Math.pow(r, 1 / 2.4) - 0.055;
      } else {
        r = 12.92 * r;
      }

      if (g > 0.0031308) {
        g = 1.055 * Math.pow(g, 1 / 2.4) - 0.055;
      } else {
        g = 12.92 * g;
      }

      if (b > 0.0031308) {
        b = 1.055 * Math.pow(b, 1 / 2.4) - 0.055;
      } else {
        b = 12.92 * b;
      }

      r = r * 255;
      g = g * 255;
      b = b * 255;

      return [r, g, b];
    }
  }, {
    key: "cielab2RGB",
    value: function cielab2RGB() {
      var l = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (!(l >= 0 && l <= 100)) {
        return null;
      }

      var xyz = this.cielab2XYZ(l, a, b);
      return this.xyz2RGB.apply(this, _toConsumableArray(xyz));
    }
  }]);

  return Colors;
}();

exports.default = Colors;

},{}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('./core.utils');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('./core.validators');

var _core4 = _interopRequireDefault(_core3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Compute/test intersection between different objects.
 *
 * @module core/intersections
 */

var Intersections = function () {
  function Intersections() {
    _classCallCheck(this, Intersections);
  }

  _createClass(Intersections, null, [{
    key: 'aabbPlane',

    /**
     * Compute intersection between oriented bounding box and a plane.
     *
     * Returns intersection in plane's space.
     *
     * Should return at least 3 intersections. If not, the plane and the box do not
     * intersect.
     *
     * @param {Object} aabb - Axe Aligned Bounding Box representation.
     * @param {THREE.Vector3} aabb.halfDimensions - Half dimensions of the box.
     * @param {THREE.Vector3} aabb.center - Center of the box.
     * @param {THREE.Matrix4} aabb.toAABB - Transform to go from plane space to box space.
     * @param {Object} plane - Plane representation
     * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
     * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
     *
     * @returns {Array<THREE.Vector3>} List of all intersections in plane's space.
     * @returns {boolean} false is invalid input provided.
     *
     * @example
     * //Returns array with intersection N intersections
     * let aabb = {
     *   center: new THREE.Vector3(150, 150, 150),
     *   halfDimensions: new THREE.Vector3(50, 60, 70),
     *   toAABB: new THREE.Matrix4()
     * }
     * let plane = {
     *   position: new THREE.Vector3(110, 120, 130),
     *   direction: new THREE.Vector3(1, 0, 0)
     * }
     *
     * let intersections = CoreIntersections.aabbPlane(aabb, plane);
     * // intersections ==
     * //[ { x : 110, y : 90,  z : 80 },
     * //  { x : 110, y : 210, z : 220 },
     * //  { x : 110, y : 210, z : 80 },
     * //  { x : 110, y : 90,  z : 220 } ]
     *
     * //Returns empty array with 0 intersections
     * let aabb = {
     *
     * }
     * let plane = {
     *
     * }
     *
     * let intersections = VJS.Core.Validators.matrix4(new THREE.Vector3());
     *
     * //Returns false if invalid input?
     *
     */
    value: function aabbPlane(aabb, plane) {
      //
      // obb = { halfDimensions, orientation, center, toAABB }
      // plane = { position, direction }
      //
      //
      // LOGIC:
      //
      // Test intersection of each edge of the Oriented Bounding Box with the Plane
      //
      // ALL EDGES
      //
      //      .+-------+
      //    .' |     .'|
      //   +---+---+'  |
      //   |   |   |   |
      //   |  ,+---+---+
      //   |.'     | .'
      //   +-------+'
      //
      // SPACE ORIENTATION
      //
      //       +
      //     j |
      //       |
      //       |   i
      //   k  ,+-------+
      //    .'
      //   +
      //
      //
      // 1- Move Plane position and orientation in IJK space
      // 2- Test Edges/ IJK Plane intersections
      // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox

      var intersections = [];

      if (!(this.validateAabb(aabb) && this.validatePlane(plane))) {
        window.console.log('Invalid aabb or plane provided.');
        return false;
      }

      // invert space matrix
      var fromAABB = new THREE.Matrix4();
      fromAABB.getInverse(aabb.toAABB);

      var t1 = plane.direction.clone().applyMatrix4(aabb.toAABB);
      var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(aabb.toAABB);

      var planeAABB = this.posdir(plane.position.clone().applyMatrix4(aabb.toAABB), new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize());

      var bbox = _core2.default.bbox(aabb.center, aabb.halfDimensions);

      var orientation = new THREE.Vector3(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1));

      // 12 edges (i.e. ray)/plane intersection tests
      // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)
      //
      //       +
      //       |
      //       |
      //       |
      //      ,+---+---+
      //    .'
      //   +

      var ray = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      ray.direction = orientation.y;
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      ray.direction = orientation.z;
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE LAST CORNER
      //
      //               +
      //             .'
      //   +-------+'
      //           |
      //           |
      //           |
      //           +
      //

      var ray2 = this.posdir(new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      ray2.direction = orientation.y;
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      ray2.direction = orientation.z;
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE SECOND CORNER
      //
      //               +
      //               |
      //               |
      //               |
      //               +
      //             .'
      //           +'

      var ray3 = this.posdir(new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.y);
      this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

      ray3.direction = orientation.z;
      this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE THIRD CORNER
      //
      //      .+-------+
      //    .'
      //   +
      //
      //
      //
      //

      var ray4 = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

      ray4.direction = orientation.z;
      this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE FOURTH CORNER
      //
      //
      //
      //   +
      //   |
      //   |
      //   |
      //   +-------+

      var ray5 = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

      ray5.direction = orientation.y;
      this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

      // @todo make sure objects are unique...

      // back to original space
      intersections.map(function (element) {
        return element.applyMatrix4(fromAABB);
      });

      return intersections;
    }

    /**
     * Compute intersection between a ray and a plane.
     *
     * @memberOf this
     * @public
     *
     * @param {Object} ray - Ray representation.
     * @param {THREE.Vector3} ray.position - position of normal which describes the ray.
     * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.
     * @param {Object} plane - Plane representation
     * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
     * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
     *
     * @returns {THREE.Vector3|null} Intersection between ray and plane or null.
     */

  }, {
    key: 'rayPlane',
    value: function rayPlane(ray, plane) {
      // ray: {position, direction}
      // plane: {position, direction}

      if (ray.direction.dot(plane.direction) !== 0) {
        //
        // not parallel, move forward
        //
        // LOGIC:
        //
        // Ray equation: P = P0 + tV
        // P = <Px, Py, Pz>
        // P0 = <ray.position.x, ray.position.y, ray.position.z>
        // V = <ray.direction.x, ray.direction.y, ray.direction.z>
        //
        // Therefore:
        // Px = ray.position.x + t*ray.direction.x
        // Py = ray.position.y + t*ray.direction.y
        // Pz = ray.position.z + t*ray.direction.z
        //
        //
        //
        // Plane equation: ax + by + cz + d = 0
        // a = plane.direction.x
        // b = plane.direction.y
        // c = plane.direction.z
        // d = -( plane.direction.x*plane.position.x +
        //        plane.direction.y*plane.position.y +
        //        plane.direction.z*plane.position.z )
        //
        //
        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz
        // 2- find t
        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection
        //
        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) / (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);

        var intersection = new THREE.Vector3(ray.position.x + t * ray.direction.x, ray.position.y + t * ray.direction.y, ray.position.z + t * ray.direction.z);

        return intersection;
      }

      return null;
    }

    /**
     * Compute intersection between a ray and a box
     * @param {Object} ray
     * @param {Object} box
     * @return {Array}
     */

  }, {
    key: 'rayBox',
    value: function rayBox(ray, box) {
      // should also do the space transforms here
      // ray: {position, direction}
      // box: {halfDimensions, center}

      var intersections = [];

      var bbox = _core2.default.bbox(box.center, box.halfDimensions);

      // window.console.log(bbox);

      // X min
      var plane = this.posdir(new THREE.Vector3(bbox.min.x, box.center.y, box.center.z), new THREE.Vector3(-1, 0, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // X max
      plane = this.posdir(new THREE.Vector3(bbox.max.x, box.center.y, box.center.z), new THREE.Vector3(1, 0, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Y min
      plane = this.posdir(new THREE.Vector3(box.center.x, bbox.min.y, box.center.z), new THREE.Vector3(0, -1, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Y max
      plane = this.posdir(new THREE.Vector3(box.center.x, bbox.max.y, box.center.z), new THREE.Vector3(0, 1, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Z min
      plane = this.posdir(new THREE.Vector3(box.center.x, box.center.y, bbox.min.z), new THREE.Vector3(0, 0, -1));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Z max
      plane = this.posdir(new THREE.Vector3(box.center.x, box.center.y, bbox.max.z), new THREE.Vector3(0, 0, 1));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      return intersections;
    }

    /**
     * Intersection between ray and a plane that are in a box.
     * @param {*} ray
     * @param {*} planeAABB
     * @param {*} bbox
     * @param {*} intersections
     */

  }, {
    key: 'rayPlaneInBBox',
    value: function rayPlaneInBBox(ray, planeAABB, bbox, intersections) {
      var intersection = this.rayPlane(ray, planeAABB);
      // window.console.log(intersection);
      if (intersection && this.inBBox(intersection, bbox)) {
        if (!intersections.find(this.findIntersection(intersection))) {
          intersections.push(intersection);
        }
      }
    }

    /**
     * Find intersection in array
     * @param {*} myintersection
     */

  }, {
    key: 'findIntersection',
    value: function findIntersection(myintersection) {
      return function found(element, index, array) {
        if (myintersection.x === element.x && myintersection.y === element.y && myintersection.z === element.z) {
          return true;
        }

        return false;
      };
    }

    /**
     * Is point in box.
     * @param {Object} point
     * @param {Object} bbox
     * @return {Boolean}
     */

  }, {
    key: 'inBBox',
    value: function inBBox(point, bbox) {
      //
      var epsilon = 0.0001;
      if (point && point.x >= bbox.min.x - epsilon && point.y >= bbox.min.y - epsilon && point.z >= bbox.min.z - epsilon && point.x <= bbox.max.x + epsilon && point.y <= bbox.max.y + epsilon && point.z <= bbox.max.z + epsilon) {
        return true;
      }
      return false;
    }
  }, {
    key: 'posdir',
    value: function posdir(position, direction) {
      return { position: position, direction: direction };
    }
  }, {
    key: 'validatePlane',
    value: function validatePlane(plane) {
      //
      if (plane === null) {
        window.console.log('Invalid plane.');
        window.console.log(plane);

        return false;
      }

      if (!_core4.default.vector3(plane.position)) {
        window.console.log('Invalid plane.position.');
        window.console.log(plane.position);

        return false;
      }

      if (!_core4.default.vector3(plane.direction)) {
        window.console.log('Invalid plane.direction.');
        window.console.log(plane.direction);

        return false;
      }

      return true;
    }
  }, {
    key: 'validateAabb',
    value: function validateAabb(aabb) {
      //
      if (aabb === null) {
        window.console.log('Invalid aabb.');
        window.console.log(aabb);
        return false;
      }

      if (!_core4.default.matrix4(aabb.toAABB)) {
        window.console.log('Invalid aabb.toAABB: ');
        window.console.log(aabb.toAABB);

        return false;
      }

      if (!_core4.default.vector3(aabb.center)) {
        window.console.log('Invalid aabb.center.');
        window.console.log(aabb.center);

        return false;
      }

      if (!(_core4.default.vector3(aabb.halfDimensions) && aabb.halfDimensions.x >= 0 && aabb.halfDimensions.y >= 0 && aabb.halfDimensions.z >= 0)) {
        window.console.log('Invalid aabb.halfDimensions.');
        window.console.log(aabb.halfDimensions);

        return false;
      }

      return true;
    }
  }]);

  return Intersections;
}();

exports.default = Intersections;

},{"./core.utils":105,"./core.validators":106}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = require('./core.colors');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('./core.intersections');

var _core4 = _interopRequireDefault(_core3);

var _core5 = require('./core.pack');

var _core6 = _interopRequireDefault(_core5);

var _core7 = require('./core.validators');

var _core8 = _interopRequireDefault(_core7);

var _core9 = require('./core.utils');

var _core10 = _interopRequireDefault(_core9);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module core
 */
exports.default = {
  Colors: _core2.default,
  Intersections: _core4.default,
  Utils: _core10.default,
  Validators: _core8.default
};

},{"./core.colors":101,"./core.intersections":102,"./core.pack":104,"./core.utils":105,"./core.validators":106}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Packing functions.
 *
 * @module core/pack */

var Pack = function Pack() {
  _classCallCheck(this, Pack);
};

exports.default = Pack;

},{}],105:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('./core.validators');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var URL = require('url');

/**
 * General purpose functions.
 *
 * @module core/utils
 */
var CoreUtils = function () {
  function CoreUtils() {
    _classCallCheck(this, CoreUtils);
  }

  _createClass(CoreUtils, null, [{
    key: 'bbox',

    /**
     * Generate a bouding box object.
     * @param {THREE.Vector3} center - Center of the box.
     * @param {THREE.Vector3} halfDimensions - Half Dimensions of the box.
     * @return {Object} The bounding box object. {Object.min} is a {THREE.Vector3}
     * containing the min bounds. {Object.max} is a {THREE.Vector3} containing the
     * max bounds.
     * @return {boolean} False input NOT valid.
     * @example
     * // Returns
     * //{ min: { x : 0, y : 0,  z : 0 },
     * //  max: { x : 2, y : 4,  z : 6 }
     * //}
     * VJS.Core.Utils.bbox(
     *   new THREE.Vector3(1, 2, 3), new THREE.Vector3(1, 2, 3));
     *
     * //Returns false
     * VJS.Core.Utils.bbox(new THREE.Vector3(), new THREE.Matrix4());
     *
     */
    value: function bbox(center, halfDimensions) {
      // make sure we have valid inputs
      if (!(_core2.default.vector3(center) && _core2.default.vector3(halfDimensions))) {
        window.console.log('Invalid center or plane halfDimensions.');
        return false;
      }

      // make sure half dimensions are >= 0
      if (!(halfDimensions.x >= 0 && halfDimensions.y >= 0 && halfDimensions.z >= 0)) {
        window.console.log('halfDimensions must be >= 0.');
        window.console.log(halfDimensions);
        return false;
      }

      // min/max bound
      var min = center.clone().sub(halfDimensions);
      var max = center.clone().add(halfDimensions);

      return {
        min: min,
        max: max
      };
    }

    /**
     * Find min/max values in an array
     * @param {Array} data
     * @return {Array}
     */

  }, {
    key: 'minMax',
    value: function minMax() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = data.length;

      for (var index = 0; index < numPixels; index++) {
        var spv = data[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }

    /**
     * Check HTMLElement
     * @param {HTMLElement} obj
     * @return {boolean}
     */

  }, {
    key: 'isElement',
    value: function isElement(obj) {
      try {
        // Using W3 DOM2 (works for FF, Opera and Chrom)
        return obj instanceof HTMLElement;
      } catch (e) {
        // Browsers not supporting W3 DOM2 don't have HTMLElement and
        // an exception is thrown and we end up here. Testing some
        // properties that all elements have. (works on IE7)
        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.nodeType === 1 && _typeof(obj.style) === 'object' && _typeof(obj.ownerDocument) === 'object';
      }
    }

    /**
     * Check string
     * @param {String} str
     * @return {Boolean}
     */

  }, {
    key: 'isString',
    value: function isString(str) {
      return typeof str === 'string' || str instanceof String;
    }

    /**
     * Parse url
     * @param {*} url
     * @return {Object}
     */

  }, {
    key: 'parseUrl',
    value: function parseUrl(url) {
      //
      var data = {};
      data.filename = '';
      data.extension = '';
      data.pathname = '';
      data.query = '';

      var parsedUrl = URL.parse(url);
      data.pathname = parsedUrl.pathname;
      data.query = parsedUrl.query;

      // get file name
      data.filename = data.pathname.split('/').pop();

      // find extension
      var splittedName = data.filename.split('.');
      if (splittedName.length <= 1) {
        data.extension = 'dicom';
      } else {
        data.extension = data.filename.split('.').pop();
      }

      if (!isNaN(data.extension)) {
        data.extension = 'dicom';
      }

      if (data.query && data.query.includes('contentType=application%2Fdicom')) {
        data.extension = 'dicom';
      }

      return data;
    }

    /**
     * Compute IJK to LPS tranform.
     *
     * @param {*} xCos
     * @param {*} yCos
     * @param {*} zCos
     * @param {*} spacing
     * @param {*} origin
     * @param {*} registrationMatrix
     *
     * @return {*}
     */

  }, {
    key: 'ijk2LPS',
    value: function ijk2LPS(xCos, yCos, zCos, spacing, origin) {
      var registrationMatrix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new THREE.Matrix4();

      var ijk2LPS = new THREE.Matrix4();
      ijk2LPS.set(xCos.x * spacing.x, yCos.x * spacing.y, zCos.x * spacing.z, origin.x, xCos.y * spacing.x, yCos.y * spacing.y, zCos.y * spacing.z, origin.y, xCos.z * spacing.x, yCos.z * spacing.y, zCos.z * spacing.z, origin.z, 0, 0, 0, 1);
      ijk2LPS.premultiply(registrationMatrix);

      return ijk2LPS;
    }

    /**
     * Compute AABB to LPS transform.
     * AABB: Axe Aligned Bounding Box.
     * @param {*} xCos
     * @param {*} yCos
     * @param {*} zCos
     * @param {*} origin
     */

  }, {
    key: 'aabb2LPS',
    value: function aabb2LPS(xCos, yCos, zCos, origin) {
      var aabb2LPS = new THREE.Matrix4();
      aabb2LPS.set(xCos.x, yCos.x, zCos.x, origin.x, xCos.y, yCos.y, zCos.y, origin.y, xCos.z, yCos.z, zCos.z, origin.z, 0, 0, 0, 1);
    }

    /**
     * Transform coordinates from world coordinate to data
     *
     * @param {*} lps2IJK
     * @param {*} worldCoordinates
     *
     * @return {*}
     */

  }, {
    key: 'worldToData',
    value: function worldToData(lps2IJK, worldCoordinates) {
      var dataCoordinate = new THREE.Vector3().copy(worldCoordinates).applyMatrix4(lps2IJK);

      // same rounding in the shaders
      dataCoordinate.addScalar(0.5).floor();

      return dataCoordinate;
    }

    /**
     * Get voxel value
     *
     * @param {*} stack
     * @param {*} coordinate
     *
     * @return {*}
     */

  }, {
    key: 'value',
    value: function value(stack, coordinate) {
      if (coordinate.z >= 0 && coordinate.z < stack._frame.length) {
        return stack._frame[coordinate.z].value(coordinate.x, coordinate.y);
      } else {
        return null;
      }
    }

    /**
     * Apply slope/intercept to a value
     *
     * @param {*} value
     * @param {*} slope
     * @param {*} intercept
     *
     * @return {*}
     */

  }, {
    key: 'rescaleSlopeIntercept',
    value: function rescaleSlopeIntercept(value, slope, intercept) {
      return value * slope + intercept;
    }
  }]);

  return CoreUtils;
}();

exports.default = CoreUtils;

},{"./core.validators":106,"url":81}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Validate basic structures.
 *
 * @example
 * //Returns true
 * VJS.Core.Validators.matrix4(new THREE.Matrix4());
 *
 * //Returns false
 * VJS.Core.Validators.matrix4(new THREE.Vector3());
 *
 * @module core/validators
 */

var Validators = function () {
  function Validators() {
    _classCallCheck(this, Validators);
  }

  _createClass(Validators, null, [{
    key: 'matrix4',

    /**
     * Validates a matrix as a THREEJS.Matrix4
     * link
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid Matrix4, false if NOT.
     */
    value: function matrix4(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('elements') && objectToTest.elements.length === 16 && typeof objectToTest.identity === 'function' && typeof objectToTest.copy === 'function' && typeof objectToTest.determinant === 'function')) {
        return false;
      }

      return true;
    }

    /**
    * Validates a vector as a THREEJS.Vector3
    * @param {Object} objectToTest - The object to be tested.
    * @return {boolean} True if valid Vector3, false if NOT.
    */

  }, {
    key: 'vector3',
    value: function vector3(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('x') && objectToTest.hasOwnProperty('y') && objectToTest.hasOwnProperty('z') && !objectToTest.hasOwnProperty('w'))) {
        return false;
      }

      return true;
    }

    /**
     * Validates a box.
     *
     * @example
     * // a box is defined as
     * let box = {
     *   center: THREE.Vector3,
     *   halfDimensions: THREE.Vector3
     * }
     *
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid box, false if NOT.
     */

  }, {
    key: 'box',
    value: function box(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('center') && this.vector3(objectToTest.center) && objectToTest.hasOwnProperty('halfDimensions') && this.vector3(objectToTest.halfDimensions) && objectToTest.halfDimensions.x >= 0 && objectToTest.halfDimensions.y >= 0 && objectToTest.halfDimensions.z >= 0)) {
        return false;
      }

      return true;
    }

    /**
     * Validates a ray.
     *
     * @example
     * // a ray is defined as
     * let ray = {
     *   postion: THREE.Vector3,
     *   direction: THREE.Vector3
     * }
     *
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid ray, false if NOT.
     */

  }, {
    key: 'ray',
    value: function ray(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('position') && this.vector3(objectToTest.position) && objectToTest.hasOwnProperty('direction') && this.vector3(objectToTest.direction))) {
        return false;
      }

      return true;
    }
  }]);

  return Validators;
}();

exports.default = Validators;

},{}],107:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _geometries = require('./geometries.slice');

var _geometries2 = _interopRequireDefault(_geometries);

var _geometries3 = require('./geometries.voxel');

var _geometries4 = _interopRequireDefault(_geometries3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module geometries
 */

exports.default = {
  Slice: _geometries2.default,
  Voxel: _geometries4.default
};

},{"./geometries.slice":108,"./geometries.voxel":109}],108:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 *
 * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}
 *
 * @module geometries/slice
 *
 * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.
 * @param {THREE.Vector3} center - Center of the box to be sliced.
 * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)
 * @param {THREE.Vector3} position - Position of the cutting plane.
 * @param {THREE.Vector3} direction - Cross direction of the cutting plane.
 *
 * @example
 * // Define box to be sliced
 * let halfDimensions = new THREE.Vector(123, 45, 67);
 * let center = new THREE.Vector3(0, 0, 0);
 * let orientation = new THREE.Vector3(
 *   new THREE.Vector3(1, 0, 0),
 *   new THREE.Vector3(0, 1, 0),
 *   new THREE.Vector3(0, 0, 1)
 * );
 *
 * // Define slice plane
 * let position = center.clone();
 * let direction = new THREE.Vector3(-0.2, 0.5, 0.3);
 *
 * // Create the slice geometry & materials
 * let sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);
 * let sliceMaterial = new THREE.MeshBasicMaterial({
 *   'side': THREE.DoubleSide,
 *   'color': 0xFF5722
 * });
 *
 *  // Create mesh and add it to the scene
 *  let slice = new THREE.Mesh(sliceGeometry, sliceMaterial);
 *  scene.add(slice);
 */

var GeometriesSlice = function (_THREE$ShapeGeometry) {
  _inherits(GeometriesSlice, _THREE$ShapeGeometry);

  function GeometriesSlice(halfDimensions, center, position, direction) {
    var toAABB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new THREE.Matrix4();

    _classCallCheck(this, GeometriesSlice);

    //
    // prepare data for the shape!
    //
    var aabb = {
      halfDimensions: halfDimensions,
      center: center,
      toAABB: toAABB
    };

    var plane = {
      position: position,
      direction: direction
    };

    // BOOM!
    var intersections = _core2.default.aabbPlane(aabb, plane);

    // can not exist before calling the constructor
    if (intersections.length < 3) {
      window.console.log('WARNING: Less than 3 intersections between AABB and Plane.');
      window.console.log('AABB');
      window.console.log(aabb);
      window.console.log('Plane');
      window.console.log(plane);
      window.console.log('exiting...');
      // or throw error?
      throw 'geometries.slice has less than 3 intersections, can not create a valid geometry.';
    }

    var orderedIntersections = GeometriesSlice.orderIntersections(intersections, direction);
    var sliceShape = GeometriesSlice.shape(orderedIntersections);

    //
    // Generate Geometry from shape
    // It does triangulation for us!
    //

    var _this = _possibleConstructorReturn(this, (GeometriesSlice.__proto__ || Object.getPrototypeOf(GeometriesSlice)).call(this, sliceShape));

    _this.type = 'SliceGeometry';

    // update real position of each vertex! (not in 2d)
    _this.vertices = orderedIntersections;
    _this.verticesNeedUpdate = true;
    return _this;
  }

  _createClass(GeometriesSlice, null, [{
    key: 'shape',
    value: function shape(points) {
      //
      // Create Shape
      //
      var shape = new THREE.Shape();
      // move to first point!
      shape.moveTo(points[0].xy.x, points[0].xy.y);

      // loop through all points!
      for (var l = 1; l < points.length; l++) {
        // project each on plane!
        shape.lineTo(points[l].xy.x, points[l].xy.y);
      }

      // close the shape!
      shape.lineTo(points[0].xy.x, points[0].xy.y);
      return shape;
    }

    /**
     *
     * Convenience function to extract center of mass from list of points.
     *
     * @private
     *
     * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.
     *
     * @returns {THREE.Vector3} Center of mass from given points.
     */

  }, {
    key: 'centerOfMass',
    value: function centerOfMass(points) {
      var centerOfMass = new THREE.Vector3(0, 0, 0);
      for (var i = 0; i < points.length; i++) {
        centerOfMass.x += points[i].x;
        centerOfMass.y += points[i].y;
        centerOfMass.z += points[i].z;
      }
      centerOfMass.divideScalar(points.length);

      return centerOfMass;
    }

    /**
     *
     * Order 3D planar points around a refence point.
     *
     * @private
     *
     * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.
     * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.
     *
     * @returns {Array<Object>} Set of object representing the ordered points.
     */

  }, {
    key: 'orderIntersections',
    value: function orderIntersections(points, direction) {
      var reference = GeometriesSlice.centerOfMass(points);
      // direction from first point to reference
      var referenceDirection = new THREE.Vector3(points[0].x - reference.x, points[0].y - reference.y, points[0].z - reference.z).normalize();

      var base = new THREE.Vector3(0, 0, 0).crossVectors(referenceDirection, direction).normalize();

      var orderedpoints = [];

      // other lines // if inter, return location + angle
      for (var j = 0; j < points.length; j++) {
        var point = new THREE.Vector3(points[j].x, points[j].y, points[j].z);
        point.direction = new THREE.Vector3(points[j].x - reference.x, points[j].y - reference.y, points[j].z - reference.z).normalize();

        var x = referenceDirection.dot(point.direction);
        var y = base.dot(point.direction);
        point.xy = { x: x, y: y };

        var theta = Math.atan2(y, x) * (180 / Math.PI);
        point.angle = theta;

        orderedpoints.push(point);
      }

      orderedpoints.sort(function (a, b) {
        return a.angle - b.angle;
      });

      var noDups = [orderedpoints[0]];
      var epsilon = 0.0001;
      for (var i = 1; i < orderedpoints.length; i++) {
        if (Math.abs(orderedpoints[i - 1].angle - orderedpoints[i].angle) > epsilon) {
          noDups.push(orderedpoints[i]);
        }
      }

      return noDups;
    }
  }]);

  return GeometriesSlice;
}(THREE.ShapeGeometry);

exports.default = GeometriesSlice;

},{"../core/core.intersections":102}],109:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 *
 * @module geometries/voxel
 */

var GeometriesVoxel = function (_THREE$BoxGeometry) {
  _inherits(GeometriesVoxel, _THREE$BoxGeometry);

  function GeometriesVoxel(dataPosition) {
    _classCallCheck(this, GeometriesVoxel);

    var _this = _possibleConstructorReturn(this, (GeometriesVoxel.__proto__ || Object.getPrototypeOf(GeometriesVoxel)).call(this, 1, 1, 1));

    _this._location = dataPosition;

    _this.applyMatrix(new THREE.Matrix4().makeTranslation(_this._location.x, _this._location.y, _this._location.z));

    _this.verticesNeedUpdate = true;
    return _this;
  }

  _createClass(GeometriesVoxel, [{
    key: "resetVertices",
    value: function resetVertices() {
      this.vertices[0].set(0.5, 0.5, 0.5);
      this.vertices[1].set(0.5, 0.5, -0.5);
      this.vertices[2].set(0.5, -0.5, 0.5);
      this.vertices[3].set(0.5, -0.5, -0.5);
      this.vertices[4].set(-0.5, 0.5, -0.5);
      this.vertices[5].set(-0.5, 0.5, 0.5);
      this.vertices[6].set(-0.5, -0.5, -0.5);
      this.vertices[7].set(-0.5, -0.5, 0.5);
    }
  }, {
    key: "location",
    set: function set(location) {
      this._location = location;

      // update vertices from location
      this.vertices[0].set(+0.5, +0.5, +0.5);
      this.vertices[1].set(+0.5, +0.5, -0.5);
      this.vertices[2].set(+0.5, -0.5, +0.5);
      this.vertices[3].set(+0.5, -0.5, -0.5);
      this.vertices[4].set(-0.5, +0.5, -0.5);
      this.vertices[5].set(-0.5, +0.5, +0.5);
      this.vertices[6].set(-0.5, -0.5, -0.5);
      this.vertices[7].set(-0.5, -0.5, +0.5);

      this.applyMatrix(new THREE.Matrix4().makeTranslation(this._location.x, this._location.y, this._location.z));

      this.verticesNeedUpdate = true;
    },
    get: function get() {
      return this._location;
    }
  }]);

  return GeometriesVoxel;
}(THREE.BoxGeometry);

exports.default = GeometriesVoxel;

},{}],110:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/** * Imports ***/

/**
 * @module helpers/border
 */
var HelpersBorder = function (_THREE$Object3D) {
  _inherits(HelpersBorder, _THREE$Object3D);

  function HelpersBorder(helpersSlice) {
    _classCallCheck(this, HelpersBorder);

    var _this = _possibleConstructorReturn(this, (HelpersBorder.__proto__ || Object.getPrototypeOf(HelpersBorder)).call(this));
    //


    _this._helpersSlice = helpersSlice;

    _this._visible = true;
    _this._color = 0xff0000;
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    _this._create();
    return _this;
  }

  _createClass(HelpersBorder, [{
    key: '_create',
    value: function _create() {
      if (!this._material) {
        this._material = new THREE.LineBasicMaterial({
          color: this._color,
          linewidth: 1
        });
      }

      //
      if (!this._helpersSlice.geometry.vertices) {
        return;
      }

      this._geometry = new THREE.Geometry();
      for (var i = 0; i < this._helpersSlice.geometry.vertices.length; i++) {
        this._geometry.vertices.push(this._helpersSlice.geometry.vertices[i]);
      }
      this._geometry.vertices.push(this._helpersSlice.geometry.vertices[0]);

      this._mesh = new THREE.Line(this._geometry, this._material);
      if (this._helpersSlice.aabbSpace === 'IJK') {
        this._mesh.applyMatrix(this._helpersSlice.stack.ijk2LPS);
      }
      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: '_update',
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._geometry.dispose();
      this._geometry = null;
      this._material.dispose();
      this._material = null;
    }
  }, {
    key: 'helpersSlice',
    set: function set(helpersSlice) {
      this._helpersSlice = helpersSlice;
      this._update();
    },
    get: function get() {
      return this._helpersSlice;
    }
  }, {
    key: 'visible',
    set: function set(visible) {
      this._visible = visible;
      if (this._mesh) {
        this._mesh.visible = this._visible;
      }
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: 'color',
    set: function set(color) {
      this._color = color;
      if (this._material) {
        this._material.color.set(this._color);
      }
    },
    get: function get() {
      return this._color;
    }
  }]);

  return HelpersBorder;
}(THREE.Object3D);

exports.default = HelpersBorder;

},{}],111:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module helpers/boundingbox
 */

var HelpersBoundingBox = function (_THREE$Object3D) {
  _inherits(HelpersBoundingBox, _THREE$Object3D);

  function HelpersBoundingBox(stack) {
    _classCallCheck(this, HelpersBoundingBox);

    // private vars
    var _this = _possibleConstructorReturn(this, (HelpersBoundingBox.__proto__ || Object.getPrototypeOf(HelpersBoundingBox)).call(this));
    //


    _this._stack = stack;
    _this._visible = true;
    _this._color = 0xFFFFFF;
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // create object
    _this._create();
    return _this;
  }

  // getters/setters


  _createClass(HelpersBoundingBox, [{
    key: "_create",

    // private methods
    value: function _create() {
      // Convenience vars
      var dimensions = this._stack.dimensionsIJK;
      var halfDimensions = this._stack.halfDimensionsIJK;
      var offset = new THREE.Vector3(-0.5, -0.5, -0.5);

      // Geometry
      this._geometry = new THREE.BoxGeometry(dimensions.x, dimensions.y, dimensions.z);
      // position bbox in image space
      this._geometry.applyMatrix(new THREE.Matrix4().makeTranslation(halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));

      // Mesh
      var boxMesh = new THREE.Mesh(this._geometry, new THREE.MeshBasicMaterial(0xff0000));
      this._mesh = new THREE.BoxHelper(boxMesh, this._color);

      // Material
      this._material = this._mesh.material;

      // position bbox in world space
      this._mesh.applyMatrix(this._stack.ijk2LPS);
      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: "_update",
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh.material.dispose();
        this._mesh.material = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._geometry.dispose();
      this._geometry = null;
      this._material.dispose();
      this._material = null;
    }
  }, {
    key: "visible",
    set: function set(visible) {
      this._visible = visible;
      if (this._mesh) {
        this._mesh.visible = this._visible;
      }
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "color",
    set: function set(color) {
      this._color = color;
      if (this._material) {
        this._material.color.set(this._color);
      }
    },
    get: function get() {
      return this._color;
    }
  }]);

  return HelpersBoundingBox;
}(THREE.Object3D);

exports.default = HelpersBoundingBox;

},{}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpers = require('./helpers.border');

var _helpers2 = _interopRequireDefault(_helpers);

var _helpers3 = require('./helpers.boundingbox');

var _helpers4 = _interopRequireDefault(_helpers3);

var _helpers5 = require('./helpers.localizer');

var _helpers6 = _interopRequireDefault(_helpers5);

var _helpers7 = require('./helpers.lut');

var _helpers8 = _interopRequireDefault(_helpers7);

var _helpers9 = require('./helpers.progressbar');

var _helpers10 = _interopRequireDefault(_helpers9);

var _helpersProgressbar = require('./helpers.progressbar.eventbased');

var _helpersProgressbar2 = _interopRequireDefault(_helpersProgressbar);

var _helpers11 = require('./helpers.slice');

var _helpers12 = _interopRequireDefault(_helpers11);

var _helpers13 = require('./helpers.stack');

var _helpers14 = _interopRequireDefault(_helpers13);

var _helpers15 = require('./helpers.volumerendering');

var _helpers16 = _interopRequireDefault(_helpers15);

var _helpers17 = require('./x/helpers.x');

var _helpers18 = _interopRequireDefault(_helpers17);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module helpers
 */

exports.default = {
  Border: _helpers2.default,
  BoundingBox: _helpers4.default,
  Localizer: _helpers6.default,
  Lut: _helpers8.default,
  ProgressBar: _helpers10.default,
  ProgressBarEventBased: _helpersProgressbar2.default,
  Slice: _helpers12.default,
  Stack: _helpers14.default,
  VolumeRendering: _helpers16.default,
  X: _helpers18.default
};

},{"./helpers.border":110,"./helpers.boundingbox":111,"./helpers.localizer":113,"./helpers.lut":114,"./helpers.progressbar":117,"./helpers.progressbar.eventbased":116,"./helpers.slice":118,"./helpers.stack":119,"./helpers.volumerendering":120,"./x/helpers.x":122}],113:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shadersLocalizer = require('../shaders/shaders.localizer.uniform');

var _shadersLocalizer2 = _interopRequireDefault(_shadersLocalizer);

var _shadersLocalizer3 = require('../shaders/shaders.localizer.vertex');

var _shadersLocalizer4 = _interopRequireDefault(_shadersLocalizer3);

var _shadersLocalizer5 = require('../shaders/shaders.localizer.fragment');

var _shadersLocalizer6 = _interopRequireDefault(_shadersLocalizer5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * @module helpers/localizer
 */

var HelpersLocalizer = function (_THREE$Object3D) {
  _inherits(HelpersLocalizer, _THREE$Object3D);

  function HelpersLocalizer(stack, geometry, referencePlane) {
    _classCallCheck(this, HelpersLocalizer);

    var _this = _possibleConstructorReturn(this, (HelpersLocalizer.__proto__ || Object.getPrototypeOf(HelpersLocalizer)).call(this));
    //


    _this._stack = stack;
    _this._referencePlane = referencePlane;
    _this._plane1 = null;
    _this._color1 = null;
    _this._plane2 = null;
    _this._color2 = null;
    _this._plane3 = null;
    _this._color3 = null;
    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._shadersFragment = _shadersLocalizer6.default;
    _this._shadersVertex = _shadersLocalizer4.default;
    _this._uniforms = _shadersLocalizer2.default.uniforms();
    _this._material = null;
    _this._geometry = geometry;

    _this._create();
    return _this;
  }

  _createClass(HelpersLocalizer, [{
    key: '_create',
    value: function _create() {
      this._prepareMaterial();
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.applyMatrix(this._stack._ijk2LPS);
      this.add(this._mesh);
    }
  }, {
    key: '_prepareMaterial',
    value: function _prepareMaterial() {
      if (!this.material) {
        // reference plane
        this._uniforms.uSlice.value = this._referencePlane;

        // localizer planes
        if (this._plane1) {
          this._uniforms.uPlane1.value = this._plane1;
          this._uniforms.uPlaneColor1.value = this._color1;
        }

        if (this._plane2) {
          this._uniforms.uPlane2.value = this._plane2;
          this._uniforms.uPlaneColor2.value = this._color2;
        }

        if (this._plane3) {
          this._uniforms.uPlane3.value = this._plane3;
          this._uniforms.uPlaneColor3.value = this._color3;
        }

        //
        this._uniforms.uCanvasWidth.value = this._canvasWidth;
        this._uniforms.uCanvasHeight.value = this._canvasHeight;

        // generate material
        var fs = new _shadersLocalizer6.default(this._uniforms);
        var vs = new _shadersLocalizer4.default();
        this._material = new THREE.ShaderMaterial({ side: THREE.DoubleSide,
          uniforms: this._uniforms,
          vertexShader: vs.compute(),
          fragmentShader: fs.compute()
        });
        this._material.transparent = true;
      }
    }
  }, {
    key: 'update',
    value: function update() {
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'geometry',
    get: function get() {
      return this._geometry;
    },
    set: function set(geometry) {
      this._geometry = geometry;

      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'referencePlane',
    get: function get() {
      return this._referencePlane;
    },
    set: function set(referencePlane) {
      this._referencePlane = referencePlane;
      this._uniforms.uSlice.value = this._referencePlane;
    }
  }, {
    key: 'plane1',
    get: function get() {
      return this._plane1;
    },
    set: function set(plane1) {
      this._plane1 = plane1;
      this._uniforms.uPlane1.value = this._plane1;
    }
  }, {
    key: 'color1',
    get: function get() {
      return this._color1;
    },
    set: function set(color1) {
      this._color1 = color1;
      this._uniforms.uPlaneColor1.value = this._color1;
    }
  }, {
    key: 'plane2',
    get: function get() {
      return this._plane2;
    },
    set: function set(plane2) {
      this._plane2 = plane2;
      this._uniforms.uPlane2.value = this._plane2;
    }
  }, {
    key: 'color2',
    get: function get() {
      return this._color2;
    },
    set: function set(color2) {
      this._color2 = color2;
      this._uniforms.uPlaneColor2.value = this._color2;
    }
  }, {
    key: 'plane3',
    get: function get() {
      return this._plane3;
    },
    set: function set(plane3) {
      this._plane3 = plane3;
      this._uniforms.uPlane3.value = this._plane3;
    }
  }, {
    key: 'color3',
    get: function get() {
      return this._color3;
    },
    set: function set(color3) {
      this._color3 = color3;
      this._uniforms.uPlaneColor3.value = this._color3;
    }
  }, {
    key: 'canvasWidth',
    get: function get() {
      return this._canvasWidth;
    },
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._uniforms.uCanvasWidth.value = this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    get: function get() {
      return this._canvasHeight;
    },
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._uniforms.uCanvasHeight.value = this._canvasHeight;
    }
  }]);

  return HelpersLocalizer;
}(THREE.Object3D);

exports.default = HelpersLocalizer;

},{"../shaders/shaders.localizer.fragment":159,"../shaders/shaders.localizer.uniform":160,"../shaders/shaders.localizer.vertex":161}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module helpers/lut
 */

var HelpersLut = function () {
  function HelpersLut(containerID) {
    var lut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
    var lutO = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';
    var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [[0, 0, 0, 0], [1, 1, 1, 1]];
    var opacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [[0, 0], [1, 1]];
    var discrete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    _classCallCheck(this, HelpersLut);

    // min/max (0-1 or real intensities)
    // show/hide
    // horizontal/vertical
    this._containerID = containerID;

    this._discrete = discrete;
    this._color = color;
    this._lut = lut;
    this._luts = _defineProperty({}, lut, color);

    this._opacity = opacity;
    this._lutO = lutO;
    this._lutsO = _defineProperty({}, lutO, opacity);

    this.initCanvas();
    this.paintCanvas();
  }

  _createClass(HelpersLut, [{
    key: 'initCanvas',
    value: function initCanvas() {
      // container
      this._canvasContainer = this.initCanvasContainer(this._containerID);
      // background
      this._canvasBg = this.createCanvas();
      this._canvasContainer.appendChild(this._canvasBg);
      // foreground
      this._canvas = this.createCanvas();
      this._canvasContainer.appendChild(this._canvas);
    }
  }, {
    key: 'initCanvasContainer',
    value: function initCanvasContainer(canvasContainerId) {
      var canvasContainer = document.getElementById(canvasContainerId);
      canvasContainer.style.width = '256 px';
      canvasContainer.style.height = '128 px';
      canvasContainer.style.border = '1px solid #F9F9F9';
      return canvasContainer;
    }
  }, {
    key: 'createCanvas',
    value: function createCanvas() {
      var canvas = document.createElement('canvas');
      canvas.height = 16;
      canvas.width = 256;
      return canvas;
    }
  }, {
    key: 'paintCanvas',
    value: function paintCanvas() {
      // setup context
      var ctx = this._canvas.getContext('2d');
      ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
      ctx.globalCompositeOperation = 'source-over';

      // apply color
      if (!this._discrete) {
        var color = ctx.createLinearGradient(0, 0, this._canvas.width, this._canvas.height);
        for (var i = 0; i < this._color.length; i++) {
          color.addColorStop(this._color[i][0], 'rgba( ' + Math.round(this._color[i][1] * 255) + ', ' + Math.round(this._color[i][2] * 255) + ', ' + Math.round(this._color[i][3] * 255) + ', 1)');
        }

        ctx.fillStyle = color;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
      } else {
        ctx.lineWidth = 2 * this._canvas.height;

        for (var _i = 0; _i < this._color.length; _i++) {
          var currentPos = this._color[_i][0];
          var nextPos = 1;
          if (_i < this._color.length - 1) {
            nextPos = this._color[_i + 1][0];
          }
          var previousPos = 0;
          if (_i > 0) {
            previousPos = this._color[_i - 1][0];
          }

          var from = previousPos + (currentPos - previousPos) / 2;
          var to = currentPos + (nextPos - currentPos) / 2;
          var _color = this._color[_i];
          var opacity = this._opacity[_i] ? this._opacity[_i][1] : 1;

          ctx.beginPath();
          ctx.strokeStyle = 'rgba( ' + Math.round(_color[1] * 255) + ', ' + Math.round(_color[2] * 255) + ', ' + Math.round(_color[3] * 255) + ', ' + opacity + ')';
          ctx.moveTo(from * this._canvas.width, 0);
          ctx.lineTo(to * this._canvas.width, 0);
          ctx.stroke();
          ctx.closePath();
        }
      }

      if (!this._discrete) {
        // if discrete, we already took care of the opacity.
        // setup context
        ctx.globalCompositeOperation = 'destination-in';

        // apply opacity
        var _opacity = ctx.createLinearGradient(0, 0, this._canvas.width, this._canvas.height);
        for (var _i2 = 0; _i2 < this._opacity.length; _i2++) {
          _opacity.addColorStop(this._opacity[_i2][0], 'rgba(255, 255, 255, ' + this._opacity[_i2][1] + ')');
        }
        ctx.fillStyle = _opacity;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
      }
    }
  }, {
    key: 'lutsAvailable',
    value: function lutsAvailable() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'color';

      var available = [];
      var luts = this._luts;

      if (type !== 'color') {
        luts = this._lutsO;
      }

      for (var i in luts) {
        available.push(i);
      }

      return available;
    }

    // add luts to class' lut (so a user can add its own as well)

  }, {
    key: 'texture',
    get: function get() {
      var texture = new THREE.Texture(this._canvas);
      texture.mapping = THREE.UVMapping;
      texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.magFilter = texture.minFilter = THREE.NearestFilter;
      texture.premultiplyAlpha = true;
      texture.needsUpdate = true;
      return texture;
    }
  }, {
    key: 'lut',
    set: function set(targetLUT) {
      this._color = this._luts[targetLUT];
      this._lut = targetLUT;

      this.paintCanvas();
    },
    get: function get() {
      return this._lut;
    }
  }, {
    key: 'luts',
    set: function set(newLuts) {
      this._luts = newLuts;
    },
    get: function get() {
      return this._luts;
    }
  }, {
    key: 'lutO',
    set: function set(targetLUTO) {
      this._opacity = this._lutsO[targetLUTO];
      this._lutO = targetLUTO;

      this.paintCanvas();
    },
    get: function get() {
      return this._lutO;
    }
  }, {
    key: 'lutsO',
    set: function set(newLutsO) {
      this._lutsO = newLutsO;
    },
    get: function get() {
      return this._lutsO;
    }
  }, {
    key: 'discrete',
    set: function set(discrete) {
      this._discrete = discrete;

      this.paintCanvas();
    },
    get: function get() {
      return this._discrete;
    }
  }], [{
    key: 'presetLuts',
    value: function presetLuts() {
      return {
        'default': [[0, 0, 0, 0], [1, 1, 1, 1]],
        'spectrum': [[0, 0, 0, 0], [0.1, 0, 0, 1], [0.33, 0, 1, 1], [0.5, 0, 1, 0], [0.66, 1, 1, 0], [0.9, 1, 0, 0], [1, 1, 1, 1]],
        'hot_and_cold': [[0, 0, 0, 1], [0.15, 0, 1, 1], [0.3, 0, 1, 0], [0.45, 0, 0, 0], [0.5, 0, 0, 0], [0.55, 0, 0, 0], [0.7, 1, 1, 0], [0.85, 1, 0, 0], [1, 1, 1, 1]],
        'gold': [[0, 0, 0, 0], [0.13, 0.19, 0.03, 0], [0.25, 0.39, 0.12, 0], [0.38, 0.59, 0.26, 0], [0.50, 0.80, 0.46, 0.08], [0.63, 0.99, 0.71, 0.21], [0.75, 0.99, 0.88, 0.34], [0.88, 0.99, 0.99, 0.48], [1, 0.90, 0.95, 0.61]],
        'red': [[0, 0.75, 0, 0], [0.5, 1, 0.5, 0], [0.95, 1, 1, 0], [1, 1, 1, 1]],
        'green': [[0, 0, 0.75, 0], [0.5, 0.5, 1, 0], [0.95, 1, 1, 0], [1, 1, 1, 1]],
        'blue': [[0, 0, 0, 1], [0.5, 0, 0.5, 1], [0.95, 0, 1, 1], [1, 1, 1, 1]],
        'walking_dead': [[0, 0.1, 1, 1], [1, 1, 1, 1]],
        'random': [[0, 0, 0, 0], [0.27, 0.18, 0.18, 0.18], [0.41, 1, 1, 1], [0.7, 1, 0, 0], [1, 1, 1, 1]]
      };
    }
  }, {
    key: 'presetLutsO',
    value: function presetLutsO() {
      return {
        'linear': [[0, 0], [1, 1]],
        'lowpass': [[0, 0.8], [0.2, 0.6], [0.3, 0.1], [1, 0]],
        'bandpass': [[0, 0], [0.4, 0.8], [0.6, 0.8], [1, 0]],
        'highpass': [[0, 0], [0.7, 0.1], [0.8, 0.6], [1, 0.8]],
        'flat': [[0, .7], [1, 1]],
        'random': [[0, 0.], [0.38, 0.], [0.55, 1.], [0.72, 1.], [1, 0.05]]
      };
    }
  }]);

  return HelpersLut;
}();

exports.default = HelpersLut;

},{}],115:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * Helpers material mixin.
 *
 * @module helpers/material/mixin
 */

var HerlpersMaterialMixin = function HerlpersMaterialMixin(superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: "_createMaterial",
      value: function _createMaterial(extraOptions) {
        // generate shaders on-demand!
        var fs = new this._shadersFragment(this._uniforms);
        var vs = new this._shadersVertex();

        // material
        var globalOptions = {
          uniforms: this._uniforms,
          vertexShader: vs.compute(),
          fragmentShader: fs.compute()
        };

        var options = Object.assign(extraOptions, globalOptions);
        this._material = new THREE.ShaderMaterial(options);
        this._material.needsUpdate = true;
      }
    }, {
      key: "_updateMaterial",
      value: function _updateMaterial() {
        // generate shaders on-demand!
        var fs = new this._shadersFragment(this._uniforms);
        var vs = new this._shadersVertex();

        this._material.vertexShader = vs.compute();
        this._material.fragmentShader = fs.compute();

        this._material.needsUpdate = true;
      }
    }, {
      key: "_prepareTexture",
      value: function _prepareTexture() {
        this._textures = [];
        for (var m = 0; m < this._stack._rawData.length; m++) {
          var tex = new THREE.DataTexture(this._stack.rawData[m], this._stack.textureSize, this._stack.textureSize, this._stack.textureType, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
          tex.needsUpdate = true;
          tex.flipY = true;
          this._textures.push(tex);
        }
      }
    }]);

    return _class;
  }(superclass);
};

exports.default = HerlpersMaterialMixin;

},{}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core/core.utils');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Event Based progressbar
 * @module helpers/progressBar
 *
 * @example
 *
 * let loader = new LoadersVolume();
 * const domContainer = document.getElementById('progressbar');
 * const pb = new HelpersProgressBarEventBased(loader, domContainer);
 */

var HelpersProgressBarEventBased = function () {
  function HelpersProgressBarEventBased(emitter, domTarget) {
    _classCallCheck(this, HelpersProgressBarEventBased);

    if (!emitter || !this._isFunction(emitter.emit)) {
      console.error('please give the this._emitter instance');
      return;
    }

    if (_core2.default.isString(domTarget)) {
      this._dom = document.getElementById(domTarget);
    } else {
      this._dom = domTarget;
    }

    if (!_core2.default.isElement(this._dom)) {
      console.error('please give the id of container dom or directly a dom instance');
      return;
    }
    this._emitter = emitter;
    this.initContainerDom();
    this.initEventListenner();
    this.loaded = 0;
    this.totalFile = 0;
  }

  _createClass(HelpersProgressBarEventBased, [{
    key: '_isFunction',
    value: function _isFunction(fn) {
      return Object.prototype.toString.call(fn) === '[object Function]';
    }
  }, {
    key: 'initEventListenner',
    value: function initEventListenner() {
      var self = this;

      this._emitter.on('load-start', function (event) {
        var totalFiles = event.totalFiles;
        self.totalFile = totalFiles;
        self._domTotalFile.innerHTML = totalFiles;
      });

      this._emitter.on('fetch-start', function (event) {
        var fetchLi = document.createElement('li');

        var fileTag = document.createElement('div');
        fileTag.innerHTML = 'file: ' + event.file;
        fileTag.style.color = '#ffffff';
        fetchLi.append(fileTag);

        fetchLi.className = 'fetch-file';
        fetchLi.id = 'file-' + event.file;
        fetchLi.style.marginBottom = '7px';
        fetchLi.style.border = '1px solid #ffffff;';
        fetchLi.style.width = '60%';
        var fetchprogress = document.createElement('div');
        fetchprogress.id = 'file-fetch-' + event.file;
        fetchprogress.style.width = '0%';
        fetchLi.append(fetchprogress);
        self._domProcessList.append(fetchLi);
      });

      this._emitter.on('fetch-progress', function (event) {
        var id = 'file-fetch-' + event.file;
        var fileFetchDom = document.getElementById(id);
        fileFetchDom.style.width = event.loaded / event.total * 100 + '%';
        fileFetchDom.style.border = '1px solid red';
      });

      this._emitter.on('fetch-success', function (event) {
        // show result
        var liParent = document.getElementById('file-' + event.file);
        var result = document.createElement('div');
        result.id = 'file-result-' + event.file;
        result.innerHTML = 'fetch-success';
        result.style.color = '#ffffff';
        liParent.append(result);
      });

      this._emitter.on('fetch-error', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-abort', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-end', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-timeout', function (event) {
        // console.log(event);
      });

      this._emitter.on('parse-start', function (event) {
        var liParent = document.getElementById('file-' + event.file);
        var parseprogress = document.createElement('div');
        parseprogress.id = 'file-parse-' + event.file;
        parseprogress.style.width = '0%';
        liParent.append(parseprogress);
      });

      this._emitter.on('parsing', function (event) {
        var id = 'file-parse-' + event.file;
        var fileParseDom = document.getElementById(id);
        fileParseDom.style.width = event.parsed / event.total * 100 + '%';
        fileParseDom.style.border = '1px solid yellow';
      });

      this._emitter.on('parse-success', function (event) {
        self.loaded += 1;
        self._domCurrentFile.innerHTML = self.loaded;
        self._domCurrentProgress.style.width = self.loaded / self.totalFile * 100 + '%';
        // show result
        var liParent = document.getElementById('file-' + event.file);
        var result = document.createElement('div');
        result.id = 'file-result-' + event.file;
        result.innerHTML = 'parse-success';
        result.style.color = '#ffffff';
        liParent.append(result);
      });
    }
  }, {
    key: 'initContainerDom',
    value: function initContainerDom() {
      var containerDom = "<div id='ami-progress-bar-container' style='background-color: rgb(33, 33, 33); color: #ffffff;'>" + "<div>" + "<label for='progress-bar' id='progress-label' style='width: 60%; border: 1px solid #ffffff; text-align: center;'>" + "<span id='current-file-index'>0</span>" + "/" + "<span id='total-file'>0</span>" + "</label>" + "<div id='progress-bar' style='width: 60%; border: 1px solid #ffffff; text-align: center;'>" + "<div id='current-progress' style='border: 1px solid red; width: 0%;'></div>" + "</div>" + "</div>" + "<ul id='process-list' style='list-style-type: none; padding: 0; overflow-y: auto;'>" +
      // "<li class='fetch-file'>" +
      // "<div id='file-fetch-xxxxxid'></div>" +
      // "<div id='file-parse-xxxxxid'></div>" +
      // "</li>" +
      "</ul>" + "</div>";
      var wrap = document.createElement('div');
      wrap.innerHTML = containerDom;
      this._dom.append(wrap);
      // dom interface
      this._domCurrentFile = document.getElementById('current-file-index');
      this._domTotalFile = document.getElementById('total-file');
      this._domProcessList = document.getElementById('process-list');
      this._domCurrentProgress = document.getElementById('current-progress');
    }
  }]);

  return HelpersProgressBarEventBased;
}();

exports.default = HelpersProgressBarEventBased;

},{"../core/core.utils":105}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module helpers/progressBar
 */

var HelpersProgressBar = function () {
  function HelpersProgressBar(container) {
    _classCallCheck(this, HelpersProgressBar);

    this._container = container;
    this._modes = {
      'load': {
        'name': 'load',
        'color': '#FFF56F'
      },
      'parse': {
        'name': 'parse',
        'color': '#2196F3'
      }
    };

    this.requestAnimationFrameID = null;

    this._mode = null;
    this._value = null;
    this._total = null;

    this.init();
  }

  _createClass(HelpersProgressBar, [{
    key: 'free',
    value: function free() {
      var progressContainers = this._container.getElementsByClassName('progress container');
      if (progressContainers.length > 0) {
        progressContainers[0].parentNode.removeChild(progressContainers[0]);
      }
      progressContainers = null;
      // stop rendering loop
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
  }, {
    key: 'init',
    value: function init() {
      var progressContainer = this._domContainer();

      for (var mode in this._modes) {
        if (this._modes.hasOwnProperty(mode)) {
          var bar = this._domBar(this._modes[mode]);
          progressContainer.appendChild(bar);
          bar = null;
        }
      }

      this._container.appendChild(progressContainer);
      progressContainer = null;

      // start rendering loop
      this.updateUI();
    }
  }, {
    key: 'update',
    value: function update(value, total, mode) {
      this._mode = mode;
      this._value = value;
      // depending on CDN, total return to XHTTPRequest can be 0.
      // In this case, we generate a random number to animate the progressbar
      if (total === 0) {
        this._total = value;
        this._value = Math.random() * value;
      } else {
        this._total = total;
      }
    }
  }, {
    key: 'updateUI',
    value: function updateUI() {
      var _this = this;

      this.requestAnimationFrameID = requestAnimationFrame(function () {
        _this.updateUI();
      });

      if (!(this._modes.hasOwnProperty(this._mode) && this._modes[this._mode].hasOwnProperty('name') && this._modes[this._mode].hasOwnProperty('color'))) {
        return false;
      }

      var message = '';
      var progress = Math.round(this._value / this._total * 100);
      var color = this._modes[this._mode].color;

      var progressBar = this._container.getElementsByClassName('progress ' + this._modes[this._mode].name);
      if (progressBar.length > 0) {
        progressBar[0].style.borderColor = color;
        progressBar[0].style.width = progress + '%';
      }
      progressBar = null;
    }
  }, {
    key: '_domContainer',
    value: function _domContainer() {
      var container = document.createElement('div');

      // class it
      container.classList.add('progress');
      container.classList.add('container');

      // style it
      container.style.width = '100%';
      container.style.height = '8px';
      container.style.position = 'absolute';
      container.style.backgroundColor = 'rgba(158, 158, 158, 0.5)';
      container.style.top = '0';
      container.style.zIndex = '1';

      return container;
    }
  }, {
    key: '_domBar',
    value: function _domBar(mode) {
      if (!(mode.hasOwnProperty('name') && mode.hasOwnProperty('color'))) {
        window.console.log('Invalid mode provided.');
        window.console.log(mode);

        return false;
      }

      var bar = document.createElement('div');

      // class it
      bar.classList.add(mode.name);
      bar.classList.add('progress');

      // style it
      bar.style.border = '2px solid ' + mode.color;
      bar.style.width = '0%';

      return bar;
    }
  }]);

  return HelpersProgressBar;
}();

exports.default = HelpersProgressBar;

},{}],118:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _geometries = require('../geometries/geometries.slice');

var _geometries2 = _interopRequireDefault(_geometries);

var _shadersData = require('../shaders/shaders.data.uniform');

var _shadersData2 = _interopRequireDefault(_shadersData);

var _shadersData3 = require('../shaders/shaders.data.vertex');

var _shadersData4 = _interopRequireDefault(_shadersData3);

var _shadersData5 = require('../shaders/shaders.data.fragment');

var _shadersData6 = _interopRequireDefault(_shadersData5);

var _helpersMaterial = require('../helpers/helpers.material.mixin');

var _helpersMaterial2 = _interopRequireDefault(_helpersMaterial);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * @module helpers/slice
 */

var HelpersSlice = function (_HelpersMaterialMixin) {
  _inherits(HelpersSlice, _HelpersMaterialMixin);

  function HelpersSlice(stack) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector3(0, 0, 0);
    var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector3(0, 0, 1);
    var aabbSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'IJK';

    _classCallCheck(this, HelpersSlice);

    // private vars
    var _this = _possibleConstructorReturn(this, (HelpersSlice.__proto__ || Object.getPrototypeOf(HelpersSlice)).call(this));
    //


    _this._stack = stack;

    // image settings
    // index only used to grab window/level and intercept/slope
    _this._invert = _this._stack.invert;

    _this._lut = 'none';
    _this._lutTexture = null;
    // if auto === true, get from index
    // else from stack which holds the default values
    _this._intensityAuto = true;
    _this._interpolation = 1; // default to trilinear interpolation
    // starts at 0
    _this._index = index;
    _this._windowWidth = null;
    _this._windowCenter = null;
    _this._rescaleSlope = null;
    _this._rescaleIntercept = null;

    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._borderColor = null;

    // Object3D settings
    // shape
    _this._planePosition = position;
    _this._planeDirection = direction;
    // change aaBBSpace changes the box dimensions
    // also changes the transform
    // there is also a switch to move back mesh to LPS space automatically
    _this._aaBBspace = aabbSpace; // or LPS -> different transforms, esp for the geometry/mesh
    _this._material = null;
    _this._textures = [];
    _this._shadersFragment = _shadersData6.default;
    _this._shadersVertex = _shadersData4.default;
    _this._uniforms = _shadersData2.default.uniforms();
    _this._geometry = null;
    _this._mesh = null;
    _this._visible = true;

    // update dimensions, center, etc.
    // depending on aaBBSpace
    _this._init();

    // update object
    _this._create();
    return _this;
  }

  // getters/setters

  _createClass(HelpersSlice, [{
    key: '_init',
    value: function _init() {
      if (!this._stack || !this._stack._prepared || !this._stack._packed) {
        return;
      }

      if (this._aaBBspace === 'IJK') {
        this._halfDimensions = this._stack.halfDimensionsIJK;
        this._center = new THREE.Vector3(this._stack.halfDimensionsIJK.x - 0.5, this._stack.halfDimensionsIJK.y - 0.5, this._stack.halfDimensionsIJK.z - 0.5);
        this._toAABB = new THREE.Matrix4();
      } else {
        // LPS
        var aaBBox = this._stack.AABBox();
        this._halfDimensions = aaBBox.clone().multiplyScalar(0.5);
        this._center = this._stack.centerAABBox();
        this._toAABB = this._stack.lps2AABB;
      }
    }

    // private methods

  }, {
    key: '_create',
    value: function _create() {
      if (!this._stack || !this._stack.prepared || !this._stack.packed) {
        return;
      }

      // Convenience vars
      try {
        this._geometry = new _geometries2.default(this._halfDimensions, this._center, this._planePosition, this._planeDirection, this._toAABB);
      } catch (e) {
        window.console.log(e);
        window.console.log('invalid slice geometry - exiting...');
        return;
      }

      if (!this._geometry.vertices) {
        return;
      }

      if (!this._material) {
        //
        this._uniforms.uTextureSize.value = this._stack.textureSize;
        this._uniforms.uDataDimensions.value = [this._stack.dimensionsIJK.x, this._stack.dimensionsIJK.y, this._stack.dimensionsIJK.z];
        this._uniforms.uWorldToData.value = this._stack.lps2IJK;
        this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
        this._uniforms.uPixelType.value = this._stack.pixelType;
        this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
        this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;
        // compute texture if material exist
        this._prepareTexture();
        this._uniforms.uTextureContainer.value = this._textures;

        this._createMaterial({
          side: THREE.DoubleSide
        });
      }

      // update intensity related stuff
      this.updateIntensitySettings();
      this.updateIntensitySettingsUniforms();

      // create the mesh!
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      if (this._aaBBspace === 'IJK') {
        this._mesh.applyMatrix(this._stack.ijk2LPS);
      }

      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: 'updateIntensitySettings',
    value: function updateIntensitySettings() {
      // if auto, get from frame index
      if (this._intensityAuto) {
        this.updateIntensitySetting('windowCenter');
        this.updateIntensitySetting('windowWidth');
        this.updateIntensitySetting('rescaleSlope');
        this.updateIntensitySetting('rescaleIntercept');
      } else {
        if (this._windowCenter === null) {
          this._windowCenter = this._stack.windowCenter;
        }

        if (this.__windowWidth === null) {
          this._windowWidth = this._stack.windowWidth;
        }

        if (this._rescaleSlope === null) {
          this._rescaleSlope = this._stack.rescaleSlope;
        }

        if (this._rescaleIntercept === null) {
          this._rescaleIntercept = this._stack.rescaleIntercept;
        }
      }
    }
  }, {
    key: 'updateIntensitySettingsUniforms',
    value: function updateIntensitySettingsUniforms() {
      // compensate for the offset to only pass > 0 values to shaders
      // models > models.stack.js : _packTo8Bits
      var offset = 0;
      if (this._stack._minMax[0] < 0) {
        offset -= this._stack._minMax[0];
      }

      // set slice window center and width
      this._uniforms.uRescaleSlopeIntercept.value = [this._rescaleSlope, this._rescaleIntercept];
      this._uniforms.uWindowCenterWidth.value = [offset + this._windowCenter, this._windowWidth];

      // invert
      this._uniforms.uInvert.value = this._invert === true ? 1 : 0;

      // interpolation
      this._uniforms.uInterpolation.value = this._interpolation;

      // lut
      if (this._lut === 'none') {
        this._uniforms.uLut.value = 0;
      } else {
        this._uniforms.uLut.value = 1;
        this._uniforms.uTextureLUT.value = this._lutTexture;
      }
    }
  }, {
    key: 'updateIntensitySetting',
    value: function updateIntensitySetting(setting) {
      if (this._stack.frame[this._index] && this._stack.frame[this._index][setting]) {
        this['_' + setting] = this._stack.frame[this._index][setting];
      } else {
        this['_' + setting] = this._stack[setting];
      }
    }
  }, {
    key: '_update',
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        // we do not want to dispose the texture!
        // this._mesh.material.dispose();
        // this._mesh.material = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      // Release memory
      for (var j = 0; j < this._textures.length; j++) {
        this._textures[j].dispose();
        this._textures[j] = null;
      }
      this._textures = null;
      this._shadersFragment = null;
      this._shadersVertex = null;

      this._uniforms = null;

      // material, geometry and mesh
      this.remove(this._mesh);
      this._mesh.geometry.dispose();
      this._mesh.geometry = null;
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._mesh = null;

      this._geometry.dispose();
      this._geometry = null;
      this._material.vertexShader = null;
      this._material.fragmentShader = null;
      this._material.uniforms = null;
      this._material.dispose();
      this._material = null;

      this._stack = null;
    }
  }, {
    key: 'cartesianEquation',
    value: function cartesianEquation() {
      // Make sure we have a geometry
      if (!this._geometry || !this._geometry.vertices || this._geometry.vertices.length < 3) {
        return new THREE.Vector4();
      }

      var vertices = this._geometry.vertices;
      var dataToWorld = this._stack.ijk2LPS;
      var p1 = new THREE.Vector3(vertices[0].x, vertices[0].y, vertices[0].z).applyMatrix4(dataToWorld);
      var p2 = new THREE.Vector3(vertices[1].x, vertices[1].y, vertices[1].z).applyMatrix4(dataToWorld);
      var p3 = new THREE.Vector3(vertices[2].x, vertices[2].y, vertices[2].z).applyMatrix4(dataToWorld);
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var normal = v1.subVectors(p3, p2).cross(v2.subVectors(p1, p2)).normalize();

      return new THREE.Vector4(normal.x, normal.y, normal.z, -normal.dot(p1));
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    },
    set: function set(stack) {
      this._stack = stack;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'invert',
    get: function get() {
      return this._invert;
    },
    set: function set(invert) {
      this._invert = invert;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'lut',
    get: function get() {
      return this._lut;
    },
    set: function set(lut) {
      this._lut = lut;
    }
  }, {
    key: 'lutTexture',
    get: function get() {
      return this._lutTexture;
    },
    set: function set(lutTexture) {
      this._lutTexture = lutTexture;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'intensityAuto',
    get: function get() {
      return this._intensityAuto;
    },
    set: function set(intensityAuto) {
      this._intensityAuto = intensityAuto;
      this.updateIntensitySettings();
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'interpolation',
    get: function get() {
      return this._interpolation;
    },
    set: function set(interpolation) {
      this._interpolation = interpolation;
      this.updateIntensitySettingsUniforms();
      this._updateMaterial();
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
      this._update();
    }
  }, {
    key: 'planePosition',
    set: function set(position) {
      this._planePosition = position;
      this._update();
    },
    get: function get() {
      return this._planePosition;
    }
  }, {
    key: 'planeDirection',
    set: function set(direction) {
      this._planeDirection = direction;
      this._update();
    },
    get: function get() {
      return this._planeDirection;
    }
  }, {
    key: 'halfDimensions',
    set: function set(halfDimensions) {
      this._halfDimensions = halfDimensions;
    },
    get: function get() {
      return this._halfDimensions;
    }
  }, {
    key: 'center',
    set: function set(center) {
      this._center = center;
    },
    get: function get() {
      return this._center;
    }
  }, {
    key: 'aabbSpace',
    set: function set(aabbSpace) {
      this._aaBBspace = aabbSpace;
      this._init();
    },
    get: function get() {
      return this._aaBBspace;
    }
  }, {
    key: 'mesh',
    set: function set(mesh) {
      this._mesh = mesh;
    },
    get: function get() {
      return this._mesh;
    }
  }, {
    key: 'geometry',
    set: function set(geometry) {
      this._geometry = geometry;
    },
    get: function get() {
      return this._geometry;
    }
  }, {
    key: 'canvasWidth',
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._uniforms.uCanvasWidth.value = this._canvasWidth;
    },
    get: function get() {
      return this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._uniforms.uCanvasHeight.value = this._canvasHeight;
    },
    get: function get() {
      return this._canvasHeight;
    }
  }, {
    key: 'borderColor',
    set: function set(borderColor) {
      this._borderColor = borderColor;
      this._uniforms.uBorderColor.value = new THREE.Color(borderColor);
    },
    get: function get() {
      return this._borderColor;
    }
  }]);

  return HelpersSlice;
}((0, _helpersMaterial2.default)(THREE.Object3D));

exports.default = HelpersSlice;

},{"../geometries/geometries.slice":108,"../helpers/helpers.material.mixin":115,"../shaders/shaders.data.fragment":152,"../shaders/shaders.data.uniform":153,"../shaders/shaders.data.vertex":154}],119:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _helpers = require('../helpers/helpers.border');

var _helpers2 = _interopRequireDefault(_helpers);

var _helpers3 = require('../helpers/helpers.boundingbox');

var _helpers4 = _interopRequireDefault(_helpers3);

var _helpers5 = require('../helpers/helpers.slice');

var _helpers6 = _interopRequireDefault(_helpers5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * Helper to easily display and interact with a stack.<br>
 *<br>
 * Defaults:<br>
 *   - orientation: 0 (acquisition direction)<br>
 *   - index: middle slice in acquisition direction<br>
 *<br>
 * Features:<br>
 *   - slice from the stack (in any direction)<br>
 *   - slice border<br>
 *   - stack bounding box<br>
 *<br>
 * Live demo at: {@link http://jsfiddle.net/gh/get/library/pure/fnndsc/ami/tree/master/lessons/01#run|Lesson 01}
 *
 * @example
 * let stack = new VJS.Models.Stack();
 * ... // prepare the stack
 *
 * let stackHelper = new VJS.Helpers.Stack(stack);
 * stackHelper.bbox.color = 0xF9F9F9;
 * stackHelper.border.color = 0xF9F9F9;
 *
 * let scene = new THREE.Scene();
 * scene.add(stackHelper);
 *
 * @extends THREE.Object3D
 *
 * @see module:helpers/border
 * @see module:helpers/boundingbox
 * @see module:helpers/slice
 *
 * @module helpers/stack
 */
var HelpersStack = function (_THREE$Object3D) {
  _inherits(HelpersStack, _THREE$Object3D);

  function HelpersStack(stack) {
    _classCallCheck(this, HelpersStack);

    var _this = _possibleConstructorReturn(this, (HelpersStack.__proto__ || Object.getPrototypeOf(HelpersStack)).call(this));
    //


    _this._stack = stack;
    _this._bBox = null;
    _this._slice = null;
    _this._border = null;
    _this._dummy = null;

    _this._orientation = 0;
    _this._index = 0;

    _this._uniforms = null;
    _this._autoWindowLevel = false;
    _this._outOfBounds = false;
    _this._orientationMaxIndex = 0;

    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._borderColor = null;

    // this._arrow = {
    //   visible: true,
    //   color: 0xFFF336,
    //   length: 20,
    //   material: null,
    //   geometry: null,
    //   mesh: null
    // };
    _this._create();
    return _this;
  }

  //
  // PUBLIC METHODS
  //

  //
  // SETTERS/GETTERS
  //

  /**
   * Get stack.
   *
   * @type {ModelsStack}
   */

  _createClass(HelpersStack, [{
    key: '_create',

    //
    // PRIVATE METHODS
    //

    /**
     * Initial setup, including stack prepare, bbox prepare, slice prepare and
     * border prepare.
     *
     * @private
     */
    value: function _create() {
      if (this._stack) {
        // prepare sthe stack internals
        this._prepareStack();

        // prepare visual objects
        this._prepareBBox();
        this._prepareSlice();
        this._prepareBorder();
        // todo: Arrow
      } else {
        window.console.log('no stack to be prepared...');
      }
    }
  }, {
    key: '_computeOrientationMaxIndex',
    value: function _computeOrientationMaxIndex() {
      var dimensionsIJK = this._stack.dimensionsIJK;
      this._orientationMaxIndex = 0;
      switch (this._orientation) {
        case 0:
          this._orientationMaxIndex = dimensionsIJK.z - 1;
          break;
        case 1:
          this._orientationMaxIndex = dimensionsIJK.x - 1;
          break;
        case 2:
          this._orientationMaxIndex = dimensionsIJK.y - 1;
          break;
        default:
          // do nothing!
          break;
      }
    }

    /**
     * Given orientation, check if index is in/out of bounds.
     *
     * @private
     */

  }, {
    key: '_isIndexOutOfBounds',
    value: function _isIndexOutOfBounds() {
      this._computeOrientationMaxIndex();
      if (this._index >= this._orientationMaxIndex || this._index < 0) {
        this._outOfBounds = true;
      } else {
        this._outOfBounds = false;
      }
    }

    /**
     * Prepare a stack for visualization. (image to world transform, frames order,
     * pack data into 8 bits textures, etc.)
     *
     * @private
     */

  }, {
    key: '_prepareStack',
    value: function _prepareStack() {
      // make sure there is something, if not throw an error
      // compute image to workd transform, order frames, etc.
      if (!this._stack.prepared) {
        this._stack.prepare();
      }
      // pack data into 8 bits rgba texture for the shader
      // this one can be slow...
      if (!this._stack.packed) {
        this._stack.pack();
      }
    }

    /**
     * Setup bounding box helper given prepared stack and add bounding box helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareBBox',
    value: function _prepareBBox() {
      this._bBox = new _helpers4.default(this._stack);
      this.add(this._bBox);
    }

    /**
     * Setup border helper given slice helper and add border helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareBorder',
    value: function _prepareBorder() {
      this._border = new _helpers2.default(this._slice);
      this.add(this._border);
    }

    /**
     * Setup slice helper given prepared stack helper and add slice helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareSlice',
    value: function _prepareSlice() {
      var halfDimensionsIJK = this._stack.halfDimensionsIJK;
      // compute initial index given orientation
      this._index = this._prepareSliceIndex(halfDimensionsIJK);
      // compute initial position given orientation and index
      var position = this._prepareSlicePosition(halfDimensionsIJK, this._index);
      // compute initial direction orientation
      var direction = this._prepareDirection(this._orientation);

      this._slice = new _helpers6.default(this._stack, this._index, position, direction);
      this.add(this._slice);
    }

    /**
     * Compute slice index depending on orientation.
     *
     * @param {THREE.Vector3} indices - Indices in each direction.
     *
     * @returns {number} Slice index according to current orientation.
     *
     * @private
     */

  }, {
    key: '_prepareSliceIndex',
    value: function _prepareSliceIndex(indices) {
      var index = 0;
      switch (this._orientation) {
        case 0:
          index = Math.floor(indices.z);
          break;
        case 1:
          index = Math.floor(indices.x);
          break;
        case 2:
          index = Math.floor(indices.y);
          break;
        default:
          // do nothing!
          break;
      }
      return index;
    }

    /**
     * Compute slice position depending on orientation.
     * Sets index in proper location of reference position.
     *
     * @param {THREE.Vector3} rPosition - Reference position.
     * @param {number} index - Current index.
     *
     * @returns {number} Slice index according to current orientation.
     *
     * @private
     */

  }, {
    key: '_prepareSlicePosition',
    value: function _prepareSlicePosition(rPosition, index) {
      var position = new THREE.Vector3(0, 0, 0);
      switch (this._orientation) {
        case 0:
          position = new THREE.Vector3(Math.floor(rPosition.x), Math.floor(rPosition.y), index);
          break;
        case 1:
          position = new THREE.Vector3(index, Math.floor(rPosition.y), Math.floor(rPosition.z));
          break;
        case 2:
          position = new THREE.Vector3(Math.floor(rPosition.x), index, Math.floor(rPosition.z));
          break;
        default:
          // do nothing!
          break;
      }
      return position;
    }

    /**
     * Compute slice direction depending on orientation.
     *
     * @param {number} orientation - Slice orientation.
     *
     * @returns {THREE.Vector3} Slice direction
     *
     * @private
     */

  }, {
    key: '_prepareDirection',
    value: function _prepareDirection(orientation) {
      var direction = new THREE.Vector3(0, 0, 1);
      switch (orientation) {
        case 0:
          direction = new THREE.Vector3(0, 0, 1);
          break;
        case 1:
          direction = new THREE.Vector3(1, 0, 0);
          break;
        case 2:
          direction = new THREE.Vector3(0, 1, 0);
          break;
        default:
          // do nothing!
          break;
      }

      return direction;
    }

    /**
     * Release the stack helper memory including the slice memory.
     *
     * @public
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this.remove(this._slice);
      this._slice.dispose();
      this._slice = null;
      this._bBox.dispose();
      this._bBox = null;
      this._border.dispose();
      this._border = null;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    }

    /**
     * Set stack.
     *
     * @type {ModelsStack}
     */

    , set: function set(stack) {
      this._stack = stack;
    }

    /**
     * Get bounding box helper.
     *
     * @type {HelpersBoundingBox}
     */

  }, {
    key: 'bbox',
    get: function get() {
      return this._bBox;
    }

    /**
     * Get slice helper.
     *
     * @type {HelpersSlice}
     */

  }, {
    key: 'slice',
    get: function get() {
      return this._slice;
    }

    /**
     * Get border helper.
     *
     * @type {HelpersSlice}
     */

  }, {
    key: 'border',
    get: function get() {
      return this._border;
    }

    /**
     * Set/get current slice index.<br>
     * Sets outOfBounds flag to know if target index is in/out stack bounding box.<br>
     * <br>
     * Internally updates the sliceHelper index and position. Also updates the
     * borderHelper with the updated sliceHelper.
     *
     * @type {number}
     */

  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;

      // update the slice
      this._slice.index = index;
      var halfDimensions = this._stack.halfDimensionsIJK;
      this._slice.planePosition = this._prepareSlicePosition(halfDimensions, this._index);

      // also update the border
      this._border.helpersSlice = this._slice;

      // update ourOfBounds flag
      this._isIndexOutOfBounds();
    }

    /**
     * Set/get current slice orientation.<br>
     * Values: <br>
     *   - 0: acquisition direction (slice normal is z_cosine)<br>
     *   - 1: next direction (slice normal is x_cosine)<br>
     *   - 2: next direction (slice normal is y_cosine)<br>
     *   - n: set orientation to 0<br>
     * <br>
     * Internally updates the sliceHelper direction. Also updates the
     * borderHelper with the updated sliceHelper.
     *
     * @type {number}
     */

  }, {
    key: 'orientation',
    set: function set(orientation) {
      this._orientation = orientation;
      this._computeOrientationMaxIndex();

      this._slice.planeDirection = this._prepareDirection(this._orientation);

      // also update the border
      this._border.helpersSlice = this._slice;
    },
    get: function get() {
      return this._orientation;
    }

    /**
     * Set/get the outOfBound flag.
     *
     * @type {boolean}
     */

  }, {
    key: 'outOfBounds',
    set: function set(outOfBounds) {
      this._outOfBounds = outOfBounds;
    },
    get: function get() {
      return this._outOfBounds;
    }

    /**
     * Set/get the orientationMaxIndex flag.
     *
     * @type {boolean}
     */

  }, {
    key: 'orientationMaxIndex',
    set: function set(orientationMaxIndex) {
      this._orientationMaxIndex = orientationMaxIndex;
    },
    get: function get() {
      return this._orientationMaxIndex;
    }
  }, {
    key: 'canvasWidth',
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._slice.canvasWidth = this._canvasWidth;
    },
    get: function get() {
      return this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._slice.canvasHeight = this._canvasHeight;
    },
    get: function get() {
      return this._canvasHeight;
    }
  }, {
    key: 'borderColor',
    set: function set(borderColor) {
      this._borderColor = borderColor;
      this._border.color = borderColor;
      this._slice.borderColor = this._borderColor;
    },
    get: function get() {
      return this._borderColor;
    }
  }]);

  return HelpersStack;
}(THREE.Object3D);

exports.default = HelpersStack;

},{"../helpers/helpers.border":110,"../helpers/helpers.boundingbox":111,"../helpers/helpers.slice":118}],120:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shadersVr = require('../shaders/shaders.vr.uniform');

var _shadersVr2 = _interopRequireDefault(_shadersVr);

var _shadersVr3 = require('../shaders/shaders.vr.vertex');

var _shadersVr4 = _interopRequireDefault(_shadersVr3);

var _shadersVr5 = require('../shaders/shaders.vr.fragment');

var _shadersVr6 = _interopRequireDefault(_shadersVr5);

var _helpersMaterial = require('../helpers/helpers.material.mixin');

var _helpersMaterial2 = _interopRequireDefault(_helpersMaterial);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * @module helpers/volumerendering
 */

var HelpersVolumeRendering = function (_HelpersMaterialMixin) {
  _inherits(HelpersVolumeRendering, _HelpersMaterialMixin);

  function HelpersVolumeRendering(stack) {
    _classCallCheck(this, HelpersVolumeRendering);

    var _this = _possibleConstructorReturn(this, (HelpersVolumeRendering.__proto__ || Object.getPrototypeOf(HelpersVolumeRendering)).call(this));
    //


    _this._stack = stack;
    _this._textures = [];
    _this._shadersFragment = _shadersVr6.default;
    _this._shadersVertex = _shadersVr4.default;
    _this._uniforms = _shadersVr2.default.uniforms();
    _this._material = null;
    _this._geometry = null;

    _this._interpolation = 1; // default to trilinear interpolation

    _this._create();
    return _this;
  }

  _createClass(HelpersVolumeRendering, [{
    key: '_create',
    value: function _create() {
      this._prepareStack();
      this._prepareTexture();
      this._prepareMaterial();
      this._prepareGeometry();

      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this.add(this._mesh);
    }
  }, {
    key: '_prepareStack',
    value: function _prepareStack() {
      if (!this._stack.prepared) {
        this._stack.prepare();
      }

      if (!this._stack.packed) {
        this._stack.pack();
      }
    }
  }, {
    key: '_prepareMaterial',
    value: function _prepareMaterial() {
      // compensate for the offset to only pass > 0 values to shaders
      // models > models.stack.js : _packTo8Bits
      var offset = 0;
      if (this._stack._minMax[0] < 0) {
        offset = this._stack._minMax[0];
      }

      // uniforms
      this._uniforms = _shadersVr2.default.uniforms();
      this._uniforms.uWorldBBox.value = this._stack.worldBoundingBox();
      this._uniforms.uTextureSize.value = this._stack.textureSize;
      this._uniforms.uTextureContainer.value = this._textures;
      this._uniforms.uWorldToData.value = this._stack.lps2IJK;
      this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
      this._uniforms.uPixelType.value = this._stack.pixelType;
      this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
      this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;
      this._uniforms.uWindowCenterWidth.value = [offset + this._stack.windowCenter, this._stack.windowWidth * 0.8];
      this._uniforms.uRescaleSlopeIntercept.value = [this._stack.rescaleSlope, this._stack.rescaleIntercept];
      this._uniforms.uDataDimensions.value = [this._stack.dimensionsIJK.x, this._stack.dimensionsIJK.y, this._stack.dimensionsIJK.z];
      this._uniforms.uInterpolation.value = this._interpolation;

      this._createMaterial({
        side: THREE.FrontSide,
        transparent: true
      });
    }
  }, {
    key: '_prepareGeometry',
    value: function _prepareGeometry() {
      var worldBBox = this._stack.worldBoundingBox();
      var centerLPS = this._stack.worldCenter();

      this._geometry = new THREE.BoxGeometry(worldBBox[1] - worldBBox[0], worldBBox[3] - worldBBox[2], worldBBox[5] - worldBBox[4]);
      this._geometry.applyMatrix(new THREE.Matrix4().makeTranslation(centerLPS.x, centerLPS.y, centerLPS.z));
    }
  }, {
    key: 'uniforms',
    get: function get() {
      return this._uniforms;
    },
    set: function set(uniforms) {
      this._uniforms = uniforms;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    },
    set: function set(stack) {
      this._stack = stack;
    }
  }, {
    key: 'interpolation',
    get: function get() {
      return this._interpolation;
    },
    set: function set(interpolation) {
      this._interpolation = interpolation;
      this._uniforms.uInterpolation.value = this._interpolation;
      this._updateMaterial();
    }
  }]);

  return HelpersVolumeRendering;
}((0, _helpersMaterial2.default)(THREE.Object3D));

exports.default = HelpersVolumeRendering;

},{"../helpers/helpers.material.mixin":115,"../shaders/shaders.vr.fragment":162,"../shaders/shaders.vr.uniform":163,"../shaders/shaders.vr.vertex":164}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module helpers/x/interactor
 */
var Interactor = function () {
  function Interactor() {
    _classCallCheck(this, Interactor);
  }

  // private methods


  _createClass(Interactor, [{
    key: "_create",
    value: function _create() {}
  }, {
    key: "_update",
    value: function _update() {}
  }]);

  return Interactor;
}();

exports.default = Interactor;

},{}],122:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpersX = require('./helpers.x.interactor');

var _helpersX2 = _interopRequireDefault(_helpersX);

var _helpersX3 = require('./helpers.x.mesh');

var _helpersX4 = _interopRequireDefault(_helpersX3);

var _helpersX5 = require('./helpers.x.renderer3d');

var _helpersX6 = _interopRequireDefault(_helpersX5);

var _helpersX7 = require('./helpers.x.renderer2d');

var _helpersX8 = _interopRequireDefault(_helpersX7);

var _helpersX9 = require('./helpers.x.volume');

var _helpersX10 = _interopRequireDefault(_helpersX9);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module helpers
 */

exports.default = {
  Interactor: _helpersX2.default,
  Mesh: _helpersX4.default,
  Renderer3D: _helpersX6.default,
  Renderer2D: _helpersX8.default,
  Volume: _helpersX10.default
};

},{"./helpers.x.interactor":121,"./helpers.x.mesh":123,"./helpers.x.renderer2d":124,"./helpers.x.renderer3d":125,"./helpers.x.volume":126}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module helpers/x/mesh
 */
var _class = function () {
  function _class() {
    _classCallCheck(this, _class);

    this._file = null;

    this._3jsVTK_loader = new THREE.VTKLoader();
    this._mesh = null;
    this._materialColor = 0xE91E63;
    this._RAStoLPS = null;
    this._material = new THREE.MeshLambertMaterial({
      shading: THREE.SmoothShading,
      color: this._materialColor,
      side: THREE.DoubleSide });
  }

  // accessor properties


  _createClass(_class, [{
    key: "load",

    // load function
    value: function load() {
      var _this = this;

      if (this.file) {
        return new Promise(function (resolve, reject) {
          _this._3jsVTK_loader.load(_this.file, function (geometry) {
            geometry.computeVertexNormals();
            _this._mesh = new THREE.Mesh(geometry, _this._material);
            _this._RAStoLPS = new THREE.Matrix4();
            _this._RAStoLPS.set(-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            _this._mesh.applyMatrix(_this._RAStoLPS);
            // resolve the promise and return the mesh
            resolve(_this._mesh);
          }, function () {}, function (error) {
            console.log(error);
            reject({
              message: "Couldn't load file: " + _this.file + ".",
              error: error
            });
          });
        });
      }

      return Promise.reject({ message: "File is not defined: " + this.file + "." });
    }
  }, {
    key: "file",
    get: function get() {
      return this._file;
    },
    set: function set(fname) {
      this._file = fname;
    }
  }, {
    key: "materialColor",
    get: function get() {
      return this._materialColor;
    },
    set: function set(color) {
      this._materialColor = color;
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],124:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}(); /**
      * @module helpers/x/renderer2d
      */

var _cameras = require('../../cameras/cameras.orthographic');

var _cameras2 = _interopRequireDefault(_cameras);

var _controls = require('../../controls/controls.trackballortho');

var _controls2 = _interopRequireDefault(_controls);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var _class = function () {
  function _class() {
    var containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'r2d';
    var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

    _classCallCheck(this, _class);

    this._container = null;
    this._renderer = null;
    this._camera = null;
    this._controls = null;
    this._orientation = orientation;
    this._scene = null;
    this._object = null;

    this._initRenderer(containerId);
    this._initCamera();
    this._initScene();
    this._initControls();

    // setup event listeners
    this._onScroll = this._onScroll.bind(this);
    this._onWindowResize = this._onWindowResize.bind(this);
    this.addEventListeners();
  }

  _createClass(_class, [{
    key: 'add',
    value: function add(object) {
      this._object = object;
      this._scene.add(this._object);

      this._setupCamera(this._object.stack);
      this._orientCamera(this._object, this._orientation);

      this._object.canvasWidth = this._container.clientWidth;
      this._object.canvasHeight = this._container.clientHeight;
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._controls.addEventListener('OnScroll', this._onScroll, false);
      window.addEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._controls.removeEventListener('OnScroll', this._onScroll, false);
      window.removeEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'animate',
    value: function animate() {
      this._controls.update();
      this._renderer.render(this._scene, this._camera);

      // request new frame
      requestAnimationFrame(this.animate.bind(this));
    }

    // private methods

  }, {
    key: '_initRenderer',
    value: function _initRenderer(containerId) {
      // renderer
      this._container = document.getElementById(containerId);
      this._renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._renderer.setClearColor(0x212121, 1);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._container.appendChild(this._renderer.domElement);
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      this._camera = new _cameras2.default(this._container.clientWidth / -2, this._container.clientWidth / 2, this._container.clientHeight / 2, this._container.clientHeight / -2, 1, 1000);
    }
  }, {
    key: '_initScene',
    value: function _initScene() {
      this._scene = new THREE.Scene();
    }
  }, {
    key: '_initControls',
    value: function _initControls() {
      // controls
      this._controls = new _controls2.default(this._camera, this._container);
      this._controls.staticMoving = true;
      this._controls.noRotate = true;
      this._camera.controls = this._controls;
    }
  }, {
    key: '_setupCamera',
    value: function _setupCamera(stack) {
      // set camera
      var worldbb = stack.worldBoundingBox();
      var lpsDims = new THREE.Vector3(worldbb[1] - worldbb[0], worldbb[3] - worldbb[2], worldbb[5] - worldbb[4]);

      // box: {halfDimensions, center}
      var box = {
        center: stack.worldCenter().clone(),
        halfDimensions: new THREE.Vector3(lpsDims.x + 10, lpsDims.y + 10, lpsDims.z + 10)
      };

      // init and zoom
      var canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };

      this._camera.directions = [stack.xCosine, stack.yCosine, stack.zCosine];
      this._camera.box = box;
      this._camera.canvas = canvas;
      this._camera.update();
      this._camera.fitBox(2);
    }
  }, {
    key: '_orientCamera',
    value: function _orientCamera(target) {
      var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

      this._camera.orientation = orientation;
      this._camera.update();
      this._camera.fitBox(2);
      target.orientation = this._camera.stackOrientation;
    }
  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._camera.canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };
      this._camera.fitBox(2);
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._object.canvasWidth = this._container.clientWidth;
      this._object.canvasHeight = this._container.clientHeight;
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      if (event.delta > 0) {
        if (this._object.index >= this._object.orientationMaxIndex) {
          return false;
        }
        this._object.index += 1;
      } else {
        if (this._object.index <= 0) {
          return false;
        }
        this._object.index -= 1;
      }
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"../../cameras/cameras.orthographic":97,"../../controls/controls.trackballortho":100}],125:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}(); /**
      * @module helpers/x/renderer3d
      */

var _controls = require('../../controls/controls.trackball');

var _controls2 = _interopRequireDefault(_controls);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var _class = function () {
  function _class() {
    var containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'r3d';

    _classCallCheck(this, _class);

    this._container = null;
    this._renderer = null;
    this._camera = null;
    this._controls = null;
    this._scene = null;

    this._initRenderer(containerId);
    this._initCamera();
    this._initScene();
    this._initControls();

    // setup event listeners
    this._onWindowResize = this._onWindowResize.bind(this);
    this.addEventListeners();
  }

  _createClass(_class, [{
    key: 'add',
    value: function add(obj) {
      this._scene.add(obj);
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      window.addEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      window.removeEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'center',
    value: function center(worldPosition) {
      // update camrea's and control's target
      this._camera.lookAt(worldPosition.x, worldPosition.y, worldPosition.z);
      this._camera.updateProjectionMatrix();
      this._controls.target.set(worldPosition.x, worldPosition.y, worldPosition.z);
    }
  }, {
    key: 'animate',
    value: function animate() {
      this._controls.update();
      this._renderer.render(this._scene, this._camera);

      // request new frame
      requestAnimationFrame(this.animate.bind(this));
    }

    // private methods

  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._camera.aspect = this._container.clientWidth / this._container.clientHeight;
      this._camera.updateProjectionMatrix();

      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
    }
  }, {
    key: '_initRenderer',
    value: function _initRenderer(containerId) {
      // renderer
      this._container = document.getElementById(containerId);
      this._renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._renderer.setClearColor(0x424242, 1);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._container.appendChild(this._renderer.domElement);
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      this._camera = new THREE.PerspectiveCamera(45, this._container.clientWidth / this._container.clientHeight, 1, 10000000);
      this._camera.position.x = 250;
      this._camera.position.y = 250;
      this._camera.position.z = 250;
    }
  }, {
    key: '_initScene',
    value: function _initScene() {
      // add some lights to the scene by default
      this._scene = new THREE.Scene();

      // ambient
      this._scene.add(new THREE.AmbientLight(0x353535));

      // directional 1
      var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(200, 200, 1000).normalize();
      this._scene.add(directionalLight);

      // directional 2
      var directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight2.position.set(-200, -200, -1000).normalize();
      this._scene.add(directionalLight2);
    }
  }, {
    key: '_initControls',
    value: function _initControls() {
      // controls
      this._controls = new _controls2.default(this._camera, this._container);
      this._controls.rotateSpeed = 1.4;
      this._controls.zoomSpeed = 1.2;
      this._controls.panSpeed = 0.8;
    }
  }, {
    key: 'container',
    set: function set(container) {
      this._container = container;
    },
    get: function get() {
      return this._container;
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"../../controls/controls.trackball":99}],126:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _helpers = require('../helpers.stack');

var _helpers2 = _interopRequireDefault(_helpers);

var _loaders = require('../../loaders/loaders.volume');

var _loaders2 = _interopRequireDefault(_loaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /**
   * @module helpers/x/volume
   */

var _class = function (_THREE$Object3D) {
  _inherits(_class, _THREE$Object3D);

  function _class() {
    _classCallCheck(this, _class);

    var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));

    _this._file = null;
    _this._progressbarContainer = null;
    _this._stack = null;
    _this._centerLPS = null;
    _this._xSlice = null;
    _this._ySlice = null;
    _this._zSlice = null;
    return _this;
  }

  // accessor properties


  _createClass(_class, [{
    key: '_createSlice',

    // private methods
    value: function _createSlice(orientation) {
      if (this._stack) {
        var stackHelper = new _helpers2.default(this._stack);
        stackHelper.orientation = orientation;

        if (orientation === 0) {
          stackHelper.border.color = 0xF44336;
          this._xSlice = stackHelper;
        } else if (orientation === 1) {
          stackHelper.bbox.visible = false;
          stackHelper.border.color = 0x4CAF50;
          this._ySlice = stackHelper;
        } else {
          stackHelper.bbox.visible = false;
          stackHelper.border.color = 0x2196F3;
          this._zSlice = stackHelper;
        }

        this._centerLPS = stackHelper.stack.worldCenter();
      }
    }

    // public methods

  }, {
    key: 'load',
    value: function load() {
      var _this2 = this;

      if (this.file) {
        // instantiate the loader
        // it loads and parses the dicom image
        var loader = new _loaders2.default(this._progressbarContainer);
        return loader.load(this.file).then(function () {
          return new Promise(function (resolve, reject) {
            if (loader.data.length <= 0) {
              return reject({ message: 'No data loaded: ' + loader.data + '.' });
            }

            // create the three slices when all files have been loaded
            var series = loader.data[0].mergeSeries(loader.data)[0];
            loader.free();

            _this2._stack = series.stack[0];
            _this2._createSlice(0);
            _this2.add(_this2._xSlice);
            _this2._createSlice(1);
            _this2.add(_this2._ySlice);
            _this2._createSlice(2);
            _this2.add(_this2._zSlice);

            return resolve(_this2);
          });
        }).catch(function (error) {
          loader.free();
          window.console.log('Something went wrong loading the volume...');
          window.console.log(error);
        });
      }

      return Promise.reject({ message: 'File not defined: ' + this.file + '.' });
    }
  }, {
    key: 'file',
    get: function get() {
      return this._file;
    },
    set: function set(fname) {
      this._file = fname;
    }
  }, {
    key: 'progressbarContainer',
    set: function set(container) {
      this._progressbarContainer = container;
    }
  }, {
    key: 'centerLPS',
    get: function get() {
      return this._centerLPS;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    }
  }]);

  return _class;
}(THREE.Object3D);

exports.default = _class;

},{"../../loaders/loaders.volume":129,"../helpers.stack":119}],127:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _helpers = require('../helpers/helpers.progressbar');

var _helpers2 = _interopRequireDefault(_helpers);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** Imports **/

/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/base
 * @extends EventEmitter
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
var LoadersBase = function (_EventEmitter) {
  _inherits(LoadersBase, _EventEmitter);

  /**
   * Create a Loader.
   * @param {dom} container - The dom container of loader.
   * @param {object} ProgressBar - The progressbar of loader.
   */
  function LoadersBase() {
    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var ProgressBar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _helpers2.default;

    _classCallCheck(this, LoadersBase);

    var _this = _possibleConstructorReturn(this, (LoadersBase.__proto__ || Object.getPrototypeOf(LoadersBase)).call(this));

    _this._loaded = -1;
    _this._totalLoaded = -1;
    _this._parsed = -1;
    _this._totalParsed = -1;

    _this._data = [];

    _this._container = container;
    _this._progressBar = null;
    if (_this._container && ProgressBar) {
      _this._progressBar = new ProgressBar(_this._container);
    }
    return _this;
  }

  /**
   * free the reference.
   */

  _createClass(LoadersBase, [{
    key: 'free',
    value: function free() {
      this._container = null;
      // this._helpersProgressBar = null;

      if (this._progressBar) {
        this._progressBar.free();
        this._progressBar = null;
      }
    }

    /**
     * load the resource by url.
     * @param {string} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'fetch',
    value: function fetch(url) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open('GET', url);
        request.crossOrigin = true;
        request.responseType = 'arraybuffer';

        request.onloadstart = function (event) {
          // emit 'fetch-start' event
          _this2.emit('fetch-start', {
            file: url,
            time: new Date()
          });
        };

        request.onload = function (event) {
          if (request.status === 200) {
            _this2._loaded = event.loaded;
            _this2._totalLoaded = event.total;

            // will be removed after eventer set up
            if (_this2._progressBar) {
              _this2._progressBar.update(_this2._loaded, _this2._totalLoaded, 'load');
            }

            var buffer = request.response;
            var response = {
              url: url,
              buffer: buffer
            };

            // emit 'fetch-success' event
            _this2.emit('fetch-success', {
              file: url,
              time: new Date(),
              totalLoaded: event.total
            });

            resolve(response);
          } else {
            reject(request.statusText);
          }
        };

        request.onerror = function () {
          // emit 'fetch-error' event
          _this2.emit('fetch-error', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.onabort = function (event) {
          // emit 'fetch-start' event
          _this2.emit('fetch-abort', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.ontimeout = function () {
          // emit 'fetch-timeout' event
          _this2.emit('fetch-timeout', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.onprogress = function (event) {
          _this2._loaded = event.loaded;
          _this2._totalLoaded = event.total;
          // emit 'fetch-progress' event
          _this2.emit('fetch-progress', {
            file: url,
            total: event.total,
            loaded: event.loaded,
            time: new Date()
          });
          // will be removed after eventer set up
          if (_this2._progressBar) {
            _this2._progressBar.update(_this2._loaded, _this2._totalLoaded, 'load');
          }
        };

        request.onloadend = function (event) {
          // emit 'fetch-end' event
          _this2.emit('fetch-end', {
            file: url,
            time: new Date()
          });
          // just use onload when success and onerror when failure, etc onabort
          // reject(request.statusText);
        };

        request.send();
      });
    }

    /**
     * parse the data loaded
     * SHOULD BE implementd by detail loader.
     * @param {object} response - loaded data.
     * @return {promise} promise.
     */

  }, {
    key: 'parse',
    value: function parse(response) {
      return new Promise(function (resolve, reject) {
        resolve(response);
      });
    }

    /**
     * default load sequence group promise.
     * @param {array} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'loadSequenceGroup',
    value: function loadSequenceGroup(url) {
      var _this3 = this;

      var fetchSequence = [];

      url.forEach(function (file) {
        fetchSequence.push(_this3.fetch(file));
      });

      return Promise.all(fetchSequence).then(function (rawdata) {
        return _this3.parse(rawdata);
      }).then(function (data) {
        _this3._data.push(data);
        return data;
      }).catch(function (error) {
        window.console.log('oops... something went wrong...');
        window.console.log(error);
      });
    }

    /**
     * default load sequence promise.
     * @param {string} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'loadSequence',
    value: function loadSequence(url) {
      var _this4 = this;

      return this.fetch(url).then(function (rawdata) {
        return _this4.parse(rawdata);
      }).then(function (data) {
        _this4._data.push(data);
        return data;
      }).catch(function (error) {
        window.console.log('oops... something went wrong...');
        window.console.log(error);
      });
    }

    /**
     * load the data by url(urls)
     * @param {string|array} url - resource url.
     * @return {promise} promise
     */

  }, {
    key: 'load',
    value: function load(url) {
      var _this5 = this;

      // if we load a single file, convert it to an array
      if (!Array.isArray(url)) {
        url = [url];
      }

      // emit 'load-start' event
      this.emit('load-start', {
        files: url,
        time: new Date()
      });

      var loadSequences = [];
      url.forEach(function (file) {
        if (!Array.isArray(file)) {
          loadSequences.push(_this5.loadSequence(file));
        } else {
          loadSequences.push(_this5.loadSequenceGroup(file));
        }
      });
      return Promise.all(loadSequences);
    }

    /**
     * Set data
     * @param {array} data
     */

  }, {
    key: 'data',
    set: function set(data) {
      this._data = data;
    }

    /**
     * Get data
     * @return {array} data loaded
     */

    , get: function get() {
      return this._data;
    }
  }]);

  return LoadersBase;
}(_events2.default);

exports.default = LoadersBase;

},{"../helpers/helpers.progressbar":117,"events":26}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loaders = require('./loaders.volume');

var _loaders2 = _interopRequireDefault(_loaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module loaders
 */

exports.default = {
  Volume: _loaders2.default
};

},{"./loaders.volume":129}],129:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _loaders = require('./loaders.base');

var _loaders2 = _interopRequireDefault(_loaders);

var _core = require('../core/core.utils');

var _core2 = _interopRequireDefault(_core);

var _models = require('../models/models.series');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('../models/models.stack');

var _models4 = _interopRequireDefault(_models3);

var _models5 = require('../models/models.frame');

var _models6 = _interopRequireDefault(_models5);

var _parsers = require('../parsers/parsers.dicom');

var _parsers2 = _interopRequireDefault(_parsers);

var _parsers3 = require('../parsers/parsers.mhd');

var _parsers4 = _interopRequireDefault(_parsers3);

var _parsers5 = require('../parsers/parsers.nifti');

var _parsers6 = _interopRequireDefault(_parsers5);

var _parsers7 = require('../parsers/parsers.nrrd');

var _parsers8 = _interopRequireDefault(_parsers7);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/** * Imports ***/
var PAKO = require('pako');

/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/volumes
 * @extends LoadersBase
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
var LoadersVolumes = function (_LoadersBase) {
  _inherits(LoadersVolumes, _LoadersBase);

  function LoadersVolumes() {
    _classCallCheck(this, LoadersVolumes);

    return _possibleConstructorReturn(this, (LoadersVolumes.__proto__ || Object.getPrototypeOf(LoadersVolumes)).apply(this, arguments));
  }

  _createClass(LoadersVolumes, [{
    key: 'parse',

    /**
     * Parse response.
     * response is formated as:
     *    {
     *      url: 'resource url',
     *      buffer: xmlresponse,
     *    }
     * @param {object} response - response
     * @return {promise} promise
     */
    value: function parse(response) {
      var _this2 = this;

      // emit 'parse-start' event
      this.emit('parse-start', {
        file: response.url,
        time: new Date()
      });
      // give a chance to the UI to update because
      // after the rendering will be blocked with intensive JS
      // will be removed after eventer set up
      if (this._progressBar) {
        this._progressBar.update(0, 100, 'parse');
      }

      return new Promise(function (resolve, reject) {
        window.setTimeout(function () {
          resolve(new Promise(function (resolve, reject) {
            var data = response;

            if (!Array.isArray(data)) {
              data = [data];
            }

            data.forEach(function (dataset) {
              _this2._preprocess(dataset);
            });

            if (data.length === 1) {
              data = data[0];
            } else {
              // if raw/mhd pair
              var mhdFile = data.filter(_this2._filterByExtension.bind(null, 'MHD'));
              var rawFile = data.filter(_this2._filterByExtension.bind(null, 'RAW'));
              if (data.length === 2 && mhdFile.length === 1 && rawFile.length === 1) {
                data.url = mhdFile[0].url;
                data.extension = mhdFile[0].extension;
                data.mhdBuffer = mhdFile[0].buffer;
                data.rawBuffer = rawFile[0].buffer;
              }
            }

            var Parser = _this2._parser(data.extension);
            if (!Parser) {
              // emit 'parse-error' event
              _this2.emit('parse-error', {
                file: response.url,
                time: new Date(),
                error: data.filename + 'can not be parsed.'
              });
              reject(data.filename + ' can not be parsed.');
            }

            // check extension
            var volumeParser = null;
            try {
              volumeParser = new Parser(data, 0);
            } catch (e) {
              window.console.log(e);
              // emit 'parse-error' event
              _this2.emit('parse-error', {
                file: response.url,
                time: new Date(),
                error: e
              });
              reject(e);
            }

            // create a series
            var series = new _models2.default();
            // global information
            series.seriesInstanceUID = volumeParser.seriesInstanceUID();
            series.transferSyntaxUID = volumeParser.transferSyntaxUID();
            series.seriesDescription = volumeParser.seriesDescription();
            series.studyDescription = volumeParser.studyDescription();
            series.numberOfFrames = volumeParser.numberOfFrames();
            if (!series.numberOfFrames) {
              series.numberOfFrames = 1;
            }
            series.numberOfChannels = volumeParser.numberOfChannels();
            series.modality = volumeParser.modality();
            // if it is a segmentation, attach extra information
            if (series.modality === 'SEG') {
              // colors
              // labels
              // etc.
              series.segmentationType = volumeParser.segmentationType();
              series.segmentationSegments = volumeParser.segmentationSegments();
            }
            // patient information
            series.patientID = volumeParser.patientID();
            series.patientName = volumeParser.patientName();
            series.patientAge = volumeParser.patientAge();
            series.patientBirthdate = volumeParser.patientBirthdate();
            series.patientSex = volumeParser.patientSex();

            // just create 1 dummy stack for now
            var stack = new _models4.default();
            stack.numberOfChannels = volumeParser.numberOfChannels();
            stack.pixelRepresentation = volumeParser.pixelRepresentation();
            stack.pixelType = volumeParser.pixelType();
            stack.invert = volumeParser.invert();
            stack.spacingBetweenSlices = volumeParser.spacingBetweenSlices();
            stack.modality = series.modality;
            // if it is a segmentation, attach extra information
            if (stack.modality === 'SEG') {
              // colors
              // labels
              // etc.
              stack.segmentationType = series.segmentationType;
              stack.segmentationSegments = series.segmentationSegments;
            }
            series.stack.push(stack);
            // recursive call for each frame
            // better than for loop to be able
            // to update dom with "progress" callback
            setTimeout(_this2.parseFrame(series, stack, response.url, 0, volumeParser, resolve, reject), 0);
          }));
        }, 10);
      });
    }

    /**
     * recursive parse frame
     * @param {ModelsSeries} series - data series
     * @param {ModelsStack} stack - data stack
     * @param {string} url - resource url
     * @param {number} i - frame index
     * @param {parser} dataParser - selected parser
     * @param {promise.resolve} resolve - promise resolve args
     * @param {promise.reject} reject - promise reject args
     */

  }, {
    key: 'parseFrame',
    value: function parseFrame(series, stack, url, i, dataParser, resolve, reject) {
      var frame = new _models6.default();
      frame.sopInstanceUID = dataParser.sopInstanceUID(i);
      frame.url = url;
      frame.index = i;
      frame.rows = dataParser.rows(i);
      frame.columns = dataParser.columns(i);
      frame.numberOfChannels = stack.numberOfChannels;
      frame.pixelRepresentation = stack.pixelRepresentation;
      frame.pixelType = stack.pixelType;
      frame.pixelData = dataParser.extractPixelData(i);
      frame.pixelSpacing = dataParser.pixelSpacing(i);
      frame.spacingBetweenSlices = dataParser.spacingBetweenSlices(i);
      frame.sliceThickness = dataParser.sliceThickness(i);
      frame.imageOrientation = dataParser.imageOrientation(i);
      frame.rightHanded = dataParser.rightHanded();
      stack.rightHanded = frame.rightHanded;
      if (frame.imageOrientation === null) {
        frame.imageOrientation = [1, 0, 0, 0, 1, 0];
      }
      frame.imagePosition = dataParser.imagePosition(i);
      if (frame.imagePosition === null) {
        frame.imagePosition = [0, 0, i];
      }
      frame.dimensionIndexValues = dataParser.dimensionIndexValues(i);
      frame.bitsAllocated = dataParser.bitsAllocated(i);
      frame.instanceNumber = dataParser.instanceNumber(i);
      frame.windowCenter = dataParser.windowCenter(i);
      frame.windowWidth = dataParser.windowWidth(i);
      frame.rescaleSlope = dataParser.rescaleSlope(i);
      frame.rescaleIntercept = dataParser.rescaleIntercept(i);
      // should pass frame index for consistency...
      frame.minMax = dataParser.minMaxPixelData(frame.pixelData);

      // if series.mo
      if (series.modality === 'SEG') {
        frame.referencedSegmentNumber = dataParser.referencedSegmentNumber(i);
      }

      stack.frame.push(frame);

      // update status
      this._parsed = i + 1;
      this._totalParsed = series.numberOfFrames;

      // will be removed after eventer set up
      if (this._progressBar) {
        this._progressBar.update(this._parsed, this._totalParsed, 'parse');
      }

      // emit 'parsing' event
      this.emit('parsing', {
        file: url,
        total: this._totalParsed,
        parsed: this._parsed,
        time: new Date()
      });

      if (this._parsed === this._totalParsed) {
        // emit 'parse-success' event
        this.emit('parse-success', {
          file: url,
          total: this._totalParsed,
          parsed: this._parsed,
          time: new Date()
        });

        resolve(series);
      } else {
        setTimeout(this.parseFrame(series, stack, url, this._parsed, dataParser, resolve, reject), 0);
      }
    }

    /**
     * Return parser given an extension
     * @param {string} extension - extension
     * @return {parser} selected parser
     */

  }, {
    key: '_parser',
    value: function _parser(extension) {
      var Parser = null;

      switch (extension.toUpperCase()) {
        case 'NII':
        case 'NII_':
          Parser = _parsers6.default;
          break;
        case 'DCM':
        case 'DICOM':
        case 'IMA':
        case '':
          Parser = _parsers2.default;
          break;
        case 'MHD':
          Parser = _parsers4.default;
          break;
        case 'NRRD':
          Parser = _parsers8.default;
          break;
        default:
          window.console.log('unsupported extension: ' + extension);
          return false;
      }
      return Parser;
    }

    /**
     * Pre-process data to be parsed (find data type and de-compress)
     * @param {*} data
     */

  }, {
    key: '_preprocess',
    value: function _preprocess(data) {
      var parsedUrl = _core2.default.parseUrl(data.url);
      // update data
      data.filename = parsedUrl.filename;
      data.extension = parsedUrl.extension;
      data.pathname = parsedUrl.pathname;
      data.query = parsedUrl.query;

      // unzip if extension is '.gz'
      if (data.extension === 'gz') {
        data.gzcompressed = true;
        data.extension = data.filename.split('.gz').shift().split('.').pop();
        var decompressedData = PAKO.inflate(data.buffer);
        data.buffer = decompressedData.buffer;
      } else {
        data.gzcompressed = false;
      }
    }

    /**
     * Filter data by extension
     * @param {*} extension
     * @param {*} item
     * @returns Boolean
     */

  }, {
    key: '_filterByExtension',
    value: function _filterByExtension(extension, item) {
      if (item.extension.toUpperCase() === extension.toUpperCase()) {
        return true;
      }
      return false;
    }
  }]);

  return LoadersVolumes;
}(_loaders2.default);

exports.default = LoadersVolumes;

},{"../core/core.utils":105,"../models/models.frame":131,"../models/models.series":133,"../models/models.stack":134,"../parsers/parsers.dicom":136,"../parsers/parsers.mhd":138,"../parsers/parsers.nifti":139,"../parsers/parsers.nrrd":140,"./loaders.base":127,"pako":51}],130:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Base object.
 *
 * @module models/base
 */

var ModelsBase = function () {
  function ModelsBase() {
    _classCallCheck(this, ModelsBase);

    this._id = -1;
  }
  /**
   * Merge 2 arrays of models.
   * Merge the target array into the reference array.
   *
   * @param {Array.<Models>} referenceArray - Array to be merge against
   * @param {Array.<Models>} targetArray - Array to be merged against reference.
   *
   * @return {boolean} True if merge was sucessful. False if something went wrong.
   */

  _createClass(ModelsBase, [{
    key: 'mergeModels',
    value: function mergeModels(referenceArray, targetArray) {
      if (!(this._validateModelArray(referenceArray) && this._validateModelArray(targetArray))) {
        window.console.log('invalid inputs provided.');
        return false;
      }

      for (var i = 0; i < targetArray.length; i++) {
        // test targetArray against existing targetArray
        for (var j = 0; j < referenceArray.length; j++) {
          if (referenceArray[j].merge(targetArray[i])) {
            // merged successfully
            break;
          } else if (j === referenceArray.length - 1) {
            // last merge was not successful
            // this is a new targetArray
            referenceArray.push(targetArray[i]);
          }
        }
      }

      return true;
    }

    /**
     * Merge model against current model.
     */

  }, {
    key: 'merge',
    value: function merge(model) {
      // make sure model is valid
      if (!this.validate(model)) {
        return false;
      }

      // they can be merged if they match
      if (this._id === model._id) {
        return true;
      }
      return false;
    }

    /**
     * Validate a model.
     *
     * @return {boolean} True if model is valid. False if not.
     */

  }, {
    key: 'validate',
    value: function validate(model) {
      if (!(model && model !== null && typeof model.merge === 'function')) {
        return false;
      }

      return true;
    }

    /**
     * Validate array of models.
     *
     * @param {Array.<Models>} modelArray - Array containing models.
     *
     * @return {boolean} True if array is valid. False if not.
     */

  }, {
    key: '_validateModelArray',
    value: function _validateModelArray(modelArray) {
      if (!(modelArray !== null && Array === modelArray.constructor)) {
        window.console.log('invalid model array provided.');
        return false;
      }

      for (var i = 0; i < modelArray.length; i++) {
        if (!(modelArray[i] && modelArray[i] !== null && typeof modelArray[i].validate === 'function' && modelArray[i].validate(modelArray[i]))) {
          return false;
        }
      }

      return true;
    }
  }]);

  return ModelsBase;
}();

exports.default = ModelsBase;

},{}],131:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * Frame object.
 *
 * @module models/frame
 */
var ModelsFrame = function (_ModelsBase) {
  _inherits(ModelsFrame, _ModelsBase);

  /**
   * Constructor
   */
  function ModelsFrame() {
    _classCallCheck(this, ModelsFrame);

    var _this = _possibleConstructorReturn(this, (ModelsFrame.__proto__ || Object.getPrototypeOf(ModelsFrame)).call(this));

    _this._sopInstanceUID = null;
    _this._url = null;
    _this._stackID = -1;
    _this._rows = 0;
    _this._columns = 0;
    _this._dimensionIndexValues = [];
    _this._imagePosition = null;
    _this._imageOrientation = null;
    _this._rightHanded = true;
    _this._sliceThickness = 1;
    _this._spacingBetweenSlices = null;
    _this._pixelRepresentation = 0;
    _this._pixelType = 0;
    _this._pixelSpacing = null;
    _this._pixelAspectRatio = null;
    _this._pixelData = null;

    _this._instanceNumber = null;
    _this._windowCenter = null;
    _this._windowWidth = null;
    _this._rescaleSlope = null;
    _this._rescaleIntercept = null;

    _this._bitsAllocated = 8;

    _this._minMax = null;
    _this._dist = null;

    _this._index = -1;

    _this._referencedSegmentNumber = -1;
    return _this;
  }

  /**
   * Validate the frame.
   *
   * @param {*} model
   *
   * @return {*}
   */

  _createClass(ModelsFrame, [{
    key: 'validate',
    value: function validate(model) {
      if (!(_get(ModelsFrame.prototype.__proto__ || Object.getPrototypeOf(ModelsFrame.prototype), 'validate', this).call(this, model) && typeof model.cosines === 'function' && typeof model.spacingXY === 'function' && model.hasOwnProperty('_sopInstanceUID') && model.hasOwnProperty('_dimensionIndexValues') && model.hasOwnProperty('_imageOrientation') && model.hasOwnProperty('_imagePosition'))) {
        return false;
      }

      return true;
    }

    /**
     * Merge current frame with provided frame.
     *
     * Frames can be merged (i.e. are identical) if following are equals:
     *  - dimensionIndexValues
     *  - imageOrientation
     *  - imagePosition
     *  - instanceNumber
     *  - sopInstanceUID
     *
     * @param {*} frame
     *
     * @return {boolean} True if frames could be merge. False if not.
     */

  }, {
    key: 'merge',
    value: function merge(frame) {
      if (!this.validate(frame)) {
        return false;
      }

      if (this._compareArrays(this._dimensionIndexValues, frame.dimensionIndexValues) && this._compareArrays(this._imageOrientation, frame.imageOrientation) && this._compareArrays(this._imagePosition, frame.imagePosition) && this._instanceNumber === frame.instanceNumber && this._sopInstanceUID === frame.sopInstanceUID) {
        return true;
      } else {
        return false;
      }
    }

    /**
     * Generate X, y and Z cosines from image orientation
     * Returns default orientation if _imageOrientation was invalid.
     *
     * @returns {array} Array[3] containing cosinesX, Y and Z.
     */

  }, {
    key: 'cosines',
    value: function cosines() {
      var cosines = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];

      if (this._imageOrientation && this._imageOrientation.length === 6) {
        var xCos = new THREE.Vector3(this._imageOrientation[0], this._imageOrientation[1], this._imageOrientation[2]);
        var yCos = new THREE.Vector3(this._imageOrientation[3], this._imageOrientation[4], this._imageOrientation[5]);

        if (xCos.length() > 0 && yCos.length() > 0) {
          cosines[0] = xCos;
          cosines[1] = yCos;
          cosines[2] = new THREE.Vector3(0, 0, 0).crossVectors(cosines[0], cosines[1]).normalize();
        }
      } else {
        window.console.log('No valid image orientation for frame');
        window.console.log(this);
        window.console.log('Returning default orientation.');
      }

      if (!this._rightHanded) {
        cosines[2].negate();
      }

      return cosines;
    }

    /**
     * Get x/y spacing of a frame.
     *
     * @return {*}
     */

  }, {
    key: 'spacingXY',
    value: function spacingXY() {
      var spacingXY = [1.0, 1.0];

      if (this.pixelSpacing) {
        spacingXY[0] = this.pixelSpacing[0];

        spacingXY[1] = this.pixelSpacing[1];
      } else if (this.pixelAspectRatio) {
        spacingXY[0] = 1.0;
        spacingXY[1] = 1.0 * this.pixelAspectRatio[1] / this.pixelAspectRatio[0];
      }

      return spacingXY;
    }

    /**
     * Get data value
     *
     * @param {*} column
     * @param {*} row
     *
     * @return {*}
     */

  }, {
    key: 'value',
    value: function value(column, row) {
      return this.pixelData[column + this._columns * row];
    }

    /**
     * Compare 2 arrays.
     *
     * 2 null arrays return true.
     * Do no perform strict type checking.
     *
     * @param {*} reference
     * @param {*} target
     *
     * @return {boolean} True if arrays are identicals. False if not.
     */

  }, {
    key: '_compareArrays',
    value: function _compareArrays(reference, target) {
      // could both be null
      if (reference === target) {
        return true;
      }

      // if not null....
      if (reference && target && reference.join() === target.join()) {
        return true;
      }

      return false;
    }
  }, {
    key: 'rows',
    get: function get() {
      return this._rows;
    },
    set: function set(rows) {
      this._rows = rows;
    }
  }, {
    key: 'columns',
    get: function get() {
      return this._columns;
    },
    set: function set(columns) {
      this._columns = columns;
    }
  }, {
    key: 'spacingBetweenSlices',
    get: function get() {
      return this._spacingBetweenSlices;
    },
    set: function set(spacingBetweenSlices) {
      this._spacingBetweenSlices = spacingBetweenSlices;
    }
  }, {
    key: 'sliceThickness',
    get: function get() {
      return this._sliceThickness;
    },
    set: function set(sliceThickness) {
      this._sliceThickness = sliceThickness;
    }
  }, {
    key: 'imagePosition',
    get: function get() {
      return this._imagePosition;
    },
    set: function set(imagePosition) {
      this._imagePosition = imagePosition;
    }
  }, {
    key: 'imageOrientation',
    get: function get() {
      return this._imageOrientation;
    },
    set: function set(imageOrientation) {
      this._imageOrientation = imageOrientation;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
    }
  }, {
    key: 'bitsAllocated',
    get: function get() {
      return this._bitsAllocated;
    },
    set: function set(bitsAllocated) {
      this._bitsAllocated = bitsAllocated;
    }
  }, {
    key: 'dist',
    get: function get() {
      return this._dist;
    },
    set: function set(dist) {
      this._dist = dist;
    }
  }, {
    key: 'pixelSpacing',
    get: function get() {
      return this._pixelSpacing;
    },
    set: function set(pixelSpacing) {
      this._pixelSpacing = pixelSpacing;
    }
  }, {
    key: 'pixelAspectRatio',
    get: function get() {
      return this._pixelAspectRatio;
    },
    set: function set(pixelAspectRatio) {
      this._pixelAspectRatio = pixelAspectRatio;
    }
  }, {
    key: 'minMax',
    get: function get() {
      return this._minMax;
    },
    set: function set(minMax) {
      this._minMax = minMax;
    }
  }, {
    key: 'dimensionIndexValues',
    get: function get() {
      return this._dimensionIndexValues;
    },
    set: function set(dimensionIndexValues) {
      this._dimensionIndexValues = dimensionIndexValues;
    }
  }, {
    key: 'instanceNumber',
    get: function get() {
      return this._instanceNumber;
    },
    set: function set(instanceNumber) {
      this._instanceNumber = instanceNumber;
    }
  }, {
    key: 'pixelData',
    get: function get() {
      return this._pixelData;
    },
    set: function set(pixelData) {
      this._pixelData = pixelData;
    }
  }, {
    key: 'sopInstanceUID',
    set: function set(sopInstanceUID) {
      this._sopInstanceUID = sopInstanceUID;
    },
    get: function get() {
      return this._sopInstanceUID;
    }
  }, {
    key: 'pixelRepresentation',
    get: function get() {
      return this._pixelRepresentation;
    },
    set: function set(pixelRepresentation) {
      this._pixelRepresentation = pixelRepresentation;
    }
  }, {
    key: 'pixelType',
    get: function get() {
      return this._pixelType;
    },
    set: function set(pixelType) {
      this._pixelType = pixelType;
    }
  }, {
    key: 'url',
    get: function get() {
      return this._url;
    },
    set: function set(url) {
      this._url = url;
    }
  }, {
    key: 'referencedSegmentNumber',
    get: function get() {
      return this._referencedSegmentNumber;
    },
    set: function set(referencedSegmentNumber) {
      this._referencedSegmentNumber = referencedSegmentNumber;
    }
  }, {
    key: 'rightHanded',
    get: function get() {
      return this._rightHanded;
    },
    set: function set(rightHanded) {
      this._rightHanded = rightHanded;
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
    }
  }]);

  return ModelsFrame;
}(_models2.default);

exports.default = ModelsFrame;

},{"../models/models.base":130}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _models = require('./models.frame');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('./models.stack');

var _models4 = _interopRequireDefault(_models3);

var _models5 = require('./models.series');

var _models6 = _interopRequireDefault(_models5);

var _models7 = require('./models.voxel');

var _models8 = _interopRequireDefault(_models7);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module models
 */

exports.default = {
  Frame: _models2.default,
  Stack: _models4.default,
  Series: _models6.default,
  Voxel: _models8.default
};

},{"./models.frame":131,"./models.series":133,"./models.stack":134,"./models.voxel":135}],133:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * Series object.
 *
 * @module models/series
 */
var ModelsSeries = function (_ModelsBase) {
  _inherits(ModelsSeries, _ModelsBase);

  /**
   * Models series constructor
   */
  function ModelsSeries() {
    _classCallCheck(this, ModelsSeries);

    var _this = _possibleConstructorReturn(this, (ModelsSeries.__proto__ || Object.getPrototypeOf(ModelsSeries)).call(this));

    _this._concatenationUID = -1;
    _this._seriesInstanceUID = -1;
    _this._transferSyntaxUID = '';
    _this._seriesNumber = -1;
    _this._seriesDescription = '';
    _this._studyDescription = '';
    _this._modality = 'Modality not set';
    _this._dimensionIndexSequence = [];
    // it is used in the loader in case a dicom/nifti contains multiple frames
    // should be updated after merge or renamed
    _this._numberOfFrames = 0;
    _this._numberOfChannels = 1;

    // patient information
    _this._patientID = '';
    _this._patientName = '';
    _this._patientAge = '';
    _this._patientBirthdate = '';
    _this._patientSex = '';

    // SEGMENTATION STUFF
    _this._segmentationType = null;
    _this._segmentationSegments = [];

    // STACK
    _this._stack = [];
    return _this;
  }

  /**
   * Validate a series.
   *
   * Requirements:
   *   - mergeSeries method
   *   - _seriesInstanceUID
   *   - _numberOfFrames
   *   - _numberOfChannels
   *   _ _stack
   *
   * @param {ModelsSeries} model - Model to be validated as series.
   *
   * @return {boolean} True if series is valid. False if not.
   *
   * @override
   */

  _createClass(ModelsSeries, [{
    key: 'validate',
    value: function validate(model) {
      if (!(_get(ModelsSeries.prototype.__proto__ || Object.getPrototypeOf(ModelsSeries.prototype), 'validate', this).call(this, model) && typeof model.mergeSeries === 'function' && model.hasOwnProperty('_seriesInstanceUID') && model.hasOwnProperty('_numberOfFrames') && model.hasOwnProperty('_numberOfChannels') && model.hasOwnProperty('_stack') && typeof model._stack !== 'undefined' && Array === model._stack.constructor)) {
        return false;
      }

      return true;
    }

    /**
     * Merge current series with provided series.
     * 2 series can ONLY be merge if they have the same SeriesInstanceUID.
     *
     * Also merges the stacks inside a series.
     *
     * @param {ModelsSeries} series - Series to be merged against current series.
     *
     * @return {boolean} True if series could be merge. False if not.
     *
     * @override
     */

  }, {
    key: 'merge',
    value: function merge(series) {
      if (!this.validate(series)) {
        return false;
      }

      if (this._seriesInstanceUID === series.seriesInstanceUID) {
        return this.mergeModels(this._stack, series.stack);
      } else {
        return false;
      }
    }

    /**
     * Merge current series with provided array of series.
     * 2 series can ONLY be merge if they have the same SeriesInstanceUID.
     *
     * Also merges the stacks inside a series.
     *
     * @param {Array.<ModelsSeries>} target - Series to be merged against current series.
     *
     * @return {Array.<ModelsSeries>} Array of series properly merged.
     */

  }, {
    key: 'mergeSeries',
    value: function mergeSeries(target) {
      var seriesContainer = [this];
      this.mergeModels(seriesContainer, target);
      return seriesContainer;
    }

    /**
     * Series instance UID setter
     *
     * @param {*} seriesInstanceUID
     */

  }, {
    key: 'seriesInstanceUID',
    set: function set(seriesInstanceUID) {
      this._seriesInstanceUID = seriesInstanceUID;
    }

    /**
     * Series instace UID getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._seriesInstanceUID;
    }

    /**
     * Transfer syntax UID setter
     *
     * @param {*} transferSyntaxUID
     */

  }, {
    key: 'transferSyntaxUID',
    set: function set(transferSyntaxUID) {
      this._transferSyntaxUID = transferSyntaxUID;
    }

    /**
     * Transfer syntax UID getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._transferSyntaxUID;
    }

    /**
     * Transfer syntax UID getter
     *
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUIDLabel',
    get: function get() {
      switch (this._transferSyntaxUID) {
        case '1.2.840.10008.1.2.4.90':
          return 'JPEG 2000 Lossless';
        case '1.2.840.10008.1.2.4.91':
          return 'JPEG 2000 Lossy';
        case '1.2.840.10008.1.2.4.57':
          return 'JPEG Lossless, Nonhierarchical (Processes 14)';
        case '1.2.840.10008.1.2.4.70':
          return 'JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])';
        case '1.2.840.10008.1.2.4.50':
          return 'JPEG Baseline lossy process 1 (8 bit)';
        case '1.2.840.10008.1.2.4.51':
          return 'JPEG Baseline lossy process 2 & 4 (12 bit)';
        case '1.2.840.10008.1.2':
          return 'Implicit VR Little Endian';
        case '1.2.840.10008.1.2.1':
          return 'Explicit VR Little Endian';
        case '1.2.840.10008.1.2.2':
          return 'Explicit VR Big Endian';
        default:
          return 'Unknown transfersyntax: ' + this._transferSyntaxUID;
      }
    }

    /**
     * Study descripition setter
     *
     * @param {*} studyDescription
     */

  }, {
    key: 'studyDescription',
    set: function set(studyDescription) {
      this._studyDescription = studyDescription;
    }

    /**
     * Study description getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._studyDescription;
    }

    /**
     * Series descripition setter
     *
     * @param {*} seriesDescription
     */

  }, {
    key: 'seriesDescription',
    set: function set(seriesDescription) {
      this._seriesDescription = seriesDescription;
    }

    /**
     * Series description getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._seriesDescription;
    }

    /**
     * Patient ID setter
     *
     * @param {*} patientID
     */

  }, {
    key: 'patientID',
    set: function set(patientID) {
      this._patientID = patientID;
    }

    /**
     * Patient ID getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientID;
    }

    /**
     * Patient name setter
     *
     * @param {*} patientName
     */

  }, {
    key: 'patientName',
    set: function set(patientName) {
      this._patientName = patientName;
    }

    /**
     * Patient name getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientName;
    }

    /**
     * Patient age setter
     *
     * @param {*} patientAge
     */

  }, {
    key: 'patientAge',
    set: function set(patientAge) {
      this._patientAge = patientAge;
    }

    /**
     * Patient age getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientAge;
    }

    /**
     * Patient birthdate setter
     *
     * @param {*} patientBirthdate
     */

  }, {
    key: 'patientBirthdate',
    set: function set(patientBirthdate) {
      this._patientBirthdate = patientBirthdate;
    }

    /**
     * Patient birthdate getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientBirthdate;
    }

    /**
     * Patient sex setter
     *
     * @param {*} patientSex
     */

  }, {
    key: 'patientSex',
    set: function set(patientSex) {
      this._patientSex = patientSex;
    }

    /**
     * Patient sex getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientSex;
    }

    /**
     * Number of frames setter
     *
     * @param {*} numberOfFrames
     */

  }, {
    key: 'numberOfFrames',
    set: function set(numberOfFrames) {
      this._numberOfFrames = numberOfFrames;
    }

    /**
     * Number of frames getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._numberOfFrames;
    }

    /**
     * Number of channels setter
     *
     * @param {*} numberOfChannels
     */

  }, {
    key: 'numberOfChannels',
    set: function set(numberOfChannels) {
      this._numberOfChannels = numberOfChannels;
    }

    /**
     * Number of channels getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._numberOfChannels;
    }
  }, {
    key: 'stack',
    set: function set(stack) {
      this._stack = stack;
    },
    get: function get() {
      return this._stack;
    }
  }, {
    key: 'modality',
    set: function set(modality) {
      this._modality = modality;
    },
    get: function get() {
      return this._modality;
    }
  }, {
    key: 'segmentationType',
    set: function set(segmentationType) {
      this._segmentationType = segmentationType;
    },
    get: function get() {
      return this._segmentationType;
    }
  }, {
    key: 'segmentationSegments',
    set: function set(segmentationSegments) {
      this._segmentationSegments = segmentationSegments;
    },
    get: function get() {
      return this._segmentationSegments;
    }
  }]);

  return ModelsSeries;
}(_models2.default);

exports.default = ModelsSeries;

},{"../models/models.base":130}],134:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core/core.colors');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('../core/core.utils');

var _core4 = _interopRequireDefault(_core3);

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

var binaryString = require('math-float32-to-binary-string');

/**
 * Stack object.
 *
 * @module models/stack
 */

var ModelsStack = function (_ModelsBase) {
  _inherits(ModelsStack, _ModelsBase);

  /**
   * Models Stack constructor
   */
  function ModelsStack() {
    _classCallCheck(this, ModelsStack);

    var _this = _possibleConstructorReturn(this, (ModelsStack.__proto__ || Object.getPrototypeOf(ModelsStack)).call(this));

    _this._uid = null;
    _this._stackID = -1;

    _this._frame = [];
    _this._numberOfFrames = 0;

    _this._rows = 0;
    _this._columns = 0;
    _this._numberOfChannels = 1;
    _this._bitsAllocated = 8;
    _this._pixelType = 0;
    _this._pixelRepresentation = 0;

    _this._textureSize = 4096;
    _this._nbTextures = 7;
    _this._rawData = [];

    _this._windowCenter = 0;
    _this._windowWidth = 0;

    _this._rescaleSlope = 1;
    _this._rescaleIntercept = 0;

    _this._minMax = [65535, -32768];

    // TRANSFORMATION MATRICES
    _this._regMatrix = new THREE.Matrix4();

    _this._ijk2LPS = null;
    _this._lps2IJK = null;

    _this._aabb2LPS = null;
    _this._lps2AABB = null;

    //
    // IJK dimensions
    _this._dimensionsIJK = null;
    _this._halfDimensionsIJK = null;
    _this._spacing = new THREE.Vector3(1, 1, 1);
    _this._spacingBetweenSlices = 0;
    _this._sliceThickness = 0;
    _this._origin = null;
    _this._rightHanded = true;
    _this._xCosine = new THREE.Vector3(1, 0, 0);
    _this._yCosine = new THREE.Vector3(0, 1, 0);
    _this._zCosine = new THREE.Vector3(0, 0, 1);

    // convenience vars
    _this._prepared = false;
    _this._packed = false;
    _this._packedPerPixel = 1;

    //
    _this._modality = 'Modality not set';

    // SEGMENTATION STUFF
    _this._segmentationType = null;
    _this._segmentationSegments = [];
    _this._segmentationDefaultColor = [63, 174, 128];
    _this._frameSegment = [];
    _this._segmentationLUT = [];
    _this._segmentationLUTO = [];

    // photometricInterpretation Monochrome1 VS Monochrome2
    _this._invert = false;
    return _this;
  }

  /**
   * Prepare segmentation stack.
   * A segmentation stack can hold x frames that are at the same location
   * but segmentation specific information:
   * - Frame X contains voxels for segmentation A.
   * - Frame Y contains voxels for segmenttation B.
   * - Frame X and Y are at the same location.
   *
   * We currently merge overlaping frames into 1.
   */

  _createClass(ModelsStack, [{
    key: 'prepareSegmentation',
    value: function prepareSegmentation() {
      // store frame and do special pre-processing
      this._frameSegment = this._frame;
      var mergedFrames = [];

      // order frames
      this.computeCosines();
      this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
      this._frame.sort(this._sortDistanceArraySort);

      // merge frames
      var prevIndex = -1;
      for (var i = 0; i < this._frame.length; i++) {
        if (!mergedFrames[prevIndex] || mergedFrames[prevIndex]._dist != this._frame[i]._dist) {
          mergedFrames.push(this._frame[i]);
          prevIndex++;

          // Scale frame
          // by default each frame contains binary data about a segmentation.
          // we scale it by the referenceSegmentNumber in order to have a
          // segmentation specific voxel value rather than 0 or 1.
          // That allows us to merge frames later on.
          // If we merge frames without scaling, then we can not differenciate
          // voxels from segmentation A or B as the value is 0 or 1 in both cases.
          for (var k = 0; k < mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; k++) {
            mergedFrames[prevIndex]._pixelData[k] *= this._frame[i]._referencedSegmentNumber;
          }
        } else {
          // frame already exsits at this location.
          // merge data from this segmentation into existing frame
          for (var _k = 0; _k < mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; _k++) {
            mergedFrames[prevIndex]._pixelData[_k] += this._frame[i].pixelData[_k] * this._frame[i]._referencedSegmentNumber;
          }
        }

        mergedFrames[prevIndex].minMax = _core4.default.minMax(mergedFrames[prevIndex]._pixelData);
      }

      // get information about segments
      var dict = {};
      var max = 0;
      for (var _i = 0; _i < this._segmentationSegments.length; _i++) {
        max = Math.max(max, parseInt(this._segmentationSegments[_i].segmentNumber, 10));

        var color = this._segmentationSegments[_i].recommendedDisplayCIELab;
        if (color === null) {
          dict[this._segmentationSegments[_i].segmentNumber] = this._segmentationDefaultColor;
        } else {
          dict[this._segmentationSegments[_i].segmentNumber] = _core2.default.cielab2RGB.apply(_core2.default, _toConsumableArray(color));
        }
      }

      // generate LUTs
      for (var _i2 = 0; _i2 <= max; _i2++) {
        var index = _i2 / max;
        var opacity = _i2 ? 1 : 0;
        var rgb = [0, 0, 0];
        if (dict.hasOwnProperty(_i2.toString())) {
          rgb = dict[_i2.toString()];
        }

        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;

        this._segmentationLUT.push([index].concat(_toConsumableArray(rgb)));
        this._segmentationLUTO.push([index, opacity]);
      }

      this._frame = mergedFrames;
    }

    /**
     * Compute cosines
     * Order frames
     * computeSpacing
     * sanityCheck
     * init some vars
     * compute min/max
     * compute transformation matrices
     *
     * @return {*}
     */

  }, {
    key: 'prepare',
    value: function prepare() {
      // if segmentation, merge some frames...
      if (this._modality === 'SEG') {
        this.prepareSegmentation();
      }

      // we need at least 1 frame
      if (this._frame && this._frame.length > 0) {
        this._numberOfFrames = this._frame.length;
      } else {
        window.console.log('_frame doesn\'t contain anything....');
        window.console.log(this._frame);
        return false;
      }

      // pass parameters from frame to stack
      this._rows = this._frame[0].rows;
      this._columns = this._frame[0].columns;
      this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
      this._halfDimensionsIJK = new THREE.Vector3(this._dimensionsIJK.x / 2, this._dimensionsIJK.y / 2, this._dimensionsIJK.z / 2);
      this._spacingBetweenSlices = this._frame[0].spacingBetweenSlices;
      this._sliceThickness = this._frame[0].sliceThickness;

      // compute direction cosines
      this.computeCosines();

      // order the frames
      this.orderFrames();

      // compute/guess spacing
      this.computeSpacing();
      // set extra vars if nulls
      // do it now because before we would think image position/orientation
      // are defined and we would use it to compute spacing.
      if (!this._frame[0].imagePosition) {
        this._frame[0].imagePosition = [0, 0, 0];
      }
      if (!this._frame[0].imageOrientation) {
        this._frame[0].imageOrientation = [1, 0, 0, 0, 1, 0];
      }

      this._origin = this._arrayToVector3(this._frame[0].imagePosition, 0);

      // compute transforms
      this.computeIJK2LPS();

      this.computeLPS2AABB();
      // this.packEchos();

      this._rescaleSlope = this._frame[0].rescaleSlope || 1;
      this._rescaleIntercept = this._frame[0].rescaleIntercept || 0;

      // rescale/slope min max
      this.computeMinMaxIntensities();
      this._minMax[0] = ModelsStack.valueRescaleSlopeIntercept(this._minMax[0], this._rescaleSlope, this._rescaleIntercept);
      this._minMax[1] = ModelsStack.valueRescaleSlopeIntercept(this._minMax[1], this._rescaleSlope, this._rescaleIntercept);

      var width = this._frame[0].windowWidth || this._minMax[1] - this._minMax[0];
      this._windowWidth = this._rescaleSlope * width + this._rescaleIntercept;

      var center = this._frame[0].windowCenter || this._minMax[0] + width / 2;
      this._windowCenter = this._rescaleSlope * center + this._rescaleIntercept;

      this._bitsAllocated = this._frame[0].bitsAllocated;
      this._prepared = true;
    }
  }, {
    key: 'packEchos',
    value: function packEchos() {
      // 4 echo times...
      var echos = 4;
      var packedEcho = [];
      for (var i = 0; i < this._frame.length; i += echos) {
        var frame = this._frame[i];
        for (var k = 0; k < this._rows * this._columns; k++) {
          for (var j = 1; j < echos; j++) {
            frame.pixelData[k] += this._frame[i + j].pixelData[k];
          }
          frame.pixelData[k] /= echos;
        }
        packedEcho.push(frame);
      }
      this._frame = packedEcho;
      this._numberOfFrames = this._frame.length;
      this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
      this._halfDimensionsIJK = new THREE.Vector3(this._dimensionsIJK.x / 2, this._dimensionsIJK.y / 2, this._dimensionsIJK.z / 2);
    }

    // frame.cosines - returns array [x, y, z]

  }, {
    key: 'computeCosines',
    value: function computeCosines() {
      if (this._frame && this._frame[0]) {
        var cosines = this._frame[0].cosines();
        this._xCosine = cosines[0];
        this._yCosine = cosines[1];
        this._zCosine = cosines[2];
      }
    }
  }, {
    key: 'orderFrames',
    value: function orderFrames() {
      // order the frames based on theirs dimension indices
      // first index is the most important.
      // 1,1,1,1 willl be first
      // 1,1,2,1 will be next
      // 1,1,2,3 will be next
      // 1,1,3,1 wil be next
      if (this._frame[0].dimensionIndexValues) {
        this._frame.sort(this._orderFrameOnDimensionIndicesArraySort);

        // else order with image position and orientation
      } else if (this._frame[0].imagePosition && this._frame[0].imageOrientation && this._frame[1] && this._frame[1].imagePosition && this._frame[1].imageOrientation && this._frame[0].imagePosition.join() !== this._frame[1].imagePosition.join()) {
        // compute and sort by dist in this series
        this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
        this._frame.sort(this._sortDistanceArraySort);
      } else if (this._frame[0].instanceNumber !== null && this._frame[1] && this._frame[1].instanceNumber !== null && this._frame[0].instanceNumber !== this._frame[1].instanceNumber) {
        this._frame.sort(this._sortInstanceNumberArraySort);
      } else if (this._frame[0].sopInstanceUID && this._frame[1] && this._frame[1].sopInstanceUID && this._frame[0].sopInstanceUID !== this._frame[1].sopInstanceUID) {
        this._frame.sort(this._sortSopInstanceUIDArraySort);
      } else {
        // window.console.log(this._frame[0]);
        // window.console.log(this._frame[1]);
        // window.console.log(this._frame[0].instanceNumber !== null && true);
        // window.console.log(
        // this._frame[0].instanceNumber !== this._frame[1].instanceNumber);
        window.console.log('do not know how to order the frames...');
        // else slice location
        // image number
        // ORDERING BASED ON instance number
        // _ordering = 'instance_number';
        // first_image.sort(function(a,b){
        // return a["instance_number"]-b["instance_number"]});
      }
    }
  }, {
    key: 'computeSpacing',
    value: function computeSpacing() {
      this.xySpacing();
      this.zSpacing();
    }

    /**
     * Compute stack z spacing
     */

  }, {
    key: 'zSpacing',
    value: function zSpacing() {
      if (this._numberOfFrames > 1) {
        if (this._frame[0].pixelSpacing && this._frame[0].pixelSpacing[2]) {
          this._spacing.z = this._frame[0].pixelSpacing[2];
        } else {
          // compute and sort by dist in this series
          this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));

          // if distances are different, re-sort array
          if (this._frame[1].dist !== this._frame[0].dist) {
            this._frame.sort(this._sortDistanceArraySort);
            this._spacing.z = this._frame[1].dist - this._frame[0].dist;
          } else if (this._spacingBetweenSlices) {
            this._spacing.z = this._spacingBetweenSlices;
          } else if (this._frame[0].sliceThickness) {
            this._spacing.z = this._frame[0].sliceThickness;
          }
        }
      }

      // Spacing
      // can not be 0 if not matrix can not be inverted.
      if (this._spacing.z === 0) {
        this._spacing.z = 1;
      }
    }

    /**
     *  FRAME CAN DO IT
     */

  }, {
    key: 'xySpacing',
    value: function xySpacing() {
      if (this._frame && this._frame[0]) {
        var spacingXY = this._frame[0].spacingXY();
        this._spacing.x = spacingXY[0];
        this._spacing.y = spacingXY[1];
      }
    }

    /**
     * Find min and max intensities among all frames.
     */

  }, {
    key: 'computeMinMaxIntensities',
    value: function computeMinMaxIntensities() {
      // what about colors!!!!?
      for (var i = 0; i < this._frame.length; i++) {
        // get min/max
        this._minMax[0] = Math.min(this._minMax[0], this._frame[i].minMax[0]);
        this._minMax[1] = Math.max(this._minMax[1], this._frame[i].minMax[1]);
      }
    }

    /**
     * Compute IJK to LPS and invert transforms
     */

  }, {
    key: 'computeIJK2LPS',
    value: function computeIJK2LPS() {
      // ijk to lps
      this._ijk2LPS = _core4.default.ijk2LPS(this._xCosine, this._yCosine, this._zCosine, this._spacing, this._origin, this._regMatrix);

      // lps 2 ijk
      this._lps2IJK = new THREE.Matrix4();
      this._lps2IJK.getInverse(this._ijk2LPS);
    }

    /**
     * Compute LPS to AABB and invert transforms
     */

  }, {
    key: 'computeLPS2AABB',
    value: function computeLPS2AABB() {
      this._aabb2LPS = _core4.default.aabb2LPS(this._xCosine, this._yCosine, this._zCosine, this._origin);

      this._lps2AABB = new THREE.Matrix4();
      this._lps2AABB.getInverse(this._aabb2LPS);
    }

    /**
     * Merge stacks
     *
     * @param {*} stack
     *
     * @return {*}
     */

  }, {
    key: 'merge',
    value: function merge(stack) {
      // also make sure x/y/z cosines are a match!
      if (this._stackID === stack.stackID) {
        return this.mergeModels(this._frame, stack.frame);
      } else {
        return false;
      }
    }

    /**
     * Pack current stack pixel data into 8 bits array buffers
     */

  }, {
    key: 'pack',
    value: function pack() {
      // Get total number of voxels
      var nbVoxels = this._dimensionsIJK.x * this._dimensionsIJK.y * this._dimensionsIJK.z;

      // Packing style
      if (this._bitsAllocated === 16 && this._numberOfChannels === 1) {
        this._packedPerPixel = 2;
      }

      // Loop through all the textures we need
      var textureDimension = this._textureSize * this._textureSize;
      var requiredTextures = Math.ceil(nbVoxels / (textureDimension * this._packedPerPixel));
      var voxelIndexStart = 0;
      var voxelIndexStop = this._packedPerPixel * textureDimension;
      if (voxelIndexStop > nbVoxels) {
        voxelIndexStop = nbVoxels;
      }

      for (var ii = 0; ii < requiredTextures; ii++) {
        var packed = this._packTo8Bits(this._numberOfChannels, this._frame, this._textureSize, voxelIndexStart, voxelIndexStop);
        this._textureType = packed.textureType;
        this._rawData.push(packed.data);

        voxelIndexStart += this._packedPerPixel * textureDimension;
        voxelIndexStop += this._packedPerPixel * textureDimension;
        if (voxelIndexStop > nbVoxels) {
          voxelIndexStop = nbVoxels;
        }
      }

      this._packed = true;
    }

    /**
     * Pack frame data to 32 bits texture
     * @param {*} channels
     * @param {*} frame
     * @param {*} textureSize
     * @param {*} startVoxel
     * @param {*} stopVoxel
     */

  }, {
    key: '_packTo8Bits',
    value: function _packTo8Bits(channels, frame, textureSize, startVoxel, stopVoxel) {
      var packed = {
        textureType: null,
        data: null
      };

      var bitsAllocated = frame[0].bitsAllocated;
      var pixelType = frame[0].pixelType;

      // transform signed to unsigned for convenience
      var offset = 0;
      if (this._minMax[0] < 0) {
        offset -= this._minMax[0];
      }

      var packIndex = 0;
      var frameIndex = 0;
      var inFrameIndex = 0;
      // frame should return it!
      var frameDimension = frame[0].rows * frame[0].columns;

      if (bitsAllocated === 8 && channels === 1 || bitsAllocated === 1) {
        var data = new Uint8Array(textureSize * textureSize * 1);
        for (var i = startVoxel; i < stopVoxel; i++) {
          frameIndex = ~~(i / frameDimension);
          inFrameIndex = i % frameDimension;

          data[packIndex] = offset + frame[frameIndex].pixelData[inFrameIndex];
          packIndex++;
        }
        packed.textureType = THREE.LuminanceFormat;
        packed.data = data;
      } else if (bitsAllocated === 16 && channels === 1) {
        var _data = new Uint8Array(textureSize * textureSize * 4);
        var coordinate = 0;
        var channelOffset = 0;

        for (var _i3 = startVoxel; _i3 < stopVoxel; _i3++) {
          frameIndex = ~~(_i3 / frameDimension);
          inFrameIndex = _i3 % frameDimension;

          var raw = offset + frame[frameIndex].pixelData[inFrameIndex];
          _data[4 * coordinate + 2 * channelOffset] = raw & 0x00FF;
          _data[4 * coordinate + 2 * channelOffset + 1] = raw >>> 8 & 0x00FF;

          packIndex++;
          coordinate = Math.floor(packIndex / 2);
          channelOffset = packIndex % 2;
        }

        packed.textureType = THREE.RGBAFormat;
        packed.data = _data;
      } else if (bitsAllocated === 32 && channels === 1 && pixelType === 0) {
        var _data2 = new Uint8Array(textureSize * textureSize * 4);
        for (var _i4 = startVoxel; _i4 < stopVoxel; _i4++) {
          frameIndex = ~~(_i4 / frameDimension);
          inFrameIndex = _i4 % frameDimension;

          var _raw = offset + frame[frameIndex].pixelData[inFrameIndex];
          _data2[4 * packIndex] = _raw & 0x000000FF;
          _data2[4 * packIndex + 1] = _raw >>> 8 & 0x000000FF;
          _data2[4 * packIndex + 2] = _raw >>> 16 & 0x000000FF;
          _data2[4 * packIndex + 3] = _raw >>> 24 & 0x000000FF;

          packIndex++;
        }
        packed.textureType = THREE.RGBAFormat;
        packed.data = _data2;
      } else if (bitsAllocated === 32 && channels === 1 && pixelType === 1) {
        var _data3 = new Uint8Array(textureSize * textureSize * 4);

        for (var _i5 = startVoxel; _i5 < stopVoxel; _i5++) {
          frameIndex = ~~(_i5 / frameDimension);
          inFrameIndex = _i5 % frameDimension;

          var _raw2 = offset + frame[frameIndex].pixelData[inFrameIndex];
          var bitString = binaryString(_raw2);
          var bitStringArray = bitString.match(/.{1,8}/g);

          _data3[4 * packIndex] = parseInt(bitStringArray[0], 2);
          _data3[4 * packIndex + 1] = parseInt(bitStringArray[1], 2);
          _data3[4 * packIndex + 2] = parseInt(bitStringArray[2], 2);
          _data3[4 * packIndex + 3] = parseInt(bitStringArray[3], 2);

          packIndex++;
        }

        packed.textureType = THREE.RGBAFormat;
        packed.data = _data3;
      } else if (bitsAllocated === 8 && channels === 3) {
        var _data4 = new Uint8Array(textureSize * textureSize * 3);

        for (var _i6 = startVoxel; _i6 < stopVoxel; _i6++) {
          frameIndex = ~~(_i6 / frameDimension);
          inFrameIndex = _i6 % frameDimension;

          _data4[3 * packIndex] = frame[frameIndex].pixelData[3 * inFrameIndex];
          _data4[3 * packIndex + 1] = frame[frameIndex].pixelData[3 * inFrameIndex + 1];
          _data4[3 * packIndex + 2] = frame[frameIndex].pixelData[3 * inFrameIndex + 2];
          packIndex++;
        }

        packed.textureType = THREE.RGBFormat;
        packed.data = _data4;
      }

      return packed;
    }

    /**
     * Get the stack world center
     *
     *@return {*}
     */

  }, {
    key: 'worldCenter',
    value: function worldCenter() {
      var center = this._halfDimensionsIJK.clone().addScalar(-0.5).applyMatrix4(this._ijk2LPS);
      return center;
    }

    /**
     * Get the stack world bounding box
     * @return {*}
     */

  }, {
    key: 'worldBoundingBox',
    value: function worldBoundingBox() {
      var bbox = [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE];

      var dims = this._dimensionsIJK;

      for (var i = 0; i <= dims.x; i += dims.x) {
        for (var j = 0; j <= dims.y; j += dims.y) {
          for (var k = 0; k <= dims.z; k += dims.z) {
            var world = new THREE.Vector3(i, j, k).applyMatrix4(this._ijk2LPS);
            bbox = [Math.min(bbox[0], world.x), Math.max(bbox[1], world.x), // x min/max
            Math.min(bbox[2], world.y), Math.max(bbox[3], world.y), Math.min(bbox[4], world.z), Math.max(bbox[5], world.z)];
          }
        }
      }

      return bbox;
    }

    /**
     * Get AABB size in LPS space.
     *
     * @return {*}
     */

  }, {
    key: 'AABBox',
    value: function AABBox() {
      var world0 = new THREE.Vector3().addScalar(-0.5).applyMatrix4(this._ijk2LPS).applyMatrix4(this._lps2AABB);

      var world7 = this._dimensionsIJK.clone().addScalar(-0.5).applyMatrix4(this._ijk2LPS).applyMatrix4(this._lps2AABB);

      var minBBox = new THREE.Vector3(Math.abs(world0.x - world7.x), Math.abs(world0.y - world7.y), Math.abs(world0.z - world7.z));

      return minBBox;
    }

    /**
     * Get AABB center in LPS space
     */

  }, {
    key: 'centerAABBox',
    value: function centerAABBox() {
      var centerBBox = this.worldCenter();
      centerBBox.applyMatrix4(this._lps2AABB);
      return centerBBox;
    }
  }, {
    key: '_arrayToVector3',
    value: function _arrayToVector3(array, index) {
      return new THREE.Vector3(array[index], array[index + 1], array[index + 2]);
    }
  }, {
    key: '_orderFrameOnDimensionIndicesArraySort',
    value: function _orderFrameOnDimensionIndicesArraySort(a, b) {
      if ('dimensionIndexValues' in a && Object.prototype.toString.call(a.dimensionIndexValues) === '[object Array]' && 'dimensionIndexValues' in b && Object.prototype.toString.call(b.dimensionIndexValues) === '[object Array]') {
        for (var i = 0; i < a.dimensionIndexValues.length; i++) {
          if (parseInt(a.dimensionIndexValues[i], 10) > parseInt(b.dimensionIndexValues[i], 10)) {
            return 1;
          }
          if (parseInt(a.dimensionIndexValues[i], 10) < parseInt(b.dimensionIndexValues[i], 10)) {
            return -1;
          }
        }
      } else {
        window.console.log('One of the frames doesn\'t have a dimensionIndexValues array.');
        window.console.log(a);
        window.console.log(b);
      }

      return 0;
    }
  }, {
    key: '_computeDistanceArrayMap',
    value: function _computeDistanceArrayMap(normal, frame) {
      frame.dist = frame.imagePosition[0] * normal.x + frame.imagePosition[1] * normal.y + frame.imagePosition[2] * normal.z;
      return frame;
    }
  }, {
    key: '_sortDistanceArraySort',
    value: function _sortDistanceArraySort(a, b) {
      return a.dist - b.dist;
    }
  }, {
    key: '_sortInstanceNumberArraySort',
    value: function _sortInstanceNumberArraySort(a, b) {
      return a.instanceNumber - b.instanceNumber;
    }
  }, {
    key: '_sortSopInstanceUIDArraySort',
    value: function _sortSopInstanceUIDArraySort(a, b) {
      return a.sopInstanceUID - b.sopInstanceUID;
    }
  }, {
    key: 'numberOfChannels',
    set: function set(numberOfChannels) {
      this._numberOfChannels = numberOfChannels;
    },
    get: function get() {
      return this._numberOfChannels;
    }
  }, {
    key: 'frame',
    set: function set(frame) {
      this._frame = frame;
    },
    get: function get() {
      return this._frame;
    }
  }, {
    key: 'prepared',
    set: function set(prepared) {
      this._prepared = prepared;
    },
    get: function get() {
      return this._prepared;
    }
  }, {
    key: 'packed',
    set: function set(packed) {
      this._packed = packed;
    },
    get: function get() {
      return this._packed;
    }
  }, {
    key: 'packedPerPixel',
    set: function set(packedPerPixel) {
      this._packedPerPixel = packedPerPixel;
    },
    get: function get() {
      return this._packedPerPixel;
    }
  }, {
    key: 'dimensionsIJK',
    set: function set(dimensionsIJK) {
      this._dimensionsIJK = dimensionsIJK;
    },
    get: function get() {
      return this._dimensionsIJK;
    }
  }, {
    key: 'halfDimensionsIJK',
    set: function set(halfDimensionsIJK) {
      this._halfDimensionsIJK = halfDimensionsIJK;
    },
    get: function get() {
      return this._halfDimensionsIJK;
    }
  }, {
    key: 'regMatrix',
    set: function set(regMatrix) {
      this._regMatrix = regMatrix;
    },
    get: function get() {
      return this._regMatrix;
    }
  }, {
    key: 'ijk2LPS',
    set: function set(ijk2LPS) {
      this._ijk2LPS = ijk2LPS;
    },
    get: function get() {
      return this._ijk2LPS;
    }
  }, {
    key: 'lps2IJK',
    set: function set(lps2IJK) {
      this._lps2IJK = lps2IJK;
    },
    get: function get() {
      return this._lps2IJK;
    }
  }, {
    key: 'lps2AABB',
    set: function set(lps2AABB) {
      this._lps2AABB = lps2AABB;
    },
    get: function get() {
      return this._lps2AABB;
    }
  }, {
    key: 'textureSize',
    set: function set(textureSize) {
      this._textureSize = textureSize;
    },
    get: function get() {
      return this._textureSize;
    }
  }, {
    key: 'textureType',
    set: function set(textureType) {
      this._textureType = textureType;
    },
    get: function get() {
      return this._textureType;
    }
  }, {
    key: 'bitsAllocated',
    set: function set(bitsAllocated) {
      this._bitsAllocated = bitsAllocated;
    },
    get: function get() {
      return this._bitsAllocated;
    }
  }, {
    key: 'rawData',
    set: function set(rawData) {
      this._rawData = rawData;
    },
    get: function get() {
      return this._rawData;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
    }
  }, {
    key: 'xCosine',
    get: function get() {
      return this._xCosine;
    },
    set: function set(xCosine) {
      this._xCosine = xCosine;
    }
  }, {
    key: 'yCosine',
    get: function get() {
      return this._yCosine;
    },
    set: function set(yCosine) {
      this._yCosine = yCosine;
    }
  }, {
    key: 'zCosine',
    get: function get() {
      return this._zCosine;
    },
    set: function set(zCosine) {
      this._zCosine = zCosine;
    }
  }, {
    key: 'minMax',
    get: function get() {
      return this._minMax;
    },
    set: function set(minMax) {
      this._minMax = minMax;
    }
  }, {
    key: 'stackID',
    get: function get() {
      return this._stackID;
    },
    set: function set(stackID) {
      this._stackID = stackID;
    }
  }, {
    key: 'pixelType',
    get: function get() {
      return this._pixelType;
    },
    set: function set(pixelType) {
      this._pixelType = pixelType;
    }
  }, {
    key: 'pixelRepresentation',
    get: function get() {
      return this._pixelRepresentation;
    },
    set: function set(pixelRepresentation) {
      this._pixelRepresentation = pixelRepresentation;
    }
  }, {
    key: 'invert',
    set: function set(invert) {
      this._invert = invert;
    },
    get: function get() {
      return this._invert;
    }
  }, {
    key: 'modality',
    set: function set(modality) {
      this._modality = modality;
    },
    get: function get() {
      return this._modality;
    }
  }, {
    key: 'rightHanded',
    get: function get() {
      return this._rightHanded;
    },
    set: function set(rightHanded) {
      this._rightHanded = rightHanded;
    }
  }, {
    key: 'spacingBetweenSlices',
    get: function get() {
      return this._spacingBetweenSlices;
    },
    set: function set(spacingBetweenSlices) {
      this._spacingBetweenSlices = spacingBetweenSlices;
    }
  }, {
    key: 'segmentationSegments',
    set: function set(segmentationSegments) {
      this._segmentationSegments = segmentationSegments;
    },
    get: function get() {
      return this._segmentationSegments;
    }
  }, {
    key: 'segmentationType',
    set: function set(segmentationType) {
      this._segmentationType = segmentationType;
    },
    get: function get() {
      return this._segmentationType;
    }
  }, {
    key: 'segmentationLUT',
    set: function set(segmentationLUT) {
      this._segmentationLUT = segmentationLUT;
    },
    get: function get() {
      return this._segmentationLUT;
    }
  }, {
    key: 'segmentationLUTO',
    set: function set(segmentationLUTO) {
      this._segmentationLUTO = segmentationLUTO;
    },
    get: function get() {
      return this._segmentationLUTO;
    }

    // DEPRECATED FUNCTION

    /**
     * @deprecated for core.utils.value
     *
     * Get voxel value.
     *
     * @param {*} stack
     * @param {*} coordinate
     *
     * @return {*}
     */

  }], [{
    key: 'indexInDimensions',
    value: function indexInDimensions(index, dimensions) {
      if (index.x >= 0 && index.y >= 0 && index.z >= 0 && index.x < dimensions.x && index.y < dimensions.y && index.z < dimensions.z) {
        return true;
      }

      return false;
    }
  }, {
    key: 'value',
    value: function value(stack, coordinate) {
      console.warn('models.stack.value is deprecated.\n       Please use core.utils.value instead.');
      return _core4.default.value(stack, coordinate);
    }

    /**
     * @deprecated for core.utils.rescaleSlopeIntercept
     *
     * Apply slope/intercept to a value.
     *
     * @param {*} value
     * @param {*} slope
     * @param {*} intercept
     *
     * @return {*}
     */

  }, {
    key: 'valueRescaleSlopeIntercept',
    value: function valueRescaleSlopeIntercept(value, slope, intercept) {
      console.warn('models.stack.valueRescaleSlopeIntercept is deprecated.\n       Please use core.utils.rescaleSlopeIntercept instead.');
      return _core4.default.rescaleSlopeIntercept(value, slope, intercept);
    }

    /**
     * @deprecated for core.utils.worldToData
     *
     * Transform coordinates from world coordinate to data
     *
     * @param {*} stack
     * @param {*} worldCoordinates
     *
     * @return {*}
     */

  }, {
    key: 'worldToData',
    value: function worldToData(stack, worldCoordinates) {
      console.warn('models.stack.worldToData is deprecated.\n       Please use core.utils.worldToData instead.');

      return _core4.default.worldToData(stack._lps2IJK, worldCoordinates);
    }
  }]);

  return ModelsStack;
}(_models2.default);

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }


exports.default = ModelsStack;

},{"../core/core.colors":101,"../core/core.utils":105,"../models/models.base":130,"math-float32-to-binary-string":43}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module models/voxel
 */

var ModelsVoxel = function () {
  function ModelsVoxel() {
    _classCallCheck(this, ModelsVoxel);

    this._id = -1;
    this._worldCoordinates = null;
    this._dataCoordinates = null;
    this._screenCoordinates = null;
    this._value = null;
  }

  _createClass(ModelsVoxel, [{
    key: "worldCoordinates",
    set: function set(worldCoordinates) {
      this._worldCoordinates = worldCoordinates;
    },
    get: function get() {
      return this._worldCoordinates;
    }
  }, {
    key: "dataCoordinates",
    set: function set(dataCoordinates) {
      this._dataCoordinates = dataCoordinates;
    },
    get: function get() {
      return this._dataCoordinates;
    }
  }, {
    key: "screenCoordinates",
    set: function set(screenCoordinates) {
      this._screenCoordinates = screenCoordinates;
    },
    get: function get() {
      return this._screenCoordinates;
    }
  }, {
    key: "value",
    set: function set(value) {
      this._value = value;
    },
    get: function get() {
      return this._value;
    }
  }, {
    key: "id",
    set: function set(id) {
      this._id = id;
    },
    get: function get() {
      return this._id;
    }
  }]);

  return ModelsVoxel;
}();

exports.default = ModelsVoxel;

},{}],136:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

/** * Imports ***/

var DicomParser = require('dicom-parser');
var Jpeg = require('jpeg-lossless-decoder-js');
var JpegBaseline = require('../../external/scripts/jpeg');
var Jpx = require('../../external/scripts/jpx');

/**
 * Dicom parser is a combination of utilities to get a VJS image from dicom files.
 *scripts
 * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.
 *
 * @module parsers/dicom
 *
 * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which
 * VJS.parsers.dicom can pull the data from.
 */

var ParsersDicom = function (_ParsersVolume) {
  _inherits(ParsersDicom, _ParsersVolume);

  function ParsersDicom(data, id) {
    _classCallCheck(this, ParsersDicom);

    var _this = _possibleConstructorReturn(this, (ParsersDicom.__proto__ || Object.getPrototypeOf(ParsersDicom)).call(this));

    _this._id = id;

    _this._arrayBuffer = data.buffer;

    var byteArray = new Uint8Array(_this._arrayBuffer);

    // catch error
    // throw error if any!
    _this._dataSet = null;

    try {
      _this._dataSet = DicomParser.parseDicom(byteArray);
    } catch (e) {
      window.console.log(e);
      throw 'parsers.dicom could not parse the file';
    }
    return _this;
  }

  // image/frame specific


  _createClass(ParsersDicom, [{
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      return this._dataSet.string('x0020000e');
    }
  }, {
    key: 'studyInstanceUID',
    value: function studyInstanceUID() {
      return this._dataSet.string('x0020000d');
    }
  }, {
    key: 'modality',
    value: function modality() {
      return this._dataSet.string('x00080060');
    }
  }, {
    key: 'segmentationType',
    value: function segmentationType() {
      return this._dataSet.string('x00620001');
    }
  }, {
    key: 'segmentationSegments',
    value: function segmentationSegments() {
      var segmentationSegments = [];
      var segmentSequence = this._dataSet.elements.x00620002;

      if (!segmentSequence) {
        return segmentationSegments;
      }

      for (var i = 0; i < segmentSequence.items.length; i++) {
        var recommendedDisplayCIELab = this._recommendedDisplayCIELab(segmentSequence.items[i]);
        var segmentationCode = this._segmentationCode(segmentSequence.items[i]);
        var segmentNumber = segmentSequence.items[i].dataSet.uint16('x00620004');
        var segmentLabel = segmentSequence.items[i].dataSet.string('x00620005');
        var segmentAlgorithmType = segmentSequence.items[i].dataSet.string('x00620008');

        segmentationSegments.push({
          recommendedDisplayCIELab: recommendedDisplayCIELab,
          segmentationCodeDesignator: segmentationCode['segmentationCodeDesignator'],
          segmentationCodeValue: segmentationCode['segmentationCodeValue'],
          segmentationCodeMeaning: segmentationCode['segmentationCodeMeaning'],
          segmentNumber: segmentNumber,
          segmentLabel: segmentLabel,
          segmentAlgorithmType: segmentAlgorithmType
        });
      }

      return segmentationSegments;
    }
  }, {
    key: '_segmentationCode',
    value: function _segmentationCode(segment) {
      var segmentationCodeDesignator = 'unknown';
      var segmentationCodeValue = 'unknown';
      var segmentationCodeMeaning = 'unknown';
      var element = segment.dataSet.elements.x00082218;

      if (element && element.items && element.items.length > 0) {
        segmentationCodeDesignator = element.items[0].dataSet.string('x00080102');
        segmentationCodeValue = element.items[0].dataSet.string('x00080100');
        segmentationCodeMeaning = element.items[0].dataSet.string('x00080104');
      }

      return {
        segmentationCodeDesignator: segmentationCodeDesignator,
        segmentationCodeValue: segmentationCodeValue,
        segmentationCodeMeaning: segmentationCodeMeaning
      };
    }
  }, {
    key: '_recommendedDisplayCIELab',
    value: function _recommendedDisplayCIELab(segment) {
      if (!segment.dataSet.elements.x0062000d) {
        return null;
      }

      var offset = segment.dataSet.elements.x0062000d.dataOffset;
      var length = segment.dataSet.elements.x0062000d.length;
      var byteArray = segment.dataSet.byteArray.slice(offset, offset + length);

      // https://www.dabsoft.ch/dicom/3/C.10.7.1.1/
      var CIELabScaled = new Uint16Array(length / 2);
      for (var i = 0; i < length / 2; i++) {
        CIELabScaled[i] = (byteArray[2 * i + 1] << 8) + byteArray[2 * i];
      }

      var CIELabNormalized = [CIELabScaled[0] / 65535 * 100, CIELabScaled[1] / 65535 * 255 - 128, CIELabScaled[2] / 65535 * 255 - 128];

      return CIELabNormalized;
    }

    /**
     * SOP Instance UID
     *
     * @param {*} frameIndex
     *
     * @return {*}
     */

  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var sopInstanceUID = this._findStringEverywhere('x2005140f', 'x00080018', frameIndex);
      return sopInstanceUID;
    }

    /**
     * Transfer syntax UID
     *
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUID',
    value: function transferSyntaxUID() {
      return this._dataSet.string('x00020010');
    }

    /**
     * Study description
     *
     * @return {*}
     */

  }, {
    key: 'studyDescription',
    value: function studyDescription() {
      return this._dataSet.string('x00081030');
    }

    /**
     * Series description
     *
     * @return {*}
     */

  }, {
    key: 'seriesDescription',
    value: function seriesDescription() {
      return this._dataSet.string('x0008103e');
    }

    /**
     * Patient name
     *
     * @return {*}
     */

  }, {
    key: 'patientName',
    value: function patientName() {
      return this._dataSet.string('x00100010');
    }

    /**
     * Patient ID
     *
     * @return {*}
     */

  }, {
    key: 'patientID',
    value: function patientID() {
      return this._dataSet.string('x00100020');
    }

    /**
     * Patient birthdate
     *
     * @return {*}
     */

  }, {
    key: 'patientBirthdate',
    value: function patientBirthdate() {
      return this._dataSet.string('x00100030');
    }

    /**
     * Patient sex
     *
     * @return {*}
     */

  }, {
    key: 'patientSex',
    value: function patientSex() {
      return this._dataSet.string('x00100040');
    }

    /**
     * Patient age
     *
     * @return {*}
     */

  }, {
    key: 'patientAge',
    value: function patientAge() {
      return this._dataSet.string('x00101010');
    }

    /**
     * Photometric interpretation
     *
     * @return {*}
     */

  }, {
    key: 'photometricInterpretation',
    value: function photometricInterpretation() {
      return this._dataSet.string('x00280004');
    }
  }, {
    key: 'planarConfiguration',
    value: function planarConfiguration() {
      var planarConfiguration = this._dataSet.uint16('x00280006');

      if (typeof planarConfiguration === 'undefined') {
        planarConfiguration = null;
      }

      return planarConfiguration;
    }
  }, {
    key: 'samplesPerPixel',
    value: function samplesPerPixel() {
      return this._dataSet.uint16('x00280002');
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      var numberOfFrames = this._dataSet.intString('x00280008');

      // need something smarter!
      if (typeof numberOfFrames === 'undefined') {
        numberOfFrames = null;
      }

      return numberOfFrames;
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;
      var photometricInterpretation = this.photometricInterpretation();

      if (!(photometricInterpretation !== 'RGB' && photometricInterpretation !== 'PALETTE COLOR' && photometricInterpretation !== 'YBR_FULL' && photometricInterpretation !== 'YBR_FULL_422' && photometricInterpretation !== 'YBR_PARTIAL_422' && photometricInterpretation !== 'YBR_PARTIAL_420' && photometricInterpretation !== 'YBR_RCT')) {
        numberOfChannels = 3;
      }

      // make sure we return a number! (not a string!)
      return numberOfChannels;
    }
  }, {
    key: 'invert',
    value: function invert() {
      var photometricInterpretation = this.photometricInterpretation();

      return photometricInterpretation === 'MONOCHROME1' ? true : false;
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var imageOrientation = this._findStringEverywhere('x00209116', 'x00200037', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      if (imageOrientation) {
        // make sure we return a number! (not a string!)
        // might not need to split (floatString + index)
        imageOrientation = imageOrientation.split('\\').map(Number);
      }

      return imageOrientation;
    }
  }, {
    key: 'referencedSegmentNumber',
    value: function referencedSegmentNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var referencedSegmentNumber = -1;
      var referencedSegmentNumberElement = this._findInGroupSequence('x52009230', 'x0062000a', frameIndex);

      if (referencedSegmentNumberElement !== null) {
        referencedSegmentNumber = referencedSegmentNumberElement.uint16('x0062000b');
      }

      return referencedSegmentNumber;
    }
  }, {
    key: 'pixelAspectRatio',
    value: function pixelAspectRatio() {
      var pixelAspectRatio = [this._dataSet.intString('x00280034', 0), this._dataSet.intString('x00280034', 1)];

      // need something smarter!
      if (typeof pixelAspectRatio[0] === 'undefined') {
        pixelAspectRatio = null;
      }

      // make sure we return a number! (not a string!)
      return pixelAspectRatio;
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var imagePosition = this._findStringEverywhere('x00209113', 'x00200032', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      if (imagePosition) {
        // make sure we return a number! (not a string!)
        imagePosition = imagePosition.split('\\').map(Number);
      }

      return imagePosition;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var instanceNumber = null;
      // first look for frame!
      // per frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        if (perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x2005140f) {
          var planeOrientationSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;
          instanceNumber = planeOrientationSequence.intString('x00200013');
        } else {
          instanceNumber = this._dataSet.intString('x00200013');

          if (typeof instanceNumber === 'undefined') {
            instanceNumber = null;
          }
        }
      } else {
        // should we default to undefined??
        // default orientation
        instanceNumber = this._dataSet.intString('x00200013');

        if (typeof instanceNumber === 'undefined') {
          instanceNumber = null;
        }
      }

      return instanceNumber;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var pixelSpacing = this._findStringEverywhere('x00289110', 'x00280030', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      // should we default to undefined??
      if (pixelSpacing) {
        // make sure we return array of numbers! (not strings!)
        pixelSpacing = pixelSpacing.split('\\').map(Number);
      }

      return pixelSpacing;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var rows = this._dataSet.uint16('x00280010');

      if (typeof rows === 'undefined') {
        rows = null;
        // print warning at least...
      }

      return rows;
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var columns = this._dataSet.uint16('x00280011');

      if (typeof columns === 'undefined') {
        columns = null;
        // print warning at least...
      }

      return columns;
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 integer, 1 float
      // dicom only support integers
      return 0;
    }
  }, {
    key: 'pixelRepresentation',
    value: function pixelRepresentation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var pixelRepresentation = this._dataSet.uint16('x00280103');
      return pixelRepresentation;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var bitsAllocated = this._dataSet.uint16('x00280100');
      return bitsAllocated;
    }
  }, {
    key: 'highBit',
    value: function highBit() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var highBit = this._dataSet.uint16('x00280102');
      return highBit;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289145', 'x00281052', frameIndex);
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289145', 'x00281053', frameIndex);
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289132', 'x00281050', frameIndex);
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289132', 'x00281051', frameIndex);
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289110', 'x00180050', frameIndex);
    }
  }, {
    key: 'spacingBetweenSlices',
    value: function spacingBetweenSlices() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var spacing = this._dataSet.intString('x00180088');

      if (typeof spacing === 'undefined') {
        spacing = null;
      }

      return spacing;
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var dimensionIndexValues = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        var frameContentSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111;
        if (frameContentSequence !== undefined && frameContentSequence !== null) {
          frameContentSequence = frameContentSequence.items[0].dataSet;
          var dimensionIndexValuesElt = frameContentSequence.elements.x00209157;
          if (dimensionIndexValuesElt !== undefined && dimensionIndexValuesElt !== null) {
            // /4 because UL
            var nbValues = dimensionIndexValuesElt.length / 4;
            dimensionIndexValues = [];

            for (var i = 0; i < nbValues; i++) {
              dimensionIndexValues.push(frameContentSequence.uint32('x00209157', i));
            }
          }
        }
      }

      return dimensionIndexValues;
    }
  }, {
    key: 'inStackPositionNumber',
    value: function inStackPositionNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var inStackPositionNumber = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        // NOT A PHILIPS TRICK!
        var philipsPrivateSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;
        inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');
      } else {
        inStackPositionNumber = null;
      }

      console.log('instack position ' + inStackPositionNumber);

      return inStackPositionNumber;
    }
  }, {
    key: 'stackID',
    value: function stackID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var stackID = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        // NOT A PHILIPS TRICK!
        var philipsPrivateSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;
        stackID = philipsPrivateSequence.intString('x00209056');
      } else {
        stackID = null;
      }

      return stackID;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // decompress
      var decompressedData = this._decodePixelData(frameIndex);

      var numberOfChannels = this.numberOfChannels();

      if (numberOfChannels > 1) {
        return this._convertColorSpace(decompressedData);
      } else {
        return decompressedData;
      }
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;

      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }

    //
    // private methods
    //

  }, {
    key: '_findInGroupSequence',
    value: function _findInGroupSequence(sequence, subsequence, index) {
      var functionalGroupSequence = this._dataSet.elements[sequence];

      if (typeof functionalGroupSequence !== 'undefined') {
        var inSequence = functionalGroupSequence.items[index].dataSet.elements[subsequence];

        if (typeof inSequence !== 'undefined') {
          return inSequence.items[0].dataSet;
        }
      }

      return null;
    }
  }, {
    key: '_findStringInGroupSequence',
    value: function _findStringInGroupSequence(sequence, subsequence, tag, index) {
      // index = 0 if shared!!!
      var dataSet = this._findInGroupSequence(sequence, subsequence, index);

      if (dataSet !== null) {
        return dataSet.string(tag);
      }

      return null;
    }
  }, {
    key: '_findStringInFrameGroupSequence',
    value: function _findStringInFrameGroupSequence(subsequence, tag, index) {
      return this._findStringInGroupSequence('x52009229', subsequence, tag, 0) || this._findStringInGroupSequence('x52009230', subsequence, tag, index);
    }
  }, {
    key: '_findStringEverywhere',
    value: function _findStringEverywhere(subsequence, tag, index) {
      var targetString = this._findStringInFrameGroupSequence(subsequence, tag, index);

      if (targetString === null) {
        targetString = this._dataSet.string(tag);
      }

      if (typeof targetString === 'undefined') {
        targetString = null;
      }

      return targetString;
    }
  }, {
    key: '_findFloatStringInGroupSequence',
    value: function _findFloatStringInGroupSequence(sequence, subsequence, tag, index) {
      var dataInGroupSequence = this._dataSet.floatString(tag);

      // try to get it from enhanced MR images
      // per-frame functionnal group
      if (typeof dataInGroupSequence === 'undefined') {
        dataInGroupSequence = this._findInGroupSequence(sequence, subsequence, index);

        if (dataInGroupSequence !== null) {
          return dataInGroupSequence.floatString(tag);
        } else {
          return null;
        }
      }

      return dataInGroupSequence;
    }
  }, {
    key: '_findFloatStringInFrameGroupSequence',
    value: function _findFloatStringInFrameGroupSequence(subsequence, tag, index) {
      return this._findFloatStringInGroupSequence('x52009229', subsequence, tag, 0) || this._findFloatStringInGroupSequence('x52009230', subsequence, tag, index);
    }
  }, {
    key: '_decodePixelData',
    value: function _decodePixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // if compressed..?
      var transferSyntaxUID = this.transferSyntaxUID();

      // find compression scheme
      if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||
      // JPEG 2000 Lossless
      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {
        // JPEG 2000 Lossy
        return this._decodeJ2K(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.4.57' ||
      // JPEG Lossless, Nonhierarchical (Processes 14)
      transferSyntaxUID === '1.2.840.10008.1.2.4.70') {
        // JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])
        return this._decodeJPEGLossless(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.4.50' ||
      // JPEG Baseline lossy process 1 (8 bit)
      transferSyntaxUID === '1.2.840.10008.1.2.4.51') {
        // JPEG Baseline lossy process 2 & 4 (12 bit)
        return this._decodeJPEGBaseline(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2' ||
      // Implicit VR Little Endian
      transferSyntaxUID === '1.2.840.10008.1.2.1') {
        // Explicit VR Little Endian
        return this._decodeUncompressed(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.2') {
        // Explicit VR Big Endian
        var frame = this._decodeUncompressed(frameIndex);
        // and sawp it!
        return this._swapFrame(frame);
      } else {
        throw {
          error: 'no decoder for transfer syntax ' + transferSyntaxUID
        };
      }
    }
  }, {
    key: '_decodeJ2K',
    value: function _decodeJ2K() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      // let pixelDataElement = this._dataSet.elements.x7fe00010;
      // let pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);
      var jpxImage = new Jpx();
      // https://github.com/OHIF/image-JPEG2000/issues/6
      // It currently returns either Int16 or Uint16 based on whether the codestream is signed or not.
      jpxImage.parse(encodedPixelData);

      // let j2kWidth = jpxImage.width;
      // let j2kHeight = jpxImage.height;

      var componentsCount = jpxImage.componentsCount;
      if (componentsCount !== 1) {
        throw 'JPEG2000 decoder returned a componentCount of ${componentsCount}, when 1 is expected';
      }
      var tileCount = jpxImage.tiles.length;

      if (tileCount !== 1) {
        throw 'JPEG2000 decoder returned a tileCount of ${tileCount}, when 1 is expected';
      }

      var tileComponents = jpxImage.tiles[0];
      var pixelData = tileComponents.items;

      // window.console.log(j2kWidth, j2kHeight);

      return pixelData;
    }

    // from cornerstone

  }, {
    key: '_decodeJPEGLossless',
    value: function _decodeJPEGLossless() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      var pixelRepresentation = this.pixelRepresentation(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var byteOutput = bitsAllocated <= 8 ? 1 : 2;
      var decoder = new Jpeg.lossless.Decoder();
      var decompressedData = decoder.decode(encodedPixelData.buffer, encodedPixelData.byteOffset, encodedPixelData.length, byteOutput);

      if (pixelRepresentation === 0) {
        if (byteOutput === 2) {
          return new Uint16Array(decompressedData.buffer);
        } else {
          // untested!
          return new Uint8Array(decompressedData.buffer);
        }
      } else {
        return new Int16Array(decompressedData.buffer);
      }
    }
  }, {
    key: '_decodeJPEGBaseline',
    value: function _decodeJPEGBaseline() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      var rows = this.rows(frameIndex);
      var columns = this.columns(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var jpegBaseline = new JpegBaseline();
      jpegBaseline.parse(encodedPixelData);

      if (bitsAllocated === 8) {
        return jpegBaseline.getData(columns, rows);
      } else if (bitsAllocated === 16) {
        return jpegBaseline.getData16(columns, rows);
      }
    }
  }, {
    key: '_decodeUncompressed',
    value: function _decodeUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var pixelRepresentation = this.pixelRepresentation(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var pixelDataElement = this._dataSet.elements.x7fe00010;
      var pixelDataOffset = pixelDataElement.dataOffset;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      var frameOffset = 0;
      var buffer = this._dataSet.byteArray.buffer;

      if (pixelRepresentation === 0 && bitsAllocated === 8) {
        // unsigned 8 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 16) {
        // unsigned 16 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 1 && bitsAllocated === 16) {
        // signed 16 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 32) {
        // unsigned 32 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 4;
        return new Uint32Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 1) {
        var newBuffer = new ArrayBuffer(numPixels);
        var newArray = new Uint8Array(newBuffer);

        frameOffset = pixelDataOffset + frameIndex * numPixels;
        var index = 0;

        var bitStart = frameIndex * numPixels;
        var bitEnd = frameIndex * numPixels + numPixels;

        var byteStart = Math.floor(bitStart / 8);
        var bitStartOffset = bitStart - byteStart * 8;
        var byteEnd = Math.ceil(bitEnd / 8);

        var targetBuffer = new Uint8Array(buffer, pixelDataOffset);

        for (var i = byteStart; i <= byteEnd; i++) {
          while (bitStartOffset < 8) {
            switch (bitStartOffset) {
              case 0:
                newArray[index] = targetBuffer[i] & 0x0001;
                break;
              case 1:
                newArray[index] = targetBuffer[i] >>> 1 & 0x0001;
                break;
              case 2:
                newArray[index] = targetBuffer[i] >>> 2 & 0x0001;
                break;
              case 3:
                newArray[index] = targetBuffer[i] >>> 3 & 0x0001;
                break;
              case 4:
                newArray[index] = targetBuffer[i] >>> 4 & 0x0001;
                break;
              case 5:
                newArray[index] = targetBuffer[i] >>> 5 & 0x0001;
                break;
              case 6:
                newArray[index] = targetBuffer[i] >>> 6 & 0x0001;
                break;
              case 7:
                newArray[index] = targetBuffer[i] >>> 7 & 0x0001;
                break;
              default:
                break;
            }

            bitStartOffset++;
            index++;
            // if return..
            if (index >= numPixels) {
              return newArray;
            }
          }
          bitStartOffset = 0;
        }
      }
    }
  }, {
    key: '_convertColorSpace',
    value: function _convertColorSpace(uncompressedData) {
      var rgbData = null;
      var photometricInterpretation = this.photometricInterpretation();
      var planarConfiguration = this.planarConfiguration();

      if (photometricInterpretation === 'RGB' && planarConfiguration === 0) {
        // ALL GOOD, ALREADY ORDERED
        // planar or non planar planarConfiguration
        rgbData = uncompressedData;
      } else if (photometricInterpretation === 'RGB' && planarConfiguration === 1) {
        if (uncompressedData instanceof Int8Array) {
          rgbData = new Int8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint8Array) {
          rgbData = new Uint8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Int16Array) {
          rgbData = new Int16Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint16Array) {
          rgbData = new Uint16Array(uncompressedData.length);
        } else {
          throw 'unsuported typed array: ${uncompressedData}';
        }

        var numPixels = uncompressedData.length / 3;
        var rgbaIndex = 0;
        var rIndex = 0;
        var gIndex = numPixels;
        var bIndex = numPixels * 2;
        for (var i = 0; i < numPixels; i++) {
          rgbData[rgbaIndex++] = uncompressedData[rIndex++]; // red
          rgbData[rgbaIndex++] = uncompressedData[gIndex++]; // green
          rgbData[rgbaIndex++] = uncompressedData[bIndex++]; // blue
        }
      } else if (photometricInterpretation === 'YBR_FULL') {
        if (uncompressedData instanceof Int8Array) {
          rgbData = new Int8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint8Array) {
          rgbData = new Uint8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Int16Array) {
          rgbData = new Int16Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint16Array) {
          rgbData = new Uint16Array(uncompressedData.length);
        } else {
          throw 'unsuported typed array: ${uncompressedData}';
        }

        // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js
        var nPixels = uncompressedData.length / 3;
        var ybrIndex = 0;
        var _rgbaIndex = 0;
        for (var _i = 0; _i < nPixels; _i++) {
          var y = uncompressedData[ybrIndex++];
          var cb = uncompressedData[ybrIndex++];
          var cr = uncompressedData[ybrIndex++];
          rgbData[_rgbaIndex++] = y + 1.40200 * (cr - 128); // red
          rgbData[_rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green
          rgbData[_rgbaIndex++] = y + 1.77200 * (cb - 128); // blue
          // rgbData[rgbaIndex++] = 255; //alpha
        }
      } else {
        throw 'photometric interpolation not supported: ${photometricInterpretation}';
      }

      return rgbData;
    }

    /**
     * Swap bytes in frame.
     */

  }, {
    key: '_swapFrame',
    value: function _swapFrame(frame) {
      // swap bytes ( if 8bits (1byte), nothing to swap)
      var bitsAllocated = this.bitsAllocated();

      if (bitsAllocated === 16) {
        for (var i = 0; i < frame.length; i++) {
          frame[i] = this._swap16(frame[i]);
        }
      } else if (bitsAllocated === 32) {
        for (var _i2 = 0; _i2 < frame.length; _i2++) {
          frame[_i2] = this._swap32(frame[_i2]);
        }
      }

      return frame;
    }
  }]);

  return ParsersDicom;
}(_parsers2.default);

// VJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {
//   // try to access frame of reference UID through its DICOM tag
//   let seriesNumber = imageJqueryDom.find('[tag="00200052"] Value').text();

//   // if not available, assume we only have 1 frame
//   if (seriesNumber === '') {
//     seriesNumber = 1;
//   }
//   return seriesNumber;
// };

//
// ENDIAN NESS NOT TAKEN CARE OF
// http://stackoverflow.com/questions/5320439/how-do-i-swap-endian-ness-byte-order-of-a-letiable-in-javascript
// http://www.barre.nom.fr/medical/samples/
//
//


exports.default = ParsersDicom;

},{"../../external/scripts/jpeg":1,"../../external/scripts/jpx":2,"./parsers.volume":141,"dicom-parser":25,"jpeg-lossless-decoder-js":35}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parsers = require('./parsers.dicom');

var _parsers2 = _interopRequireDefault(_parsers);

var _parsers3 = require('./parsers.nifti');

var _parsers4 = _interopRequireDefault(_parsers3);

var _parsers5 = require('./parsers.nrrd');

var _parsers6 = _interopRequireDefault(_parsers5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module parsers
 */

exports.default = {
  Dicom: _parsers2.default,
  Nifti: _parsers4.default,
  Nrrd: _parsers6.default
};

},{"./parsers.dicom":136,"./parsers.nifti":139,"./parsers.nrrd":140}],138:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * @module parsers/mhd
 */
var ParsersMHD = function (_ParsersVolume) {
  _inherits(ParsersMHD, _ParsersVolume);

  function ParsersMHD(data, id) {
    _classCallCheck(this, ParsersMHD);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersMHD.__proto__ || Object.getPrototypeOf(ParsersMHD)).call(this));

    _this._id = id;
    _this._url = data.url;
    _this._header = {};
    _this._buffer = null;

    try {
      // parse header (mhd) data
      var lines = new TextDecoder().decode(data.mhdBuffer).split('\n');
      lines.forEach(function (line) {
        var keyvalue = line.split('=');
        if (keyvalue.length === 2) {
          _this._header[keyvalue[0].trim()] = keyvalue[1].trim();
        }
      });

      _this._header.DimSize = _this._header.DimSize.split(' ');
      _this._header.ElementSpacing = _this._header.ElementSpacing.split(' ');
      _this._header.TransformMatrix = _this._header.TransformMatrix.split(' ');
      _this._header.Offset = _this._header.Offset.split(' ');
      //
      _this._buffer = data.rawBuffer;
    } catch (error) {
      window.console.log('ooops... :(');
    }
    return _this;
  }

  _createClass(ParsersMHD, [{
    key: 'rightHanded',
    value: function rightHanded() {
      var anatomicalOrientation = this._header.AnatomicalOrientation;
      if (anatomicalOrientation === 'RAS' || anatomicalOrientation === 'RPI' || anatomicalOrientation === 'LPS' || anatomicalOrientation === 'LAI') {
        this._rightHanded = true;
      } else {
        this._rightHanded = false;
      }

      return this._rightHanded;
    }
  }, {
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return parseInt(this._header.DimSize[2], 10);
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return parseInt(this._header.DimSize[1], 10);
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return parseInt(this._header.DimSize[0], 10);
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 - int
      // 1 - float
      return 0;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var bitsAllocated = 1;

      if (this._header.ElementType === 'MET_UCHAR' || this._header.ElementType === 'MET_CHAR') {
        bitsAllocated = 8;
      } else if (this._header.ElementType === 'MET_USHORT' || this._header.ElementType === 'MET_SHORT') {
        bitsAllocated = 16;
      } else if (this._header.ElementType === 'MET_UFLOAT' || this._header.ElementType === 'MET_FLOAT') {
        bitsAllocated = 32;
      }

      return bitsAllocated;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var x = parseFloat(this._header.ElementSpacing[0], 10);
      var y = parseFloat(this._header.ElementSpacing[1], 10);
      var z = parseFloat(this._header.ElementSpacing[2], 10);
      return [x, y, z];
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var invertX = this._header.AnatomicalOrientation.match(/L/) ? -1 : 1;
      var invertY = this._header.AnatomicalOrientation.match(/P/) ? -1 : 1;

      var x = new THREE.Vector3(parseFloat(this._header.TransformMatrix[0]) * invertX, parseFloat(this._header.TransformMatrix[1]) * invertY, parseFloat(this._header.TransformMatrix[2]));
      x.normalize();

      var y = new THREE.Vector3(parseFloat(this._header.TransformMatrix[3]) * invertX, parseFloat(this._header.TransformMatrix[4]) * invertY, parseFloat(this._header.TransformMatrix[5]));
      y.normalize();

      return [x.x, x.y, x.z, y.x, y.y, y.z];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [parseFloat(this._header.Offset[0]), parseFloat(this._header.Offset[1]), parseFloat(this._header.Offset[2])];
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var buffer = this._buffer;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      if (!this.rightHanded()) {
        frameIndex = this.numberOfFrames() - 1 - frameIndex;
      }
      var frameOffset = frameIndex * numPixels;

      if (this._header.ElementType === 'MET_CHAR') {
        frameOffset = frameOffset;
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_UCHAR') {
        frameOffset = frameOffset;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_SHORT') {
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_USHORT') {
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_FLOAT') {
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      }
    }
  }]);

  return ParsersMHD;
}(_parsers2.default);

exports.default = ParsersMHD;

},{"./parsers.volume":141}],139:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // use nifti-js and just parse header.???

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

// http://brainder.org/2012/09/23/the-nifti-file-format/

/** * Imports ***/

var NiftiReader = require('nifti-reader-js');
/**
 * @module parsers/nifti
 */

var ParsersNifti = function (_ParsersVolume) {
  _inherits(ParsersNifti, _ParsersVolume);

  function ParsersNifti(data, id) {
    _classCallCheck(this, ParsersNifti);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersNifti.__proto__ || Object.getPrototypeOf(ParsersNifti)).call(this));

    _this._id = id;
    _this._arrayBuffer = data.buffer;
    _this._url = data.url;
    _this._dataSet = null;
    _this._niftiHeader = null;
    _this._niftiImage = null;
    _this._ordered = true;
    _this._orderedData = null;

    //
    _this._qfac = 1.0;

    if (NiftiReader.isNIFTI(_this._arrayBuffer)) {
      _this._dataSet = NiftiReader.readHeader(_this._arrayBuffer);
      _this._niftiImage = NiftiReader.readImage(_this._dataSet, _this._arrayBuffer);
    } else {
      throw 'parsers.nifti could not parse the file';
    }
    return _this;
  }

  _createClass(ParsersNifti, [{
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return this._dataSet.dims[3];
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;

      // can dims[0] >= 5 and not multi channels with RGB datatypecode?

      if (this._dataSet.dims[0] >= 5) {
        numberOfChannels = this._dataSet.dims[5];
        this._ordered = false;
      } else if (this._dataSet.datatypeCode === 128) {
        numberOfChannels = 3;
      } else if (this._dataSet.datatypeCode === 2304) {
        numberOfChannels = 4;
      }

      return numberOfChannels;
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.dims[2];
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.dims[1];
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // papaya.volume.nifti.NIFTI_TYPE_UINT8           = 2;
      // papaya.volume.nifti.NIFTI_TYPE_INT16           = 4;
      // papaya.volume.nifti.NIFTI_TYPE_INT32           = 8;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT32        = 16;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX64      = 32;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT64        = 64;
      // papaya.volume.nifti.NIFTI_TYPE_RGB24         = 128;
      // papaya.volume.nifti.NIFTI_TYPE_INT8          = 256;
      // papaya.volume.nifti.NIFTI_TYPE_UINT16        = 512;
      // papaya.volume.nifti.NIFTI_TYPE_UINT32        = 768;
      // papaya.volume.nifti.NIFTI_TYPE_INT64        = 1024;
      // papaya.volume.nifti.NIFTI_TYPE_UINT64       = 1280;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT128     = 1536;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX128   = 1792;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX256   = 2048;

      // 0 integer, 1 float

      var pixelType = 0;
      if (this._dataSet.datatypeCode === 16 || this._dataSet.datatypeCode === 64 || this._dataSet.datatypeCode === 1536) {
        pixelType = 1;
      }
      return pixelType;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.numBitsPerVoxel;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [this._dataSet.pixDims[1], this._dataSet.pixDims[2], this._dataSet.pixDims[3]];
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      // should be a string...
      return null; // this._dataSet.pixDims[3].toString();
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // window.console.log(this._dataSet);
      // http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
      // http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c
      if (this._dataSet.qform_code > 0) {
        // https://github.com/Kitware/ITK/blob/master/Modules/IO/NIFTI/src/itkNiftiImageIO.cxx
        var a = 0.0;
        var b = this._dataSet.quatern_b;
        var c = this._dataSet.quatern_c;
        var d = this._dataSet.quatern_d;
        // compute a
        a = 1.0 - (b * b + c * c + d * d);
        if (a < 0.0000001) {
          /* special case */

          a = 1.0 / Math.sqrt(b * b + c * c + d * d);
          b *= a;c *= a;d *= a; /* normalize (b,c,d) vector */
          a = 0.0; /* a = 0 ==> 180 degree rotation */
        } else {
          a = Math.sqrt(a); /* angle = 2*arccos(a) */
        }

        if (this._dataSet.pixDims[0] < 0.0) {
          this._rightHanded = false;
        }

        return [-(a * a + b * b - c * c - d * d), -2 * (b * c + a * d), 2 * (b * d - a * c), -2 * (b * c - a * d), -(a * a + c * c - b * b - d * d), 2 * (c * d + a * b)];
      } else if (this._dataSet.sform_code > 0) {
        console.log('sform > 0');

        var sx = this._dataSet.srow_x;
        var sy = this._dataSet.srow_y;
        var sz = this._dataSet.srow_z;
        // fill IJKToRAS
        // goog.vec.Mat4.setRowValues(IJKToRAS, 0, sx[0], sx[1], sx[2], sx[3]);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 1, sy[0], sy[1], sy[2], sy[3]);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 2, sz[0], sz[1], sz[2], sz[3]);
      } else if (this._dataSet.qform_code === 0) {
        console.log('qform === 0');

        // fill IJKToRAS
        // goog.vec.Mat4.setRowValues(IJKToRAS, 0, MRI.pixdim[1], 0, 0, 0);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 1, 0, MRI.pixdim[2], 0, 0);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 2, 0, 0, MRI.pixdim[3], 0);
      }
      return [1, 0, 0, 0, 1, 0];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // qoffset is RAS
      return [-this._dataSet.qoffset_x, -this._dataSet.qoffset_y, this._dataSet.qoffset_z];
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.scl_slope;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.scl_intercept;
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
      // let buffer = this._dataSet.imageData;
      // if (this._dataSet.compressed) {
      // let buffer = this._dataSet.rawData[0];
      // try {
      //   let data = pako.inflate(new Uint8Array(buffer));
      //   buffer = data.buffer;
      // } catch (err) {
      //   console.log(err);
      // }

      // window.console.log(buffer);
      // }

      // is it compressed?
      // yes/no

      //     try {
      //   var result = pako.inflate(compressed);
      // } catch (err) {
      //   console.log(err);
      // }

      // window.console.log(this);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // papaya.volume.nifti.NIFTI_TYPE_UINT8           = 2;
      // papaya.volume.nifti.NIFTI_TYPE_INT16           = 4;
      // papaya.volume.nifti.NIFTI_TYPE_INT32           = 8;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT32        = 16;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX64      = 32;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT64        = 64;
      // papaya.volume.nifti.NIFTI_TYPE_RGB24         = 128;
      // papaya.volume.nifti.NIFTI_TYPE_INT8          = 256;
      // papaya.volume.nifti.NIFTI_TYPE_UINT16        = 512;
      // papaya.volume.nifti.NIFTI_TYPE_UINT32        = 768;
      // papaya.volume.nifti.NIFTI_TYPE_INT64        = 1024;
      // papaya.volume.nifti.NIFTI_TYPE_UINT64       = 1280;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT128     = 1536;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX128   = 1792;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX256   = 2048;

      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      // if( !this.rightHanded() ){
      //   frameIndex = this.numberOfFrames() - 1 - frameIndex;
      // }
      var frameOffset = frameIndex * numPixels;
      var buffer = this._niftiImage;

      // use bits allocated && pixel reprensentation too
      if (!this._ordered && this._orderedData === null) {
        // order then
        this._reorderData();
      }

      if (this._orderedData !== null) {
        // just a slice...
        return this._orderedData.slice(frameOffset, frameOffset + numPixels);
      } else if (this._dataSet.datatypeCode === 2) {
        // unsigned int 8 bit
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 256) {
        // signed int 8 bit
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 512) {
        // unsigned int 16 bit
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 4) {
        // signed int 16 bit
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 8) {
        // signed int 32 bit
        frameOffset = frameOffset * 4;
        return new Int32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 16) {
        // signed float 32 bit
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      } else {
        console.log('Unknown data type: datatypeCode : ' + this._dataSet.datatypeCode);
      }
    }
  }, {
    key: '_reorderData',
    value: function _reorderData() {
      window.console.log('re-order');
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows() * this.columns() * numberOfChannels;
      var buffer = this._niftiImage;

      var totalNumPixels = numPixels * this.numberOfFrames();
      var tmp = null;
      this._orderedData = null;

      if (this._dataSet.datatypeCode === 2) {
        // unsigned 8 bit
        tmp = new Uint8Array(buffer, 0, totalNumPixels);
        this._orderedData = new Uint8Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 256) {
        // signed 8 bit
        tmp = new Int8Array(buffer, 0, totalNumPixels);
        this._orderedData = new Int8Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 512) {
        tmp = new Uint16Array(buffer, 0, totalNumPixels);
        this._orderedData = new Uint16Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 4) {
        tmp = new Int16Array(buffer, 0, totalNumPixels);
        this._orderedData = new Int16Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 16) {
        tmp = new Float32Array(buffer, 0, totalNumPixels);
        this._orderedData = new Float32Array(tmp.length);
      }

      // re-order pixels...
      var numPixels2 = tmp.length / 3;
      var rgbaIndex = 0;
      var rIndex = 0;
      var gIndex = numPixels2;
      var bIndex = numPixels2 * 2;

      for (var i = 0; i < numPixels2; i++) {
        this._orderedData[rgbaIndex++] = tmp[rIndex++]; // red
        this._orderedData[rgbaIndex++] = tmp[gIndex++]; // green
        this._orderedData[rgbaIndex++] = tmp[bIndex++]; // blue
      }

      this._ordered = true;
    }
  }]);

  return ParsersNifti;
}(_parsers2.default);

exports.default = ParsersNifti;

},{"./parsers.volume":141,"nifti-reader-js":46}],140:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // use nifti-js and just parse header.???

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

// http://brainder.org/2012/09/23/the-nifti-file-format/

/** * Imports ***/

var pako = require('pako');
var NrrdReader = require('nrrd-js');
/**
 * @module parsers/nifti
 */

var ParsersNifti = function (_ParsersVolume) {
  _inherits(ParsersNifti, _ParsersVolume);

  function ParsersNifti(data, id) {
    _classCallCheck(this, ParsersNifti);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersNifti.__proto__ || Object.getPrototypeOf(ParsersNifti)).call(this));

    _this._id = id;
    _this._arrayBuffer = data.buffer;
    _this._url = data.url;
    _this._dataSet = null;
    _this._unpackedData = null;

    try {
      _this._dataSet = NrrdReader.parse(_this._arrayBuffer);
      console.log(_this._dataSet);
    } catch (error) {
      window.console.log('ooops... :(');
    }

    window.console.log(_this._dataSet);
    return _this;
  }

  _createClass(ParsersNifti, [{
    key: 'rightHanded',
    value: function rightHanded() {
      if (this._dataSet.space.match(/^right-anterior-superior/) || this._dataSet.space.match(/^left-posterior-superior/)) {
        this._rightHanded = true;
      } else {
        this._rightHanded = false;
      }

      return this._rightHanded;
    }
  }, {
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return this._dataSet.sizes[2];
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;
      return numberOfChannels;
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.sizes[1];
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.sizes[0];
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 - int
      // 1 - float
      var pixelType = 0;
      if (this._dataSet.type === 'float') {
        pixelType = 1;
      }
      return pixelType;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var bitsAllocated = 1;

      if (this._dataSet.type === 'int8' || this._dataSet.type === 'uint8' || this._dataSet.type === 'char') {
        bitsAllocated = 8;
      } else if (this._dataSet.type === 'int16' || this._dataSet.type === 'uint16' || this._dataSet.type === 'short') {
        bitsAllocated = 16;
      } else if (this._dataSet.type === 'int32' || this._dataSet.type === 'uint32' || this._dataSet.type === 'float') {
        bitsAllocated = 32;
      }

      return bitsAllocated;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var x = new THREE.Vector3(this._dataSet.spaceDirections[0][0], this._dataSet.spaceDirections[0][1], this._dataSet.spaceDirections[0][2]);

      var y = new THREE.Vector3(this._dataSet.spaceDirections[1][0], this._dataSet.spaceDirections[1][1], this._dataSet.spaceDirections[1][2]);

      var z = new THREE.Vector3(this._dataSet.spaceDirections[2][0], this._dataSet.spaceDirections[2][1], this._dataSet.spaceDirections[2][2]);

      return [x.length(), y.length(), z.length()];
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      // should be a string...
      return null; // this._dataSet.pixDims[3].toString();
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var invertX = this._dataSet.space.match(/right/) ? -1 : 1;
      var invertY = this._dataSet.space.match(/anterior/) ? -1 : 1;

      var x = new THREE.Vector3(this._dataSet.spaceDirections[0][0] * invertX, this._dataSet.spaceDirections[0][1] * invertY, this._dataSet.spaceDirections[0][2]);
      x.normalize();

      var y = new THREE.Vector3(this._dataSet.spaceDirections[1][0] * invertX, this._dataSet.spaceDirections[1][1] * invertY, this._dataSet.spaceDirections[1][2]);
      y.normalize();

      return [x.x, x.y, x.z, y.x, y.y, y.z];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [this._dataSet.spaceOrigin[0], this._dataSet.spaceOrigin[1], this._dataSet.spaceOrigin[2]];
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 1; // this._dataSet.scl_slope;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 0; // this._dataSet.scl_intercept;
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var buffer = this._dataSet.buffer;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      if (!this.rightHanded()) {
        frameIndex = this.numberOfFrames() - 1 - frameIndex;
      }
      var frameOffset = frameIndex * numPixels;

      // unpack data if needed
      if (this._unpackedData === null && this._dataSet.encoding === 'gzip') {
        var unpackedData = pako.inflate(this._dataSet.buffer);
        this._unpackedData = unpackedData.buffer;
        buffer = this._unpackedData;
      } else if (this._dataSet.encoding === 'gzip') {
        buffer = this._unpackedData;
      }

      if (this._dataSet.type === 'int8' || this._dataSet.type === 'char') {
        frameOffset = frameOffset;
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint8') {
        frameOffset = frameOffset;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'int16' || this._dataSet.type === 'short') {
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint16') {
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'int32') {
        frameOffset = frameOffset * 4;
        return new Int32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint32') {
        frameOffset = frameOffset * 4;
        return new Uint32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'float') {
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      }
    }
  }]);

  return ParsersNifti;
}(_parsers2.default);

exports.default = ParsersNifti;

},{"./parsers.volume":141,"nrrd-js":50,"pako":51}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module parsers/volume
 */
var ParsersVolume = function () {
  function ParsersVolume() {
    _classCallCheck(this, ParsersVolume);

    this._rightHanded = true;
  }

  _createClass(ParsersVolume, [{
    key: 'pixelRepresentation',
    value: function pixelRepresentation() {
      return 0;
    }
  }, {
    key: 'modality',
    value: function modality() {
      return 'unknown';
    }
  }, {
    key: 'segmentationType',
    value: function segmentationType() {
      return 'unknown';
    }
  }, {
    key: 'segmentationSegments',
    value: function segmentationSegments() {
      return [];
    }
  }, {
    key: 'referencedSegmentNumber',
    value: function referencedSegmentNumber(frameIndex) {
      return -1;
    }
  }, {
    key: 'rightHanded',
    value: function rightHanded() {
      return this._rightHanded;
    }
  }, {
    key: 'spacingBetweenSlices',
    value: function spacingBetweenSlices() {
      return null;
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      return 1;
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      return null;
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 1;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 0;
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {}

    // http://stackoverflow.com/questions/5320439/how-do-i-swap-endian-ness-byte-order-of-a-variable-in-javascript

  }, {
    key: '_swap16',
    value: function _swap16(val) {
      return (val & 0xFF) << 8 | val >> 8 & 0xFF;
    }
  }, {
    key: '_swap32',
    value: function _swap32(val) {
      return (val & 0xFF) << 24 | (val & 0xFF00) << 8 | val >> 8 & 0xFF00 | val >> 24 & 0xFF;
    }
  }, {
    key: 'invert',
    value: function invert() {
      return false;
    }

    /**
     * Get the transfer syntax UID.
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUID',
    value: function transferSyntaxUID() {
      return 'no value provided';
    }

    /**
     * Get the study desciption.
     * @return {*}
     */

  }, {
    key: 'studyDescription',
    value: function studyDescription() {
      return 'no value provided';
    }

    /**
     * Get the series desciption.
     * @return {*}
     */

  }, {
    key: 'seriesDescription',
    value: function seriesDescription() {
      return 'no value provided';
    }

    /**
     * Get the patient ID.
     * @return {*}
     */

  }, {
    key: 'patientID',
    value: function patientID() {
      return 'no value provided';
    }

    /**
     * Get the patient name.
     * @return {*}
     */

  }, {
    key: 'patientName',
    value: function patientName() {
      return 'no value provided';
    }

    /**
     * Get the patient age.
     * @return {*}
     */

  }, {
    key: 'patientAge',
    value: function patientAge() {
      return 'no value provided';
    }

    /**
     * Get the patient birthdate.
     * @return {*}
     */

  }, {
    key: 'patientBirthdate',
    value: function patientBirthdate() {
      return 'no value provided';
    }

    /**
     * Get the patient sex.
     * @return {*}
     */

  }, {
    key: 'patientSex',
    value: function patientSex() {
      return 'no value provided';
    }
  }]);

  return ParsersVolume;
}();

exports.default = ParsersVolume;

},{}],142:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var IntersectBox = function (_ShadersBase) {
  _inherits(IntersectBox, _ShadersBase);

  function IntersectBox() {
    _classCallCheck(this, IntersectBox);

    var _this = _possibleConstructorReturn(this, (IntersectBox.__proto__ || Object.getPrototypeOf(IntersectBox)).call(this));

    _this.name = 'intersectBox';

    // default properties names
    _this._rayOrigin = 'rayOrigin';
    _this._rayDirection = 'rayDirection';
    _this._aabbMin = 'aabbMin';
    _this._aabbMax = 'aabbMax';
    _this._tNear = 'tNear';
    _this._tFar = 'tFar';
    _this._intersect = 'intersect';
    return _this;
  }

  _createClass(IntersectBox, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var rayOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._rayOrigin;
      var rayDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._rayDirection;
      var aabbMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._aabbMin;
      var aabbMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._aabbMax;
      var tNear = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this._tNear;
      var tFar = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._tFar;
      var intersect = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this._intersect;

      this._base = baseFragment;
      return this.compute(rayOrigin, rayDirection, aabbMin, aabbMax, tNear, tFar, intersect);
    }
  }, {
    key: 'compute',
    value: function compute(rayOrigin, rayDirection, aabbMin, aabbMax, tNear, tFar, intersect) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + rayOrigin + ', ' + rayDirection + ', ' + aabbMin + ', ' + aabbMax + ', ' + tNear + ', ' + tFar + ', ' + intersect + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(vec3 rayOrigin, vec3 rayDirection, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar, out bool intersect){\n  // compute intersection of ray with all six bbox planes\n  vec3 invRay = vec3(1.) / rayDirection;\n  vec3 tBot = invRay * (boxMin - rayOrigin);\n  vec3 tTop = invRay * (boxMax - rayOrigin);\n  // re-order intersections to find smallest and largest on each axis\n  vec3 tMin = min(tTop, tBot);\n  vec3 tMax = max(tTop, tBot);\n  // find the largest tMin and the smallest tMax\n  float largest_tMin = max(max(tMin.x, tMin.y), max(tMin.x, tMin.z));\n  float smallest_tMax = min(min(tMax.x, tMax.y), min(tMax.x, tMax.z));\n  tNear = largest_tMin;\n  tFar = smallest_tMax;\n  intersect = smallest_tMax > largest_tMin;\n}\n\n    ';
    }
  }]);

  return IntersectBox;
}(_shaders2.default);

exports.default = new IntersectBox();

},{"../shaders.base":148}],143:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Texture3d = function (_ShadersBase) {
  _inherits(Texture3d, _ShadersBase);

  function Texture3d() {
    _classCallCheck(this, Texture3d);

    var _this = _possibleConstructorReturn(this, (Texture3d.__proto__ || Object.getPrototypeOf(Texture3d)).call(this));

    _this.name = 'texture3d';

    // default properties names
    _this._dataCoordinates = 'dataCoordinates';
    _this._dataValue = 'dataValue';
    _this._offset = 'offset';
    return _this;
  }

  _createClass(Texture3d, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var dataCoordinates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._dataCoordinates;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;
      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._offset;

      this._base = baseFragment;
      return this.compute(dataCoordinates, dataValue, offset);
    }
  }, {
    key: 'compute',
    value: function compute(dataCoordinates, dataValue, offset) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + dataCoordinates + ', ' + dataValue + ', ' + offset + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in ivec3 dataCoordinates, out vec4 dataValue, out int offset){\n    \n  int index = dataCoordinates.x\n            + dataCoordinates.y * uDataDimensions.x\n            + dataCoordinates.z * uDataDimensions.y * uDataDimensions.x;\n  int indexP = int(index/uPackedPerPixel);\n  offset = index - 2*indexP;\n\n  // Map data index to right sampler2D texture\n  int voxelsPerTexture = uTextureSize*uTextureSize;\n  int textureIndex = int(floor(float(indexP) / float(voxelsPerTexture)));\n  // modulo seems incorrect sometimes...\n  // int inTextureIndex = int(mod(float(index), float(textureSize*textureSize)));\n  int inTextureIndex = indexP - voxelsPerTexture*textureIndex;\n\n  // Get row and column in the texture\n  int colIndex = int(mod(float(inTextureIndex), float(uTextureSize)));\n  int rowIndex = int(floor(float(inTextureIndex)/float(uTextureSize)));\n\n  // Map row and column to uv\n  vec2 uv = vec2(0,0);\n  uv.x = (0.5 + float(colIndex)) / float(uTextureSize);\n  uv.y = 1. - (0.5 + float(rowIndex)) / float(uTextureSize);\n\n  //\n  if(textureIndex == 0){ dataValue = texture2D(uTextureContainer[0], uv); }\n  else if(textureIndex == 1){dataValue = texture2D(uTextureContainer[1], uv);}\n  else if(textureIndex == 2){ dataValue = texture2D(uTextureContainer[2], uv); }\n  else if(textureIndex == 3){ dataValue = texture2D(uTextureContainer[3], uv); }\n  else if(textureIndex == 4){ dataValue = texture2D(uTextureContainer[4], uv); }\n  else if(textureIndex == 5){ dataValue = texture2D(uTextureContainer[5], uv); }\n  else if(textureIndex == 6){ dataValue = texture2D(uTextureContainer[6], uv); }\n\n}\n    ';
    }
  }]);

  return Texture3d;
}(_shaders2.default);

exports.default = new Texture3d();

},{"../shaders.base":148}],144:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Unpack = function (_ShadersBase) {
  _inherits(Unpack, _ShadersBase);

  function Unpack() {
    _classCallCheck(this, Unpack);

    var _this = _possibleConstructorReturn(this, (Unpack.__proto__ || Object.getPrototypeOf(Unpack)).call(this));

    _this.name = 'unpack';

    // default properties names
    _this._packedData = 'packedData';
    _this._offset = 'offset';
    _this._unpackedData = 'unpackedData';

    _this._base._uniforms = {
      uNumberOfChannels: {
        value: 1
      },
      uBitsAllocated: {
        value: 16
      },
      uPixelType: {
        value: 0
      }
    };
    return _this;
  }

  _createClass(Unpack, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var packedData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._packedData;
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._offset;
      var unpackedData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._unpackedData;

      this._base = baseFragment;
      return this.compute(packedData, offset, unpackedData);
    }
  }, {
    key: 'compute',
    value: function compute(packedData, offset, unpackedData) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + packedData + ', ' + offset + ', ' + unpackedData + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      // fun stuff
      var content = '';
      if (this._base._uniforms.uNumberOfChannels.value === 1) {
        switch (this._base._uniforms.uBitsAllocated.value) {

          case 1:
          case 8:
            content = this.upack8();
            break;

          case 16:
            content = this.upack16();
            break;

          case 32:
            content = this.upack32();
            break;

          default:
            content = this.upackDefault();
            break;

        }
      } else {
        content = this.upackIdentity();
      }

      this._definition = '\nvoid ' + this._name + '(in vec4 packedData, in int offset, out vec4 unpackedData){\n\n' + content + '\n\n}  \n    ';
    }
  }, {
    key: 'upack8',
    value: function upack8() {
      this._base._functions['uInt8'] = this.uInt8();

      return '\nuInt8(\n  packedData.r,\n  unpackedData.x);\n    ';
    }
  }, {
    key: 'upack16',
    value: function upack16() {
      this._base._functions['uInt16'] = this.uInt16();

      return '\nuInt16(\n  packedData.r * float( 1 - offset) + packedData.b * float(offset),\n  packedData.g * float( 1 - offset) + packedData.a * float(offset),\n  unpackedData.x);\n    ';
    }
  }, {
    key: 'upack32',
    value: function upack32() {
      if (this._base._uniforms.uPixelType.value === 0) {
        this._base._functions['uInt32'] = this.uInt32();

        return '\nuInt32(\n  packedData.r,\n  packedData.g,\n  packedData.b,\n  packedData.a,\n  unpackedData.x);\n      ';
      } else {
        this._base._functions['uFloat32'] = this.uFloat32();

        return '\nuFloat32(\n  packedData.r,\n  packedData.g,\n  packedData.b,\n  packedData.a,\n  unpackedData.x);\n      ';
      }
    }
  }, {
    key: 'upackIdentity',
    value: function upackIdentity() {
      return '\n\nunpackedData = packedData;\n\n      ';
    }
  }, {
    key: 'uInt8',
    value: function uInt8() {
      return '\nvoid uInt8(in float r, out float value){\n  value = r * 256.;\n}\n    ';
    }
  }, {
    key: 'uInt16',
    value: function uInt16() {
      return '\nvoid uInt16(in float r, in float a, out float value){\n  value = r * 256. + a * 65536.;\n}\n    ';
    }
  }, {
    key: 'uInt32',
    value: function uInt32() {
      return '\nvoid uInt32(in float r, in float g, in float b, in float a, out float value){\n  value = r * 256. + g * 65536. + b * 16777216. + a * 4294967296.;\n}\n    ';
    }
  }, {
    key: 'uFloat32',
    value: function uFloat32() {
      return '\nvoid uFloat32(in float r, in float g, in float b, in float a, out float value){\n\n  // create arrays containing bits for rgba values\n  // value between 0 and 255\n  value = r * 255.;\n  int bytemeR[8];\n  bytemeR[0] = int(floor(value / 128.));\n  value -= float(bytemeR[0] * 128);\n  bytemeR[1] = int(floor(value / 64.));\n  value -= float(bytemeR[1] * 64);\n  bytemeR[2] = int(floor(value / 32.));\n  value -= float(bytemeR[2] * 32);\n  bytemeR[3] = int(floor(value / 16.));\n  value -= float(bytemeR[3] * 16);\n  bytemeR[4] = int(floor(value / 8.));\n  value -= float(bytemeR[4] * 8);\n  bytemeR[5] = int(floor(value / 4.));\n  value -= float(bytemeR[5] * 4);\n  bytemeR[6] = int(floor(value / 2.));\n  value -= float(bytemeR[6] * 2);\n  bytemeR[7] = int(floor(value));\n\n  value = g * 255.;\n  int bytemeG[8];\n  bytemeG[0] = int(floor(value / 128.));\n  value -= float(bytemeG[0] * 128);\n  bytemeG[1] = int(floor(value / 64.));\n  value -= float(bytemeG[1] * 64);\n  bytemeG[2] = int(floor(value / 32.));\n  value -= float(bytemeG[2] * 32);\n  bytemeG[3] = int(floor(value / 16.));\n  value -= float(bytemeG[3] * 16);\n  bytemeG[4] = int(floor(value / 8.));\n  value -= float(bytemeG[4] * 8);\n  bytemeG[5] = int(floor(value / 4.));\n  value -= float(bytemeG[5] * 4);\n  bytemeG[6] = int(floor(value / 2.));\n  value -= float(bytemeG[6] * 2);\n  bytemeG[7] = int(floor(value));\n\n  value = b * 255.;\n  int bytemeB[8];\n  bytemeB[0] = int(floor(value / 128.));\n  value -= float(bytemeB[0] * 128);\n  bytemeB[1] = int(floor(value / 64.));\n  value -= float(bytemeB[1] * 64);\n  bytemeB[2] = int(floor(value / 32.));\n  value -= float(bytemeB[2] * 32);\n  bytemeB[3] = int(floor(value / 16.));\n  value -= float(bytemeB[3] * 16);\n  bytemeB[4] = int(floor(value / 8.));\n  value -= float(bytemeB[4] * 8);\n  bytemeB[5] = int(floor(value / 4.));\n  value -= float(bytemeB[5] * 4);\n  bytemeB[6] = int(floor(value / 2.));\n  value -= float(bytemeB[6] * 2);\n  bytemeB[7] = int(floor(value));\n\n  value = a * 255.;\n  int bytemeA[8];\n  bytemeA[0] = int(floor(value / 128.));\n  value -= float(bytemeA[0] * 128);\n  bytemeA[1] = int(floor(value / 64.));\n  value -= float(bytemeA[1] * 64);\n  bytemeA[2] = int(floor(value / 32.));\n  value -= float(bytemeA[2] * 32);\n  bytemeA[3] = int(floor(value / 16.));\n  value -= float(bytemeA[3] * 16);\n  bytemeA[4] = int(floor(value / 8.));\n  value -= float(bytemeA[4] * 8);\n  bytemeA[5] = int(floor(value / 4.));\n  value -= float(bytemeA[5] * 4);\n  bytemeA[6] = int(floor(value / 2.));\n  value -= float(bytemeA[6] * 2);\n  bytemeA[7] = int(floor(value));\n\n  // compute float32 value from bit arrays\n\n  // sign\n  int issigned = 1 - 2 * bytemeR[0];\n  //   issigned = int(pow(-1., float(bytemeR[0])));\n\n  // exponent\n  int exponent = 0;\n\n  exponent += bytemeR[1] * int(pow(2., 7.));\n  exponent += bytemeR[2] * int(pow(2., 6.));\n  exponent += bytemeR[3] * int(pow(2., 5.));\n  exponent += bytemeR[4] * int(pow(2., 4.));\n  exponent += bytemeR[5] * int(pow(2., 3.));\n  exponent += bytemeR[6] * int(pow(2., 2.));\n  exponent += bytemeR[7] * int(pow(2., 1.));\n\n  exponent += bytemeG[0];\n\n\n  // fraction\n  float fraction = 0.;\n\n  fraction = float(bytemeG[1]) * pow(2., -1.);\n  fraction += float(bytemeG[2]) * pow(2., -2.);\n  fraction += float(bytemeG[3]) * pow(2., -3.);\n  fraction += float(bytemeG[4]) * pow(2., -4.);\n  fraction += float(bytemeG[5]) * pow(2., -5.);\n  fraction += float(bytemeG[6]) * pow(2., -6.);\n  fraction += float(bytemeG[7]) * pow(2., -7.);\n\n  fraction += float(bytemeB[0]) * pow(2., -8.);\n  fraction += float(bytemeB[1]) * pow(2., -9.);\n  fraction += float(bytemeB[2]) * pow(2., -10.);\n  fraction += float(bytemeB[3]) * pow(2., -11.);\n  fraction += float(bytemeB[4]) * pow(2., -12.);\n  fraction += float(bytemeB[5]) * pow(2., -13.);\n  fraction += float(bytemeB[6]) * pow(2., -14.);\n  fraction += float(bytemeB[7]) * pow(2., -15.);\n\n  fraction += float(bytemeA[0]) * pow(2., -16.);\n  fraction += float(bytemeA[1]) * pow(2., -17.);\n  fraction += float(bytemeA[2]) * pow(2., -18.);\n  fraction += float(bytemeA[3]) * pow(2., -19.);\n  fraction += float(bytemeA[4]) * pow(2., -20.);\n  fraction += float(bytemeA[5]) * pow(2., -21.);\n  fraction += float(bytemeA[6]) * pow(2., -22.);\n  fraction += float(bytemeA[7]) * pow(2., -23.);\n\n  value = float(issigned) * pow( 2., float(exponent - 127)) * (1. + fraction);\n}\n    ';
    }
  }]);

  return Unpack;
}(_shaders2.default);

exports.default = new Unpack();

},{"../shaders.base":148}],145:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersHelpers = require('../helpers/shaders.helpers.unpack');

var _shadersHelpers2 = _interopRequireDefault(_shadersHelpers);

var _shadersHelpers3 = require('../helpers/shaders.helpers.texture3d');

var _shadersHelpers4 = _interopRequireDefault(_shadersHelpers3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var InterpolationIdentity = function (_ShadersBase) {
  _inherits(InterpolationIdentity, _ShadersBase);

  function InterpolationIdentity() {
    _classCallCheck(this, InterpolationIdentity);

    var _this = _possibleConstructorReturn(this, (InterpolationIdentity.__proto__ || Object.getPrototypeOf(InterpolationIdentity)).call(this));

    _this.name = 'interpolationIdentity';

    // default properties names
    _this._currentVoxel = 'currentVoxel';
    _this._dataValue = 'dataValue';
    return _this;
  }

  _createClass(InterpolationIdentity, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var currentVoxel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._currentVoxel;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;

      this._base = baseFragment;
      return this.compute(currentVoxel, dataValue);
    }
  }, {
    key: 'compute',
    value: function compute(currentVoxel, dataValue) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + currentVoxel + ', ' + dataValue + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in vec3 currentVoxel, out vec4 dataValue){\n  // lower bound\n  vec3 rcurrentVoxel = vec3(floor(currentVoxel.x + 0.5 ), floor(currentVoxel.y + 0.5 ), floor(currentVoxel.z + 0.5 ));\n  ivec3 voxel = ivec3(int(rcurrentVoxel.x), int(rcurrentVoxel.y), int(rcurrentVoxel.z));\n\n  vec4 tmp = vec4(0., 0., 0., 0.);\n  int offset = 0;\n\n  ' + _shadersHelpers4.default.api(this._base, 'voxel', 'tmp', 'offset') + '\n  ' + _shadersHelpers2.default.api(this._base, 'tmp', 'offset', 'dataValue') + '\n}\n    ';
    }
  }]);

  return InterpolationIdentity;
}(_shaders2.default);

exports.default = new InterpolationIdentity();

},{"../helpers/shaders.helpers.texture3d":143,"../helpers/shaders.helpers.unpack":144,"../shaders.base":148}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shadersInterpolation = require('./shaders.interpolation.identity');

var _shadersInterpolation2 = _interopRequireDefault(_shadersInterpolation);

var _shadersInterpolation3 = require('./shaders.interpolation.trilinear');

var _shadersInterpolation4 = _interopRequireDefault(_shadersInterpolation3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function shadersInterpolation(baseFragment, currentVoxel, dataValue, gradient) {
  switch (baseFragment._uniforms.uInterpolation.value) {

    case 0:
      // no interpolation
      return _shadersInterpolation2.default.api(baseFragment, currentVoxel, dataValue);

    case 1:
      // trilinear interpolation
      return _shadersInterpolation4.default.api(baseFragment, currentVoxel, dataValue, gradient);

    default:
      return _shadersInterpolation2.default.api(baseFragment, currentVoxel, dataValue);

  }
}

exports.default = shadersInterpolation;

},{"./shaders.interpolation.identity":145,"./shaders.interpolation.trilinear":147}],147:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersInterpolation = require('./shaders.interpolation.identity');

var _shadersInterpolation2 = _interopRequireDefault(_shadersInterpolation);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var InterpolationTrilinear = function (_ShadersBase) {
  _inherits(InterpolationTrilinear, _ShadersBase);

  function InterpolationTrilinear() {
    _classCallCheck(this, InterpolationTrilinear);

    var _this = _possibleConstructorReturn(this, (InterpolationTrilinear.__proto__ || Object.getPrototypeOf(InterpolationTrilinear)).call(this));

    _this.name = 'interpolationTrilinear';

    // default properties names
    _this._currentVoxel = 'currentVoxel';
    _this._dataValue = 'dataValue';
    _this._gradient = 'gradient';
    return _this;
  }

  _createClass(InterpolationTrilinear, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var currentVoxel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._currentVoxel;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;
      var gradient = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._gradient;

      this._base = baseFragment;
      return this.compute(currentVoxel, dataValue, gradient);
    }
  }, {
    key: 'compute',
    value: function compute(currentVoxel, dataValue, gradient) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + currentVoxel + ', ' + dataValue + ', ' + gradient + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in vec3 currentVoxel, out vec4 dataValue, out vec3 gradient){\n\n  // https://en.wikipedia.org/wiki/Trilinear_interpolation\n  vec3 lower_bound = vec3(floor(currentVoxel.x), floor(currentVoxel.y), floor(currentVoxel.z));\n  if(lower_bound.x < 0.){\n    lower_bound.x = 0.;\n  }\n  if(lower_bound.y < 0.){\n    lower_bound.y = 0.;\n  }\n  if(lower_bound.z < 0.){\n    lower_bound.z = 0.;\n  }\n  \n  vec3 higher_bound = lower_bound + vec3(1);\n\n  float xd = ( currentVoxel.x - lower_bound.x ) / ( higher_bound.x - lower_bound.x );\n  float yd = ( currentVoxel.y - lower_bound.y ) / ( higher_bound.y - lower_bound.y );\n  float zd = ( currentVoxel.z - lower_bound.z ) / ( higher_bound.z - lower_bound.z );\n\n  //\n  // c00\n  //\n\n  //\n\n  vec4 v000 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c000 = vec3(lower_bound.x, lower_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c000', 'v000') + '\n  vec3 g000 = v000.r * vec3(-1., -1., -1.);\n\n  //\n\n  vec4 v100 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c100 = vec3(higher_bound.x, lower_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c100', 'v100') + '\n  vec3 g100 = v100.r * vec3(1., -1., -1.);\n\n  vec4 c00 = v000 * ( 1.0 - xd ) + v100 * xd;\n\n  //\n  // c01\n  //\n  vec4 v001 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c001 = vec3(lower_bound.x, lower_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c001', 'v001') + '\n  vec3 g001 = v001.r * vec3(-1., -1., 1.);\n\n  vec4 v101 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c101 = vec3(higher_bound.x, lower_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c101', 'v101') + '\n  vec3 g101 = v101.r * vec3(1., -1., 1.);\n\n  vec4 c01 = v001 * ( 1.0 - xd ) + v101 * xd;\n\n  //\n  // c10\n  //\n  vec4 v010 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c010 = vec3(lower_bound.x, higher_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c010', 'v010') + '\n  vec3 g010 = v010.r * vec3(-1., 1., -1.);\n\n  vec4 v110 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c110 = vec3(higher_bound.x, higher_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c110', 'v110') + '\n  vec3 g110 = v110.r * vec3(1., 1., -1.);\n\n  vec4 c10 = v010 * ( 1.0 - xd ) + v110 * xd;\n\n  //\n  // c11\n  //\n  vec4 v011 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c011 = vec3(lower_bound.x, higher_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c011', 'v011') + '\n  vec3 g011 = v011.r * vec3(-1., 1., 1.);\n\n  vec4 v111 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c111 = vec3(higher_bound.x, higher_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c111', 'v111') + '\n  vec3 g111 = v111.r * vec3(1., 1., 1.);\n\n  vec4 c11 = v011 * ( 1.0 - xd ) + v111 * xd;\n\n  // c0 and c1\n  vec4 c0 = c00 * ( 1.0 - yd) + c10 * yd;\n  vec4 c1 = c01 * ( 1.0 - yd) + c11 * yd;\n\n  // c\n  vec4 c = c0 * ( 1.0 - zd) + c1 * zd;\n  dataValue = c;\n\n  // compute gradient\n  gradient = g000 + g100 + g010 + g110 + g011 + g111 + g110 + g011;\n  // gradientMagnitude = length(gradient);\n  // // https://en.wikipedia.org/wiki/Normal_(geometry)#Transforming_normals\n  // vec3 localNormal = (-1. / gradientMagnitude) * gradient;\n  // normal = normalize(normalPixelToPatient' + this.id + ' * localNormal);\n  //normal = gradient;\n\n}\n    ';
    }
  }]);

  return InterpolationTrilinear;
}(_shaders2.default);

exports.default = new InterpolationTrilinear();

},{"../shaders.base":148,"./shaders.interpolation.identity":145}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersBase = function () {
  function ShadersBase() {
    _classCallCheck(this, ShadersBase);

    this._name = 'shadersBase';
    this._base = {
      _functions: {},
      _uniforms: {}
    };
    this._definition = '';
  }

  _createClass(ShadersBase, [{
    key: 'name',
    get: function get() {
      return this._name;
    },
    set: function set(name) {
      this._name = name;
    }
  }]);

  return ShadersBase;
}();

exports.default = ShadersBase;

},{}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\n\n    float luma (vec3 rgb) {\n\treturn (rgb.r + rgb.g + rgb.b)/3.0;\n}\n\nconst float T = 0.04;\nconst float M = 1.0;\nconst float L = 0.002;\n\nvoid main(void) {\n\n  vec2 texCoord = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n\n  float borderWidth = uWidth; // in px\n  float step_u = borderWidth * 1.0 / uCanvasWidth;\n  float step_v = borderWidth * 1.0 / uCanvasHeight;\n  vec4 centerPixel = texture2D(uTextureFilled, texCoord);\n\n  vec4 rightPixel  = texture2D(uTextureFilled, texCoord + vec2(step_u, 0.0));\n  vec4 bottomPixel = texture2D(uTextureFilled, texCoord + vec2(0.0, step_v));\n\n  // now manually compute the derivatives\n  float _dFdX = length(rightPixel - centerPixel) / step_u;\n  float _dFdY = length(bottomPixel - centerPixel) / step_v;\n\n  // gl_FragColor.r = _dFdX;\n  // gl_FragColor.g = _dFdY;\n  gl_FragColor.r = max(max(centerPixel.r, rightPixel.r), bottomPixel.r);\n  gl_FragColor.g = max(max(centerPixel.g, rightPixel.g), bottomPixel.g);\n  gl_FragColor.b = max(max(centerPixel.b, rightPixel.b), bottomPixel.b);\n  gl_FragColor.a = max(_dFdX, _dFdY);\n\n  return;\n  float h = 1./uCanvasHeight;\n  float w = 1./uCanvasWidth;\n  vec4 n[9];\n  n[0] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, -h));\n  n[1] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(0.0, -h));\n  n[2] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(  w, -h));\n  n[3] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, 0.0));\n  n[4] = texture2D(uTextureFilled, vProjectedTextCoords);\n  n[5] = texture2D(uTextureFilled, texCoord + vec2(  w, 0.0));\n  n[6] = texture2D(uTextureFilled, texCoord + vec2( -w, h));\n  n[7] = texture2D(uTextureFilled, texCoord + vec2(0.0, h));\n  n[8] = texture2D(uTextureFilled, texCoord + vec2(  w, h));\n  vec4 sobel_horizEdge = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_vertEdge  = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec3 sobel = sqrt((sobel_horizEdge.rgb * sobel_horizEdge.rgb) + (sobel_vertEdge.rgb * sobel_vertEdge.rgb));\n  gl_FragColor = vec4( sobel, max(max(sobel.r, sobel.g), sobel.b) );\n\n\n  return;\n\n  gl_FragColor.r = (texCoord + vec2(0.0, step_v)).r;\n  gl_FragColor.g = (texCoord + vec2(step_u, 0.0)).g;\n  gl_FragColor = centerPixel;\n  gl_FragColor.r = texCoord.x;\n  // gl_FragColor.g = (texCoord + vec2(0.0, step_v)).x;\n  gl_FragColor.b = (texCoord + vec2(step_u, 0.0)).x;\n  gl_FragColor.rg = (texCoord + vec2(0.0, step_v));\n  gl_FragColor.b = 0.;\n  return;\n  vec2 texCoordSlope = fwidth(texCoord);\n  vec4 color2 = texture2D(uTextureFilled, vProjectedTextCoords);\n  // dfdx that vProjectedTextCoords\n  float l = luma (color2.rgb) ;\n    float luminance = dot(color2.rgb,vec3(0.2126, 0.7152, 0.0722));\n\n  \tfloat q0 = fwidth (luminance);\n    if(q0 > 0.01){\n      q0 = 1.0;\n    }\n\tfloat q1 = abs (dFdx (l)); \n\tfloat q2 = abs (dFdy (l));\n\n  \tvec4 ct = vec4 (1.0, 1.0, 1.0, 0.0);\n\tvec4 c0 = mix (ct, vec4 (1.0, 0.0, 0.0, 1.0), \n\t\tsmoothstep (T * (1.0 - M), T * (1.0 + M), q0));\n\ngl_FragColor.r = fwidth(color2.r);//abs(dFdx(color2.b));//texCoord;//color2.rgb;\ngl_FragColor.g = fwidth(color2.g);\ngl_FragColor.b = fwidth(color2.b);\ngl_FragColor.a = 1.;\n// gl_FragColor.a = q0;\n// gl_FragColor = color2;\n//return;\n\n\n  //The back position is the world space position stored in the texture.\n  vec4 color = texture2D(uTextureFilled, texCoord);\n  float lColor = length(color.rgb);\n  float maxColor = length(color.rgb);//max(max(color.r, color.g), color.b);\n  // if(maxColor > 0.1){\n  //   maxColor = 1.0;\n  // }\n\n\n\n  // gl_FragColor = color;//vec4(color.r, color.g, color.b, 1);\n  // return;\n  // float tmpxx  = abs(dFdx(lColor));\n  // float tmpxy  = abs(dFdy(lColor));\n  // float tmpx = max(tmpxx,tmpxy);\n\n  // float tmpyx  = abs(dFdx(color.y));\n  // float tmpyy  = abs(dFdy(color.y));\n  // float tmpy = max(tmpyx,tmpyy);\n\n  // float tmpzx  = abs(dFdx(color.z));\n  // float tmpzy  = abs(dFdy(color.z));\n  // float tmpz = max(tmpzx,tmpzy);\n\n  // float tmpmax = max(max(tmpx, tmpy), tmpz);\n  // if(tmpmax > 0.01){\n  //   tmpmax = 1.0;\n  // }\n  // gl_FragColor.r = tmpx;//smoothstep(tmpx-5., tmpx+5., lColor);\n  // gl_FragColor.g = tmpx;\n  // gl_FragColor.b = tmpx;\n\n  // vec4 color2 = texture2D(uTextureFilled, vec2(texcX, texcY));\n\n  // gl_FragColor.r = color.r - texcX;\n  // gl_FragColor.g = color.g - texcY;\n  // gl_FragColor.b = color.b - color2.b;\n  // gl_FragColor.a = 1.;\n\n  // float threshold = 0.7;\n  // float afwidth = length(vec2(dFdx(maxColor), dFdy(maxColor)));\n  // gl_FragColor.a = afwidth;\n  // float opacity =\n  //   smoothstep(afwidth - threshold, afwidth + threshold, maxColor);\n\n  // gl_FragColor.a = maxColor;\n\n// float aaf = fwidth(maxColor);\n// float alpha = smoothstep(.01, .8, aaf);\n// gl_FragColor = vec4(color.rgb, alpha);\n\n  // float h = 1./uCanvasHeight;\n  // float w = 1./uCanvasWidth;\n  // vec4 n[9];\n  // n[0] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, -h));\n  // n[1] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(0.0, -h));\n  // n[2] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(  w, -h));\n  // n[3] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, 0.0));\n  // n[4] = texture2D(uTextureFilled, vProjectedTextCoords);\n  // n[5] = texture2D(uTextureFilled, texCoord + vec2(  w, 0.0));\n  // n[6] = texture2D(uTextureFilled, texCoord + vec2( -w, h));\n  // n[7] = texture2D(uTextureFilled, texCoord + vec2(0.0, h));\n  // n[8] = texture2D(uTextureFilled, texCoord + vec2(  w, h));\n  // vec4 sobel_horizEdge = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  // vec4 sobel_vertEdge  = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  // vec3 sobel = sqrt((sobel_horizEdge.rgb * sobel_horizEdge.rgb) + (sobel_vertEdge.rgb * sobel_vertEdge.rgb));\n  // gl_FragColor = vec4( n[1].rgb, 1.0 );\n  // gl_FragColor.r = 1.0;\n\n  return;\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\nvarying vec4      vProjectedCoords;\nvarying vec2      vProjectedTextCoords;\nvarying mat4      vProjectionViewMatrix;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uWidth': {
          type: 'f',
          value: 1.,
          typeGLSL: 'float'
        },
        'uTextureFilled': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying vec4 vProjectedCoords;\nvarying mat4 vProjectionViewMatrix;\nvarying vec2 vProjectedTextCoords;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectionViewMatrix = projectionMatrix * viewMatrix;\n  vProjectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  vProjectedTextCoords = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid main(void) {\n\n  // draw border if slice is cropped\n  // float uBorderDashLength = 10.;\n\n  if( uCanvasWidth > 0. &&\n      ((gl_FragCoord.x > uBorderMargin && (gl_FragCoord.x - uBorderMargin) < uBorderWidth) ||\n       (gl_FragCoord.x < (uCanvasWidth - uBorderMargin) && (gl_FragCoord.x + uBorderMargin) > (uCanvasWidth - uBorderWidth) ))){\n    float valueY = mod(gl_FragCoord.y, 2. * uBorderDashLength);\n    if( valueY < uBorderDashLength && gl_FragCoord.y > uBorderMargin && gl_FragCoord.y < (uCanvasHeight - uBorderMargin) ){\n      gl_FragColor = vec4(uBorderColor, 1.);\n      return;\n    }\n  }\n\n  if( uCanvasHeight > 0. &&\n      ((gl_FragCoord.y > uBorderMargin && (gl_FragCoord.y - uBorderMargin) < uBorderWidth) ||\n       (gl_FragCoord.y < (uCanvasHeight - uBorderMargin) && (gl_FragCoord.y + uBorderMargin) > (uCanvasHeight - uBorderWidth) ))){\n    float valueX = mod(gl_FragCoord.x, 2. * uBorderDashLength);\n    if( valueX < uBorderDashLength && gl_FragCoord.x > uBorderMargin && gl_FragCoord.x < (uCanvasWidth - uBorderMargin) ){\n      gl_FragColor = vec4(uBorderColor, 1.);\n      return;\n    }\n  }\n\n  // get texture coordinates of current pixel\n  vec4 dataCoordinates = uWorldToData * vPos;\n  vec3 currentVoxel = vec3(dataCoordinates.x, dataCoordinates.y, dataCoordinates.z);\n  vec4 dataValue = vec4(0., 0., 0., 0.);\n  vec3 gradient = vec3(0., 0., 0.);\n  ' + (0, _shaders2.default)(this, 'currentVoxel', 'dataValue', 'gradient') + '\n\n  // how do we deal wil more than 1 channel?\n  if(uNumberOfChannels == 1){\n    float intensity = dataValue.r;\n\n    // rescale/slope\n    intensity = intensity*uRescaleSlopeIntercept[0] + uRescaleSlopeIntercept[1];\n\n    float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\n    float windowMax = uWindowCenterWidth[0] + uWindowCenterWidth[1] * 0.5;\n    intensity = ( intensity - windowMin ) / uWindowCenterWidth[1];\n\n    dataValue.r = dataValue.g = dataValue.b = intensity;\n    dataValue.a = 1.0;\n  }\n\n  // Apply LUT table...\n  //\n  if(uLut == 1){\n    // should opacity be grabbed there?\n    dataValue = texture2D( uTextureLUT, vec2( dataValue.r , 1.0) );\n  }\n\n  if(uInvert == 1){\n    dataValue = vec4(1.) - dataValue;\n    // how do we deal with that and opacity?\n    dataValue.a = 1.;\n  }\n\n  gl_FragColor = dataValue;\n\n    // if on edge, draw line\n  // float xPos = gl_FragCoord.x/512.;\n  // float yPos = gl_FragCoord.y/512.;\n  // if( xPos < 0.05 || xPos > .95 || yPos < 0.05 || yPos > .95){\n  //   gl_FragColor = vec4(xPos, yPos, 0., 1.);//dataValue;\n  //   //return;\n  // }\n\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{"./interpolation/shaders.interpolation":146}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',

    /**
     * Shaders data uniforms
     */
    value: function uniforms() {
      return {
        'uTextureSize': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureContainer': {
          type: 'tv',
          value: [],
          typeGLSL: 'sampler2D',
          length: 7
        },
        'uDataDimensions': {
          type: 'iv',
          value: [0, 0, 0],
          typeGLSL: 'ivec3'
        },
        'uWorldToData': {
          type: 'm4',
          value: new THREE.Matrix4(),
          typeGLSL: 'mat4'
        },
        'uWindowCenterWidth': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uRescaleSlopeIntercept': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uNumberOfChannels': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uBitsAllocated': {
          type: 'i',
          value: 8,
          typeGLSL: 'int'
        },
        'uInvert': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uLut': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureLUT': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uPixelType': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uPackedPerPixel': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uInterpolation': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uBorderColor': {
          type: 'v3',
          value: [1.0, 0.0, 0.5],
          typeGLSL: 'vec3'
        },
        'uBorderWidth': {
          type: 'f',
          value: 2.,
          typeGLSL: 'float'
        },
        'uBorderMargin': {
          type: 'f',
          value: 2.,
          typeGLSL: 'float'
        },
        'uBorderDashLength': {
          type: 'f',
          value: 10.,
          typeGLSL: 'float'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shadersContour = require('./shaders.contour.uniform');

var _shadersContour2 = _interopRequireDefault(_shadersContour);

var _shadersContour3 = require('./shaders.contour.fragment');

var _shadersContour4 = _interopRequireDefault(_shadersContour3);

var _shadersContour5 = require('./shaders.contour.vertex');

var _shadersContour6 = _interopRequireDefault(_shadersContour5);

var _shadersData = require('./shaders.data.uniform');

var _shadersData2 = _interopRequireDefault(_shadersData);

var _shadersData3 = require('./shaders.data.fragment');

var _shadersData4 = _interopRequireDefault(_shadersData3);

var _shadersData5 = require('./shaders.data.vertex');

var _shadersData6 = _interopRequireDefault(_shadersData5);

var _shadersVr = require('./shaders.vr.uniform');

var _shadersVr2 = _interopRequireDefault(_shadersVr);

var _shadersVr3 = require('./shaders.vr.fragment');

var _shadersVr4 = _interopRequireDefault(_shadersVr3);

var _shadersVr5 = require('./shaders.vr.vertex');

var _shadersVr6 = _interopRequireDefault(_shadersVr5);

var _shadersLayer = require('./shaders.layer.uniform');

var _shadersLayer2 = _interopRequireDefault(_shadersLayer);

var _shadersLayer3 = require('./shaders.layer.fragment');

var _shadersLayer4 = _interopRequireDefault(_shadersLayer3);

var _shadersLayer5 = require('./shaders.layer.vertex');

var _shadersLayer6 = _interopRequireDefault(_shadersLayer5);

var _shadersLocalizer = require('./shaders.localizer.uniform');

var _shadersLocalizer2 = _interopRequireDefault(_shadersLocalizer);

var _shadersLocalizer3 = require('./shaders.localizer.fragment');

var _shadersLocalizer4 = _interopRequireDefault(_shadersLocalizer3);

var _shadersLocalizer5 = require('./shaders.localizer.vertex');

var _shadersLocalizer6 = _interopRequireDefault(_shadersLocalizer5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module shaders
 */

exports.default = {
  ContourUniform: _shadersContour2.default,
  ContourFragment: _shadersContour4.default,
  ContourVertex: _shadersContour6.default,

  DataUniform: _shadersData2.default,
  DataFragment: _shadersData4.default,
  DataVertex: _shadersData6.default,

  VRUniform: _shadersVr2.default,
  VRFragment: _shadersVr4.default,
  VRVertex: _shadersVr6.default,

  LayerUniform: _shadersLayer2.default,
  LayerFragment: _shadersLayer4.default,
  LayerVertex: _shadersLayer6.default,

  LocalizerUniform: _shadersLocalizer2.default,
  LocalizerFragment: _shadersLocalizer4.default,
  LocalizerVertex: _shadersLocalizer6.default
};

},{"./shaders.contour.fragment":149,"./shaders.contour.uniform":150,"./shaders.contour.vertex":151,"./shaders.data.fragment":152,"./shaders.data.uniform":153,"./shaders.data.vertex":154,"./shaders.layer.fragment":156,"./shaders.layer.uniform":157,"./shaders.layer.vertex":158,"./shaders.localizer.fragment":159,"./shaders.localizer.uniform":160,"./shaders.localizer.vertex":161,"./shaders.vr.fragment":162,"./shaders.vr.uniform":163,"./shaders.vr.vertex":164}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid main(void) {\n\n  vec2 texc = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n\n  // just silence warning for\n  vec4 dummy = vPos;\n\n  //The back position is the world space position stored in the texture.\n  vec4 baseColor0 = texture2D(uTextureBackTest0, texc);\n  vec4 baseColor1 = texture2D(uTextureBackTest1, texc);\n\n  if( uTrackMouse == 1 ){\n\n      if( vProjectedCoords.x < uMouse.x ){\n\n        gl_FragColor = baseColor0;\n\n      }\n      else{\n\n        gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );\n\n      }\n\n  }\n  else{\n\n    if( uType1 == 0 ){\n\n      //merge an image into\n      gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );\n\n    }\n    else{\n\n      float opacity = baseColor1.a;\n      gl_FragColor = mix( baseColor0, baseColor1, opacity * uOpacity1 );\n\n    }\n\n  }\n\n  return;\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\nvarying vec4      vProjectedCoords;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uTextureBackTest0': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uTextureBackTest1': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uOpacity0': {
          type: 'f',
          value: 1.0,
          typeGLSL: 'float'
        },
        'uOpacity1': {
          type: 'f',
          value: 1.0,
          typeGLSL: 'float'
        },
        'uType0': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uType1': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uTrackMouse': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uMouse': {
          type: 'v2',
          value: new THREE.Vector2(),
          typeGLSL: 'vec2'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying vec4 vProjectedCoords;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Localizer fragment shader
 */
var _class = function () {

  /**
   * 
   */
  function _class(uniforms) {
    _classCallCheck(this, _class);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  /**
   * 
   */

  _createClass(_class, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }

    /**
     * 
     */

  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }

    /**
     * 
     */

  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid intersectionProjection(\n  in vec4 plane,\n  in vec4 slice,\n  out vec3 intersectionProjection){\n\n      vec3 intersectionDirection = normalize(cross(plane.xyz, slice.xyz));\n      vec3 intersectionPoint = \n        cross(intersectionDirection,slice.xyz) * plane.w +\n        cross(plane.xyz, intersectionDirection) * slice.w;\n\n      intersectionProjection =\n        intersectionPoint.xyz +\n        (dot(vPos.xyz - intersectionPoint, intersectionDirection)\n          * intersectionDirection);\n\n}\n\nvoid main(void) {\n      vec4 c1 = vec4(0., 0., 0., 0.);\n      vec4 c2 = vec4(0., 0., 0., 0.);\n      vec4 c3 = vec4(0., 0., 0., 0.);\n\n      // localizer #1\n      // must be normalized!\n      if(length(uPlane1.xyz) > 0.5) {\n        vec3 projection1 = vec3(1.);\n        intersectionProjection(\n          uPlane1,\n          uSlice,\n          projection1\n        );\n\n        vec4 projInter1 = (vProjectionViewMatrix * vec4(projection1, 1.));\n        vec3 ndc1 = projInter1.xyz / projInter1.w;\n        vec2 screenSpace1 = (ndc1.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d1 = distance(gl_FragCoord.xy, screenSpace1.xy);\n        c1 = vec4(uPlaneColor1, 1. - smoothstep(.5, .7, d1));\n      }\n\n      // localizer #2\n      if(length(uPlane2.xyz) > 0.5) {\n        vec3 projection2 = vec3(1.);\n        intersectionProjection(\n          uPlane2,\n          uSlice,\n          projection2\n        );\n\n        vec4 projInter2 = (vProjectionViewMatrix * vec4(projection2, 1.));\n        vec3 ndc2 = projInter2.xyz / projInter2.w;\n        vec2 screenSpace2 = (ndc2.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d2 = distance(gl_FragCoord.xy, screenSpace2.xy);\n        c2 = vec4(uPlaneColor2, 1. - smoothstep(.5, .7, d2));\n      }\n\n      // localizer #3\n      if(length(uPlane3.xyz) > 0.5) {\n        vec3 projection3 = vec3(1.);\n        intersectionProjection(\n          uPlane3,\n          uSlice,\n          projection3\n        );\n\n        vec4 projInter3 = (vProjectionViewMatrix * vec4(projection3, 1.));\n        vec3 ndc3 = projInter3.xyz / projInter3.w;\n        vec2 screenSpace3 = (ndc3.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d3 = distance(gl_FragCoord.xy, screenSpace3.xy);\n        c3 = vec4(uPlaneColor3, 1. - smoothstep(.5, .7, d3));\n      }\n\n      vec3 colorMix = c1.xyz*c1.w + c2.xyz*c2.w + c3.xyz*c3.w;\n      gl_FragColor = vec4(colorMix, max(max(c1.w, c2.w),c3.w));\n}\n   ';
    }

    /**
     * 
     */

  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4 vPos;\nvarying mat4 vProjectionViewMatrix;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"./interpolation/shaders.interpolation":146}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/localizer/uniforms
 */

var _class = function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  _createClass(_class, null, [{
    key: 'uniforms',

    /**
     * Shaders data uniforms
     */
    value: function uniforms() {
      return {
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uSlice': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlane1': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor1': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        },
        'uPlane2': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor2': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        },
        'uPlane3': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor3': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        }

      };
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * 
 */
var _class = function () {
  /**
   * 
   */
  function _class() {
    _classCallCheck(this, _class);
  }

  /**
   * 
   */

  _createClass(_class, [{
    key: "compute",
    value: function compute() {
      return "\nvarying vec4 vPos;\nvarying mat4 vProjectionViewMatrix;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectionViewMatrix = projectionMatrix * viewMatrix;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersHelpers = require('./helpers/shaders.helpers.intersectBox');

var _shadersHelpers2 = _interopRequireDefault(_shadersHelpers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid getIntensity(in vec3 dataCoordinates, out float intensity, out vec3 gradient){\n\n  vec4 dataValue = vec4(0., 0., 0., 0.);\n  ' + (0, _shaders2.default)(this, 'dataCoordinates', 'dataValue', 'gradient') + '\n\n  intensity = dataValue.r;\n\n  // rescale/slope\n  intensity = intensity*uRescaleSlopeIntercept[0] + uRescaleSlopeIntercept[1];\n  // window level\n  float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\n  intensity = ( intensity - windowMin ) / uWindowCenterWidth[1];\n}\n\nvoid main(void) {\n  const int maxSteps = 1024;\n\n  // the ray\n  vec3 rayOrigin = cameraPosition;\n  vec3 rayDirection = normalize(vPos.xyz - rayOrigin);\n\n  // the Axe-Aligned B-Box\n  vec3 AABBMin = vec3(uWorldBBox[0], uWorldBBox[2], uWorldBBox[4]);\n  vec3 AABBMax = vec3(uWorldBBox[1], uWorldBBox[3], uWorldBBox[5]);\n\n  // Intersection ray/bbox\n  float tNear, tFar;\n  bool intersect = false;\n  ' + _shadersHelpers2.default.api(this, 'rayOrigin', 'rayDirection', 'AABBMin', 'AABBMax', 'tNear', 'tFar', 'intersect') + '\n  if (tNear < 0.0) tNear = 0.0;\n\n  // init the ray marching\n  float tCurrent = tNear;\n  float tStep = (tFar - tNear) / float(uSteps);\n  vec4 accumulatedColor = vec4(0.0);\n  float accumulatedAlpha = 0.0;\n\n  for(int rayStep = 0; rayStep < maxSteps; rayStep++){\n    vec3 currentPosition = rayOrigin + rayDirection * tCurrent;\n    // some non-linear FUN\n    // some occlusion issue to be fixed\n    vec3 transformedPosition = currentPosition; //transformPoint(currentPosition, uAmplitude, uFrequence);\n    // world to data coordinates\n    // rounding trick\n    // first center of first voxel in data space is CENTERED on (0,0,0)\n    vec4 dataCoordinatesRaw = uWorldToData * vec4(transformedPosition, 1.0);\n    vec3 currentVoxel = vec3(dataCoordinatesRaw.x, dataCoordinatesRaw.y, dataCoordinatesRaw.z);\n    float intensity = 0.0;\n    vec3 gradient = vec3(0., 0., 0.);\n    getIntensity(currentVoxel, intensity, gradient);\n\n    vec4 colorSample;\n    float alphaSample;\n    if(uLut == 1){\n      vec4 colorFromLUT = texture2D( uTextureLUT, vec2( intensity, 1.0) );\n      // 256 colors\n      colorSample = colorFromLUT;\n      alphaSample = colorFromLUT.a;\n    }\n    else{\n      alphaSample = intensity;\n      colorSample.r = colorSample.g = colorSample.b = intensity * alphaSample;\n    }\n\n    alphaSample = alphaSample * uAlphaCorrection;\n    alphaSample *= (1.0 - accumulatedAlpha);\n\n    accumulatedColor += alphaSample * colorSample;\n    accumulatedAlpha += alphaSample;\n\n    tCurrent += tStep;\n\n    if(tCurrent > tFar || accumulatedAlpha >= 1.0 ) break;\n  }\n\n  gl_FragColor = vec4(accumulatedColor.xyz, accumulatedAlpha);\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{"./helpers/shaders.helpers.intersectBox":142,"./interpolation/shaders.interpolation":146}],163:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uTextureSize': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureContainer': {
          type: 'tv',
          value: [],
          typeGLSL: 'sampler2D',
          length: 7
        },
        'uDataDimensions': {
          type: 'iv',
          value: [0, 0, 0],
          typeGLSL: 'ivec3'
        },
        'uWorldToData': {
          type: 'm4',
          value: new THREE.Matrix4(),
          typeGLSL: 'mat4'
        },
        'uWindowCenterWidth': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uRescaleSlopeIntercept': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uNumberOfChannels': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uBitsAllocated': {
          type: 'i',
          value: 8,
          typeGLSL: 'int'
        },
        'uInvert': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uLut': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureLUT': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uPixelType': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uPackedPerPixel': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uInterpolation': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uWorldBBox': {
          type: 'fv1',
          value: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'float',
          length: 6
        },
        'uSteps': {
          type: 'i',
          value: 256,
          typeGLSL: 'int'
        },
        'uAlphaCorrection': {
          type: 'f',
          value: 0.5,
          typeGLSL: 'float'
        },
        'uFrequence': {
          type: 'f',
          value: 0.0,
          typeGLSL: 'float'
        },
        'uAmplitude': {
          type: 'f',
          value: 0.0,
          typeGLSL: 'float'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],165:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsAnnotation = function (_WidgetsBase) {
  _inherits(WidgetsAnnotation, _WidgetsBase);

  function WidgetsAnnotation(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsAnnotation);

    var _this = _possibleConstructorReturn(this, (WidgetsAnnotation.__proto__ || Object.getPrototypeOf(WidgetsAnnotation)).call(this));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;
    _this._container = container;

    _this._active = true;

    _this._worldPosition = new THREE.Vector3();
    if (_this._targetMesh !== null) {
      _this._worldPosition = _this._targetMesh.position;
    }

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // dom stuff
    _this._line = null;
    _this._label = null;
    _this._cone = null;
    _this._labeltext = null;

    //booleans
    _this._alreadycreated = null; //bool that turns true when the user enter the name of the label
    _this._movinglabel = null; //bool that turns true when the label is moving with the mouse
    _this._labelmoved = false; //bool that turns true once the label is moved by the user (at least once)

    _this._labelhovered = false;
    _this._domHovered = false;
    _this._hovered = true;

    //var
    _this._labelpositionx = null; //position of label (top left corner)
    _this._labelpositiony = null; //position of label (top left corner)
    _this._differencemousecenterlabelx = 0; //difference between mouse position in the label and position of label (top left corner)
    _this._differencemousecenterlabely = 0; //difference between mouse position in the label and position of label (top left corner)

    // add handles
    _this._handles = [];

    self = _this;

    // first handle
    var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    firstHandle.worldPosition = _this._worldPosition;
    firstHandle.hovered = true;
    _this.add(firstHandle);

    _this._handles.push(firstHandle);

    var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    secondHandle.worldPosition = _this._worldPosition;
    secondHandle.hovered = true;
    // active and tracking might be redundant
    secondHandle.active = true;
    secondHandle.tracking = true;
    _this.add(secondHandle);

    _this._handles.push(secondHandle);

    // Create annotation

    _this.create();

    _this.onMove = _this.onMove.bind(_this);
    _this.onHoverlabel = _this.onHoverlabel.bind(_this);
    _this.notonHoverlabel = _this.notonHoverlabel.bind(_this);
    _this.changelabeltext = _this.changelabeltext.bind(_this);
    _this.movelabel = _this.movelabel.bind(_this);
    _this.notmovelabel = _this.notmovelabel.bind(_this);

    _this.addEventListeners();

    return _this;
  }

  _createClass(WidgetsAnnotation, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._label.addEventListener('mouseenter', this.onHoverlabel);
      this._label.addEventListener('mouseleave', this.notonHoverlabel);
      this._label.addEventListener('dblclick', this.changelabeltext);
      this._label.addEventListener('mousedown', this.movelabel);
      this._container.addEventListener('mouseup', this.notmovelabel);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);
    }
  }, {
    key: 'movelabel',
    value: function movelabel() {
      //function called when mousedown
      if (this._labelhovered = true) {
        //if label hobered we will move the label
        this._movinglabel = true;
        this._labelmoved = true;
        var mousey = -(-event.clientY + this._container.offsetHeight);
        var mousex = event.clientX;
        //calculate differencemousecenterlabel (difference between ref position of the label (top-left corner) and mouse position in the label)
        this._differencemousecenterlabelx = Math.abs(Math.abs(mousex) - Math.abs(this._labelpositionx));
        this._differencemousecenterlabely = Math.abs(Math.abs(mousey) - Math.abs(this._labelpositiony));
      }
    }
  }, {
    key: 'notmovelabel',
    value: function notmovelabel() {
      //this function is called when mouseup
      this._movinglabel = false;
      this._handles[0]._controls.enabled = true; //move the camera when mousedown and mousedown again
      this._handles[1]._controls.enabled = true;
      this._differencemousecenterlabelx = 0; //restart the value of differencemousecenterlabel. Necessary?
      this._differencemousecenterlabely = 0;
    }
  }, {
    key: 'onHoverlabel',
    value: function onHoverlabel() {
      //this function is called when mouse enters the label with "mouseenter" event
      this._labelhovered = true;
    }
  }, {
    key: 'notonHoverlabel',
    value: function notonHoverlabel() {
      //this function is called when mouse leaves the label with "mouseleave" event
      this._labelhovered = false;
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {

      if (this._movinglabel == true) {
        this._handles[0]._controls.enabled = false;
        this._handles[1]._controls.enabled = false;
      }

      this._dragged = true;

      this._handles[0].onMove(evt);
      this._handles[1].onMove(evt);

      this._hovered = this._handles[0].hovered || this._handles[1].hovered || this._labelhovered;

      this.update();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {

      this._dragged = false;

      this._handles[0].onStart(evt);
      this._handles[1].onStart(evt);

      this._active = this._handles[0].active || this._handles[1].active;

      this.update();
    }
  }, {
    key: 'setlabeltext',
    value: function setlabeltext() {
      this._labeltext = prompt("Please enter the name of the label", ""); //this function is called when the user creates a new arrow
      if (typeof this._labeltext == 'string') {
        //avoid error
        if (this._labeltext.length > 0) {
          this._label.innerHTML = this._labeltext;
          this._label.style.display = ''; //in css an empty string is used to revert display=none. Show the label once we know the content
          this._dashline.style.display = ''; //in css an empty string is used to revert display=none. Show the label once we know the content
        } else {
          this._label.innerHTML = this._labeltext;
          this._label.style.display = 'none'; //hide the label
          this._dashline.style.display = 'none'; //hide the label
        }
      }
    }
  }, {
    key: 'changelabeltext',
    value: function changelabeltext() {
      //this function is called when the user does double click in the label
      this._labeltext = prompt("Please enter new name of the label", this._label.innerHTML);
      if (typeof this._labeltext == 'string') {
        //avoid error
        if (this._labeltext.length > 0) {
          this._label.innerHTML = this._labeltext;
          this._label.style.display = ''; //in css an empty string is used to revert display=none. Show the label
          this._dashline.style.display = ''; //in css an empty string is used to revert display=none. Show the label
        } else {
          // if the length is 0 the user pressed Cancel
          this._label.innerHTML = this._labeltext;
          this._label.style.display = 'none'; //hide the label
          this._dashline.style.display = 'none'; //hide the label
        }
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      // First Handle
      this._handles[0].onEnd(evt);

      // Second Handle
      if (this._dragged || !this._handles[1].tracking) {
        this._handles[1].tracking = false;
        this._handles[1].onEnd(evt);
      } else {
        this._handles[1].tracking = false;
      }

      if (self._alreadycreated != true) {
        this.setlabeltext();
        self._alreadycreated = true;
      }

      // State of annotation widget
      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'update',
    value: function update() {
      this.updateColor();

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMPosition();
      this.updateDOMColor();
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.Geometry();
      this._geometry.vertices.push(this._handles[0].worldPosition);
      this._geometry.vertices.push(this._handles[1].worldPosition);

      // material
      this._material = new THREE.LineBasicMaterial();
      this.updateMeshColor();

      // mesh
      this._meshline = new THREE.Line(this._geometry, this._material);
      this._meshline.visible = true;

      // add it!
      this.add(this._meshline);

      //create cone and add it
      this._conegeometry = new THREE.CylinderGeometry(0, 2, 10);
      this._conegeometry.translate(0, -5, 0);
      this._conegeometry.rotateX(-Math.PI / 2);
      this._cone = new THREE.Mesh(this._conegeometry, this._material);
      this._cone.visible = true;
      this.add(this._cone);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._geometry) {
        this._geometry.verticesNeedUpdate = true;
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // add line!
      this._line = document.createElement('div');
      this._line.setAttribute('class', 'widgets handle line');
      this._line.style.position = 'absolute';
      this._line.style.transformOrigin = '0 100%';
      this._line.style.marginTop = '-1px';
      this._line.style.height = '2px'; //2
      this._line.style.width = '3px'; //3
      this._container.appendChild(this._line);

      // add dash line
      this._dashline = document.createElement('div');
      this._dashline.setAttribute('class', 'widgets handle dashline');
      this._dashline.style.position = 'absolute';
      this._dashline.style.border = 'none';
      this._dashline.style.borderTop = '2.5px dashed #F9F9F9';
      this._dashline.style.transformOrigin = '0 100%';
      this._dashline.style.height = '1px';
      this._dashline.style.width = '50%';
      this._dashline.style.display = 'none';
      this._container.appendChild(this._dashline);

      // add label!
      this._label = document.createElement('div');
      this._label.setAttribute('id', this.uuid);
      this._label.setAttribute('class', 'widgets handle label');
      this._label.style.border = '2px solid #F9F9F9';
      this._label.style.backgroundColor = '#F9F9F9';
      // this._label.style.opacity = '0.5';
      this._label.style.color = '#353535';
      this._label.style.padding = '4px';
      this._label.style.position = 'absolute';
      this._label.style.transformOrigin = '0 100%';
      this._label.innerHTML = 'Hello, world!';
      this._label.style.display = 'none';
      this._container.appendChild(this._label);

      this.updateDOMColor();
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {

      console.log('function updateDOMPosition');
      // update annotation lines and text!
      var x1 = this._handles[0].screenPosition.x;
      var y1 = this._handles[0].screenPosition.y;
      var x2 = this._handles[1].screenPosition.x;
      var y2 = this._handles[1].screenPosition.y;

      var x0 = x1 + (x2 - x1) / 2;
      var y0 = y1 + (y2 - y1) / 2;

      var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

      var posY = y1 - this._container.offsetHeight;

      // update line
      var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
      transform += ' rotate(' + angle + 'deg)';

      this._line.style.transform = transform;
      this._line.style.width = length + 'px';

      // update label position
      var mousex = 0;
      var mousey = 0;

      var posY0 = void 0;

      posY0 = y0 - this._container.offsetHeight - this._label.offsetHeight / 2;
      x0 -= this._label.offsetWidth / 2;

      var x;
      var y;

      if (this._labelmoved == false) {
        //if the user hasnt moved the label, the position is defined by the position of the arrow
        var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
        this._label.style.transform = transform2;
        this._labelpositionx = Math.round(x0);
        this._labelpositiony = Math.round(posY0);
      }

      if (this._movinglabel) {
        //if the user has moved the label, the position is defined by the mouse
        mousex = event.clientX;
        mousey = -(-event.clientY + this._container.offsetHeight);
        this._label.style.transform = 'translate3D(' + (mousex - this._differencemousecenterlabelx) + 'px,' + (mousey - this._differencemousecenterlabely) + 'px, 0)';
        //we use differencemousecenterlabel to check the difference between the position of the mouse in the label and the reference position of the label (top-left corner)
        this._labelpositionx = mousex - this._differencemousecenterlabelx;
        this._labelpositiony = mousey - this._differencemousecenterlabely;
      }

      //update cone
      var w0 = this._handles[0].worldPosition;
      var w1 = this._handles[1].worldPosition;

      //position and rotation of cone
      this._cone.position.set(w1.x, w1.y, w1.z);
      this._cone.lookAt(w0);

      // update dash line

      //calculate the place in the label: center of the label
      x1 = this._handles[0].screenPosition.x;
      y1 = this._handles[0].screenPosition.y;
      x2 = this._labelpositionx;
      y2 = this._labelpositiony + this._container.offsetHeight; //revert the operation in 'mousey' to get the previous eventY

      //get the size of the label so we can place the dashed line in the center of it
      var labelheight = this._label.offsetHeight;
      var labelwidth = this._label.offsetWidth;

      var centerlabelx = 0;
      var centerlabely = 0;

      if (isFinite(labelwidth) && isFinite(labelheight)) {
        //if the extraction has been succesfull, we calculate the center of the label with total size
        centerlabelx = labelwidth / 2;
        centerlabely = labelheight / 2;
      }

      x2 += centerlabelx;
      y2 += centerlabely;

      //calculate the place in the arrow: closest part of the line to place the dashed line
      var x1_tail = this._handles[0].screenPosition.x; //first position: tail of arrow
      var y1_tail = this._handles[0].screenPosition.y;
      var x1_body = (this._handles[0].screenPosition.x + this._handles[1].screenPosition.x) / 2; //second position: center of arrow
      var y1_body = (this._handles[0].screenPosition.y + this._handles[1].screenPosition.y) / 2;
      var x1_nose = this._handles[1].screenPosition.x; //third position: peak of arrow
      var y1_nose = this._handles[1].screenPosition.y;

      //calculate all the lengths to the label, so we can choose the min
      var lengthtaillabel = Math.sqrt((x1_tail - x2) * (x1_tail - x2) + (y1_tail - y2) * (y1_tail - y2));
      var lengthbodylabel = Math.sqrt((x1_body - x2) * (x1_body - x2) + (y1_body - y2) * (y1_body - y2));
      var lengthnoselabel = Math.sqrt((x1_nose - x2) * (x1_nose - x2) + (y1_nose - y2) * (y1_nose - y2));

      var lengths = [lengthtaillabel, lengthbodylabel, lengthnoselabel];
      var minlength = Math.min(lengthtaillabel, lengthbodylabel, lengthnoselabel);
      var minlengthindex = lengths.indexOf(minlength);

      if (minlengthindex == 0) {
        x1 = x1_tail;
        y1 = y1_tail;
      }
      if (minlengthindex == 1) {
        x1 = x1_body;
        y1 = y1_body;
      }
      if (minlengthindex == 2) {
        x1 = x1_nose;
        y1 = y1_nose;
      }

      // Once we found the closest point to the label, we create the dashed line from that point
      var lengthdashline = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angledashline = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

      var posYdashline = y1 - this._container.offsetHeight;

      // update dashed line
      var transformdashline = 'translate3D(' + x1 + 'px,' + posYdashline + 'px, 0)';
      transformdashline += ' rotate(' + angledashline + 'deg)';

      this._dashline.style.transform = transformdashline;
      this._dashline.style.width = lengthdashline + 'px';
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._line.style.backgroundColor = '' + this._color;
      this._dashline.style.borderTop = '2.5px dashed ' + ('' + this._color);
      this._label.style.borderColor = '' + this._color;
    }
  }, {
    key: 'worldPosition',
    get: function get() {
      return this._worldPosition;
    },
    set: function set(worldPosition) {
      this._worldPosition = worldPosition;
      this._handles[0].worldPosition = this._worldPosition;
      this._handles[1].worldPosition = this._worldPosition;

      this.update();
    }
  }]);

  return WidgetsAnnotation;
}(_widgets2.default);

exports.default = WidgetsAnnotation;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],166:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 *
 */
var WidgetsBase = function (_THREE$Object3D) {
  _inherits(WidgetsBase, _THREE$Object3D);

  function WidgetsBase(container) {
    _classCallCheck(this, WidgetsBase);

    // is widget enabled?
    var _this = _possibleConstructorReturn(this, (WidgetsBase.__proto__ || Object.getPrototypeOf(WidgetsBase)).call(this));
    // init THREE Object 3D


    _this._enabled = true;

    // STATE, ENUM might be better
    _this._selected = false;
    _this._hovered = false;
    _this._active = false;
    // thos._state = 'SELECTED';

    _this._colors = {
      default: '#00B0FF',
      active: '#FFEB3B',
      hover: '#F50057',
      select: '#76FF03'
    };
    _this._color = _this._colors.default;

    _this._dragged = false;
    // can not call it visible because it conflicts with THREE.Object3D
    _this._displayed = true;

    _this._container = container;
    return _this;
  }

  _createClass(WidgetsBase, [{
    key: 'initOffsets',
    value: function initOffsets() {
      var box = this._container.getBoundingClientRect();

      var body = document.body;
      var docEl = document.documentElement;

      var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
      var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;

      var clientTop = docEl.clientTop || body.clientTop || 0;
      var clientLeft = docEl.clientLeft || body.clientLeft || 0;

      var top = box.top + scrollTop - clientTop;
      var left = box.left + scrollLeft - clientLeft;

      this._offsets = {
        top: Math.round(top),
        left: Math.round(left)
      };
    }
  }, {
    key: 'offsetChanged',
    value: function offsetChanged() {
      this.initOffsets();
      this.update();
    }
  }, {
    key: 'getMouseOffsets',
    value: function getMouseOffsets(event, container) {
      return {
        x: (event.clientX - this._offsets.left) / container.offsetWidth * 2 - 1,
        y: -((event.clientY - this._offsets.top) / container.offsetHeight) * 2 + 1,
        screenX: event.clientX - this._offsets.left,
        screenY: event.clientY - this._offsets.top
      };
    }
  }, {
    key: 'update',
    value: function update() {
      // to be overloaded
      window.console.log('update() should be overloaded!');
    }
  }, {
    key: 'free',
    value: function free() {
      this._container = null;
    }
  }, {
    key: 'updateColor',
    value: function updateColor() {
      if (this._active) {
        this._color = this._colors.active;
      } else if (this._hovered) {
        this._color = this._colors.hover;
      } else if (this._selected) {
        this._color = this._colors.select;
      } else {
        this._color = this._colors.default;
      }
    }
  }, {
    key: 'enabled',
    get: function get() {
      return this._enabled;
    },
    set: function set(enabled) {
      this._enabled = enabled;
      this.update();
    }
  }, {
    key: 'selected',
    get: function get() {
      return this._selected;
    },
    set: function set(selected) {
      this._selected = selected;
      this.update();
    }
  }, {
    key: 'hovered',
    get: function get() {
      return this._hovered;
    },
    set: function set(hovered) {
      this._hovered = hovered;
      this.update();
    }
  }, {
    key: 'dragged',
    get: function get() {
      return this._dragged;
    },
    set: function set(dragged) {
      this._dragged = dragged;
      this.update();
    }
  }, {
    key: 'displayed',
    get: function get() {
      return this._displayed;
    },
    set: function set(displayed) {
      this._displayed = displayed;
      this.update();
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    },
    set: function set(active) {
      this._active = active;
      this.update();
    }
  }, {
    key: 'color',
    get: function get() {
      return this._color;
    },
    set: function set(color) {
      this._color = color;
      this.update();
    }
  }]);

  return WidgetsBase;
}(THREE.Object3D);

exports.default = WidgetsBase;

},{}],167:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsBiRuler = function (_WidgetsBase) {
    _inherits(WidgetsBiRuler, _WidgetsBase);

    function WidgetsBiRuler(targetMesh, controls, camera, container) {
        _classCallCheck(this, WidgetsBiRuler);

        var _this = _possibleConstructorReturn(this, (WidgetsBiRuler.__proto__ || Object.getPrototypeOf(WidgetsBiRuler)).call(this));

        _this._targetMesh = targetMesh;
        _this._controls = controls;
        _this._camera = camera;
        _this._container = container;

        _this._active = true;
        _this._initOrtho = false;

        _this._worldPosition = new THREE.Vector3();
        if (_this._targetMesh !== null) {
            _this._worldPosition = _this._targetMesh.position;
        }

        // mesh stuff
        _this._material = null;
        _this._geometry = null;
        _this._mesh = null;

        // dom stuff
        _this._line = null;
        _this._distance = null;

        // add handles
        _this._handles = [];

        // first handle
        var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        firstHandle.worldPosition = _this._worldPosition;
        firstHandle.hovered = true;
        _this.add(firstHandle);

        _this._handles.push(firstHandle);

        var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        secondHandle.worldPosition = _this._worldPosition;
        secondHandle.hovered = true;
        // active and tracking might be redundant
        secondHandle.active = true;
        secondHandle.tracking = true;
        _this.add(secondHandle);

        _this._handles.push(secondHandle);

        // third handle
        var thirdHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        thirdHandle.worldPosition = _this._worldPosition;
        thirdHandle.hovered = true;
        _this.add(thirdHandle);

        _this._handles.push(thirdHandle);

        // fourth handle
        var fourthHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        fourthHandle.worldPosition = _this._worldPosition;
        fourthHandle.hovered = true;
        _this.add(fourthHandle);

        _this._handles.push(fourthHandle);

        // Create ruler
        _this.create();

        _this.onMove = _this.onMove.bind(_this);
        _this.addEventListeners();

        _this._orientation = null;
        _this._slice = null;
        return _this;
    }

    _createClass(WidgetsBiRuler, [{
        key: 'addEventListeners',
        value: function addEventListeners() {
            this._container.addEventListener('mousewheel', this.onMove);
            this._container.addEventListener('DOMMouseScroll', this.onMove);
        }
    }, {
        key: 'onMove',
        value: function onMove(evt) {
            this._dragged = true;

            this._handles[0].onMove(evt);
            this._handles[1].onMove(evt);
            this._handles[2].onMove(evt);
            this._handles[3].onMove(evt);

            this._hovered = this._handles[0].hovered || this._handles[1].hovered || this._handles[2].hovered || this._handles[3].hovered;

            this.update();
        }
    }, {
        key: 'onStart',
        value: function onStart(evt) {
            this._dragged = false;

            this._handles[0].onStart(evt);
            this._handles[1].onStart(evt);
            this._handles[2].onStart(evt);
            this._handles[3].onStart(evt);

            this._active = this._handles[0].active || this._handles[1].active || this._handles[2].active || this._handles[3].active;
            this.update();
        }
    }, {
        key: 'onEnd',
        value: function onEnd(evt) {
            // First Handle
            this._handles[0].onEnd(evt);
            this._handles[2].onEnd(evt);
            this._handles[3].onEnd(evt);

            window.console.log(this);

            // Second Handle
            if (this._dragged || !this._handles[1].tracking) {
                this._handles[1].tracking = false;
                this._handles[1].onEnd(evt);
            } else {
                this._handles[1].tracking = false;
            }

            // State of ruler widget
            this._active = this._handles[0].active || this._handles[1].active || this._handles[2].active || this._handles[3].active;
            this.update();
        }
    }, {
        key: 'create',
        value: function create() {
            this.createMesh();
            this.createDOM();
        }
    }, {
        key: 'hideDOM',
        value: function hideDOM() {
            this._line.style.display = 'none';
            this._distance.style.display = 'none';
            this._line2.style.display = 'none';
            this._distance2.style.display = 'none';

            for (var index in this._handles) {
                this._handles[index].hideDOM();
            }

            this._dashline.style.display = 'none';
        }
    }, {
        key: 'showDOM',
        value: function showDOM() {
            this._line.style.display = '';
            this._distance.style.display = '';
            this._line2.style.display = '';
            this._distance2.style.display = '';

            for (var index in this._handles) {
                this._handles[index].showDOM();
            }

            this._dashline.style.display = '';
        }
    }, {
        key: 'hideMesh',
        value: function hideMesh() {
            this._mesh.visible = false;
            this._mesh2.visible = false;
            this._handles[0].visible = false;
            this._handles[1].visible = false;
            this._handles[2].visible = false;
            this._handles[3].visible = false;
        }
    }, {
        key: 'showMesh',
        value: function showMesh() {
            this._mesh.visible = true;
            this._mesh2.visible = true;
            this._handles[0].visible = true;
            this._handles[1].visible = true;
            this._handles[2].visible = true;
            this._handles[3].visible = true;
        }
    }, {
        key: 'show',
        value: function show() {
            this.showDOM();
            this.showMesh();
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.hideDOM();
            this.hideMesh();
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateColor();

            // mesh stuff
            this.updateMeshColor();
            this.updateMeshPosition();

            // DOM stuff
            this.updateDOMPosition();
            this.updateDOMColor();
        }
    }, {
        key: 'createMesh',
        value: function createMesh() {
            // geometry
            this._geometry = new THREE.Geometry();
            this._geometry.vertices.push(this._handles[0].worldPosition);
            this._geometry.vertices.push(this._handles[1].worldPosition);

            // geometry
            this._geometry2 = new THREE.Geometry();
            this._geometry2.vertices.push(this._handles[2].worldPosition);
            this._geometry2.vertices.push(this._handles[3].worldPosition);

            // material
            this._material = new THREE.LineBasicMaterial();
            this._material2 = new THREE.LineBasicMaterial();
            this.updateMeshColor();

            // mesh
            this._mesh = new THREE.Line(this._geometry, this._material);
            this._mesh.visible = true;
            this._mesh2 = new THREE.Line(this._geometry2, this._material2);
            this._mesh2.visible = true;

            // add it!
            this.add(this._mesh);
            this.add(this._mesh2);
        }
    }, {
        key: 'updateMeshColor',
        value: function updateMeshColor() {
            if (this._material) {
                this._material.color.set(this._color);
            }
            if (this._material2) {
                this._material2.color.set(this._color);
            }
        }
    }, {
        key: 'updateMeshPosition',
        value: function updateMeshPosition() {
            if (this._geometry) {
                this._geometry.verticesNeedUpdate = true;
            }
            if (this._geometry2) {
                this._geometry2.verticesNeedUpdate = true;
            }
        }
    }, {
        key: 'createDOM',
        value: function createDOM() {
            // add line!
            this._line = document.createElement('div');
            this._line.setAttribute('class', 'widgets handle line');
            this._line.style.position = 'absolute';
            this._line.style.transformOrigin = '0 100%';
            this._line.style.marginTop = '-1px';
            this._line.style.height = '2px';
            this._line.style.width = '3px';
            this._container.appendChild(this._line);

            // add distance!
            this._distance = document.createElement('div');
            this._distance.setAttribute('class', 'widgets handle distance');
            this._distance.style.border = '2px solid';
            this._distance.style.backgroundColor = '#F9F9F9';
            // this._distance.style.opacity = '0.5';
            this._distance.style.color = '#353535';
            this._distance.style.padding = '4px';
            this._distance.style.position = 'absolute';
            this._distance.style.transformOrigin = '0 100%';
            this._distance.innerHTML = 'Hello, world!';
            this._container.appendChild(this._distance);

            // add line!
            this._line2 = document.createElement('div');
            this._line2.setAttribute('class', 'widgets handle line');
            this._line2.style.position = 'absolute';
            this._line2.style.transformOrigin = '0 100%';
            this._line2.style.marginTop = '-1px';
            this._line2.style.height = '2px';
            this._line2.style.width = '3px';
            this._container.appendChild(this._line2);

            // add distance!
            this._distance2 = document.createElement('div');
            this._distance2.setAttribute('class', 'widgets handle distance');
            this._distance.style.border = '2px solid';
            this._distance.style.backgroundColor = '#F9F9F9';
            // this._distance2.style.opacity = '0.5';
            this._distance2.style.color = '#353535';
            this._distance2.style.padding = '4px';
            this._distance2.style.position = 'absolute';
            this._distance2.style.transformOrigin = '0 100%';
            this._distance2.innerHTML = 'Hello, world!';
            this._container.appendChild(this._distance2);

            // add dash line
            this._dashline = document.createElement('div');
            this._dashline.setAttribute('class', 'widgets handle dashline');
            this._dashline.style.position = 'absolute';
            this._dashline.style.border = 'none';
            this._dashline.style.borderTop = '2.5px dashed #F9F9F9';
            this._dashline.style.transformOrigin = '0 100%';
            this._dashline.style.height = '1px';
            this._dashline.style.width = '50%';
            this._container.appendChild(this._dashline);

            this.updateDOMColor();
        }
    }, {
        key: 'updateDOMPosition',
        value: function updateDOMPosition() {
            // update rulers lines and text!
            var x1 = this._handles[0].screenPosition.x;
            var y1 = this._handles[0].screenPosition.y;
            var x2 = this._handles[1].screenPosition.x;
            var y2 = this._handles[1].screenPosition.y;

            //let x0 = x1 + (x2 - x1)/2;
            //let y0 = y1 + (y2 - y1)/2;
            var x0 = x2;
            var y0 = y2;

            if (y1 >= y2) {
                y0 = y2 - 30;
            } else {
                y0 = y2 + 30;
            }

            var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            var posY = y1 - this._container.offsetHeight;

            // update line
            var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            this._line.style.transform = transform;
            this._line.style.width = length;

            // update distance
            var w0 = this._handles[0].worldPosition;
            var w1 = this._handles[1].worldPosition;

            this._distance.innerHTML = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2) + ' mm';
            this._distanceValue = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2);
            var posY0 = y0 - this._container.offsetHeight - this._distance.offsetHeight / 2;
            x0 -= this._distance.offsetWidth / 2;

            var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
            this._distance.style.transform = transform2;

            // update rulers lines 2 and text!
            var x3 = this._handles[2].screenPosition.x;
            var y3 = this._handles[2].screenPosition.y;
            var x4 = this._handles[3].screenPosition.x;
            var y4 = this._handles[3].screenPosition.y;

            //let x0 = x1 + (x2 - x1)/2;
            //let y0 = y1 + (y2 - y1)/2;
            var x02 = x4;
            var y02 = y4;

            if (y3 >= y4) {
                y02 = y4 - 30;
            } else {
                y02 = y4 + 30;
            }

            length = Math.sqrt((x3 - x4) * (x3 - x4) + (y3 - y4) * (y3 - y4));
            angle = Math.atan2(y4 - y3, x4 - x3) * 180 / Math.PI;

            posY = y3 - this._container.offsetHeight;

            // update line
            transform = 'translate3D(' + x3 + 'px,' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            this._line2.style.transform = transform;
            this._line2.style.width = length;

            // update distance
            var w02 = this._handles[2].worldPosition;
            var w12 = this._handles[3].worldPosition;

            this._distance2.innerHTML = Math.sqrt((w02.x - w12.x) * (w02.x - w12.x) + (w02.y - w12.y) * (w02.y - w12.y) + (w02.z - w12.z) * (w02.z - w12.z)).toFixed(2) + ' mm';
            this._distance2Value = Math.sqrt((w02.x - w12.x) * (w02.x - w12.x) + (w02.y - w12.y) * (w02.y - w12.y) + (w02.z - w12.z) * (w02.z - w12.z)).toFixed(2);
            var posY02 = y02 - this._container.offsetHeight - this._distance2.offsetHeight / 2;
            x02 -= this._distance2.offsetWidth / 2;

            transform2 = 'translate3D(' + Math.round(x02) + 'px,' + Math.round(posY02) + 'px, 0)';
            this._distance2.style.transform = transform2;

            // update dash line

            var l1center = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.5);
            var l2center = this.getPointInBetweenByPerc(this._handles[2].worldPosition, this._handles[3].worldPosition, 0.5);

            var screen1 = this._handles[0].worldToScreen(l1center, this._camera, this._container);
            var screen2 = this._handles[0].worldToScreen(l2center, this._camera, this._container);

            x1 = screen1.x;
            y1 = screen1.y;
            x2 = screen2.x;
            y2 = screen2.y;

            length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            posY = y1 - this._container.offsetHeight;

            // update line
            transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            this._dashline.style.transform = transform;
            this._dashline.style.width = length;
        }
    }, {
        key: 'updateDOMColor',
        value: function updateDOMColor() {
            this._line.style.backgroundColor = '' + this._color;
            this._distance.style.borderColor = '' + this._color;

            this._line2.style.backgroundColor = '' + this._color;
            this._distance2.style.borderColor = '' + this._color;
        }
    }, {
        key: 'getPointInBetweenByPerc',
        value: function getPointInBetweenByPerc(pointA, pointB, percentage) {

            var dir = pointB.clone().sub(pointA);
            var len = dir.length();
            dir = dir.normalize().multiplyScalar(len * percentage);
            return pointA.clone().add(dir);
        }
    }, {
        key: 'initOrtho',
        value: function initOrtho() {
            this._initOrtho = true;

            var pcenter = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.5);
            this._handles[2].worldPosition = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.25);
            this._handles[3].worldPosition = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.75);

            this._handles[2].worldPosition.x = pcenter.x - Math.sqrt((pcenter.y - this._handles[2].worldPosition.y) * (pcenter.y - this._handles[2].worldPosition.y));
            this._handles[2].worldPosition.y = pcenter.y + Math.sqrt((pcenter.x - this._handles[2].worldPosition.x) * (pcenter.x - this._handles[2].worldPosition.x));

            this._handles[3].worldPosition.x = pcenter.x + Math.sqrt((pcenter.y - this._handles[2].worldPosition.y) * (pcenter.y - this._handles[2].worldPosition.y));
            this._handles[3].worldPosition.y = pcenter.y - Math.sqrt((pcenter.x - this._handles[2].worldPosition.x) * (pcenter.x - this._handles[2].worldPosition.x));
        }
    }, {
        key: 'worldPosition',
        get: function get() {
            return this._worldPosition;
        },
        set: function set(worldPosition) {
            this._worldPosition = worldPosition;
            this._handles[0].worldPosition = this._worldPosition;
            this._handles[1].worldPosition = this._worldPosition;
            this._handles[2].worldPosition = this._worldPosition;
            this._handles[3].worldPosition = this._worldPosition;

            this.update();
        }
    }, {
        key: 'shotestDistance',
        get: function get() {
            return this._distanceValue < this._distance2Value ? this._distanceValue : this._distance2Value;
        }
    }, {
        key: 'longestDistance',
        get: function get() {
            return this._distanceValue > this._distance2Value ? this._distanceValue : this._distance2Value;
        }
    }]);

    return WidgetsBiRuler;
}(_widgets2.default);

exports.default = WidgetsBiRuler;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],168:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsHandle = function (_WidgetsBase) {
  _inherits(WidgetsHandle, _WidgetsBase);

  function WidgetsHandle(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsHandle);

    var _this = _possibleConstructorReturn(this, (WidgetsHandle.__proto__ || Object.getPrototypeOf(WidgetsHandle)).call(this, container));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    // if no target mesh, use plane for FREE dragging.
    _this._plane = {
      position: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };
    _this._offset = new THREE.Vector3();
    _this._raycaster = new THREE.Raycaster();

    _this._tracking = false;

    _this._mouse = new THREE.Vector2();
    _this._lastEvent = null;

    // world (LPS) position of this handle
    _this._worldPosition = new THREE.Vector3();

    // screen position of this handle
    _this._screenPosition = new THREE.Vector2();

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;
    _this._meshDisplayed = true;
    _this._meshHovered = false;
    _this._meshStyle = 'sphere'; // cube, etc.

    // dom stuff
    _this._dom = null;
    _this._domDisplayed = true;
    _this._domHovered = false;
    _this._domStyle = 'circle'; // square, triangle

    if (_this._targetMesh !== null) {
      _this._worldPosition.copy(_this._targetMesh.position);
    }

    _this._screenPosition = _this.worldToScreen(_this._worldPosition, _this._camera, _this._container);

    // create handle
    _this.create();
    _this.initOffsets();

    // event listeners
    _this.onMove = _this.onMove.bind(_this);
    _this.onHover = _this.onHover.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsHandle, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._dom.addEventListener('mouseenter', this.onHover);
      this._dom.addEventListener('mouseleave', this.onHover);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._dom.removeEventListener('mouseenter', this.onHover);
      this._dom.removeEventListener('mouseleave', this.onHover);

      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      console.log(evt);
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);
      console.log(this._mouse);

      // update raycaster
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._hovered) {
        this._active = true;
        this._controls.enabled = false;

        if (this._targetMesh) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._offset.copy(intersectsTarget[0].point).sub(this._worldPosition);
          }
        } else {
          this._plane.position.copy(this._worldPosition);
          this._plane.direction.copy(this._camera.getWorldDirection());
          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._offset.copy(intersection).sub(this._plane.position);
          }
        }

        this.update();
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      // stay active and keep controls disabled
      if (this._tracking === true) {
        return;
      }

      // unselect if go up without moving
      if (!this._dragged && this._active) {
        // change state if was not dragging
        this._selected = !this._selected;
      }

      this._active = false;
      this._dragged = false;
      this._controls.enabled = true;

      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }

    /**
     *
     *
     */

  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      // set ray.position to satisfy CoreIntersections::rayPlane API
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._active) {
        this._dragged = true;

        if (this._targetMesh !== null) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._worldPosition.copy(intersectsTarget[0].point.sub(this._offset));
          }
        } else {
          if (this._plane.direction.length() === 0) {
            // free mode!this._targetMesh
            this._plane.position.copy(this._worldPosition);
            this._plane.direction.copy(this._camera.getWorldDirection());
          }

          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._worldPosition.copy(intersection.sub(this._offset));
          }
        }
      } else {
        this.onHover(null);
      }

      this.update();
    }
  }, {
    key: 'onHover',
    value: function onHover(evt) {
      if (evt) {
        this._lastEvent = evt;
        evt.preventDefault();
        this.hoverDom(evt);
      }

      this.hoverMesh();

      this._hovered = this._meshHovered || this._domHovered;
      this._container.style.cursor = this._hovered ? 'pointer' : 'default';
    }
  }, {
    key: 'update',
    value: function update() {
      // general update
      this.updateColor();

      // update screen position of handle
      this._screenPosition = this.worldToScreen(this._worldPosition, this._camera, this._container);

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMColor();
      this.updateDOMPosition();
    }

    //

  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._mesh) {
        this._mesh.position.x = this._worldPosition.x;
        this._mesh.position.y = this._worldPosition.y;
        this._mesh.position.z = this._worldPosition.z;
      }
    }
  }, {
    key: 'hoverMesh',
    value: function hoverMesh() {
      // check raycast intersection, do we want to hover on mesh or just css?
      var intersectsHandle = this._raycaster.intersectObject(this._mesh);
      this._meshHovered = intersectsHandle.length > 0;
    }
  }, {
    key: 'hoverDom',
    value: function hoverDom(evt) {
      this._domHovered = evt.type === 'mouseenter';
    }
  }, {
    key: 'worldToScreen',
    value: function worldToScreen(worldCoordinate, camera, canvas) {
      var screenCoordinates = worldCoordinate.clone();
      screenCoordinates.project(camera);

      screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);
      screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);
      screenCoordinates.z = 0;

      return screenCoordinates;
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.SphereGeometry(1, 16, 16);

      // material
      this._material = new THREE.MeshBasicMaterial({
        wireframe: true,
        wireframeLinewidth: 2
      });

      // mesh
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.position.x = this._worldPosition.x;
      this._mesh.position.y = this._worldPosition.y;
      this._mesh.position.z = this._worldPosition.z;
      this._mesh.visible = true;

      this.updateMeshColor();

      // add it!
      this.add(this._mesh);
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // dom
      this._dom = document.createElement('div');
      this._dom.setAttribute('id', this.uuid);
      this._dom.setAttribute('class', 'AMI Widget Handle');
      this._dom.style.border = '2px solid';
      this._dom.style.backgroundColor = '#F9F9F9';
      this._dom.style.color = '#F9F9F9';
      this._dom.style.position = 'absolute';
      this._dom.style.width = '12px';
      this._dom.style.height = '12px';
      this._dom.style.margin = '-6px';
      this._dom.style.borderRadius = '50%';
      this._dom.style.transformOrigin = '0 100%';

      var posY = this._screenPosition.y - this._container.offsetHeight;
      this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';

      this.updateDOMColor();

      // add it!
      this._container.appendChild(this._dom);
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      if (this._dom) {
        var posY = this._screenPosition.y - this._container.offsetHeight;
        this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';
      }
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._dom.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      // threejs stuff

      // dom
      this._container.removeChild(this._dom);
      // event
      this.removeEventListeners();

      _get(WidgetsHandle.prototype.__proto__ || Object.getPrototypeOf(WidgetsHandle.prototype), 'free', this).call(this);
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._dom.style.display = 'none';
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._dom.style.display = '';
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'worldPosition',
    set: function set(worldPosition) {
      this._worldPosition.copy(worldPosition);

      this.update();
    },
    get: function get() {
      return this._worldPosition;
    }
  }, {
    key: 'screenPosition',
    set: function set(screenPosition) {
      this._screenPosition = screenPosition;
    },
    get: function get() {
      return this._screenPosition;
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    },
    set: function set(active) {
      this._active = active;
      // this._tracking = this._active;
      this._controls.enabled = !this._active;

      this.update();
    }
  }, {
    key: 'tracking',
    get: function get() {
      return this._tracking;
    },
    set: function set(tracking) {
      this._tracking = tracking;
      this.update();
    }
  }]);

  return WidgetsHandle;
}(_widgets2.default);

exports.default = WidgetsHandle;

},{"../core/core.intersections":102,"../widgets/widgets.base":166}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _widgets = require('./widgets.annotation');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('./widgets.biruler');

var _widgets4 = _interopRequireDefault(_widgets3);

var _widgets5 = require('./widgets.handle');

var _widgets6 = _interopRequireDefault(_widgets5);

var _widgets7 = require('./widgets.roi');

var _widgets8 = _interopRequireDefault(_widgets7);

var _widgets9 = require('./widgets.ruler');

var _widgets10 = _interopRequireDefault(_widgets9);

var _widgets11 = require('./widgets.voxelProbe');

var _widgets12 = _interopRequireDefault(_widgets11);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module widgets
 */

exports.default = {
  Annotation: _widgets2.default,
  BiRuler: _widgets4.default,
  Handle: _widgets6.default,
  Roi: _widgets8.default,
  Ruler: _widgets10.default,
  VoxelProbe: _widgets12.default
};

},{"./widgets.annotation":165,"./widgets.biruler":167,"./widgets.handle":168,"./widgets.roi":170,"./widgets.ruler":171,"./widgets.voxelProbe":172}],170:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsRoi = function (_WidgetsBase) {
    _inherits(WidgetsRoi, _WidgetsBase);

    function WidgetsRoi(targetMesh, controls, camera, container) {
        _classCallCheck(this, WidgetsRoi);

        var _this = _possibleConstructorReturn(this, (WidgetsRoi.__proto__ || Object.getPrototypeOf(WidgetsRoi)).call(this));

        _this._targetMesh = targetMesh;
        _this._controls = controls;
        _this._camera = camera;
        _this._container = container;

        _this._active = true;
        _this._init = false;

        _this._worldPosition = new THREE.Vector3();
        if (_this._targetMesh !== null) {
            _this._worldPosition = _this._targetMesh.position;
        }

        // mesh stuff
        _this._material = null;
        _this._geometry = null;
        _this._mesh = null;

        // dom stuff
        _this._lines = [];
        _this._area = null;

        // add handles
        _this._handles = [];

        // first handle
        var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        firstHandle.worldPosition = _this._worldPosition;
        firstHandle.hovered = true;
        _this.add(firstHandle);

        _this._handles.push(firstHandle);

        // Create ruler
        _this.create();

        _this.onMove = _this.onMove.bind(_this);
        _this.addEventListeners();

        _this._orientation = null;
        _this._slice = null;
        return _this;
    }

    _createClass(WidgetsRoi, [{
        key: 'addEventListeners',
        value: function addEventListeners() {
            this._container.addEventListener('mousewheel', this.onMove);
            this._container.addEventListener('DOMMouseScroll', this.onMove);
        }
    }, {
        key: 'onMove',
        value: function onMove(evt) {
            this._dragged = true;
            var numHandles = this._handles.length;

            if (this.active && !this._init) {
                var lastHandle = this._handles[numHandles - 1];
                lastHandle.hovered = false;
                lastHandle.active = false;
                lastHandle.tracking = false;

                var nextHandle = new _widgets4.default(this._targetMesh, this._controls, this._camera, this._container);
                nextHandle.worldPosition = this._worldPosition;
                nextHandle.hovered = true;
                nextHandle.active = true;
                nextHandle.tracking = true;
                this.add(nextHandle);

                this._handles.push(nextHandle);

                var newLine = document.createElement('div');
                newLine.setAttribute('class', 'widgets handle line');
                newLine.style.position = 'absolute';
                newLine.style.transformOrigin = '0 100%';
                newLine.style.marginTop = '-1px';
                newLine.style.height = '2px';
                newLine.style.width = '3px';
                newLine.style.backgroundColor = '#F9F9F9';

                this._lines.push(newLine);
                this._container.appendChild(newLine);
            }

            var hovered = false;

            for (var index in this._handles) {
                this._handles[index].onMove(evt);
                hovered = hovered || this._handles[index].hovered;
            }

            this._hovered = hovered;

            if (this.active && numHandles > 2) {
                this.pushPopHandle();
            }

            this.update();
        }
    }, {
        key: 'onStart',
        value: function onStart(evt) {
            this._dragged = false;

            var active = false;

            for (var index in this._handles) {
                this._handles[index].onStart(evt);
                active = active || this._handles[index].active;
            }

            this._active = active;
            this.update();
        }
    }, {
        key: 'onEnd',
        value: function onEnd(evt) {
            // First Handle
            var active = false;
            for (var index in this._handles.slice(0, this._handles.length - 2)) {
                this._handles[index].onEnd(evt);
                active = active || this._handles[index].active;
            }

            // Second Handle
            if (this._dragged || !this._handles[this._handles.length - 1].tracking) {
                this._handles[this._handles.length - 1].tracking = false;
                this._handles[this._handles.length - 1].onEnd(evt);
            } else {
                this._handles[this._handles.length - 1].tracking = false;
            }

            active = active || this._handles[this._handles.length - 1].active;
            // State of ruler widget
            this._active = active;

            var newLine = document.createElement('div');
            newLine.setAttribute('class', 'widgets handle line');
            newLine.style.position = 'absolute';
            newLine.style.transformOrigin = '0 100%';
            newLine.style.marginTop = '-1px';
            newLine.style.height = '2px';
            newLine.style.width = '3px';
            newLine.style.backgroundColor = '#F9F9F9';

            this._lines.push(newLine);
            this._container.appendChild(newLine);

            this._init = true;
            this.update();
        }
    }, {
        key: 'create',
        value: function create() {
            this.createMesh();
            this.createDOM();
        }
    }, {
        key: 'hideDOM',
        value: function hideDOM() {
            for (var index in this._handles) {
                this._handles[index].hideDOM();
            }

            for (var _index in this._lines) {
                this._lines[_index].style.display = 'none';
            }
        }
    }, {
        key: 'showDOM',
        value: function showDOM() {
            for (var index in this._handles) {
                this._handles[index].showDOM();
            }

            for (var _index2 in this._lines) {
                this._lines[_index2].style.display = '';
            }
        }
    }, {
        key: 'hideMesh',
        value: function hideMesh() {
            this.visible = false;
        }
    }, {
        key: 'showMesh',
        value: function showMesh() {
            this.visible = true;
        }
    }, {
        key: 'show',
        value: function show() {
            this.showDOM();
            this.showMesh();
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.hideDOM();
            this.hideMesh();
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateColor();

            for (var index in this._handles) {
                this._handles[index].update();
            }

            // mesh stuff
            this.updateMeshColor();
            this.updateMeshPosition();

            // DOM stuff
            this.updateDOMPosition();
            this.updateDOMColor();
        }
    }, {
        key: 'createMesh',
        value: function createMesh() {
            // geometry
            this._geometry = new THREE.Geometry();
            for (var index in this._handles) {
                this._geometry.vertices.push(this._handles[index].worldPosition);
            }

            // material
            this._material = new THREE.LineBasicMaterial();
            this.updateMeshColor();

            // mesh
            this._mesh = new THREE.Line(this._geometry, this._material);
            this._mesh.visible = true;

            // add it!
            this.add(this._mesh);
        }
    }, {
        key: 'updateMeshColor',
        value: function updateMeshColor() {
            if (this._material) {
                this._material.color.set(this._color);
            }
        }
    }, {
        key: 'updateMeshPosition',
        value: function updateMeshPosition() {
            if (this._geometry) {
                this._geometry.verticesNeedUpdate = true;
            }
        }
    }, {
        key: 'createDOM',
        value: function createDOM() {
            // add line!
            this._line = document.createElement('div');
            this._line.setAttribute('class', 'widgets handle line');
            this._line.style.position = 'absolute';
            this._line.style.transformOrigin = '0 100%';
            this._line.style.marginTop = '-1px';
            this._line.style.height = '2px';
            this._line.style.width = '3px';
            this._container.appendChild(this._line);

            // add distance!
            this._distance = document.createElement('div');
            this._distance.setAttribute('class', 'widgets handle distance');
            this._distance.style.border = '2px solid';
            this._distance.style.backgroundColor = '#F9F9F9';
            // this._distance.style.opacity = '0.5';
            this._distance.style.color = '#353535';
            this._distance.style.padding = '4px';
            this._distance.style.position = 'absolute';
            this._distance.style.transformOrigin = '0 100%';
            this._distance.innerHTML = 'Hello, world!';
            this._container.appendChild(this._distance);

            this.updateDOMColor();
        }
    }, {
        key: 'isPointOnLine',
        value: function isPointOnLine(pointA, pointB, pointToCheck) {
            var c = new THREE.Vector3();
            c.crossVectors(pointA.clone().sub(pointToCheck), pointB.clone().sub(pointToCheck));
            return !c.length();
        }
    }, {
        key: 'pushPopHandle',
        value: function pushPopHandle() {
            var handle0 = this._handles[this._handles.length - 3];
            var handle1 = this._handles[this._handles.length - 2];
            var newhandle = this._handles[this._handles.length - 1];

            var isOnLine = this.isPointOnLine(handle0.worldPosition, handle1.worldPosition, newhandle.worldPosition);

            if (isOnLine) {
                handle1._dom.style.display = 'none';
                this.remove(handle1);

                this._handles[this._handles.length - 2] = newhandle;
                this._handles.pop();

                var tempLine = this._lines.pop();
                tempLine.style.display = 'none';
                this._container.removeChild(tempLine);
            }

            return isOnLine;
        }
    }, {
        key: 'updateLineDOM',
        value: function updateLineDOM(lineIndex, handle0Index, handle1Index) {
            // update rulers lines and text!
            var x1 = this._handles[handle0Index].screenPosition.x;
            var y1 = this._handles[handle0Index].screenPosition.y;
            var x2 = this._handles[handle1Index].screenPosition.x;
            var y2 = this._handles[handle1Index].screenPosition.y;

            var x0 = x2;
            var y0 = y2;

            if (y1 >= y2) {
                y0 = y2 - 30;
            } else {
                y0 = y2 + 30;
            }

            var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            var posY = y1 - this._container.offsetHeight;

            // update line
            var transform = 'translate3D(' + x1 + 'px, ' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            //this._lines[lineIndex].style.display = '';
            this._lines[lineIndex].style.transform = transform;
            this._lines[lineIndex].style.width = length;
        }
    }, {
        key: 'updateDOMPosition',
        value: function updateDOMPosition() {
            if (this._handles.length >= 2) {
                for (var index in this._lines) {
                    this.updateLineDOM(index, index, parseInt(index) + 1 == this._handles.length ? 0 : parseInt(index) + 1);
                }
            }
        }
    }, {
        key: 'updateDOMColor',
        value: function updateDOMColor() {
            this._line.style.backgroundColor = '' + this._color;
            this._distance.style.borderColor = '' + this._color;
        }
    }, {
        key: 'getPointInBetweenByPerc',
        value: function getPointInBetweenByPerc(pointA, pointB, percentage) {

            var dir = pointB.clone().sub(pointA);
            var len = dir.length();
            dir = dir.normalize().multiplyScalar(len * percentage);
            return pointA.clone().add(dir);
        }
    }, {
        key: 'worldPosition',
        get: function get() {
            return this._worldPosition;
        },
        set: function set(worldPosition) {
            this._worldPosition = worldPosition;

            for (var index in this._handles) {
                this._handles[index]._worldPosition = this._worldPosition;
            }

            this.update();
        }
    }]);

    return WidgetsRoi;
}(_widgets2.default);

exports.default = WidgetsRoi;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],171:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsRuler = function (_WidgetsBase) {
  _inherits(WidgetsRuler, _WidgetsBase);

  function WidgetsRuler(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsRuler);

    var _this = _possibleConstructorReturn(this, (WidgetsRuler.__proto__ || Object.getPrototypeOf(WidgetsRuler)).call(this, container));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    _this._active = true;
    _this._lastEvent = null;

    _this._worldPosition = new THREE.Vector3();
    if (_this._targetMesh !== null) {
      _this._worldPosition = _this._targetMesh.position;
    }

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // dom stuff
    _this._line = null;
    _this._distance = null;

    // add handles
    _this._handles = [];

    // first handle
    var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    firstHandle.worldPosition = _this._worldPosition;
    firstHandle.hovered = true;
    _this.add(firstHandle);

    _this._handles.push(firstHandle);

    var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    secondHandle.worldPosition = _this._worldPosition;
    secondHandle.hovered = true;
    // active and tracking might be redundant
    secondHandle.active = true;
    secondHandle.tracking = true;
    _this.add(secondHandle);

    _this._handles.push(secondHandle);

    // Create ruler
    _this.create();
    _this.initOffsets();

    _this.onMove = _this.onMove.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsRuler, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      this._dragged = true;

      this._handles[0].onMove(evt);
      this._handles[1].onMove(evt);

      this._hovered = this._handles[0].hovered || this._handles[1].hovered;
      this.update();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      this._lastEvent = evt;
      this._dragged = false;

      this._handles[0].onStart(evt);
      this._handles[1].onStart(evt);

      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      // First Handle
      this._handles[0].onEnd(evt);

      // window.console.log(this);

      // Second Handle
      if (this._dragged || !this._handles[1].tracking) {
        this._handles[1].tracking = false;
        this._handles[1].onEnd(evt);
      } else {
        this._handles[1].tracking = false;
      }

      // State of ruler widget
      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._line.style.display = 'none';
      this._distance.style.display = 'none';
      for (var index in this._handles) {
        this._handles[index].hideDOM();
      }
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._line.style.display = '';
      this._distance.style.display = '';
      for (var index in this._handles) {
        this._handles[index].showDOM();
      }
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'update',
    value: function update() {
      this.updateColor();

      // update handles
      this._handles[0].update();
      this._handles[1].update();

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMColor();
      this.updateDOMPosition();
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.Geometry();
      this._geometry.vertices.push(this._handles[0].worldPosition);
      this._geometry.vertices.push(this._handles[1].worldPosition);

      // material
      this._material = new THREE.LineBasicMaterial();
      this.updateMeshColor();

      // mesh
      this._mesh = new THREE.Line(this._geometry, this._material);
      this._mesh.visible = true;

      // add it!
      this.add(this._mesh);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._geometry) {
        this._geometry.verticesNeedUpdate = true;
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // add line!
      this._line = document.createElement('div');
      this._line.setAttribute('id', this.uuid);
      this._line.setAttribute('class', 'AMI Widget Ruler');
      this._line.style.position = 'absolute';
      this._line.style.transformOrigin = '0 100%';
      this._line.style.marginTop = '-1px';
      this._line.style.height = '2px';
      this._line.style.width = '3px';
      this._container.appendChild(this._line);

      // add distance!
      this._distance = document.createElement('div');
      this._distance.setAttribute('class', 'widgets handle distance');
      this._distance.style.border = '2px solid';
      this._distance.style.backgroundColor = '#F9F9F9';
      // this._distance.style.opacity = '0.5';
      this._distance.style.color = '#353535';
      this._distance.style.padding = '4px';
      this._distance.style.position = 'absolute';
      this._distance.style.transformOrigin = '0 100%';
      this._distance.innerHTML = 'Hello, world!';
      this._container.appendChild(this._distance);

      this.updateDOMColor();
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      // update rulers lines and text!
      var x1 = this._handles[0].screenPosition.x;
      var y1 = this._handles[0].screenPosition.y;
      var x2 = this._handles[1].screenPosition.x;
      var y2 = this._handles[1].screenPosition.y;

      //let x0 = x1 + (x2 - x1)/2;
      //let y0 = y1 + (y2 - y1)/2;
      var x0 = x2;
      var y0 = y2;

      if (y1 >= y2) {
        y0 = y2 - 30;
      } else {
        y0 = y2 + 30;
      }

      var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

      var posY = y1 - this._container.offsetHeight;

      // update line
      var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
      transform += ' rotate(' + angle + 'deg)';

      this._line.style.transform = transform;
      this._line.style.width = length;

      // update distance
      var w0 = this._handles[0].worldPosition;
      var w1 = this._handles[1].worldPosition;

      this._distance.innerHTML = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2) + ' mm';
      var posY0 = y0 - this._container.offsetHeight - this._distance.offsetHeight / 2;
      x0 -= this._distance.offsetWidth / 2;

      var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
      this._distance.style.transform = transform2;
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._line.style.backgroundColor = '' + this._color;
      this._distance.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._handles.forEach(function (h) {
        h.free();
      });

      this._handles = [];

      this._container.removeChild(this._line);
      this._container.removeChild(this._distance);

      this.remove(this._mesh);

      _get(WidgetsRuler.prototype.__proto__ || Object.getPrototypeOf(WidgetsRuler.prototype), 'free', this).call(this);
    }
  }, {
    key: 'worldPosition',
    get: function get() {
      return this._worldPosition;
    },
    set: function set(worldPosition) {
      this._worldPosition = worldPosition;
      this._handles[0].worldPosition = this._worldPosition;
      this._handles[1].worldPosition = this._worldPosition;

      this.update();
    }
  }]);

  return WidgetsRuler;
}(_widgets2.default);

exports.default = WidgetsRuler;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],172:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _geometries = require('../geometries/geometries.voxel');

var _geometries2 = _interopRequireDefault(_geometries);

var _models = require('../models/models.stack');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('../models/models.voxel');

var _models4 = _interopRequireDefault(_models3);

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/voxelProbe
 */

var WidgetsVoxelProbe = function (_WidgetsBase) {
  _inherits(WidgetsVoxelProbe, _WidgetsBase);

  function WidgetsVoxelProbe(stack, targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsVoxelProbe);

    var _this = _possibleConstructorReturn(this, (WidgetsVoxelProbe.__proto__ || Object.getPrototypeOf(WidgetsVoxelProbe)).call(this, container));

    _this._stack = stack;

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    // if no target mesh, use plane for FREE dragging.
    _this._plane = {
      position: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };

    _this._offset = new THREE.Vector3();
    _this._raycaster = new THREE.Raycaster();

    _this._tracking = false;

    _this._mouse = new THREE.Vector2();
    _this._lastEvent = null;

    // world (LPS) position of the center
    _this._worldPosition = new THREE.Vector3();

    // screen position of the center
    _this._screenPosition = new THREE.Vector2();

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;
    _this._meshDisplayed = true;
    _this._meshHovered = false;
    _this._meshStyle = 'sphere'; // cube, etc.

    // dom stuff
    _this._dom = null;
    _this._domDisplayed = true;
    _this._domHovered = false;
    _this._domStyle = 'circle'; // square, triangle

    if (_this._targetMesh !== null) {
      _this._worldPosition.copy(_this._targetMesh.position);
    }

    _this._screenPosition = _this.worldToScreen(_this._worldPosition, _this._camera, _this._container);

    // create handle
    _this.create();
    _this.initOffsets();

    // event listeners
    _this.onMove = _this.onMove.bind(_this);
    _this.onHover = _this.onHover.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsVoxelProbe, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._dom.addEventListener('mouseenter', this.onHover);
      this._dom.addEventListener('mouseleave', this.onHover);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._dom.removeEventListener('mouseenter', this.onHover);
      this._dom.removeEventListener('mouseleave', this.onHover);

      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._hovered) {
        this._active = true;
        this._controls.enabled = false;

        if (this._targetMesh) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._offset.copy(intersectsTarget[0].point).sub(this._worldPosition);
          }
        } else {
          this._plane.position.copy(this._worldPosition);
          this._plane.direction.copy(this._camera.getWorldDirection());
          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._offset.copy(intersection).sub(this._plane.position);
          }
        }

        this.update();
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      // stay active and keep controls disabled
      if (this._tracking === true) {
        return;
      }

      // unselect if go up without moving
      if (!this._dragged && this._active) {
        // change state if was not dragging
        this._selected = !this._selected;
      }

      this._active = false;
      this._dragged = false;
      this._controls.enabled = true;

      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      // set ray.position to satisfy CoreIntersections::rayPlane API
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._active) {
        this._dragged = true;

        if (this._targetMesh !== null) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._worldPosition.copy(intersectsTarget[0].point.sub(this._offset));
          }
        } else {
          if (this._plane.direction.length() === 0) {
            // free mode!this._targetMesh
            this._plane.position.copy(this._worldPosition);
            this._plane.direction.copy(this._camera.getWorldDirection());
          }

          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._worldPosition.copy(intersection.sub(this._offset));
          }
        }
      } else {
        this.onHover(null);
      }

      this.update();
    }
  }, {
    key: 'onHover',
    value: function onHover(evt) {
      if (evt) {
        this._lastEvent = evt;
        evt.preventDefault();
        this.hoverDom(evt);
      }

      this.hoverMesh();

      this._hovered = this._meshHovered || this._domHovered;
      this._container.style.cursor = this._hovered ? 'pointer' : 'default';
    }
  }, {
    key: 'hoverMesh',
    value: function hoverMesh() {
      // check raycast intersection, do we want to hover on mesh or just css?
      var intersectsHandle = this._raycaster.intersectObject(this._mesh);
      this._meshHovered = intersectsHandle.length > 0;
    }
  }, {
    key: 'hoverDom',
    value: function hoverDom(evt) {
      this._domHovered = evt.type === 'mouseenter';
    }
  }, {
    key: 'worldToScreen',
    value: function worldToScreen(worldCoordinate, camera, canvas) {
      var screenCoordinates = worldCoordinate.clone();
      screenCoordinates.project(camera);

      screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);
      screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);
      screenCoordinates.z = 0;

      return screenCoordinates;
    }
  }, {
    key: 'create',
    value: function create() {
      this.createVoxel();
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'createVoxel',
    value: function createVoxel() {
      this._voxel = new _models4.default();
      this._voxel.id = this.id;
      this._voxel.worldCoordinates = this._worldCoordinates;
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      var dataCoordinates = _models2.default.worldToData(this._stack, this._worldPosition);

      this._geometry = new _geometries2.default(dataCoordinates);
      this._material = new THREE.MeshBasicMaterial({
        wireframe: true,
        wireframeLinewidth: 1
      });
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.applyMatrix(this._stack.ijk2LPS);
      this._mesh.visible = true;

      this.updateMeshColor();

      this.add(this._mesh);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // dom
      this._dom = document.createElement('div');
      this._dom.setAttribute('id', this.uuid);
      this._dom.setAttribute('class', 'AMI Widget VoxelProbe');
      this._dom.style.border = '2px solid #000';
      this._dom.style.backgroundColor = 'rgb(249, 249, 249)';
      this._dom.style.color = '#212121';
      this._dom.style.position = 'absolute';
      this._dom.style.transformOrigin = '0px 100% 0px';

      // measurenents
      var measurementsContainer = document.createElement('div');
      // LPS
      var lpsContainer = document.createElement('div');
      lpsContainer.setAttribute('id', 'lpsPosition');
      measurementsContainer.appendChild(lpsContainer);
      // IJK
      var ijkContainer = document.createElement('div');
      ijkContainer.setAttribute('id', 'ijkPosition');
      measurementsContainer.appendChild(ijkContainer);
      // Value
      var valueContainer = document.createElement('div');
      valueContainer.setAttribute('id', 'value');
      measurementsContainer.appendChild(valueContainer);

      this.updateDOMColor();
      this._dom.appendChild(measurementsContainer);

      // add it!
      this._container.appendChild(this._dom);
    }
  }, {
    key: 'updateDOMContent',
    value: function updateDOMContent() {
      var rasContainer = this._dom.querySelector('#lpsPosition');
      rasContainer.innerHTML = 'LPS: \n      ' + this._voxel.worldCoordinates.x.toFixed(2) + ' :\n      ' + this._voxel.worldCoordinates.y.toFixed(2) + ' :\n      ' + this._voxel.worldCoordinates.z.toFixed(2);

      var ijkContainer = this._dom.querySelector('#ijkPosition');
      ijkContainer.innerHTML = 'IJK: \n      ' + this._voxel.dataCoordinates.x + ' :\n      ' + this._voxel.dataCoordinates.y + ' :\n      ' + this._voxel.dataCoordinates.z;

      var valueContainer = this._dom.querySelector('#value');
      valueContainer.innerHTML = 'Value: ' + this._voxel.value;
    }
  }, {
    key: 'update',
    value: function update() {
      // general update
      this.updateColor();
      this._screenPosition = this.worldToScreen(this._worldPosition, this._camera, this._container);

      // set data coordinates && value
      this.updateVoxel(this._worldPosition);

      // update mesh position
      this.updateMeshColor();
      if (this._mesh && this._mesh.geometry) {
        this._mesh.geometry.location = this._voxel.dataCoordinates;
        this._mesh.updateMatrix();
      }

      // update dom
      this.updateDOMContent();
      this.updateDOMColor();
      this.updateDOMPosition();
    }
  }, {
    key: 'updateVoxel',
    value: function updateVoxel(worldCoordinates) {
      // update world coordinates
      this._voxel.worldCoordinates = worldCoordinates;

      // update data coordinates
      this._voxel.dataCoordinates = _models2.default.worldToData(this._stack, this._voxel.worldCoordinates);

      // update value
      var value = _models2.default.value(this._stack, this._voxel.dataCoordinates);

      this._voxel.value = _models2.default.valueRescaleSlopeIntercept(value, this._stack.rescaleSlope, this._stack.rescaleIntercept);
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      if (this._dom) {
        var posY = this._screenPosition.y - this._container.offsetHeight;
        this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';
      }
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._dom.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      this._container.removeEventListener('mouseup', this.onMouseUpHandler, false);
      this._container.removeEventListener('mousemove', this.onMouseMoveHandler, false);

      this._container.removeEventListener('mousewheel', this.onMouseMoveHandler, false);
      this._container.removeEventListener('DOMMouseScroll', this.onMouseMoveHandler, false);

      this._voxel.removeTest();
      this.remove(this._voxel);
      this._voxel = null;

      _get(WidgetsVoxelProbe.prototype.__proto__ || Object.getPrototypeOf(WidgetsVoxelProbe.prototype), 'free', this).call(this);
    }
  }, {
    key: 'hoverVoxel',
    value: function hoverVoxel(mouseScreenCoordinates, currentDataCoordinates) {
      // update distance mouse/this._voxel
      var dx = mouseScreenCoordinates.screenX - this._voxel.voxel.screenCoordinates.x;
      var dy = mouseScreenCoordinates.screenY - this._voxel.voxel.screenCoordinates.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      this._voxel.distance = distance;
      if (distance >= 0 && distance < 10) {
        this._hover = true;
      } else {
        this._hover = false;
      }
    }
  }, {
    key: 'worldPosition',
    set: function set(worldPosition) {
      this._worldPosition.copy(worldPosition);
      this.update();
    }
  }, {
    key: 'defaultColor',
    set: function set(defaultColor) {
      this._defaultColor = defaultColor;
      this.update();
    },
    get: function get() {
      return this._defaultColor;
    }
  }, {
    key: 'activeColor',
    set: function set(activeColor) {
      this._activeColor = activeColor;
      this.update();
    },
    get: function get() {
      return this._activeColor;
    }
  }, {
    key: 'hoverColor',
    set: function set(hoverColor) {
      this._hoverColor = hoverColor;
      this.update();
    },
    get: function get() {
      return this._hoverColor;
    }
  }, {
    key: 'selectedColor',
    set: function set(selectedColor) {
      this._selectedColor = selectedColor;
      this.update();
    },
    get: function get() {
      return this._selectedColor;
    }
  }, {
    key: 'showVoxel',
    set: function set(showVoxel) {
      this._showVoxel = showVoxel;
      this.update();
    },
    get: function get() {
      return this._showVoxel;
    }
  }, {
    key: 'showDomSVG',
    set: function set(showDomSVG) {
      this._showDomSVG = showDomSVG;
      this.update();
    },
    get: function get() {
      return this._showDomSVG;
    }
  }, {
    key: 'showDomMeasurements',
    set: function set(showDomMeasurements) {
      this._showDomMeasurements = showDomMeasurements;
      this.update();
    },
    get: function get() {
      return this._showDomMeasurements;
    }
  }]);

  return WidgetsVoxelProbe;
}(_widgets2.default);

exports.default = WidgetsVoxelProbe;

},{"../core/core.intersections":102,"../geometries/geometries.voxel":109,"../models/models.stack":134,"../models/models.voxel":135,"../widgets/widgets.base":166}]},{},[95])(95)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleHRlcm5hbC9zY3JpcHRzL2pwZWcuanMiLCJleHRlcm5hbC9zY3JpcHRzL2pweC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL3NyYy9iaW5kaW5nLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLXNoaW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29uc3QtbmluZi1mbG9hdDMyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb25zdC1waW5mLWZsb2F0MzIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kaWNvbS1wYXJzZXIvZGlzdC9kaWNvbVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9jb21wb25lbnQtc3BlYy5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2RhdGEtc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2ZyYW1lLWhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2h1ZmZtYW4tdGFibGUuanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvcXVhbnRpemF0aW9uLXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvc2Nhbi1jb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9zY2FuLWhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21hdGgtYWJzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWNlaWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nL2xpYi9kaXYyLmpzIiwibm9kZV9tb2R1bGVzL21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWZsb2F0MzItdG8tYmluYXJ5LXN0cmluZy9saWIvbXVsdDIuanMiLCJub2RlX21vZHVsZXMvbWF0aC1mbG9vci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmlmdGktcmVhZGVyLWpzL3NyYy9uaWZ0aS5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL25pZnRpMS5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL25pZnRpMi5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9ucnJkLWpzL25ycmQuanMiLCJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGlscy1sZWZ0LXBhZC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWxzLXJlcGVhdC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWxzLXJpZ2h0LXBhZC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLWludGVnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW5vbm5lZ2F0aXZlLWludGVnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW51bWJlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tc3RyaW5nLXByaW1pdGl2ZS9saWIvaW5kZXguanMiLCJwYWNrYWdlLmpzb24iLCJzcmMvYW1pLmpzIiwic3JjL2NhbWVyYXMvY2FtZXJhcy5qcyIsInNyYy9jYW1lcmFzL2NhbWVyYXMub3J0aG9ncmFwaGljLmpzIiwic3JjL2NvbnRyb2xzL2NvbnRyb2xzLmpzIiwic3JjL2NvbnRyb2xzL2NvbnRyb2xzLnRyYWNrYmFsbC5qcyIsInNyYy9jb250cm9scy9jb250cm9scy50cmFja2JhbGxvcnRoby5qcyIsInNyYy9jb3JlL2NvcmUuY29sb3JzLmpzIiwic3JjL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zLmpzIiwic3JjL2NvcmUvY29yZS5qcyIsInNyYy9jb3JlL2NvcmUucGFjay5qcyIsInNyYy9jb3JlL2NvcmUudXRpbHMuanMiLCJzcmMvY29yZS9jb3JlLnZhbGlkYXRvcnMuanMiLCJzcmMvZ2VvbWV0cmllcy9nZW9tZXRyaWVzLmpzIiwic3JjL2dlb21ldHJpZXMvZ2VvbWV0cmllcy5zbGljZS5qcyIsInNyYy9nZW9tZXRyaWVzL2dlb21ldHJpZXMudm94ZWwuanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLmJvcmRlci5qcyIsInNyYy9oZWxwZXJzL2hlbHBlcnMuYm91bmRpbmdib3guanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLmpzIiwic3JjL2hlbHBlcnMvaGVscGVycy5sb2NhbGl6ZXIuanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLmx1dC5qcyIsInNyYy9oZWxwZXJzL2hlbHBlcnMubWF0ZXJpYWwubWl4aW4uanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLnByb2dyZXNzYmFyLmV2ZW50YmFzZWQuanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLnByb2dyZXNzYmFyLmpzIiwic3JjL2hlbHBlcnMvaGVscGVycy5zbGljZS5qcyIsInNyYy9oZWxwZXJzL2hlbHBlcnMuc3RhY2suanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLnZvbHVtZXJlbmRlcmluZy5qcyIsInNyYy9oZWxwZXJzL3gvaGVscGVycy54LmludGVyYWN0b3IuanMiLCJzcmMvaGVscGVycy94L2hlbHBlcnMueC5qcyIsInNyYy9oZWxwZXJzL3gvaGVscGVycy54Lm1lc2guanMiLCJzcmMvaGVscGVycy94L2hlbHBlcnMueC5yZW5kZXJlcjJkLmpzIiwic3JjL2hlbHBlcnMveC9oZWxwZXJzLngucmVuZGVyZXIzZC5qcyIsInNyYy9oZWxwZXJzL3gvaGVscGVycy54LnZvbHVtZS5qcyIsInNyYy9sb2FkZXJzL2xvYWRlcnMuYmFzZS5qcyIsInNyYy9sb2FkZXJzL2xvYWRlcnMuanMiLCJzcmMvbG9hZGVycy9sb2FkZXJzLnZvbHVtZS5qcyIsInNyYy9tb2RlbHMvbW9kZWxzLmJhc2UuanMiLCJzcmMvbW9kZWxzL21vZGVscy5mcmFtZS5qcyIsInNyYy9tb2RlbHMvbW9kZWxzLmpzIiwic3JjL21vZGVscy9tb2RlbHMuc2VyaWVzLmpzIiwic3JjL21vZGVscy9tb2RlbHMuc3RhY2suanMiLCJzcmMvbW9kZWxzL21vZGVscy52b3hlbC5qcyIsInNyYy9wYXJzZXJzL3BhcnNlcnMuZGljb20uanMiLCJzcmMvcGFyc2Vycy9wYXJzZXJzLmpzIiwic3JjL3BhcnNlcnMvcGFyc2Vycy5taGQuanMiLCJzcmMvcGFyc2Vycy9wYXJzZXJzLm5pZnRpLmpzIiwic3JjL3BhcnNlcnMvcGFyc2Vycy5ucnJkLmpzIiwic3JjL3BhcnNlcnMvcGFyc2Vycy52b2x1bWUuanMiLCJzcmMvc2hhZGVycy9oZWxwZXJzL3NoYWRlcnMuaGVscGVycy5pbnRlcnNlY3RCb3guanMiLCJzcmMvc2hhZGVycy9oZWxwZXJzL3NoYWRlcnMuaGVscGVycy50ZXh0dXJlM2QuanMiLCJzcmMvc2hhZGVycy9oZWxwZXJzL3NoYWRlcnMuaGVscGVycy51bnBhY2suanMiLCJzcmMvc2hhZGVycy9pbnRlcnBvbGF0aW9uL3NoYWRlcnMuaW50ZXJwb2xhdGlvbi5pZGVudGl0eS5qcyIsInNyYy9zaGFkZXJzL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uLmpzIiwic3JjL3NoYWRlcnMvaW50ZXJwb2xhdGlvbi9zaGFkZXJzLmludGVycG9sYXRpb24udHJpbGluZWFyLmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5iYXNlLmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5jb250b3VyLmZyYWdtZW50LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5jb250b3VyLnVuaWZvcm0uanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLmNvbnRvdXIudmVydGV4LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5kYXRhLmZyYWdtZW50LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5kYXRhLnVuaWZvcm0uanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLmRhdGEudmVydGV4LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5qcyIsInNyYy9zaGFkZXJzL3NoYWRlcnMubGF5ZXIuZnJhZ21lbnQuanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLmxheWVyLnVuaWZvcm0uanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLmxheWVyLnZlcnRleC5qcyIsInNyYy9zaGFkZXJzL3NoYWRlcnMubG9jYWxpemVyLmZyYWdtZW50LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5sb2NhbGl6ZXIudW5pZm9ybS5qcyIsInNyYy9zaGFkZXJzL3NoYWRlcnMubG9jYWxpemVyLnZlcnRleC5qcyIsInNyYy9zaGFkZXJzL3NoYWRlcnMudnIuZnJhZ21lbnQuanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLnZyLnVuaWZvcm0uanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLnZyLnZlcnRleC5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMuYW5ub3RhdGlvbi5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMuYmFzZS5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMuYmlydWxlci5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMuaGFuZGxlLmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0cy5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMucm9pLmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0cy5ydWxlci5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMudm94ZWxQcm9iZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcjlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9EQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O2FBQU8sS0FBUCxBQUFZLEFBQ2I7Ozs7c0IsQUFFYSxXQUFXLEFBQ3ZCO1dBQUEsQUFBSyxhQUFMLEFBQWtCLEFBQ2xCO1dBQUEsQUFBSyxBQUNOO0E7d0JBRWUsQUFDZDthQUFPLEtBQVAsQUFBWSxBQUNiOzs7O3NCLEFBRWMsWUFBWSxBQUN6QjtXQUFBLEFBQUssY0FBTCxBQUFtQixBQUNuQjtXQUFBLEFBQUssQUFDTjtBO3dCQUVnQixBQUNmO2FBQU8sS0FBUCxBQUFZLEFBQ2I7Ozs7c0IsQUFFdUIscUJBQXFCLEFBQzNDO1dBQUEsQUFBSyx1QkFBTCxBQUE0QixBQUM1QjtXQUFBLEFBQUssQUFDTjtBO3dCQUV5QixBQUN4QjthQUFPLEtBQVAsQUFBWSxBQUNiOzs7Ozs7O2tCLEFBbmRrQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBqc2hpbnQgaWdub3JlOiBzdGFydFxuXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAvXG4gLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xuLypcbiBDb3B5cmlnaHQgMjAxMSBub3RtYXN0ZXJ5ZXRcblxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyAtIFRoZSBKUEVHIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBJVFUgQ0NJVFQgUmVjb21tZW5kYXRpb24gVC44MVxuLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2l0dS10ODEucGRmKVxuLy8gLSBUaGUgSkZJRiBzcGVjaWZpY2F0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgSlBFRyBGaWxlIEludGVyY2hhbmdlIEZvcm1hdFxuLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2pmaWYzLnBkZilcbi8vIC0gVGhlIEFkb2JlIEFwcGxpY2F0aW9uLVNwZWNpZmljIEpQRUcgbWFya2VycyBpbiB0aGUgU3VwcG9ydGluZyB0aGUgRENUIEZpbHRlcnNcbi8vICAgaW4gUG9zdFNjcmlwdCBMZXZlbCAyLCBUZWNobmljYWwgTm90ZSAjNTExNlxuLy8gICAocGFydG5lcnMuYWRvYmUuY29tL3B1YmxpYy9kZXZlbG9wZXIvZW4vcHMvc2RrLzUxMTYuRENUX0ZpbHRlci5wZGYpXG5cbnZhciBDb2xvclNwYWNlID0ge1Vua293bjogMCwgR3JheXNjYWxlOiAxLCBBZG9iZVJHQjogMiwgUkdCOiAzLCBDWU1LOiA0fTtcbnZhciBKcGVnSW1hZ2UgPSAoZnVuY3Rpb24ganBlZ0ltYWdlKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIGRjdFppZ1phZyA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAwLFxuICAgIDEsIDgsXG4gICAgMTYsIDksIDIsXG4gICAgMywgMTAsIDE3LCAyNCxcbiAgICAzMiwgMjUsIDE4LCAxMSwgNCxcbiAgICA1LCAxMiwgMTksIDI2LCAzMywgNDAsXG4gICAgNDgsIDQxLCAzNCwgMjcsIDIwLCAxMywgNixcbiAgICA3LCAxNCwgMjEsIDI4LCAzNSwgNDIsIDQ5LCA1NixcbiAgICA1NywgNTAsIDQzLCAzNiwgMjksIDIyLCAxNSxcbiAgICAyMywgMzAsIDM3LCA0NCwgNTEsIDU4LFxuICAgIDU5LCA1MiwgNDUsIDM4LCAzMSxcbiAgICAzOSwgNDYsIDUzLCA2MCxcbiAgICA2MSwgNTQsIDQ3LFxuICAgIDU1LCA2MixcbiAgICA2M1xuICBdKTtcblxuICB2YXIgZGN0Q29zMSA9IDQwMTc7ICAgLy8gY29zKHBpLzE2KVxuICB2YXIgZGN0U2luMSA9IDc5OTsgICAvLyBzaW4ocGkvMTYpXG4gIHZhciBkY3RDb3MzID0gMzQwNjsgICAvLyBjb3MoMypwaS8xNilcbiAgdmFyIGRjdFNpbjMgPSAyMjc2OyAgIC8vIHNpbigzKnBpLzE2KVxuICB2YXIgZGN0Q29zNiA9IDE1Njc7ICAgLy8gY29zKDYqcGkvMTYpXG4gIHZhciBkY3RTaW42ID0gMzc4NDsgICAvLyBzaW4oNipwaS8xNilcbiAgdmFyIGRjdFNxcnQyID0gNTc5MzsgICAvLyBzcXJ0KDIpXG4gIHZhciBkY3RTcXJ0MWQyID0gMjg5NjsgIC8vIHNxcnQoMikgLyAyXG5cbiAgZnVuY3Rpb24gY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgdmFsdWVzKSB7XG4gICAgdmFyIGsgPSAwLCBjb2RlID0gW10sIGksIGosIGxlbmd0aCA9IDE2O1xuICAgIHdoaWxlIChsZW5ndGggPiAwICYmICFjb2RlTGVuZ3Roc1tsZW5ndGggLSAxXSlcbiAgICAgIGxlbmd0aC0tO1xuICAgIGNvZGUucHVzaCh7Y2hpbGRyZW46IFtdLCBpbmRleDogMH0pO1xuICAgIHZhciBwID0gY29kZVswXSwgcTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RlTGVuZ3Roc1tpXTsgaisrKSB7XG4gICAgICAgIHAgPSBjb2RlLnBvcCgpO1xuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gdmFsdWVzW2tdO1xuICAgICAgICB3aGlsZSAocC5pbmRleCA+IDApIHtcbiAgICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBwLmluZGV4Kys7XG4gICAgICAgIGNvZGUucHVzaChwKTtcbiAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICBjb2RlLnB1c2gocSA9IHtjaGlsZHJlbjogW10sIGluZGV4OiAwfSk7XG4gICAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgICAgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIHAgaGVyZSBwb2ludHMgdG8gbGFzdCBjb2RlXG4gICAgICAgIGNvZGUucHVzaChxID0ge2NoaWxkcmVuOiBbXSwgaW5kZXg6IDB9KTtcbiAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICAgIHAgPSBxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29kZVswXS5jaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgcm93LCBjb2wpIHtcbiAgICByZXR1cm4gNjQgKiAoKGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lICsgMSkgKiByb3cgKyBjb2wpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgc3BlY3RyYWxTdGFydCwgc3BlY3RyYWxFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZVByZXYsIHN1Y2Nlc3NpdmUpIHtcbiAgICB2YXIgcHJlY2lzaW9uID0gZnJhbWUucHJlY2lzaW9uO1xuICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGZyYW1lLnNhbXBsZXNQZXJMaW5lO1xuICAgIHZhciBzY2FuTGluZXMgPSBmcmFtZS5zY2FuTGluZXM7XG4gICAgdmFyIG1jdXNQZXJMaW5lID0gZnJhbWUubWN1c1BlckxpbmU7XG4gICAgdmFyIHByb2dyZXNzaXZlID0gZnJhbWUucHJvZ3Jlc3NpdmU7XG4gICAgdmFyIG1heEggPSBmcmFtZS5tYXhILCBtYXhWID0gZnJhbWUubWF4VjtcblxuICAgIHZhciBzdGFydE9mZnNldCA9IG9mZnNldCwgYml0c0RhdGEgPSAwLCBiaXRzQ291bnQgPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVhZEJpdCgpIHtcbiAgICAgIGlmIChiaXRzQ291bnQgPiAwKSB7XG4gICAgICAgIGJpdHNDb3VudC0tO1xuICAgICAgICByZXR1cm4gKGJpdHNEYXRhID4+IGJpdHNDb3VudCkgJiAxO1xuICAgICAgfVxuICAgICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgIGlmIChiaXRzRGF0YSA9PSAweEZGKSB7XG4gICAgICAgIHZhciBuZXh0Qnl0ZSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICBpZiAobmV4dEJ5dGUpIHtcbiAgICAgICAgICB0aHJvdyBcInVuZXhwZWN0ZWQgbWFya2VyOiBcIiArICgoYml0c0RhdGEgPDwgOCkgfCBuZXh0Qnl0ZSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVuc3R1ZmYgMFxuICAgICAgfVxuICAgICAgYml0c0NvdW50ID0gNztcbiAgICAgIHJldHVybiBiaXRzRGF0YSA+Pj4gNztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNvZGVIdWZmbWFuKHRyZWUpIHtcbiAgICAgIHZhciBub2RlID0gdHJlZTtcbiAgICAgIHZhciBiaXQ7XG4gICAgICB3aGlsZSAoKGJpdCA9IHJlYWRCaXQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVbYml0XTtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnbnVtYmVyJylcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICB0aHJvdyBcImludmFsaWQgaHVmZm1hbiBzZXF1ZW5jZVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjZWl2ZShsZW5ndGgpIHtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBiaXQgPSByZWFkQml0KCk7XG4gICAgICAgIGlmIChiaXQgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBuID0gKG4gPDwgMSkgfCBiaXQ7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjZWl2ZUFuZEV4dGVuZChsZW5ndGgpIHtcbiAgICAgIHZhciBuID0gcmVjZWl2ZShsZW5ndGgpO1xuICAgICAgaWYgKG4gPj0gMSA8PCAobGVuZ3RoIC0gMSkpXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgcmV0dXJuIG4gKyAoLTEgPDwgbGVuZ3RoKSArIDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlQmFzZWxpbmUoY29tcG9uZW50LCBvZmZzZXQpIHtcbiAgICAgIHZhciB0ID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlREMpO1xuICAgICAgdmFyIGRpZmYgPSB0ID09PSAwID8gMCA6IHJlY2VpdmVBbmRFeHRlbmQodCk7XG4gICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldF0gPSAoY29tcG9uZW50LnByZWQgKz0gZGlmZik7XG4gICAgICB2YXIgayA9IDE7XG4gICAgICB3aGlsZSAoayA8IDY0KSB7XG4gICAgICAgIHZhciBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgICAgdmFyIHMgPSBycyAmIDE1LCByID0gcnMgPj4gNDtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICBpZiAociA8IDE1KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgayArPSAxNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBrICs9IHI7XG4gICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZURDRmlyc3QoY29tcG9uZW50LCBvZmZzZXQpIHtcbiAgICAgIHZhciB0ID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlREMpO1xuICAgICAgdmFyIGRpZmYgPSB0ID09PSAwID8gMCA6IChyZWNlaXZlQW5kRXh0ZW5kKHQpIDw8IHN1Y2Nlc3NpdmUpO1xuICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXRdID0gKGNvbXBvbmVudC5wcmVkICs9IGRpZmYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZURDU3VjY2Vzc2l2ZShjb21wb25lbnQsIG9mZnNldCkge1xuICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXRdIHw9IHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlO1xuICAgIH1cblxuICAgIHZhciBlb2JydW4gPSAwO1xuICAgIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCBvZmZzZXQpIHtcbiAgICAgIGlmIChlb2JydW4gPiAwKSB7XG4gICAgICAgIGVvYnJ1bi0tO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgayA9IHNwZWN0cmFsU3RhcnQsIGUgPSBzcGVjdHJhbEVuZDtcbiAgICAgIHdoaWxlIChrIDw9IGUpIHtcbiAgICAgICAgdmFyIHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgICB2YXIgcyA9IHJzICYgMTUsIHIgPSBycyA+PiA0O1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgIGlmIChyIDwgMTUpIHtcbiAgICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgayArPSAxNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBrICs9IHI7XG4gICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdID0gcmVjZWl2ZUFuZEV4dGVuZChzKSAqICgxIDw8IHN1Y2Nlc3NpdmUpO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMCwgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlO1xuICAgIGZ1bmN0aW9uIGRlY29kZUFDU3VjY2Vzc2l2ZShjb21wb25lbnQsIG9mZnNldCkge1xuICAgICAgdmFyIGsgPSBzcGVjdHJhbFN0YXJ0LCBlID0gc3BlY3RyYWxFbmQsIHIgPSAwO1xuICAgICAgd2hpbGUgKGsgPD0gZSkge1xuICAgICAgICB2YXIgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgc3dpdGNoIChzdWNjZXNzaXZlQUNTdGF0ZSkge1xuICAgICAgICAgIGNhc2UgMDogLy8gaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgdmFyIHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgICAgICAgdmFyIHMgPSBycyAmIDE1O1xuICAgICAgICAgICAgciA9IHJzID4+IDQ7XG4gICAgICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByID0gMTY7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocyAhPT0gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBcImludmFsaWQgQUNuIGVuY29kaW5nXCI7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZSA9IHJlY2VpdmVBbmRFeHRlbmQocyk7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gciA/IDIgOiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAxOiAvLyBza2lwcGluZyByIHplcm8gaXRlbXNcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSkge1xuICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByLS07XG4gICAgICAgICAgICAgIGlmIChyID09PSAwKVxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gc3VjY2Vzc2l2ZUFDU3RhdGUgPT0gMiA/IDMgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiAvLyBzZXQgdmFsdWUgZm9yIGEgemVybyBpdGVtXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSkge1xuICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdID0gc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlIDw8IHN1Y2Nlc3NpdmU7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDogLy8gZW9iXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSkge1xuICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgICBpZiAoc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDQpIHtcbiAgICAgICAgZW9icnVuLS07XG4gICAgICAgIGlmIChlb2JydW4gPT09IDApXG4gICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZSwgbWN1LCByb3csIGNvbCkge1xuICAgICAgdmFyIG1jdVJvdyA9IChtY3UgLyBtY3VzUGVyTGluZSkgfCAwO1xuICAgICAgdmFyIG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xuICAgICAgdmFyIGJsb2NrUm93ID0gbWN1Um93ICogY29tcG9uZW50LnYgKyByb3c7XG4gICAgICB2YXIgYmxvY2tDb2wgPSBtY3VDb2wgKiBjb21wb25lbnQuaCArIGNvbDtcbiAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICBkZWNvZGUoY29tcG9uZW50LCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlLCBtY3UpIHtcbiAgICAgIHZhciBibG9ja1JvdyA9IChtY3UgLyBjb21wb25lbnQuYmxvY2tzUGVyTGluZSkgfCAwO1xuICAgICAgdmFyIGJsb2NrQ29sID0gbWN1ICUgY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XG4gICAgICB2YXIgb2Zmc2V0ID0gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCBibG9ja1JvdywgYmxvY2tDb2wpO1xuICAgICAgZGVjb2RlKGNvbXBvbmVudCwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50c0xlbmd0aCA9IGNvbXBvbmVudHMubGVuZ3RoO1xuICAgIHZhciBjb21wb25lbnQsIGksIGosIGssIG47XG4gICAgdmFyIGRlY29kZUZuO1xuICAgIGlmIChwcm9ncmVzc2l2ZSkge1xuICAgICAgaWYgKHNwZWN0cmFsU3RhcnQgPT09IDApXG4gICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVEQ0ZpcnN0IDogZGVjb2RlRENTdWNjZXNzaXZlO1xuICAgICAgZWxzZVxuICAgICAgICBkZWNvZGVGbiA9IHN1Y2Nlc3NpdmVQcmV2ID09PSAwID8gZGVjb2RlQUNGaXJzdCA6IGRlY29kZUFDU3VjY2Vzc2l2ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjb2RlRm4gPSBkZWNvZGVCYXNlbGluZTtcbiAgICB9XG5cbiAgICB2YXIgbWN1ID0gMCwgbWFya2VyO1xuICAgIHZhciBtY3VFeHBlY3RlZDtcbiAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PSAxKSB7XG4gICAgICBtY3VFeHBlY3RlZCA9IGNvbXBvbmVudHNbMF0uYmxvY2tzUGVyTGluZSAqIGNvbXBvbmVudHNbMF0uYmxvY2tzUGVyQ29sdW1uO1xuICAgIH0gZWxzZSB7XG4gICAgICBtY3VFeHBlY3RlZCA9IG1jdXNQZXJMaW5lICogZnJhbWUubWN1c1BlckNvbHVtbjtcbiAgICB9XG4gICAgaWYgKCFyZXNldEludGVydmFsKSB7XG4gICAgICByZXNldEludGVydmFsID0gbWN1RXhwZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGgsIHY7XG4gICAgd2hpbGUgKG1jdSA8IG1jdUV4cGVjdGVkKSB7XG4gICAgICAvLyByZXNldCBpbnRlcnZhbCBzdHVmZlxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwO1xuICAgICAgfVxuICAgICAgZW9icnVuID0gMDtcblxuICAgICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT0gMSkge1xuICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzWzBdO1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgcmVzZXRJbnRlcnZhbDsgbisrKSB7XG4gICAgICAgICAgZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1KTtcbiAgICAgICAgICBtY3UrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IHJlc2V0SW50ZXJ2YWw7IG4rKykge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBoID0gY29tcG9uZW50Lmg7XG4gICAgICAgICAgICB2ID0gY29tcG9uZW50LnY7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdjsgaisrKSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1LCBqLCBrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtY3UrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIG1hcmtlclxuICAgICAgYml0c0NvdW50ID0gMDtcbiAgICAgIG1hcmtlciA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xuICAgICAgaWYgKG1hcmtlciA8PSAweEZGMDApIHtcbiAgICAgICAgdGhyb3cgXCJtYXJrZXIgd2FzIG5vdCBmb3VuZFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFya2VyID49IDB4RkZEMCAmJiBtYXJrZXIgPD0gMHhGRkQ3KSB7IC8vIFJTVHhcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XG4gIH1cblxuICAvLyBBIHBvcnQgb2YgcG9wcGxlcidzIElEQ1QgbWV0aG9kIHdoaWNoIGluIHR1cm4gaXMgdGFrZW4gZnJvbTpcbiAgLy8gICBDaHJpc3RvcGggTG9lZmZsZXIsIEFkcmlhYW4gTGlndGVuYmVyZywgR2VvcmdlIFMuIE1vc2NoeXR6LFxuICAvLyAgIFwiUHJhY3RpY2FsIEZhc3QgMS1EIERDVCBBbGdvcml0aG1zIHdpdGggMTEgTXVsdGlwbGljYXRpb25zXCIsXG4gIC8vICAgSUVFRSBJbnRsLiBDb25mLiBvbiBBY291c3RpY3MsIFNwZWVjaCAmIFNpZ25hbCBQcm9jZXNzaW5nLCAxOTg5LFxuICAvLyAgIDk4OC05OTEuXG4gIGZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZShjb21wb25lbnQsIGJsb2NrQnVmZmVyT2Zmc2V0LCBwKSB7XG4gICAgdmFyIHF0ID0gY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlO1xuICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHQ7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBkZXF1YW50XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgIHBbaV0gPSBjb21wb25lbnQuYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgaV0gKiBxdFtpXTtcbiAgICB9XG5cbiAgICAvLyBpbnZlcnNlIERDVCBvbiByb3dzXG4gICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgdmFyIHJvdyA9IDggKiBpO1xuXG4gICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXG4gICAgICBpZiAocFsxICsgcm93XSA9PT0gMCAmJiBwWzIgKyByb3ddID09PSAwICYmIHBbMyArIHJvd10gPT09IDAgJiZcbiAgICAgICAgcFs0ICsgcm93XSA9PT0gMCAmJiBwWzUgKyByb3ddID09PSAwICYmIHBbNiArIHJvd10gPT09IDAgJiZcbiAgICAgICAgcFs3ICsgcm93XSA9PT0gMCkge1xuICAgICAgICB0ID0gKGRjdFNxcnQyICogcFswICsgcm93XSArIDUxMikgPj4gMTA7XG4gICAgICAgIHBbMCArIHJvd10gPSB0O1xuICAgICAgICBwWzEgKyByb3ddID0gdDtcbiAgICAgICAgcFsyICsgcm93XSA9IHQ7XG4gICAgICAgIHBbMyArIHJvd10gPSB0O1xuICAgICAgICBwWzQgKyByb3ddID0gdDtcbiAgICAgICAgcFs1ICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNiArIHJvd10gPSB0O1xuICAgICAgICBwWzcgKyByb3ddID0gdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWdlIDRcbiAgICAgIHYwID0gKGRjdFNxcnQyICogcFswICsgcm93XSArIDEyOCkgPj4gODtcbiAgICAgIHYxID0gKGRjdFNxcnQyICogcFs0ICsgcm93XSArIDEyOCkgPj4gODtcbiAgICAgIHYyID0gcFsyICsgcm93XTtcbiAgICAgIHYzID0gcFs2ICsgcm93XTtcbiAgICAgIHY0ID0gKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSAtIHBbNyArIHJvd10pICsgMTI4KSA+PiA4O1xuICAgICAgdjcgPSAoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddICsgcFs3ICsgcm93XSkgKyAxMjgpID4+IDg7XG4gICAgICB2NSA9IHBbMyArIHJvd10gPDwgNDtcbiAgICAgIHY2ID0gcFs1ICsgcm93XSA8PCA0O1xuXG4gICAgICAvLyBzdGFnZSAzXG4gICAgICB0ID0gKHYwIC0gdjEgKyAxKSA+PiAxO1xuICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICB2MSA9IHQ7XG4gICAgICB0ID0gKHYyICogZGN0U2luNiArIHYzICogZGN0Q29zNiArIDEyOCkgPj4gODtcbiAgICAgIHYyID0gKHYyICogZGN0Q29zNiAtIHYzICogZGN0U2luNiArIDEyOCkgPj4gODtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7XG4gICAgICB2NCA9ICh2NCArIHY2ICsgMSkgPj4gMTtcbiAgICAgIHY2ID0gdDtcbiAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7XG4gICAgICB2NSA9ICh2NyAtIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY3ID0gdDtcblxuICAgICAgLy8gc3RhZ2UgMlxuICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjMgKyAxKSA+PiAxO1xuICAgICAgdjMgPSB0O1xuICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcbiAgICAgIHYxID0gKHYxICsgdjIgKyAxKSA+PiAxO1xuICAgICAgdjIgPSB0O1xuICAgICAgdCA9ICh2NCAqIGRjdFNpbjMgKyB2NyAqIGRjdENvczMgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY0ID0gKHY0ICogZGN0Q29zMyAtIHY3ICogZGN0U2luMyArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSB0O1xuICAgICAgdCA9ICh2NSAqIGRjdFNpbjEgKyB2NiAqIGRjdENvczEgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY1ID0gKHY1ICogZGN0Q29zMSAtIHY2ICogZGN0U2luMSArIDIwNDgpID4+IDEyO1xuICAgICAgdjYgPSB0O1xuXG4gICAgICAvLyBzdGFnZSAxXG4gICAgICBwWzAgKyByb3ddID0gdjAgKyB2NztcbiAgICAgIHBbNyArIHJvd10gPSB2MCAtIHY3O1xuICAgICAgcFsxICsgcm93XSA9IHYxICsgdjY7XG4gICAgICBwWzYgKyByb3ddID0gdjEgLSB2NjtcbiAgICAgIHBbMiArIHJvd10gPSB2MiArIHY1O1xuICAgICAgcFs1ICsgcm93XSA9IHYyIC0gdjU7XG4gICAgICBwWzMgKyByb3ddID0gdjMgKyB2NDtcbiAgICAgIHBbNCArIHJvd10gPSB2MyAtIHY0O1xuICAgIH1cblxuICAgIC8vIGludmVyc2UgRENUIG9uIGNvbHVtbnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICB2YXIgY29sID0gaTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGFsbC16ZXJvIEFDIGNvZWZmaWNpZW50c1xuICAgICAgaWYgKHBbMSAqIDggKyBjb2xdID09PSAwICYmIHBbMiAqIDggKyBjb2xdID09PSAwICYmIHBbMyAqIDggKyBjb2xdID09PSAwICYmXG4gICAgICAgIHBbNCAqIDggKyBjb2xdID09PSAwICYmIHBbNSAqIDggKyBjb2xdID09PSAwICYmIHBbNiAqIDggKyBjb2xdID09PSAwICYmXG4gICAgICAgIHBbNyAqIDggKyBjb2xdID09PSAwKSB7XG4gICAgICAgIHQgPSAoZGN0U3FydDIgKiBwW2kgKyAwXSArIDgxOTIpID4+IDE0O1xuICAgICAgICBwWzAgKiA4ICsgY29sXSA9IHQ7XG4gICAgICAgIHBbMSAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgcFsyICogOCArIGNvbF0gPSB0O1xuICAgICAgICBwWzMgKiA4ICsgY29sXSA9IHQ7XG4gICAgICAgIHBbNCAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgcFs1ICogOCArIGNvbF0gPSB0O1xuICAgICAgICBwWzYgKiA4ICsgY29sXSA9IHQ7XG4gICAgICAgIHBbNyAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWdlIDRcbiAgICAgIHYwID0gKGRjdFNxcnQyICogcFswICogOCArIGNvbF0gKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYxID0gKGRjdFNxcnQyICogcFs0ICogOCArIGNvbF0gKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYyID0gcFsyICogOCArIGNvbF07XG4gICAgICB2MyA9IHBbNiAqIDggKyBjb2xdO1xuICAgICAgdjQgPSAoZGN0U3FydDFkMiAqIChwWzEgKiA4ICsgY29sXSAtIHBbNyAqIDggKyBjb2xdKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSAoZGN0U3FydDFkMiAqIChwWzEgKiA4ICsgY29sXSArIHBbNyAqIDggKyBjb2xdKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjUgPSBwWzMgKiA4ICsgY29sXTtcbiAgICAgIHY2ID0gcFs1ICogOCArIGNvbF07XG5cbiAgICAgIC8vIHN0YWdlIDNcbiAgICAgIHQgPSAodjAgLSB2MSArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTtcbiAgICAgIHYxID0gdDtcbiAgICAgIHQgPSAodjIgKiBkY3RTaW42ICsgdjMgKiBkY3RDb3M2ICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MiA9ICh2MiAqIGRjdENvczYgLSB2MyAqIGRjdFNpbjYgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7XG4gICAgICB2NCA9ICh2NCArIHY2ICsgMSkgPj4gMTtcbiAgICAgIHY2ID0gdDtcbiAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7XG4gICAgICB2NSA9ICh2NyAtIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY3ID0gdDtcblxuICAgICAgLy8gc3RhZ2UgMlxuICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjMgKyAxKSA+PiAxO1xuICAgICAgdjMgPSB0O1xuICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcbiAgICAgIHYxID0gKHYxICsgdjIgKyAxKSA+PiAxO1xuICAgICAgdjIgPSB0O1xuICAgICAgdCA9ICh2NCAqIGRjdFNpbjMgKyB2NyAqIGRjdENvczMgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY0ID0gKHY0ICogZGN0Q29zMyAtIHY3ICogZGN0U2luMyArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSB0O1xuICAgICAgdCA9ICh2NSAqIGRjdFNpbjEgKyB2NiAqIGRjdENvczEgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY1ID0gKHY1ICogZGN0Q29zMSAtIHY2ICogZGN0U2luMSArIDIwNDgpID4+IDEyO1xuICAgICAgdjYgPSB0O1xuXG4gICAgICAvLyBzdGFnZSAxXG4gICAgICBwWzAgKiA4ICsgY29sXSA9IHYwICsgdjc7XG4gICAgICBwWzcgKiA4ICsgY29sXSA9IHYwIC0gdjc7XG4gICAgICBwWzEgKiA4ICsgY29sXSA9IHYxICsgdjY7XG4gICAgICBwWzYgKiA4ICsgY29sXSA9IHYxIC0gdjY7XG4gICAgICBwWzIgKiA4ICsgY29sXSA9IHYyICsgdjU7XG4gICAgICBwWzUgKiA4ICsgY29sXSA9IHYyIC0gdjU7XG4gICAgICBwWzMgKiA4ICsgY29sXSA9IHYzICsgdjQ7XG4gICAgICBwWzQgKiA4ICsgY29sXSA9IHYzIC0gdjQ7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0byA4LWJpdCBpbnRlZ2Vyc1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICB2YXIgaW5kZXggPSBibG9ja0J1ZmZlck9mZnNldCArIGk7XG4gICAgICB2YXIgcSA9IHBbaV07XG4gICAgICBxID0gKHEgPD0gLTIwNTYgLyBjb21wb25lbnQuYml0Q29udmVyc2lvbikgPyAwIDpcbiAgICAgICAgKHEgPj0gMjAyNCAvIGNvbXBvbmVudC5iaXRDb252ZXJzaW9uKSA/IDI1NSAvIGNvbXBvbmVudC5iaXRDb252ZXJzaW9uIDpcbiAgICAgICAgKHEgKyAyMDU2IC8gY29tcG9uZW50LmJpdENvbnZlcnNpb24pID4+IDQ7XG4gICAgICBjb21wb25lbnQuYmxvY2tEYXRhW2luZGV4XSA9IHE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgYmxvY2tzUGVyTGluZSA9IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xuICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uO1xuICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcbiAgICB2YXIgY29tcHV0YXRpb25CdWZmZXIgPSBuZXcgSW50MzJBcnJheSg2NCk7XG5cbiAgICB2YXIgaSwgaiwgbGwgPSAwO1xuICAgIGZvciAodmFyIGJsb2NrUm93ID0gMDsgYmxvY2tSb3cgPCBibG9ja3NQZXJDb2x1bW47IGJsb2NrUm93KyspIHtcbiAgICAgIGZvciAodmFyIGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICAgIHF1YW50aXplQW5kSW52ZXJzZShjb21wb25lbnQsIG9mZnNldCwgY29tcHV0YXRpb25CdWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50LmJsb2NrRGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYW1wVG9VaW50OChhKSB7XG4gICAgcmV0dXJuIGEgPD0gMCA/IDAgOiBhID49IDI1NSA/IDI1NSA6IGEgfCAwO1xuICB9XG5cbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0ge1xuICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQocGF0aCkge1xuICAgICAgdmFyIGhhbmRsZURhdGEgPSAoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5wYXJzZShkYXRhKTtcbiAgICAgICAgaWYgKHRoaXMub25sb2FkKVxuICAgICAgICAgIHRoaXMub25sb2FkKCk7XG4gICAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgICBpZiAocGF0aC5pbmRleE9mKFwiZGF0YTpcIikgPiAtMSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGF0aC5pbmRleE9mKFwiYmFzZTY0LFwiKSArIDc7XG4gICAgICAgIHZhciBkYXRhID0gYXRvYihwYXRoLnN1YnN0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBhcnJbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlRGF0YShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgcGF0aCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgIHhoci5vbmxvYWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFRPRE8gY2F0Y2ggcGFyc2UgZXJyb3JcbiAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgaGFuZGxlRGF0YShkYXRhKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoZGF0YSkge1xuXG4gICAgICBmdW5jdGlvbiByZWFkVWludDE2KCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVhZERhdGFCbG9jaygpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgdmFyIGFycmF5ID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCAtIDIpO1xuICAgICAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKSB7XG4gICAgICAgIHZhciBtY3VzUGVyTGluZSA9IE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDggLyBmcmFtZS5tYXhIKTtcbiAgICAgICAgdmFyIG1jdXNQZXJDb2x1bW4gPSBNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCAvIGZyYW1lLm1heFYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2ldO1xuICAgICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDgpICogY29tcG9uZW50LmggLyBmcmFtZS5tYXhIKTtcbiAgICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zY2FuTGluZXMgLyA4KSAqIGNvbXBvbmVudC52IC8gZnJhbWUubWF4Vik7XG4gICAgICAgICAgdmFyIGJsb2Nrc1BlckxpbmVGb3JNY3UgPSBtY3VzUGVyTGluZSAqIGNvbXBvbmVudC5oO1xuICAgICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW5Gb3JNY3UgPSBtY3VzUGVyQ29sdW1uICogY29tcG9uZW50LnY7XG5cbiAgICAgICAgICB2YXIgYmxvY2tzQnVmZmVyU2l6ZSA9IDY0ICogYmxvY2tzUGVyQ29sdW1uRm9yTWN1ICogKGJsb2Nrc1BlckxpbmVGb3JNY3UgKyAxKTtcbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhID0gbmV3IEludDE2QXJyYXkoYmxvY2tzQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lO1xuICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW4gPSBibG9ja3NQZXJDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUubWN1c1BlckxpbmUgPSBtY3VzUGVyTGluZTtcbiAgICAgICAgZnJhbWUubWN1c1BlckNvbHVtbiA9IG1jdXNQZXJDb2x1bW47XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHZhciBqZmlmID0gbnVsbDtcbiAgICAgIHZhciBhZG9iZSA9IG51bGw7XG4gICAgICB2YXIgcGl4ZWxzID0gbnVsbDtcbiAgICAgIHZhciBmcmFtZSwgcmVzZXRJbnRlcnZhbDtcbiAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZXMgPSBbXTtcbiAgICAgIHZhciBodWZmbWFuVGFibGVzQUMgPSBbXSwgaHVmZm1hblRhYmxlc0RDID0gW107XG4gICAgICB2YXIgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICAgIGlmIChmaWxlTWFya2VyICE9IDB4RkZEOCkgeyAvLyBTT0kgKFN0YXJ0IG9mIEltYWdlKVxuICAgICAgICB0aHJvdyBcIlNPSSBub3QgZm91bmRcIjtcbiAgICAgIH1cblxuICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICAgIHdoaWxlIChmaWxlTWFya2VyICE9IDB4RkZEOSkgeyAvLyBFT0kgKEVuZCBvZiBpbWFnZSlcbiAgICAgICAgdmFyIGksIGosIGw7XG4gICAgICAgIHN3aXRjaCAoZmlsZU1hcmtlcikge1xuICAgICAgICAgIGNhc2UgMHhGRkUwOiAvLyBBUFAwIChBcHBsaWNhdGlvbiBTcGVjaWZpYylcbiAgICAgICAgICBjYXNlIDB4RkZFMTogLy8gQVBQMVxuICAgICAgICAgIGNhc2UgMHhGRkUyOiAvLyBBUFAyXG4gICAgICAgICAgY2FzZSAweEZGRTM6IC8vIEFQUDNcbiAgICAgICAgICBjYXNlIDB4RkZFNDogLy8gQVBQNFxuICAgICAgICAgIGNhc2UgMHhGRkU1OiAvLyBBUFA1XG4gICAgICAgICAgY2FzZSAweEZGRTY6IC8vIEFQUDZcbiAgICAgICAgICBjYXNlIDB4RkZFNzogLy8gQVBQN1xuICAgICAgICAgIGNhc2UgMHhGRkU4OiAvLyBBUFA4XG4gICAgICAgICAgY2FzZSAweEZGRTk6IC8vIEFQUDlcbiAgICAgICAgICBjYXNlIDB4RkZFQTogLy8gQVBQMTBcbiAgICAgICAgICBjYXNlIDB4RkZFQjogLy8gQVBQMTFcbiAgICAgICAgICBjYXNlIDB4RkZFQzogLy8gQVBQMTJcbiAgICAgICAgICBjYXNlIDB4RkZFRDogLy8gQVBQMTNcbiAgICAgICAgICBjYXNlIDB4RkZFRTogLy8gQVBQMTRcbiAgICAgICAgICBjYXNlIDB4RkZFRjogLy8gQVBQMTVcbiAgICAgICAgICBjYXNlIDB4RkZGRTogLy8gQ09NIChDb21tZW50KVxuICAgICAgICAgICAgdmFyIGFwcERhdGEgPSByZWFkRGF0YUJsb2NrKCk7XG5cbiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRTApIHtcbiAgICAgICAgICAgICAgaWYgKGFwcERhdGFbMF0gPT09IDB4NEEgJiYgYXBwRGF0YVsxXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzJdID09PSAweDQ5ICYmXG4gICAgICAgICAgICAgICAgYXBwRGF0YVszXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzRdID09PSAwKSB7IC8vICdKRklGXFx4MDAnXG4gICAgICAgICAgICAgICAgamZpZiA9IHtcbiAgICAgICAgICAgICAgICAgIHZlcnNpb246IHttYWpvcjogYXBwRGF0YVs1XSwgbWlub3I6IGFwcERhdGFbNl19LFxuICAgICAgICAgICAgICAgICAgZGVuc2l0eVVuaXRzOiBhcHBEYXRhWzddLFxuICAgICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSxcbiAgICAgICAgICAgICAgICAgIHlEZW5zaXR5OiAoYXBwRGF0YVsxMF0gPDwgOCkgfCBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgICAgIHRodW1iV2lkdGg6IGFwcERhdGFbMTJdLFxuICAgICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLFxuICAgICAgICAgICAgICAgICAgdGh1bWJEYXRhOiBhcHBEYXRhLnN1YmFycmF5KDE0LCAxNCArIDMgKiBhcHBEYXRhWzEyXSAqIGFwcERhdGFbMTNdKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gQVBQMSAtIEV4aWZcbiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRUUpIHtcbiAgICAgICAgICAgICAgaWYgKGFwcERhdGFbMF0gPT09IDB4NDEgJiYgYXBwRGF0YVsxXSA9PT0gMHg2NCAmJiBhcHBEYXRhWzJdID09PSAweDZGICYmXG4gICAgICAgICAgICAgICAgYXBwRGF0YVszXSA9PT0gMHg2MiAmJiBhcHBEYXRhWzRdID09PSAweDY1ICYmIGFwcERhdGFbNV0gPT09IDApIHsgLy8gJ0Fkb2JlXFx4MDAnXG4gICAgICAgICAgICAgICAgYWRvYmUgPSB7XG4gICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBhcHBEYXRhWzZdLFxuICAgICAgICAgICAgICAgICAgZmxhZ3MwOiAoYXBwRGF0YVs3XSA8PCA4KSB8IGFwcERhdGFbOF0sXG4gICAgICAgICAgICAgICAgICBmbGFnczE6IChhcHBEYXRhWzldIDw8IDgpIHwgYXBwRGF0YVsxMF0sXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Db2RlOiBhcHBEYXRhWzExXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweEZGREI6IC8vIERRVCAoRGVmaW5lIFF1YW50aXphdGlvbiBUYWJsZXMpXG4gICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlc0VuZCA9IHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCArIG9mZnNldCAtIDI7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcXVhbnRpemF0aW9uVGFibGVzRW5kKSB7XG4gICAgICAgICAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgdmFyIHRhYmxlRGF0YSA9IG5ldyBJbnQzMkFycmF5KDY0KTtcbiAgICAgICAgICAgICAgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDApIHsgLy8gOCBiaXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDY0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2pdO1xuICAgICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDEpIHsgLy8xNiBiaXRcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHp6ID0gZGN0WmlnWmFnW2pdO1xuICAgICAgICAgICAgICAgICAgdGFibGVEYXRhW3p6XSA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IFwiRFFUOiBpbnZhbGlkIHRhYmxlIHNwZWNcIjtcbiAgICAgICAgICAgICAgcXVhbnRpemF0aW9uVGFibGVzW3F1YW50aXphdGlvblRhYmxlU3BlYyAmIDE1XSA9IHRhYmxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweEZGQzA6IC8vIFNPRjAgKFN0YXJ0IG9mIEZyYW1lLCBCYXNlbGluZSBEQ1QpXG4gICAgICAgICAgY2FzZSAweEZGQzE6IC8vIFNPRjEgKFN0YXJ0IG9mIEZyYW1lLCBFeHRlbmRlZCBEQ1QpXG4gICAgICAgICAgY2FzZSAweEZGQzI6IC8vIFNPRjIgKFN0YXJ0IG9mIEZyYW1lLCBQcm9ncmVzc2l2ZSBEQ1QpXG4gICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJPbmx5IHNpbmdsZSBmcmFtZSBKUEVHcyBzdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxuICAgICAgICAgICAgZnJhbWUgPSB7fTtcbiAgICAgICAgICAgIGZyYW1lLmV4dGVuZGVkID0gKGZpbGVNYXJrZXIgPT09IDB4RkZDMSk7XG4gICAgICAgICAgICBmcmFtZS5wcm9ncmVzc2l2ZSA9IChmaWxlTWFya2VyID09PSAweEZGQzIpO1xuICAgICAgICAgICAgZnJhbWUucHJlY2lzaW9uID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICBmcmFtZS5zY2FuTGluZXMgPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICBmcmFtZS5zYW1wbGVzUGVyTGluZSA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudElkcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IGRhdGFbb2Zmc2V0KytdLCBjb21wb25lbnRJZDtcbiAgICAgICAgICAgIHZhciBtYXhIID0gMCwgbWF4ViA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50SWQgPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgIHZhciBoID0gZGF0YVtvZmZzZXQgKyAxXSA+PiA0O1xuICAgICAgICAgICAgICB2YXIgdiA9IGRhdGFbb2Zmc2V0ICsgMV0gJiAxNTtcbiAgICAgICAgICAgICAgaWYgKG1heEggPCBoKVxuICAgICAgICAgICAgICAgIG1heEggPSBoO1xuICAgICAgICAgICAgICBpZiAobWF4ViA8IHYpXG4gICAgICAgICAgICAgICAgbWF4ViA9IHY7XG4gICAgICAgICAgICAgIHZhciBxSWQgPSBkYXRhW29mZnNldCArIDJdO1xuICAgICAgICAgICAgICBsID0gZnJhbWUuY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBoOiBoLFxuICAgICAgICAgICAgICAgIHY6IHYsXG4gICAgICAgICAgICAgICAgcXVhbnRpemF0aW9uVGFibGU6IHF1YW50aXphdGlvblRhYmxlc1txSWRdLFxuICAgICAgICAgICAgICAgIHF1YW50aXphdGlvblRhYmxlSWQ6IHFJZCxcbiAgICAgICAgICAgICAgICBiaXRDb252ZXJzaW9uOiAyNTUgLyAoKDEgPDwgZnJhbWUucHJlY2lzaW9uKSAtIDEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBmcmFtZS5jb21wb25lbnRJZHNbY29tcG9uZW50SWRdID0gbCAtIDE7XG4gICAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhbWUubWF4SCA9IG1heEg7XG4gICAgICAgICAgICBmcmFtZS5tYXhWID0gbWF4VjtcbiAgICAgICAgICAgIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweEZGQzQ6IC8vIERIVCAoRGVmaW5lIEh1ZmZtYW4gVGFibGVzKVxuICAgICAgICAgICAgdmFyIGh1ZmZtYW5MZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAyOyBpIDwgaHVmZm1hbkxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgIHZhciBodWZmbWFuVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgIHZhciBjb2RlTGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGhTdW0gPSAwO1xuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgMTY7IGorKywgb2Zmc2V0KyspXG4gICAgICAgICAgICAgICAgY29kZUxlbmd0aFN1bSArPSAoY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgICB2YXIgaHVmZm1hblZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGNvZGVMZW5ndGhTdW0pO1xuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29kZUxlbmd0aFN1bTsgaisrLCBvZmZzZXQrKylcbiAgICAgICAgICAgICAgICBodWZmbWFuVmFsdWVzW2pdID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgICBpICs9IDE3ICsgY29kZUxlbmd0aFN1bTtcblxuICAgICAgICAgICAgICAoKGh1ZmZtYW5UYWJsZVNwZWMgPj4gNCkgPT09IDAgP1xuICAgICAgICAgICAgICAgIGh1ZmZtYW5UYWJsZXNEQyA6IGh1ZmZtYW5UYWJsZXNBQylbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9XG4gICAgICAgICAgICAgICAgYnVpbGRIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMsIGh1ZmZtYW5WYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4RkZERDogLy8gRFJJIChEZWZpbmUgUmVzdGFydCBJbnRlcnZhbClcbiAgICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxuICAgICAgICAgICAgcmVzZXRJbnRlcnZhbCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweEZGREE6IC8vIFNPUyAoU3RhcnQgb2YgU2NhbilcbiAgICAgICAgICAgIHZhciBzY2FuTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yc0NvdW50ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdLCBjb21wb25lbnQ7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0b3JzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50SW5kZXggPSBmcmFtZS5jb21wb25lbnRJZHNbZGF0YVtvZmZzZXQrK11dO1xuICAgICAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudEluZGV4XTtcbiAgICAgICAgICAgICAgdmFyIHRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlREMgPSBodWZmbWFuVGFibGVzRENbdGFibGVTcGVjID4+IDRdO1xuICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlQUMgPSBodWZmbWFuVGFibGVzQUNbdGFibGVTcGVjICYgMTVdO1xuICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzcGVjdHJhbFN0YXJ0ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICB2YXIgc3BlY3RyYWxFbmQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NlZCA9IGRlY29kZVNjYW4oZGF0YSwgb2Zmc2V0LFxuICAgICAgICAgICAgICBmcmFtZSwgY29tcG9uZW50cywgcmVzZXRJbnRlcnZhbCxcbiAgICAgICAgICAgICAgc3BlY3RyYWxTdGFydCwgc3BlY3RyYWxFbmQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uID4+IDQsIHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uICYgMTUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHByb2Nlc3NlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgLSAzXSA9PSAweEZGICYmXG4gICAgICAgICAgICAgIGRhdGFbb2Zmc2V0IC0gMl0gPj0gMHhDMCAmJiBkYXRhW29mZnNldCAtIDJdIDw9IDB4RkUpIHtcbiAgICAgICAgICAgICAgLy8gY291bGQgYmUgaW5jb3JyZWN0IGVuY29kaW5nIC0tIGxhc3QgMHhGRiBieXRlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAvLyBibG9jayB3YXMgZWF0ZW4gYnkgdGhlIGVuY29kZXJcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgXCJ1bmtub3duIEpQRUcgbWFya2VyIFwiICsgZmlsZU1hcmtlci50b1N0cmluZygxNik7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53aWR0aCA9IGZyYW1lLnNhbXBsZXNQZXJMaW5lO1xuICAgICAgdGhpcy5oZWlnaHQgPSBmcmFtZS5zY2FuTGluZXM7XG4gICAgICB0aGlzLmpmaWYgPSBqZmlmO1xuICAgICAgdGhpcy5hZG9iZSA9IGFkb2JlO1xuICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG4gICAgICBzd2l0Y2ggKGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoKVxuICAgICAge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy5jb2xvcnNwYWNlID0gQ29sb3JTcGFjZS5HcmF5c2NhbGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBpZiAodGhpcy5hZG9iZSlcbiAgICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuQWRvYmVSR0I7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5jb2xvcnNwYWNlID0gQ29sb3JTcGFjZS5SR0I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLkNZTUs7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5jb2xvcnNwYWNlID0gQ29sb3JTcGFjZS5Vbmtub3duO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2ldO1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZSAmJiBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGVJZCAhPT0gbnVsbClcbiAgICAgICAgICBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGUgPSBxdWFudGl6YXRpb25UYWJsZXNbY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlSWRdO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgb3V0cHV0OiBidWlsZENvbXBvbmVudERhdGEoZnJhbWUsIGNvbXBvbmVudCksXG4gICAgICAgICAgc2NhbGVYOiBjb21wb25lbnQuaCAvIGZyYW1lLm1heEgsXG4gICAgICAgICAgc2NhbGVZOiBjb21wb25lbnQudiAvIGZyYW1lLm1heFYsXG4gICAgICAgICAgYmxvY2tzUGVyTGluZTogY29tcG9uZW50LmJsb2Nrc1BlckxpbmUsXG4gICAgICAgICAgYmxvY2tzUGVyQ29sdW1uOiBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uLFxuICAgICAgICAgIGJpdENvbnZlcnNpb246IGNvbXBvbmVudC5iaXRDb252ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RGF0YTE2OiBmdW5jdGlvbiBnZXREYXRhMTYod2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50cy5sZW5ndGggIT09IDEpXG4gICAgICAgIHRocm93ICdVbnN1cHBvcnRlZCBjb2xvciBtb2RlJztcbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLndpZHRoIC8gd2lkdGgsIHNjYWxlWSA9IHRoaXMuaGVpZ2h0IC8gaGVpZ2h0O1xuXG4gICAgICB2YXIgY29tcG9uZW50LCBjb21wb25lbnRTY2FsZVgsIGNvbXBvbmVudFNjYWxlWTtcbiAgICAgIHZhciB4LCB5LCBpO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgbnVtQ29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICB2YXIgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogbnVtQ29tcG9uZW50cztcbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGRhdGFMZW5ndGgpO1xuICAgICAgdmFyIGNvbXBvbmVudExpbmU7XG5cbiAgICAgIC8vIGxpbmVEYXRhIGlzIHJldXNlZCBmb3IgYWxsIGNvbXBvbmVudHMuIEFzc3VtZSBmaXJzdCBjb21wb25lbnQgaXNcbiAgICAgIC8vIHRoZSBiaWdnZXN0XG4gICAgICB2YXIgbGluZURhdGEgPSBuZXcgVWludDE2QXJyYXkoKHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lIDw8IDMpICpcbiAgICAgIHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW4gKiA4KTtcblxuICAgICAgLy8gRmlyc3QgY29uc3RydWN0IGltYWdlIGRhdGEgLi4uXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ29tcG9uZW50czsgaSsrKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tpXTtcbiAgICAgICAgdmFyIGJsb2Nrc1BlckxpbmUgPSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcbiAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbiA9IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW47XG4gICAgICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcblxuICAgICAgICB2YXIgaiwgaywgbGwgPSAwO1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGJsb2NrUm93ID0gMDsgYmxvY2tSb3cgPCBibG9ja3NQZXJDb2x1bW47IGJsb2NrUm93KyspIHtcbiAgICAgICAgICB2YXIgc2NhbkxpbmUgPSBibG9ja1JvdyA8PCAzO1xuICAgICAgICAgIGZvciAodmFyIGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0ID0gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCBibG9ja1JvdywgYmxvY2tDb2wpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDAsIHNhbXBsZSA9IGJsb2NrQ29sIDw8IDM7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gKHNjYW5MaW5lICsgaikgKiBzYW1wbGVzUGVyTGluZTtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgICAgICAgICAgIGxpbmVEYXRhW2xpbmVPZmZzZXQgKyBzYW1wbGUgKyBrXSA9XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQub3V0cHV0W2J1ZmZlck9mZnNldCArIG9mZnNldCsrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFNjYWxlWCA9IGNvbXBvbmVudC5zY2FsZVggKiBzY2FsZVg7XG4gICAgICAgIGNvbXBvbmVudFNjYWxlWSA9IGNvbXBvbmVudC5zY2FsZVkgKiBzY2FsZVk7XG4gICAgICAgIG9mZnNldCA9IGk7XG5cbiAgICAgICAgdmFyIGN4LCBjeTtcbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgY3kgPSAwIHwgKHkgKiBjb21wb25lbnRTY2FsZVkpO1xuICAgICAgICAgICAgY3ggPSAwIHwgKHggKiBjb21wb25lbnRTY2FsZVgpO1xuICAgICAgICAgICAgaW5kZXggPSBjeSAqIHNhbXBsZXNQZXJMaW5lICsgY3g7XG4gICAgICAgICAgICBkYXRhW29mZnNldF0gPSBsaW5lRGF0YVtpbmRleF07XG4gICAgICAgICAgICBvZmZzZXQgKz0gbnVtQ29tcG9uZW50cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24gZ2V0RGF0YSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgc2NhbGVYID0gdGhpcy53aWR0aCAvIHdpZHRoLCBzY2FsZVkgPSB0aGlzLmhlaWdodCAvIGhlaWdodDtcblxuICAgICAgdmFyIGNvbXBvbmVudCwgY29tcG9uZW50U2NhbGVYLCBjb21wb25lbnRTY2FsZVk7XG4gICAgICB2YXIgeCwgeSwgaTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIFksIENiLCBDciwgSywgQywgTSwgWWUsIFIsIEcsIEI7XG4gICAgICB2YXIgY29sb3JUcmFuc2Zvcm07XG4gICAgICB2YXIgbnVtQ29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICB2YXIgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogbnVtQ29tcG9uZW50cztcbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICB2YXIgY29tcG9uZW50TGluZTtcblxuICAgICAgLy8gbGluZURhdGEgaXMgcmV1c2VkIGZvciBhbGwgY29tcG9uZW50cy4gQXNzdW1lIGZpcnN0IGNvbXBvbmVudCBpc1xuICAgICAgLy8gdGhlIGJpZ2dlc3RcbiAgICAgIHZhciBsaW5lRGF0YSA9IG5ldyBVaW50OEFycmF5KCh0aGlzLmNvbXBvbmVudHNbMF0uYmxvY2tzUGVyTGluZSA8PCAzKSAqXG4gICAgICB0aGlzLmNvbXBvbmVudHNbMF0uYmxvY2tzUGVyQ29sdW1uICogOCk7XG5cbiAgICAgIC8vIEZpcnN0IGNvbnN0cnVjdCBpbWFnZSBkYXRhIC4uLlxuICAgICAgZm9yIChpID0gMDsgaSA8IG51bUNvbXBvbmVudHM7IGkrKykge1xuICAgICAgICBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNbaV07XG4gICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XG4gICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uO1xuICAgICAgICB2YXIgc2FtcGxlc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lIDw8IDM7XG5cbiAgICAgICAgdmFyIGosIGssIGxsID0gMDtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XG4gICAgICAgICAgdmFyIHNjYW5MaW5lID0gYmxvY2tSb3cgPDwgMztcbiAgICAgICAgICBmb3IgKHZhciBibG9ja0NvbCA9IDA7IGJsb2NrQ29sIDwgYmxvY2tzUGVyTGluZTsgYmxvY2tDb2wrKykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwLCBzYW1wbGUgPSBibG9ja0NvbCA8PCAzO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IChzY2FuTGluZSArIGopICogc2FtcGxlc1BlckxpbmU7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgICAgICAgICBsaW5lRGF0YVtsaW5lT2Zmc2V0ICsgc2FtcGxlICsga10gPVxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm91dHB1dFtidWZmZXJPZmZzZXQgKyBvZmZzZXQrK10gKiBjb21wb25lbnQuYml0Q29udmVyc2lvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudFNjYWxlWCA9IGNvbXBvbmVudC5zY2FsZVggKiBzY2FsZVg7XG4gICAgICAgIGNvbXBvbmVudFNjYWxlWSA9IGNvbXBvbmVudC5zY2FsZVkgKiBzY2FsZVk7XG4gICAgICAgIG9mZnNldCA9IGk7XG5cbiAgICAgICAgdmFyIGN4LCBjeTtcbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgY3kgPSAwIHwgKHkgKiBjb21wb25lbnRTY2FsZVkpO1xuICAgICAgICAgICAgY3ggPSAwIHwgKHggKiBjb21wb25lbnRTY2FsZVgpO1xuICAgICAgICAgICAgaW5kZXggPSBjeSAqIHNhbXBsZXNQZXJMaW5lICsgY3g7XG4gICAgICAgICAgICBkYXRhW29mZnNldF0gPSBsaW5lRGF0YVtpbmRleF07XG4gICAgICAgICAgICBvZmZzZXQgKz0gbnVtQ29tcG9uZW50cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gLi4uIHRoZW4gdHJhbnNmb3JtIGNvbG9ycywgaWYgbmVjZXNzYXJ5XG4gICAgICBzd2l0Y2ggKG51bUNvbXBvbmVudHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIG5vIGNvbG9yIGNvbnZlcnNpb24gZm9yIG9uZSBvciB0d28gY29tcG9lbmVudHNcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdHJhbnNmb3JtIGZvciB0aHJlZSBjb21wb25lbnRzIGlzIHRydWVcbiAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgLy8gVGhlIGFkb2JlIHRyYW5zZm9ybSBtYXJrZXIgb3ZlcnJpZGVzIGFueSBwcmV2aW91cyBzZXR0aW5nXG4gICAgICAgICAgaWYgKHRoaXMuYWRvYmUgJiYgdGhpcy5hZG9iZS50cmFuc2Zvcm1Db2RlKVxuICAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbG9yVHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gISF0aGlzLmNvbG9yVHJhbnNmb3JtO1xuXG4gICAgICAgICAgaWYgKGNvbG9yVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSArPSBudW1Db21wb25lbnRzKSB7XG4gICAgICAgICAgICAgIFkgPSBkYXRhW2kgICAgXTtcbiAgICAgICAgICAgICAgQ2IgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgQ3IgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICAgICAgICBSID0gY2xhbXBUb1VpbnQ4KFkgLSAxNzkuNDU2ICsgMS40MDIgKiBDcik7XG4gICAgICAgICAgICAgIEcgPSBjbGFtcFRvVWludDgoWSArIDEzNS40NTkgLSAwLjM0NCAqIENiIC0gMC43MTQgKiBDcik7XG4gICAgICAgICAgICAgIEIgPSBjbGFtcFRvVWludDgoWSAtIDIyNi44MTYgKyAxLjc3MiAqIENiKTtcblxuICAgICAgICAgICAgICBkYXRhW2kgICAgXSA9IFI7XG4gICAgICAgICAgICAgIGRhdGFbaSArIDFdID0gRztcbiAgICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGlmICghdGhpcy5hZG9iZSlcbiAgICAgICAgICAgIHRocm93ICdVbnN1cHBvcnRlZCBjb2xvciBtb2RlICg0IGNvbXBvbmVudHMpJztcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB0cmFuc2Zvcm0gZm9yIGZvdXIgY29tcG9uZW50cyBpcyBmYWxzZVxuICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgICAgLy8gVGhlIGFkb2JlIHRyYW5zZm9ybSBtYXJrZXIgb3ZlcnJpZGVzIGFueSBwcmV2aW91cyBzZXR0aW5nXG4gICAgICAgICAgaWYgKHRoaXMuYWRvYmUgJiYgdGhpcy5hZG9iZS50cmFuc2Zvcm1Db2RlKVxuICAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbG9yVHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gISF0aGlzLmNvbG9yVHJhbnNmb3JtO1xuXG4gICAgICAgICAgaWYgKGNvbG9yVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSArPSBudW1Db21wb25lbnRzKSB7XG4gICAgICAgICAgICAgIFkgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICBDYiA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICBDciA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgICAgICAgIEMgPSBjbGFtcFRvVWludDgoNDM0LjQ1NiAtIFkgLSAxLjQwMiAqIENyKTtcbiAgICAgICAgICAgICAgTSA9IGNsYW1wVG9VaW50OCgxMTkuNTQxIC0gWSArIDAuMzQ0ICogQ2IgKyAwLjcxNCAqIENyKTtcbiAgICAgICAgICAgICAgWSA9IGNsYW1wVG9VaW50OCg0ODEuODE2IC0gWSAtIDEuNzcyICogQ2IpO1xuXG4gICAgICAgICAgICAgIGRhdGFbaSAgICBdID0gQztcbiAgICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNO1xuICAgICAgICAgICAgICBkYXRhW2kgKyAyXSA9IFk7XG4gICAgICAgICAgICAgIC8vIEsgaXMgdW5jaGFuZ2VkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93ICdVbnN1cHBvcnRlZCBjb2xvciBtb2RlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gY29uc3RydWN0b3I7XG59KSgpO1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSnBlZ0ltYWdlO1xufSIsIi8qISBpbWFnZS1KUEVHMjAwMCAtIHYwLjMuMSAtIDIwMTUtMDgtMjYgfCBodHRwczovL2dpdGh1Yi5jb20vT0hJRi9pbWFnZS1KUEVHMjAwMCAqL1xuLyogLSotIE1vZGU6IEphdmE7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gKi9cbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cbi8qIENvcHlyaWdodCAyMDEyIE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZ2xvYmFscyBBcml0aG1ldGljRGVjb2RlciwgZ2xvYmFsU2NvcGUsIGxvZzIsIHJlYWRVaW50MTYsIHJlYWRVaW50MzIsXG4gICAgICAgICAgIGluZm8sIHdhcm4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSnB4SW1hZ2UgPSAoZnVuY3Rpb24gSnB4SW1hZ2VDbG9zdXJlKCkge1xuICAvLyBUYWJsZSBFLjFcbiAgdmFyIFN1YmJhbmRzR2FpbkxvZzIgPSB7XG4gICAgJ0xMJzogMCxcbiAgICAnTEgnOiAxLFxuICAgICdITCc6IDEsXG4gICAgJ0hIJzogMlxuICB9O1xuICBmdW5jdGlvbiBKcHhJbWFnZSgpIHtcbiAgICB0aGlzLmZhaWxPbkNvcnJ1cHRlZEltYWdlID0gZmFsc2U7XG4gIH1cbiAgSnB4SW1hZ2UucHJvdG90eXBlID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiBKcHhJbWFnZV9wYXJzZShkYXRhKSB7XG5cbiAgICAgIHZhciBoZWFkID0gcmVhZFVpbnQxNihkYXRhLCAwKTtcbiAgICAgIC8vIE5vIGJveCBoZWFkZXIsIGltbWVkaWF0ZSBzdGFydCBvZiBjb2Rlc3RyZWFtIChTT0MpXG4gICAgICBpZiAoaGVhZCA9PT0gMHhGRjRGKSB7XG4gICAgICAgIHRoaXMucGFyc2VDb2Rlc3RyZWFtKGRhdGEsIDAsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgaGVhZGVyU2l6ZSA9IDg7XG4gICAgICAgIHZhciBsYm94ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgIHZhciB0Ym94ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDQpO1xuICAgICAgICBwb3NpdGlvbiArPSBoZWFkZXJTaXplO1xuICAgICAgICBpZiAobGJveCA9PT0gMSkge1xuICAgICAgICAgIC8vIFhMQm94OiByZWFkIFVJbnQ2NCBhY2NvcmRpbmcgdG8gc3BlYy5cbiAgICAgICAgICAvLyBKYXZhU2NyaXB0J3MgaW50IHByZWNpc2lvbiBvZiA1MyBiaXQgc2hvdWxkIGJlIHN1ZmZpY2llbnQgaGVyZS5cbiAgICAgICAgICBsYm94ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbikgKiA0Mjk0OTY3Mjk2ICtcbiAgICAgICAgICAgICAgICAgcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDQpO1xuICAgICAgICAgIHBvc2l0aW9uICs9IDg7XG4gICAgICAgICAgaGVhZGVyU2l6ZSArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYm94ID09PSAwKSB7XG4gICAgICAgICAgbGJveCA9IGxlbmd0aCAtIHBvc2l0aW9uICsgaGVhZGVyU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGJveCA8IGhlYWRlclNpemUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogSW52YWxpZCBib3ggZmllbGQgc2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gbGJveCAtIGhlYWRlclNpemU7XG4gICAgICAgIHZhciBqdW1wRGF0YUxlbmd0aCA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAodGJveCkge1xuICAgICAgICAgIGNhc2UgMHg2QTcwMzI2ODogLy8gJ2pwMmgnXG4gICAgICAgICAgICBqdW1wRGF0YUxlbmd0aCA9IGZhbHNlOyAvLyBwYXJzaW5nIGNoaWxkIGJveGVzXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4NjM2RjZDNzI6IC8vICdjb2xyJ1xuICAgICAgICAgICAgLy8gQ29sb3JzcGFjZXMgYXJlIG5vdCB1c2VkLCB0aGUgQ1MgZnJvbSB0aGUgUERGIGlzIHVzZWQuXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gZGF0YVtwb3NpdGlvbl07XG4gICAgICAgICAgICB2YXIgcHJlY2VkZW5jZSA9IGRhdGFbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgICAgIHZhciBhcHByb3hpbWF0aW9uID0gZGF0YVtwb3NpdGlvbiArIDJdO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gMSkge1xuICAgICAgICAgICAgICAvLyBlbnVtZXJhdGVkIGNvbG9yc3BhY2VcbiAgICAgICAgICAgICAgdmFyIGNvbG9yc3BhY2UgPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMyk7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY29sb3JzcGFjZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6IC8vIHRoaXMgaW5kaWNhdGVzIGEgc1JHQiBjb2xvcnNwYWNlXG4gICAgICAgICAgICAgICAgY2FzZSAxNzogLy8gdGhpcyBpbmRpY2F0ZXMgYSBncmF5c2NhbGUgY29sb3JzcGFjZVxuICAgICAgICAgICAgICAgIGNhc2UgMTg6IC8vIHRoaXMgaW5kaWNhdGVzIGEgWVVWIGNvbG9yc3BhY2VcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB3YXJuKCdVbmtub3duIGNvbG9yc3BhY2UgJyArIGNvbG9yc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSAyKSB7XG4gICAgICAgICAgICAgIGluZm8oJ0lDQyBwcm9maWxlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHg2QTcwMzI2MzogLy8gJ2pwMmMnXG4gICAgICAgICAgICB0aGlzLnBhcnNlQ29kZXN0cmVhbShkYXRhLCBwb3NpdGlvbiwgcG9zaXRpb24gKyBkYXRhTGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHg2QTUwMjAyMDogLy8gJ2pQXFwwMjRcXDAyNCdcbiAgICAgICAgICAgIGlmICgweDBkMGE4NzBhICE9PSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIEpQMiBzaWduYXR1cmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaGVhZGVyIHR5cGVzIGFyZSB2YWxpZCBidXQgY3VycmVudGx5IG5vdCB1c2VkOlxuICAgICAgICAgIGNhc2UgMHg2QTUwMUExQTogLy8gJ2pQXFwwMzJcXDAzMidcbiAgICAgICAgICBjYXNlIDB4NjY3NDc5NzA6IC8vICdmdHlwJ1xuICAgICAgICAgIGNhc2UgMHg3MjcyNjU3MTogLy8gJ3JyZXEnXG4gICAgICAgICAgY2FzZSAweDcyNjU3MzIwOiAvLyAncmVzICdcbiAgICAgICAgICBjYXNlIDB4Njk2ODY0NzI6IC8vICdpaGRyJ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBoZWFkZXJUeXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZSgodGJveCA+PiAyNCkgJiAweEZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0Ym94ID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRib3ggPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRib3ggJiAweEZGKTtcbiAgICAgICAgICAgIHdhcm4oJ1Vuc3VwcG9ydGVkIGhlYWRlciB0eXBlICcgKyB0Ym94ICsgJyAoJyArIGhlYWRlclR5cGUgKyAnKScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGp1bXBEYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgcG9zaXRpb24gKz0gZGF0YUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2VJbWFnZVByb3BlcnRpZXM6IGZ1bmN0aW9uIEpweEltYWdlX3BhcnNlSW1hZ2VQcm9wZXJ0aWVzKHN0cmVhbSkge1xuICAgICAgdmFyIG5ld0J5dGUgPSBzdHJlYW0uZ2V0Qnl0ZSgpO1xuICAgICAgd2hpbGUgKG5ld0J5dGUgPj0gMCkge1xuICAgICAgICB2YXIgb2xkQnl0ZSA9IG5ld0J5dGU7XG4gICAgICAgIG5ld0J5dGUgPSBzdHJlYW0uZ2V0Qnl0ZSgpO1xuICAgICAgICB2YXIgY29kZSA9IChvbGRCeXRlIDw8IDgpIHwgbmV3Qnl0ZTtcbiAgICAgICAgLy8gSW1hZ2UgYW5kIHRpbGUgc2l6ZSAoU0laKVxuICAgICAgICBpZiAoY29kZSA9PT0gMHhGRjUxKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXAoNCk7XG4gICAgICAgICAgdmFyIFhzaXogPSBzdHJlYW0uZ2V0SW50MzIoKSA+Pj4gMDsgLy8gQnl0ZSA0XG4gICAgICAgICAgdmFyIFlzaXogPSBzdHJlYW0uZ2V0SW50MzIoKSA+Pj4gMDsgLy8gQnl0ZSA4XG4gICAgICAgICAgdmFyIFhPc2l6ID0gc3RyZWFtLmdldEludDMyKCkgPj4+IDA7IC8vIEJ5dGUgMTJcbiAgICAgICAgICB2YXIgWU9zaXogPSBzdHJlYW0uZ2V0SW50MzIoKSA+Pj4gMDsgLy8gQnl0ZSAxNlxuICAgICAgICAgIHN0cmVhbS5za2lwKDE2KTtcbiAgICAgICAgICB2YXIgQ3NpeiA9IHN0cmVhbS5nZXRVaW50MTYoKTsgLy8gQnl0ZSAzNlxuICAgICAgICAgIHRoaXMud2lkdGggPSBYc2l6IC0gWE9zaXo7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBZc2l6IC0gWU9zaXo7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzQ291bnQgPSBDc2l6O1xuICAgICAgICAgIC8vIFJlc3VsdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyBVaW50OEFycmF5c1xuICAgICAgICAgIHRoaXMuYml0c1BlckNvbXBvbmVudCA9IDg7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogTm8gc2l6ZSBtYXJrZXIgZm91bmQgaW4gSlBYIHN0cmVhbScpO1xuICAgIH0sXG4gICAgcGFyc2VDb2Rlc3RyZWFtOiBmdW5jdGlvbiBKcHhJbWFnZV9wYXJzZUNvZGVzdHJlYW0oZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBkb05vdFJlY292ZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlIChwb3NpdGlvbiArIDEgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgY29kZSA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG5cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gMCwgaiwgc3FjZCwgc3BxY2RzLCBzcHFjZFNpemUsIHNjYWxhckV4cG91bmRlZCwgdGlsZTtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMHhGRjRGOiAvLyBTdGFydCBvZiBjb2Rlc3RyZWFtIChTT0MpXG4gICAgICAgICAgICAgIGNvbnRleHQubWFpbkhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGRDk6IC8vIEVuZCBvZiBjb2Rlc3RyZWFtIChFT0MpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGNTE6IC8vIEltYWdlIGFuZCB0aWxlIHNpemUgKFNJWilcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHZhciBzaXogPSB7fTtcbiAgICAgICAgICAgICAgc2l6LlhzaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgNCk7XG4gICAgICAgICAgICAgIHNpei5Zc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDgpO1xuICAgICAgICAgICAgICBzaXouWE9zaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMTIpO1xuICAgICAgICAgICAgICBzaXouWU9zaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMTYpO1xuICAgICAgICAgICAgICBzaXouWFRzaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMjApO1xuICAgICAgICAgICAgICBzaXouWVRzaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMjQpO1xuICAgICAgICAgICAgICBzaXouWFRPc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDI4KTtcbiAgICAgICAgICAgICAgc2l6LllUT3NpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAzMik7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRzQ291bnQgPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uICsgMzYpO1xuICAgICAgICAgICAgICBzaXouQ3NpeiA9IGNvbXBvbmVudHNDb3VudDtcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgaiA9IHBvc2l0aW9uICsgMzg7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAoZGF0YVtqXSAmIDB4N0YpICsgMSxcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkOiAhIShkYXRhW2pdICYgMHg4MCksXG4gICAgICAgICAgICAgICAgICBYUnNpejogZGF0YVtqICsgMV0sXG4gICAgICAgICAgICAgICAgICBZUnNpejogZGF0YVtqICsgMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUNvbXBvbmVudERpbWVuc2lvbnMoY29tcG9uZW50LCBzaXopO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRleHQuU0laID0gc2l6O1xuICAgICAgICAgICAgICBjb250ZXh0LmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICAgICAgICBjYWxjdWxhdGVUaWxlR3JpZHMoY29udGV4dCwgY29tcG9uZW50cyk7XG4gICAgICAgICAgICAgIGNvbnRleHQuUUNDID0gW107XG4gICAgICAgICAgICAgIGNvbnRleHQuQ09DID0gW107XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGNUM6IC8vIFF1YW50aXphdGlvbiBkZWZhdWx0IChRQ0QpXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICB2YXIgcWNkID0ge307XG4gICAgICAgICAgICAgIGogPSBwb3NpdGlvbiArIDI7XG4gICAgICAgICAgICAgIHNxY2QgPSBkYXRhW2orK107XG4gICAgICAgICAgICAgIHN3aXRjaCAoc3FjZCAmIDB4MUYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBzcHFjZFNpemUgPSA4O1xuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDE2O1xuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBzcHFjZFNpemUgPSAxNjtcbiAgICAgICAgICAgICAgICAgIHNjYWxhckV4cG91bmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IEludmFsaWQgU1FjZCB2YWx1ZSAnICsgc3FjZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcWNkLm5vUXVhbnRpemF0aW9uID0gKHNwcWNkU2l6ZSA9PT0gOCk7XG4gICAgICAgICAgICAgIHFjZC5zY2FsYXJFeHBvdW5kZWQgPSBzY2FsYXJFeHBvdW5kZWQ7XG4gICAgICAgICAgICAgIHFjZC5ndWFyZEJpdHMgPSBzcWNkID4+IDU7XG4gICAgICAgICAgICAgIHNwcWNkcyA9IFtdO1xuICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbmd0aCArIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwcWNkID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHNwcWNkU2l6ZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgc3BxY2QuZXBzaWxvbiA9IGRhdGFbaisrXSA+PiAzO1xuICAgICAgICAgICAgICAgICAgc3BxY2QubXUgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzcHFjZC5lcHNpbG9uID0gZGF0YVtqXSA+PiAzO1xuICAgICAgICAgICAgICAgICAgc3BxY2QubXUgPSAoKGRhdGFbal0gJiAweDcpIDw8IDgpIHwgZGF0YVtqICsgMV07XG4gICAgICAgICAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwcWNkcy5wdXNoKHNwcWNkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBxY2QuU1BxY2RzID0gc3BxY2RzO1xuICAgICAgICAgICAgICBpZiAoY29udGV4dC5tYWluSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5RQ0QgPSBxY2Q7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5RQ0QgPSBxY2Q7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5RQ0MgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRjVEOiAvLyBRdWFudGl6YXRpb24gY29tcG9uZW50IChRQ0MpXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICB2YXIgcWNjID0ge307XG4gICAgICAgICAgICAgIGogPSBwb3NpdGlvbiArIDI7XG4gICAgICAgICAgICAgIHZhciBjcWNjO1xuICAgICAgICAgICAgICBpZiAoY29udGV4dC5TSVouQ3NpeiA8IDI1Nykge1xuICAgICAgICAgICAgICAgIGNxY2MgPSBkYXRhW2orK107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3FjYyA9IHJlYWRVaW50MTYoZGF0YSwgaik7XG4gICAgICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNxY2QgPSBkYXRhW2orK107XG4gICAgICAgICAgICAgIHN3aXRjaCAoc3FjZCAmIDB4MUYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBzcHFjZFNpemUgPSA4O1xuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDE2O1xuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBzcHFjZFNpemUgPSAxNjtcbiAgICAgICAgICAgICAgICAgIHNjYWxhckV4cG91bmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IEludmFsaWQgU1FjZCB2YWx1ZSAnICsgc3FjZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcWNjLm5vUXVhbnRpemF0aW9uID0gKHNwcWNkU2l6ZSA9PT0gOCk7XG4gICAgICAgICAgICAgIHFjYy5zY2FsYXJFeHBvdW5kZWQgPSBzY2FsYXJFeHBvdW5kZWQ7XG4gICAgICAgICAgICAgIHFjYy5ndWFyZEJpdHMgPSBzcWNkID4+IDU7XG4gICAgICAgICAgICAgIHNwcWNkcyA9IFtdO1xuICAgICAgICAgICAgICB3aGlsZSAoaiA8IChsZW5ndGggKyBwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBzcHFjZCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChzcHFjZFNpemUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgIHNwcWNkLmVwc2lsb24gPSBkYXRhW2orK10gPj4gMztcbiAgICAgICAgICAgICAgICAgIHNwcWNkLm11ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3BxY2QuZXBzaWxvbiA9IGRhdGFbal0gPj4gMztcbiAgICAgICAgICAgICAgICAgIHNwcWNkLm11ID0gKChkYXRhW2pdICYgMHg3KSA8PCA4KSB8IGRhdGFbaiArIDFdO1xuICAgICAgICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcHFjZHMucHVzaChzcHFjZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcWNjLlNQcWNkcyA9IHNwcWNkcztcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQubWFpbkhlYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuUUNDW2NxY2NdID0gcWNjO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbGUuUUNDW2NxY2NdID0gcWNjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGNTI6IC8vIENvZGluZyBzdHlsZSBkZWZhdWx0IChDT0QpXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICB2YXIgY29kID0ge307XG4gICAgICAgICAgICAgIGogPSBwb3NpdGlvbiArIDI7XG4gICAgICAgICAgICAgIHZhciBzY29kID0gZGF0YVtqKytdO1xuICAgICAgICAgICAgICBjb2QuZW50cm9weUNvZGVyV2l0aEN1c3RvbVByZWNpbmN0cyA9ICEhKHNjb2QgJiAxKTtcbiAgICAgICAgICAgICAgY29kLnNvcE1hcmtlclVzZWQgPSAhIShzY29kICYgMik7XG4gICAgICAgICAgICAgIGNvZC5lcGhNYXJrZXJVc2VkID0gISEoc2NvZCAmIDQpO1xuICAgICAgICAgICAgICBjb2QucHJvZ3Jlc3Npb25PcmRlciA9IGRhdGFbaisrXTtcbiAgICAgICAgICAgICAgY29kLmxheWVyc0NvdW50ID0gcmVhZFVpbnQxNihkYXRhLCBqKTtcbiAgICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgICBjb2QubXVsdGlwbGVDb21wb25lbnRUcmFuc2Zvcm0gPSBkYXRhW2orK107XG5cbiAgICAgICAgICAgICAgY29kLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IGRhdGFbaisrXTtcbiAgICAgICAgICAgICAgY29kLnhjYiA9IChkYXRhW2orK10gJiAweEYpICsgMjtcbiAgICAgICAgICAgICAgY29kLnljYiA9IChkYXRhW2orK10gJiAweEYpICsgMjtcbiAgICAgICAgICAgICAgdmFyIGJsb2NrU3R5bGUgPSBkYXRhW2orK107XG4gICAgICAgICAgICAgIGNvZC5zZWxlY3RpdmVBcml0aG1ldGljQ29kaW5nQnlwYXNzID0gISEoYmxvY2tTdHlsZSAmIDEpO1xuICAgICAgICAgICAgICBjb2QucmVzZXRDb250ZXh0UHJvYmFiaWxpdGllcyA9ICEhKGJsb2NrU3R5bGUgJiAyKTtcbiAgICAgICAgICAgICAgY29kLnRlcm1pbmF0aW9uT25FYWNoQ29kaW5nUGFzcyA9ICEhKGJsb2NrU3R5bGUgJiA0KTtcbiAgICAgICAgICAgICAgY29kLnZlcnRpY2FseVN0cmlwZSA9ICEhKGJsb2NrU3R5bGUgJiA4KTtcbiAgICAgICAgICAgICAgY29kLnByZWRpY3RhYmxlVGVybWluYXRpb24gPSAhIShibG9ja1N0eWxlICYgMTYpO1xuICAgICAgICAgICAgICBjb2Quc2VnbWVudGF0aW9uU3ltYm9sVXNlZCA9ICEhKGJsb2NrU3R5bGUgJiAzMik7XG4gICAgICAgICAgICAgIGNvZC5yZXZlcnNpYmxlVHJhbnNmb3JtYXRpb24gPSBkYXRhW2orK107XG4gICAgICAgICAgICAgIGlmIChjb2QuZW50cm9weUNvZGVyV2l0aEN1c3RvbVByZWNpbmN0cykge1xuICAgICAgICAgICAgICAgIHZhciBwcmVjaW5jdHNTaXplcyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuZ3RoICsgcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcmVjaW5jdHNTaXplID0gZGF0YVtqKytdO1xuICAgICAgICAgICAgICAgICAgcHJlY2luY3RzU2l6ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIFBQeDogcHJlY2luY3RzU2l6ZSAmIDB4RixcbiAgICAgICAgICAgICAgICAgICAgUFB5OiBwcmVjaW5jdHNTaXplID4+IDRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2QucHJlY2luY3RzU2l6ZXMgPSBwcmVjaW5jdHNTaXplcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKGNvZC5zZWxlY3RpdmVBcml0aG1ldGljQ29kaW5nQnlwYXNzKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQucHVzaCgnc2VsZWN0aXZlQXJpdGhtZXRpY0NvZGluZ0J5cGFzcycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb2QucmVzZXRDb250ZXh0UHJvYmFiaWxpdGllcykge1xuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkLnB1c2goJ3Jlc2V0Q29udGV4dFByb2JhYmlsaXRpZXMnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29kLnRlcm1pbmF0aW9uT25FYWNoQ29kaW5nUGFzcykge1xuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkLnB1c2goJ3Rlcm1pbmF0aW9uT25FYWNoQ29kaW5nUGFzcycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb2QudmVydGljYWx5U3RyaXBlKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQucHVzaCgndmVydGljYWx5U3RyaXBlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvZC5wcmVkaWN0YWJsZVRlcm1pbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQucHVzaCgncHJlZGljdGFibGVUZXJtaW5hdGlvbicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1bnN1cHBvcnRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZG9Ob3RSZWNvdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogVW5zdXBwb3J0ZWQgQ09EIG9wdGlvbnMgKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5qb2luKCcsICcpICsgJyknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29udGV4dC5tYWluSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5DT0QgPSBjb2Q7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5DT0QgPSBjb2Q7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5DT0MgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRjkwOiAvLyBTdGFydCBvZiB0aWxlLXBhcnQgKFNPVClcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHRpbGUgPSB7fTtcbiAgICAgICAgICAgICAgdGlsZS5pbmRleCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24gKyAyKTtcbiAgICAgICAgICAgICAgdGlsZS5sZW5ndGggPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgNCk7XG4gICAgICAgICAgICAgIHRpbGUuZGF0YUVuZCA9IHRpbGUubGVuZ3RoICsgcG9zaXRpb24gLSAyO1xuICAgICAgICAgICAgICB0aWxlLnBhcnRJbmRleCA9IGRhdGFbcG9zaXRpb24gKyA4XTtcbiAgICAgICAgICAgICAgdGlsZS5wYXJ0c0NvdW50ID0gZGF0YVtwb3NpdGlvbiArIDldO1xuXG4gICAgICAgICAgICAgIGNvbnRleHQubWFpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAodGlsZS5wYXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBjb21wb25lbnQgc3BlY2lmaWMgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICB0aWxlLkNPRCA9IGNvbnRleHQuQ09EO1xuICAgICAgICAgICAgICAgIHRpbGUuQ09DID0gY29udGV4dC5DT0Muc2xpY2UoMCk7IC8vIGNsb25lIG9mIHRoZSBnbG9iYWwgQ09DXG4gICAgICAgICAgICAgICAgdGlsZS5RQ0QgPSBjb250ZXh0LlFDRDtcbiAgICAgICAgICAgICAgICB0aWxlLlFDQyA9IGNvbnRleHQuUUNDLnNsaWNlKDApOyAvLyBjbG9uZSBvZiB0aGUgZ2xvYmFsIENPQ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbGUgPSB0aWxlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRjkzOiAvLyBTdGFydCBvZiBkYXRhIChTT0QpXG4gICAgICAgICAgICAgIHRpbGUgPSBjb250ZXh0LmN1cnJlbnRUaWxlO1xuICAgICAgICAgICAgICBpZiAodGlsZS5wYXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplVGlsZShjb250ZXh0LCB0aWxlLmluZGV4KTtcbiAgICAgICAgICAgICAgICBidWlsZFBhY2tldHMoY29udGV4dCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBtb3ZpbmcgdG8gdGhlIGVuZCBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgICBsZW5ndGggPSB0aWxlLmRhdGFFbmQgLSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgcGFyc2VUaWxlUGFja2V0cyhjb250ZXh0LCBkYXRhLCBwb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkY1NTogLy8gVGlsZS1wYXJ0IGxlbmd0aHMsIG1haW4gaGVhZGVyIChUTE0pXG4gICAgICAgICAgICBjYXNlIDB4RkY1NzogLy8gUGFja2V0IGxlbmd0aCwgbWFpbiBoZWFkZXIgKFBMTSlcbiAgICAgICAgICAgIGNhc2UgMHhGRjU4OiAvLyBQYWNrZXQgbGVuZ3RoLCB0aWxlLXBhcnQgaGVhZGVyIChQTFQpXG4gICAgICAgICAgICBjYXNlIDB4RkY2NDogLy8gQ29tbWVudCAoQ09NKVxuICAgICAgICAgICAgICBsZW5ndGggPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgLy8gc2tpcHBpbmcgY29udGVudFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRjUzOiAvLyBDb2Rpbmcgc3R5bGUgY29tcG9uZW50IChDT0MpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBDb2Rlc3RyZWFtIGNvZGUgMHhGRjUzIChDT0MpIGlzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IFVua25vd24gY29kZXN0cmVhbSBjb2RlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zaXRpb24gKz0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb05vdFJlY292ZXIgfHwgdGhpcy5mYWlsT25Db3JydXB0ZWRJbWFnZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybignVHJ5aW5nIHRvIHJlY292ZXIgZnJvbSAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50aWxlcyA9IHRyYW5zZm9ybUNvbXBvbmVudHMoY29udGV4dCk7XG4gICAgICB0aGlzLndpZHRoID0gY29udGV4dC5TSVouWHNpeiAtIGNvbnRleHQuU0laLlhPc2l6O1xuICAgICAgdGhpcy5oZWlnaHQgPSBjb250ZXh0LlNJWi5Zc2l6IC0gY29udGV4dC5TSVouWU9zaXo7XG4gICAgICB0aGlzLmNvbXBvbmVudHNDb3VudCA9IGNvbnRleHQuU0laLkNzaXo7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjYWxjdWxhdGVDb21wb25lbnREaW1lbnNpb25zKGNvbXBvbmVudCwgc2l6KSB7XG4gICAgLy8gU2VjdGlvbiBCLjIgQ29tcG9uZW50IG1hcHBpbmdcbiAgICBjb21wb25lbnQueDAgPSBNYXRoLmNlaWwoc2l6LlhPc2l6IC8gY29tcG9uZW50LlhSc2l6KTtcbiAgICBjb21wb25lbnQueDEgPSBNYXRoLmNlaWwoc2l6LlhzaXogLyBjb21wb25lbnQuWFJzaXopO1xuICAgIGNvbXBvbmVudC55MCA9IE1hdGguY2VpbChzaXouWU9zaXogLyBjb21wb25lbnQuWVJzaXopO1xuICAgIGNvbXBvbmVudC55MSA9IE1hdGguY2VpbChzaXouWXNpeiAvIGNvbXBvbmVudC5ZUnNpeik7XG4gICAgY29tcG9uZW50LndpZHRoID0gY29tcG9uZW50LngxIC0gY29tcG9uZW50LngwO1xuICAgIGNvbXBvbmVudC5oZWlnaHQgPSBjb21wb25lbnQueTEgLSBjb21wb25lbnQueTA7XG4gIH1cbiAgZnVuY3Rpb24gY2FsY3VsYXRlVGlsZUdyaWRzKGNvbnRleHQsIGNvbXBvbmVudHMpIHtcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XG4gICAgLy8gU2VjdGlvbiBCLjMgRGl2aXNpb24gaW50byB0aWxlIGFuZCB0aWxlLWNvbXBvbmVudHNcbiAgICB2YXIgdGlsZSwgdGlsZXMgPSBbXTtcbiAgICB2YXIgbnVtWHRpbGVzID0gTWF0aC5jZWlsKChzaXouWHNpeiAtIHNpei5YVE9zaXopIC8gc2l6LlhUc2l6KTtcbiAgICB2YXIgbnVtWXRpbGVzID0gTWF0aC5jZWlsKChzaXouWXNpeiAtIHNpei5ZVE9zaXopIC8gc2l6LllUc2l6KTtcbiAgICBmb3IgKHZhciBxID0gMDsgcSA8IG51bVl0aWxlczsgcSsrKSB7XG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IG51bVh0aWxlczsgcCsrKSB7XG4gICAgICAgIHRpbGUgPSB7fTtcbiAgICAgICAgdGlsZS50eDAgPSBNYXRoLm1heChzaXouWFRPc2l6ICsgcCAqIHNpei5YVHNpeiwgc2l6LlhPc2l6KTtcbiAgICAgICAgdGlsZS50eTAgPSBNYXRoLm1heChzaXouWVRPc2l6ICsgcSAqIHNpei5ZVHNpeiwgc2l6LllPc2l6KTtcbiAgICAgICAgdGlsZS50eDEgPSBNYXRoLm1pbihzaXouWFRPc2l6ICsgKHAgKyAxKSAqIHNpei5YVHNpeiwgc2l6LlhzaXopO1xuICAgICAgICB0aWxlLnR5MSA9IE1hdGgubWluKHNpei5ZVE9zaXogKyAocSArIDEpICogc2l6LllUc2l6LCBzaXouWXNpeik7XG4gICAgICAgIHRpbGUud2lkdGggPSB0aWxlLnR4MSAtIHRpbGUudHgwO1xuICAgICAgICB0aWxlLmhlaWdodCA9IHRpbGUudHkxIC0gdGlsZS50eTA7XG4gICAgICAgIHRpbGUuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aWxlcy5wdXNoKHRpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnRpbGVzID0gdGlsZXM7XG5cbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29tcG9uZW50c0NvdW50OyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSB0aWxlcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIHZhciB0aWxlQ29tcG9uZW50ID0ge307XG4gICAgICAgIHRpbGUgPSB0aWxlc1tqXTtcbiAgICAgICAgdGlsZUNvbXBvbmVudC50Y3gwID0gTWF0aC5jZWlsKHRpbGUudHgwIC8gY29tcG9uZW50LlhSc2l6KTtcbiAgICAgICAgdGlsZUNvbXBvbmVudC50Y3kwID0gTWF0aC5jZWlsKHRpbGUudHkwIC8gY29tcG9uZW50LllSc2l6KTtcbiAgICAgICAgdGlsZUNvbXBvbmVudC50Y3gxID0gTWF0aC5jZWlsKHRpbGUudHgxIC8gY29tcG9uZW50LlhSc2l6KTtcbiAgICAgICAgdGlsZUNvbXBvbmVudC50Y3kxID0gTWF0aC5jZWlsKHRpbGUudHkxIC8gY29tcG9uZW50LllSc2l6KTtcbiAgICAgICAgdGlsZUNvbXBvbmVudC53aWR0aCA9IHRpbGVDb21wb25lbnQudGN4MSAtIHRpbGVDb21wb25lbnQudGN4MDtcbiAgICAgICAgdGlsZUNvbXBvbmVudC5oZWlnaHQgPSB0aWxlQ29tcG9uZW50LnRjeTEgLSB0aWxlQ29tcG9uZW50LnRjeTA7XG4gICAgICAgIHRpbGUuY29tcG9uZW50c1tpXSA9IHRpbGVDb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldEJsb2Nrc0RpbWVuc2lvbnMoY29udGV4dCwgY29tcG9uZW50LCByKSB7XG4gICAgdmFyIGNvZE9yQ29jID0gY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycztcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKCFjb2RPckNvYy5lbnRyb3B5Q29kZXJXaXRoQ3VzdG9tUHJlY2luY3RzKSB7XG4gICAgICByZXN1bHQuUFB4ID0gMTU7XG4gICAgICByZXN1bHQuUFB5ID0gMTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5QUHggPSBjb2RPckNvYy5wcmVjaW5jdHNTaXplc1tyXS5QUHg7XG4gICAgICByZXN1bHQuUFB5ID0gY29kT3JDb2MucHJlY2luY3RzU2l6ZXNbcl0uUFB5O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgY29kZWJsb2NrIHNpemUgYXMgZGVzY3JpYmVkIGluIHNlY3Rpb24gQi43XG4gICAgcmVzdWx0LnhjYl8gPSAociA+IDAgPyBNYXRoLm1pbihjb2RPckNvYy54Y2IsIHJlc3VsdC5QUHggLSAxKSA6XG4gICAgICAgICAgICAgICAgICAgTWF0aC5taW4oY29kT3JDb2MueGNiLCByZXN1bHQuUFB4KSk7XG4gICAgcmVzdWx0LnljYl8gPSAociA+IDAgPyBNYXRoLm1pbihjb2RPckNvYy55Y2IsIHJlc3VsdC5QUHkgLSAxKSA6XG4gICAgICAgICAgICAgICAgICAgTWF0aC5taW4oY29kT3JDb2MueWNiLCByZXN1bHQuUFB5KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFByZWNpbmN0cyhjb250ZXh0LCByZXNvbHV0aW9uLCBkaW1lbnNpb25zKSB7XG4gICAgLy8gU2VjdGlvbiBCLjYgRGl2aXNpb24gcmVzb2x1dGlvbiB0byBwcmVjaW5jdHNcbiAgICB2YXIgcHJlY2luY3RXaWR0aCA9IDEgPDwgZGltZW5zaW9ucy5QUHg7XG4gICAgdmFyIHByZWNpbmN0SGVpZ2h0ID0gMSA8PCBkaW1lbnNpb25zLlBQeTtcbiAgICAvLyBKYXNwZXIgaW50cm9kdWNlcyBjb2RlYmxvY2sgZ3JvdXBzIGZvciBtYXBwaW5nIGVhY2ggc3ViYmFuZCBjb2RlYmxvY2tzXG4gICAgLy8gdG8gcHJlY2luY3RzLiBQcmVjaW5jdCBwYXJ0aXRpb24gZGl2aWRlcyBhIHJlc29sdXRpb24gYWNjb3JkaW5nIHRvIHdpZHRoXG4gICAgLy8gYW5kIGhlaWdodCBwYXJhbWV0ZXJzLiBUaGUgc3ViYmFuZCB0aGF0IGJlbG9uZ3MgdG8gdGhlIHJlc29sdXRpb24gbGV2ZWxcbiAgICAvLyBoYXMgYSBkaWZmZXJlbnQgc2l6ZSB0aGFuIHRoZSBsZXZlbCwgdW5sZXNzIGl0IGlzIHRoZSB6ZXJvIHJlc29sdXRpb24uXG5cbiAgICAvLyBGcm9tIEphc3BlciBkb2N1bWVudGF0aW9uOiBqcGVnMjAwMC5wZGYsIHNlY3Rpb24gSzogVGllci0yIGNvZGluZzpcbiAgICAvLyBUaGUgcHJlY2luY3QgcGFydGl0aW9uaW5nIGZvciBhIHBhcnRpY3VsYXIgc3ViYmFuZCBpcyBkZXJpdmVkIGZyb20gYVxuICAgIC8vIHBhcnRpdGlvbmluZyBvZiBpdHMgcGFyZW50IExMIGJhbmQgKGkuZS4sIHRoZSBMTCBiYW5kIGF0IHRoZSBuZXh0IGhpZ2hlclxuICAgIC8vIHJlc29sdXRpb24gbGV2ZWwpLi4uIFRoZSBMTCBiYW5kIGFzc29jaWF0ZWQgd2l0aCBlYWNoIHJlc29sdXRpb24gbGV2ZWwgaXNcbiAgICAvLyBkaXZpZGVkIGludG8gcHJlY2luY3RzLi4uIEVhY2ggb2YgdGhlIHJlc3VsdGluZyBwcmVjaW5jdCByZWdpb25zIGlzIHRoZW5cbiAgICAvLyBtYXBwZWQgaW50byBpdHMgY2hpbGQgc3ViYmFuZHMgKGlmIGFueSkgYXQgdGhlIG5leHQgbG93ZXIgcmVzb2x1dGlvblxuICAgIC8vIGxldmVsLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSB1c2luZyB0aGUgY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxuICAgIC8vICh1LCB2KSA9IChjZWlsKHgvMiksIGNlaWwoeS8yKSkgd2hlcmUgKHgsIHkpIGFuZCAodSwgdikgYXJlIHRoZVxuICAgIC8vIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgaW4gdGhlIExMIGJhbmQgYW5kIGNoaWxkIHN1YmJhbmQsIHJlc3BlY3RpdmVseS5cbiAgICB2YXIgaXNaZXJvUmVzID0gcmVzb2x1dGlvbi5yZXNMZXZlbCA9PT0gMDtcbiAgICB2YXIgcHJlY2luY3RXaWR0aEluU3ViYmFuZCA9IDEgPDwgKGRpbWVuc2lvbnMuUFB4ICsgKGlzWmVyb1JlcyA/IDAgOiAtMSkpO1xuICAgIHZhciBwcmVjaW5jdEhlaWdodEluU3ViYmFuZCA9IDEgPDwgKGRpbWVuc2lvbnMuUFB5ICsgKGlzWmVyb1JlcyA/IDAgOiAtMSkpO1xuICAgIHZhciBudW1wcmVjaW5jdHN3aWRlID0gKHJlc29sdXRpb24udHJ4MSA+IHJlc29sdXRpb24udHJ4MCA/XG4gICAgICBNYXRoLmNlaWwocmVzb2x1dGlvbi50cngxIC8gcHJlY2luY3RXaWR0aCkgLVxuICAgICAgTWF0aC5mbG9vcihyZXNvbHV0aW9uLnRyeDAgLyBwcmVjaW5jdFdpZHRoKSA6IDApO1xuICAgIHZhciBudW1wcmVjaW5jdHNoaWdoID0gKHJlc29sdXRpb24udHJ5MSA+IHJlc29sdXRpb24udHJ5MCA/XG4gICAgICBNYXRoLmNlaWwocmVzb2x1dGlvbi50cnkxIC8gcHJlY2luY3RIZWlnaHQpIC1cbiAgICAgIE1hdGguZmxvb3IocmVzb2x1dGlvbi50cnkwIC8gcHJlY2luY3RIZWlnaHQpIDogMCk7XG4gICAgdmFyIG51bXByZWNpbmN0cyA9IG51bXByZWNpbmN0c3dpZGUgKiBudW1wcmVjaW5jdHNoaWdoO1xuXG4gICAgcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMgPSB7XG4gICAgICBwcmVjaW5jdFdpZHRoOiBwcmVjaW5jdFdpZHRoLFxuICAgICAgcHJlY2luY3RIZWlnaHQ6IHByZWNpbmN0SGVpZ2h0LFxuICAgICAgbnVtcHJlY2luY3Rzd2lkZTogbnVtcHJlY2luY3Rzd2lkZSxcbiAgICAgIG51bXByZWNpbmN0c2hpZ2g6IG51bXByZWNpbmN0c2hpZ2gsXG4gICAgICBudW1wcmVjaW5jdHM6IG51bXByZWNpbmN0cyxcbiAgICAgIHByZWNpbmN0V2lkdGhJblN1YmJhbmQ6IHByZWNpbmN0V2lkdGhJblN1YmJhbmQsXG4gICAgICBwcmVjaW5jdEhlaWdodEluU3ViYmFuZDogcHJlY2luY3RIZWlnaHRJblN1YmJhbmRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBkaW1lbnNpb25zKSB7XG4gICAgLy8gU2VjdGlvbiBCLjcgRGl2aXNpb24gc3ViLWJhbmQgaW50byBjb2RlLWJsb2Nrc1xuICAgIHZhciB4Y2JfID0gZGltZW5zaW9ucy54Y2JfO1xuICAgIHZhciB5Y2JfID0gZGltZW5zaW9ucy55Y2JfO1xuICAgIHZhciBjb2RlYmxvY2tXaWR0aCA9IDEgPDwgeGNiXztcbiAgICB2YXIgY29kZWJsb2NrSGVpZ2h0ID0gMSA8PCB5Y2JfO1xuICAgIHZhciBjYngwID0gc3ViYmFuZC50YngwID4+IHhjYl87XG4gICAgdmFyIGNieTAgPSBzdWJiYW5kLnRieTAgPj4geWNiXztcbiAgICB2YXIgY2J4MSA9IChzdWJiYW5kLnRieDEgKyBjb2RlYmxvY2tXaWR0aCAtIDEpID4+IHhjYl87XG4gICAgdmFyIGNieTEgPSAoc3ViYmFuZC50YnkxICsgY29kZWJsb2NrSGVpZ2h0IC0gMSkgPj4geWNiXztcbiAgICB2YXIgcHJlY2luY3RQYXJhbWV0ZXJzID0gc3ViYmFuZC5yZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycztcbiAgICB2YXIgY29kZWJsb2NrcyA9IFtdO1xuICAgIHZhciBwcmVjaW5jdHMgPSBbXTtcbiAgICB2YXIgaSwgaiwgY29kZWJsb2NrLCBwcmVjaW5jdE51bWJlcjtcbiAgICBmb3IgKGogPSBjYnkwOyBqIDwgY2J5MTsgaisrKSB7XG4gICAgICBmb3IgKGkgPSBjYngwOyBpIDwgY2J4MTsgaSsrKSB7XG4gICAgICAgIGNvZGVibG9jayA9IHtcbiAgICAgICAgICBjYng6IGksXG4gICAgICAgICAgY2J5OiBqLFxuICAgICAgICAgIHRieDA6IGNvZGVibG9ja1dpZHRoICogaSxcbiAgICAgICAgICB0YnkwOiBjb2RlYmxvY2tIZWlnaHQgKiBqLFxuICAgICAgICAgIHRieDE6IGNvZGVibG9ja1dpZHRoICogKGkgKyAxKSxcbiAgICAgICAgICB0YnkxOiBjb2RlYmxvY2tIZWlnaHQgKiAoaiArIDEpXG4gICAgICAgIH07XG5cbiAgICAgICAgY29kZWJsb2NrLnRieDBfID0gTWF0aC5tYXgoc3ViYmFuZC50YngwLCBjb2RlYmxvY2sudGJ4MCk7XG4gICAgICAgIGNvZGVibG9jay50YnkwXyA9IE1hdGgubWF4KHN1YmJhbmQudGJ5MCwgY29kZWJsb2NrLnRieTApO1xuICAgICAgICBjb2RlYmxvY2sudGJ4MV8gPSBNYXRoLm1pbihzdWJiYW5kLnRieDEsIGNvZGVibG9jay50YngxKTtcbiAgICAgICAgY29kZWJsb2NrLnRieTFfID0gTWF0aC5taW4oc3ViYmFuZC50YnkxLCBjb2RlYmxvY2sudGJ5MSk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNpbmN0IG51bWJlciBmb3IgdGhpcyBjb2RlYmxvY2ssIGNvZGVibG9jayBwb3NpdGlvblxuICAgICAgICAvLyBzaG91bGQgYmUgcmVsYXRpdmUgdG8gaXRzIHN1YmJhbmQsIHVzZSBhY3R1YWwgZGltZW5zaW9uIGFuZCBwb3NpdGlvblxuICAgICAgICAvLyBTZWUgY29tbWVudCBhYm91dCBjb2RlYmxvY2sgZ3JvdXAgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICB2YXIgcGkgPSBNYXRoLmZsb29yKChjb2RlYmxvY2sudGJ4MF8gLSBzdWJiYW5kLnRieDApIC9cbiAgICAgICAgICBwcmVjaW5jdFBhcmFtZXRlcnMucHJlY2luY3RXaWR0aEluU3ViYmFuZCk7XG4gICAgICAgIHZhciBwaiA9IE1hdGguZmxvb3IoKGNvZGVibG9jay50YnkwXyAtIHN1YmJhbmQudGJ5MCkgL1xuICAgICAgICAgIHByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdEhlaWdodEluU3ViYmFuZCk7XG4gICAgICAgIHByZWNpbmN0TnVtYmVyID0gcGkgKyAocGogKiBwcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3Rzd2lkZSk7XG5cbiAgICAgICAgY29kZWJsb2NrLnByZWNpbmN0TnVtYmVyID0gcHJlY2luY3ROdW1iZXI7XG4gICAgICAgIGNvZGVibG9jay5zdWJiYW5kVHlwZSA9IHN1YmJhbmQudHlwZTtcbiAgICAgICAgY29kZWJsb2NrLkxibG9jayA9IDM7XG5cbiAgICAgICAgaWYgKGNvZGVibG9jay50YngxXyA8PSBjb2RlYmxvY2sudGJ4MF8gfHxcbiAgICAgICAgICAgIGNvZGVibG9jay50YnkxXyA8PSBjb2RlYmxvY2sudGJ5MF8pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlYmxvY2tzLnB1c2goY29kZWJsb2NrKTtcbiAgICAgICAgLy8gYnVpbGRpbmcgcHJlY2luY3QgZm9yIHRoZSBzdWItYmFuZFxuICAgICAgICB2YXIgcHJlY2luY3QgPSBwcmVjaW5jdHNbcHJlY2luY3ROdW1iZXJdO1xuICAgICAgICBpZiAocHJlY2luY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChpIDwgcHJlY2luY3QuY2J4TWluKSB7XG4gICAgICAgICAgICBwcmVjaW5jdC5jYnhNaW4gPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IHByZWNpbmN0LmNieE1heCkge1xuICAgICAgICAgICAgcHJlY2luY3QuY2J4TWF4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGogPCBwcmVjaW5jdC5jYnlNaW4pIHtcbiAgICAgICAgICAgIHByZWNpbmN0LmNieE1pbiA9IGo7XG4gICAgICAgICAgfSBlbHNlIGlmIChqID4gcHJlY2luY3QuY2J5TWF4KSB7XG4gICAgICAgICAgICBwcmVjaW5jdC5jYnlNYXggPSBqO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVjaW5jdHNbcHJlY2luY3ROdW1iZXJdID0gcHJlY2luY3QgPSB7XG4gICAgICAgICAgICBjYnhNaW46IGksXG4gICAgICAgICAgICBjYnlNaW46IGosXG4gICAgICAgICAgICBjYnhNYXg6IGksXG4gICAgICAgICAgICBjYnlNYXg6IGpcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvZGVibG9jay5wcmVjaW5jdCA9IHByZWNpbmN0O1xuICAgICAgfVxuICAgIH1cbiAgICBzdWJiYW5kLmNvZGVibG9ja1BhcmFtZXRlcnMgPSB7XG4gICAgICBjb2RlYmxvY2tXaWR0aDogeGNiXyxcbiAgICAgIGNvZGVibG9ja0hlaWdodDogeWNiXyxcbiAgICAgIG51bWNvZGVibG9ja3dpZGU6IGNieDEgLSBjYngwICsgMSxcbiAgICAgIG51bWNvZGVibG9ja2hpZ2g6IGNieTEgLSBjYnkwICsgMVxuICAgIH07XG4gICAgc3ViYmFuZC5jb2RlYmxvY2tzID0gY29kZWJsb2NrcztcbiAgICBzdWJiYW5kLnByZWNpbmN0cyA9IHByZWNpbmN0cztcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgcHJlY2luY3ROdW1iZXIsIGxheWVyTnVtYmVyKSB7XG4gICAgdmFyIHByZWNpbmN0Q29kZWJsb2NrcyA9IFtdO1xuICAgIC8vIFNlY3Rpb24gQi4xMC44IE9yZGVyIG9mIGluZm8gaW4gcGFja2V0XG4gICAgdmFyIHN1YmJhbmRzID0gcmVzb2x1dGlvbi5zdWJiYW5kcztcbiAgICAvLyBzdWItYmFuZHMgYWxyZWFkeSBvcmRlcmVkIGluICdMTCcsICdITCcsICdMSCcsIGFuZCAnSEgnIHNlcXVlbmNlXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gc3ViYmFuZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIHN1YmJhbmQgPSBzdWJiYW5kc1tpXTtcbiAgICAgIHZhciBjb2RlYmxvY2tzID0gc3ViYmFuZC5jb2RlYmxvY2tzO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gY29kZWJsb2Nrcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIHZhciBjb2RlYmxvY2sgPSBjb2RlYmxvY2tzW2pdO1xuICAgICAgICBpZiAoY29kZWJsb2NrLnByZWNpbmN0TnVtYmVyICE9PSBwcmVjaW5jdE51bWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHByZWNpbmN0Q29kZWJsb2Nrcy5wdXNoKGNvZGVibG9jayk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsYXllck51bWJlcjogbGF5ZXJOdW1iZXIsXG4gICAgICBjb2RlYmxvY2tzOiBwcmVjaW5jdENvZGVibG9ja3NcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIExheWVyUmVzb2x1dGlvbkNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoY29udGV4dCkge1xuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcbiAgICB2YXIgbGF5ZXJzQ291bnQgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQ7XG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xuICAgIHZhciBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSAwO1xuICAgIGZvciAodmFyIHEgPSAwOyBxIDwgY29tcG9uZW50c0NvdW50OyBxKyspIHtcbiAgICAgIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IE1hdGgubWF4KG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCxcbiAgICAgICAgdGlsZS5jb21wb25lbnRzW3FdLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpO1xuICAgIH1cblxuICAgIHZhciBsID0gMCwgciA9IDAsIGkgPSAwLCBrID0gMDtcblxuICAgIHRoaXMubmV4dFBhY2tldCA9IGZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKSB7XG4gICAgICAvLyBTZWN0aW9uIEIuMTIuMS4xIExheWVyLXJlc29sdXRpb24tY29tcG9uZW50LXBvc2l0aW9uXG4gICAgICBmb3IgKDsgbCA8IGxheWVyc0NvdW50OyBsKyspIHtcbiAgICAgICAgZm9yICg7IHIgPD0gbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyByKyspIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHIgPiBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XG4gICAgICAgICAgICB2YXIgbnVtcHJlY2luY3RzID0gcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzO1xuICAgICAgICAgICAgZm9yICg7IGsgPCBudW1wcmVjaW5jdHM7KSB7XG4gICAgICAgICAgICAgIHZhciBwYWNrZXQgPSBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgaywgbCk7XG4gICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgICByID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIFJlc29sdXRpb25MYXllckNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoY29udGV4dCkge1xuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcbiAgICB2YXIgbGF5ZXJzQ291bnQgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQ7XG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xuICAgIHZhciBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSAwO1xuICAgIGZvciAodmFyIHEgPSAwOyBxIDwgY29tcG9uZW50c0NvdW50OyBxKyspIHtcbiAgICAgIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IE1hdGgubWF4KG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCxcbiAgICAgICAgdGlsZS5jb21wb25lbnRzW3FdLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpO1xuICAgIH1cblxuICAgIHZhciByID0gMCwgbCA9IDAsIGkgPSAwLCBrID0gMDtcblxuICAgIHRoaXMubmV4dFBhY2tldCA9IGZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKSB7XG4gICAgICAvLyBTZWN0aW9uIEIuMTIuMS4yIFJlc29sdXRpb24tbGF5ZXItY29tcG9uZW50LXBvc2l0aW9uXG4gICAgICBmb3IgKDsgciA8PSBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xuICAgICAgICBmb3IgKDsgbCA8IGxheWVyc0NvdW50OyBsKyspIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHIgPiBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XG4gICAgICAgICAgICB2YXIgbnVtcHJlY2luY3RzID0gcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzO1xuICAgICAgICAgICAgZm9yICg7IGsgPCBudW1wcmVjaW5jdHM7KSB7XG4gICAgICAgICAgICAgIHZhciBwYWNrZXQgPSBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgaywgbCk7XG4gICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIFJlc29sdXRpb25Qb3NpdGlvbkNvbXBvbmVudExheWVySXRlcmF0b3IoY29udGV4dCkge1xuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcbiAgICB2YXIgbGF5ZXJzQ291bnQgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQ7XG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xuICAgIHZhciBsLCByLCBjLCBwO1xuICAgIHZhciBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSAwO1xuICAgIGZvciAoYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcbiAgICAgIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IE1hdGgubWF4KG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCxcbiAgICAgICAgY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpO1xuICAgIH1cbiAgICB2YXIgbWF4TnVtUHJlY2luY3RzSW5MZXZlbCA9IG5ldyBJbnQzMkFycmF5KFxuICAgICAgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ICsgMSk7XG4gICAgZm9yIChyID0gMDsgciA8PSBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7ICsrcikge1xuICAgICAgdmFyIG1heE51bVByZWNpbmN0cyA9IDA7XG4gICAgICBmb3IgKGMgPSAwOyBjIDwgY29tcG9uZW50c0NvdW50OyArK2MpIHtcbiAgICAgICAgdmFyIHJlc29sdXRpb25zID0gdGlsZS5jb21wb25lbnRzW2NdLnJlc29sdXRpb25zO1xuICAgICAgICBpZiAociA8IHJlc29sdXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIG1heE51bVByZWNpbmN0cyA9IE1hdGgubWF4KG1heE51bVByZWNpbmN0cyxcbiAgICAgICAgICAgIHJlc29sdXRpb25zW3JdLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXhOdW1QcmVjaW5jdHNJbkxldmVsW3JdID0gbWF4TnVtUHJlY2luY3RzO1xuICAgIH1cbiAgICBsID0gMDtcbiAgICByID0gMDtcbiAgICBjID0gMDtcbiAgICBwID0gMDtcblxuICAgIHRoaXMubmV4dFBhY2tldCA9IGZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKSB7XG4gICAgICAvLyBTZWN0aW9uIEIuMTIuMS4zIFJlc29sdXRpb24tcG9zaXRpb24tY29tcG9uZW50LWxheWVyXG4gICAgICBmb3IgKDsgciA8PSBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xuICAgICAgICBmb3IgKDsgcCA8IG1heE51bVByZWNpbmN0c0luTGV2ZWxbcl07IHArKykge1xuICAgICAgICAgIGZvciAoOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XG4gICAgICAgICAgICBpZiAociA+IGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XG4gICAgICAgICAgICB2YXIgbnVtcHJlY2luY3RzID0gcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzO1xuICAgICAgICAgICAgaWYgKHAgPj0gbnVtcHJlY2luY3RzKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IGwgPCBsYXllcnNDb3VudDspIHtcbiAgICAgICAgICAgICAgdmFyIHBhY2tldCA9IGNyZWF0ZVBhY2tldChyZXNvbHV0aW9uLCBwLCBsKTtcbiAgICAgICAgICAgICAgbCsrO1xuICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHAgPSAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gUG9zaXRpb25Db21wb25lbnRSZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihjb250ZXh0KSB7XG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xuICAgIHZhciBsYXllcnNDb3VudCA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5sYXllcnNDb3VudDtcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XG4gICAgdmFyIHByZWNpbmN0c1NpemVzID0gZ2V0UHJlY2luY3RTaXplc0luSW1hZ2VTY2FsZSh0aWxlKTtcbiAgICB2YXIgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMgPSBwcmVjaW5jdHNTaXplcztcbiAgICB2YXIgbCA9IDAsIHIgPSAwLCBjID0gMCwgcHggPSAwLCBweSA9IDA7XG5cbiAgICB0aGlzLm5leHRQYWNrZXQgPSBmdW5jdGlvbiBKcHhJbWFnZV9uZXh0UGFja2V0KCkge1xuICAgICAgLy8gU2VjdGlvbiBCLjEyLjEuNCBQb3NpdGlvbi1jb21wb25lbnQtcmVzb2x1dGlvbi1sYXllclxuICAgICAgZm9yICg7IHB5IDwgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMubWF4TnVtSGlnaDsgcHkrKykge1xuICAgICAgICBmb3IgKDsgcHggPCBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5tYXhOdW1XaWRlOyBweCsrKSB7XG4gICAgICAgICAgZm9yICg7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcbiAgICAgICAgICAgIHZhciBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPVxuICAgICAgICAgICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtcbiAgICAgICAgICAgIGZvciAoOyByIDw9IGRlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XG4gICAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gY29tcG9uZW50LnJlc29sdXRpb25zW3JdO1xuICAgICAgICAgICAgICB2YXIgc2l6ZUluSW1hZ2VTY2FsZSA9XG4gICAgICAgICAgICAgICAgcHJlY2luY3RzU2l6ZXMuY29tcG9uZW50c1tjXS5yZXNvbHV0aW9uc1tyXTtcbiAgICAgICAgICAgICAgdmFyIGsgPSBnZXRQcmVjaW5jdEluZGV4SWZFeGlzdChcbiAgICAgICAgICAgICAgICBweCxcbiAgICAgICAgICAgICAgICBweSxcbiAgICAgICAgICAgICAgICBzaXplSW5JbWFnZVNjYWxlLFxuICAgICAgICAgICAgICAgIHByZWNpbmN0c0l0ZXJhdGlvblNpemVzLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24pO1xuICAgICAgICAgICAgICBpZiAoayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoOyBsIDwgbGF5ZXJzQ291bnQ7KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhY2tldCA9IGNyZWF0ZVBhY2tldChyZXNvbHV0aW9uLCBrLCBsKTtcbiAgICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjID0gMDtcbiAgICAgICAgfVxuICAgICAgICBweCA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBDb21wb25lbnRQb3NpdGlvblJlc29sdXRpb25MYXllckl0ZXJhdG9yKGNvbnRleHQpIHtcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XG4gICAgdmFyIHRpbGVJbmRleCA9IGNvbnRleHQuY3VycmVudFRpbGUuaW5kZXg7XG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XG4gICAgdmFyIGxheWVyc0NvdW50ID0gdGlsZS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLmxheWVyc0NvdW50O1xuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcbiAgICB2YXIgcHJlY2luY3RzU2l6ZXMgPSBnZXRQcmVjaW5jdFNpemVzSW5JbWFnZVNjYWxlKHRpbGUpO1xuICAgIHZhciBsID0gMCwgciA9IDAsIGMgPSAwLCBweCA9IDAsIHB5ID0gMDtcblxuICAgIHRoaXMubmV4dFBhY2tldCA9IGZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKSB7XG4gICAgICAvLyBTZWN0aW9uIEIuMTIuMS41IENvbXBvbmVudC1wb3NpdGlvbi1yZXNvbHV0aW9uLWxheWVyXG4gICAgICBmb3IgKDsgYyA8IGNvbXBvbmVudHNDb3VudDsgKytjKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XG4gICAgICAgIHZhciBwcmVjaW5jdHNJdGVyYXRpb25TaXplcyA9IHByZWNpbmN0c1NpemVzLmNvbXBvbmVudHNbY107XG4gICAgICAgIHZhciBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPVxuICAgICAgICAgIGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50O1xuICAgICAgICBmb3IgKDsgcHkgPCBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5tYXhOdW1IaWdoOyBweSsrKSB7XG4gICAgICAgICAgZm9yICg7IHB4IDwgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMubWF4TnVtV2lkZTsgcHgrKykge1xuICAgICAgICAgICAgZm9yICg7IHIgPD0gZGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XG4gICAgICAgICAgICAgIHZhciBzaXplSW5JbWFnZVNjYWxlID0gcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMucmVzb2x1dGlvbnNbcl07XG4gICAgICAgICAgICAgIHZhciBrID0gZ2V0UHJlY2luY3RJbmRleElmRXhpc3QoXG4gICAgICAgICAgICAgICAgcHgsXG4gICAgICAgICAgICAgICAgcHksXG4gICAgICAgICAgICAgICAgc2l6ZUluSW1hZ2VTY2FsZSxcbiAgICAgICAgICAgICAgICBwcmVjaW5jdHNJdGVyYXRpb25TaXplcyxcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgaWYgKGsgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKDsgbCA8IGxheWVyc0NvdW50Oykge1xuICAgICAgICAgICAgICAgIHZhciBwYWNrZXQgPSBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgaywgbCk7XG4gICAgICAgICAgICAgICAgbCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB5ID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFByZWNpbmN0SW5kZXhJZkV4aXN0KFxuICAgIHB4SW5kZXgsIHB5SW5kZXgsIHNpemVJbkltYWdlU2NhbGUsIHByZWNpbmN0SXRlcmF0aW9uU2l6ZXMsIHJlc29sdXRpb24pIHtcbiAgICB2YXIgcG9zWCA9IHB4SW5kZXggKiBwcmVjaW5jdEl0ZXJhdGlvblNpemVzLm1pbldpZHRoO1xuICAgIHZhciBwb3NZID0gcHlJbmRleCAqIHByZWNpbmN0SXRlcmF0aW9uU2l6ZXMubWluSGVpZ2h0O1xuICAgIGlmIChwb3NYICUgc2l6ZUluSW1hZ2VTY2FsZS53aWR0aCAhPT0gMCB8fFxuICAgICAgICBwb3NZICUgc2l6ZUluSW1hZ2VTY2FsZS5oZWlnaHQgIT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3RhcnRQcmVjaW5jdFJvd0luZGV4ID1cbiAgICAgIChwb3NZIC8gc2l6ZUluSW1hZ2VTY2FsZS53aWR0aCkgKlxuICAgICAgcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3Rzd2lkZTtcbiAgICByZXR1cm4gKHBvc1ggLyBzaXplSW5JbWFnZVNjYWxlLmhlaWdodCkgKyBzdGFydFByZWNpbmN0Um93SW5kZXg7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UHJlY2luY3RTaXplc0luSW1hZ2VTY2FsZSh0aWxlKSB7XG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHRpbGUuY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIG1pbldpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWluSGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWF4TnVtV2lkZSA9IDA7XG4gICAgdmFyIG1heE51bUhpZ2ggPSAwO1xuICAgIHZhciBzaXplUGVyQ29tcG9uZW50ID0gbmV3IEFycmF5KGNvbXBvbmVudHNDb3VudCk7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcbiAgICAgIHZhciBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPVxuICAgICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtcbiAgICAgIHZhciBzaXplUGVyUmVzb2x1dGlvbiA9IG5ldyBBcnJheShkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgKyAxKTtcbiAgICAgIHZhciBtaW5XaWR0aEN1cnJlbnRDb21wb25lbnQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIG1heE51bVdpZGVDdXJyZW50Q29tcG9uZW50ID0gMDtcbiAgICAgIHZhciBtYXhOdW1IaWdoQ3VycmVudENvbXBvbmVudCA9IDA7XG4gICAgICB2YXIgc2NhbGUgPSAxO1xuICAgICAgZm9yICh2YXIgciA9IGRlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgciA+PSAwOyAtLXIpIHtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XG4gICAgICAgIHZhciB3aWR0aEN1cnJlbnRSZXNvbHV0aW9uID1cbiAgICAgICAgICBzY2FsZSAqIHJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzLnByZWNpbmN0V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRDdXJyZW50UmVzb2x1dGlvbiA9XG4gICAgICAgICAgc2NhbGUgKiByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdEhlaWdodDtcbiAgICAgICAgbWluV2lkdGhDdXJyZW50Q29tcG9uZW50ID0gTWF0aC5taW4oXG4gICAgICAgICAgbWluV2lkdGhDdXJyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHdpZHRoQ3VycmVudFJlc29sdXRpb24pO1xuICAgICAgICBtaW5IZWlnaHRDdXJyZW50Q29tcG9uZW50ID0gTWF0aC5taW4oXG4gICAgICAgICAgbWluSGVpZ2h0Q3VycmVudENvbXBvbmVudCxcbiAgICAgICAgICBoZWlnaHRDdXJyZW50UmVzb2x1dGlvbik7XG4gICAgICAgIG1heE51bVdpZGVDdXJyZW50Q29tcG9uZW50ID0gTWF0aC5tYXgobWF4TnVtV2lkZUN1cnJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3Rzd2lkZSk7XG4gICAgICAgIG1heE51bUhpZ2hDdXJyZW50Q29tcG9uZW50ID0gTWF0aC5tYXgobWF4TnVtSGlnaEN1cnJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzaGlnaCk7XG4gICAgICAgIHNpemVQZXJSZXNvbHV0aW9uW3JdID0ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aEN1cnJlbnRSZXNvbHV0aW9uLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0Q3VycmVudFJlc29sdXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgc2NhbGUgPDw9IDE7XG4gICAgICB9XG4gICAgICBtaW5XaWR0aCA9IE1hdGgubWluKG1pbldpZHRoLCBtaW5XaWR0aEN1cnJlbnRDb21wb25lbnQpO1xuICAgICAgbWluSGVpZ2h0ID0gTWF0aC5taW4obWluSGVpZ2h0LCBtaW5IZWlnaHRDdXJyZW50Q29tcG9uZW50KTtcbiAgICAgIG1heE51bVdpZGUgPSBNYXRoLm1heChtYXhOdW1XaWRlLCBtYXhOdW1XaWRlQ3VycmVudENvbXBvbmVudCk7XG4gICAgICBtYXhOdW1IaWdoID0gTWF0aC5tYXgobWF4TnVtSGlnaCwgbWF4TnVtSGlnaEN1cnJlbnRDb21wb25lbnQpO1xuICAgICAgc2l6ZVBlckNvbXBvbmVudFtjXSA9IHtcbiAgICAgICAgcmVzb2x1dGlvbnM6IHNpemVQZXJSZXNvbHV0aW9uLFxuICAgICAgICBtaW5XaWR0aDogbWluV2lkdGhDdXJyZW50Q29tcG9uZW50LFxuICAgICAgICBtaW5IZWlnaHQ6IG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQsXG4gICAgICAgIG1heE51bVdpZGU6IG1heE51bVdpZGVDdXJyZW50Q29tcG9uZW50LFxuICAgICAgICBtYXhOdW1IaWdoOiBtYXhOdW1IaWdoQ3VycmVudENvbXBvbmVudFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvbmVudHM6IHNpemVQZXJDb21wb25lbnQsXG4gICAgICBtaW5XaWR0aDogbWluV2lkdGgsXG4gICAgICBtaW5IZWlnaHQ6IG1pbkhlaWdodCxcbiAgICAgIG1heE51bVdpZGU6IG1heE51bVdpZGUsXG4gICAgICBtYXhOdW1IaWdoOiBtYXhOdW1IaWdoXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFBhY2tldHMoY29udGV4dCkge1xuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XG4gICAgLy8gQ3JlYXRpbmcgcmVzb2x1dGlvbnMgYW5kIHN1Yi1iYW5kcyBmb3IgZWFjaCBjb21wb25lbnRcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xuICAgICAgdmFyIGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9XG4gICAgICAgIGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50O1xuICAgICAgLy8gU2VjdGlvbiBCLjUgUmVzb2x1dGlvbiBsZXZlbHMgYW5kIHN1Yi1iYW5kc1xuICAgICAgdmFyIHJlc29sdXRpb25zID0gW107XG4gICAgICB2YXIgc3ViYmFuZHMgPSBbXTtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDw9IGRlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XG4gICAgICAgIHZhciBibG9ja3NEaW1lbnNpb25zID0gZ2V0QmxvY2tzRGltZW5zaW9ucyhjb250ZXh0LCBjb21wb25lbnQsIHIpO1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHt9O1xuICAgICAgICB2YXIgc2NhbGUgPSAxIDw8IChkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgLSByKTtcbiAgICAgICAgcmVzb2x1dGlvbi50cngwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gwIC8gc2NhbGUpO1xuICAgICAgICByZXNvbHV0aW9uLnRyeTAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTAgLyBzY2FsZSk7XG4gICAgICAgIHJlc29sdXRpb24udHJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIHNjYWxlKTtcbiAgICAgICAgcmVzb2x1dGlvbi50cnkxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kxIC8gc2NhbGUpO1xuICAgICAgICByZXNvbHV0aW9uLnJlc0xldmVsID0gcjtcbiAgICAgICAgYnVpbGRQcmVjaW5jdHMoY29udGV4dCwgcmVzb2x1dGlvbiwgYmxvY2tzRGltZW5zaW9ucyk7XG4gICAgICAgIHJlc29sdXRpb25zLnB1c2gocmVzb2x1dGlvbik7XG5cbiAgICAgICAgdmFyIHN1YmJhbmQ7XG4gICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgLy8gb25lIHN1Yi1iYW5kIChMTCkgd2l0aCBsYXN0IGRlY29tcG9zaXRpb25cbiAgICAgICAgICBzdWJiYW5kID0ge307XG4gICAgICAgICAgc3ViYmFuZC50eXBlID0gJ0xMJztcbiAgICAgICAgICBzdWJiYW5kLnRieDAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDAgLyBzY2FsZSk7XG4gICAgICAgICAgc3ViYmFuZC50YnkwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kwIC8gc2NhbGUpO1xuICAgICAgICAgIHN1YmJhbmQudGJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIHNjYWxlKTtcbiAgICAgICAgICBzdWJiYW5kLnRieTEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTEgLyBzY2FsZSk7XG4gICAgICAgICAgc3ViYmFuZC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICBidWlsZENvZGVibG9ja3MoY29udGV4dCwgc3ViYmFuZCwgYmxvY2tzRGltZW5zaW9ucyk7XG4gICAgICAgICAgc3ViYmFuZHMucHVzaChzdWJiYW5kKTtcbiAgICAgICAgICByZXNvbHV0aW9uLnN1YmJhbmRzID0gW3N1YmJhbmRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBic2NhbGUgPSAxIDw8IChkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgLSByICsgMSk7XG4gICAgICAgICAgdmFyIHJlc29sdXRpb25TdWJiYW5kcyA9IFtdO1xuICAgICAgICAgIC8vIHRocmVlIHN1Yi1iYW5kcyAoSEwsIExIIGFuZCBISCkgd2l0aCByZXN0IG9mIGRlY29tcG9zaXRpb25zXG4gICAgICAgICAgc3ViYmFuZCA9IHt9O1xuICAgICAgICAgIHN1YmJhbmQudHlwZSA9ICdITCc7XG4gICAgICAgICAgc3ViYmFuZC50YngwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gwIC8gYnNjYWxlIC0gMC41KTtcbiAgICAgICAgICBzdWJiYW5kLnRieTAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTAgLyBic2NhbGUpO1xuICAgICAgICAgIHN1YmJhbmQudGJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIGJzY2FsZSAtIDAuNSk7XG4gICAgICAgICAgc3ViYmFuZC50YnkxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kxIC8gYnNjYWxlKTtcbiAgICAgICAgICBzdWJiYW5kLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICAgIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBibG9ja3NEaW1lbnNpb25zKTtcbiAgICAgICAgICBzdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xuICAgICAgICAgIHJlc29sdXRpb25TdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xuXG4gICAgICAgICAgc3ViYmFuZCA9IHt9O1xuICAgICAgICAgIHN1YmJhbmQudHlwZSA9ICdMSCc7XG4gICAgICAgICAgc3ViYmFuZC50YngwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gwIC8gYnNjYWxlKTtcbiAgICAgICAgICBzdWJiYW5kLnRieTAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTAgLyBic2NhbGUgLSAwLjUpO1xuICAgICAgICAgIHN1YmJhbmQudGJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIGJzY2FsZSk7XG4gICAgICAgICAgc3ViYmFuZC50YnkxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kxIC8gYnNjYWxlIC0gMC41KTtcbiAgICAgICAgICBzdWJiYW5kLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICAgIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBibG9ja3NEaW1lbnNpb25zKTtcbiAgICAgICAgICBzdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xuICAgICAgICAgIHJlc29sdXRpb25TdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xuXG4gICAgICAgICAgc3ViYmFuZCA9IHt9O1xuICAgICAgICAgIHN1YmJhbmQudHlwZSA9ICdISCc7XG4gICAgICAgICAgc3ViYmFuZC50YngwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gwIC8gYnNjYWxlIC0gMC41KTtcbiAgICAgICAgICBzdWJiYW5kLnRieTAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTAgLyBic2NhbGUgLSAwLjUpO1xuICAgICAgICAgIHN1YmJhbmQudGJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIGJzY2FsZSAtIDAuNSk7XG4gICAgICAgICAgc3ViYmFuZC50YnkxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kxIC8gYnNjYWxlIC0gMC41KTtcbiAgICAgICAgICBzdWJiYW5kLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICAgIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBibG9ja3NEaW1lbnNpb25zKTtcbiAgICAgICAgICBzdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xuICAgICAgICAgIHJlc29sdXRpb25TdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xuXG4gICAgICAgICAgcmVzb2x1dGlvbi5zdWJiYW5kcyA9IHJlc29sdXRpb25TdWJiYW5kcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tcG9uZW50LnJlc29sdXRpb25zID0gcmVzb2x1dGlvbnM7XG4gICAgICBjb21wb25lbnQuc3ViYmFuZHMgPSBzdWJiYW5kcztcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgdGhlIHBhY2tldHMgc2VxdWVuY2VcbiAgICB2YXIgcHJvZ3Jlc3Npb25PcmRlciA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5wcm9ncmVzc2lvbk9yZGVyO1xuICAgIHN3aXRjaCAocHJvZ3Jlc3Npb25PcmRlcikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XG4gICAgICAgICAgbmV3IExheWVyUmVzb2x1dGlvbkNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XG4gICAgICAgICAgbmV3IFJlc29sdXRpb25MYXllckNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XG4gICAgICAgICAgbmV3IFJlc29sdXRpb25Qb3NpdGlvbkNvbXBvbmVudExheWVySXRlcmF0b3IoY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XG4gICAgICAgICAgbmV3IFBvc2l0aW9uQ29tcG9uZW50UmVzb2x1dGlvbkxheWVySXRlcmF0b3IoY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XG4gICAgICAgICAgbmV3IENvbXBvbmVudFBvc2l0aW9uUmVzb2x1dGlvbkxheWVySXRlcmF0b3IoY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IFVuc3VwcG9ydGVkIHByb2dyZXNzaW9uIG9yZGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3Npb25PcmRlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVGlsZVBhY2tldHMoY29udGV4dCwgZGF0YSwgb2Zmc2V0LCBkYXRhTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB2YXIgYnVmZmVyLCBidWZmZXJTaXplID0gMCwgc2tpcE5leHRCaXQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiByZWFkQml0cyhjb3VudCkge1xuICAgICAgd2hpbGUgKGJ1ZmZlclNpemUgPCBjb3VudCkge1xuICAgICAgICBpZihvZmZzZXQgKyBwb3NpdGlvbiAgPj0gZGF0YS5sZW5ndGgpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgRU9GXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gZGF0YVtvZmZzZXQgKyBwb3NpdGlvbl07XG4gICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIGlmIChza2lwTmV4dEJpdCkge1xuICAgICAgICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgNykgfCBiO1xuICAgICAgICAgIGJ1ZmZlclNpemUgKz0gNztcbiAgICAgICAgICBza2lwTmV4dEJpdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBiO1xuICAgICAgICAgIGJ1ZmZlclNpemUgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiA9PT0gMHhGRikge1xuICAgICAgICAgIHNraXBOZXh0Qml0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyU2l6ZSAtPSBjb3VudDtcbiAgICAgIHJldHVybiAoYnVmZmVyID4+PiBidWZmZXJTaXplKSAmICgoMSA8PCBjb3VudCkgLSAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2tpcE1hcmtlcklmRXF1YWwodmFsdWUpIHtcbiAgICAgIGlmIChkYXRhW29mZnNldCArIHBvc2l0aW9uIC0gMV0gPT09IDB4RkYgJiZcbiAgICAgICAgICBkYXRhW29mZnNldCArIHBvc2l0aW9uXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgc2tpcEJ5dGVzKDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YVtvZmZzZXQgKyBwb3NpdGlvbl0gPT09IDB4RkYgJiZcbiAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyBwb3NpdGlvbiArIDFdID09PSB2YWx1ZSkge1xuICAgICAgICBza2lwQnl0ZXMoMik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBza2lwQnl0ZXMoY291bnQpIHtcbiAgICAgIHBvc2l0aW9uICs9IGNvdW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbGlnblRvQnl0ZSgpIHtcbiAgICAgIGJ1ZmZlclNpemUgPSAwO1xuICAgICAgaWYgKHNraXBOZXh0Qml0KSB7XG4gICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIHNraXBOZXh0Qml0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb2RpbmdwYXNzZXMoKSB7XG4gICAgICBpZiAocmVhZEJpdHMoMSkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAocmVhZEJpdHMoMSkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSByZWFkQml0cygyKTtcbiAgICAgIGlmICh2YWx1ZSA8IDMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICsgMztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcmVhZEJpdHMoNSk7XG4gICAgICBpZiAodmFsdWUgPCAzMSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyA2O1xuICAgICAgfVxuICAgICAgdmFsdWUgPSByZWFkQml0cyg3KTtcbiAgICAgIHJldHVybiB2YWx1ZSArIDM3O1xuICAgIH1cbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcbiAgICB2YXIgc29wTWFya2VyVXNlZCA9IGNvbnRleHQuQ09ELnNvcE1hcmtlclVzZWQ7XG4gICAgdmFyIGVwaE1hcmtlclVzZWQgPSBjb250ZXh0LkNPRC5lcGhNYXJrZXJVc2VkO1xuICAgIHZhciBwYWNrZXRzSXRlcmF0b3IgPSB0aWxlLnBhY2tldHNJdGVyYXRvcjtcbiAgICB3aGlsZSAocG9zaXRpb24gPCBkYXRhTGVuZ3RoKSB7XG4gICAgICB0cnl7XG4gICAgICAgIGFsaWduVG9CeXRlKCk7XG4gICAgICAgIGlmIChzb3BNYXJrZXJVc2VkICYmIHNraXBNYXJrZXJJZkVxdWFsKDB4OTEpKSB7XG4gICAgICAgICAgLy8gU2tpcCBhbHNvIG1hcmtlciBzZWdtZW50IGxlbmd0aCBhbmQgcGFja2V0IHNlcXVlbmNlIElEXG4gICAgICAgICAgc2tpcEJ5dGVzKDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWNrZXQgPSBwYWNrZXRzSXRlcmF0b3IubmV4dFBhY2tldCgpO1xuICAgICAgICBpZiAocGFja2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvL05vIG1vcmUgcGFja2V0cy4gU3RyZWFtIGlzIHByb2JhYmx5IHRydW5jYXRlZC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWFkQml0cygxKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXllck51bWJlciA9IHBhY2tldC5sYXllck51bWJlcjtcbiAgICAgICAgdmFyIHF1ZXVlID0gW10sIGNvZGVibG9jaztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFja2V0LmNvZGVibG9ja3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGNvZGVibG9jayA9IHBhY2tldC5jb2RlYmxvY2tzW2ldO1xuICAgICAgICAgIHZhciBwcmVjaW5jdCA9IGNvZGVibG9jay5wcmVjaW5jdDtcbiAgICAgICAgICB2YXIgY29kZWJsb2NrQ29sdW1uID0gY29kZWJsb2NrLmNieCAtIHByZWNpbmN0LmNieE1pbjtcbiAgICAgICAgICB2YXIgY29kZWJsb2NrUm93ID0gY29kZWJsb2NrLmNieSAtIHByZWNpbmN0LmNieU1pbjtcbiAgICAgICAgICB2YXIgY29kZWJsb2NrSW5jbHVkZWQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZmlyc3RUaW1lSW5jbHVzaW9uID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHZhbHVlUmVhZHk7XG4gICAgICAgICAgaWYgKGNvZGVibG9ja1snaW5jbHVkZWQnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2RlYmxvY2tJbmNsdWRlZCA9ICEhcmVhZEJpdHMoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlYWRpbmcgaW5jbHVzaW9uIHRyZWVcbiAgICAgICAgICAgIHByZWNpbmN0ID0gY29kZWJsb2NrLnByZWNpbmN0O1xuICAgICAgICAgICAgdmFyIGluY2x1c2lvblRyZWUsIHplcm9CaXRQbGFuZXNUcmVlO1xuICAgICAgICAgICAgaWYgKHByZWNpbmN0WydpbmNsdXNpb25UcmVlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlID0gcHJlY2luY3QuaW5jbHVzaW9uVHJlZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGJ1aWxkaW5nIGluY2x1c2lvbiBhbmQgemVybyBiaXQtcGxhbmVzIHRyZWVzXG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IHByZWNpbmN0LmNieE1heCAtIHByZWNpbmN0LmNieE1pbiArIDE7XG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwcmVjaW5jdC5jYnlNYXggLSBwcmVjaW5jdC5jYnlNaW4gKyAxO1xuICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlID0gbmV3IEluY2x1c2lvblRyZWUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgIHplcm9CaXRQbGFuZXNUcmVlID0gbmV3IFRhZ1RyZWUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgIHByZWNpbmN0LmluY2x1c2lvblRyZWUgPSBpbmNsdXNpb25UcmVlO1xuICAgICAgICAgICAgICBwcmVjaW5jdC56ZXJvQml0UGxhbmVzVHJlZSA9IHplcm9CaXRQbGFuZXNUcmVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmNsdXNpb25UcmVlLnJlc2V0KGNvZGVibG9ja0NvbHVtbiwgY29kZWJsb2NrUm93LCBsYXllck51bWJlcik7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGluY2x1c2lvblRyZWUuaXNBYm92ZVRocmVzaG9sZCgpKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uVHJlZS5pc0tub3duKCkpIHtcbiAgICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlLm5leHRMZXZlbCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZWFkQml0cygxKSkge1xuICAgICAgICAgICAgICAgIGluY2x1c2lvblRyZWUuc2V0S25vd24oKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uVHJlZS5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgY29kZWJsb2NrLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNvZGVibG9ja0luY2x1ZGVkID0gZmlyc3RUaW1lSW5jbHVzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlLm5leHRMZXZlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlLmluY3JlbWVudFZhbHVlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb2RlYmxvY2tJbmNsdWRlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaXJzdFRpbWVJbmNsdXNpb24pIHtcbiAgICAgICAgICAgIHplcm9CaXRQbGFuZXNUcmVlID0gcHJlY2luY3QuemVyb0JpdFBsYW5lc1RyZWU7XG4gICAgICAgICAgICB6ZXJvQml0UGxhbmVzVHJlZS5yZXNldChjb2RlYmxvY2tDb2x1bW4sIGNvZGVibG9ja1Jvdyk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlYWRCaXRzKDEpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVSZWFkeSA9ICF6ZXJvQml0UGxhbmVzVHJlZS5uZXh0TGV2ZWwoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHplcm9CaXRQbGFuZXNUcmVlLmluY3JlbWVudFZhbHVlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVibG9jay56ZXJvQml0UGxhbmVzID0gemVyb0JpdFBsYW5lc1RyZWUudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb2RpbmdwYXNzZXMgPSByZWFkQ29kaW5ncGFzc2VzKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRCaXRzKDEpKSB7XG4gICAgICAgICAgICBjb2RlYmxvY2suTGJsb2NrKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb2RpbmdwYXNzZXNMb2cyID0gbG9nMihjb2RpbmdwYXNzZXMpO1xuICAgICAgICAgIC8vIHJvdW5kaW5nIGRvd24gbG9nMlxuICAgICAgICAgIHZhciBiaXRzID0gKChjb2RpbmdwYXNzZXMgPCAoMSA8PCBjb2RpbmdwYXNzZXNMb2cyKSkgP1xuICAgICAgICAgICAgICAgICAgICAgIGNvZGluZ3Bhc3Nlc0xvZzIgLSAxIDogY29kaW5ncGFzc2VzTG9nMikgKyBjb2RlYmxvY2suTGJsb2NrO1xuICAgICAgICAgIHZhciBjb2RlZERhdGFMZW5ndGggPSByZWFkQml0cyhiaXRzKTtcbiAgICAgICAgICBxdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGNvZGVibG9jazogY29kZWJsb2NrLFxuICAgICAgICAgICAgY29kaW5ncGFzc2VzOiBjb2RpbmdwYXNzZXMsXG4gICAgICAgICAgICBkYXRhTGVuZ3RoOiBjb2RlZERhdGFMZW5ndGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhbGlnblRvQnl0ZSgpO1xuICAgICAgICBpZiAoZXBoTWFya2VyVXNlZCkge1xuICAgICAgICAgIHNraXBNYXJrZXJJZkVxdWFsKDB4OTIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHBhY2tldEl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIGNvZGVibG9jayA9IHBhY2tldEl0ZW0uY29kZWJsb2NrO1xuICAgICAgICAgIGlmIChjb2RlYmxvY2tbJ2RhdGEnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2RlYmxvY2suZGF0YSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb2RlYmxvY2suZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBzdGFydDogb2Zmc2V0ICsgcG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IG9mZnNldCArIHBvc2l0aW9uICsgcGFja2V0SXRlbS5kYXRhTGVuZ3RoLFxuICAgICAgICAgICAgY29kaW5ncGFzc2VzOiBwYWNrZXRJdGVtLmNvZGluZ3Bhc3Nlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvc2l0aW9uICs9IHBhY2tldEl0ZW0uZGF0YUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBjb3B5Q29lZmZpY2llbnRzKGNvZWZmaWNpZW50cywgbGV2ZWxXaWR0aCwgbGV2ZWxIZWlnaHQsIHN1YmJhbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEsIG1iLCByZXZlcnNpYmxlLCBzZWdtZW50YXRpb25TeW1ib2xVc2VkKSB7XG4gICAgdmFyIHgwID0gc3ViYmFuZC50YngwO1xuICAgIHZhciB5MCA9IHN1YmJhbmQudGJ5MDtcbiAgICB2YXIgd2lkdGggPSBzdWJiYW5kLnRieDEgLSBzdWJiYW5kLnRieDA7XG4gICAgdmFyIGNvZGVibG9ja3MgPSBzdWJiYW5kLmNvZGVibG9ja3M7XG4gICAgdmFyIHJpZ2h0ID0gc3ViYmFuZC50eXBlLmNoYXJBdCgwKSA9PT0gJ0gnID8gMSA6IDA7XG4gICAgdmFyIGJvdHRvbSA9IHN1YmJhbmQudHlwZS5jaGFyQXQoMSkgPT09ICdIJyA/IGxldmVsV2lkdGggOiAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29kZWJsb2Nrcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgY29kZWJsb2NrID0gY29kZWJsb2Nrc1tpXTtcbiAgICAgIHZhciBibG9ja1dpZHRoID0gY29kZWJsb2NrLnRieDFfIC0gY29kZWJsb2NrLnRieDBfO1xuICAgICAgdmFyIGJsb2NrSGVpZ2h0ID0gY29kZWJsb2NrLnRieTFfIC0gY29kZWJsb2NrLnRieTBfO1xuICAgICAgaWYgKGJsb2NrV2lkdGggPT09IDAgfHwgYmxvY2tIZWlnaHQgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY29kZWJsb2NrWydkYXRhJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJpdE1vZGVsLCBjdXJyZW50Q29kaW5ncGFzc1R5cGU7XG4gICAgICBiaXRNb2RlbCA9IG5ldyBCaXRNb2RlbChibG9ja1dpZHRoLCBibG9ja0hlaWdodCwgY29kZWJsb2NrLnN1YmJhbmRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWJsb2NrLnplcm9CaXRQbGFuZXMsIG1iKTtcbiAgICAgIGN1cnJlbnRDb2RpbmdwYXNzVHlwZSA9IDI7IC8vIGZpcnN0IGJpdCBwbGFuZSBzdGFydHMgZnJvbSBjbGVhbnVwXG5cbiAgICAgIC8vIGNvbGxlY3QgZGF0YVxuICAgICAgdmFyIGRhdGEgPSBjb2RlYmxvY2suZGF0YSwgdG90YWxMZW5ndGggPSAwLCBjb2RpbmdwYXNzZXMgPSAwO1xuICAgICAgdmFyIGosIGpqLCBkYXRhSXRlbTtcbiAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGRhdGFJdGVtID0gZGF0YVtqXTtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUl0ZW0uZW5kIC0gZGF0YUl0ZW0uc3RhcnQ7XG4gICAgICAgIGNvZGluZ3Bhc3NlcyArPSBkYXRhSXRlbS5jb2RpbmdwYXNzZXM7XG4gICAgICB9XG4gICAgICB2YXIgZW5jb2RlZERhdGEgPSBuZXcgSW50MTZBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgZGF0YUl0ZW0gPSBkYXRhW2pdO1xuICAgICAgICB2YXIgY2h1bmsgPSBkYXRhSXRlbS5kYXRhLnN1YmFycmF5KGRhdGFJdGVtLnN0YXJ0LCBkYXRhSXRlbS5lbmQpO1xuICAgICAgICBlbmNvZGVkRGF0YS5zZXQoY2h1bmssIHBvc2l0aW9uKTtcbiAgICAgICAgcG9zaXRpb24gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgfVxuICAgICAgLy8gZGVjb2RpbmcgdGhlIGl0ZW1cbiAgICAgIHZhciBkZWNvZGVyID0gbmV3IEFyaXRobWV0aWNEZWNvZGVyKGVuY29kZWREYXRhLCAwLCB0b3RhbExlbmd0aCk7XG4gICAgICBiaXRNb2RlbC5zZXREZWNvZGVyKGRlY29kZXIpO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgY29kaW5ncGFzc2VzOyBqKyspIHtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50Q29kaW5ncGFzc1R5cGUpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBiaXRNb2RlbC5ydW5TaWduaWZpY2FuY2VQcm9wb2dhdGlvblBhc3MoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGJpdE1vZGVsLnJ1bk1hZ25pdHVkZVJlZmluZW1lbnRQYXNzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBiaXRNb2RlbC5ydW5DbGVhbnVwUGFzcygpO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRhdGlvblN5bWJvbFVzZWQpIHtcbiAgICAgICAgICAgICAgYml0TW9kZWwuY2hlY2tTZWdtZW50YXRpb25TeW1ib2woKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRDb2RpbmdwYXNzVHlwZSA9IChjdXJyZW50Q29kaW5ncGFzc1R5cGUgKyAxKSAlIDM7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSAoY29kZWJsb2NrLnRieDBfIC0geDApICsgKGNvZGVibG9jay50YnkwXyAtIHkwKSAqIHdpZHRoO1xuICAgICAgdmFyIHNpZ24gPSBiaXRNb2RlbC5jb2VmZmljZW50c1NpZ247XG4gICAgICB2YXIgbWFnbml0dWRlID0gYml0TW9kZWwuY29lZmZpY2VudHNNYWduaXR1ZGU7XG4gICAgICB2YXIgYml0c0RlY29kZWQgPSBiaXRNb2RlbC5iaXRzRGVjb2RlZDtcbiAgICAgIHZhciBtYWduaXR1ZGVDb3JyZWN0aW9uID0gcmV2ZXJzaWJsZSA/IDAgOiAwLjU7XG4gICAgICB2YXIgaywgbiwgbmI7XG4gICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICAvLyBEbyB0aGUgaW50ZXJsZWF2aW5nIG9mIFNlY3Rpb24gRi4zLjMgaGVyZSwgc28gd2UgZG8gbm90IG5lZWRcbiAgICAgIC8vIHRvIGNvcHkgbGF0ZXIuIExMIGxldmVsIGlzIG5vdCBpbnRlcmxlYXZlZCwganVzdCBjb3BpZWQuXG4gICAgICB2YXIgaW50ZXJsZWF2ZSA9IChzdWJiYW5kLnR5cGUgIT09ICdMTCcpO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGJsb2NrSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgdmFyIHJvdyA9IChvZmZzZXQgLyB3aWR0aCkgfCAwOyAvLyByb3cgaW4gdGhlIG5vbi1pbnRlcmxlYXZlZCBzdWJiYW5kXG4gICAgICAgIHZhciBsZXZlbE9mZnNldCA9IDIgKiByb3cgKiAobGV2ZWxXaWR0aCAtIHdpZHRoKSArIHJpZ2h0ICsgYm90dG9tO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgYmxvY2tXaWR0aDsgaysrKSB7XG4gICAgICAgICAgbiA9IG1hZ25pdHVkZVtwb3NpdGlvbl07XG4gICAgICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgICAgIG4gPSAobiArIG1hZ25pdHVkZUNvcnJlY3Rpb24pICogZGVsdGE7XG4gICAgICAgICAgICBpZiAoc2lnbltwb3NpdGlvbl0gIT09IDApIHtcbiAgICAgICAgICAgICAgbiA9IC1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmIgPSBiaXRzRGVjb2RlZFtwb3NpdGlvbl07XG4gICAgICAgICAgICB2YXIgcG9zID0gaW50ZXJsZWF2ZSA/IChsZXZlbE9mZnNldCArIChvZmZzZXQgPDwgMSkpIDogb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHJldmVyc2libGUgJiYgKG5iID49IG1iKSkge1xuICAgICAgICAgICAgICBjb2VmZmljaWVudHNbcG9zXSA9IG47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2VmZmljaWVudHNbcG9zXSA9IG4gKiAoMSA8PCAobWIgLSBuYikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSB3aWR0aCAtIGJsb2NrV2lkdGg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVRpbGUoY29udGV4dCwgdGlsZSwgYykge1xuICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XG4gICAgdmFyIGNvZGluZ1N0eWxlUGFyYW1ldGVycyA9IGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnM7XG4gICAgdmFyIHF1YW50aXphdGlvblBhcmFtZXRlcnMgPSBjb21wb25lbnQucXVhbnRpemF0aW9uUGFyYW1ldGVycztcbiAgICB2YXIgZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID1cbiAgICAgIGNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7XG4gICAgdmFyIHNwcWNkcyA9IHF1YW50aXphdGlvblBhcmFtZXRlcnMuU1BxY2RzO1xuICAgIHZhciBzY2FsYXJFeHBvdW5kZWQgPSBxdWFudGl6YXRpb25QYXJhbWV0ZXJzLnNjYWxhckV4cG91bmRlZDtcbiAgICB2YXIgZ3VhcmRCaXRzID0gcXVhbnRpemF0aW9uUGFyYW1ldGVycy5ndWFyZEJpdHM7XG4gICAgdmFyIHNlZ21lbnRhdGlvblN5bWJvbFVzZWQgPSBjb2RpbmdTdHlsZVBhcmFtZXRlcnMuc2VnbWVudGF0aW9uU3ltYm9sVXNlZDtcbiAgICB2YXIgcHJlY2lzaW9uID0gY29udGV4dC5jb21wb25lbnRzW2NdLnByZWNpc2lvbjtcblxuICAgIHZhciByZXZlcnNpYmxlID0gY29kaW5nU3R5bGVQYXJhbWV0ZXJzLnJldmVyc2libGVUcmFuc2Zvcm1hdGlvbjtcbiAgICB2YXIgdHJhbnNmb3JtID0gKHJldmVyc2libGUgPyBuZXcgUmV2ZXJzaWJsZVRyYW5zZm9ybSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgSXJyZXZlcnNpYmxlVHJhbnNmb3JtKCkpO1xuXG4gICAgdmFyIHN1YmJhbmRDb2VmZmljaWVudHMgPSBbXTtcbiAgICB2YXIgYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyBpKyspIHtcbiAgICAgIHZhciByZXNvbHV0aW9uID0gY29tcG9uZW50LnJlc29sdXRpb25zW2ldO1xuXG4gICAgICB2YXIgd2lkdGggPSByZXNvbHV0aW9uLnRyeDEgLSByZXNvbHV0aW9uLnRyeDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gcmVzb2x1dGlvbi50cnkxIC0gcmVzb2x1dGlvbi50cnkwO1xuICAgICAgLy8gQWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aG9sZSBzdWJsZXZlbC5cbiAgICAgIHZhciBjb2VmZmljaWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0KTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcmVzb2x1dGlvbi5zdWJiYW5kcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIHZhciBtdSwgZXBzaWxvbjtcbiAgICAgICAgaWYgKCFzY2FsYXJFeHBvdW5kZWQpIHtcbiAgICAgICAgICAvLyBmb3JtdWxhIEUtNVxuICAgICAgICAgIG11ID0gc3BxY2RzWzBdLm11O1xuICAgICAgICAgIGVwc2lsb24gPSBzcHFjZHNbMF0uZXBzaWxvbiArIChpID4gMCA/IDEgLSBpIDogMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXUgPSBzcHFjZHNbYl0ubXU7XG4gICAgICAgICAgZXBzaWxvbiA9IHNwcWNkc1tiXS5lcHNpbG9uO1xuICAgICAgICAgIGIrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJiYW5kID0gcmVzb2x1dGlvbi5zdWJiYW5kc1tqXTtcbiAgICAgICAgdmFyIGdhaW5Mb2cyID0gU3ViYmFuZHNHYWluTG9nMltzdWJiYW5kLnR5cGVdO1xuXG4gICAgICAgIC8vIGNhbHVsYXRlIHF1YW50aXphdGlvbiBjb2VmZmljaWVudCAoU2VjdGlvbiBFLjEuMS4xKVxuICAgICAgICB2YXIgZGVsdGEgPSAocmV2ZXJzaWJsZSA/IDEgOlxuICAgICAgICAgIE1hdGgucG93KDIsIHByZWNpc2lvbiArIGdhaW5Mb2cyIC0gZXBzaWxvbikgKiAoMSArIG11IC8gMjA0OCkpO1xuICAgICAgICB2YXIgbWIgPSAoZ3VhcmRCaXRzICsgZXBzaWxvbiAtIDEpO1xuXG4gICAgICAgIC8vIEluIHRoZSBmaXJzdCByZXNvbHV0aW9uIGxldmVsLCBjb3B5Q29lZmZpY2llbnRzIHdpbGwgZmlsbCB0aGVcbiAgICAgICAgLy8gd2hvbGUgYXJyYXkgd2l0aCBjb2VmZmljaWVudHMuIEluIHRoZSBzdWNjZWRpbmcgcGFzc2VzLFxuICAgICAgICAvLyBjb3B5Q29lZmZpY2llbnRzIHdpbGwgY29uc2VjdXRpdmVseSBmaWxsIGluIHRoZSB2YWx1ZXMgdGhhdCBiZWxvbmdcbiAgICAgICAgLy8gdG8gdGhlIGludGVybGVhdmVkIHBvc2l0aW9ucyBvZiB0aGUgSEwsIExILCBhbmQgSEggY29lZmZpY2llbnRzLlxuICAgICAgICAvLyBUaGUgTEwgY29lZmZpY2llbnRzIHdpbGwgdGhlbiBiZSBpbnRlcmxlYXZlZCBpbiBUcmFuc2Zvcm0uaXRlcmF0ZSgpLlxuICAgICAgICBjb3B5Q29lZmZpY2llbnRzKGNvZWZmaWNpZW50cywgd2lkdGgsIGhlaWdodCwgc3ViYmFuZCwgZGVsdGEsIG1iLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2libGUsIHNlZ21lbnRhdGlvblN5bWJvbFVzZWQpO1xuICAgICAgfVxuICAgICAgc3ViYmFuZENvZWZmaWNpZW50cy5wdXNoKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgaXRlbXM6IGNvZWZmaWNpZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybS5jYWxjdWxhdGUoc3ViYmFuZENvZWZmaWNpZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQudGN4MCwgY29tcG9uZW50LnRjeTApO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBjb21wb25lbnQudGN4MCxcbiAgICAgIHRvcDogY29tcG9uZW50LnRjeTAsXG4gICAgICB3aWR0aDogcmVzdWx0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZXN1bHQuaGVpZ2h0LFxuICAgICAgaXRlbXM6IHJlc3VsdC5pdGVtc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNmb3JtQ29tcG9uZW50cyhjb250ZXh0KSB7XG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xuICAgIHZhciBjb21wb25lbnRzID0gY29udGV4dC5jb21wb25lbnRzO1xuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcbiAgICB2YXIgcmVzdWx0SW1hZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29udGV4dC50aWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbaV07XG4gICAgICB2YXIgdHJhbnNmb3JtZWRUaWxlcyA9IFtdO1xuICAgICAgdmFyIGM7XG4gICAgICBmb3IgKGMgPSAwOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcbiAgICAgICAgdHJhbnNmb3JtZWRUaWxlc1tjXSA9IHRyYW5zZm9ybVRpbGUoY29udGV4dCwgdGlsZSwgYyk7XG4gICAgICB9XG4gICAgICB2YXIgdGlsZTAgPSB0cmFuc2Zvcm1lZFRpbGVzWzBdO1xuICAgICAgdmFyIGlzU2lnbmVkID0gY29tcG9uZW50c1swXS5pc1NpZ25lZDtcbiAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IEludDE2QXJyYXkodGlsZTAuaXRlbXMubGVuZ3RoICogY29tcG9uZW50c0NvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDE2QXJyYXkodGlsZTAuaXRlbXMubGVuZ3RoICogY29tcG9uZW50c0NvdW50KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGxlZnQ6IHRpbGUwLmxlZnQsXG4gICAgICAgIHRvcDogdGlsZTAudG9wLFxuICAgICAgICB3aWR0aDogdGlsZTAud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGlsZTAuaGVpZ2h0LFxuICAgICAgICBpdGVtczogb3V0XG4gICAgICB9O1xuXG4gICAgICAvLyBTZWN0aW9uIEcuMi4yIEludmVyc2UgbXVsdGkgY29tcG9uZW50IHRyYW5zZm9ybVxuICAgICAgdmFyIHNoaWZ0LCBvZmZzZXQsIG1heCwgbWluLCBtYXhLO1xuICAgICAgdmFyIHBvcyA9IDAsIGosIGpqLCB5MCwgeTEsIHkyLCByLCBnLCBiLCBrLCB2YWw7XG4gICAgICBpZiAodGlsZS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLm11bHRpcGxlQ29tcG9uZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBmb3VyQ29tcG9uZW50cyA9IGNvbXBvbmVudHNDb3VudCA9PT0gNDtcbiAgICAgICAgdmFyIHkwaXRlbXMgPSB0cmFuc2Zvcm1lZFRpbGVzWzBdLml0ZW1zO1xuICAgICAgICB2YXIgeTFpdGVtcyA9IHRyYW5zZm9ybWVkVGlsZXNbMV0uaXRlbXM7XG4gICAgICAgIHZhciB5Mml0ZW1zID0gdHJhbnNmb3JtZWRUaWxlc1syXS5pdGVtcztcbiAgICAgICAgdmFyIHkzaXRlbXMgPSBmb3VyQ29tcG9uZW50cyA/IHRyYW5zZm9ybWVkVGlsZXNbM10uaXRlbXMgOiBudWxsO1xuXG4gICAgICAgIC8vIEhBQ0s6IFRoZSBtdWx0aXBsZSBjb21wb25lbnQgdHJhbnNmb3JtIGZvcm11bGFzIGJlbG93IGFzc3VtZSB0aGF0XG4gICAgICAgIC8vIGFsbCBjb21wb25lbnRzIGhhdmUgdGhlIHNhbWUgcHJlY2lzaW9uLiBXaXRoIHRoaXMgaW4gbWluZCwgd2VcbiAgICAgICAgLy8gY29tcHV0ZSBzaGlmdCBhbmQgb2Zmc2V0IG9ubHkgb25jZS5cbiAgICAgICAgc2hpZnQgPSBjb21wb25lbnRzWzBdLnByZWNpc2lvbiAtIDg7XG4gICAgICAgIG9mZnNldCA9ICgxMjggPDwgc2hpZnQpICsgMC41O1xuICAgICAgICBtYXggPSAyNTUgKiAoMSA8PCBzaGlmdCk7XG4gICAgICAgIG1heEsgPSBtYXggKiAwLjU7XG4gICAgICAgIG1pbiA9IC1tYXhLO1xuXG4gICAgICAgIHZhciBjb21wb25lbnQwID0gdGlsZS5jb21wb25lbnRzWzBdO1xuICAgICAgICB2YXIgYWxwaGEwMSA9IGNvbXBvbmVudHNDb3VudCAtIDM7XG4gICAgICAgIGpqID0geTBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmICghY29tcG9uZW50MC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMucmV2ZXJzaWJsZVRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgICAgLy8gaW52ZXJzZSBpcnJldmVyc2libGUgbXVsdGlwbGUgY29tcG9uZW50IHRyYW5zZm9ybVxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqajsgaisrLCBwb3MgKz0gYWxwaGEwMSkge1xuICAgICAgICAgICAgeTAgPSB5MGl0ZW1zW2pdICsgb2Zmc2V0O1xuICAgICAgICAgICAgeTEgPSB5MWl0ZW1zW2pdO1xuICAgICAgICAgICAgeTIgPSB5Mml0ZW1zW2pdO1xuICAgICAgICAgICAgciA9IHkwICsgMS40MDIgKiB5MjtcbiAgICAgICAgICAgIGcgPSB5MCAtIDAuMzQ0MTMgKiB5MSAtIDAuNzE0MTQgKiB5MjtcbiAgICAgICAgICAgIGIgPSB5MCArIDEuNzcyICogeTE7XG4gICAgICAgICAgICBvdXRbcG9zKytdID0gciA8PSAwID8gMCA6IHIgPj0gbWF4ID8gMjU1IDogciA+PiBzaGlmdDtcbiAgICAgICAgICAgIG91dFtwb3MrK10gPSBnIDw9IDAgPyAwIDogZyA+PSBtYXggPyAyNTUgOiBnID4+IHNoaWZ0O1xuICAgICAgICAgICAgb3V0W3BvcysrXSA9IGIgPD0gMCA/IDAgOiBiID49IG1heCA/IDI1NSA6IGIgPj4gc2hpZnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGludmVyc2UgcmV2ZXJzaWJsZSBtdWx0aXBsZSBjb21wb25lbnQgdHJhbnNmb3JtXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpqOyBqKyssIHBvcyArPSBhbHBoYTAxKSB7XG4gICAgICAgICAgICB5MCA9IHkwaXRlbXNbal0gKyBvZmZzZXQ7XG4gICAgICAgICAgICB5MSA9IHkxaXRlbXNbal07XG4gICAgICAgICAgICB5MiA9IHkyaXRlbXNbal07XG4gICAgICAgICAgICBnID0geTAgLSAoKHkyICsgeTEpID4+IDIpO1xuICAgICAgICAgICAgciA9IGcgKyB5MjtcbiAgICAgICAgICAgIGIgPSBnICsgeTE7XG4gICAgICAgICAgICBvdXRbcG9zKytdID0gciA8PSAwID8gMCA6IHIgPj0gbWF4ID8gMjU1IDogciA+PiBzaGlmdDtcbiAgICAgICAgICAgIG91dFtwb3MrK10gPSBnIDw9IDAgPyAwIDogZyA+PSBtYXggPyAyNTUgOiBnID4+IHNoaWZ0O1xuICAgICAgICAgICAgb3V0W3BvcysrXSA9IGIgPD0gMCA/IDAgOiBiID49IG1heCA/IDI1NSA6IGIgPj4gc2hpZnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VyQ29tcG9uZW50cykge1xuICAgICAgICAgIGZvciAoaiA9IDAsIHBvcyA9IDM7IGogPCBqajsgaisrLCBwb3MgKz0gNCkge1xuICAgICAgICAgICAgayA9IHkzaXRlbXNbal07XG4gICAgICAgICAgICBvdXRbcG9zXSA9IGsgPD0gbWluID8gMCA6IGsgPj0gbWF4SyA/IDI1NSA6IChrICsgb2Zmc2V0KSA+PiBzaGlmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIG5vIG11bHRpLWNvbXBvbmVudCB0cmFuc2Zvcm1cbiAgICAgICAgZm9yIChjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudHNbY10ucHJlY2lzaW9uID09PSA4KXtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRyYW5zZm9ybWVkVGlsZXNbY10uaXRlbXM7XG4gICAgICAgICAgICBzaGlmdCA9IGNvbXBvbmVudHNbY10ucHJlY2lzaW9uIC0gODtcbiAgICAgICAgICAgIG9mZnNldCA9ICgxMjggPDwgc2hpZnQpICsgMC41O1xuICAgICAgICAgICAgbWF4ID0gKDEyNy41ICogKDEgPDwgc2hpZnQpKTtcbiAgICAgICAgICAgIG1pbiA9IC1tYXg7XG4gICAgICAgICAgICBmb3IgKHBvcyA9IGMsIGogPSAwLCBqaiA9IGl0ZW1zLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFsID0gaXRlbXNbal07XG4gICAgICAgICAgICAgIG91dFtwb3NdID0gdmFsIDw9IG1pbiA/IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA+PSBtYXggPyAyNTUgOiAodmFsICsgb2Zmc2V0KSA+PiBzaGlmdDtcbiAgICAgICAgICAgICAgcG9zICs9IGNvbXBvbmVudHNDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZhciBpc1NpZ25lZCA9IGNvbXBvbmVudHNbY10uaXNTaWduZWQ7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0cmFuc2Zvcm1lZFRpbGVzW2NdLml0ZW1zO1xuXG4gICAgICAgICAgICBpZihpc1NpZ25lZCl7XG4gICAgICAgICAgICAgIGZvciAocG9zID0gYywgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIG91dFtwb3NdID0gaXRlbXNbal07XG4gICAgICAgICAgICAgICAgcG9zICs9IGNvbXBvbmVudHNDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHNoaWZ0ID0gY29tcG9uZW50c1tjXS5wcmVjaXNpb24gLSA4O1xuICAgICAgICAgICAgICBvZmZzZXQgPSAoMTI4IDw8IHNoaWZ0KSArIDAuNTtcbiAgICAgICAgICAgICAgdmFyIHByZWNpc2lvbk1heCA9IE1hdGgucG93KDIsY29tcG9uZW50c1tjXS5wcmVjaXNpb24pLTE7XG4gICAgICAgICAgICAgIGZvciAocG9zID0gYywgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIHZhbCA9IGl0ZW1zW2pdO1xuICAgICAgICAgICAgICAgIG91dFtwb3NdID0gTWF0aC5tYXgoTWF0aC5taW4oKHZhbCArIG9mZnNldCkscHJlY2lzaW9uTWF4KSwwKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gY29tcG9uZW50c0NvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHRJbWFnZXMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0SW1hZ2VzO1xuICB9XG4gIGZ1bmN0aW9uIGluaXRpYWxpemVUaWxlKGNvbnRleHQsIHRpbGVJbmRleCkge1xuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcbiAgICAgIHZhciBxY2RPclFjYyA9IChjb250ZXh0LmN1cnJlbnRUaWxlLlFDQ1tjXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5RQ0NbY10gOiBjb250ZXh0LmN1cnJlbnRUaWxlLlFDRCk7XG4gICAgICBjb21wb25lbnQucXVhbnRpemF0aW9uUGFyYW1ldGVycyA9IHFjZE9yUWNjO1xuICAgICAgdmFyIGNvZE9yQ29jID0gKGNvbnRleHQuY3VycmVudFRpbGUuQ09DW2NdICE9PSB1bmRlZmluZWQgID9cbiAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5DT0NbY10gOiBjb250ZXh0LmN1cnJlbnRUaWxlLkNPRCk7XG4gICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzID0gY29kT3JDb2M7XG4gICAgfVxuICAgIHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycyA9IGNvbnRleHQuY3VycmVudFRpbGUuQ09EO1xuICB9XG5cbiAgLy8gU2VjdGlvbiBCLjEwLjIgVGFnIHRyZWVzXG4gIHZhciBUYWdUcmVlID0gKGZ1bmN0aW9uIFRhZ1RyZWVDbG9zdXJlKCkge1xuICAgIGZ1bmN0aW9uIFRhZ1RyZWUod2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGxldmVsc0xlbmd0aCA9IGxvZzIoTWF0aC5tYXgod2lkdGgsIGhlaWdodCkpICsgMTtcbiAgICAgIHRoaXMubGV2ZWxzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHtcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAvIDIpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfVxuICAgIFRhZ1RyZWUucHJvdG90eXBlID0ge1xuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIFRhZ1RyZWVfcmVzZXQoaSwgaikge1xuICAgICAgICB2YXIgY3VycmVudExldmVsID0gMCwgdmFsdWUgPSAwLCBsZXZlbDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRMZXZlbCA8IHRoaXMubGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBpICsgaiAqIGxldmVsLndpZHRoO1xuICAgICAgICAgIGlmIChsZXZlbC5pdGVtc1tpbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBsZXZlbC5pdGVtc1tpbmRleF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV2ZWwuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBpID4+PSAxO1xuICAgICAgICAgIGogPj49IDE7XG4gICAgICAgICAgY3VycmVudExldmVsKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExldmVsLS07XG4gICAgICAgIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcbiAgICAgICAgbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICBkZWxldGUgdGhpcy52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBpbmNyZW1lbnRWYWx1ZTogZnVuY3Rpb24gVGFnVHJlZV9pbmNyZW1lbnRWYWx1ZSgpIHtcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxdO1xuICAgICAgICBsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0rKztcbiAgICAgIH0sXG4gICAgICBuZXh0TGV2ZWw6IGZ1bmN0aW9uIFRhZ1RyZWVfbmV4dExldmVsKCkge1xuICAgICAgICB2YXIgY3VycmVudExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW2N1cnJlbnRMZXZlbF07XG4gICAgICAgIHZhciB2YWx1ZSA9IGxldmVsLml0ZW1zW2xldmVsLmluZGV4XTtcbiAgICAgICAgY3VycmVudExldmVsLS07XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPCAwKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWxzW2N1cnJlbnRMZXZlbF07XG4gICAgICAgIGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYWdUcmVlO1xuICB9KSgpO1xuXG4gIHZhciBJbmNsdXNpb25UcmVlID0gKGZ1bmN0aW9uIEluY2x1c2lvblRyZWVDbG9zdXJlKCkge1xuICAgIGZ1bmN0aW9uIEluY2x1c2lvblRyZWUod2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGxldmVsc0xlbmd0aCA9IGxvZzIoTWF0aC5tYXgod2lkdGgsIGhlaWdodCkpICsgMTtcbiAgICAgIHRoaXMubGV2ZWxzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgdmFyIHN0YXR1cyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIGl0ZW1zW2pdID0gMDtcbiAgICAgICAgICBzdGF0dXNbal0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxldmVsID0ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBpdGVtczogaXRlbXMsXG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sZXZlbHMucHVzaChsZXZlbCk7XG5cbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGggLyAyKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBJbmNsdXNpb25UcmVlLnByb3RvdHlwZSA9IHtcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiBJbmNsdXNpb25UcmVlX3Jlc2V0KGksIGosIHN0b3BWYWx1ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdG9wVmFsdWUgPSBzdG9wVmFsdWU7XG4gICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSAwO1xuICAgICAgICB3aGlsZSAoY3VycmVudExldmVsIDwgdGhpcy5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBpICsgaiAqIGxldmVsLndpZHRoO1xuICAgICAgICAgIGxldmVsLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICBpID4+PSAxO1xuICAgICAgICAgIGogPj49IDE7XG4gICAgICAgICAgY3VycmVudExldmVsKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IHRoaXMubGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubWluVmFsdWUgPXRoaXMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsXS5pdGVtc1swXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSxcbiAgICAgIGluY3JlbWVudFZhbHVlOiBmdW5jdGlvbiBJbmNsdXNpb25UcmVlX2luY3JlbWVudFZhbHVlKCkge1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRMZXZlbF07XG4gICAgICAgIGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA9IGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSArIDE7XG4gICAgICAgIGlmKGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA+IHRoaXMubWluVmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm1pblZhbHVlID0gbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbmV4dExldmVsOiBmdW5jdGlvbiBJbmNsdXNpb25UcmVlX25leHRMZXZlbCgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgICAgICBjdXJyZW50TGV2ZWwtLTtcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcbiAgICAgICAgICBpZihsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPCB0aGlzLm1pblZhbHVlKSB7XG4gICAgICAgICAgICBsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPSB0aGlzLm1pblZhbHVlO1xuICAgICAgICAgIH1lbHNlIGlmIChsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPiB0aGlzLm1pblZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm1pblZhbHVlID0gbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICBpc0xlYWY6IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfaXNMZWFmKCl7XG4gICAgICByZXR1cm4gKHRoaXMuY3VycmVudExldmVsID09PSAwKTtcbiAgICB9LFxuICAgIGlzQWJvdmVUaHJlc2hvbGQ6IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfaXNBYm92ZVRocmVzaG9sZCgpe1xuICAgICAgdmFyIGxldmVsaW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW2xldmVsaW5kZXhdO1xuICAgICAgcmV0dXJuIChsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPiB0aGlzLmN1cnJlbnRTdG9wVmFsdWUpO1xuICAgIH0sXG4gICAgaXNLbm93bjogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9pc0tub3duKCl7XG4gICAgICB2YXIgbGV2ZWxpbmRleCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbbGV2ZWxpbmRleF07XG4gICAgICByZXR1cm4gKGxldmVsLnN0YXR1c1tsZXZlbC5pbmRleF0gPiAwKTtcbiAgICB9LFxuICAgIHNldEtub3duOiBmdW5jdGlvbiBJbmNsdXNpb25UcmVlX3NldEtub3duKCl7XG4gICAgICB2YXIgbGV2ZWxpbmRleCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbbGV2ZWxpbmRleF07XG4gICAgICBsZXZlbC5zdGF0dXNbbGV2ZWwuaW5kZXhdID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB9O1xuICAgIHJldHVybiBJbmNsdXNpb25UcmVlO1xuICB9KSgpO1xuXG4gIC8vIFNlY3Rpb24gRC4gQ29lZmZpY2llbnQgYml0IG1vZGVsaW5nXG4gIHZhciBCaXRNb2RlbCA9IChmdW5jdGlvbiBCaXRNb2RlbENsb3N1cmUoKSB7XG4gICAgdmFyIFVOSUZPUk1fQ09OVEVYVCA9IDE3O1xuICAgIHZhciBSVU5MRU5HVEhfQ09OVEVYVCA9IDE4O1xuICAgIC8vIFRhYmxlIEQtMVxuICAgIC8vIFRoZSBpbmRleCBpcyBiaW5hcnkgcHJlc2VudGF0aW9uOiAwZGRkdnZoaCwgZGRkIC0gc3VtIG9mIERpICgwLi40KSxcbiAgICAvLyB2diAtIHN1bSBvZiBWaSAoMC4uMiksIGFuZCBoaCAtIHN1bSBvZiBIaSAoMC4uMilcbiAgICB2YXIgTExBbmRMSENvbnRleHRzTGFiZWwgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAwLCA1LCA4LCAwLCAzLCA3LCA4LCAwLCA0LCA3LCA4LCAwLCAwLCAwLCAwLCAwLCAxLCA2LCA4LCAwLCAzLCA3LCA4LCAwLCA0LFxuICAgICAgNywgOCwgMCwgMCwgMCwgMCwgMCwgMiwgNiwgOCwgMCwgMywgNywgOCwgMCwgNCwgNywgOCwgMCwgMCwgMCwgMCwgMCwgMiwgNixcbiAgICAgIDgsIDAsIDMsIDcsIDgsIDAsIDQsIDcsIDgsIDAsIDAsIDAsIDAsIDAsIDIsIDYsIDgsIDAsIDMsIDcsIDgsIDAsIDQsIDcsIDhcbiAgICBdKTtcbiAgICB2YXIgSExDb250ZXh0TGFiZWwgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAwLCAzLCA0LCAwLCA1LCA3LCA3LCAwLCA4LCA4LCA4LCAwLCAwLCAwLCAwLCAwLCAxLCAzLCA0LCAwLCA2LCA3LCA3LCAwLCA4LFxuICAgICAgOCwgOCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgNCwgMCwgNiwgNywgNywgMCwgOCwgOCwgOCwgMCwgMCwgMCwgMCwgMCwgMiwgMyxcbiAgICAgIDQsIDAsIDYsIDcsIDcsIDAsIDgsIDgsIDgsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDQsIDAsIDYsIDcsIDcsIDAsIDgsIDgsIDhcbiAgICBdKTtcbiAgICB2YXIgSEhDb250ZXh0TGFiZWwgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAwLCAxLCAyLCAwLCAxLCAyLCAyLCAwLCAyLCAyLCAyLCAwLCAwLCAwLCAwLCAwLCAzLCA0LCA1LCAwLCA0LCA1LCA1LCAwLCA1LFxuICAgICAgNSwgNSwgMCwgMCwgMCwgMCwgMCwgNiwgNywgNywgMCwgNywgNywgNywgMCwgNywgNywgNywgMCwgMCwgMCwgMCwgMCwgOCwgOCxcbiAgICAgIDgsIDAsIDgsIDgsIDgsIDAsIDgsIDgsIDgsIDAsIDAsIDAsIDAsIDAsIDgsIDgsIDgsIDAsIDgsIDgsIDgsIDAsIDgsIDgsIDhcbiAgICBdKTtcblxuICAgIGZ1bmN0aW9uIEJpdE1vZGVsKHdpZHRoLCBoZWlnaHQsIHN1YmJhbmQsIHplcm9CaXRQbGFuZXMsIG1iKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5jb250ZXh0TGFiZWxUYWJsZSA9IChzdWJiYW5kID09PSAnSEgnID8gSEhDb250ZXh0TGFiZWwgOlxuICAgICAgICAoc3ViYmFuZCA9PT0gJ0hMJyA/IEhMQ29udGV4dExhYmVsIDogTExBbmRMSENvbnRleHRzTGFiZWwpKTtcblxuICAgICAgdmFyIGNvZWZmaWNpZW50Q291bnQgPSB3aWR0aCAqIGhlaWdodDtcblxuICAgICAgLy8gY29lZmZpY2llbnRzIG91dHNpZGUgdGhlIGVuY29kaW5nIHJlZ2lvbiB0cmVhdGVkIGFzIGluc2lnbmlmaWNhbnRcbiAgICAgIC8vIGFkZCBib3JkZXIgc3RhdGUgY2VsbHMgZm9yIHNpZ25pZmljYW5jZVN0YXRlXG4gICAgICB0aGlzLm5laWdoYm9yc1NpZ25pZmljYW5jZSA9IG5ldyBVaW50OEFycmF5KGNvZWZmaWNpZW50Q291bnQpO1xuICAgICAgdGhpcy5jb2VmZmljZW50c1NpZ24gPSBuZXcgVWludDhBcnJheShjb2VmZmljaWVudENvdW50KTtcbiAgICAgIHRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGUgPSBtYiA+IDE0ID8gbmV3IFVpbnQzMkFycmF5KGNvZWZmaWNpZW50Q291bnQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYiA+IDYgPyBuZXcgVWludDE2QXJyYXkoY29lZmZpY2llbnRDb3VudCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGNvZWZmaWNpZW50Q291bnQpO1xuICAgICAgdGhpcy5wcm9jZXNzaW5nRmxhZ3MgPSBuZXcgVWludDhBcnJheShjb2VmZmljaWVudENvdW50KTtcblxuICAgICAgdmFyIGJpdHNEZWNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoY29lZmZpY2llbnRDb3VudCk7XG4gICAgICBpZiAoemVyb0JpdFBsYW5lcyAhPT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZWZmaWNpZW50Q291bnQ7IGkrKykge1xuICAgICAgICAgIGJpdHNEZWNvZGVkW2ldID0gemVyb0JpdFBsYW5lcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5iaXRzRGVjb2RlZCA9IGJpdHNEZWNvZGVkO1xuXG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgQml0TW9kZWwucHJvdG90eXBlID0ge1xuICAgICAgc2V0RGVjb2RlcjogZnVuY3Rpb24gQml0TW9kZWxfc2V0RGVjb2RlcihkZWNvZGVyKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IGRlY29kZXI7XG4gICAgICB9LFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIEJpdE1vZGVsX3Jlc2V0KCkge1xuICAgICAgICAvLyBXZSBoYXZlIDE3IGNvbnRleHRzIHRoYXQgYXJlIGFjY2Vzc2VkIHZpYSBjb250ZXh0IGxhYmVscyxcbiAgICAgICAgLy8gcGx1cyB0aGUgdW5pZm9ybSBhbmQgcnVubGVuZ3RoIGNvbnRleHQuXG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBuZXcgSW50OEFycmF5KDE5KTtcblxuICAgICAgICAvLyBDb250ZXh0cyBhcmUgcGFja2VkIGludG8gMSBieXRlOlxuICAgICAgICAvLyBoaWdoZXN0IDcgYml0cyBjYXJyeSB0aGUgaW5kZXgsIGxvd2VzdCBiaXQgY2FycmllcyBtcHNcbiAgICAgICAgdGhpcy5jb250ZXh0c1swXSA9ICg0IDw8IDEpIHwgMDtcbiAgICAgICAgdGhpcy5jb250ZXh0c1tVTklGT1JNX0NPTlRFWFRdID0gKDQ2IDw8IDEpIHwgMDtcbiAgICAgICAgdGhpcy5jb250ZXh0c1tSVU5MRU5HVEhfQ09OVEVYVF0gPSAoMyA8PCAxKSB8IDA7XG4gICAgICB9LFxuICAgICAgc2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlOlxuICAgICAgICBmdW5jdGlvbiBCaXRNb2RlbF9zZXROZWlnaGJvcnNTaWduaWZpY2FuY2Uocm93LCBjb2x1bW4sIGluZGV4KSB7XG4gICAgICAgIHZhciBuZWlnaGJvcnNTaWduaWZpY2FuY2UgPSB0aGlzLm5laWdoYm9yc1NpZ25pZmljYW5jZTtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHZhciBsZWZ0ID0gKGNvbHVtbiA+IDApO1xuICAgICAgICB2YXIgcmlnaHQgPSAoY29sdW1uICsgMSA8IHdpZHRoKTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgaWYgKHJvdyA+IDApIHtcbiAgICAgICAgICBpID0gaW5kZXggLSB3aWR0aDtcbiAgICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2kgLSAxXSArPSAweDEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpICsgMV0gKz0gMHgxMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2ldICs9IDB4MDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93ICsgMSA8IGhlaWdodCkge1xuICAgICAgICAgIGkgPSBpbmRleCArIHdpZHRoO1xuICAgICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaSAtIDFdICs9IDB4MTA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2kgKyAxXSArPSAweDEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaV0gKz0gMHgwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4IC0gMV0gKz0gMHgwMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXggKyAxXSArPSAweDAxO1xuICAgICAgICB9XG4gICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF0gfD0gMHg4MDtcbiAgICAgIH0sXG4gICAgICBydW5TaWduaWZpY2FuY2VQcm9wb2dhdGlvblBhc3M6XG4gICAgICAgIGZ1bmN0aW9uIEJpdE1vZGVsX3J1blNpZ25pZmljYW5jZVByb3BvZ2F0aW9uUGFzcygpIHtcbiAgICAgICAgdmFyIGRlY29kZXIgPSB0aGlzLmRlY29kZXI7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgY29lZmZpY2VudHNNYWduaXR1ZGUgPSB0aGlzLmNvZWZmaWNlbnRzTWFnbml0dWRlO1xuICAgICAgICB2YXIgY29lZmZpY2VudHNTaWduID0gdGhpcy5jb2VmZmljZW50c1NpZ247XG4gICAgICAgIHZhciBuZWlnaGJvcnNTaWduaWZpY2FuY2UgPSB0aGlzLm5laWdoYm9yc1NpZ25pZmljYW5jZTtcbiAgICAgICAgdmFyIHByb2Nlc3NpbmdGbGFncyA9IHRoaXMucHJvY2Vzc2luZ0ZsYWdzO1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5jb250ZXh0TGFiZWxUYWJsZTtcbiAgICAgICAgdmFyIGJpdHNEZWNvZGVkID0gdGhpcy5iaXRzRGVjb2RlZDtcbiAgICAgICAgdmFyIHByb2Nlc3NlZEludmVyc2VNYXNrID0gfjE7XG4gICAgICAgIHZhciBwcm9jZXNzZWRNYXNrID0gMTtcbiAgICAgICAgdmFyIGZpcnN0TWFnbml0dWRlQml0TWFzayA9IDI7XG5cbiAgICAgICAgZm9yICh2YXIgaTAgPSAwOyBpMCA8IGhlaWdodDsgaTAgKz0gNCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaTAgKiB3aWR0aCArIGo7XG4gICAgICAgICAgICBmb3IgKHZhciBpMSA9IDA7IGkxIDwgNDsgaTErKywgaW5kZXggKz0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSBpMCArIGkxO1xuICAgICAgICAgICAgICBpZiAoaSA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBjbGVhciBwcm9jZXNzZWQgZmxhZyBmaXJzdFxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdICY9IHByb2Nlc3NlZEludmVyc2VNYXNrO1xuXG4gICAgICAgICAgICAgIGlmIChjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gfHxcbiAgICAgICAgICAgICAgICAgICFuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgY29udGV4dExhYmVsID0gbGFiZWxzW25laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF1dO1xuICAgICAgICAgICAgICB2YXIgZGVjaXNpb24gPSBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIGNvbnRleHRMYWJlbCk7XG4gICAgICAgICAgICAgIGlmIChkZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBzaWduID0gdGhpcy5kZWNvZGVTaWduQml0KGksIGosIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb2VmZmljZW50c1NpZ25baW5kZXhdID0gc2lnbjtcbiAgICAgICAgICAgICAgICBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlKGksIGosIGluZGV4KTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIHw9IGZpcnN0TWFnbml0dWRlQml0TWFzaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleF0rKztcbiAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSB8PSBwcm9jZXNzZWRNYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlY29kZVNpZ25CaXQ6IGZ1bmN0aW9uIEJpdE1vZGVsX2RlY29kZVNpZ25CaXQocm93LCBjb2x1bW4sIGluZGV4KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgY29lZmZpY2VudHNNYWduaXR1ZGUgPSB0aGlzLmNvZWZmaWNlbnRzTWFnbml0dWRlO1xuICAgICAgICB2YXIgY29lZmZpY2VudHNTaWduID0gdGhpcy5jb2VmZmljZW50c1NpZ247XG4gICAgICAgIHZhciBjb250cmlidXRpb24sIHNpZ24wLCBzaWduMSwgc2lnbmlmaWNhbmNlMTtcbiAgICAgICAgdmFyIGNvbnRleHRMYWJlbCwgZGVjb2RlZDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgaG9yaXpvbnRhbCBjb250cmlidXRpb25cbiAgICAgICAgc2lnbmlmaWNhbmNlMSA9IChjb2x1bW4gPiAwICYmIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4IC0gMV0gIT09IDApO1xuICAgICAgICBpZiAoY29sdW1uICsgMSA8IHdpZHRoICYmIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4ICsgMV0gIT09IDApIHtcbiAgICAgICAgICBzaWduMSA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCArIDFdO1xuICAgICAgICAgIGlmIChzaWduaWZpY2FuY2UxKSB7XG4gICAgICAgICAgICBzaWduMCA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCAtIDFdO1xuICAgICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24xIC0gc2lnbjA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDEgLSBzaWduMSAtIHNpZ24xO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaWduaWZpY2FuY2UxKSB7XG4gICAgICAgICAgc2lnbjAgPSBjb2VmZmljZW50c1NpZ25baW5kZXggLSAxXTtcbiAgICAgICAgICBjb250cmlidXRpb24gPSAxIC0gc2lnbjAgLSBzaWduMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cmlidXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob3Jpem9udGFsQ29udHJpYnV0aW9uID0gMyAqIGNvbnRyaWJ1dGlvbjtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdmVydGljYWwgY29udHJpYnV0aW9uIGFuZCBjb21iaW5lIHdpdGggdGhlIGhvcml6b250YWxcbiAgICAgICAgc2lnbmlmaWNhbmNlMSA9IChyb3cgPiAwICYmIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4IC0gd2lkdGhdICE9PSAwKTtcbiAgICAgICAgaWYgKHJvdyArIDEgPCBoZWlnaHQgJiYgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXggKyB3aWR0aF0gIT09IDApIHtcbiAgICAgICAgICBzaWduMSA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCArIHdpZHRoXTtcbiAgICAgICAgICBpZiAoc2lnbmlmaWNhbmNlMSkge1xuICAgICAgICAgICAgc2lnbjAgPSBjb2VmZmljZW50c1NpZ25baW5kZXggLSB3aWR0aF07XG4gICAgICAgICAgICBjb250cmlidXRpb24gPSAxIC0gc2lnbjEgLSBzaWduMCArIGhvcml6b250YWxDb250cmlidXRpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDEgLSBzaWduMSAtIHNpZ24xICsgaG9yaXpvbnRhbENvbnRyaWJ1dGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2lnbmlmaWNhbmNlMSkge1xuICAgICAgICAgIHNpZ24wID0gY29lZmZpY2VudHNTaWduW2luZGV4IC0gd2lkdGhdO1xuICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDEgLSBzaWduMCAtIHNpZ24wICsgaG9yaXpvbnRhbENvbnRyaWJ1dGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cmlidXRpb24gPSBob3Jpem9udGFsQ29udHJpYnV0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRyaWJ1dGlvbiA+PSAwKSB7XG4gICAgICAgICAgY29udGV4dExhYmVsID0gOSArIGNvbnRyaWJ1dGlvbjtcbiAgICAgICAgICBkZWNvZGVkID0gdGhpcy5kZWNvZGVyLnJlYWRCaXQodGhpcy5jb250ZXh0cywgY29udGV4dExhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0TGFiZWwgPSA5IC0gY29udHJpYnV0aW9uO1xuICAgICAgICAgIGRlY29kZWQgPSB0aGlzLmRlY29kZXIucmVhZEJpdCh0aGlzLmNvbnRleHRzLCBjb250ZXh0TGFiZWwpIF4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgIH0sXG4gICAgICBydW5NYWduaXR1ZGVSZWZpbmVtZW50UGFzczpcbiAgICAgICAgZnVuY3Rpb24gQml0TW9kZWxfcnVuTWFnbml0dWRlUmVmaW5lbWVudFBhc3MoKSB7XG4gICAgICAgIHZhciBkZWNvZGVyID0gdGhpcy5kZWNvZGVyO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIGNvZWZmaWNlbnRzTWFnbml0dWRlID0gdGhpcy5jb2VmZmljZW50c01hZ25pdHVkZTtcbiAgICAgICAgdmFyIG5laWdoYm9yc1NpZ25pZmljYW5jZSA9IHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlO1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgYml0c0RlY29kZWQgPSB0aGlzLmJpdHNEZWNvZGVkO1xuICAgICAgICB2YXIgcHJvY2Vzc2luZ0ZsYWdzID0gdGhpcy5wcm9jZXNzaW5nRmxhZ3M7XG4gICAgICAgIHZhciBwcm9jZXNzZWRNYXNrID0gMTtcbiAgICAgICAgdmFyIGZpcnN0TWFnbml0dWRlQml0TWFzayA9IDI7XG4gICAgICAgIHZhciBsZW5ndGggPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoNCA9IHdpZHRoICogNDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleDAgPSAwLCBpbmRleE5leHQ7IGluZGV4MCA8IGxlbmd0aDsgaW5kZXgwID0gaW5kZXhOZXh0KSB7XG4gICAgICAgICAgaW5kZXhOZXh0ID0gTWF0aC5taW4obGVuZ3RoLCBpbmRleDAgKyB3aWR0aDQpO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSBpbmRleDAgKyBqOyBpbmRleCA8IGluZGV4TmV4dDsgaW5kZXggKz0gd2lkdGgpIHtcblxuICAgICAgICAgICAgICAvLyBzaWduaWZpY2FudCBidXQgbm90IHRob3NlIHRoYXQgaGF2ZSBqdXN0IGJlY29tZVxuICAgICAgICAgICAgICBpZiAoIWNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSB8fFxuICAgICAgICAgICAgICAgIChwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdICYgcHJvY2Vzc2VkTWFzaykgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSAxNjtcbiAgICAgICAgICAgICAgaWYgKChwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdICYgZmlyc3RNYWduaXR1ZGVCaXRNYXNrKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gXj0gZmlyc3RNYWduaXR1ZGVCaXRNYXNrO1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0IHJlZmluZW1lbnRcbiAgICAgICAgICAgICAgIHZhciBzaWduaWZpY2FuY2UgPSBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdICYgMTI3O1xuICAgICAgICAgICAgICAgY29udGV4dExhYmVsID0gc2lnbmlmaWNhbmNlID09PSAwID8gMTUgOiAxNDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBiaXQgPSBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIGNvbnRleHRMYWJlbCk7XG4gICAgICAgICAgICAgIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSA9XG4gICAgICAgICAgICAgICAgKGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSA8PCAxKSB8IGJpdDtcbiAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXhdKys7XG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gfD0gcHJvY2Vzc2VkTWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBydW5DbGVhbnVwUGFzczogZnVuY3Rpb24gQml0TW9kZWxfcnVuQ2xlYW51cFBhc3MoKSB7XG4gICAgICAgIHZhciBkZWNvZGVyID0gdGhpcy5kZWNvZGVyO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIG5laWdoYm9yc1NpZ25pZmljYW5jZSA9IHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlO1xuICAgICAgICB2YXIgY29lZmZpY2VudHNNYWduaXR1ZGUgPSB0aGlzLmNvZWZmaWNlbnRzTWFnbml0dWRlO1xuICAgICAgICB2YXIgY29lZmZpY2VudHNTaWduID0gdGhpcy5jb2VmZmljZW50c1NpZ247XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmNvbnRleHRMYWJlbFRhYmxlO1xuICAgICAgICB2YXIgYml0c0RlY29kZWQgPSB0aGlzLmJpdHNEZWNvZGVkO1xuICAgICAgICB2YXIgcHJvY2Vzc2luZ0ZsYWdzID0gdGhpcy5wcm9jZXNzaW5nRmxhZ3M7XG4gICAgICAgIHZhciBwcm9jZXNzZWRNYXNrID0gMTtcbiAgICAgICAgdmFyIGZpcnN0TWFnbml0dWRlQml0TWFzayA9IDI7XG4gICAgICAgIHZhciBvbmVSb3dEb3duID0gd2lkdGg7XG4gICAgICAgIHZhciB0d29Sb3dzRG93biA9IHdpZHRoICogMjtcbiAgICAgICAgdmFyIHRocmVlUm93c0Rvd24gPSB3aWR0aCAqIDM7XG4gICAgICAgIHZhciBpTmV4dDtcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwOyBpMCA8IGhlaWdodDsgaTAgPSBpTmV4dCkge1xuICAgICAgICAgIGlOZXh0ID0gTWF0aC5taW4oaTAgKyA0LCBoZWlnaHQpO1xuICAgICAgICAgIHZhciBpbmRleEJhc2UgPSBpMCAqIHdpZHRoO1xuICAgICAgICAgIHZhciBjaGVja0FsbEVtcHR5ID0gaTAgKyAzIDwgaGVpZ2h0O1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGluZGV4MCA9IGluZGV4QmFzZSArIGo7XG4gICAgICAgICAgICAvLyB1c2luZyB0aGUgcHJvcGVydHk6IGxhYmVsc1tuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdXSA9PT0gMFxuICAgICAgICAgICAgLy8gd2hlbiBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdID09PSAwXG4gICAgICAgICAgICB2YXIgYWxsRW1wdHkgPSAoY2hlY2tBbGxFbXB0eSAmJlxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXgwXSA9PT0gMCAmJlxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXgwICsgb25lUm93RG93bl0gPT09IDAgJiZcbiAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4MCArIHR3b1Jvd3NEb3duXSA9PT0gMCAmJlxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXgwICsgdGhyZWVSb3dzRG93bl0gPT09IDAgJiZcbiAgICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4MF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4MCArIG9uZVJvd0Rvd25dID09PSAwICYmXG4gICAgICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleDAgKyB0d29Sb3dzRG93bl0gPT09IDAgJiZcbiAgICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4MCArIHRocmVlUm93c0Rvd25dID09PSAwKTtcbiAgICAgICAgICAgIHZhciBpMSA9IDAsIGluZGV4ID0gaW5kZXgwO1xuICAgICAgICAgICAgdmFyIGkgPSBpMCwgc2lnbjtcbiAgICAgICAgICAgIGlmIChhbGxFbXB0eSkge1xuICAgICAgICAgICAgICB2YXIgaGFzU2lnbmlmaWNhbnRDb2VmZmljZW50ID1cbiAgICAgICAgICAgICAgICBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFJVTkxFTkdUSF9DT05URVhUKTtcbiAgICAgICAgICAgICAgaWYgKCFoYXNTaWduaWZpY2FudENvZWZmaWNlbnQpIHtcbiAgICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleDBdKys7XG4gICAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXgwICsgb25lUm93RG93bl0rKztcbiAgICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleDAgKyB0d29Sb3dzRG93bl0rKztcbiAgICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleDAgKyB0aHJlZVJvd3NEb3duXSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBuZXh0IGNvbHVtblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkxID0gKGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgVU5JRk9STV9DT05URVhUKSA8PCAxKSB8XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgVU5JRk9STV9DT05URVhUKTtcbiAgICAgICAgICAgICAgaWYgKGkxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaSA9IGkwICsgaTE7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gaTEgKiB3aWR0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNpZ24gPSB0aGlzLmRlY29kZVNpZ25CaXQoaSwgaiwgaW5kZXgpO1xuICAgICAgICAgICAgICBjb2VmZmljZW50c1NpZ25baW5kZXhdID0gc2lnbjtcbiAgICAgICAgICAgICAgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdID0gMTtcbiAgICAgICAgICAgICAgdGhpcy5zZXROZWlnaGJvcnNTaWduaWZpY2FuY2UoaSwgaiwgaW5kZXgpO1xuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIHw9IGZpcnN0TWFnbml0dWRlQml0TWFzaztcblxuICAgICAgICAgICAgICBpbmRleCA9IGluZGV4MDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTIgPSBpMDsgaTIgPD0gaTsgaTIrKywgaW5kZXggKz0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleF0rKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGkxKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSBpMCArIGkxOyBpIDwgaU5leHQ7IGkrKywgaW5kZXggKz0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgaWYgKGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSB8fFxuICAgICAgICAgICAgICAgIChwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdICYgcHJvY2Vzc2VkTWFzaykgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSBsYWJlbHNbbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4XV07XG4gICAgICAgICAgICAgIHZhciBkZWNpc2lvbiA9IGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgY29udGV4dExhYmVsKTtcbiAgICAgICAgICAgICAgaWYgKGRlY2lzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IHRoaXMuZGVjb2RlU2lnbkJpdChpLCBqLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29lZmZpY2VudHNTaWduW2luZGV4XSA9IHNpZ247XG4gICAgICAgICAgICAgICAgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5laWdoYm9yc1NpZ25pZmljYW5jZShpLCBqLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSB8PSBmaXJzdE1hZ25pdHVkZUJpdE1hc2s7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXhdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hlY2tTZWdtZW50YXRpb25TeW1ib2w6IGZ1bmN0aW9uIEJpdE1vZGVsX2NoZWNrU2VnbWVudGF0aW9uU3ltYm9sKCkge1xuICAgICAgICB2YXIgZGVjb2RlciA9IHRoaXMuZGVjb2RlcjtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIHN5bWJvbCA9IChkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFVOSUZPUk1fQ09OVEVYVCkgPDwgMykgfFxuICAgICAgICAgICAgICAgICAgICAgKGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgVU5JRk9STV9DT05URVhUKSA8PCAyKSB8XG4gICAgICAgICAgICAgICAgICAgICAoZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBVTklGT1JNX0NPTlRFWFQpIDw8IDEpIHxcbiAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFVOSUZPUk1fQ09OVEVYVCk7XG4gICAgICAgIGlmIChzeW1ib2wgIT09IDB4QSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBJbnZhbGlkIHNlZ21lbnRhdGlvbiBzeW1ib2wnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQml0TW9kZWw7XG4gIH0pKCk7XG5cbiAgLy8gU2VjdGlvbiBGLCBEaXNjcmV0ZSB3YXZlbGV0IHRyYW5zZm9ybWF0aW9uXG4gIHZhciBUcmFuc2Zvcm0gPSAoZnVuY3Rpb24gVHJhbnNmb3JtQ2xvc3VyZSgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm0oKSB7fVxuXG4gICAgVHJhbnNmb3JtLnByb3RvdHlwZS5jYWxjdWxhdGUgPVxuICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtQ2FsY3VsYXRlKHN1YmJhbmRzLCB1MCwgdjApIHtcbiAgICAgIHZhciBsbCA9IHN1YmJhbmRzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDEsIGlpID0gc3ViYmFuZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBsbCA9IHRoaXMuaXRlcmF0ZShsbCwgc3ViYmFuZHNbaV0sIHUwLCB2MCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGw7XG4gICAgfTtcbiAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChidWZmZXIsIG9mZnNldCwgc2l6ZSkge1xuICAgICAgLy8gU2VjdGlvbiBGLjMuNyBleHRlbmRpbmcuLi4gdXNpbmcgbWF4IGV4dGVuc2lvbiBvZiA0XG4gICAgICB2YXIgaTEgPSBvZmZzZXQgLSAxLCBqMSA9IG9mZnNldCArIDE7XG4gICAgICB2YXIgaTIgPSBvZmZzZXQgKyBzaXplIC0gMiwgajIgPSBvZmZzZXQgKyBzaXplO1xuICAgICAgYnVmZmVyW2kxLS1dID0gYnVmZmVyW2oxKytdO1xuICAgICAgYnVmZmVyW2oyKytdID0gYnVmZmVyW2kyLS1dO1xuICAgICAgYnVmZmVyW2kxLS1dID0gYnVmZmVyW2oxKytdO1xuICAgICAgYnVmZmVyW2oyKytdID0gYnVmZmVyW2kyLS1dO1xuICAgICAgYnVmZmVyW2kxLS1dID0gYnVmZmVyW2oxKytdO1xuICAgICAgYnVmZmVyW2oyKytdID0gYnVmZmVyW2kyLS1dO1xuICAgICAgYnVmZmVyW2kxXSA9IGJ1ZmZlcltqMV07XG4gICAgICBidWZmZXJbajJdID0gYnVmZmVyW2kyXTtcbiAgICB9O1xuICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIFRyYW5zZm9ybV9pdGVyYXRlKGxsLCBobF9saF9oaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MCwgdjApIHtcbiAgICAgIHZhciBsbFdpZHRoID0gbGwud2lkdGgsIGxsSGVpZ2h0ID0gbGwuaGVpZ2h0LCBsbEl0ZW1zID0gbGwuaXRlbXM7XG4gICAgICB2YXIgd2lkdGggPSBobF9saF9oaC53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBobF9saF9oaC5oZWlnaHQ7XG4gICAgICB2YXIgaXRlbXMgPSBobF9saF9oaC5pdGVtcztcbiAgICAgIHZhciBpLCBqLCBrLCBsLCB1LCB2O1xuXG4gICAgICAvLyBJbnRlcmxlYXZlIExMIGFjY29yZGluZyB0byBTZWN0aW9uIEYuMy4zXG4gICAgICBmb3IgKGsgPSAwLCBpID0gMDsgaSA8IGxsSGVpZ2h0OyBpKyspIHtcbiAgICAgICAgbCA9IGkgKiAyICogd2lkdGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsbFdpZHRoOyBqKyssIGsrKywgbCArPSAyKSB7XG4gICAgICAgICAgaXRlbXNbbF0gPSBsbEl0ZW1zW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUaGUgTEwgYmFuZCBpcyBub3QgbmVlZGVkIGFueW1vcmUuXG4gICAgICBsbEl0ZW1zID0gbGwuaXRlbXMgPSBudWxsO1xuXG4gICAgICB2YXIgYnVmZmVyUGFkZGluZyA9IDQ7XG4gICAgICB2YXIgcm93QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCArIDIgKiBidWZmZXJQYWRkaW5nKTtcblxuICAgICAgLy8gU2VjdGlvbiBGLjMuNCBIT1JfU1JcbiAgICAgIGlmICh3aWR0aCA9PT0gMSkge1xuICAgICAgICAvLyBpZiB3aWR0aCA9IDEsIHdoZW4gdTAgZXZlbiBrZWVwIGl0ZW1zIGFzIGlzLCB3aGVuIG9kZCBkaXZpZGUgYnkgMlxuICAgICAgICBpZiAoKHUwICYgMSkgIT09IDApIHtcbiAgICAgICAgICBmb3IgKHYgPSAwLCBrID0gMDsgdiA8IGhlaWdodDsgdisrLCBrICs9IHdpZHRoKSB7XG4gICAgICAgICAgICBpdGVtc1trXSAqPSAwLjU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHYgPSAwLCBrID0gMDsgdiA8IGhlaWdodDsgdisrLCBrICs9IHdpZHRoKSB7XG4gICAgICAgICAgcm93QnVmZmVyLnNldChpdGVtcy5zdWJhcnJheShrLCBrICsgd2lkdGgpLCBidWZmZXJQYWRkaW5nKTtcblxuICAgICAgICAgIHRoaXMuZXh0ZW5kKHJvd0J1ZmZlciwgYnVmZmVyUGFkZGluZywgd2lkdGgpO1xuICAgICAgICAgIHRoaXMuZmlsdGVyKHJvd0J1ZmZlciwgYnVmZmVyUGFkZGluZywgd2lkdGgpO1xuXG4gICAgICAgICAgaXRlbXMuc2V0KFxuICAgICAgICAgICAgcm93QnVmZmVyLnN1YmFycmF5KGJ1ZmZlclBhZGRpbmcsIGJ1ZmZlclBhZGRpbmcgKyB3aWR0aCksXG4gICAgICAgICAgICBrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBY2Nlc3NlcyB0byB0aGUgaXRlbXMgYXJyYXkgY2FuIHRha2UgbG9uZywgYmVjYXVzZSBpdCBtYXkgbm90IGZpdCBpbnRvXG4gICAgICAvLyBDUFUgY2FjaGUgYW5kIGhhcyB0byBiZSBmZXRjaGVkIGZyb20gbWFpbiBtZW1vcnkuIFNpbmNlIHN1YnNlcXVlbnRcbiAgICAgIC8vIGFjY2Vzc2VzIHRvIHRoZSBpdGVtcyBhcnJheSBhcmUgbm90IGxvY2FsIHdoZW4gcmVhZGluZyBjb2x1bW5zLCB3ZVxuICAgICAgLy8gaGF2ZSBhIGNhY2hlIG1pc3MgZXZlcnkgdGltZS4gVG8gcmVkdWNlIGNhY2hlIG1pc3NlcywgZ2V0IHVwIHRvXG4gICAgICAvLyAnbnVtQnVmZmVycycgaXRlbXMgYXQgYSB0aW1lIGFuZCBzdG9yZSB0aGVtIGludG8gdGhlIGluZGl2aWR1YWxcbiAgICAgIC8vIGJ1ZmZlcnMuIFRoZSBjb2xCdWZmZXJzIHNob3VsZCBiZSBzbWFsbCBlbm91Z2ggdG8gZml0IGludG8gQ1BVIGNhY2hlLlxuICAgICAgdmFyIG51bUJ1ZmZlcnMgPSAxNjtcbiAgICAgIHZhciBjb2xCdWZmZXJzID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQnVmZmVyczsgaSsrKSB7XG4gICAgICAgIGNvbEJ1ZmZlcnMucHVzaChuZXcgRmxvYXQzMkFycmF5KGhlaWdodCArIDIgKiBidWZmZXJQYWRkaW5nKSk7XG4gICAgICB9XG4gICAgICB2YXIgYiwgY3VycmVudEJ1ZmZlciA9IDA7XG4gICAgICBsbCA9IGJ1ZmZlclBhZGRpbmcgKyBoZWlnaHQ7XG5cbiAgICAgIC8vIFNlY3Rpb24gRi4zLjUgVkVSX1NSXG4gICAgICBpZiAoaGVpZ2h0ID09PSAxKSB7XG4gICAgICAgICAgLy8gaWYgaGVpZ2h0ID0gMSwgd2hlbiB2MCBldmVuIGtlZXAgaXRlbXMgYXMgaXMsIHdoZW4gb2RkIGRpdmlkZSBieSAyXG4gICAgICAgIGlmICgodjAgJiAxKSAhPT0gMCkge1xuICAgICAgICAgIGZvciAodSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBpdGVtc1t1XSAqPSAwLjU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xuICAgICAgICAgIC8vIGlmIHdlIHJhbiBvdXQgb2YgYnVmZmVycywgY29weSBzZXZlcmFsIGltYWdlIGNvbHVtbnMgYXQgb25jZVxuICAgICAgICAgIGlmIChjdXJyZW50QnVmZmVyID09PSAwKSB7XG4gICAgICAgICAgICBudW1CdWZmZXJzID0gTWF0aC5taW4od2lkdGggLSB1LCBudW1CdWZmZXJzKTtcbiAgICAgICAgICAgIGZvciAoayA9IHUsIGwgPSBidWZmZXJQYWRkaW5nOyBsIDwgbGw7IGsgKz0gd2lkdGgsIGwrKykge1xuICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgbnVtQnVmZmVyczsgYisrKSB7XG4gICAgICAgICAgICAgICAgY29sQnVmZmVyc1tiXVtsXSA9IGl0ZW1zW2sgKyBiXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ1ZmZlciA9IG51bUJ1ZmZlcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudEJ1ZmZlci0tO1xuICAgICAgICAgIHZhciBidWZmZXIgPSBjb2xCdWZmZXJzW2N1cnJlbnRCdWZmZXJdO1xuICAgICAgICAgIHRoaXMuZXh0ZW5kKGJ1ZmZlciwgYnVmZmVyUGFkZGluZywgaGVpZ2h0KTtcbiAgICAgICAgICB0aGlzLmZpbHRlcihidWZmZXIsIGJ1ZmZlclBhZGRpbmcsIGhlaWdodCk7XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIGxhc3QgYnVmZmVyIGluIHRoaXMgZ3JvdXAgb2YgYnVmZmVycywgZmx1c2ggYWxsIGJ1ZmZlcnMuXG4gICAgICAgICAgaWYgKGN1cnJlbnRCdWZmZXIgPT09IDApIHtcbiAgICAgICAgICAgIGsgPSB1IC0gbnVtQnVmZmVycyArIDE7XG4gICAgICAgICAgICBmb3IgKGwgPSBidWZmZXJQYWRkaW5nOyBsIDwgbGw7IGsgKz0gd2lkdGgsIGwrKykge1xuICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgbnVtQnVmZmVyczsgYisrKSB7XG4gICAgICAgICAgICAgICAgaXRlbXNbayArIGJdID0gY29sQnVmZmVyc1tiXVtsXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBpdGVtczogaXRlbXNcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNmb3JtO1xuICB9KSgpO1xuXG4gIC8vIFNlY3Rpb24gMy44LjIgSXJyZXZlcnNpYmxlIDktNyBmaWx0ZXJcbiAgdmFyIElycmV2ZXJzaWJsZVRyYW5zZm9ybSA9IChmdW5jdGlvbiBJcnJldmVyc2libGVUcmFuc2Zvcm1DbG9zdXJlKCkge1xuICAgIGZ1bmN0aW9uIElycmV2ZXJzaWJsZVRyYW5zZm9ybSgpIHtcbiAgICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElycmV2ZXJzaWJsZVRyYW5zZm9ybS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpO1xuICAgIElycmV2ZXJzaWJsZVRyYW5zZm9ybS5wcm90b3R5cGUuZmlsdGVyID1cbiAgICAgIGZ1bmN0aW9uIGlycmV2ZXJzaWJsZVRyYW5zZm9ybUZpbHRlcih4LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgdmFyIGxlbiA9IGxlbmd0aCA+PiAxO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICAgIHZhciBqLCBuLCBjdXJyZW50LCBuZXh0O1xuXG4gICAgICB2YXIgYWxwaGEgPSAtMS41ODYxMzQzNDIwNTk5MjQ7XG4gICAgICB2YXIgYmV0YSA9IC0wLjA1Mjk4MDExODU3Mjk2MTtcbiAgICAgIHZhciBnYW1tYSA9IDAuODgyOTExMDc1NTMwOTM0O1xuICAgICAgdmFyIGRlbHRhID0gMC40NDM1MDY4NTIwNDM5NzE7XG4gICAgICB2YXIgSyA9IDEuMjMwMTc0MTA0OTE0MDAxO1xuICAgICAgdmFyIEtfID0gMSAvIEs7XG5cbiAgICAgIC8vIHN0ZXAgMSBpcyBjb21iaW5lZCB3aXRoIHN0ZXAgM1xuXG4gICAgICAvLyBzdGVwIDJcbiAgICAgIGogPSBvZmZzZXQgLSAzO1xuICAgICAgZm9yIChuID0gbGVuICsgNDsgbi0tOyBqICs9IDIpIHtcbiAgICAgICAgeFtqXSAqPSBLXztcbiAgICAgIH1cblxuICAgICAgLy8gc3RlcCAxICYgM1xuICAgICAgaiA9IG9mZnNldCAtIDI7XG4gICAgICBjdXJyZW50ID0gZGVsdGEgKiB4W2ogLTFdO1xuICAgICAgZm9yIChuID0gbGVuICsgMzsgbi0tOyBqICs9IDIpIHtcbiAgICAgICAgbmV4dCA9IGRlbHRhICogeFtqICsgMV07XG4gICAgICAgIHhbal0gPSBLICogeFtqXSAtIGN1cnJlbnQgLSBuZXh0O1xuICAgICAgICBpZiAobi0tKSB7XG4gICAgICAgICAgaiArPSAyO1xuICAgICAgICAgIGN1cnJlbnQgPSBkZWx0YSAqIHhbaiArIDFdO1xuICAgICAgICAgIHhbal0gPSBLICogeFtqXSAtIGN1cnJlbnQgLSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHN0ZXAgNFxuICAgICAgaiA9IG9mZnNldCAtIDE7XG4gICAgICBjdXJyZW50ID0gZ2FtbWEgKiB4W2ogLSAxXTtcbiAgICAgIGZvciAobiA9IGxlbiArIDI7IG4tLTsgaiArPSAyKSB7XG4gICAgICAgIG5leHQgPSBnYW1tYSAqIHhbaiArIDFdO1xuICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xuICAgICAgICBpZiAobi0tKSB7XG4gICAgICAgICAgaiArPSAyO1xuICAgICAgICAgIGN1cnJlbnQgPSBnYW1tYSAqIHhbaiArIDFdO1xuICAgICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc3RlcCA1XG4gICAgICBqID0gb2Zmc2V0O1xuICAgICAgY3VycmVudCA9IGJldGEgKiB4W2ogLSAxXTtcbiAgICAgIGZvciAobiA9IGxlbiArIDE7IG4tLTsgaiArPSAyKSB7XG4gICAgICAgIG5leHQgPSBiZXRhICogeFtqICsgMV07XG4gICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XG4gICAgICAgIGlmIChuLS0pIHtcbiAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgY3VycmVudCA9IGJldGEgKiB4W2ogKyAxXTtcbiAgICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHN0ZXAgNlxuICAgICAgaWYgKGxlbiAhPT0gMCkge1xuICAgICAgICBqID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgY3VycmVudCA9IGFscGhhICogeFtqIC0gMV07XG4gICAgICAgIGZvciAobiA9IGxlbjsgbi0tOyBqICs9IDIpIHtcbiAgICAgICAgICBuZXh0ID0gYWxwaGEgKiB4W2ogKyAxXTtcbiAgICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xuICAgICAgICAgIGlmIChuLS0pIHtcbiAgICAgICAgICAgIGogKz0gMjtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBhbHBoYSAqIHhbaiArIDFdO1xuICAgICAgICAgICAgeFtqXSAtPSBjdXJyZW50ICsgbmV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBJcnJldmVyc2libGVUcmFuc2Zvcm07XG4gIH0pKCk7XG5cbiAgLy8gU2VjdGlvbiAzLjguMSBSZXZlcnNpYmxlIDUtMyBmaWx0ZXJcbiAgdmFyIFJldmVyc2libGVUcmFuc2Zvcm0gPSAoZnVuY3Rpb24gUmV2ZXJzaWJsZVRyYW5zZm9ybUNsb3N1cmUoKSB7XG4gICAgZnVuY3Rpb24gUmV2ZXJzaWJsZVRyYW5zZm9ybSgpIHtcbiAgICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFJldmVyc2libGVUcmFuc2Zvcm0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKTtcbiAgICBSZXZlcnNpYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5maWx0ZXIgPVxuICAgICAgZnVuY3Rpb24gcmV2ZXJzaWJsZVRyYW5zZm9ybUZpbHRlcih4LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgdmFyIGxlbiA9IGxlbmd0aCA+PiAxO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICAgIHZhciBqLCBuO1xuXG4gICAgICBmb3IgKGogPSBvZmZzZXQsIG4gPSBsZW4gKyAxOyBuLS07IGogKz0gMikge1xuICAgICAgICB4W2pdIC09ICh4W2ogLSAxXSArIHhbaiArIDFdICsgMikgPj4gMjtcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gb2Zmc2V0ICsgMSwgbiA9IGxlbjsgbi0tOyBqICs9IDIpIHtcbiAgICAgICAgeFtqXSArPSAoeFtqIC0gMV0gKyB4W2ogKyAxXSkgPj4gMTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJldmVyc2libGVUcmFuc2Zvcm07XG4gIH0pKCk7XG5cbiAgcmV0dXJuIEpweEltYWdlO1xufSkoKTtcblxuXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xuLyogQ29weXJpZ2h0IDIwMTIgTW96aWxsYSBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBRTSBDb2RlciBkZWNvZGluZyBhcyBkZWZpbmVkIGluXG4gKiAgIEpQRUcgMjAwMCBQYXJ0IEkgRmluYWwgQ29tbWl0dGVlIERyYWZ0IFZlcnNpb24gMS4wXG4gKiAgIEFubmV4IEMuMyBBcml0aG1ldGljIGRlY29kaW5nIHByb2NlZHVyZSBcbiAqIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmpwZWcub3JnL3B1YmxpYy9mY2QxNTQ0NC0xLnBkZlxuICogXG4gKiBUaGUgYXJpdGhtZXRpYyBkZWNvZGVyIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBjb250ZXh0IG1vZGVscyB0byBkZWNvZGVcbiAqIEpQRUcyMDAwIGFuZCBKQklHMiBzdHJlYW1zLlxuICovXG52YXIgQXJpdGhtZXRpY0RlY29kZXIgPSAoZnVuY3Rpb24gQXJpdGhtZXRpY0RlY29kZXJDbG9zdXJlKCkge1xuICAvLyBUYWJsZSBDLTJcbiAgdmFyIFFlVGFibGUgPSBbXG4gICAge3FlOiAweDU2MDEsIG5tcHM6IDEsIG5scHM6IDEsIHN3aXRjaEZsYWc6IDF9LFxuICAgIHtxZTogMHgzNDAxLCBubXBzOiAyLCBubHBzOiA2LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MTgwMSwgbm1wczogMywgbmxwczogOSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDBBQzEsIG5tcHM6IDQsIG5scHM6IDEyLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDUyMSwgbm1wczogNSwgbmxwczogMjksIHN3aXRjaEZsYWc6IDB9LFxuICAgIHtxZTogMHgwMjIxLCBubXBzOiAzOCwgbmxwczogMzMsIHN3aXRjaEZsYWc6IDB9LFxuICAgIHtxZTogMHg1NjAxLCBubXBzOiA3LCBubHBzOiA2LCBzd2l0Y2hGbGFnOiAxfSxcbiAgICB7cWU6IDB4NTQwMSwgbm1wczogOCwgbmxwczogMTQsIHN3aXRjaEZsYWc6IDB9LFxuICAgIHtxZTogMHg0ODAxLCBubXBzOiA5LCBubHBzOiAxNCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDM4MDEsIG5tcHM6IDEwLCBubHBzOiAxNCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDMwMDEsIG5tcHM6IDExLCBubHBzOiAxNywgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDI0MDEsIG5tcHM6IDEyLCBubHBzOiAxOCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDFDMDEsIG5tcHM6IDEzLCBubHBzOiAyMCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDE2MDEsIG5tcHM6IDI5LCBubHBzOiAyMSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDU2MDEsIG5tcHM6IDE1LCBubHBzOiAxNCwgc3dpdGNoRmxhZzogMX0sXG4gICAge3FlOiAweDU0MDEsIG5tcHM6IDE2LCBubHBzOiAxNCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDUxMDEsIG5tcHM6IDE3LCBubHBzOiAxNSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDQ4MDEsIG5tcHM6IDE4LCBubHBzOiAxNiwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDM4MDEsIG5tcHM6IDE5LCBubHBzOiAxNywgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDM0MDEsIG5tcHM6IDIwLCBubHBzOiAxOCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDMwMDEsIG5tcHM6IDIxLCBubHBzOiAxOSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDI4MDEsIG5tcHM6IDIyLCBubHBzOiAxOSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDI0MDEsIG5tcHM6IDIzLCBubHBzOiAyMCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDIyMDEsIG5tcHM6IDI0LCBubHBzOiAyMSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDFDMDEsIG5tcHM6IDI1LCBubHBzOiAyMiwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDE4MDEsIG5tcHM6IDI2LCBubHBzOiAyMywgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDE2MDEsIG5tcHM6IDI3LCBubHBzOiAyNCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDE0MDEsIG5tcHM6IDI4LCBubHBzOiAyNSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDEyMDEsIG5tcHM6IDI5LCBubHBzOiAyNiwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDExMDEsIG5tcHM6IDMwLCBubHBzOiAyNywgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDBBQzEsIG5tcHM6IDMxLCBubHBzOiAyOCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDA5QzEsIG5tcHM6IDMyLCBubHBzOiAyOSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDA4QTEsIG5tcHM6IDMzLCBubHBzOiAzMCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDA1MjEsIG5tcHM6IDM0LCBubHBzOiAzMSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDA0NDEsIG5tcHM6IDM1LCBubHBzOiAzMiwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAyQTEsIG5tcHM6IDM2LCBubHBzOiAzMywgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAyMjEsIG5tcHM6IDM3LCBubHBzOiAzNCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAxNDEsIG5tcHM6IDM4LCBubHBzOiAzNSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAxMTEsIG5tcHM6IDM5LCBubHBzOiAzNiwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAwODUsIG5tcHM6IDQwLCBubHBzOiAzNywgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAwNDksIG5tcHM6IDQxLCBubHBzOiAzOCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAwMjUsIG5tcHM6IDQyLCBubHBzOiAzOSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAwMTUsIG5tcHM6IDQzLCBubHBzOiA0MCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAwMDksIG5tcHM6IDQ0LCBubHBzOiA0MSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAwMDUsIG5tcHM6IDQ1LCBubHBzOiA0Miwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAwMDEsIG5tcHM6IDQ1LCBubHBzOiA0Mywgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDU2MDEsIG5tcHM6IDQ2LCBubHBzOiA0Niwgc3dpdGNoRmxhZzogMH1cbiAgXTtcblxuICAvLyBDLjMuNSBJbml0aWFsaXNhdGlvbiBvZiB0aGUgZGVjb2RlciAoSU5JVERFQylcbiAgZnVuY3Rpb24gQXJpdGhtZXRpY0RlY29kZXIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5icCA9IHN0YXJ0O1xuICAgIHRoaXMuZGF0YUVuZCA9IGVuZDtcblxuICAgIHRoaXMuY2hpZ2ggPSBkYXRhW3N0YXJ0XTtcbiAgICB0aGlzLmNsb3cgPSAwO1xuXG4gICAgdGhpcy5ieXRlSW4oKTtcblxuICAgIHRoaXMuY2hpZ2ggPSAoKHRoaXMuY2hpZ2ggPDwgNykgJiAweEZGRkYpIHwgKCh0aGlzLmNsb3cgPj4gOSkgJiAweDdGKTtcbiAgICB0aGlzLmNsb3cgPSAodGhpcy5jbG93IDw8IDcpICYgMHhGRkZGO1xuICAgIHRoaXMuY3QgLT0gNztcbiAgICB0aGlzLmEgPSAweDgwMDA7XG4gIH1cblxuICBBcml0aG1ldGljRGVjb2Rlci5wcm90b3R5cGUgPSB7XG4gICAgLy8gQy4zLjQgQ29tcHJlc3NlZCBkYXRhIGlucHV0IChCWVRFSU4pXG4gICAgYnl0ZUluOiBmdW5jdGlvbiBBcml0aG1ldGljRGVjb2Rlcl9ieXRlSW4oKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciBicCA9IHRoaXMuYnA7XG4gICAgICBpZiAoZGF0YVticF0gPT09IDB4RkYpIHtcbiAgICAgICAgdmFyIGIxID0gZGF0YVticCArIDFdO1xuICAgICAgICBpZiAoYjEgPiAweDhGKSB7XG4gICAgICAgICAgdGhpcy5jbG93ICs9IDB4RkYwMDtcbiAgICAgICAgICB0aGlzLmN0ID0gODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicCsrO1xuICAgICAgICAgIHRoaXMuY2xvdyArPSAoZGF0YVticF0gPDwgOSk7XG4gICAgICAgICAgdGhpcy5jdCA9IDc7XG4gICAgICAgICAgdGhpcy5icCA9IGJwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicCsrO1xuICAgICAgICB0aGlzLmNsb3cgKz0gYnAgPCB0aGlzLmRhdGFFbmQgPyAoZGF0YVticF0gPDwgOCkgOiAweEZGMDA7XG4gICAgICAgIHRoaXMuY3QgPSA4O1xuICAgICAgICB0aGlzLmJwID0gYnA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jbG93ID4gMHhGRkZGKSB7XG4gICAgICAgIHRoaXMuY2hpZ2ggKz0gKHRoaXMuY2xvdyA+PiAxNik7XG4gICAgICAgIHRoaXMuY2xvdyAmPSAweEZGRkY7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBDLjMuMiBEZWNvZGluZyBhIGRlY2lzaW9uIChERUNPREUpXG4gICAgcmVhZEJpdDogZnVuY3Rpb24gQXJpdGhtZXRpY0RlY29kZXJfcmVhZEJpdChjb250ZXh0cywgcG9zKSB7XG4gICAgICAvLyBjb250ZXh0cyBhcmUgcGFja2VkIGludG8gMSBieXRlOlxuICAgICAgLy8gaGlnaGVzdCA3IGJpdHMgY2FycnkgY3guaW5kZXgsIGxvd2VzdCBiaXQgY2FycmllcyBjeC5tcHNcbiAgICAgIHZhciBjeF9pbmRleCA9IGNvbnRleHRzW3Bvc10gPj4gMSwgY3hfbXBzID0gY29udGV4dHNbcG9zXSAmIDE7XG4gICAgICB2YXIgcWVUYWJsZUljeCA9IFFlVGFibGVbY3hfaW5kZXhdO1xuICAgICAgdmFyIHFlSWN4ID0gcWVUYWJsZUljeC5xZTtcbiAgICAgIHZhciBkO1xuICAgICAgdmFyIGEgPSB0aGlzLmEgLSBxZUljeDtcblxuICAgICAgaWYgKHRoaXMuY2hpZ2ggPCBxZUljeCkge1xuICAgICAgICAvLyBleGNoYW5nZUxwc1xuICAgICAgICBpZiAoYSA8IHFlSWN4KSB7XG4gICAgICAgICAgYSA9IHFlSWN4O1xuICAgICAgICAgIGQgPSBjeF9tcHM7XG4gICAgICAgICAgY3hfaW5kZXggPSBxZVRhYmxlSWN4Lm5tcHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYSA9IHFlSWN4O1xuICAgICAgICAgIGQgPSAxIF4gY3hfbXBzO1xuICAgICAgICAgIGlmIChxZVRhYmxlSWN4LnN3aXRjaEZsYWcgPT09IDEpIHtcbiAgICAgICAgICAgIGN4X21wcyA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN4X2luZGV4ID0gcWVUYWJsZUljeC5ubHBzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoaWdoIC09IHFlSWN4O1xuICAgICAgICBpZiAoKGEgJiAweDgwMDApICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5hID0gYTtcbiAgICAgICAgICByZXR1cm4gY3hfbXBzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4Y2hhbmdlTXBzXG4gICAgICAgIGlmIChhIDwgcWVJY3gpIHtcbiAgICAgICAgICBkID0gMSBeIGN4X21wcztcbiAgICAgICAgICBpZiAocWVUYWJsZUljeC5zd2l0Y2hGbGFnID09PSAxKSB7XG4gICAgICAgICAgICBjeF9tcHMgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjeF9pbmRleCA9IHFlVGFibGVJY3gubmxwcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkID0gY3hfbXBzO1xuICAgICAgICAgIGN4X2luZGV4ID0gcWVUYWJsZUljeC5ubXBzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDLjMuMyByZW5vcm1EO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAodGhpcy5jdCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuYnl0ZUluKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhIDw8PSAxO1xuICAgICAgICB0aGlzLmNoaWdoID0gKCh0aGlzLmNoaWdoIDw8IDEpICYgMHhGRkZGKSB8ICgodGhpcy5jbG93ID4+IDE1KSAmIDEpO1xuICAgICAgICB0aGlzLmNsb3cgPSAodGhpcy5jbG93IDw8IDEpICYgMHhGRkZGO1xuICAgICAgICB0aGlzLmN0LS07XG4gICAgICB9IHdoaWxlICgoYSAmIDB4ODAwMCkgPT09IDApO1xuICAgICAgdGhpcy5hID0gYTtcblxuICAgICAgY29udGV4dHNbcG9zXSA9IGN4X2luZGV4IDw8IDEgfCBjeF9tcHM7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFyaXRobWV0aWNEZWNvZGVyO1xufSkoKTtcblxuLyogLSotIE1vZGU6IEphdmE7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gKi9cbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cbi8qIENvcHlyaWdodCAyMDEyIE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZ2xvYmFscyBDbWQsIENvbG9yU3BhY2UsIERpY3QsIE1vekJsb2JCdWlsZGVyLCBOYW1lLCBQREZKUywgUmVmLCBVUkwsXG4gICAgICAgICAgIFByb21pc2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsU2NvcGUgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcyA6IHdpbmRvdztcblxudmFyIGlzV29ya2VyID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKTtcblxudmFyIEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5cbnZhciBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcblxudmFyIEltYWdlS2luZCA9IHtcbiAgR1JBWVNDQUxFXzFCUFA6IDEsXG4gIFJHQl8yNEJQUDogMixcbiAgUkdCQV8zMkJQUDogM1xufTtcblxudmFyIEFubm90YXRpb25UeXBlID0ge1xuICBXSURHRVQ6IDEsXG4gIFRFWFQ6IDIsXG4gIExJTks6IDNcbn07XG5cbnZhciBTdHJlYW1UeXBlID0ge1xuICBVTktOT1dOOiAwLFxuICBGTEFURTogMSxcbiAgTFpXOiAyLFxuICBEQ1Q6IDMsXG4gIEpQWDogNCxcbiAgSkJJRzogNSxcbiAgQTg1OiA2LFxuICBBSFg6IDcsXG4gIENDRjogOCxcbiAgUkw6IDlcbn07XG5cbnZhciBGb250VHlwZSA9IHtcbiAgVU5LTk9XTjogMCxcbiAgVFlQRTE6IDEsXG4gIFRZUEUxQzogMixcbiAgQ0lERk9OVFRZUEUwOiAzLFxuICBDSURGT05UVFlQRTBDOiA0LFxuICBUUlVFVFlQRTogNSxcbiAgQ0lERk9OVFRZUEUyOiA2LFxuICBUWVBFMzogNyxcbiAgT1BFTlRZUEU6IDgsXG4gIFRZUEUwOiA5LFxuICBNTVRZUEUxOiAxMFxufTtcblxuLy8gVGhlIGdsb2JhbCBQREZKUyBvYmplY3QgZXhwb3NlcyB0aGUgQVBJXG4vLyBJbiBwcm9kdWN0aW9uLCBpdCB3aWxsIGJlIGRlY2xhcmVkIG91dHNpZGUgYSBnbG9iYWwgd3JhcHBlclxuLy8gSW4gZGV2ZWxvcG1lbnQsIGl0IHdpbGwgYmUgZGVjbGFyZWQgaGVyZVxuaWYgKCFnbG9iYWxTY29wZS5QREZKUykge1xuICBnbG9iYWxTY29wZS5QREZKUyA9IHt9O1xufVxuXG5nbG9iYWxTY29wZS5QREZKUy5wZGZCdWcgPSBmYWxzZTtcblxuUERGSlMuVkVSQk9TSVRZX0xFVkVMUyA9IHtcbiAgZXJyb3JzOiAwLFxuICB3YXJuaW5nczogMSxcbiAgaW5mb3M6IDVcbn07XG5cbi8vIEFsbCB0aGUgcG9zc2libGUgb3BlcmF0aW9ucyBmb3IgYW4gb3BlcmF0b3IgbGlzdC5cbnZhciBPUFMgPSBQREZKUy5PUFMgPSB7XG4gIC8vIEludGVudGlvbmFsbHkgc3RhcnQgZnJvbSAxIHNvIGl0IGlzIGVhc3kgdG8gc3BvdCBiYWQgb3BlcmF0b3JzIHRoYXQgd2lsbCBiZVxuICAvLyAwJ3MuXG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb25zOiA3OCxcbiAgZW5kQW5ub3RhdGlvbnM6IDc5LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRKcGVnWE9iamVjdDogODIsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdDogODMsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwOiA4NCxcbiAgcGFpbnRJbWFnZVhPYmplY3Q6IDg1LFxuICBwYWludElubGluZUltYWdlWE9iamVjdDogODYsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6IDg3LFxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdDogODgsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdDogODksXG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzazogOTAsXG4gIGNvbnN0cnVjdFBhdGg6IDkxXG59O1xuXG4vLyBBIG5vdGljZSBmb3IgZGV2cy4gVGhlc2UgYXJlIGdvb2QgZm9yIHRoaW5ncyB0aGF0IGFyZSBoZWxwZnVsIHRvIGRldnMsIHN1Y2hcbi8vIGFzIHdhcm5pbmcgdGhhdCBXb3JrZXJzIHdlcmUgZGlzYWJsZWQsIHdoaWNoIGlzIGltcG9ydGFudCB0byBkZXZzIGJ1dCBub3Rcbi8vIGVuZCB1c2Vycy5cbmZ1bmN0aW9uIGluZm8obXNnKSB7XG4gIGlmIChQREZKUy52ZXJib3NpdHkgPj0gUERGSlMuVkVSQk9TSVRZX0xFVkVMUy5pbmZvcykge1xuICAgIGNvbnNvbGUubG9nKCdJbmZvOiAnICsgbXNnKTtcbiAgfVxufVxuXG4vLyBOb24tZmF0YWwgd2FybmluZ3MuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAoUERGSlMudmVyYm9zaXR5ID49IFBERkpTLlZFUkJPU0lUWV9MRVZFTFMud2FybmluZ3MpIHtcbiAgICBjb25zb2xlLmxvZygnV2FybmluZzogJyArIG1zZyk7XG4gIH1cbn1cblxuLy8gRmF0YWwgZXJyb3JzIHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGZhbGxiYWNrIFVJIGFuZCBoYWx0IGV4ZWN1dGlvbiBieVxuLy8gdGhyb3dpbmcgYW4gZXhjZXB0aW9uLlxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIC8vIElmIG11bHRpcGxlIGFyZ3VtZW50cyB3ZXJlIHBhc3NlZCwgcGFzcyB0aGVtIGFsbCB0byB0aGUgbG9nIGZ1bmN0aW9uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgbG9nQXJndW1lbnRzID0gWydFcnJvcjonXTtcbiAgICBsb2dBcmd1bWVudHMucHVzaC5hcHBseShsb2dBcmd1bWVudHMsIGFyZ3VtZW50cyk7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgbG9nQXJndW1lbnRzKTtcbiAgICAvLyBKb2luIHRoZSBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBzdHJpbmcgZm9yIHRoZSBsaW5lcyBiZWxvdy5cbiAgICBtc2cgPSBbXS5qb2luLmNhbGwoYXJndW1lbnRzLCAnICcpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdFcnJvcjogJyArIG1zZyk7XG4gIH1cbiAgY29uc29sZS5sb2coYmFja3RyYWNlKCkpO1xuICBVbnN1cHBvcnRlZE1hbmFnZXIubm90aWZ5KFVOU1VQUE9SVEVEX0ZFQVRVUkVTLnVua25vd24pO1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuZnVuY3Rpb24gYmFja3RyYWNlKCkge1xuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGUuc3RhY2sgPyBlLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgyKS5qb2luKCdcXG4nKSA6ICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxufVxuXG52YXIgVU5TVVBQT1JURURfRkVBVFVSRVMgPSBQREZKUy5VTlNVUFBPUlRFRF9GRUFUVVJFUyA9IHtcbiAgdW5rbm93bjogJ3Vua25vd24nLFxuICBmb3JtczogJ2Zvcm1zJyxcbiAgamF2YVNjcmlwdDogJ2phdmFTY3JpcHQnLFxuICBzbWFzazogJ3NtYXNrJyxcbiAgc2hhZGluZ1BhdHRlcm46ICdzaGFkaW5nUGF0dGVybicsXG4gIGZvbnQ6ICdmb250J1xufTtcblxudmFyIFVuc3VwcG9ydGVkTWFuYWdlciA9IFBERkpTLlVuc3VwcG9ydGVkTWFuYWdlciA9XG4gIChmdW5jdGlvbiBVbnN1cHBvcnRlZE1hbmFnZXJDbG9zdXJlKCkge1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHJldHVybiB7XG4gICAgbGlzdGVuOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGNiKTtcbiAgICB9LFxuICAgIG5vdGlmeTogZnVuY3Rpb24gKGZlYXR1cmVJZCkge1xuICAgICAgd2FybignVW5zdXBwb3J0ZWQgZmVhdHVyZSBcIicgKyBmZWF0dXJlSWQgKyAnXCInKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpXShmZWF0dXJlSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbi8vIENvbWJpbmVzIHR3byBVUkxzLiBUaGUgYmFzZVVybCBzaGFsbCBiZSBhYnNvbHV0ZSBVUkwuIElmIHRoZSB1cmwgaXMgYW5cbi8vIGFic29sdXRlIFVSTCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBpcy5cbmZ1bmN0aW9uIGNvbWJpbmVVcmwoYmFzZVVybCwgdXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIGJhc2VVcmw7XG4gIH1cbiAgaWYgKC9eW2Etel1bYS16MC05K1xcLS5dKjovaS50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHZhciBpO1xuICBpZiAodXJsLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgLy8gYWJzb2x1dGUgcGF0aFxuICAgIGkgPSBiYXNlVXJsLmluZGV4T2YoJzovLycpO1xuICAgIGlmICh1cmwuY2hhckF0KDEpID09PSAnLycpIHtcbiAgICAgICsraTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IGJhc2VVcmwuaW5kZXhPZignLycsIGkgKyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VVcmwuc3Vic3RyaW5nKDAsIGkpICsgdXJsO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlbGF0aXZlIHBhdGhcbiAgICB2YXIgcGF0aExlbmd0aCA9IGJhc2VVcmwubGVuZ3RoO1xuICAgIGkgPSBiYXNlVXJsLmxhc3RJbmRleE9mKCcjJyk7XG4gICAgcGF0aExlbmd0aCA9IGkgPj0gMCA/IGkgOiBwYXRoTGVuZ3RoO1xuICAgIGkgPSBiYXNlVXJsLmxhc3RJbmRleE9mKCc/JywgcGF0aExlbmd0aCk7XG4gICAgcGF0aExlbmd0aCA9IGkgPj0gMCA/IGkgOiBwYXRoTGVuZ3RoO1xuICAgIHZhciBwcmVmaXhMZW5ndGggPSBiYXNlVXJsLmxhc3RJbmRleE9mKCcvJywgcGF0aExlbmd0aCk7XG4gICAgcmV0dXJuIGJhc2VVcmwuc3Vic3RyaW5nKDAsIHByZWZpeExlbmd0aCArIDEpICsgdXJsO1xuICB9XG59XG5cbi8vIFZhbGlkYXRlcyBpZiBVUkwgaXMgc2FmZSBhbmQgYWxsb3dlZCwgZS5nLiB0byBhdm9pZCBYU1MuXG5mdW5jdGlvbiBpc1ZhbGlkVXJsKHVybCwgYWxsb3dSZWxhdGl2ZSkge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBSRkMgMzk4NiAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMSlcbiAgLy8gc2NoZW1lID0gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXG4gIHZhciBwcm90b2NvbCA9IC9eW2Etel1bYS16MC05K1xcLS5dKig/PTopL2kuZXhlYyh1cmwpO1xuICBpZiAoIXByb3RvY29sKSB7XG4gICAgcmV0dXJuIGFsbG93UmVsYXRpdmU7XG4gIH1cbiAgcHJvdG9jb2wgPSBwcm90b2NvbFswXS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgY2FzZSAnbWFpbHRvJzpcbiAgICBjYXNlICd0ZWwnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuUERGSlMuaXNWYWxpZFVybCA9IGlzVmFsaWRVcmw7XG5cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHsgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuUERGSlMuc2hhZG93ID0gc2hhZG93O1xuXG52YXIgUGFzc3dvcmRSZXNwb25zZXMgPSBQREZKUy5QYXNzd29yZFJlc3BvbnNlcyA9IHtcbiAgTkVFRF9QQVNTV09SRDogMSxcbiAgSU5DT1JSRUNUX1BBU1NXT1JEOiAyXG59O1xuXG52YXIgUGFzc3dvcmRFeGNlcHRpb24gPSAoZnVuY3Rpb24gUGFzc3dvcmRFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBQYXNzd29yZEV4Y2VwdGlvbihtc2csIGNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSAnUGFzc3dvcmRFeGNlcHRpb24nO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgUGFzc3dvcmRFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIFBhc3N3b3JkRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gUGFzc3dvcmRFeGNlcHRpb247XG5cbiAgcmV0dXJuIFBhc3N3b3JkRXhjZXB0aW9uO1xufSkoKTtcblBERkpTLlBhc3N3b3JkRXhjZXB0aW9uID0gUGFzc3dvcmRFeGNlcHRpb247XG5cbnZhciBVbmtub3duRXJyb3JFeGNlcHRpb24gPSAoZnVuY3Rpb24gVW5rbm93bkVycm9yRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gVW5rbm93bkVycm9yRXhjZXB0aW9uKG1zZywgZGV0YWlscykge1xuICAgIHRoaXMubmFtZSA9ICdVbmtub3duRXJyb3JFeGNlcHRpb24nO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG5cbiAgVW5rbm93bkVycm9yRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBVbmtub3duRXJyb3JFeGNlcHRpb24uY29uc3RydWN0b3IgPSBVbmtub3duRXJyb3JFeGNlcHRpb247XG5cbiAgcmV0dXJuIFVua25vd25FcnJvckV4Y2VwdGlvbjtcbn0pKCk7XG5QREZKUy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBVbmtub3duRXJyb3JFeGNlcHRpb247XG5cbnZhciBJbnZhbGlkUERGRXhjZXB0aW9uID0gKGZ1bmN0aW9uIEludmFsaWRQREZFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBJbnZhbGlkUERGRXhjZXB0aW9uKG1zZykge1xuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkUERGRXhjZXB0aW9uJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gIH1cblxuICBJbnZhbGlkUERGRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBJbnZhbGlkUERGRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gSW52YWxpZFBERkV4Y2VwdGlvbjtcblxuICByZXR1cm4gSW52YWxpZFBERkV4Y2VwdGlvbjtcbn0pKCk7XG5QREZKUy5JbnZhbGlkUERGRXhjZXB0aW9uID0gSW52YWxpZFBERkV4Y2VwdGlvbjtcblxudmFyIE1pc3NpbmdQREZFeGNlcHRpb24gPSAoZnVuY3Rpb24gTWlzc2luZ1BERkV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIE1pc3NpbmdQREZFeGNlcHRpb24obXNnKSB7XG4gICAgdGhpcy5uYW1lID0gJ01pc3NpbmdQREZFeGNlcHRpb24nO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgfVxuXG4gIE1pc3NpbmdQREZFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIE1pc3NpbmdQREZFeGNlcHRpb24uY29uc3RydWN0b3IgPSBNaXNzaW5nUERGRXhjZXB0aW9uO1xuXG4gIHJldHVybiBNaXNzaW5nUERGRXhjZXB0aW9uO1xufSkoKTtcblBERkpTLk1pc3NpbmdQREZFeGNlcHRpb24gPSBNaXNzaW5nUERGRXhjZXB0aW9uO1xuXG52YXIgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID1cbiAgICAoZnVuY3Rpb24gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKG1zZywgc3RhdHVzKSB7XG4gICAgdGhpcy5uYW1lID0gJ1VuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbic7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICB9XG5cbiAgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG5cbiAgcmV0dXJuIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcbn0pKCk7XG5QREZKUy5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPSBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG5cbnZhciBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbiA9IChmdW5jdGlvbiBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uKG1zZykge1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgfVxuXG4gIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbic7XG4gIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gTm90SW1wbGVtZW50ZWRFeGNlcHRpb247XG5cbiAgcmV0dXJuIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uO1xufSkoKTtcblxudmFyIE1pc3NpbmdEYXRhRXhjZXB0aW9uID0gKGZ1bmN0aW9uIE1pc3NpbmdEYXRhRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gTWlzc2luZ0RhdGFFeGNlcHRpb24oYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuYmVnaW4gPSBiZWdpbjtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnTWlzc2luZyBkYXRhIFsnICsgYmVnaW4gKyAnLCAnICsgZW5kICsgJyknO1xuICB9XG5cbiAgTWlzc2luZ0RhdGFFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIE1pc3NpbmdEYXRhRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ01pc3NpbmdEYXRhRXhjZXB0aW9uJztcbiAgTWlzc2luZ0RhdGFFeGNlcHRpb24uY29uc3RydWN0b3IgPSBNaXNzaW5nRGF0YUV4Y2VwdGlvbjtcblxuICByZXR1cm4gTWlzc2luZ0RhdGFFeGNlcHRpb247XG59KSgpO1xuXG52YXIgWFJlZlBhcnNlRXhjZXB0aW9uID0gKGZ1bmN0aW9uIFhSZWZQYXJzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIFhSZWZQYXJzZUV4Y2VwdGlvbihtc2cpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gIH1cblxuICBYUmVmUGFyc2VFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIFhSZWZQYXJzZUV4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdYUmVmUGFyc2VFeGNlcHRpb24nO1xuICBYUmVmUGFyc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBYUmVmUGFyc2VFeGNlcHRpb247XG5cbiAgcmV0dXJuIFhSZWZQYXJzZUV4Y2VwdGlvbjtcbn0pKCk7XG5cblxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBhc3NlcnQoYnl0ZXMgIT09IG51bGwgJiYgdHlwZW9mIGJ5dGVzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgYnl0ZXMubGVuZ3RoICE9PSB1bmRlZmluZWQsICdJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nJyk7XG4gIHZhciBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gIHZhciBNQVhfQVJHVU1FTlRfQ09VTlQgPSA4MTkyO1xuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG4gIHZhciBzdHJCdWYgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgdmFyIGNodW5rRW5kID0gTWF0aC5taW4oaSArIE1BWF9BUkdVTUVOVF9DT1VOVCwgbGVuZ3RoKTtcbiAgICB2YXIgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBjaHVua0VuZCk7XG4gICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuaykpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGFzc2VydCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJywgJ0ludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXMnKTtcbiAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRjtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2YWx1ZSA+PiAyNCkgJiAweGZmLCAodmFsdWUgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlID4+IDgpICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcbn1cblxuZnVuY3Rpb24gbG9nMih4KSB7XG4gIHZhciBuID0gMSwgaSA9IDA7XG4gIHdoaWxlICh4ID4gbikge1xuICAgIG4gPDw9IDE7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiByZWFkSW50OChkYXRhLCBzdGFydCkge1xuICByZXR1cm4gKGRhdGFbc3RhcnRdIDw8IDI0KSA+PiAyNDtcbn1cblxuZnVuY3Rpb24gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xufVxuXG5mdW5jdGlvbiByZWFkVWludDMyKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gKChkYXRhW29mZnNldF0gPDwgMjQpIHwgKGRhdGFbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgIChkYXRhW29mZnNldCArIDJdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAzXSkgPj4+IDA7XG59XG5cbi8vIExhenkgdGVzdCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgcGxhdGZvcm1cbi8vIE5PVEU6IFRoaXMgd2lsbCBiZSAndHJ1ZScgZm9yIHNpbXVsYXRlZCBUeXBlZEFycmF5c1xuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XG4gIHZhciBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoMik7XG4gIGJ1ZmZlcjhbMF0gPSAxO1xuICB2YXIgYnVmZmVyMTYgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyOC5idWZmZXIpO1xuICByZXR1cm4gKGJ1ZmZlcjE2WzBdID09PSAxKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBERkpTLCAnaXNMaXR0bGVFbmRpYW4nLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBQREZKU19pc0xpdHRsZUVuZGlhbigpIHtcbiAgICByZXR1cm4gc2hhZG93KFBERkpTLCAnaXNMaXR0bGVFbmRpYW4nLCBpc0xpdHRsZUVuZGlhbigpKTtcbiAgfVxufSk7XG5cbi8vI2lmICEoRklSRUZPWCB8fCBNT1pDRU5UUkFMIHx8IEIyRyB8fCBDSFJPTUUpXG4vLy8vIExhenkgdGVzdCBpZiB0aGUgdXNlckFnYW50IHN1cHBvcnQgQ2FudmFzVHlwZWRBcnJheXNcbmZ1bmN0aW9uIGhhc0NhbnZhc1R5cGVkQXJyYXlzKCkge1xuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xuICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHZhciBpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKDEsIDEpO1xuICByZXR1cm4gKHR5cGVvZiBpbWFnZURhdGEuZGF0YS5idWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBERkpTLCAnaGFzQ2FudmFzVHlwZWRBcnJheXMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBQREZKU19oYXNDYW52YXNUeXBlZEFycmF5cygpIHtcbiAgICByZXR1cm4gc2hhZG93KFBERkpTLCAnaGFzQ2FudmFzVHlwZWRBcnJheXMnLCBoYXNDYW52YXNUeXBlZEFycmF5cygpKTtcbiAgfVxufSk7XG5cbnZhciBVaW50MzJBcnJheVZpZXcgPSAoZnVuY3Rpb24gVWludDMyQXJyYXlWaWV3Q2xvc3VyZSgpIHtcblxuICBmdW5jdGlvbiBVaW50MzJBcnJheVZpZXcoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLmJ5dGVMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyAodGhpcy5ieXRlTGVuZ3RoID4+IDIpIDogbGVuZ3RoO1xuICAgIGVuc3VyZVVpbnQzMkFycmF5Vmlld1Byb3BzKHRoaXMubGVuZ3RoKTtcbiAgfVxuICBVaW50MzJBcnJheVZpZXcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB2YXIgdWludDMyQXJyYXlWaWV3U2V0dGVycyA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZVVpbnQzMkFycmF5UHJvcChpbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLCBvZmZzZXQgPSBpbmRleCA8PCAyO1xuICAgICAgICByZXR1cm4gKGJ1ZmZlcltvZmZzZXRdIHwgKGJ1ZmZlcltvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgKGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCAxNikgfCAoYnVmZmVyW29mZnNldCArIDNdIDw8IDI0KSkgPj4+IDA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLCBvZmZzZXQgPSBpbmRleCA8PCAyO1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlICYgMjU1O1xuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4gOCkgJiAyNTU7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+PiAxNikgJiAyNTU7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMjU1O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVVaW50MzJBcnJheVZpZXdQcm9wcyhsZW5ndGgpIHtcbiAgICB3aGlsZSAodWludDMyQXJyYXlWaWV3U2V0dGVycyA8IGxlbmd0aCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVpbnQzMkFycmF5Vmlldy5wcm90b3R5cGUsXG4gICAgICAgIHVpbnQzMkFycmF5Vmlld1NldHRlcnMsXG4gICAgICAgIGNyZWF0ZVVpbnQzMkFycmF5UHJvcCh1aW50MzJBcnJheVZpZXdTZXR0ZXJzKSk7XG4gICAgICB1aW50MzJBcnJheVZpZXdTZXR0ZXJzKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVpbnQzMkFycmF5Vmlldztcbn0pKCk7XG4vLyNlbHNlXG4vL1BERkpTLmhhc0NhbnZhc1R5cGVkQXJyYXlzID0gdHJ1ZTtcbi8vI2VuZGlmXG5cbnZhciBJREVOVElUWV9NQVRSSVggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG5cbnZhciBVdGlsID0gUERGSlMuVXRpbCA9IChmdW5jdGlvbiBVdGlsQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gVXRpbCgpIHt9XG5cbiAgdmFyIHJnYkJ1ZiA9IFsncmdiKCcsIDAsICcsJywgMCwgJywnLCAwLCAnKSddO1xuXG4gIC8vIG1ha2VDc3NSZ2IoKSBjYW4gYmUgY2FsbGVkIHRob3VzYW5kcyBvZiB0aW1lcy4gVXNpbmcgfHJnYkJ1ZnwgYXZvaWRzXG4gIC8vIGNyZWF0aW5nIG1hbnkgaW50ZXJtZWRpYXRlIHN0cmluZ3MuXG4gIFV0aWwubWFrZUNzc1JnYiA9IGZ1bmN0aW9uIFV0aWxfbWFrZUNzc1JnYihyLCBnLCBiKSB7XG4gICAgcmdiQnVmWzFdID0gcjtcbiAgICByZ2JCdWZbM10gPSBnO1xuICAgIHJnYkJ1Zls1XSA9IGI7XG4gICAgcmV0dXJuIHJnYkJ1Zi5qb2luKCcnKTtcbiAgfTtcblxuICAvLyBDb25jYXRlbmF0ZXMgdHdvIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIHRvZ2V0aGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gIFV0aWwudHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF90cmFuc2Zvcm0obTEsIG0yKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdLFxuICAgICAgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sXG4gICAgICBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSxcbiAgICAgIG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdLFxuICAgICAgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSxcbiAgICAgIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1cbiAgICBdO1xuICB9O1xuXG4gIC8vIEZvciAyZCBhZmZpbmUgdHJhbnNmb3Jtc1xuICBVdGlsLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF9hcHBseVRyYW5zZm9ybShwLCBtKSB7XG4gICAgdmFyIHh0ID0gcFswXSAqIG1bMF0gKyBwWzFdICogbVsyXSArIG1bNF07XG4gICAgdmFyIHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9O1xuXG4gIFV0aWwuYXBwbHlJbnZlcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF9hcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgIHZhciBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICB2YXIgeHQgPSAocFswXSAqIG1bM10gLSBwWzFdICogbVsyXSArIG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZDtcbiAgICB2YXIgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9O1xuXG4gIC8vIEFwcGxpZXMgdGhlIHRyYW5zZm9ybSB0byB0aGUgcmVjdGFuZ2xlIGFuZCBmaW5kcyB0aGUgbWluaW11bSBheGlhbGx5XG4gIC8vIGFsaWduZWQgYm91bmRpbmcgYm94LlxuICBVdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94ID1cbiAgICBmdW5jdGlvbiBVdGlsX2dldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHIsIG0pIHtcblxuICAgIHZhciBwMSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0ociwgbSk7XG4gICAgdmFyIHAyID0gVXRpbC5hcHBseVRyYW5zZm9ybShyLnNsaWNlKDIsIDQpLCBtKTtcbiAgICB2YXIgcDMgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyWzBdLCByWzNdXSwgbSk7XG4gICAgdmFyIHA0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclsyXSwgclsxXV0sIG0pO1xuICAgIHJldHVybiBbXG4gICAgICBNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksXG4gICAgICBNYXRoLm1pbihwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSksXG4gICAgICBNYXRoLm1heChwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksXG4gICAgICBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSlcbiAgICBdO1xuICB9O1xuXG4gIFV0aWwuaW52ZXJzZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIFV0aWxfaW52ZXJzZVRyYW5zZm9ybShtKSB7XG4gICAgdmFyIGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCxcbiAgICAgIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9O1xuXG4gIC8vIEFwcGx5IGEgZ2VuZXJpYyAzZCBtYXRyaXggTSBvbiBhIDMtdmVjdG9yIHY6XG4gIC8vICAgfCBhIGIgYyB8ICAgfCBYIHxcbiAgLy8gICB8IGQgZSBmIHwgeCB8IFkgfFxuICAvLyAgIHwgZyBoIGkgfCAgIHwgWiB8XG4gIC8vIE0gaXMgYXNzdW1lZCB0byBiZSBzZXJpYWxpemVkIGFzIFthLGIsYyxkLGUsZixnLGgsaV0sXG4gIC8vIHdpdGggdiBhcyBbWCxZLFpdXG4gIFV0aWwuYXBwbHkzZFRyYW5zZm9ybSA9IGZ1bmN0aW9uIFV0aWxfYXBwbHkzZFRyYW5zZm9ybShtLCB2KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1bMF0gKiB2WzBdICsgbVsxXSAqIHZbMV0gKyBtWzJdICogdlsyXSxcbiAgICAgIG1bM10gKiB2WzBdICsgbVs0XSAqIHZbMV0gKyBtWzVdICogdlsyXSxcbiAgICAgIG1bNl0gKiB2WzBdICsgbVs3XSAqIHZbMV0gKyBtWzhdICogdlsyXVxuICAgIF07XG4gIH07XG5cbiAgLy8gVGhpcyBjYWxjdWxhdGlvbiB1c2VzIFNpbmd1bGFyIFZhbHVlIERlY29tcG9zaXRpb24uXG4gIC8vIFRoZSBTVkQgY2FuIGJlIHJlcHJlc2VudGVkIHdpdGggZm9ybXVsYSBBID0gVVNWLiBXZSBhcmUgaW50ZXJlc3RlZCBpbiB0aGVcbiAgLy8gbWF0cml4IFMgaGVyZSBiZWNhdXNlIGl0IHJlcHJlc2VudHMgdGhlIHNjYWxlIHZhbHVlcy5cbiAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSA9XG4gICAgZnVuY3Rpb24gVXRpbF9zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtKSB7XG5cbiAgICB2YXIgdHJhbnNwb3NlID0gW21bMF0sIG1bMl0sIG1bMV0sIG1bM11dO1xuXG4gICAgLy8gTXVsdGlwbHkgbWF0cml4IG0gd2l0aCBpdHMgdHJhbnNwb3NlLlxuICAgIHZhciBhID0gbVswXSAqIHRyYW5zcG9zZVswXSArIG1bMV0gKiB0cmFuc3Bvc2VbMl07XG4gICAgdmFyIGIgPSBtWzBdICogdHJhbnNwb3NlWzFdICsgbVsxXSAqIHRyYW5zcG9zZVszXTtcbiAgICB2YXIgYyA9IG1bMl0gKiB0cmFuc3Bvc2VbMF0gKyBtWzNdICogdHJhbnNwb3NlWzJdO1xuICAgIHZhciBkID0gbVsyXSAqIHRyYW5zcG9zZVsxXSArIG1bM10gKiB0cmFuc3Bvc2VbM107XG5cbiAgICAvLyBTb2x2ZSB0aGUgc2Vjb25kIGRlZ3JlZSBwb2x5bm9taWFsIHRvIGdldCByb290cy5cbiAgICB2YXIgZmlyc3QgPSAoYSArIGQpIC8gMjtcbiAgICB2YXIgc2Vjb25kID0gTWF0aC5zcXJ0KChhICsgZCkgKiAoYSArIGQpIC0gNCAqIChhICogZCAtIGMgKiBiKSkgLyAyO1xuICAgIHZhciBzeCA9IGZpcnN0ICsgc2Vjb25kIHx8IDE7XG4gICAgdmFyIHN5ID0gZmlyc3QgLSBzZWNvbmQgfHwgMTtcblxuICAgIC8vIFNjYWxlIHZhbHVlcyBhcmUgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZWlnZW52YWx1ZXMuXG4gICAgcmV0dXJuIFtNYXRoLnNxcnQoc3gpLCBNYXRoLnNxcnQoc3kpXTtcbiAgfTtcblxuICAvLyBOb3JtYWxpemUgcmVjdGFuZ2xlIHJlY3Q9W3gxLCB5MSwgeDIsIHkyXSBzbyB0aGF0ICh4MSx5MSkgPCAoeDIseTIpXG4gIC8vIEZvciBjb29yZGluYXRlIHN5c3RlbXMgd2hvc2Ugb3JpZ2luIGxpZXMgaW4gdGhlIGJvdHRvbS1sZWZ0LCB0aGlzXG4gIC8vIG1lYW5zIG5vcm1hbGl6YXRpb24gdG8gKEJMLFRSKSBvcmRlcmluZy4gRm9yIHN5c3RlbXMgd2l0aCBvcmlnaW4gaW4gdGhlXG4gIC8vIHRvcC1sZWZ0LCB0aGlzIG1lYW5zIChUTCxCUikgb3JkZXJpbmcuXG4gIFV0aWwubm9ybWFsaXplUmVjdCA9IGZ1bmN0aW9uIFV0aWxfbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgdmFyIHIgPSByZWN0LnNsaWNlKDApOyAvLyBjbG9uZSByZWN0XG4gICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XG4gICAgICByWzBdID0gcmVjdFsyXTtcbiAgICAgIHJbMl0gPSByZWN0WzBdO1xuICAgIH1cbiAgICBpZiAocmVjdFsxXSA+IHJlY3RbM10pIHtcbiAgICAgIHJbMV0gPSByZWN0WzNdO1xuICAgICAgclszXSA9IHJlY3RbMV07XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSByZWN0YW5nbGUgW3gxLCB5MSwgeDIsIHkyXSBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAvLyBpbnRlcnNlY3Rpb24gb2YgcmVjdDEgYW5kIHJlY3QyLiBJZiBubyBpbnRlcnNlY3Rpb24sIHJldHVybnMgJ2ZhbHNlJ1xuICAvLyBUaGUgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzIG9mIHJlY3QxLCByZWN0MiBzaG91bGQgYmUgW3gxLCB5MSwgeDIsIHkyXVxuICBVdGlsLmludGVyc2VjdCA9IGZ1bmN0aW9uIFV0aWxfaW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH1cblxuICAgIC8vIE9yZGVyIHBvaW50cyBhbG9uZyB0aGUgYXhlc1xuICAgIHZhciBvcmRlcmVkWCA9IFtyZWN0MVswXSwgcmVjdDFbMl0sIHJlY3QyWzBdLCByZWN0MlsyXV0uc29ydChjb21wYXJlKSxcbiAgICAgICAgb3JkZXJlZFkgPSBbcmVjdDFbMV0sIHJlY3QxWzNdLCByZWN0MlsxXSwgcmVjdDJbM11dLnNvcnQoY29tcGFyZSksXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgcmVjdDEgPSBVdGlsLm5vcm1hbGl6ZVJlY3QocmVjdDEpO1xuICAgIHJlY3QyID0gVXRpbC5ub3JtYWxpemVSZWN0KHJlY3QyKTtcblxuICAgIC8vIFg6IGZpcnN0IGFuZCBzZWNvbmQgcG9pbnRzIGJlbG9uZyB0byBkaWZmZXJlbnQgcmVjdGFuZ2xlcz9cbiAgICBpZiAoKG9yZGVyZWRYWzBdID09PSByZWN0MVswXSAmJiBvcmRlcmVkWFsxXSA9PT0gcmVjdDJbMF0pIHx8XG4gICAgICAgIChvcmRlcmVkWFswXSA9PT0gcmVjdDJbMF0gJiYgb3JkZXJlZFhbMV0gPT09IHJlY3QxWzBdKSkge1xuICAgICAgLy8gSW50ZXJzZWN0aW9uIG11c3QgYmUgYmV0d2VlbiBzZWNvbmQgYW5kIHRoaXJkIHBvaW50c1xuICAgICAgcmVzdWx0WzBdID0gb3JkZXJlZFhbMV07XG4gICAgICByZXN1bHRbMl0gPSBvcmRlcmVkWFsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFk6IGZpcnN0IGFuZCBzZWNvbmQgcG9pbnRzIGJlbG9uZyB0byBkaWZmZXJlbnQgcmVjdGFuZ2xlcz9cbiAgICBpZiAoKG9yZGVyZWRZWzBdID09PSByZWN0MVsxXSAmJiBvcmRlcmVkWVsxXSA9PT0gcmVjdDJbMV0pIHx8XG4gICAgICAgIChvcmRlcmVkWVswXSA9PT0gcmVjdDJbMV0gJiYgb3JkZXJlZFlbMV0gPT09IHJlY3QxWzFdKSkge1xuICAgICAgLy8gSW50ZXJzZWN0aW9uIG11c3QgYmUgYmV0d2VlbiBzZWNvbmQgYW5kIHRoaXJkIHBvaW50c1xuICAgICAgcmVzdWx0WzFdID0gb3JkZXJlZFlbMV07XG4gICAgICByZXN1bHRbM10gPSBvcmRlcmVkWVsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgVXRpbC5zaWduID0gZnVuY3Rpb24gVXRpbF9zaWduKG51bSkge1xuICAgIHJldHVybiBudW0gPCAwID8gLTEgOiAxO1xuICB9O1xuXG4gIFV0aWwuYXBwZW5kVG9BcnJheSA9IGZ1bmN0aW9uIFV0aWxfYXBwZW5kVG9BcnJheShhcnIxLCBhcnIyKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJyMSwgYXJyMik7XG4gIH07XG5cbiAgVXRpbC5wcmVwZW5kVG9BcnJheSA9IGZ1bmN0aW9uIFV0aWxfcHJlcGVuZFRvQXJyYXkoYXJyMSwgYXJyMikge1xuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGFycjEsIGFycjIpO1xuICB9O1xuXG4gIFV0aWwuZXh0ZW5kT2JqID0gZnVuY3Rpb24gZXh0ZW5kT2JqKG9iajEsIG9iajIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMikge1xuICAgICAgb2JqMVtrZXldID0gb2JqMltrZXldO1xuICAgIH1cbiAgfTtcblxuICBVdGlsLmdldEluaGVyaXRhYmxlUHJvcGVydHkgPSBmdW5jdGlvbiBVdGlsX2dldEluaGVyaXRhYmxlUHJvcGVydHkoZGljdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUpIHtcbiAgICB3aGlsZSAoZGljdCAmJiAhZGljdC5oYXMobmFtZSkpIHtcbiAgICAgIGRpY3QgPSBkaWN0LmdldCgnUGFyZW50Jyk7XG4gICAgfVxuICAgIGlmICghZGljdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkaWN0LmdldChuYW1lKTtcbiAgfTtcblxuICBVdGlsLmluaGVyaXQgPSBmdW5jdGlvbiBVdGlsX2luaGVyaXQoc3ViLCBiYXNlLCBwcm90b3R5cGUpIHtcbiAgICBzdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlLnByb3RvdHlwZSk7XG4gICAgc3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YjtcbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3RvdHlwZSkge1xuICAgICAgc3ViLnByb3RvdHlwZVtwcm9wXSA9IHByb3RvdHlwZVtwcm9wXTtcbiAgICB9XG4gIH07XG5cbiAgVXRpbC5sb2FkU2NyaXB0ID0gZnVuY3Rpb24gVXRpbF9sb2FkU2NyaXB0KHNyYywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgdmFyIGxvYWRlZCA9IGZhbHNlO1xuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYyk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9O1xuXG4gIHJldHVybiBVdGlsO1xufSkoKTtcblxuLyoqXG4gKiBQREYgcGFnZSB2aWV3cG9ydCBjcmVhdGVkIGJhc2VkIG9uIHNjYWxlLCByb3RhdGlvbiBhbmQgb2Zmc2V0LlxuICogQGNsYXNzXG4gKiBAYWxpYXMgUERGSlMuUGFnZVZpZXdwb3J0XG4gKi9cbnZhciBQYWdlVmlld3BvcnQgPSBQREZKUy5QYWdlVmlld3BvcnQgPSAoZnVuY3Rpb24gUGFnZVZpZXdwb3J0Q2xvc3VyZSgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gdmlld0JveCB7QXJyYXl9IHhNaW4sIHlNaW4sIHhNYXggYW5kIHlNYXggY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSBzY2FsZSB7bnVtYmVyfSBzY2FsZSBvZiB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSByb3RhdGlvbiB7bnVtYmVyfSByb3RhdGlvbnMgb2YgdGhlIHZpZXdwb3J0IGluIGRlZ3JlZXMuXG4gICAqIEBwYXJhbSBvZmZzZXRYIHtudW1iZXJ9IG9mZnNldCBYXG4gICAqIEBwYXJhbSBvZmZzZXRZIHtudW1iZXJ9IG9mZnNldCBZXG4gICAqIEBwYXJhbSBkb250RmxpcCB7Ym9vbGVhbn0gaWYgdHJ1ZSwgYXhpcyBZIHdpbGwgbm90IGJlIGZsaXBwZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQYWdlVmlld3BvcnQodmlld0JveCwgc2NhbGUsIHJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZLCBkb250RmxpcCkge1xuICAgIHRoaXMudmlld0JveCA9IHZpZXdCb3g7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG5cbiAgICAvLyBjcmVhdGluZyB0cmFuc2Zvcm0gdG8gY29udmVydCBwZGYgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gdGhlIG5vcm1hbFxuICAgIC8vIGNhbnZhcyBsaWtlIGNvb3JkaW5hdGVzIHRha2luZyBpbiBhY2NvdW50IHNjYWxlIGFuZCByb3RhdGlvblxuICAgIHZhciBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XG4gICAgdmFyIGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICB2YXIgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiA9IHJvdGF0aW9uICUgMzYwO1xuICAgIHJvdGF0aW9uID0gcm90YXRpb24gPCAwID8gcm90YXRpb24gKyAzNjAgOiByb3RhdGlvbjtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcm90YXRlQSA9IC0xOyByb3RhdGVCID0gMDsgcm90YXRlQyA9IDA7IHJvdGF0ZUQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJvdGF0ZUEgPSAwOyByb3RhdGVCID0gMTsgcm90YXRlQyA9IDE7IHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDsgcm90YXRlQiA9IC0xOyByb3RhdGVDID0gLTE7IHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vY2FzZSAwOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcm90YXRlQSA9IDE7IHJvdGF0ZUIgPSAwOyByb3RhdGVDID0gMDsgcm90YXRlRCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQzsgcm90YXRlRCA9IC1yb3RhdGVEO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZO1xuICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gTWF0aC5hYnModmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSBNYXRoLmFicyh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9IE1hdGguYWJzKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5hYnModmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuICAgIC8vIGNyZWF0aW5nIHRyYW5zZm9ybSBmb3IgdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICAgIC8vIHRyYW5zbGF0ZSgtY2VudGVyWCwgLWNlbnRlclkpLCByb3RhdGUgYW5kIGZsaXAgdmVydGljYWxseSxcbiAgICAvLyBzY2FsZSwgYW5kIHRyYW5zbGF0ZShvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZKVxuICAgIHRoaXMudHJhbnNmb3JtID0gW1xuICAgICAgcm90YXRlQSAqIHNjYWxlLFxuICAgICAgcm90YXRlQiAqIHNjYWxlLFxuICAgICAgcm90YXRlQyAqIHNjYWxlLFxuICAgICAgcm90YXRlRCAqIHNjYWxlLFxuICAgICAgb2Zmc2V0Q2FudmFzWCAtIHJvdGF0ZUEgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVDICogc2NhbGUgKiBjZW50ZXJZLFxuICAgICAgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXG4gICAgXTtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmZvbnRTY2FsZSA9IHNjYWxlO1xuICB9XG4gIFBhZ2VWaWV3cG9ydC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIFBERkpTLlBhZ2VWaWV3cG9ydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIENsb25lcyB2aWV3cG9ydCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0gYXJncyB7T2JqZWN0fSAob3B0aW9uYWwpIElmIHNwZWNpZmllZCwgbWF5IGNvbnRhaW4gdGhlICdzY2FsZScgb3JcbiAgICAgKiAncm90YXRpb24nIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBpblxuICAgICAqIHRoZSBjbG9uZWQgdmlld3BvcnQuXG4gICAgICogQHJldHVybnMge1BERkpTLlBhZ2VWaWV3cG9ydH0gQ2xvbmVkIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiBQYWdlVmlld1BvcnRfY2xvbmUoYXJncykge1xuICAgICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgICB2YXIgc2NhbGUgPSAnc2NhbGUnIGluIGFyZ3MgPyBhcmdzLnNjYWxlIDogdGhpcy5zY2FsZTtcbiAgICAgIHZhciByb3RhdGlvbiA9ICdyb3RhdGlvbicgaW4gYXJncyA/IGFyZ3Mucm90YXRpb24gOiB0aGlzLnJvdGF0aW9uO1xuICAgICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQodGhpcy52aWV3Qm94LnNsaWNlKCksIHNjYWxlLCByb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0WCwgdGhpcy5vZmZzZXRZLCBhcmdzLmRvbnRGbGlwKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIFBERiBwb2ludCB0byB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZXMuIEZvciBleGFtcGxlcywgdXNlZnVsIGZvclxuICAgICAqIGNvbnZlcnRpbmcgUERGIGxvY2F0aW9uIGludG8gY2FudmFzIHBpeGVsIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBZIGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHRoYXQgY29udGFpbnMgJ3gnIGFuZCAneScgcHJvcGVydGllcyBvZiB0aGVcbiAgICAgKiBwb2ludCBpbiB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICAgKiBAc2VlIHtAbGluayBjb252ZXJ0VG9QZGZQb2ludH1cbiAgICAgKiBAc2VlIHtAbGluayBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZX1cbiAgICAgKi9cbiAgICBjb252ZXJ0VG9WaWV3cG9ydFBvaW50OiBmdW5jdGlvbiBQYWdlVmlld3BvcnRfY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgICByZXR1cm4gVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIFBERiByZWN0YW5nbGUgdG8gdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSByZWN0IHtBcnJheX0geE1pbiwgeU1pbiwgeE1heCBhbmQgeU1heCBjb29yZGluYXRlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IENvbnRhaW5zIGNvcnJlc3BvbmRpbmcgY29vcmRpbmF0ZXMgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIGluIHRoZSB2aWV3cG9ydCBjb29yZGluYXRlIHNwYWNlLlxuICAgICAqIEBzZWUge0BsaW5rIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnR9XG4gICAgICovXG4gICAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGU6XG4gICAgICBmdW5jdGlvbiBQYWdlVmlld3BvcnRfY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgICAgdmFyIHRsID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFswXSwgcmVjdFsxXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICAgIHZhciBiciA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMl0sIHJlY3RbM11dLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gW3RsWzBdLCB0bFsxXSwgYnJbMF0sIGJyWzFdXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIHRoZSBQREYgbG9jYXRpb24uIEZvciBleGFtcGxlcywgdXNlZnVsXG4gICAgICogZm9yIGNvbnZlcnRpbmcgY2FudmFzIHBpeGVsIGxvY2F0aW9uIGludG8gUERGIG9uZS5cbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBYIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHkge251bWJlcn0gWSBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB0aGF0IGNvbnRhaW5zICd4JyBhbmQgJ3knIHByb3BlcnRpZXMgb2YgdGhlXG4gICAgICogcG9pbnQgaW4gdGhlIFBERiBjb29yZGluYXRlIHNwYWNlLlxuICAgICAqIEBzZWUge0BsaW5rIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnR9XG4gICAgICovXG4gICAgY29udmVydFRvUGRmUG9pbnQ6IGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydF9jb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XG4gICAgICByZXR1cm4gVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gUGFnZVZpZXdwb3J0O1xufSkoKTtcblxudmFyIFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAweDJEOCwgMHgyQzcsIDB4MkM2LCAweDJEOSwgMHgyREQsIDB4MkRCLCAweDJEQSwgMHgyREMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LFxuICAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNBLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFFLCAweDIwMUMsXG4gIDB4MjAxRCwgMHgyMDE4LCAweDIwMTksIDB4MjAxQSwgMHgyMTIyLCAweEZCMDEsIDB4RkIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCxcbiAgMHgxNzgsIDB4MTdELCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN0UsIDAsIDB4MjBBQ1xuXTtcblxuZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoc3RyKSB7XG4gIHZhciBpLCBuID0gc3RyLmxlbmd0aCwgc3RyQnVmID0gW107XG4gIGlmIChzdHJbMF0gPT09ICdcXHhGRScgJiYgc3RyWzFdID09PSAnXFx4RkYnKSB7XG4gICAgLy8gVVRGMTZCRSBCT01cbiAgICBmb3IgKGkgPSAyOyBpIDwgbjsgaSArPSAyKSB7XG4gICAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzdHIuY2hhckNvZGVBdChpICsgMSkpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2wodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNJbnQodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInICYmICgodiB8IDApID09PSB2KTtcbn1cblxuZnVuY3Rpb24gaXNOdW0odikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbCh2KSB7XG4gIHJldHVybiB2ID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc05hbWUodikge1xuICByZXR1cm4gdiBpbnN0YW5jZW9mIE5hbWU7XG59XG5cbmZ1bmN0aW9uIGlzQ21kKHYsIGNtZCkge1xuICByZXR1cm4gdiBpbnN0YW5jZW9mIENtZCAmJiAoY21kID09PSB1bmRlZmluZWQgfHwgdi5jbWQgPT09IGNtZCk7XG59XG5cbmZ1bmN0aW9uIGlzRGljdCh2LCB0eXBlKSB7XG4gIGlmICghKHYgaW5zdGFuY2VvZiBEaWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgZGljdFR5cGUgPSB2LmdldCgnVHlwZScpO1xuICByZXR1cm4gaXNOYW1lKGRpY3RUeXBlKSAmJiBkaWN0VHlwZS5uYW1lID09PSB0eXBlO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHYpIHtcbiAgcmV0dXJuIHYgaW5zdGFuY2VvZiBBcnJheTtcbn1cblxuZnVuY3Rpb24gaXNTdHJlYW0odikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwgJiYgdi5nZXRCeXRlcyAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsICYmIHYuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc1JlZih2KSB7XG4gIHJldHVybiB2IGluc3RhbmNlb2YgUmVmO1xufVxuXG4vKipcbiAqIFByb21pc2UgQ2FwYWJpbGl0eSBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvbWlzZUNhcGFiaWxpdHlcbiAqIEBwcm9wZXJ0eSB7UHJvbWlzZX0gcHJvbWlzZSAtIEEgcHJvbWlzZSBvYmplY3QuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSByZXNvbHZlIC0gRnVsbGZpbGxzIHRoZSBwcm9taXNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcmVqZWN0IC0gUmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm9taXNlIGNhcGFiaWxpdHkgb2JqZWN0LlxuICogQGFsaWFzIFBERkpTLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5XG4gKlxuICogQHJldHVybiB7UHJvbWlzZUNhcGFiaWxpdHl9IEEgY2FwYWJpbGl0eSBvYmplY3QgY29udGFpbnM6XG4gKiAtIGEgUHJvbWlzZSwgcmVzb2x2ZSBhbmQgcmVqZWN0IG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KCkge1xuICB2YXIgY2FwYWJpbGl0eSA9IHt9O1xuICBjYXBhYmlsaXR5LnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY2FwYWJpbGl0eS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICBjYXBhYmlsaXR5LnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gIHJldHVybiBjYXBhYmlsaXR5O1xufVxuXG5QREZKUy5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSA9IGNyZWF0ZVByb21pc2VDYXBhYmlsaXR5O1xuXG4vKipcbiAqIFBvbHlmaWxsIGZvciBQcm9taXNlczpcbiAqIFRoZSBmb2xsb3dpbmcgcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiB0cmllcyB0byBnZW5lcmFsbHkgaW1wbGVtZW50IHRoZVxuICogUHJvbWlzZS9BKyBzcGVjLiBTb21lIG5vdGFibGUgZGlmZmVyZW5jZXMgZnJvbSBvdGhlciBwcm9taXNlIGxpYmFyaWVzIGFyZTpcbiAqIC0gVGhlcmUgY3VycmVudGx5IGlzbid0IGEgc2VwZXJhdGUgZGVmZXJyZWQgYW5kIHByb21pc2Ugb2JqZWN0LlxuICogLSBVbmhhbmRsZWQgcmVqZWN0aW9ucyBldmVudHVhbGx5IHNob3cgYW4gZXJyb3IgaWYgdGhleSBhcmVuJ3QgaGFuZGxlZC5cbiAqXG4gKiBCYXNlZCBvZmYgb2YgdGhlIHdvcmsgaW46XG4gKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04MTA0OTBcbiAqL1xuKGZ1bmN0aW9uIFByb21pc2VDbG9zdXJlKCkge1xuICBpZiAoZ2xvYmFsU2NvcGUuUHJvbWlzZSkge1xuICAgIC8vIFByb21pc2VzIGV4aXN0aW5nIGluIHRoZSBET00vV29ya2VyLCBjaGVja2luZyBwcmVzZW5jZSBvZiBhbGwvcmVzb2x2ZVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsU2NvcGUuUHJvbWlzZS5hbGwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGdsb2JhbFNjb3BlLlByb21pc2UuYWxsID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDAsIHJlc3VsdHMgPSBbXSwgcmVzb2x2ZSwgcmVqZWN0O1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBnbG9iYWxTY29wZS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlXywgcmVqZWN0Xykge1xuICAgICAgICAgIHJlc29sdmUgPSByZXNvbHZlXztcbiAgICAgICAgICByZWplY3QgPSByZWplY3RfO1xuICAgICAgICB9KTtcbiAgICAgICAgaXRlcmFibGUuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgcC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbFNjb3BlLlByb21pc2UucmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZ2xvYmFsU2NvcGUuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgZ2xvYmFsU2NvcGUuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbFNjb3BlLlByb21pc2UucmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBnbG9iYWxTY29wZS5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxTY29wZS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbFNjb3BlLlByb21pc2UucHJvdG90eXBlLmNhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBnbG9iYWxTY29wZS5Qcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsU2NvcGUuUHJvbWlzZS5wcm90b3R5cGUudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuLy8jaWYgIU1PWkNFTlRSQUxcbiAgdmFyIFNUQVRVU19QRU5ESU5HID0gMDtcbiAgdmFyIFNUQVRVU19SRVNPTFZFRCA9IDE7XG4gIHZhciBTVEFUVVNfUkVKRUNURUQgPSAyO1xuXG4gIC8vIEluIGFuIGF0dGVtcHQgdG8gYXZvaWQgc2lsZW50IGV4Y2VwdGlvbnMsIHVuaGFuZGxlZCByZWplY3Rpb25zIGFyZVxuICAvLyB0cmFja2VkIGFuZCBpZiB0aGV5IGFyZW4ndCBoYW5kbGVkIGluIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZSBhblxuICAvLyBlcnJvciBpcyBsb2dnZWQuXG4gIHZhciBSRUpFQ1RJT05fVElNRU9VVCA9IDUwMDtcblxuICB2YXIgSGFuZGxlck1hbmFnZXIgPSB7XG4gICAgaGFuZGxlcnM6IFtdLFxuICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgIHVuaGFuZGxlZFJlamVjdGlvbnM6IFtdLFxuICAgIHBlbmRpbmdSZWplY3Rpb25DaGVjazogZmFsc2UsXG5cbiAgICBzY2hlZHVsZUhhbmRsZXJzOiBmdW5jdGlvbiBzY2hlZHVsZUhhbmRsZXJzKHByb21pc2UpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0dXMgPT09IFNUQVRVU19QRU5ESU5HKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuY29uY2F0KHByb21pc2UuX2hhbmRsZXJzKTtcbiAgICAgIHByb21pc2UuX2hhbmRsZXJzID0gW107XG5cbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgc2V0VGltZW91dCh0aGlzLnJ1bkhhbmRsZXJzLmJpbmQodGhpcyksIDApO1xuICAgIH0sXG5cbiAgICBydW5IYW5kbGVyczogZnVuY3Rpb24gcnVuSGFuZGxlcnMoKSB7XG4gICAgICB2YXIgUlVOX1RJTUVPVVQgPSAxOyAvLyBtc1xuICAgICAgdmFyIHRpbWVvdXRBdCA9IERhdGUubm93KCkgKyBSVU5fVElNRU9VVDtcbiAgICAgIHdoaWxlICh0aGlzLmhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLnNoaWZ0KCk7XG5cbiAgICAgICAgdmFyIG5leHRTdGF0dXMgPSBoYW5kbGVyLnRoaXNQcm9taXNlLl9zdGF0dXM7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBoYW5kbGVyLnRoaXNQcm9taXNlLl92YWx1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChuZXh0U3RhdHVzID09PSBTVEFUVVNfUkVTT0xWRUQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vblJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgbmV4dFZhbHVlID0gaGFuZGxlci5vblJlc29sdmUobmV4dFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBoYW5kbGVyLm9uUmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG5leHRWYWx1ZSA9IGhhbmRsZXIub25SZWplY3QobmV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgbmV4dFN0YXR1cyA9IFNUQVRVU19SRVNPTFZFRDtcblxuICAgICAgICAgICAgICBpZiAoaGFuZGxlci50aGlzUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVVbmhhbmRlbGVkUmVqZWN0aW9uKGhhbmRsZXIudGhpc1Byb21pc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBTVEFUVVNfUkVKRUNURUQ7XG4gICAgICAgICAgbmV4dFZhbHVlID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVyLm5leHRQcm9taXNlLl91cGRhdGVTdGF0dXMobmV4dFN0YXR1cywgbmV4dFZhbHVlKTtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPj0gdGltZW91dEF0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucnVuSGFuZGxlcnMuYmluZCh0aGlzKSwgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIGFkZFVuaGFuZGxlZFJlamVjdGlvbjogZnVuY3Rpb24gYWRkVW5oYW5kbGVkUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVqZWN0aW9uQ2hlY2soKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVW5oYW5kZWxlZFJlamVjdGlvbjogZnVuY3Rpb24gcmVtb3ZlVW5oYW5kZWxlZFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgICBwcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb24gPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnNbaV0ucHJvbWlzZSA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoaSk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNjaGVkdWxlUmVqZWN0aW9uQ2hlY2s6IGZ1bmN0aW9uIHNjaGVkdWxlUmVqZWN0aW9uQ2hlY2soKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nUmVqZWN0aW9uQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nUmVqZWN0aW9uQ2hlY2sgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiByZWplY3Rpb25DaGVjaygpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVqZWN0aW9uQ2hlY2sgPSBmYWxzZTtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5vdyAtIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9uc1tpXS50aW1lID4gUkVKRUNUSU9OX1RJTUVPVVQpIHtcbiAgICAgICAgICAgIHZhciB1bmhhbmRsZWQgPSB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnNbaV0ucHJvbWlzZS5fdmFsdWU7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ1VuaGFuZGxlZCByZWplY3Rpb246ICcgKyB1bmhhbmRsZWQ7XG4gICAgICAgICAgICBpZiAodW5oYW5kbGVkLnN0YWNrKSB7XG4gICAgICAgICAgICAgIG1zZyArPSAnXFxuJyArIHVuaGFuZGxlZC5zdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoaSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZVJlamVjdGlvbkNoZWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSwgUkVKRUNUSU9OX1RJTUVPVVQpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gU1RBVFVTX1BFTkRJTkc7XG4gICAgdGhpcy5faGFuZGxlcnMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZXIuY2FsbCh0aGlzLCB0aGlzLl9yZXNvbHZlLmJpbmQodGhpcyksIHRoaXMuX3JlamVjdC5iaW5kKHRoaXMpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLl9yZWplY3QoZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBCdWlsZHMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBhbGwgdGhlIHBhc3NlZCBpbiBwcm9taXNlcyBhcmVcbiAgICogcmVzb2x2ZWQuXG4gICAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IG9mIGRhdGEgYW5kL29yIHByb21pc2VzIHRvIHdhaXQgZm9yLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBOZXcgZGVwZW5kYW50IHByb21pc2UuXG4gICAqL1xuICBQcm9taXNlLmFsbCA9IGZ1bmN0aW9uIFByb21pc2VfYWxsKHByb21pc2VzKSB7XG4gICAgdmFyIHJlc29sdmVBbGwsIHJlamVjdEFsbDtcbiAgICB2YXIgZGVmZXJyZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZXNvbHZlQWxsID0gcmVzb2x2ZTtcbiAgICAgIHJlamVjdEFsbCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICB2YXIgdW5yZXNvbHZlZCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmICh1bnJlc29sdmVkID09PSAwKSB7XG4gICAgICByZXNvbHZlQWxsKHJlc3VsdHMpO1xuICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICBpZiAoZGVmZXJyZWQuX3N0YXR1cyA9PT0gU1RBVFVTX1JFSkVDVEVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIHJlamVjdEFsbChyZWFzb24pO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwcm9taXNlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xuICAgICAgdmFyIHJlc29sdmUgPSAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoZGVmZXJyZWQuX3N0YXR1cyA9PT0gU1RBVFVTX1JFSkVDVEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICB1bnJlc29sdmVkLS07XG4gICAgICAgICAgaWYgKHVucmVzb2x2ZWQgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmVBbGwocmVzdWx0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkoaSk7XG4gICAgICBpZiAoUHJvbWlzZS5pc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgbGlrZWx5IGEgcHJvbWlzZSAoaGFzIGEgJ3RoZW4nIGZ1bmN0aW9uKS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWx1ZSBpcyB0aGVuYWJsZVxuICAgKi9cbiAgUHJvbWlzZS5pc1Byb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlX2lzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyByZXNvbHZlZCBwcm9taXNlXG4gICAqIEBwYXJhbSB2YWx1ZSByZXNvbHZlIHZhbHVlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gUHJvbWlzZV9yZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyByZWplY3RlZCBwcm9taXNlXG4gICAqIEBwYXJhbSByZWFzb24gcmVqZWN0aW9uIHZhbHVlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiBQcm9taXNlX3JlamVjdChyZWFzb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyByZWplY3QocmVhc29uKTsgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgX3N0YXR1czogbnVsbCxcbiAgICBfdmFsdWU6IG51bGwsXG4gICAgX2hhbmRsZXJzOiBudWxsLFxuICAgIF91bmhhbmRsZWRSZWplY3Rpb246IG51bGwsXG5cbiAgICBfdXBkYXRlU3RhdHVzOiBmdW5jdGlvbiBQcm9taXNlX191cGRhdGVTdGF0dXMoc3RhdHVzLCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gU1RBVFVTX1JFU09MVkVEIHx8XG4gICAgICAgICAgdGhpcy5fc3RhdHVzID09PSBTVEFUVVNfUkVKRUNURUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdHVzID09PSBTVEFUVVNfUkVTT0xWRUQgJiZcbiAgICAgICAgICBQcm9taXNlLmlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUudGhlbih0aGlzLl91cGRhdGVTdGF0dXMuYmluZCh0aGlzLCBTVEFUVVNfUkVTT0xWRUQpLFxuICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXR1cy5iaW5kKHRoaXMsIFNUQVRVU19SRUpFQ1RFRCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0YXR1cyA9IHN0YXR1cztcbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVU19SRUpFQ1RFRCAmJiB0aGlzLl9oYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fdW5oYW5kbGVkUmVqZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgSGFuZGxlck1hbmFnZXIuYWRkVW5oYW5kbGVkUmVqZWN0aW9uKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBIYW5kbGVyTWFuYWdlci5zY2hlZHVsZUhhbmRsZXJzKHRoaXMpO1xuICAgIH0sXG5cbiAgICBfcmVzb2x2ZTogZnVuY3Rpb24gUHJvbWlzZV9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0dXMoU1RBVFVTX1JFU09MVkVELCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIF9yZWplY3Q6IGZ1bmN0aW9uIFByb21pc2VfcmVqZWN0KHJlYXNvbikge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKFNUQVRVU19SRUpFQ1RFRCwgcmVhc29uKTtcbiAgICB9LFxuXG4gICAgdGhlbjogZnVuY3Rpb24gUHJvbWlzZV90aGVuKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcbiAgICAgIHZhciBuZXh0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goe1xuICAgICAgICB0aGlzUHJvbWlzZTogdGhpcyxcbiAgICAgICAgb25SZXNvbHZlOiBvblJlc29sdmUsXG4gICAgICAgIG9uUmVqZWN0OiBvblJlamVjdCxcbiAgICAgICAgbmV4dFByb21pc2U6IG5leHRQcm9taXNlXG4gICAgICB9KTtcbiAgICAgIEhhbmRsZXJNYW5hZ2VyLnNjaGVkdWxlSGFuZGxlcnModGhpcyk7XG4gICAgICByZXR1cm4gbmV4dFByb21pc2U7XG4gICAgfSxcblxuICAgIGNhdGNoOiBmdW5jdGlvbiBQcm9taXNlX2NhdGNoKG9uUmVqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3QpO1xuICAgIH1cbiAgfTtcblxuICBnbG9iYWxTY29wZS5Qcm9taXNlID0gUHJvbWlzZTtcbi8vI2Vsc2Vcbi8vdGhyb3cgbmV3IEVycm9yKCdET00gUHJvbWlzZSBpcyBub3QgcHJlc2VudCcpO1xuLy8jZW5kaWZcbn0pKCk7XG5cbnZhciBTdGF0VGltZXIgPSAoZnVuY3Rpb24gU3RhdFRpbWVyQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gcnBhZChzdHIsIHBhZCwgbGVuZ3RoKSB7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIHN0ciArPSBwYWQ7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZnVuY3Rpb24gU3RhdFRpbWVyKCkge1xuICAgIHRoaXMuc3RhcnRlZCA9IHt9O1xuICAgIHRoaXMudGltZXMgPSBbXTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIFN0YXRUaW1lci5wcm90b3R5cGUgPSB7XG4gICAgdGltZTogZnVuY3Rpb24gU3RhdFRpbWVyX3RpbWUobmFtZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5zdGFydGVkKSB7XG4gICAgICAgIHdhcm4oJ1RpbWVyIGlzIGFscmVhZHkgcnVubmluZyBmb3IgJyArIG5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFydGVkW25hbWVdID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuICAgIHRpbWVFbmQ6IGZ1bmN0aW9uIFN0YXRUaW1lcl90aW1lRW5kKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghKG5hbWUgaW4gdGhpcy5zdGFydGVkKSkge1xuICAgICAgICB3YXJuKCdUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJyArIG5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy50aW1lcy5wdXNoKHtcbiAgICAgICAgJ25hbWUnOiBuYW1lLFxuICAgICAgICAnc3RhcnQnOiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICAgICdlbmQnOiBEYXRlLm5vdygpXG4gICAgICB9KTtcbiAgICAgIC8vIFJlbW92ZSB0aW1lciBmcm9tIHN0YXJ0ZWQgc28gaXQgY2FuIGJlIGNhbGxlZCBhZ2Fpbi5cbiAgICAgIGRlbGV0ZSB0aGlzLnN0YXJ0ZWRbbmFtZV07XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gU3RhdFRpbWVyX3RvU3RyaW5nKCkge1xuICAgICAgdmFyIGksIGlpO1xuICAgICAgdmFyIHRpbWVzID0gdGhpcy50aW1lcztcbiAgICAgIHZhciBvdXQgPSAnJztcbiAgICAgIC8vIEZpbmQgdGhlIGxvbmdlc3QgbmFtZSBmb3IgcGFkZGluZyBwdXJwb3Nlcy5cbiAgICAgIHZhciBsb25nZXN0ID0gMDtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gdGltZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRpbWVzW2ldWyduYW1lJ107XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA+IGxvbmdlc3QpIHtcbiAgICAgICAgICBsb25nZXN0ID0gbmFtZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gdGltZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgc3BhbiA9IHRpbWVzW2ldO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBzcGFuLmVuZCAtIHNwYW4uc3RhcnQ7XG4gICAgICAgIG91dCArPSBycGFkKHNwYW5bJ25hbWUnXSwgJyAnLCBsb25nZXN0KSArICcgJyArIGR1cmF0aW9uICsgJ21zXFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICB9O1xuICByZXR1cm4gU3RhdFRpbWVyO1xufSkoKTtcblxuUERGSlMuY3JlYXRlQmxvYiA9IGZ1bmN0aW9uIGNyZWF0ZUJsb2IoZGF0YSwgY29udGVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogY29udGVudFR5cGUgfSk7XG4gIH1cbiAgLy8gQmxvYiBidWlsZGVyIGlzIGRlcHJlY2F0ZWQgaW4gRkYxNCBhbmQgcmVtb3ZlZCBpbiBGRjE4LlxuICB2YXIgYmIgPSBuZXcgTW96QmxvYkJ1aWxkZXIoKTtcbiAgYmIuYXBwZW5kKGRhdGEpO1xuICByZXR1cm4gYmIuZ2V0QmxvYihjb250ZW50VHlwZSk7XG59O1xuXG5QREZKUy5jcmVhdGVPYmplY3RVUkwgPSAoZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMQ2xvc3VyZSgpIHtcbiAgLy8gQmxvYi9jcmVhdGVPYmplY3RVUkwgaXMgbm90IGF2YWlsYWJsZSwgZmFsbGluZyBiYWNrIHRvIGRhdGEgc2NoZW1hLlxuICB2YXIgZGlnaXRzID1cbiAgICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVPYmplY3RVUkwoZGF0YSwgY29udGVudFR5cGUpIHtcbiAgICBpZiAoIVBERkpTLmRpc2FibGVDcmVhdGVPYmplY3RVUkwgJiZcbiAgICAgICAgdHlwZW9mIFVSTCAhPT0gJ3VuZGVmaW5lZCcgJiYgVVJMLmNyZWF0ZU9iamVjdFVSTCkge1xuICAgICAgdmFyIGJsb2IgPSBQREZKUy5jcmVhdGVCbG9iKGRhdGEsIGNvbnRlbnRUeXBlKTtcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSAnZGF0YTonICsgY29udGVudFR5cGUgKyAnO2Jhc2U2NCwnO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGRhdGEubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgdmFyIGIxID0gZGF0YVtpXSAmIDB4RkY7XG4gICAgICB2YXIgYjIgPSBkYXRhW2kgKyAxXSAmIDB4RkY7XG4gICAgICB2YXIgYjMgPSBkYXRhW2kgKyAyXSAmIDB4RkY7XG4gICAgICB2YXIgZDEgPSBiMSA+PiAyLCBkMiA9ICgoYjEgJiAzKSA8PCA0KSB8IChiMiA+PiA0KTtcbiAgICAgIHZhciBkMyA9IGkgKyAxIDwgaWkgPyAoKGIyICYgMHhGKSA8PCAyKSB8IChiMyA+PiA2KSA6IDY0O1xuICAgICAgdmFyIGQ0ID0gaSArIDIgPCBpaSA/IChiMyAmIDB4M0YpIDogNjQ7XG4gICAgICBidWZmZXIgKz0gZGlnaXRzW2QxXSArIGRpZ2l0c1tkMl0gKyBkaWdpdHNbZDNdICsgZGlnaXRzW2Q0XTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIE1lc3NhZ2VIYW5kbGVyKG5hbWUsIGNvbU9iaikge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgdGhpcy5jYWxsYmFja0luZGV4ID0gMTtcbiAgdGhpcy5wb3N0TWVzc2FnZVRyYW5zZmVycyA9IHRydWU7XG4gIHZhciBjYWxsYmFja3NDYXBhYmlsaXRpZXMgPSB0aGlzLmNhbGxiYWNrc0NhcGFiaWxpdGllcyA9IHt9O1xuICB2YXIgYWggPSB0aGlzLmFjdGlvbkhhbmRsZXIgPSB7fTtcblxuICBhaFsnY29uc29sZV9sb2cnXSA9IFtmdW5jdGlvbiBhaENvbnNvbGVMb2coZGF0YSkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGRhdGEpO1xuICB9XTtcbiAgYWhbJ2NvbnNvbGVfZXJyb3InXSA9IFtmdW5jdGlvbiBhaENvbnNvbGVFcnJvcihkYXRhKSB7XG4gICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBkYXRhKTtcbiAgfV07XG4gIGFoWydfdW5zdXBwb3J0ZWRfZmVhdHVyZSddID0gW2Z1bmN0aW9uIGFoX3Vuc3VwcG9ydGVkRmVhdHVyZShkYXRhKSB7XG4gICAgVW5zdXBwb3J0ZWRNYW5hZ2VyLm5vdGlmeShkYXRhKTtcbiAgfV07XG5cbiAgY29tT2JqLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIG1lc3NhZ2VIYW5kbGVyQ29tT2JqT25NZXNzYWdlKGV2ZW50KSB7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgIGlmIChkYXRhLmlzUmVwbHkpIHtcbiAgICAgIHZhciBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgaWYgKGRhdGEuY2FsbGJhY2tJZCBpbiBjYWxsYmFja3NDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgICBkZWxldGUgY2FsbGJhY2tzQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiBkYXRhKSB7XG4gICAgICAgICAgY2FsbGJhY2sucmVqZWN0KGRhdGEuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCByZXNvbHZlIGNhbGxiYWNrICcgKyBjYWxsYmFja0lkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uIGluIGFoKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWhbZGF0YS5hY3Rpb25dO1xuICAgICAgaWYgKGRhdGEuY2FsbGJhY2tJZCkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uWzBdLmNhbGwoYWN0aW9uWzFdLCBkYXRhLmRhdGEpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaXNSZXBseTogdHJ1ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlzUmVwbHk6IHRydWUsXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICBlcnJvcjogcmVhc29uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uWzBdLmNhbGwoYWN0aW9uWzFdLCBkYXRhLmRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICcgKyBkYXRhLmFjdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG5NZXNzYWdlSGFuZGxlci5wcm90b3R5cGUgPSB7XG4gIG9uOiBmdW5jdGlvbiBtZXNzYWdlSGFuZGxlck9uKGFjdGlvbk5hbWUsIGhhbmRsZXIsIHNjb3BlKSB7XG4gICAgdmFyIGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICAgIGlmIChhaFthY3Rpb25OYW1lXSkge1xuICAgICAgZXJyb3IoJ1RoZXJlIGlzIGFscmVhZHkgYW4gYWN0aW9uTmFtZSBjYWxsZWQgXCInICsgYWN0aW9uTmFtZSArICdcIicpO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IFtoYW5kbGVyLCBzY29wZV07XG4gIH0sXG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIGNvbU9iaiB0byBpbnZva2UgdGhlIGFjdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBkYXRhLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uTmFtZSBBY3Rpb24gdG8gY2FsbC5cbiAgICogQHBhcmFtIHtKU09OfSBkYXRhIEpTT04gZGF0YSB0byBzZW5kLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmZXJzXSBPcHRpb25hbCBsaXN0IG9mIHRyYW5zZmVycy9BcnJheUJ1ZmZlcnNcbiAgICovXG4gIHNlbmQ6IGZ1bmN0aW9uIG1lc3NhZ2VIYW5kbGVyU2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9O1xuICAgIHRoaXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgY29tT2JqIHRvIGludm9rZSB0aGUgYWN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGRhdGEuXG4gICAqIEV4cGVjdHMgdGhhdCBvdGhlciBzaWRlIHdpbGwgY2FsbGJhY2sgd2l0aCB0aGUgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25OYW1lIEFjdGlvbiB0byBjYWxsLlxuICAgKiBAcGFyYW0ge0pTT059IGRhdGEgSlNPTiBkYXRhIHRvIHNlbmQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2ZlcnNdIE9wdGlvbmFsIGxpc3Qgb2YgdHJhbnNmZXJzL0FycmF5QnVmZmVycy5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2l0aCByZXNwb25zZSBkYXRhLlxuICAgKi9cbiAgc2VuZFdpdGhQcm9taXNlOlxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VIYW5kbGVyU2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIHZhciBjYWxsYmFja0lkID0gdGhpcy5jYWxsYmFja0luZGV4Kys7XG4gICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgY2FsbGJhY2tJZDogY2FsbGJhY2tJZFxuICAgIH07XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBjcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuY2FsbGJhY2tzQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhcGFiaWxpdHkucmVqZWN0KGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvKipcbiAgICogU2VuZHMgcmF3IG1lc3NhZ2UgdG8gdGhlIGNvbU9iai5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIG1lc3NhZ2Uge09iamVjdH0gUmF3IG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB0cmFuc2ZlcnMgTGlzdCBvZiB0cmFuc2ZlcnMvQXJyYXlCdWZmZXJzLCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gKG1lc3NhZ2UsIHRyYW5zZmVycykge1xuICAgIGlmICh0cmFuc2ZlcnMgJiYgdGhpcy5wb3N0TWVzc2FnZVRyYW5zZmVycykge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSnB4SW1hZ2U7XG59XG5cbmZ1bmN0aW9uIGxvYWRKcGVnU3RyZWFtKGlkLCBpbWFnZVVybCwgb2Jqcykge1xuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gIGltZy5vbmxvYWQgPSAoZnVuY3Rpb24gbG9hZEpwZWdTdHJlYW1fb25sb2FkQ2xvc3VyZSgpIHtcbiAgICBvYmpzLnJlc29sdmUoaWQsIGltZyk7XG4gIH0pO1xuICBpbWcub25lcnJvciA9IChmdW5jdGlvbiBsb2FkSnBlZ1N0cmVhbV9vbmVycm9yQ2xvc3VyZSgpIHtcbiAgICBvYmpzLnJlc29sdmUoaWQsIG51bGwpO1xuICAgIHdhcm4oJ0Vycm9yIGR1cmluZyBKUEVHIGltYWdlIGxvYWRpbmcnKTtcbiAgfSk7XG4gIGltZy5zcmMgPSBpbWFnZVVybDtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBkb2Vzbid0IHdvcnRoIHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25hIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgIGNhc2UgSEVBRDpcbiAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuXG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICBiaXRzIC09IDQ7XG4gICAgICAvLy0tLS8vXG4gICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIEZMQUdTOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUSU1FOlxuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgIC8vPT09XG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE9TOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYTEVOOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWFRSQTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVuZCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE5BTUU6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPTU1FTlQ6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgSENSQzpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUNUSUQ6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJQ1Q6XG4gICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRTpcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRZUEVETzpcbiAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gMTtcbiAgICAgIGJpdHMgLT0gMTtcbiAgICAgIC8vLS0tLy9cblxuICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgYml0cyAtPSAyO1xuICAgICAgLy8tLS0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTVE9SRUQ6XG4gICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAvLy0tLS8vXG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZXzpcbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09QWTpcbiAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBpZiAoY29weSkge1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFRBQkxFOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuLy8jZW5kaWZcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5fOlxuICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTjpcbiAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgIC8vLS0tXG5cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVDpcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1RFWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE1BVENIOlxuICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgfVxuICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICBkbyB7XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMSVQ6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBsZWZ0LS07XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDSEVDSzpcbiAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAvLyBVc2UgJ3wnIGluc2RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgfVxuICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOR1RIOlxuICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRE9ORTpcbiAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIEJBRDpcbiAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIE1FTTpcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICBjYXNlIFNZTkM6XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc2RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsInZhciBtc2cgPSByZXF1aXJlKCdwYWtvL2xpYi96bGliL21lc3NhZ2VzJyk7XG52YXIgenN0cmVhbSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvenN0cmVhbScpO1xudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcycpO1xudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbmZvciAodmFyIGtleSBpbiBjb25zdGFudHMpIHtcbiAgZXhwb3J0c1trZXldID0gY29uc3RhbnRzW2tleV07XG59XG5cbi8vIHpsaWIgbW9kZXNcbmV4cG9ydHMuTk9ORSA9IDA7XG5leHBvcnRzLkRFRkxBVEUgPSAxO1xuZXhwb3J0cy5JTkZMQVRFID0gMjtcbmV4cG9ydHMuR1pJUCA9IDM7XG5leHBvcnRzLkdVTlpJUCA9IDQ7XG5leHBvcnRzLkRFRkxBVEVSQVcgPSA1O1xuZXhwb3J0cy5JTkZMQVRFUkFXID0gNjtcbmV4cG9ydHMuVU5aSVAgPSA3O1xuXG4vKipcbiAqIEVtdWxhdGUgTm9kZSdzIHpsaWIgQysrIGxheWVyIGZvciB1c2UgYnkgdGhlIEpTIGxheWVyIGluIGluZGV4LmpzXG4gKi9cbmZ1bmN0aW9uIFpsaWIobW9kZSkge1xuICBpZiAobW9kZSA8IGV4cG9ydHMuREVGTEFURSB8fCBtb2RlID4gZXhwb3J0cy5VTlpJUClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQmFkIGFyZ3VtZW50XCIpO1xuICAgIFxuICB0aGlzLm1vZGUgPSBtb2RlO1xuICB0aGlzLmluaXRfZG9uZSA9IGZhbHNlO1xuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuICB0aGlzLndpbmRvd0JpdHMgPSAwO1xuICB0aGlzLmxldmVsID0gMDtcbiAgdGhpcy5tZW1MZXZlbCA9IDA7XG4gIHRoaXMuc3RyYXRlZ3kgPSAwO1xuICB0aGlzLmRpY3Rpb25hcnkgPSBudWxsO1xufVxuXG5abGliLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24od2luZG93Qml0cywgbGV2ZWwsIG1lbUxldmVsLCBzdHJhdGVneSwgZGljdGlvbmFyeSkge1xuICB0aGlzLndpbmRvd0JpdHMgPSB3aW5kb3dCaXRzO1xuICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gIHRoaXMubWVtTGV2ZWwgPSBtZW1MZXZlbDtcbiAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAvLyBkaWN0aW9uYXJ5IG5vdCBzdXBwb3J0ZWQuXG4gIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLkdaSVAgfHwgdGhpcy5tb2RlID09PSBleHBvcnRzLkdVTlpJUClcbiAgICB0aGlzLndpbmRvd0JpdHMgKz0gMTY7XG4gICAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuVU5aSVApXG4gICAgdGhpcy53aW5kb3dCaXRzICs9IDMyO1xuICAgIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLkRFRkxBVEVSQVcgfHwgdGhpcy5tb2RlID09PSBleHBvcnRzLklORkxBVEVSQVcpXG4gICAgdGhpcy53aW5kb3dCaXRzID0gLXRoaXMud2luZG93Qml0cztcbiAgICBcbiAgdGhpcy5zdHJtID0gbmV3IHpzdHJlYW0oKTtcbiAgXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdaSVA6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICAgICAgdGhpcy5zdHJtLFxuICAgICAgICB0aGlzLmxldmVsLFxuICAgICAgICBleHBvcnRzLlpfREVGTEFURUQsXG4gICAgICAgIHRoaXMud2luZG93Qml0cyxcbiAgICAgICAgdGhpcy5tZW1MZXZlbCxcbiAgICAgICAgdGhpcy5zdHJhdGVneVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HVU5aSVA6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEVSQVc6XG4gICAgY2FzZSBleHBvcnRzLlVOWklQOlxuICAgICAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgICAgICB0aGlzLnN0cm0sXG4gICAgICAgIHRoaXMud2luZG93Qml0c1xuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vZGUgXCIgKyB0aGlzLm1vZGUpO1xuICB9XG4gIFxuICBpZiAoc3RhdHVzICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcihzdGF0dXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICB0aGlzLmluaXRfZG9uZSA9IHRydWU7XG59O1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiZGVmbGF0ZVBhcmFtcyBOb3Qgc3VwcG9ydGVkXCIpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3dyaXRlQ2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmluaXRfZG9uZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZSBiZWZvcmUgaW5pdFwiKTtcbiAgICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5OT05FKVxuICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxpemVkXCIpO1xuICAgIFxuICBpZiAodGhpcy53cml0ZV9pbl9wcm9ncmVzcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZSBhbHJlYWR5IGluIHByb2dyZXNzXCIpO1xuICAgIFxuICBpZiAodGhpcy5wZW5kaW5nX2Nsb3NlKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNsb3NlIGlzIHBlbmRpbmdcIik7XG59O1xuXG5abGliLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikgeyAgICBcbiAgdGhpcy5fd3JpdGVDaGVjaygpO1xuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gdHJ1ZTtcbiAgXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gICAgdmFyIHJlcyA9IHNlbGYuX3dyaXRlKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbik7XG4gICAgc2VsZi5jYWxsYmFjayhyZXNbMF0sIHJlc1sxXSk7XG4gICAgXG4gICAgaWYgKHNlbGYucGVuZGluZ19jbG9zZSlcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG4gIFxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCBtZXRob2QgZm9yIE5vZGUgYnVmZmVycywgdXNlZCBieSBwYWtvXG5mdW5jdGlvbiBidWZmZXJTZXQoZGF0YSwgb2Zmc2V0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBkYXRhW2ldO1xuICB9XG59XG5cblpsaWIucHJvdG90eXBlLndyaXRlU3luYyA9IGZ1bmN0aW9uKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikge1xuICB0aGlzLl93cml0ZUNoZWNrKCk7XG4gIHJldHVybiB0aGlzLl93cml0ZShmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuICBcbiAgaWYgKGZsdXNoICE9PSBleHBvcnRzLlpfTk9fRkxVU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfUEFSVElBTF9GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9TWU5DX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX0ZVTExfRkxVU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfRklOSVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX0JMT0NLKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBmbHVzaCB2YWx1ZVwiKTtcbiAgfVxuICBcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICBpbnB1dCA9IG5ldyBCdWZmZXIoMCk7XG4gICAgaW5fbGVuID0gMDtcbiAgICBpbl9vZmYgPSAwO1xuICB9XG4gIFxuICBpZiAob3V0Ll9zZXQpXG4gICAgb3V0LnNldCA9IG91dC5fc2V0O1xuICBlbHNlXG4gICAgb3V0LnNldCA9IGJ1ZmZlclNldDtcbiAgXG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICBzdHJtLmF2YWlsX2luID0gaW5fbGVuO1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0ubmV4dF9pbiA9IGluX29mZjtcbiAgc3RybS5hdmFpbF9vdXQgPSBvdXRfbGVuO1xuICBzdHJtLm91dHB1dCA9IG91dDtcbiAgc3RybS5uZXh0X291dCA9IG91dF9vZmY7XG4gIFxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIGZsdXNoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5VTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGZsdXNoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vZGUgXCIgKyB0aGlzLm1vZGUpO1xuICB9XG4gIFxuICBpZiAoc3RhdHVzICE9PSBleHBvcnRzLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKHN0YXR1cyk7XG4gIH1cbiAgXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgcmV0dXJuIFtzdHJtLmF2YWlsX2luLCBzdHJtLmF2YWlsX291dF07XG59O1xuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy53cml0ZV9pbl9wcm9ncmVzcykge1xuICAgIHRoaXMucGVuZGluZ19jbG9zZSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICB0aGlzLnBlbmRpbmdfY2xvc2UgPSBmYWxzZTtcbiAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURSB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1pJUCB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURVJBVykge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gIH0gZWxzZSB7XG4gICAgemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfVxuICBcbiAgdGhpcy5tb2RlID0gZXhwb3J0cy5OT05FO1xufTtcblxuWmxpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgaWYgKHN0YXR1cyAhPT0gZXhwb3J0cy5aX09LKSB7XG4gICAgdGhpcy5fZXJyb3Ioc3RhdHVzKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gIHRoaXMub25lcnJvcihtc2dbc3RhdHVzXSArICc6ICcgKyB0aGlzLnN0cm0ubXNnLCBzdGF0dXMpO1xuICBcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICBpZiAodGhpcy5wZW5kaW5nX2Nsb3NlKVxuICAgIHRoaXMuY2xvc2UoKTtcbn07XG5cbmV4cG9ydHMuWmxpYiA9IFpsaWI7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnZhciBiaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKS5vaztcblxuLy8gemxpYiBkb2Vzbid0IHByb3ZpZGUgdGhlc2UsIHNvIGtsdWRnZSB0aGVtIGluIGZvbGxvd2luZyB0aGUgc2FtZVxuLy8gY29uc3QgbmFtaW5nIHNjaGVtZSB6bGliIHVzZXMuXG5iaW5kaW5nLlpfTUlOX1dJTkRPV0JJVFMgPSA4O1xuYmluZGluZy5aX01BWF9XSU5ET1dCSVRTID0gMTU7XG5iaW5kaW5nLlpfREVGQVVMVF9XSU5ET1dCSVRTID0gMTU7XG5cbi8vIGZld2VyIHRoYW4gNjQgYnl0ZXMgcGVyIGNodW5rIGlzIHN0dXBpZC5cbi8vIHRlY2huaWNhbGx5IGl0IGNvdWxkIHdvcmsgd2l0aCBhcyBmZXcgYXMgOCwgYnV0IGV2ZW4gNjQgYnl0ZXNcbi8vIGlzIGFic3VyZGx5IGxvdy4gIFVzdWFsbHkgYSBNQiBvciBtb3JlIGlzIGJlc3QuXG5iaW5kaW5nLlpfTUlOX0NIVU5LID0gNjQ7XG5iaW5kaW5nLlpfTUFYX0NIVU5LID0gSW5maW5pdHk7XG5iaW5kaW5nLlpfREVGQVVMVF9DSFVOSyA9ICgxNiAqIDEwMjQpO1xuXG5iaW5kaW5nLlpfTUlOX01FTUxFVkVMID0gMTtcbmJpbmRpbmcuWl9NQVhfTUVNTEVWRUwgPSA5O1xuYmluZGluZy5aX0RFRkFVTFRfTUVNTEVWRUwgPSA4O1xuXG5iaW5kaW5nLlpfTUlOX0xFVkVMID0gLTE7XG5iaW5kaW5nLlpfTUFYX0xFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX0xFVkVMID0gYmluZGluZy5aX0RFRkFVTFRfQ09NUFJFU1NJT047XG5cbi8vIGV4cG9zZSBhbGwgdGhlIHpsaWIgY29uc3RhbnRzXG5PYmplY3Qua2V5cyhiaW5kaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgaWYgKGsubWF0Y2goL15aLykpIGV4cG9ydHNba10gPSBiaW5kaW5nW2tdO1xufSk7XG5cbi8vIHRyYW5zbGF0aW9uIHRhYmxlIGZvciByZXR1cm4gY29kZXMuXG5leHBvcnRzLmNvZGVzID0ge1xuICBaX09LOiBiaW5kaW5nLlpfT0ssXG4gIFpfU1RSRUFNX0VORDogYmluZGluZy5aX1NUUkVBTV9FTkQsXG4gIFpfTkVFRF9ESUNUOiBiaW5kaW5nLlpfTkVFRF9ESUNULFxuICBaX0VSUk5POiBiaW5kaW5nLlpfRVJSTk8sXG4gIFpfU1RSRUFNX0VSUk9SOiBiaW5kaW5nLlpfU1RSRUFNX0VSUk9SLFxuICBaX0RBVEFfRVJST1I6IGJpbmRpbmcuWl9EQVRBX0VSUk9SLFxuICBaX01FTV9FUlJPUjogYmluZGluZy5aX01FTV9FUlJPUixcbiAgWl9CVUZfRVJST1I6IGJpbmRpbmcuWl9CVUZfRVJST1IsXG4gIFpfVkVSU0lPTl9FUlJPUjogYmluZGluZy5aX1ZFUlNJT05fRVJST1Jcbn07XG5cbk9iamVjdC5rZXlzKGV4cG9ydHMuY29kZXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBleHBvcnRzLmNvZGVzW2V4cG9ydHMuY29kZXNba11dID0gaztcbn0pO1xuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuR3ppcCA9IEd6aXA7XG5leHBvcnRzLkd1bnppcCA9IEd1bnppcDtcbmV4cG9ydHMuRGVmbGF0ZVJhdyA9IERlZmxhdGVSYXc7XG5leHBvcnRzLkluZmxhdGVSYXcgPSBJbmZsYXRlUmF3O1xuZXhwb3J0cy5VbnppcCA9IFVuemlwO1xuXG5leHBvcnRzLmNyZWF0ZURlZmxhdGUgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBJbmZsYXRlKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVEZWZsYXRlUmF3ID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IERlZmxhdGVSYXcobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUluZmxhdGVSYXcgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3ppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBHemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVHdW56aXAgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgR3VuemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVVbnppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBVbnppcChvKTtcbn07XG5cblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kcy5cbi8vIGNvbXByZXNzL2RlY29tcHJlc3MgYSBzdHJpbmcgb3IgYnVmZmVyIGluIG9uZSBzdGVwLlxuZXhwb3J0cy5kZWZsYXRlID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5nemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHemlwKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZ3ppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBHemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy51bnppcCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgVW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy51bnppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuZ3VuemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5ndW56aXBTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgR3VuemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3ID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZnVuY3Rpb24gemxpYkJ1ZmZlcihlbmdpbmUsIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIG5yZWFkID0gMDtcblxuICBlbmdpbmUub24oJ2Vycm9yJywgb25FcnJvcik7XG4gIGVuZ2luZS5vbignZW5kJywgb25FbmQpO1xuXG4gIGVuZ2luZS5lbmQoYnVmZmVyKTtcbiAgZmxvdygpO1xuXG4gIGZ1bmN0aW9uIGZsb3coKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIHdoaWxlIChudWxsICE9PSAoY2h1bmsgPSBlbmdpbmUucmVhZCgpKSkge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgZW5naW5lLm9uY2UoJ3JlYWRhYmxlJywgZmxvdyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBmbG93KTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICBjYWxsYmFjayhudWxsLCBidWYpO1xuICAgIGVuZ2luZS5jbG9zZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXJTeW5jKGVuZ2luZSwgYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgc3RyaW5nIG9yIGJ1ZmZlcicpO1xuXG4gIHZhciBmbHVzaEZsYWcgPSBiaW5kaW5nLlpfRklOSVNIO1xuXG4gIHJldHVybiBlbmdpbmUuX3Byb2Nlc3NDaHVuayhidWZmZXIsIGZsdXNoRmxhZyk7XG59XG5cbi8vIGdlbmVyaWMgemxpYlxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEUpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEUpO1xufVxuXG5cblxuLy8gZ3ppcCAtIGJpZ2dlciBoZWFkZXIsIHNhbWUgZGVmbGF0ZSBjb21wcmVzc2lvblxuZnVuY3Rpb24gR3ppcChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHemlwKSkgcmV0dXJuIG5ldyBHemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HWklQKTtcbn1cblxuZnVuY3Rpb24gR3VuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd1bnppcCkpIHJldHVybiBuZXcgR3VuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HVU5aSVApO1xufVxuXG5cblxuLy8gcmF3IC0gbm8gaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlUmF3KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGVSYXcpKSByZXR1cm4gbmV3IERlZmxhdGVSYXcob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEVSQVcpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlUmF3KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGVSYXcpKSByZXR1cm4gbmV3IEluZmxhdGVSYXcob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEVSQVcpO1xufVxuXG5cbi8vIGF1dG8tZGV0ZWN0IGhlYWRlci5cbmZ1bmN0aW9uIFVuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVuemlwKSkgcmV0dXJuIG5ldyBVbnppcChvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuVU5aSVApO1xufVxuXG5cbi8vIHRoZSBabGliIGNsYXNzIHRoZXkgYWxsIGluaGVyaXQgZnJvbVxuLy8gVGhpcyB0aGluZyBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiByZXF1ZXN0cywgYW5kIHJldHVybnNcbi8vIHRydWUgb3IgZmFsc2UgaWYgdGhlcmUgaXMgYW55dGhpbmcgaW4gdGhlIHF1ZXVlIHdoZW5cbi8vIHlvdSBjYWxsIHRoZSAud3JpdGUoKSBtZXRob2QuXG5cbmZ1bmN0aW9uIFpsaWIob3B0cywgbW9kZSkge1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX2NodW5rU2l6ZSA9IG9wdHMuY2h1bmtTaXplIHx8IGV4cG9ydHMuWl9ERUZBVUxUX0NIVU5LO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChvcHRzLmZsdXNoKSB7XG4gICAgaWYgKG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9OT19GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfUEFSVElBTF9GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfU1lOQ19GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfRlVMTF9GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfRklOSVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9CTE9DSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZsdXNoIGZsYWc6ICcgKyBvcHRzLmZsdXNoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fZmx1c2hGbGFnID0gb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG5cbiAgaWYgKG9wdHMuY2h1bmtTaXplKSB7XG4gICAgaWYgKG9wdHMuY2h1bmtTaXplIDwgZXhwb3J0cy5aX01JTl9DSFVOSyB8fFxuICAgICAgICBvcHRzLmNodW5rU2l6ZSA+IGV4cG9ydHMuWl9NQVhfQ0hVTkspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaHVuayBzaXplOiAnICsgb3B0cy5jaHVua1NpemUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLndpbmRvd0JpdHMpIHtcbiAgICBpZiAob3B0cy53aW5kb3dCaXRzIDwgZXhwb3J0cy5aX01JTl9XSU5ET1dCSVRTIHx8XG4gICAgICAgIG9wdHMud2luZG93Qml0cyA+IGV4cG9ydHMuWl9NQVhfV0lORE9XQklUUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdpbmRvd0JpdHM6ICcgKyBvcHRzLndpbmRvd0JpdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmxldmVsKSB7XG4gICAgaWYgKG9wdHMubGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8XG4gICAgICAgIG9wdHMubGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBvcHRzLmxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tZW1MZXZlbCkge1xuICAgIGlmIChvcHRzLm1lbUxldmVsIDwgZXhwb3J0cy5aX01JTl9NRU1MRVZFTCB8fFxuICAgICAgICBvcHRzLm1lbUxldmVsID4gZXhwb3J0cy5aX01BWF9NRU1MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lbUxldmVsOiAnICsgb3B0cy5tZW1MZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyYXRlZ3kpIHtcbiAgICBpZiAob3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBvcHRzLnN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kaWN0aW9uYXJ5KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0cy5kaWN0aW9uYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpY3Rpb25hcnk6IGl0IHNob3VsZCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2JpbmRpbmcgPSBuZXcgYmluZGluZy5abGliKG1vZGUpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5faGFkRXJyb3IgPSBmYWxzZTtcbiAgdGhpcy5fYmluZGluZy5vbmVycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgZXJybm8pIHtcbiAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2xlYW5seSByZWNvdmVyLlxuICAgIC8vIGNvbnRpbnVpbmcgb25seSBvYnNjdXJlcyBwcm9ibGVtcy5cbiAgICBzZWxmLl9iaW5kaW5nID0gbnVsbDtcbiAgICBzZWxmLl9oYWRFcnJvciA9IHRydWU7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgICBlcnJvci5jb2RlID0gZXhwb3J0cy5jb2Rlc1tlcnJub107XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfTtcblxuICB2YXIgbGV2ZWwgPSBleHBvcnRzLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgaWYgKHR5cGVvZiBvcHRzLmxldmVsID09PSAnbnVtYmVyJykgbGV2ZWwgPSBvcHRzLmxldmVsO1xuXG4gIHZhciBzdHJhdGVneSA9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZO1xuICBpZiAodHlwZW9mIG9wdHMuc3RyYXRlZ3kgPT09ICdudW1iZXInKSBzdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3k7XG5cbiAgdGhpcy5fYmluZGluZy5pbml0KG9wdHMud2luZG93Qml0cyB8fCBleHBvcnRzLlpfREVGQVVMVF9XSU5ET1dCSVRTLFxuICAgICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLm1lbUxldmVsIHx8IGV4cG9ydHMuWl9ERUZBVUxUX01FTUxFVkVMLFxuICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLmRpY3Rpb25hcnkpO1xuXG4gIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5fY2h1bmtTaXplKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCB0aGlzLmNsb3NlKTtcbn1cblxudXRpbC5pbmhlcml0cyhabGliLCBUcmFuc2Zvcm0pO1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3ksIGNhbGxiYWNrKSB7XG4gIGlmIChsZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHxcbiAgICAgIGxldmVsID4gZXhwb3J0cy5aX01BWF9MRVZFTCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsOiAnICsgbGV2ZWwpO1xuICB9XG4gIGlmIChzdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9IVUZGTUFOX09OTFkgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1kpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0cmF0ZWd5OiAnICsgc3RyYXRlZ3kpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xldmVsICE9PSBsZXZlbCB8fCB0aGlzLl9zdHJhdGVneSAhPT0gc3RyYXRlZ3kpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mbHVzaChiaW5kaW5nLlpfU1lOQ19GTFVTSCwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9iaW5kaW5nLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpO1xuICAgICAgaWYgKCFzZWxmLl9oYWRFcnJvcikge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICBzZWxmLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9iaW5kaW5nLnJlc2V0KCk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBfZmx1c2ggZnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSB0cmFuc2Zvcm0gY2xhc3MsXG4vLyBpbnRlcm5hbGx5LCB3aGVuIHRoZSBsYXN0IGNodW5rIGhhcyBiZWVuIHdyaXR0ZW4uXG5abGliLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLl90cmFuc2Zvcm0obmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbn07XG5cblpsaWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oa2luZCwgY2FsbGJhY2spIHtcbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGtpbmQgPT09ICdmdW5jdGlvbicgfHwgKGtpbmQgPT09IHZvaWQgMCAmJiAhY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBraW5kO1xuICAgIGtpbmQgPSBiaW5kaW5nLlpfRlVMTF9GTFVTSDtcbiAgfVxuXG4gIGlmICh3cy5lbmRlZCkge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLmVuZGluZykge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHRoaXMub25jZSgnZW5kJywgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLm5lZWREcmFpbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZsdXNoKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9mbHVzaEZsYWcgPSBraW5kO1xuICAgIHRoaXMud3JpdGUobmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG5cbiAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuICB0aGlzLl9iaW5kaW5nLmNsb3NlKCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5abGliLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgZmx1c2hGbGFnO1xuICB2YXIgd3MgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgZW5kaW5nID0gd3MuZW5kaW5nIHx8IHdzLmVuZGVkO1xuICB2YXIgbGFzdCA9IGVuZGluZyAmJiAoIWNodW5rIHx8IHdzLmxlbmd0aCA9PT0gY2h1bmsubGVuZ3RoKTtcblxuICBpZiAoIWNodW5rID09PSBudWxsICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQnKSk7XG5cbiAgLy8gSWYgaXQncyB0aGUgbGFzdCBjaHVuaywgb3IgYSBmaW5hbCBmbHVzaCwgd2UgdXNlIHRoZSBaX0ZJTklTSCBmbHVzaCBmbGFnLlxuICAvLyBJZiBpdCdzIGV4cGxpY2l0bHkgZmx1c2hpbmcgYXQgc29tZSBvdGhlciB0aW1lLCB0aGVuIHdlIHVzZVxuICAvLyBaX0ZVTExfRkxVU0guIE90aGVyd2lzZSwgdXNlIFpfTk9fRkxVU0ggZm9yIG1heGltdW0gY29tcHJlc3Npb25cbiAgLy8gZ29vZG5lc3MuXG4gIGlmIChsYXN0KVxuICAgIGZsdXNoRmxhZyA9IGJpbmRpbmcuWl9GSU5JU0g7XG4gIGVsc2Uge1xuICAgIGZsdXNoRmxhZyA9IHRoaXMuX2ZsdXNoRmxhZztcbiAgICAvLyBvbmNlIHdlJ3ZlIGZsdXNoZWQgdGhlIGxhc3Qgb2YgdGhlIHF1ZXVlLCBzdG9wIGZsdXNoaW5nIGFuZFxuICAgIC8vIGdvIGJhY2sgdG8gdGhlIG5vcm1hbCBiZWhhdmlvci5cbiAgICBpZiAoY2h1bmsubGVuZ3RoID49IHdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZmx1c2hGbGFnID0gdGhpcy5fb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZywgY2IpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3Byb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGNodW5rLCBmbHVzaEZsYWcsIGNiKSB7XG4gIHZhciBhdmFpbEluQmVmb3JlID0gY2h1bmsgJiYgY2h1bmsubGVuZ3RoO1xuICB2YXIgYXZhaWxPdXRCZWZvcmUgPSB0aGlzLl9jaHVua1NpemUgLSB0aGlzLl9vZmZzZXQ7XG4gIHZhciBpbk9mZiA9IDA7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBhc3luYyA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAoIWFzeW5jKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICB2YXIgbnJlYWQgPSAwO1xuXG4gICAgdmFyIGVycm9yO1xuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oZXIpIHtcbiAgICAgIGVycm9yID0gZXI7XG4gICAgfSk7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5fYmluZGluZy53cml0ZVN5bmMoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLCAvLyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIsIC8vIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG4gICAgfSB3aGlsZSAoIXRoaXMuX2hhZEVycm9yICYmIGNhbGxiYWNrKHJlc1swXSwgcmVzWzFdKSk7XG5cbiAgICBpZiAodGhpcy5faGFkRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgdmFyIHJlcSA9IHRoaXMuX2JpbmRpbmcud3JpdGUoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuaywgLy8gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsIC8vIGluX29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0LCAvL291dF9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG5cbiAgcmVxLmJ1ZmZlciA9IGNodW5rO1xuICByZXEuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBmdW5jdGlvbiBjYWxsYmFjayhhdmFpbEluQWZ0ZXIsIGF2YWlsT3V0QWZ0ZXIpIHtcbiAgICBpZiAoc2VsZi5faGFkRXJyb3IpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgaGF2ZSA9IGF2YWlsT3V0QmVmb3JlIC0gYXZhaWxPdXRBZnRlcjtcbiAgICBhc3NlcnQoaGF2ZSA+PSAwLCAnaGF2ZSBzaG91bGQgbm90IGdvIGRvd24nKTtcblxuICAgIGlmIChoYXZlID4gMCkge1xuICAgICAgdmFyIG91dCA9IHNlbGYuX2J1ZmZlci5zbGljZShzZWxmLl9vZmZzZXQsIHNlbGYuX29mZnNldCArIGhhdmUpO1xuICAgICAgc2VsZi5fb2Zmc2V0ICs9IGhhdmU7XG4gICAgICAvLyBzZXJ2ZSBzb21lIG91dHB1dCB0byB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgc2VsZi5wdXNoKG91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzLnB1c2gob3V0KTtcbiAgICAgICAgbnJlYWQgKz0gb3V0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBleGhhdXN0ZWQgdGhlIG91dHB1dCBidWZmZXIsIG9yIHVzZWQgYWxsIHRoZSBpbnB1dCBjcmVhdGUgYSBuZXcgb25lLlxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwIHx8IHNlbGYuX29mZnNldCA+PSBzZWxmLl9jaHVua1NpemUpIHtcbiAgICAgIGF2YWlsT3V0QmVmb3JlID0gc2VsZi5fY2h1bmtTaXplO1xuICAgICAgc2VsZi5fb2Zmc2V0ID0gMDtcbiAgICAgIHNlbGYuX2J1ZmZlciA9IG5ldyBCdWZmZXIoc2VsZi5fY2h1bmtTaXplKTtcbiAgICB9XG5cbiAgICBpZiAoYXZhaWxPdXRBZnRlciA9PT0gMCkge1xuICAgICAgLy8gTm90IGFjdHVhbGx5IGRvbmUuICBOZWVkIHRvIHJlcHJvY2Vzcy5cbiAgICAgIC8vIEFsc28sIHVwZGF0ZSB0aGUgYXZhaWxJbkJlZm9yZSB0byB0aGUgYXZhaWxJbkFmdGVyIHZhbHVlLFxuICAgICAgLy8gc28gdGhhdCBpZiB3ZSBoYXZlIHRvIGhpdCBpdCBhIHRoaXJkIChmb3VydGgsIGV0Yy4pIHRpbWUsXG4gICAgICAvLyBpdCdsbCBoYXZlIHRoZSBjb3JyZWN0IGJ5dGUgY291bnRzLlxuICAgICAgaW5PZmYgKz0gKGF2YWlsSW5CZWZvcmUgLSBhdmFpbEluQWZ0ZXIpO1xuICAgICAgYXZhaWxJbkJlZm9yZSA9IGF2YWlsSW5BZnRlcjtcblxuICAgICAgaWYgKCFhc3luYylcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIHZhciBuZXdSZXEgPSBzZWxmLl9iaW5kaW5nLndyaXRlKGZsdXNoRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2h1bmtTaXplKTtcbiAgICAgIG5ld1JlcS5jYWxsYmFjayA9IGNhbGxiYWNrOyAvLyB0aGlzIHNhbWUgZnVuY3Rpb25cbiAgICAgIG5ld1JlcS5idWZmZXIgPSBjaHVuaztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFzeW5jKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZmluaXNoZWQgd2l0aCB0aGUgY2h1bmsuXG4gICAgY2IoKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhEZWZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd6aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHdW56aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhEZWZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKFVuemlwLCBabGliKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXI7XG52YXIgU2xvd0J1ZmZlciA9IGJ1ZmZlci5TbG93QnVmZmVyO1xudmFyIE1BWF9MRU4gPSBidWZmZXIua01heExlbmd0aCB8fCAyMTQ3NDgzNjQ3O1xuZXhwb3J0cy5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IG5vdCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgdmFyIGVuYyA9IGVuY29kaW5nO1xuICB2YXIgX2ZpbGwgPSBmaWxsO1xuICBpZiAoX2ZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuYyA9IHVuZGVmaW5lZDtcbiAgICBfZmlsbCA9IDA7XG4gIH1cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIGlmICh0eXBlb2YgX2ZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGZpbGxCdWYgPSBuZXcgQnVmZmVyKF9maWxsLCBlbmMpO1xuICAgIHZhciBmbGVuID0gZmlsbEJ1Zi5sZW5ndGg7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgc2l6ZSkge1xuICAgICAgYnVmW2ldID0gZmlsbEJ1ZltpICUgZmxlbl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKF9maWxsKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbn1cbmV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nICYmICghZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgVWludDhBcnJheS5mcm9tICE9PSBCdWZmZXIuZnJvbSkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIG9mZnNldCA9IGVuY29kaW5nT3JPZmZzZXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICB2YXIgbGVuID0gbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgbGVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldDtcbiAgICB9XG4gICAgaWYgKG9mZnNldCA+PSB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKGxlbiA+IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICB2YWx1ZS5jb3B5KG91dCwgMCwgMCwgdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgJyArICdBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZVNsb3coc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPj0gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzaXplKTtcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIEZMT0FUMzJfVklFVyA9IG5ldyBGbG9hdDMyQXJyYXkoIDEgKTtcbnZhciBVSU5UMzJfVklFVyA9IG5ldyBVaW50MzJBcnJheSggRkxPQVQzMl9WSUVXLmJ1ZmZlciApO1xuXG4vLyAxIDExMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IDQyODY1Nzg2ODggPT4gMHhmZjgwMDAwMCAoc2VlIElFRUUgNzU0LTIwMDgpXG52YXIgTklORiA9IDB4ZmY4MDAwMDA7XG5cbi8vIFNldCB0aGUgQXJyYXlCdWZmZXIgYml0IHNlcXVlbmNlOlxuVUlOVDMyX1ZJRVdbIDAgXSA9IE5JTkY7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMT0FUMzJfVklFV1sgMCBdO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIEZMT0FUMzJfVklFVyA9IG5ldyBGbG9hdDMyQXJyYXkoIDEgKTtcbnZhciBVSU5UMzJfVklFVyA9IG5ldyBVaW50MzJBcnJheSggRkxPQVQzMl9WSUVXLmJ1ZmZlciApO1xuXG4vLyAwIDExMTExMTExIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwID0+IDIxMzkwOTUwNDAgPT4gMHg3ZjgwMDAwMCAoc2VlIElFRUUgNzU0LTIwMDgpXG52YXIgUElORiA9IDB4N2Y4MDAwMDA7XG5cbi8vIFNldCB0aGUgQXJyYXlCdWZmZXIgYml0IHNlcXVlbmNlOlxuVUlOVDMyX1ZJRVdbIDAgXSA9IFBJTkY7XG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMT0FUMzJfVklFV1sgMCBdO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyohIGRpY29tLXBhcnNlciAtIHYxLjcuMyAtIDIwMTYtMDgtMTggfCAoYykgMjAxNCBDaHJpcyBIYWZleSB8IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFmZXkvZGljb21QYXJzZXIgKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXG4gICAgLy8gbm9kZS5qc1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgaWYodHlwZW9mIGNvcm5lcnN0b25lID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuXG4gICAgICAgICAgICAvLyBtZXRlb3JcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUGFja2FnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByb290LmRpY29tUGFyc2VyID0gZGljb21QYXJzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGljb21QYXJzZXIgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbi8qKlxuICogUGFyc2VzIGEgRElDT00gUDEwIGJ5dGUgYXJyYXkgYW5kIHJldHVybnMgYSBEYXRhU2V0IG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgZWxlbWVudHMuICBJZiB0aGUgb3B0aW9uc1xuICogYXJndW1lbnQgaXMgc3VwcGxpZWQgYW5kIGl0IGNvbnRhaW5zIHRoZSB1bnRpbFRhZyBwcm9wZXJ0eSwgcGFyc2luZyB3aWxsIHN0b3Agb25jZSB0aGF0XG4gKiB0YWcgaXMgZW5jb3V0ZXJlZC4gIFRoaXMgY2FuIGJlIHVzZWQgdG8gcGFyc2UgcGFydGlhbCBieXRlIHN0cmVhbXMuXG4gKlxuICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheVxuICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHRvIGNvbnRyb2wgcGFyc2luZyBiZWhhdmlvciAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7RGF0YVNldH1cbiAqIEB0aHJvd3MgZXJyb3IgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHBhcnNpbmcuICBUaGUgZXhjZXB0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gYSBwcm9wZXJ0eSBkYXRhU2V0IHdpdGggdGhlXG4gKiAgICAgICAgIGVsZW1lbnRzIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYmVmb3JlIHRoZSBlcnJvci5cbiAqL1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uKGRpY29tUGFyc2VyKSB7XG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIucGFyc2VEaWNvbSA9IGZ1bmN0aW9uKGJ5dGVBcnJheSwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmKGJ5dGVBcnJheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnBhcnNlRGljb206IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlQXJyYXknXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkVHJhbnNmZXJTeW50YXgobWV0YUhlYWRlckRhdGFTZXQpIHtcbiAgICAgICAgICAgIGlmKG1ldGFIZWFkZXJEYXRhU2V0LmVsZW1lbnRzLngwMDAyMDAxMCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLnBhcnNlRGljb206IG1pc3NpbmcgcmVxdWlyZWQgbWV0YSBoZWFkZXIgYXR0cmlidXRlIDAwMDIsMDAxMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNmZXJTeW50YXhFbGVtZW50ID0gbWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHMueDAwMDIwMDEwO1xuICAgICAgICAgICAgcmV0dXJuIGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyhieXRlQXJyYXksIHRyYW5zZmVyU3ludGF4RWxlbWVudC5kYXRhT2Zmc2V0LCB0cmFuc2ZlclN5bnRheEVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzRXhwbGljaXQodHJhbnNmZXJTeW50YXgpIHtcbiAgICAgICAgICAgIGlmKHRyYW5zZmVyU3ludGF4ID09PSAnMS4yLjg0MC4xMDAwOC4xLjInKSAvLyBpbXBsaWNpdCBsaXR0bGUgZW5kaWFuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWxsIG90aGVyIHRyYW5zZmVyIHN5bnRheGVzIHNob3VsZCBiZSBleHBsaWNpdFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXREYXRhU2V0Qnl0ZVN0cmVhbSh0cmFuc2ZlclN5bnRheCwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmKHRyYW5zZmVyU3ludGF4ID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMS45OScpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYW4gaW5mYWx0ZXIgY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZCwgdXNlIGl0XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmZsYXRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbEJ5dGVBcnJheUNhbGxiYWNrID0gb3B0aW9ucy5pbmZsYXRlcihieXRlQXJyYXksIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciwgZnVsbEJ5dGVBcnJheUNhbGxiYWNrLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgcnVubmluZyBvbiBub2RlLCB1c2UgdGhlIHpsaWIgbGlicmFyeSB0byBpbmZsYXRlXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MjI0NjA2L2hvdy10by1jaGVjay13aGV0aGVyLWEtc2NyaXB0LWlzLXJ1bm5pbmctdW5kZXItbm9kZS1qc1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHRoaXMubW9kdWxlICE9PSBtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5mbGF0ZSBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmxhdGVkQnVmZmVyID0gZGljb21QYXJzZXIuc2hhcmVkQ29weShieXRlQXJyYXksIHBvc2l0aW9uLCBieXRlQXJyYXkubGVuZ3RoIC0gcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZWRCdWZmZXIgPSB6bGliLmluZmxhdGVSYXdTeW5jKGRlZmxhdGVkQnVmZmVyKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBzaW5nbGUgYnl0ZSBhcnJheSB3aXRoIHRoZSBmdWxsIGhlYWRlciBieXRlcyBhbmQgdGhlIGluZmxhdGVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxsQnl0ZUFycmF5QnVmZmVyID0gZGljb21QYXJzZXIuYWxsb2MoYnl0ZUFycmF5LCBpbmZsYXRlZEJ1ZmZlci5sZW5ndGggKyBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5jb3B5KGZ1bGxCeXRlQXJyYXlCdWZmZXIsIDAsIDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaW5mbGF0ZWRCdWZmZXIuY29weShmdWxsQnl0ZUFycmF5QnVmZmVyLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGZ1bGxCeXRlQXJyYXlCdWZmZXIsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBwYWtvIGlzIGRlZmluZWQgLSB1c2UgaXQuICBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBwYXRoXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvXG4gICAgICAgICAgICAgICAgZWxzZSBpZih0eXBlb2YgcGFrbyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmZsYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZsYXRlZCA9IGJ5dGVBcnJheS5zbGljZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlZCA9IHBha28uaW5mbGF0ZVJhdyhkZWZsYXRlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgc2luZ2xlIGJ5dGUgYXJyYXkgd2l0aCB0aGUgZnVsbCBoZWFkZXIgYnl0ZXMgYW5kIHRoZSBpbmZsYXRlZCBieXRlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbEJ5dGVBcnJheSA9IGRpY29tUGFyc2VyLmFsbG9jKGJ5dGVBcnJheSwgaW5mbGF0ZWQubGVuZ3RoICsgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBmdWxsQnl0ZUFycmF5LnNldChieXRlQXJyYXkuc2xpY2UoMCwgcG9zaXRpb24pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbEJ5dGVBcnJheS5zZXQoaW5mbGF0ZWQsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciwgZnVsbEJ5dGVBcnJheSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRocm93IGV4Y2VwdGlvbiBzaW5jZSBubyBpbmZsYXRlciBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLnBhcnNlRGljb206IG5vIGluZmxhdGVyIGF2YWlsYWJsZSB0byBoYW5kbGUgZGVmbGF0ZSB0cmFuc2ZlciBzeW50YXgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRyYW5zZmVyU3ludGF4ID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMicpIC8vIGV4cGxpY2l0IGJpZyBlbmRpYW5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIuYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXksIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNmZXIgc3ludGF4ZXMgYXJlIGxpdHRsZSBlbmRpYW47IG9ubHkgdGhlIHBpeGVsIGVuY29kaW5nIGRpZmZlcnNcbiAgICAgICAgICAgICAgICAvLyBtYWtlIGEgbmV3IHN0cmVhbSBzbyB0aGUgbWV0YWhlYWRlciB3YXJuaW5ncyBkb24ndCBjb21lIGFsb25nIGZvciB0aGUgcmlkZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGJ5dGVBcnJheSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VEYXRhU2V0cyhtZXRhSGVhZGVyRGF0YVNldCwgaW5zdGFuY2VEYXRhU2V0KVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gbWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYobWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlRGF0YVNldC5lbGVtZW50c1twcm9wZXJ0eU5hbWVdID0gbWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0YUhlYWRlckRhdGFTZXQud2FybmluZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlRGF0YVNldC53YXJuaW5ncyA9IG1ldGFIZWFkZXJEYXRhU2V0Lndhcm5pbmdzLmNvbmNhdChpbnN0YW5jZURhdGFTZXQud2FybmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlRGF0YVNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREYXRhU2V0KG1ldGFIZWFkZXJEYXRhU2V0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmZXJTeW50YXggPSByZWFkVHJhbnNmZXJTeW50YXgobWV0YUhlYWRlckRhdGFTZXQpO1xuICAgICAgICAgICAgdmFyIGV4cGxpY2l0ID0gaXNFeHBsaWNpdCh0cmFuc2ZlclN5bnRheCk7XG4gICAgICAgICAgICB2YXIgZGF0YVNldEJ5dGVTdHJlYW0gPSBnZXREYXRhU2V0Qnl0ZVN0cmVhbSh0cmFuc2ZlclN5bnRheCwgbWV0YUhlYWRlckRhdGFTZXQucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBkYXRhU2V0ID0gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoZGF0YVNldEJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBkYXRhU2V0Qnl0ZVN0cmVhbS5ieXRlQXJyYXksIGVsZW1lbnRzKTtcbiAgICAgICAgICAgIGRhdGFTZXQud2FybmluZ3MgPSBkYXRhU2V0Qnl0ZVN0cmVhbS53YXJuaW5ncztcblxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIGlmKGV4cGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQoZGF0YVNldCwgZGF0YVNldEJ5dGVTdHJlYW0sIGRhdGFTZXRCeXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEltcGxpY2l0KGRhdGFTZXQsIGRhdGFTZXRCeXRlU3RyZWFtLCBkYXRhU2V0Qnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4ID0ge1xuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb246IGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFTZXQ6IGRhdGFTZXRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFTZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWluIGZ1bmN0aW9uIGhlcmVcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VUaGVCeXRlU3RyZWFtKCkge1xuICAgICAgICAgICAgdmFyIG1ldGFIZWFkZXJEYXRhU2V0ID0gZGljb21QYXJzZXIucmVhZFBhcnQxMEhlYWRlcihieXRlQXJyYXksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YVNldCA9IHJlYWREYXRhU2V0KG1ldGFIZWFkZXJEYXRhU2V0KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YVNldHMobWV0YUhlYWRlckRhdGFTZXQsIGRhdGFTZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyB3aGVyZSB3ZSBhY3R1YWxseSBzdGFydCBwYXJzaW5nXG4gICAgICAgIHJldHVybiBwYXJzZVRoZUJ5dGVTdHJlYW0oKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufSkoZGljb21QYXJzZXIpO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgYmFzaWMgb2Zmc2V0IHRhYmxlIGZvciBKUEVHIHRyYW5zZmVyIHN5bnRheGVzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICAvLyBFYWNoIEpQRUcgaW1hZ2UgaGFzIGFuIGVuZCBvZiBpbWFnZSBtYXJrZXIgMHhGRkQ5XG4gIGZ1bmN0aW9uIGlzRW5kT2ZJbWFnZU1hcmtlcihkYXRhU2V0LCBwb3NpdGlvbikge1xuICAgIHJldHVybiAoZGF0YVNldC5ieXRlQXJyYXlbcG9zaXRpb25dID09PSAweEZGICYmXG4gICAgZGF0YVNldC5ieXRlQXJyYXlbcG9zaXRpb24gKyAxXSA9PT0gMHhEOSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZyYWdtZW50RW5kT2ZJbWFnZShkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFnbWVudEluZGV4KSB7XG4gICAgdmFyIGZyYWdtZW50ID0gcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHNbZnJhZ21lbnRJbmRleF07XG4gICAgLy8gTmVlZCB0byBjaGVjayB0aGUgbGFzdCB0d28gYnl0ZXMgYW5kIHRoZSBsYXN0IHRocmVlIGJ5dGVzIGZvciBtYXJrZXIgc2luY2Ugb2RkIGxlbmd0aFxuICAgIC8vIGZyYWdtZW50cyBhcmUgemVybyBwYWRkZWRcbiAgICBpZihpc0VuZE9mSW1hZ2VNYXJrZXIoZGF0YVNldCwgZnJhZ21lbnQucG9zaXRpb24gKyBmcmFnbWVudC5sZW5ndGggLSAyKSB8fFxuICAgICAgaXNFbmRPZkltYWdlTWFya2VyKGRhdGFTZXQsIGZyYWdtZW50LnBvc2l0aW9uICsgZnJhZ21lbnQubGVuZ3RoIC0gMykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTGFzdEltYWdlRnJhbWVGcmFnbWVudEluZGV4KGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIHN0YXJ0RnJhZ21lbnQpIHtcbiAgICBmb3IodmFyIGZyYWdtZW50SW5kZXg9c3RhcnRGcmFnbWVudDsgZnJhZ21lbnRJbmRleCA8IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aDsgZnJhZ21lbnRJbmRleCsrKSB7XG4gICAgICBpZihpc0ZyYWdtZW50RW5kT2ZJbWFnZShkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFnbWVudEluZGV4KSkge1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJhc2ljIG9mZnNldCB0YWJsZSBieSBzY2FubmluZyBmcmFnbWVudHMgZm9yIEpQRUcgc3RhcnQgb2YgaW1hZ2UgYW5kIGVuZCBPZiBJbWFnZSBtYXJrZXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhU2V0IC0gdGhlIHBhcnNlZCBkaWNvbSBkYXRhc2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwaXhlbERhdGFFbGVtZW50IC0gdGhlIHBpeGVsIGRhdGEgZWxlbWVudFxuICAgKiBAcGFyYW0gW2ZyYWdtZW50c10gLSBvcHRpb25hbCBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgZWFjaCBmcmFnbWVudCAob2Zmc2V0LCBwb3NpdGlvbiwgbGVuZ3RoKVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGJhc2ljIG9mZnNldCB0YWJsZSAoYXJyYXkgb2Ygb2Zmc2V0cyB0byBiZWdpbm5pbmcgb2YgZWFjaCBmcmFtZSlcbiAgICovXG4gIGRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlID0gZnVuY3Rpb24oZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhZ21lbnRzKSB7XG4gICAgLy8gVmFsaWRhdGUgcGFyYW1ldGVyc1xuICAgIGlmKGRhdGFTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBkYXRhU2V0JztcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyAnZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIHBpeGVsRGF0YUVsZW1lbnQnO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LnRhZyAhPT0gJ3g3ZmUwMDAxMCcpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIG5vbiBwaXhlbCBkYXRhIHRhZyAoZXhwZWN0ZWQgdGFnID0geDdmZTAwMDEwJ1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmVuY2Fwc3VsYXRlZFBpeGVsRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKGZyYWdtZW50cyAmJiBmcmFnbWVudHMubGVuZ3RoIDw9MCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdmcmFnbWVudHMnIG11c3Qgbm90IGJlIHplcm8gbGVuZ3RoXCI7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB2YWx1ZXNcbiAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMgfHwgcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHM7XG5cbiAgICB2YXIgYmFzaWNPZmZzZXRUYWJsZSA9IFtdO1xuXG4gICAgdmFyIHN0YXJ0RnJhZ21lbnRJbmRleCA9IDA7XG5cbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAvLyBBZGQgdGhlIG9mZnNldCBmb3IgdGhlIHN0YXJ0IGZyYWdtZW50XG4gICAgICBiYXNpY09mZnNldFRhYmxlLnB1c2gocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHNbc3RhcnRGcmFnbWVudEluZGV4XS5vZmZzZXQpO1xuICAgICAgdmFyIGVuZEZyYWdtZW50SW5kZXggPSBmaW5kTGFzdEltYWdlRnJhbWVGcmFnbWVudEluZGV4KGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIHN0YXJ0RnJhZ21lbnRJbmRleCk7XG4gICAgICBpZihlbmRGcmFnbWVudEluZGV4ID09PSB1bmRlZmluZWQgfHwgZW5kRnJhZ21lbnRJbmRleCA9PT0gcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMubGVuZ3RoIC0xKSB7XG4gICAgICAgIHJldHVybiBiYXNpY09mZnNldFRhYmxlO1xuICAgICAgfVxuICAgICAgc3RhcnRGcmFnbWVudEluZGV4ID0gZW5kRnJhZ21lbnRJbmRleCArIDE7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgYW4gZXhwbGljaXQgZGF0YVNldCB0byBhIGphdmFzY3JpcHQgb2JqZWN0XG4gICAgICogQHBhcmFtIGRhdGFTZXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmV4cGxpY2l0RGF0YVNldFRvSlMgPSBmdW5jdGlvbiAoZGF0YVNldCwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmKGRhdGFTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmV4cGxpY2l0RGF0YVNldFRvSlM6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGRhdGFTZXQnO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgb21pdFByaXZhdGVBdHRpYnV0ZXM6IHRydWUsIC8vIHRydWUgaWYgcHJpdmF0ZSBlbGVtZW50cyBzaG91bGQgYmUgb21pdHRlZFxuICAgICAgICAgICAgbWF4RWxlbWVudExlbmd0aCA6IDEyOCAgICAgIC8vIG1heGltdW0gZWxlbWVudCBsZW5ndGggdG8gdHJ5IGFuZCBjb252ZXJ0IHRvIHN0cmluZyBmb3JtYXRcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yKHZhciB0YWcgaW4gZGF0YVNldC5lbGVtZW50cykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkYXRhU2V0LmVsZW1lbnRzW3RhZ107XG5cbiAgICAgICAgICAgIC8vIHNraXAgdGhpcyBlbGVtZW50IGlmIGl0IGEgcHJpdmF0ZSBlbGVtZW50IGFuZCBvdXIgb3B0aW9ucyBzcGVjaWZ5IHRoYXQgd2Ugc2hvdWxkXG4gICAgICAgICAgICBpZihvcHRpb25zLm9taXRQcml2YXRlQXR0aWJ1dGVzID09PSB0cnVlICYmIGRpY29tUGFyc2VyLmlzUHJpdmF0ZVRhZyh0YWcpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlbGVtZW50Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIHZhciBzZXF1ZW5jZUl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBlbGVtZW50Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSXRlbXMucHVzaChkaWNvbVBhcnNlci5leHBsaWNpdERhdGFTZXRUb0pTKGVsZW1lbnQuaXRlbXNbaV0uZGF0YVNldCwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbdGFnXSA9IHNlcXVlbmNlSXRlbXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhc1N0cmluZztcbiAgICAgICAgICAgICAgICBhc1N0cmluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA8IG9wdGlvbnMubWF4RWxlbWVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhc1N0cmluZyA9IGRpY29tUGFyc2VyLmV4cGxpY2l0RWxlbWVudFRvU3RyaW5nKGRhdGFTZXQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGFzU3RyaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3RhZ10gPSBhc1N0cmluZztcbiAgICAgICAgICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3RhZ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0OiBlbGVtZW50LmRhdGFPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggOiBlbGVtZW50Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBleHBsaWNpdCBWUiBlbGVtZW50IHRvIGEgc3RyaW5nIG9yIHVuZGVmaW5lZCBpZiBpdCBpcyBub3QgcG9zc2libGUgdG8gY29udmVydC5cbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gaW1wbGljaXQgZWxlbWVudCBpcyBzdXBwbGllZFxuICAgICAqIEBwYXJhbSBkYXRhU2V0XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5leHBsaWNpdEVsZW1lbnRUb1N0cmluZyA9IGZ1bmN0aW9uKGRhdGFTZXQsIGVsZW1lbnQpXG4gICAge1xuICAgICAgICBpZihkYXRhU2V0ID09PSB1bmRlZmluZWQgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIuZXhwbGljaXRFbGVtZW50VG9TdHJpbmc6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVycyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZWxlbWVudC52ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIuZXhwbGljaXRFbGVtZW50VG9TdHJpbmc6IGNhbm5vdCBjb252ZXJ0IGltcGxpY2l0IGVsZW1lbnQgdG8gc3RyaW5nJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdnIgPSBlbGVtZW50LnZyO1xuICAgICAgICB2YXIgdGFnID0gZWxlbWVudC50YWc7XG5cbiAgICAgICAgdmFyIHRleHRSZXN1bHQ7XG5cbiAgICAgICAgZnVuY3Rpb24gbXVsdGlFbGVtZW50VG9TdHJpbmcobnVtSXRlbXMsIGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBudW1JdGVtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZnVuYy5jYWxsKGRhdGFTZXQsIHRhZywgaSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihkaWNvbVBhcnNlci5pc1N0cmluZ1ZyKHZyKSA9PT0gdHJ1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IGRhdGFTZXQuc3RyaW5nKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodnIgPT0gJ0FUJykge1xuICAgICAgICAgICAgdmFyIG51bSA9IGRhdGFTZXQudWludDMyKHRhZyk7XG4gICAgICAgICAgICBpZihudW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtIDwgMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW0gPSAweEZGRkZGRkZGICsgbnVtICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICd4JyArIG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ciA9PSAnVVMnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0UmVzdWx0ID0gbXVsdGlFbGVtZW50VG9TdHJpbmcoZWxlbWVudC5sZW5ndGggLyAyLCBkYXRhU2V0LnVpbnQxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih2ciA9PT0gJ1NTJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gMiwgZGF0YVNldC5pbnQxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodnIgPT0gJ1VMJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gNCwgZGF0YVNldC51aW50MzIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodnIgPT09ICdTTCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRSZXN1bHQgPSBtdWx0aUVsZW1lbnRUb1N0cmluZyhlbGVtZW50Lmxlbmd0aCAvIDQsIGRhdGFTZXQuaW50MzIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodnIgPT0gJ0ZEJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gOCwgZGF0YVNldC5kb3VibGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodnIgPT0gJ0ZMJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gNCwgZGF0YVNldC5mbG9hdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dFJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBESUNPTVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLy8gYWxnb3JpdGhtIGJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQzMzAzMC92YWxpZGF0ZS1udW1iZXItb2YtZGF5cy1pbi1hLWdpdmVuLW1vbnRoXG4gIGZ1bmN0aW9uIGRheXNJbk1vbnRoKG0sIHkpIHsgLy8gbSBpcyAwIGluZGV4ZWQ6IDAtMTFcbiAgICBzd2l0Y2ggKG0pIHtcbiAgICAgIGNhc2UgMiA6XG4gICAgICAgIHJldHVybiAoeSAlIDQgPT0gMCAmJiB5ICUgMTAwKSB8fCB5ICUgNDAwID09IDAgPyAyOSA6IDI4O1xuICAgICAgY2FzZSA5IDogY2FzZSA0IDogY2FzZSA2IDogY2FzZSAxMSA6XG4gICAgICByZXR1cm4gMzA7XG4gICAgICBkZWZhdWx0IDpcbiAgICAgICAgcmV0dXJuIDMxXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZERhdGUoZCwgbSwgeSkge1xuICAgIC8vIG1ha2UgeWVhciBpcyBhIG51bWJlclxuICAgIGlmKGlzTmFOKHkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtID4gMCAmJiBtIDw9IDEyICYmIGQgPiAwICYmIGQgPD0gZGF5c0luTW9udGgobSwgeSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBEQSBmb3JtYXR0ZWQgc3RyaW5nIGludG8gYSBKYXZhc2NyaXB0IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSBhIHN0cmluZyBpbiB0aGUgREEgVlIgZm9ybWF0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlXSAtIHRydWUgaWYgYW4gZXhjZXB0aW9uIHNob3VsZCBiZSB0aHJvd24gaWYgdGhlIGRhdGUgaXMgaW52YWxpZFxuICAgKiBAcmV0dXJucyB7Kn0gSmF2YXNjcmlwdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHllYXIsIG1vbnRoIGFuZCBkYXkgb3IgdW5kZWZpbmVkIGlmIG5vdCBwcmVzZW50IG9yIG5vdCA4IGJ5dGVzIGxvbmdcbiAgICovXG4gIGRpY29tUGFyc2VyLnBhcnNlREEgPSBmdW5jdGlvbihkYXRlLCB2YWxpZGF0ZSlcbiAge1xuICAgIGlmKGRhdGUgJiYgZGF0ZS5sZW5ndGggPT09IDgpXG4gICAge1xuICAgICAgdmFyIHl5eXkgPSBwYXJzZUludChkYXRlLnN1YnN0cmluZygwLCA0KSwgMTApO1xuICAgICAgdmFyIG1tID0gcGFyc2VJbnQoZGF0ZS5zdWJzdHJpbmcoNCwgNiksIDEwKTtcbiAgICAgIHZhciBkZCA9IHBhcnNlSW50KGRhdGUuc3Vic3RyaW5nKDYsIDgpLCAxMCk7XG5cbiAgICAgIGlmKHZhbGlkYXRlKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZShkZCwgbW0sIHl5eXkpICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgXCJpbnZhbGlkIERBICdcIiArIGRhdGUgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogeXl5eSxcbiAgICAgICAgbW9udGg6IG1tLFxuICAgICAgICBkYXk6IGRkXG4gICAgICB9O1xuICAgIH1cbiAgICBpZih2YWxpZGF0ZSkge1xuICAgICAgdGhyb3cgXCJpbnZhbGlkIERBICdcIiArIGRhdGUgKyBcIidcIjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGggRElDT01cbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBUTSBmb3JtYXR0ZWQgc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzIGFuZCBmcmFjdGlvbmFsU2Vjb25kc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZSAtIGEgc3RyaW5nIGluIHRoZSBUTSBWUiBmb3JtYXRcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsaWRhdGVdIC0gdHJ1ZSBpZiBhbiBleGNlcHRpb24gc2hvdWxkIGJlIHRocm93biBpZiB0aGUgZGF0ZSBpcyBpbnZhbGlkXG4gICAqIEByZXR1cm5zIHsqfSBqYXZhc2NyaXB0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzIGFuZCBmcmFjdGlvbmFsU2Vjb25kcyBvciB1bmRlZmluZWQgaWYgbm8gZWxlbWVudCBvciBkYXRhLiAgTWlzc2luZyBmaWVsZHMgYXJlIHNldCB0byB1bmRlZmluZWRcbiAgICovXG4gIGRpY29tUGFyc2VyLnBhcnNlVE0gPSBmdW5jdGlvbih0aW1lLCB2YWxpZGF0ZSkge1xuXG4gICAgaWYgKHRpbWUubGVuZ3RoID49IDIpIC8vIG11c3QgYXQgbGVhc3QgaGF2ZSBISFxuICAgIHtcbiAgICAgIC8vIDAxMjM0NTY3ODlcbiAgICAgIC8vIEhITU1TUy5GRkZGRkZcbiAgICAgIHZhciBoaCA9IHBhcnNlSW50KHRpbWUuc3Vic3RyaW5nKDAsIDIpLCAxMCk7XG4gICAgICB2YXIgbW0gPSB0aW1lLmxlbmd0aCA+PSA0ID8gcGFyc2VJbnQodGltZS5zdWJzdHJpbmcoMiwgNCksIDEwKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzcyA9IHRpbWUubGVuZ3RoID49IDYgPyBwYXJzZUludCh0aW1lLnN1YnN0cmluZyg0LCA2KSwgMTApIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGZmZmZmZiA9IHRpbWUubGVuZ3RoID49IDggPyBwYXJzZUludCh0aW1lLnN1YnN0cmluZyg3LCAxMyksIDEwKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYodmFsaWRhdGUpIHtcbiAgICAgICAgaWYoKGlzTmFOKGhoKSkgfHxcbiAgICAgICAgICAobW0gIT09IHVuZGVmaW5lZCAmJiBpc05hTihtbSkpIHx8XG4gICAgICAgICAgKHNzICE9PSB1bmRlZmluZWQgJiYgaXNOYU4oc3MpKSB8fFxuICAgICAgICAgIChmZmZmZmYgIT09IHVuZGVmaW5lZCAmJiBpc05hTihmZmZmZmYpKSB8fFxuICAgICAgICAgIChoaCA8IDAgfHwgaGggPiAyMykgfHxcbiAgICAgICAgICAobW0gJiYgKG1tIDwwIHx8IG1tID4gNTkpKSAgfHxcbiAgICAgICAgICAoc3MgJiYgKHNzIDwwIHx8IHNzID4gNTkpKSAgfHxcbiAgICAgICAgICAoZmZmZmZmICYmIChmZmZmZmYgPDAgfHwgZmZmZmZmID4gOTk5OTk5KSkpXG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBcImludmFsaWQgVE0gJ1wiICsgdGltZSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhvdXJzOiBoaCxcbiAgICAgICAgbWludXRlczogbW0sXG4gICAgICAgIHNlY29uZHM6IHNzLFxuICAgICAgICBmcmFjdGlvbmFsU2Vjb25kczogZmZmZmZmXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmKHZhbGlkYXRlKSB7XG4gICAgICB0aHJvdyBcImludmFsaWQgVE0gJ1wiICsgdGltZSArIFwiJ1wiO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERJQ09NXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzdHJpbmdWcnMgPSB7XG4gICAgICAgIEFFOiB0cnVlLFxuICAgICAgICBBUzogdHJ1ZSxcbiAgICAgICAgQVQ6IGZhbHNlLFxuICAgICAgICBDUzogdHJ1ZSxcbiAgICAgICAgREE6IHRydWUsXG4gICAgICAgIERTOiB0cnVlLFxuICAgICAgICBEVDogdHJ1ZSxcbiAgICAgICAgRkw6IGZhbHNlLFxuICAgICAgICBGRDogZmFsc2UsXG4gICAgICAgIElTOiB0cnVlLFxuICAgICAgICBMTzogdHJ1ZSxcbiAgICAgICAgTFQ6IHRydWUsXG4gICAgICAgIE9COiBmYWxzZSxcbiAgICAgICAgT0Q6IGZhbHNlLFxuICAgICAgICBPRjogZmFsc2UsXG4gICAgICAgIE9XOiBmYWxzZSxcbiAgICAgICAgUE46IHRydWUsXG4gICAgICAgIFNIOiB0cnVlLFxuICAgICAgICBTTDogZmFsc2UsXG4gICAgICAgIFNROiBmYWxzZSxcbiAgICAgICAgU1M6IGZhbHNlLFxuICAgICAgICBTVDogdHJ1ZSxcbiAgICAgICAgVE06IHRydWUsXG4gICAgICAgIFVJOiB0cnVlLFxuICAgICAgICBVTDogZmFsc2UsXG4gICAgICAgIFVOOiB1bmRlZmluZWQsIC8vIGR1bm5vXG4gICAgICAgIFVSOiB0cnVlLFxuICAgICAgICBVUzogZmFsc2UsXG4gICAgICAgIFVUOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHRvIHNlZSBpZiB2ciBpcyBhIHN0cmluZyBvciBub3QuXG4gICAgICogQHBhcmFtIHZyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBzdHJpbmcsIGZhbHNlIGl0IG5vdCBzdHJpbmcsIHVuZGVmaW5lZCBpZiB1bmtub3duIHZyIG9yIFVOIHR5cGVcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5pc1N0cmluZ1ZyID0gZnVuY3Rpb24odnIpXG4gICAge1xuICAgICAgICByZXR1cm4gc3RyaW5nVnJzW3ZyXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgdG8gc2VlIGlmIGEgZ2l2ZW4gdGFnIGluIHRoZSBmb3JtYXQgeGdnZ2dlZWVlIGlzIGEgcHJpdmF0ZSB0YWcgb3Igbm90XG4gICAgICogQHBhcmFtIHRhZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmlzUHJpdmF0ZVRhZyA9IGZ1bmN0aW9uKHRhZylcbiAgICB7XG4gICAgICAgIHZhciBsYXN0R3JvdXBEaWdpdCA9IHBhcnNlSW50KHRhZ1s0XSk7XG4gICAgICAgIHZhciBncm91cElzT2RkID0gKGxhc3RHcm91cERpZ2l0ICUgMikgPT09IDE7XG4gICAgICAgIHJldHVybiBncm91cElzT2RkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBQTiBmb3JtYXR0ZWQgc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIGdpdmVuTmFtZSwgZmFtaWx5TmFtZSwgbWlkZGxlTmFtZSwgcHJlZml4IGFuZCBzdWZmaXhcbiAgICAgKiBAcGFyYW0gcGVyc29uTmFtZSBhIHN0cmluZyBpbiB0aGUgUE4gVlIgZm9ybWF0XG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHJldHVybnMgeyp9IGphdmFzY3JpcHQgb2JqZWN0IHdpdGggcHJvcGVydGllcyBmb3IgZ2l2ZW5OYW1lLCBmYW1pbHlOYW1lLCBtaWRkbGVOYW1lLCBwcmVmaXggYW5kIHN1ZmZpeCBvciB1bmRlZmluZWQgaWYgbm8gZWxlbWVudCBvciBkYXRhXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucGFyc2VQTiA9IGZ1bmN0aW9uKHBlcnNvbk5hbWUpIHtcbiAgICAgICAgaWYocGVyc29uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZXMgPSBwZXJzb25OYW1lLnNwbGl0KCdeJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmYW1pbHlOYW1lOiBzdHJpbmdWYWx1ZXNbMF0sXG4gICAgICAgICAgICBnaXZlbk5hbWU6IHN0cmluZ1ZhbHVlc1sxXSxcbiAgICAgICAgICAgIG1pZGRsZU5hbWU6IHN0cmluZ1ZhbHVlc1syXSxcbiAgICAgICAgICAgIHByZWZpeDogc3RyaW5nVmFsdWVzWzNdLFxuICAgICAgICAgICAgc3VmZml4OiBzdHJpbmdWYWx1ZXNbNF1cbiAgICAgICAgfTtcbiAgICB9O1xuXG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogRnVuY3Rpb25hbGl0eSBmb3IgZXh0cmFjdGluZyBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRlZE5vdGljZUxvZ2dlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGl4ZWwgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBmcmFtZSBpbiBhbiBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YSBlbGVtZW50LiAgSWYgbm8gYmFzaWMgb2Zmc2V0XG4gICAgICogdGFibGUgaXMgcHJlc2VudCwgaXQgYXNzdW1lcyB0aGF0IGFsbCBmcmFnbWVudHMgYXJlIGZvciBvbmUgZnJhbWUuICBOb3RlIHRoYXQgdGhpcyBhc3N1bXB0aW9uL2xvZ2ljIGlzIG5vdFxuICAgICAqIHZhbGlkIGZvciBtdWx0aS1mcmFtZSBpbnN0YW5jZXMgc28gdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGV2ZW50dWFsbHkgYmUgcmVtb3ZlZC4gIENvZGVcbiAgICAgKiBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2UgcmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHMoKSBvciByZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZSgpXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuNiAtIHVzZSByZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50cygpIG9yIHJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lKClcbiAgICAgKiBAcGFyYW0gZGF0YVNldCAtIHRoZSBkYXRhU2V0IGNvbnRhaW5pbmcgdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gICAgICogQHBhcmFtIHBpeGVsRGF0YUVsZW1lbnQgLSB0aGUgcGl4ZWwgZGF0YSBlbGVtZW50ICh4N2ZlMDAwMTApIHRvIGV4dHJhY3QgdGhlIGZyYW1lIGZyb21cbiAgICAgKiBAcGFyYW0gZnJhbWUgLSB0aGUgemVybyBiYXNlZCBmcmFtZSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHdpdGggdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gICAgICovXG5cblxuICAgIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGEgPSBmdW5jdGlvbihkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFtZSlcbiAgICB7XG4gICAgICAgIGlmKCFkZXByZWNhdGVkTm90aWNlTG9nZ2VkKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVkTm90aWNlTG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmKGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGEoKSBoYXMgYmVlbiBkZXByZWNhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGF0YVNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdkYXRhU2V0J1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZWxlbWVudCdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihmcmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdmcmFtZSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LnRhZyAhPT0gJ3g3ZmUwMDAxMCcpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogcGFyYW1ldGVyICdlbGVtZW50JyByZWZlcnMgdG8gbm9uIHBpeGVsIGRhdGEgdGFnIChleHBlY3RlZCB0YWcgPSB4N2ZlMDAwMTAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudC5lbmNhcHN1bGF0ZWRQaXhlbERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogcGFyYW1ldGVyICdlbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IHBhcmFtZXRlciAnZWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBwYXJhbWV0ZXIgJ2VsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBwYXJhbWV0ZXIgJ2VsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZnJhbWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IHBhcmFtZXRlciAnZnJhbWUnIG11c3QgYmUgPj0gMFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGJhc2ljIG9mZnNldCB0YWJsZSBpcyBub3QgZW1wdHksIHdlIGNhbiBleHRyYWN0IHRoZSBmcmFtZVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWUoZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gTm8gYmFzaWMgb2Zmc2V0IHRhYmxlLCBhc3N1bWUgYWxsIGZyYWdtZW50cyBhcmUgZm9yIG9uZSBmcmFtZSAtIE5PVEUgdGhhdCB0aGlzIGlzIE5PVCBhIHZhbGlkXG4gICAgICAgICAgICAvLyBhc3N1bXB0aW9uIGJ1dCBpcyB0aGUgb3JpZ2luYWwgYmVoYXZpb3Igc28gd2UgYXJlIGtlZXBpbmcgaXQgZm9yIG5vd1xuICAgICAgICAgICAgcmV0dXJuIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIDAsIHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuXG4vKipcbiAqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gYWxsb2NhdGUgbmV3IGJ5dGVBcnJheSBidWZmZXJzXG4gKi9cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYnl0ZUFycmF5IG9mIHRoZSBzYW1lIHR5cGUgKFVpbnQ4QXJyYXkgb3IgQnVmZmVyKSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgdW5kZXJseWluZyBieXRlQXJyYXkgKGVpdGhlciBVaW50OEFycmF5IG9yIEJ1ZmZlcilcbiAgICogQHBhcmFtIGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIEJ5dGUgQXJyYXlcbiAgICogQHJldHVybnMge29iamVjdH0gVWludDhBcnJheSBvciBCdWZmZXIgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGJ5dGVBcnJheVxuICAgKi9cbiAgZGljb21QYXJzZXIuYWxsb2MgPSBmdW5jdGlvbihieXRlQXJyYXksIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBieXRlQXJyYXkgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZihieXRlQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmFsbG9jOiB1bmtub3duIHR5cGUgZm9yIGJ5dGVBcnJheSc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBkaWZmZXJlbnQgdHlwZXMgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBkaWNvbVBhcnNlci5iaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJzZXMgYW4gdW5zaWduZWQgaW50IDE2IGZyb20gYSBiaWctZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgdW5zaWduZWQgaW50IDE2XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZFVpbnQxNjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MTY6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyAyID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQxNjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGJ5dGVBcnJheVtwb3NpdGlvbl0gPDwgOCkgKyBieXRlQXJyYXlbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyc2VzIGEgc2lnbmVkIGludCAxNiBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHNpZ25lZCBpbnQgMTZcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkSW50MTY6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MTY6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyAyID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDE2OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnQxNiA9IChieXRlQXJyYXlbcG9zaXRpb25dIDw8IDgpICsgYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgICAgICAvLyBmaXggc2lnblxuICAgICAgICAgICAgaWYgKGludDE2ICYgMHg4MDAwKSB7XG4gICAgICAgICAgICAgICAgaW50MTYgPSBpbnQxNiAtIDB4RkZGRiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50MTY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhbiB1bnNpZ25lZCBpbnQgMzIgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMzJcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkVWludDMyOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQzMjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgNCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MzI6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWludDMyID0gKDI1NiAqICgyNTYgKiAoMjU2ICogYnl0ZUFycmF5W3Bvc2l0aW9uXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXlbcG9zaXRpb24gKyAyXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHVpbnQzMjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGEgc2lnbmVkIGludCAzMiBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHNpZ25lZCBpbnQgMzJcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkSW50MzI6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MzI6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDQgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MzI6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW50MzIgPSAoKGJ5dGVBcnJheVtwb3NpdGlvbl0gPDwgMjQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl0gPDwgOCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXlbcG9zaXRpb24gKyAzXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnQzMjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIDMyLWJpdCBmbG9hdCBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIDMyLWJpdCBmbG9hdFxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRGbG9hdDogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRGbG9hdDogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgNCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRGbG9hdDogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEkgYW0gc3VyZSB0aGVyZSBpcyBhIGJldHRlciB3YXkgdGhhbiB0aGlzIGJ1dCB0aGlzIHNob3VsZCBiZSBzYWZlXG4gICAgICAgICAgICB2YXIgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbM10gPSBieXRlQXJyYXlbcG9zaXRpb25dO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzJdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAyXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFswXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdO1xuICAgICAgICAgICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdC5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyA2NC1iaXQgZmxvYXQgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCA2NC1iaXQgZmxvYXRcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkRG91YmxlOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZERvdWJsZTogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgOCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWREb3VibGU6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJIGFtIHN1cmUgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRoYW4gdGhpcyBidXQgdGhpcyBzaG91bGQgYmUgc2FmZVxuICAgICAgICAgICAgdmFyIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdCA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzddID0gYnl0ZUFycmF5W3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs2XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzVdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbNF0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAzXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFszXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDRdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzJdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgNV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA2XTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFswXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDddO1xuICAgICAgICAgICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdC5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGNvbW1vbiB0byBwYXJzaW5nIGJ5dGUgYXJyYXlzIG9mIGFueSB0eXBlXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgc3RyaW5nIG9mIDgtYml0IGNoYXJhY3RlcnMgZnJvbSBhbiBhcnJheSBvZiBieXRlcyBhbmQgYWR2YW5jZXNcbiAgICAgKiB0aGUgcG9zaXRpb24gYnkgbGVuZ3RoIGJ5dGVzLiAgQSBudWxsIHRlcm1pbmF0b3Igd2lsbCBlbmQgdGhlIHN0cmluZ1xuICAgICAqIGJ1dCB3aWxsIG5vdCBlZmZlY3QgYWR2YW5jZW1lbnQgb2YgdGhlIHBvc2l0aW9uLiAgVHJhaWxpbmcgYW5kIGxlYWRpbmdcbiAgICAgKiBzcGFjZXMgYXJlIHByZXNlcnZlZCAobm90IHRyaW1tZWQpXG4gICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZUFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIGxlbmd0aCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcGFyc2VkIHN0cmluZ1xuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nID0gZnVuY3Rpb24oYnl0ZUFycmF5LCBwb3NpdGlvbiwgbGVuZ3RoKVxuICAgIHtcbiAgICAgICAgaWYobGVuZ3RoIDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyAtIGxlbmd0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocG9zaXRpb24gKyBsZW5ndGggPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB2YXIgYnl0ZTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgYnl0ZSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIGldO1xuICAgICAgICAgICAgaWYoYnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9ICBsZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqXG4gKiBJbnRlcm5hbCBoZWxwZXIgY2xhc3MgdG8gYXNzaXN0IHdpdGggcGFyc2luZy4gU3VwcG9ydHMgcmVhZGluZyBmcm9tIGEgYnl0ZVxuICogc3RyZWFtIGNvbnRhaW5lZCBpbiBhIFVpbnQ4QXJyYXkuICBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICogIHZhciBieXRlU3RyZWFtID0gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXkpO1xuICpcbiAqICovXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIEJ5dGVTdHJlYW0gb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0gYnl0ZUFycmF5UGFyc2VyIGEgcGFyc2VyIGZvciBwYXJzaW5nIHRoZSBieXRlIGFycmF5XG4gICAgICogQHBhcmFtIGJ5dGVBcnJheSBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgYnl0ZSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gKG9wdGlvbmFsKSB0aGUgcG9zaXRpb24gdG8gc3RhcnQgcmVhZGluZyBmcm9tLiAgMCBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHRocm93cyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBieXRlQXJyYXlQYXJzZXIgcGFyYW1ldGVyIGlzIG5vdCBwcmVzZW50XG4gICAgICogQHRocm93cyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBieXRlQXJyYXkgcGFyYW1ldGVyIGlzIG5vdCBwcmVzZW50IG9yIGludmFsaWRcbiAgICAgKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHBvc2l0aW9uIHBhcmFtZXRlciBpcyBub3QgaW5zaWRlIHRoZSBieXRlIGFycmF5XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuQnl0ZVN0cmVhbSA9IGZ1bmN0aW9uKGJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICBpZihieXRlQXJyYXlQYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5CeXRlU3RyZWFtOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZUFycmF5UGFyc2VyJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJ5dGVBcnJheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLkJ5dGVTdHJlYW06IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlQXJyYXknXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoKGJ5dGVBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpID09PSBmYWxzZSAmJlxuICAgICAgICAgIChieXRlQXJyYXkgaW5zdGFuY2VvZiBCdWZmZXIpID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5CeXRlU3RyZWFtOiBwYXJhbWV0ZXIgYnl0ZUFycmF5IGlzIG5vdCBvZiB0eXBlIFVpbnQ4QXJyYXkgb3IgQnVmZmVyJztcbiAgICAgICAgfVxuICAgICAgICBpZihwb3NpdGlvbiA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuQnl0ZVN0cmVhbTogcGFyYW1ldGVyICdwb3NpdGlvbicgY2Fubm90IGJlIGxlc3MgdGhhbiAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocG9zaXRpb24gPj0gYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5CeXRlU3RyZWFtOiBwYXJhbWV0ZXIgJ3Bvc2l0aW9uJyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICdieXRlQXJyYXknIGxlbmd0aFwiO1xuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ieXRlQXJyYXlQYXJzZXIgPSBieXRlQXJyYXlQYXJzZXI7XG4gICAgICAgIHRoaXMuYnl0ZUFycmF5ID0gYnl0ZUFycmF5O1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gPyBwb3NpdGlvbiA6IDA7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTsgLy8gYXJyYXkgb2Ygc3RyaW5nIHdhcm5pbmdzIGVuY291bnRlcmVkIHdoaWxlIHBhcnNpbmdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2FmZWx5IHNlZWtzIHRocm91Z2ggdGhlIGJ5dGUgc3RyZWFtLiAgV2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdFxuICAgICAqIGlzIG1hZGUgdG8gc2VlayBvdXRzaWRlIG9mIHRoZSBieXRlIGFycmF5LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgdGhlIG51bWJlciBvZiBieXRlcyB0byBhZGQgdG8gdGhlIHBvc2l0aW9uXG4gICAgICogQHRocm93cyBlcnJvciBpZiBzZWVrIHdvdWxkIGNhdXNlIHBvc2l0aW9uIHRvIGJlIG91dHNpZGUgb2YgdGhlIGJ5dGVBcnJheVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbihvZmZzZXQpXG4gICAge1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uICsgb2Zmc2V0IDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5zZWVrOiBjYW5ub3Qgc2VlayB0byBwb3NpdGlvbiA8IDBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IG9mZnNldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBCeXRlU3RyZWFtIG9iamVjdCBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBvZiB0aGUgcmVxdWVzdGVkIG51bWJlciBvZiBieXRlc1xuICAgICAqIEBwYXJhbSBudW1CeXRlcyB0aGUgbGVuZ3RoIG9mIHRoZSBieXRlIGFycmF5IGZvciB0aGUgQnl0ZVN0cmVhbSB0byBjb250YWluXG4gICAgICogQHJldHVybnMge2RpY29tUGFyc2VyLkJ5dGVTdHJlYW19XG4gICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkQnl0ZVN0cmVhbSA9IGZ1bmN0aW9uKG51bUJ5dGVzKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5wb3NpdGlvbiArIG51bUJ5dGVzID4gdGhpcy5ieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZEJ5dGVTdHJlYW06IHJlYWRCeXRlU3RyZWFtIC0gYnVmZmVyIG92ZXJyZWFkJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZUFycmF5VmlldyA9IGRpY29tUGFyc2VyLnNoYXJlZENvcHkodGhpcy5ieXRlQXJyYXksIHRoaXMucG9zaXRpb24sIG51bUJ5dGVzKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBudW1CeXRlcztcbiAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKHRoaXMuYnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXlWaWV3KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQYXJzZXMgYW4gdW5zaWduZWQgaW50IDE2IGZyb20gYSBieXRlIGFycmF5IGFuZCBhZHZhbmNlc1xuICAgICAqIHRoZSBwb3NpdGlvbiBieSAyIGJ5dGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMTZcbiAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50MTYgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ieXRlQXJyYXlQYXJzZXIucmVhZFVpbnQxNih0aGlzLmJ5dGVBcnJheSwgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIHVuc2lnbmVkIGludCAzMiBmcm9tIGEgYnl0ZSBhcnJheSBhbmQgYWR2YW5jZXNcbiAgICAgKiB0aGUgcG9zaXRpb24gYnkgMiBieXRlc1xuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZSB1bnNpZ25lZCBpbnQgMzJcbiAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ieXRlQXJyYXlQYXJzZXIucmVhZFVpbnQzMih0aGlzLmJ5dGVBcnJheSwgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBzdHJpbmcgb2YgOC1iaXQgY2hhcmFjdGVycyBmcm9tIGFuIGFycmF5IG9mIGJ5dGVzIGFuZCBhZHZhbmNlc1xuICAgICAqIHRoZSBwb3NpdGlvbiBieSBsZW5ndGggYnl0ZXMuICBBIG51bGwgdGVybWluYXRvciB3aWxsIGVuZCB0aGUgc3RyaW5nXG4gICAgICogYnV0IHdpbGwgbm90IGVmZmVjdCBhZHZhbmNlbWVudCBvZiB0aGUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIGxlbmd0aCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcGFyc2VkIHN0cmluZ1xuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZEZpeGVkU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKVxuICAgIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyh0aGlzLmJ5dGVBcnJheSwgdGhpcy5wb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICpcbiAqIFRoZSBEYXRhU2V0IGNsYXNzIGVuY2Fwc3VsYXRlcyBhIGNvbGxlY3Rpb24gb2YgRElDT00gRWxlbWVudHMgYW5kIHByb3ZpZGVzIHZhcmlvdXMgZnVuY3Rpb25zXG4gKiB0byBhY2Nlc3MgdGhlIGRhdGEgaW4gdGhvc2UgZWxlbWVudHNcbiAqXG4gKiBSdWxlcyBmb3IgaGFuZGxpbmcgcGFkZGVkIHNwYWNlczpcbiAqIERTID0gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gKiBEVCA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICogSVMgPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIFBOID0gU3RyaXAgdHJhaWxpbmcgc3BhY2VzXG4gKiBUTSA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICogQUUgPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIENTID0gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gKiBTSCA9IFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICogTE8gPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIExUID0gU3RyaXAgdHJhaWxpbmcgc3BhY2VzXG4gKiBTVCA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICogVVQgPSBTdHJpcCB0cmFpbGluZyBzcGFjZXNcbiAqXG4gKi9cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCeXRlQXJyYXlQYXJzZXIoZWxlbWVudCwgZGVmYXVsdFBhcnNlcilcbiAgICB7XG4gICAgICAgIHJldHVybiAoZWxlbWVudC5wYXJzZXIgIT09IHVuZGVmaW5lZCA/IGVsZW1lbnQucGFyc2VyIDogZGVmYXVsdFBhcnNlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBEYXRhU2V0IGdpdmVuIGJ5dGVBcnJheSBhbmQgY29sbGVjdGlvbiBvZiBlbGVtZW50c1xuICAgICAqIEBwYXJhbSBieXRlQXJyYXlQYXJzZXJcbiAgICAgKiBAcGFyYW0gYnl0ZUFycmF5XG4gICAgICogQHBhcmFtIGVsZW1lbnRzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldCA9IGZ1bmN0aW9uKGJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5LCBlbGVtZW50cylcbiAgICB7XG4gICAgICAgIHRoaXMuYnl0ZUFycmF5UGFyc2VyID0gYnl0ZUFycmF5UGFyc2VyO1xuICAgICAgICB0aGlzLmJ5dGVBcnJheSA9IGJ5dGVBcnJheTtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGFuIHVuc2lnbmVkIGludCAxNiBpZiBpdCBleGlzdHMgYW5kIGhhcyBkYXRhXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgaW4gYSBtdWx0aXZhbHVlZCBlbGVtZW50LiAgRGVmYXVsdCBpcyBpbmRleCAwIGlmIG5vdCBzdXBwbGllZFxuICAgICAqIEByZXR1cm5zIHsqfSB1bnNpZ25lZCBpbnQgMTYgb3IgdW5kZWZpbmVkIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQgb3IgaGFzIGRhdGEgb2YgbGVuZ3RoIDBcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS51aW50MTYgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkVWludDE2KHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKjIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGFuIHNpZ25lZCBpbnQgMTYgaWYgaXQgZXhpc3RzIGFuZCBoYXMgZGF0YVxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIGluIGEgbXVsdGl2YWx1ZWQgZWxlbWVudC4gIERlZmF1bHQgaXMgaW5kZXggMCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiBAcmV0dXJucyB7Kn0gc2lnbmVkIGludCAxNiBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBoYXMgZGF0YSBvZiBsZW5ndGggMFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLmludDE2ID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCB0aGlzLmJ5dGVBcnJheVBhcnNlcikucmVhZEludDE2KHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKiAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgZm9yIHRhZyBhbmQgcmV0dXJucyBhbiB1bnNpZ25lZCBpbnQgMzIgaWYgaXQgZXhpc3RzIGFuZCBoYXMgZGF0YVxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIGluIGEgbXVsdGl2YWx1ZWQgZWxlbWVudC4gIERlZmF1bHQgaXMgaW5kZXggMCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiBAcmV0dXJucyB7Kn0gdW5zaWduZWQgaW50IDMyIG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCB0aGlzLmJ5dGVBcnJheVBhcnNlcikucmVhZFVpbnQzMih0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0ICsgKGluZGV4ICogNCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IGZvciB0YWcgYW5kIHJldHVybnMgYW4gc2lnbmVkIGludCAzMiBpZiBpdCBleGlzdHMgYW5kIGhhcyBkYXRhXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgaW4gYSBtdWx0aXZhbHVlZCBlbGVtZW50LiAgRGVmYXVsdCBpcyBpbmRleCAwIGlmIG5vdCBzdXBwbGllZFxuICAgICAqIEByZXR1cm5zIHsqfSBzaWduZWQgaW50IDMyIG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkSW50MzIodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCArIChpbmRleCAqIDQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGEgMzIgYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciAoVlI9RkwpIGlmIGl0IGV4aXN0cyBhbmQgaGFzIGRhdGFcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpbiBhIG11bHRpdmFsdWVkIGVsZW1lbnQuICBEZWZhdWx0IGlzIGluZGV4IDAgaWYgbm90IHN1cHBsaWVkXG4gICAgICogQHJldHVybnMgeyp9IGZsb2F0IG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkRmxvYXQodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCArIChpbmRleCAqIDQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGEgNjQgYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciAoVlI9RkQpIGlmIGl0IGV4aXN0cyBhbmQgaGFzIGRhdGFcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpbiBhIG11bHRpdmFsdWVkIGVsZW1lbnQuICBEZWZhdWx0IGlzIGluZGV4IDAgaWYgbm90IHN1cHBsaWVkXG4gICAgICogQHJldHVybnMgeyp9IGZsb2F0IG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGRvZXNuJ3QgaGFzIGRhdGEgb2YgbGVuZ3RoIDBcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkRG91YmxlKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKiA4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHN0cmluZyB2YWx1ZXMgZm9yIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHJldHVybnMgeyp9IHRoZSBudW1iZXIgb2Ygc3RyaW5nIHZhbHVlcyBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBoYXMgemVybyBsZW5ndGggZGF0YVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLm51bVN0cmluZ1ZhbHVlcyA9IGZ1bmN0aW9uKHRhZylcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpeGVkU3RyaW5nID0gZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQsIGVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBudW1NYXRjaGluZyA9IGZpeGVkU3RyaW5nLm1hdGNoKC9cXFxcL2cpO1xuICAgICAgICAgICAgaWYobnVtTWF0Y2hpbmcgPT09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtTWF0Y2hpbmcubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIGZvciB0aGUgZWxlbWVudC4gIElmIGluZGV4IGlzIHByb3ZpZGVkLCB0aGUgZWxlbWVudCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICogbXVsdGktdmFsdWVkIGFuZCB3aWxsIHJldHVybiB0aGUgY29tcG9uZW50IHNwZWNpZmllZCBieSBpbmRleC4gIFVuZGVmaW5lZCBpcyByZXR1cm5lZFxuICAgICAqIGlmIHRoZXJlIGlzIG5vIGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXgsIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IG9yIGlzIHplcm8gbGVuZ3RoLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZnVuY3Rpb24gZm9yIFZSIHR5cGVzIG9mIEFFLCBDUywgU0ggYW5kIExPXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSBkZXNpcmVkIHZhbHVlIGluIGEgbXVsdGkgdmFsdWVkIHN0cmluZyBvciB1bmRlZmluZWQgZm9yIHRoZSBlbnRpcmUgc3RyaW5nXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpeGVkU3RyaW5nID0gZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQsIGVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmKGluZGV4ID49IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGZpeGVkU3RyaW5nLnNwbGl0KCdcXFxcJyk7XG4gICAgICAgICAgICAgICAgLy8gdHJpbSB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2luZGV4XS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gdHJpbSB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWRTdHJpbmcudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgbGVhZGluZyBzcGFjZXMgcHJlc2VydmVkIGFuZCB0cmFpbGluZyBzcGFjZXMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGFjY2VzcyBkYXRhIGZvciBWUnMgb2YgdHlwZSBVVCwgU1QgYW5kIExUXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFnXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaXhlZFN0cmluZyA9IGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyh0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0LCBlbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZihpbmRleCA+PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBmaXhlZFN0cmluZy5zcGxpdCgnXFxcXCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaW5kZXhdLnJlcGxhY2UoLyArJC8sICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWRTdHJpbmcucmVwbGFjZSgvICskLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHN0cmluZyB0byBhIGZsb2F0IGZvciB0aGUgc3BlY2lmaWVkIGluZGV4IGluIGEgbXVsdGktdmFsdWVkIGVsZW1lbnQuICBJZiBpbmRleCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIHRoZSBmaXJzdCB2YWx1ZSBpbiBhIG11bHRpLXZhbHVlZCBWUiB3aWxsIGJlIHBhcnNlZCBpZiBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIGRlc2lyZWQgdmFsdWUgaW4gYSBtdWx0aSB2YWx1ZWQgc3RyaW5nIG9yIHVuZGVmaW5lZCBmb3IgdGhlIGZpcnN0IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9IGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBub3QgcHJlc2VudCBvciBkYXRhIG5vdCBsb25nIGVub3VnaFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLmZsb2F0U3RyaW5nID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0cmluZyh0YWcsIGluZGV4KTtcbiAgICAgICAgICAgIGlmKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc3RyaW5nIHRvIGFuIGludGVnZXIgZm9yIHRoZSBzcGVjaWZpZWQgaW5kZXggaW4gYSBtdWx0aS12YWx1ZWQgZWxlbWVudC4gIElmIGluZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogdGhlIGZpcnN0IHZhbHVlIGluIGEgbXVsdGktdmFsdWVkIFZSIHdpbGwgYmUgcGFyc2VkIGlmIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgZGVzaXJlZCB2YWx1ZSBpbiBhIG11bHRpIHZhbHVlZCBzdHJpbmcgb3IgdW5kZWZpbmVkIGZvciB0aGUgZmlyc3QgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gYW4gaW50ZWdlciBvciB1bmRlZmluZWQgaWYgbm90IHByZXNlbnQgb3IgZGF0YSBub3QgbG9uZyBlbm91Z2hcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5pbnRTdHJpbmcgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RyaW5nKHRhZywgaW5kZXgpO1xuICAgICAgICAgICAgaWYodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLy9kaWNvbVBhcnNlci5EYXRhU2V0ID0gRGF0YVNldDtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIHJlYWRzIGZyb20gdGhlIGJ5dGUgc3RyZWFtIHVudGlsIGl0IGZpbmRzIHRoZSBtYWdpYyBudW1iZXIgZm9yIHRoZSBTZXF1ZW5jZSBEZWxpbWl0YXRpb24gSXRlbSBpdGVtXG4gICAqIGFuZCB0aGVuIHNldHMgdGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0gYnl0ZVN0cmVhbVxuICAgKiBAcGFyYW0gZWxlbWVudFxuICAgKi9cbiAgZGljb21QYXJzZXIuZmluZEFuZFNldFVORWxlbWVudExlbmd0aCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIGVsZW1lbnQpXG4gIHtcbiAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5maW5kQW5kU2V0VU5FbGVtZW50TGVuZ3RoOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICB9XG5cbiAgICB2YXIgaXRlbURlbGltaXRhdGlvbkl0ZW1MZW5ndGggPSA4OyAvLyBncm91cCwgZWxlbWVudCwgbGVuZ3RoXG4gICAgdmFyIG1heFBvc2l0aW9uID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gaXRlbURlbGltaXRhdGlvbkl0ZW1MZW5ndGg7XG4gICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8PSBtYXhQb3NpdGlvbilcbiAgICB7XG4gICAgICB2YXIgZ3JvdXBOdW1iZXI7XG4gICAgICBncm91cE51bWJlciA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgICAgaWYoZ3JvdXBOdW1iZXIgPT09IDB4ZmZmZSlcbiAgICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnROdW1iZXI7XG4gICAgICAgIGVsZW1lbnROdW1iZXIgPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgICAgaWYoZWxlbWVudE51bWJlciA9PT0gMHhlMGRkKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gTk9URTogSXQgd291bGQgYmUgYmV0dGVyIHRvIGFsc28gY2hlY2sgZm9yIHRoZSBsZW5ndGggdG8gYmUgMCBhcyBwYXJ0IG9mIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICAgIC8vIGJ1dCB3ZSB3aWxsIGp1c3QgbG9nIGEgd2FybmluZyBmb3Igbm93XG4gICAgICAgICAgdmFyIGl0ZW1EZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgaXRlbURlbGltaXRlckxlbmd0aCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpOyAvLyB0aGUgbGVuZ3RoXG4gICAgICAgICAgaWYoaXRlbURlbGltaXRlckxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncygnZW5jb3VudGVyZWQgbm9uIHplcm8gbGVuZ3RoIGZvbGxvd2luZyBpdGVtIGRlbGltaXRlciBhdCBwb3NpdGlvbicgKyBieXRlU3RyZWFtLnBvc2l0aW9uIC0gNCArIFwiIHdoaWxlIHJlYWRpbmcgZWxlbWVudCBvZiB1bmRlZmluZWQgbGVuZ3RoIHdpdGggdGFnICcgKyBlbGVtZW50LnRhZ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIGl0ZW0gZGVsaW1pdGF0aW9uIGl0ZW0gLSBzaWxlbnRseSBzZXQgdGhlIGxlbmd0aCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIgYW5kIHNldCB0aGUgcG9zaXRpb24gcGFzdCB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICBieXRlU3RyZWFtLnNlZWsoYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gYnl0ZVN0cmVhbS5wb3NpdGlvbik7XG4gIH07XG5cblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGEgZWxlbWVudCBhbmQgYWRkcyBhbiBhcnJheSBvZiBmcmFnbWVudHMgdG8gdGhlIGVsZW1lbnRcbiAgICAgKiBjb250YWluaW5nIHRoZSBvZmZzZXQgYW5kIGxlbmd0aCBvZiBlYWNoIGZyYWdtZW50IGFuZCBhbnkgb2Zmc2V0cyBmcm9tIHRoZSBiYXNpYyBvZmZzZXRcbiAgICAgKiB0YWJsZVxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5maW5kRW5kT2ZFbmNhcHN1bGF0ZWRFbGVtZW50ID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuZmluZEVuZE9mRW5jYXBzdWxhdGVkRWxlbWVudDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmZpbmRFbmRPZkVuY2Fwc3VsYXRlZEVsZW1lbnQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdlbGVtZW50J1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5lbmNhcHN1bGF0ZWRQaXhlbERhdGEgPSB0cnVlO1xuICAgICAgICBlbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUgPSBbXTtcbiAgICAgICAgZWxlbWVudC5mcmFnbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGJhc2ljT2Zmc2V0VGFibGVJdGVtVGFnID0gZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKTtcbiAgICAgICAgaWYoYmFzaWNPZmZzZXRUYWJsZUl0ZW1UYWcgIT09ICd4ZmZmZWUwMDAnKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmZpbmRFbmRPZkVuY2Fwc3VsYXRlZEVsZW1lbnQ6IGJhc2ljIG9mZnNldCB0YWJsZSBub3QgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzaWNPZmZzZXRUYWJsZUl0ZW1sZW5ndGggPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICAgICAgdmFyIG51bUZyYWdtZW50cyA9IGJhc2ljT2Zmc2V0VGFibGVJdGVtbGVuZ3RoIC8gNDtcbiAgICAgICAgZm9yKHZhciBpID0wOyBpIDwgbnVtRnJhZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYmFzaWNPZmZzZXRUYWJsZS5wdXNoKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VPZmZzZXQgPSBieXRlU3RyZWFtLnBvc2l0aW9uO1xuXG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgaWYodGFnID09PSAneGZmZmVlMGRkJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0YWcgPT09ICd4ZmZmZWUwMDAnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZnJhZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBiYXNlT2Zmc2V0IC0gOCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gOiBieXRlU3RyZWFtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggOiBsZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHdhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goJ3VuZXhwZWN0ZWQgdGFnICcgKyB0YWcgKyAnIHdoaWxlIHNlYXJjaGluZyBmb3IgZW5kIG9mIHBpeGVsIGRhdGEgZWxlbWVudCB3aXRoIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYobGVuZ3RoID4gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gYnl0ZVN0cmVhbS5wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gYnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5mcmFnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGJhc2VPZmZzZXQgLSA4LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA6IGJ5dGVTdHJlYW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA6IGxlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlayhsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlayhsZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYod2FybmluZ3MpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goXCJwaXhlbCBkYXRhIGVsZW1lbnQgXCIgKyBlbGVtZW50LnRhZyArIFwiIG1pc3Npbmcgc2VxdWVuY2UgZGVsaW1pdGVyIHRhZyB4ZmZmZWUwZGRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVhZHMgZnJvbSB0aGUgYnl0ZSBzdHJlYW0gdW50aWwgaXQgZmluZHMgdGhlIG1hZ2ljIG51bWJlcnMgZm9yIHRoZSBpdGVtIGRlbGltaXRhdGlvbiBpdGVtXG4gICAgICogYW5kIHRoZW4gc2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW1cbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmZpbmRJdGVtRGVsaW1pdGF0aW9uSXRlbUFuZFNldEVsZW1lbnRMZW5ndGggPSBmdW5jdGlvbihieXRlU3RyZWFtLCBlbGVtZW50KVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRJbXBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbURlbGltaXRhdGlvbkl0ZW1MZW5ndGggPSA4OyAvLyBncm91cCwgZWxlbWVudCwgbGVuZ3RoXG4gICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGl0ZW1EZWxpbWl0YXRpb25JdGVtTGVuZ3RoO1xuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDw9IG1heFBvc2l0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOdW1iZXIgPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGlmKGdyb3VwTnVtYmVyID09PSAweGZmZmUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnROdW1iZXIgPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50TnVtYmVyID09PSAweGUwMGQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBJdCB3b3VsZCBiZSBiZXR0ZXIgdG8gYWxzbyBjaGVjayBmb3IgdGhlIGxlbmd0aCB0byBiZSAwIGFzIHBhcnQgb2YgdGhlIGNoZWNrIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSB3aWxsIGp1c3QgbG9nIGEgd2FybmluZyBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtRGVsaW1pdGVyTGVuZ3RoID0gYnl0ZVN0cmVhbS5yZWFkVWludDMyKCk7IC8vIHRoZSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbURlbGltaXRlckxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncygnZW5jb3VudGVyZWQgbm9uIHplcm8gbGVuZ3RoIGZvbGxvd2luZyBpdGVtIGRlbGltaXRlciBhdCBwb3NpdGlvbicgKyBieXRlU3RyZWFtLnBvc2l0aW9uIC0gNCArIFwiIHdoaWxlIHJlYWRpbmcgZWxlbWVudCBvZiB1bmRlZmluZWQgbGVuZ3RoIHdpdGggdGFnICcgKyBlbGVtZW50LnRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBpdGVtIGRlbGltaXRhdGlvbiBpdGVtIC0gc2lsZW50bHkgc2V0IHRoZSBsZW5ndGggdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGFuZCBzZXQgdGhlIHBvc2l0aW9uIHBhc3QgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICBieXRlU3RyZWFtLnNlZWsoYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gYnl0ZVN0cmVhbS5wb3NpdGlvbik7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIGRpZmZlcmVudCB0eXBlcyBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcnNlcyBhbiB1bnNpZ25lZCBpbnQgMTYgZnJvbSBhIGxpdHRsZS1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMTZcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkVWludDE2OiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQxNjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDIgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDE2OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBieXRlQXJyYXlbcG9zaXRpb25dICsgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdICogMjU2KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyc2VzIGEgc2lnbmVkIGludCAxNiBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHNpZ25lZCBpbnQgMTZcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkSW50MTY6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MTY6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyAyID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDE2OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnQxNiA9IGJ5dGVBcnJheVtwb3NpdGlvbl0gKyAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gPDwgOCk7XG4gICAgICAgICAgICAvLyBmaXggc2lnblxuICAgICAgICAgICAgaWYgKGludDE2ICYgMHg4MDAwKSB7XG4gICAgICAgICAgICAgICAgaW50MTYgPSBpbnQxNiAtIDB4RkZGRiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50MTY7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGFuIHVuc2lnbmVkIGludCAzMiBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHVuc2lnbmVkIGludCAzMlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRVaW50MzI6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDMyOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQzMjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1aW50MzIgPSAoYnl0ZUFycmF5W3Bvc2l0aW9uXSArXG4gICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gKiAyNTYpICtcbiAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAyXSAqIDI1NiAqIDI1NikgK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdICogMjU2ICogMjU2ICogMjU2ICkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdWludDMyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYSBzaWduZWQgaW50IDMyIGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgdW5zaWduZWQgaW50IDMyXG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEludDMyOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDMyOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDMyOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGludDMyID0gKGJ5dGVBcnJheVtwb3NpdGlvbl0gK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdIDw8IDgpICtcbiAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAyXSA8PCAxNikgK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdIDw8IDI0KSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnQzMjtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgMzItYml0IGZsb2F0IGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgMzItYml0IGZsb2F0XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEZsb2F0OiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEZsb2F0OiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEZsb2F0OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSSBhbSBzdXJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0aGFuIHRoaXMgYnV0IHRoaXMgc2hvdWxkIGJlIHNhZmVcbiAgICAgICAgICAgIHZhciBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFswXSA9IGJ5dGVBcnJheVtwb3NpdGlvbl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsyXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzNdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgM107XG4gICAgICAgICAgICB2YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0LmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIDY0LWJpdCBmbG9hdCBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIDY0LWJpdCBmbG9hdFxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRG91YmxlOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA4ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZERvdWJsZTogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEkgYW0gc3VyZSB0aGVyZSBpcyBhIGJldHRlciB3YXkgdGhhbiB0aGlzIGJ1dCB0aGlzIHNob3VsZCBiZSBzYWZlXG4gICAgICAgICAgICB2YXIgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMF0gPSBieXRlQXJyYXlbcG9zaXRpb25dO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzFdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMl0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAyXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFszXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzRdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgNF07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbNV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA1XTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs2XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDZdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzddID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgN107XG4gICAgICAgICAgICB2YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDY0QXJyYXkoYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0LmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgaW1wbGljaXQgYW5kIGV4cGxpY2l0IERJQ09NIGRhdGEgc2V0c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZWFkcyBhbiBleHBsaWNpdCBkYXRhIHNldFxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtIHRoZSBieXRlIHN0cmVhbSB0byByZWFkIGZyb21cbiAgICAgKiBAcGFyYW0gbWF4UG9zaXRpb24gdGhlIG1heGltdW0gcG9zaXRpb24gdG8gcmVhZCB1cCB0byAob3B0aW9uYWwgLSBvbmx5IG5lZWRlZCB3aGVuIHJlYWRpbmcgc2VxdWVuY2UgaXRlbXMpXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRFeHBsaWNpdCA9IGZ1bmN0aW9uIChkYXRhU2V0LCBieXRlU3RyZWFtLCBtYXhQb3NpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgICAgIG1heFBvc2l0aW9uID0gKG1heFBvc2l0aW9uID09PSB1bmRlZmluZWQpID8gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIDogbWF4UG9zaXRpb24gO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRFeHBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWF4UG9zaXRpb24gPCBieXRlU3RyZWFtLnBvc2l0aW9uIHx8IG1heFBvc2l0aW9uID4gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQ6IGludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnbWF4UG9zaXRpb24nXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZGF0YVNldC5lbGVtZW50cztcblxuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgbWF4UG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGRhdGFTZXQud2FybmluZ3MsIG9wdGlvbnMudW50aWxUYWcpO1xuICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudC50YWddID0gZWxlbWVudDtcbiAgICAgICAgICAgIGlmKGVsZW1lbnQudGFnID09PSBvcHRpb25zLnVudGlsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0ucG9zaXRpb24gPiBtYXhQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlcjpwYXJzZURpY29tRGF0YVNldEV4cGxpY2l0OiBidWZmZXIgb3ZlcnJ1blwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlYWRzIGFuIGltcGxpY2l0IGRhdGEgc2V0XG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW0gdGhlIGJ5dGUgc3RyZWFtIHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBtYXhQb3NpdGlvbiB0aGUgbWF4aW11bSBwb3NpdGlvbiB0byByZWFkIHVwIHRvIChvcHRpb25hbCAtIG9ubHkgbmVlZGVkIHdoZW4gcmVhZGluZyBzZXF1ZW5jZSBpdGVtcylcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEltcGxpY2l0ID0gZnVuY3Rpb24oZGF0YVNldCwgYnl0ZVN0cmVhbSwgbWF4UG9zaXRpb24sIG9wdGlvbnMpXG4gICAge1xuICAgICAgICBtYXhQb3NpdGlvbiA9IChtYXhQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSA/IGRhdGFTZXQuYnl0ZUFycmF5Lmxlbmd0aCA6IG1heFBvc2l0aW9uIDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0SW1wbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKG1heFBvc2l0aW9uIDwgYnl0ZVN0cmVhbS5wb3NpdGlvbiB8fCBtYXhQb3NpdGlvbiA+IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEltcGxpY2l0OiBpbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ21heFBvc2l0aW9uJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZGF0YVNldC5lbGVtZW50cztcblxuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgbWF4UG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0KGJ5dGVTdHJlYW0sIG9wdGlvbnMudW50aWxUYWcsIG9wdGlvbnMudnJDYWxsYmFjayk7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuICAgICAgICAgICAgaWYoZWxlbWVudC50YWcgPT09IG9wdGlvbnMudW50aWxUYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGFMZW5ndGhTaXplSW5CeXRlc0ZvclZSKHZyKVxuICAgIHtcbiAgICAgICAgaWYoIHZyID09PSAnT0InIHx8XG4gICAgICAgICAgICB2ciA9PT0gJ09XJyB8fFxuICAgICAgICAgICAgdnIgPT09ICdTUScgfHxcbiAgICAgICAgICAgIHZyID09PSAnT0YnIHx8XG4gICAgICAgICAgICB2ciA9PT0gJ1VUJyB8fFxuICAgICAgICAgICAgdnIgPT09ICdVTicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50RXhwbGljaXQgPSBmdW5jdGlvbihieXRlU3RyZWFtLCB3YXJuaW5ncywgdW50aWxUYWcpXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEV4cGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgdGFnIDogZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKSxcbiAgICAgICAgICAgIHZyIDogYnl0ZVN0cmVhbS5yZWFkRml4ZWRTdHJpbmcoMilcbiAgICAgICAgICAgIC8vIGxlbmd0aCBzZXQgYmVsb3cgYmFzZWQgb24gVlJcbiAgICAgICAgICAgIC8vIGRhdGFPZmZzZXQgc2V0IGJlbG93IGJhc2VkIG9uIFZSIGFuZCBzaXplIG9mIGxlbmd0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkYXRhTGVuZ3RoU2l6ZUJ5dGVzID0gZ2V0RGF0YUxlbmd0aFNpemVJbkJ5dGVzRm9yVlIoZWxlbWVudC52cik7XG4gICAgICAgIGlmKGRhdGFMZW5ndGhTaXplQnl0ZXMgPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICBlbGVtZW50LmRhdGFPZmZzZXQgPSBieXRlU3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKDIpO1xuICAgICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIGVsZW1lbnQuZGF0YU9mZnNldCA9IGJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgZWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZWxlbWVudC50YWcgPT09IHVudGlsVGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIFZSIGlzIFNRLCBwYXJzZSB0aGUgc2VxdWVuY2UgaXRlbXNcbiAgICAgICAgaWYoZWxlbWVudC52ciA9PT0gJ1NRJylcbiAgICAgICAge1xuICAgICAgICAgICAgZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNFeHBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncyk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYoZWxlbWVudC5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKGVsZW1lbnQudGFnID09PSAneDdmZTAwMDEwJykge1xuICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLmZpbmRFbmRPZkVuY2Fwc3VsYXRlZEVsZW1lbnQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfSAgIGVsc2UgaWYoZWxlbWVudC52ciA9PT0gJ1VOJykge1xuICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLmZpbmRBbmRTZXRVTkVsZW1lbnRMZW5ndGgoYnl0ZVN0cmVhbSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy9kaWNvbVBhcnNlci5maW5kSXRlbURlbGltaXRhdGlvbkl0ZW1BbmRTZXRFbGVtZW50TGVuZ3RoKGJ5dGVTdHJlYW0sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKGVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTZXF1ZW5jZShlbGVtZW50LCBieXRlU3RyZWFtLCB2ckNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGlmIGEgZGF0YSBkaWN0aW9uYXJ5IGNhbGxiYWNrIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gdmVyaWZ5IHRoYXQgdGhlIGVsZW1lbnQgaXMgYSBzZXF1ZW5jZS5cbiAgICAgICAgaWYgKHR5cGVvZiB2ckNhbGxiYWNrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuICh2ckNhbGxiYWNrKGVsZW1lbnQudGFnKSA9PT0gJ1NRJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChieXRlU3RyZWFtLnBvc2l0aW9uICsgNCkgPD0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRhZyA9IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSk7XG4gICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoLTQpO1xuICAgICAgICAgICAgLy8gSXRlbSBzdGFydCB0YWcgKGZmZmUsZTAwMCkgb3Igc2VxdWVuY2UgZGVsaW1pdGVyIChpLmUuIGVuZCBvZiBzZXF1ZW5jZSkgdGFnICgwZmZmZSxlMGRkKVxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSB0YWdzIHRoYXQgY291bGQgcG90ZW50aWFsbHkgYmUgZm91bmQgZGlyZWN0bHkgYWZ0ZXIgYSBzZXF1ZW5jZSBzdGFydCB0YWcgKHRoZSBkZWxpbWl0ZXJcbiAgICAgICAgICAgIC8vIGlzIGZvdW5kIGluIHRoZSBjYXNlIG9mIGFuIGVtcHR5IHNlcXVlbmNlKS4gVGhpcyBpcyBub3QgMTAwJSBzYWZlIGJlY2F1c2UgYSBub24tc2VxdWVuY2UgaXRlbVxuICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBkYXRhIHRoYXQgaGFzIHRoZXNlIGJ5dGVzLCBidXQgdGhpcyBpcyBob3cgdG8gZG8gaXQgd2l0aG91dCBhIGRhdGEgZGljdGlvbmFyeS5cbiAgICAgICAgICAgIHJldHVybiAobmV4dFRhZyA9PT0gJ3hmZmZlZTAwMCcpIHx8IChuZXh0VGFnID09PSAneGZmZmVlMGRkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgc2VxdWVuY2UgaXRlbSB0YWcgb3Igc2VxdWVuY2UgZGVsaW1pdGVyIHRhZyBpbiBwZWVraW5nIHRvIGRldGVybWluZSBWUicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0ID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgdW50aWxUYWcsIHZyQ2FsbGJhY2spXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgdGFnIDogZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKSxcbiAgICAgICAgICAgIGxlbmd0aDogYnl0ZVN0cmVhbS5yZWFkVWludDMyKCksXG4gICAgICAgICAgICBkYXRhT2Zmc2V0IDogIGJ5dGVTdHJlYW0ucG9zaXRpb25cbiAgICAgICAgfTtcblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgZWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZWxlbWVudC50YWcgPT09IHVudGlsVGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NlcXVlbmNlKGVsZW1lbnQsIGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spKSB7XG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGVsZW1lbnQgaXMgbm90IGEgc2VxdWVuY2UgYW5kIGhhcyB1bmRlZmluZWQgbGVuZ3RoLCB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIHNjYW4gdGhlIGRhdGEgZm9yIGEgbWFnaWMgbnVtYmVyIHRvIGZpZ3VyZSBvdXQgd2hlbiBpdCBlbmRzLlxuICAgICAgICBpZihlbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgZGljb21QYXJzZXIuZmluZEl0ZW1EZWxpbWl0YXRpb25JdGVtQW5kU2V0RWxlbWVudExlbmd0aChieXRlU3RyZWFtLCBlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9uIHNlcXVlbmNlIGVsZW1lbnQgd2l0aCBrbm93biBsZW5ndGgsIHNraXAgb3ZlciB0aGUgZGF0YSBwYXJ0XG4gICAgICAgIGJ5dGVTdHJlYW0uc2VlayhlbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogRnVuY3Rpb25hbGl0eSBmb3IgZXh0cmFjdGluZyBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEZyYWdtZW50SW5kZXhXaXRoT2Zmc2V0KGZyYWdtZW50cywgb2Zmc2V0KSB7XG4gICAgZm9yKHZhciBpPTA7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGZyYWdtZW50c1tpXS5vZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVOdW1iZXJPZkZyYWdtZW50c0ZvckZyYW1lKGZyYW1lSW5kZXgsIGJhc2ljT2Zmc2V0VGFibGUsIGZyYWdtZW50cywgc3RhcnRGcmFnbWVudEluZGV4KSB7XG4gICAgLy8gc3BlY2lhbCBjYXNlIGZvciBsYXN0IGZyYW1lXG4gICAgaWYoZnJhbWVJbmRleCA9PT0gYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGggLTEpIHtcbiAgICAgIHJldHVybiBmcmFnbWVudHMubGVuZ3RoIC0gc3RhcnRGcmFnbWVudEluZGV4O1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIGZyYWdtZW50IGxvb2tpbmcgZm9yIHRoZSBvbmUgbWF0Y2hpbmcgdGhlIG9mZnNldCBmb3IgdGhlIG5leHQgZnJhbWVcbiAgICB2YXIgbmV4dEZyYW1lT2Zmc2V0ID0gYmFzaWNPZmZzZXRUYWJsZVtmcmFtZUluZGV4ICsgMV07XG4gICAgZm9yKHZhciBpPXN0YXJ0RnJhZ21lbnRJbmRleCArIDE7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGZyYWdtZW50c1tpXS5vZmZzZXQgPT09IG5leHRGcmFtZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gaSAtIHN0YXJ0RnJhZ21lbnRJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNhbGN1bGF0ZU51bWJlck9mRnJhZ21lbnRzRm9yRnJhbWU6IGNvdWxkIG5vdCBmaW5kIGZyYWdtZW50IHdpdGggb2Zmc2V0IG1hdGNoaW5nIGJhc2ljIG9mZnNldCB0YWJsZVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpeGVsIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgZnJhbWUgaW4gYW4gZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGhhcyBhIG5vblxuICAgKiBlbXB0eSBiYXNpYyBvZmZzZXQgdGFibGUuICBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIGZhaWwgaWYgdGhlIGJhc2ljIG9mZnNldCB0YWJsZSBpcyBlbXB0eSAtIGluIHRoYXRcbiAgICogY2FzZSB5b3UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2ggZnJhZ21lbnRzIG1hcCB0byB3aGljaCBmcmFtZXMgYW5kIHJlYWQgdGhlbSB1c2luZ1xuICAgKiByZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50cygpLiAgQWxzbyBzZWUgdGhlIGZ1bmN0aW9uIGNyZWF0ZUpFUEdCYXNpY09mZnNldFRhYmxlKCkgdG8gc2VlXG4gICAqIGhvdyBhIGJhc2ljIG9mZnNldCB0YWJsZSBjYW4gYmUgY3JlYXRlZCBmb3IgSlBFRyBpbWFnZXNcbiAgICpcbiAgICogQHBhcmFtIGRhdGFTZXQgLSB0aGUgZGF0YVNldCBjb250YWluaW5nIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgKiBAcGFyYW0gcGl4ZWxEYXRhRWxlbWVudCAtIHRoZSBwaXhlbCBkYXRhIGVsZW1lbnQgKHg3ZmUwMDAxMCkgdG8gZXh0cmFjdCB0aGUgZnJhbWUgZnJvbVxuICAgKiBAcGFyYW0gZnJhbWVJbmRleCAtIHRoZSB6ZXJvIGJhc2VkIGZyYW1lIGluZGV4XG4gICAqIEBwYXJhbSBbYmFzaWNPZmZzZXRUYWJsZV0gLSBvcHRpb25hbCBhcnJheSBvZiBzdGFydGluZyBvZmZzZXRzIGZvciBmcmFtZXNcbiAgICogQHBhcmFtIFtmcmFnbWVudHNdIC0gb3B0aW9uYWwgYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGVhY2ggZnJhZ21lbnQgKG9mZnNldCwgcG9zaXRpb24sIGxlbmd0aClcbiAgICogQHJldHVybnMge29iamVjdH0gd2l0aCB0aGUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAgICovXG4gIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lID0gZnVuY3Rpb24oZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhbWVJbmRleCwgYmFzaWNPZmZzZXRUYWJsZSwgZnJhZ21lbnRzKVxuICB7XG4gICAgLy8gZGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgYmFzaWNPZmZzZXRUYWJsZSA9IGJhc2ljT2Zmc2V0VGFibGUgfHwgcGl4ZWxEYXRhRWxlbWVudC5iYXNpY09mZnNldFRhYmxlO1xuICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cyB8fCBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cztcblxuICAgIC8vIFZhbGlkYXRlIHBhcmFtZXRlcnNcbiAgICBpZihkYXRhU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdkYXRhU2V0J1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50J1wiO1xuICAgIH1cbiAgICBpZihmcmFtZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdmcmFtZUluZGV4J1wiO1xuICAgIH1cbiAgICBpZihiYXNpY09mZnNldFRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgZG9lcyBub3QgaGF2ZSBiYXNpY09mZnNldFRhYmxlXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQudGFnICE9PSAneDdmZTAwMDEwJykge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gbm9uIHBpeGVsIGRhdGEgdGFnIChleHBlY3RlZCB0YWcgPSB4N2ZlMDAwMTAnXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZW5jYXBzdWxhdGVkUGl4ZWxEYXRhICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIHVuZGVmaW5lZCBsZW5ndGhcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBmcmFnbWVudHNcIjtcbiAgICB9XG4gICAgaWYoYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IGJhc2ljT2Zmc2V0VGFibGUgaGFzIHplcm8gZW50cmllc1wiO1xuICAgIH1cbiAgICBpZihmcmFtZUluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdmcmFtZUluZGV4JyBtdXN0IGJlID49IDBcIjtcbiAgICB9XG4gICAgaWYoZnJhbWVJbmRleCA+PSBiYXNpY09mZnNldFRhYmxlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdmcmFtZUluZGV4JyBtdXN0IGJlIDwgYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGhcIjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIHN0YXJ0aW5nIGZyYWdtZW50IGJhc2VkIG9uIHRoZSBvZmZzZXQgZm9yIHRoZSBmcmFtZSBpbiB0aGUgYmFzaWMgb2Zmc2V0IHRhYmxlXG4gICAgdmFyIG9mZnNldCA9IGJhc2ljT2Zmc2V0VGFibGVbZnJhbWVJbmRleF07XG4gICAgdmFyIHN0YXJ0RnJhZ21lbnRJbmRleCA9IGZpbmRGcmFnbWVudEluZGV4V2l0aE9mZnNldChmcmFnbWVudHMsIG9mZnNldCk7XG4gICAgaWYoc3RhcnRGcmFnbWVudEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHVuYWJsZSB0byBmaW5kIGZyYWdtZW50IHRoYXQgbWF0Y2hlcyBiYXNpYyBvZmZzZXQgdGFibGUgZW50cnlcIjtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoaXMgZnJhbWVcbiAgICB2YXIgbnVtRnJhZ21lbnRzID0gY2FsY3VsYXRlTnVtYmVyT2ZGcmFnbWVudHNGb3JGcmFtZShmcmFtZUluZGV4LCBiYXNpY09mZnNldFRhYmxlLCBmcmFnbWVudHMsIHN0YXJ0RnJhZ21lbnRJbmRleCk7XG5cbiAgICAvLyBub3cgZXh0cmFjdCB0aGUgZnJhbWUgZnJvbSB0aGUgZnJhZ21lbnRzXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIHN0YXJ0RnJhZ21lbnRJbmRleCwgbnVtRnJhZ21lbnRzLCBmcmFnbWVudHMpO1xuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcblxuLyoqXG4gKiBGdW5jdGlvbmFsaXR5IGZvciBleHRyYWN0aW5nIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVCdWZmZXJTaXplKGZyYWdtZW50cywgc3RhcnRGcmFnbWVudCwgbnVtRnJhZ21lbnRzKSB7XG4gICAgdmFyIGJ1ZmZlclNpemUgPSAwO1xuICAgIGZvcih2YXIgaT1zdGFydEZyYWdtZW50OyBpIDwgc3RhcnRGcmFnbWVudCArIG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICBidWZmZXJTaXplICs9IGZyYWdtZW50c1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhIGZyb20gdGhlIHNwZWNpZmllZCBmcmFnbWVudHMuICBVc2UgdGhpcyBmdW5jdGlvbiB3aGVuIHlvdSBrbm93XG4gICAqIHRoZSBmcmFnbWVudHMgeW91IHdhbnQgdG8gZXh0cmFjdCBkYXRhIGZyb20uICBTZWVcbiAgICpcbiAgICogQHBhcmFtIGRhdGFTZXQgLSB0aGUgZGF0YVNldCBjb250YWluaW5nIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgKiBAcGFyYW0gcGl4ZWxEYXRhRWxlbWVudCAtIHRoZSBwaXhlbCBkYXRhIGVsZW1lbnQgKHg3ZmUwMDAxMCkgdG8gZXh0cmFjdCB0aGUgZnJhZ21lbnQgZGF0YSBmcm9tXG4gICAqIEBwYXJhbSBzdGFydEZyYWdtZW50SW5kZXggLSB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBmaXJzdCBmcmFnbWVudCB0byBleHRyYWN0IGZyb21cbiAgICogQHBhcmFtIFtudW1GcmFnbWVudHNdIC0gdGhlIG51bWJlciBvZiBmcmFnbWVudHMgdG8gZXh0cmFjdCBmcm9tLCBkZWZhdWx0IGlzIDFcbiAgICogQHBhcmFtIFtmcmFnbWVudHNdIC0gb3B0aW9uYWwgYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGVhY2ggZnJhZ21lbnQgKG9mZnNldCwgcG9zaXRpb24sIGxlbmd0aClcbiAgICogQHJldHVybnMge29iamVjdH0gYnl0ZSBhcnJheSB3aXRoIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgKi9cbiAgZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHMgPSBmdW5jdGlvbihkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBzdGFydEZyYWdtZW50SW5kZXgsIG51bUZyYWdtZW50cywgZnJhZ21lbnRzKVxuICB7XG4gICAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgICBudW1GcmFnbWVudHMgPSBudW1GcmFnbWVudHMgfHwgMTtcbiAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMgfHwgcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHM7XG5cbiAgICAvLyBjaGVjayBwYXJhbWV0ZXJzXG4gICAgaWYoZGF0YVNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZGF0YVNldCdcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCdcIjtcbiAgICB9XG4gICAgaWYoc3RhcnRGcmFnbWVudEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdzdGFydEZyYWdtZW50SW5kZXgnXCI7XG4gICAgfVxuICAgIGlmKG51bUZyYWdtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnbnVtRnJhZ21lbnRzJ1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LnRhZyAhPT0gJ3g3ZmUwMDAxMCcpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIG5vbiBwaXhlbCBkYXRhIHRhZyAoZXhwZWN0ZWQgdGFnID0geDdmZTAwMDEwJ1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmVuY2Fwc3VsYXRlZFBpeGVsRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHN0YXJ0RnJhZ21lbnRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAnc3RhcnRGcmFnbWVudEluZGV4JyBtdXN0IGJlID49IDBcIjtcbiAgICB9XG4gICAgaWYoc3RhcnRGcmFnbWVudEluZGV4ID49IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdzdGFydEZyYWdtZW50SW5kZXgnIG11c3QgYmUgPCBudW1iZXIgb2YgZnJhZ21lbnRzXCI7XG4gICAgfVxuICAgIGlmKG51bUZyYWdtZW50cyA8IDEpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAnbnVtRnJhZ21lbnRzJyBtdXN0IGJlID4gMFwiO1xuICAgIH1cbiAgICBpZihzdGFydEZyYWdtZW50SW5kZXggKyBudW1GcmFnbWVudHMgPiBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAnc3RhcnRGcmFnbWVudCcgKyAnbnVtRnJhZ21lbnRzJyA8IG51bWJlciBvZiBmcmFnbWVudHNcIjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYnl0ZSBzdHJlYW0gb24gdGhlIGRhdGEgZm9yIHRoaXMgcGl4ZWwgZGF0YSBlbGVtZW50XG4gICAgdmFyIGJ5dGVTdHJlYW0gPSBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkYXRhU2V0LmJ5dGVBcnJheVBhcnNlciwgZGF0YVNldC5ieXRlQXJyYXksIHBpeGVsRGF0YUVsZW1lbnQuZGF0YU9mZnNldCk7XG5cbiAgICAvLyBzZWVrIHBhc3QgdGhlIGJhc2ljIG9mZnNldCB0YWJsZSAobm8gbmVlZCB0byBwYXJzZSBpdCBhZ2FpbiBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUpXG4gICAgdmFyIGJhc2ljT2Zmc2V0VGFibGUgPSBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtKGJ5dGVTdHJlYW0pO1xuICAgIGlmKGJhc2ljT2Zmc2V0VGFibGUudGFnICE9PSAneGZmZmVlMDAwJylcbiAgICB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IG1pc3NpbmcgYmFzaWMgb2Zmc2V0IHRhYmxlIHhmZmZlZTAwMFwiO1xuICAgIH1cbiAgICBieXRlU3RyZWFtLnNlZWsoYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGgpO1xuXG4gICAgdmFyIGZyYWdtZW50WmVyb1Bvc2l0aW9uID0gYnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICB2YXIgZnJhZ21lbnRIZWFkZXJTaXplID0gODsgLy8gdGFnICsgbGVuZ3RoXG5cbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBmcmFnbWVudCwgcmV0dXJuIGEgdmlldyBvbiB0aGlzIGFycmF5IHRvIGF2b2lkIGNvcHlpbmdcbiAgICBpZihudW1GcmFnbWVudHMgPT09IDEpIHtcbiAgICAgIHJldHVybiBkaWNvbVBhcnNlci5zaGFyZWRDb3B5KGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBmcmFnbWVudFplcm9Qb3NpdGlvbiArIGZyYWdtZW50c1tzdGFydEZyYWdtZW50SW5kZXhdLm9mZnNldCArIGZyYWdtZW50SGVhZGVyU2l6ZSwgZnJhZ21lbnRzW3N0YXJ0RnJhZ21lbnRJbmRleF0ubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBtb3JlIHRoYW4gb25lIGZyYWdtZW50LCBjb21iaW5lIGFsbCBvZiB0aGUgZnJhZ21lbnRzIGludG8gb25lIGJ1ZmZlclxuICAgIHZhciBidWZmZXJTaXplID0gY2FsY3VsYXRlQnVmZmVyU2l6ZShmcmFnbWVudHMsIHN0YXJ0RnJhZ21lbnRJbmRleCwgbnVtRnJhZ21lbnRzKTtcblxuICAgIHZhciBwaXhlbERhdGEgPSBkaWNvbVBhcnNlci5hbGxvYyhieXRlU3RyZWFtLmJ5dGVBcnJheSwgYnVmZmVyU2l6ZSk7XG5cbiAgICB2YXIgcGl4ZWxEYXRhSW5kZXggPSAwO1xuICAgIGZvcih2YXIgaT1zdGFydEZyYWdtZW50SW5kZXg7IGkgPCBzdGFydEZyYWdtZW50SW5kZXggKyBudW1GcmFnbWVudHM7IGkrKykge1xuICAgICAgdmFyIGZyYWdtZW50T2Zmc2V0ID0gZnJhZ21lbnRaZXJvUG9zaXRpb24gKyBmcmFnbWVudHNbaV0ub2Zmc2V0ICsgZnJhZ21lbnRIZWFkZXJTaXplO1xuICAgICAgZm9yKHZhciBqPTA7IGogPCBmcmFnbWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGl4ZWxEYXRhW3BpeGVsRGF0YUluZGV4KytdID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXlbZnJhZ21lbnRPZmZzZXQrK107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBpeGVsRGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG5cbi8qKlxuICogUGFyc2VzIGEgRElDT00gUDEwIGJ5dGUgYXJyYXkgYW5kIHJldHVybnMgYSBEYXRhU2V0IG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgZWxlbWVudHMuICBJZiB0aGUgb3B0aW9uc1xuICogYXJndW1lbnQgaXMgc3VwcGxpZWQgYW5kIGl0IGNvbnRhaW5zIHRoZSB1bnRpbFRhZyBwcm9wZXJ0eSwgcGFyc2luZyB3aWxsIHN0b3Agb25jZSB0aGF0XG4gKiB0YWcgaXMgZW5jb3V0ZXJlZC4gIFRoaXMgY2FuIGJlIHVzZWQgdG8gcGFyc2UgcGFydGlhbCBieXRlIHN0cmVhbXMuXG4gKlxuICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheVxuICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHRvIGNvbnRyb2wgcGFyc2luZyBiZWhhdmlvciAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7RGF0YVNldH1cbiAqIEB0aHJvd3MgZXJyb3IgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHBhcnNpbmcuICBUaGUgZXhjZXB0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gYSBwcm9wZXJ0eSBkYXRhU2V0IHdpdGggdGhlXG4gKiAgICAgICAgIGVsZW1lbnRzIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYmVmb3JlIHRoZSBlcnJvci5cbiAqL1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uKGRpY29tUGFyc2VyKSB7XG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgZGljb21QYXJzZXIucmVhZFBhcnQxMEhlYWRlciA9IGZ1bmN0aW9uKGJ5dGVBcnJheSwgb3B0aW9ucykge1xuXG4gICAgaWYoYnl0ZUFycmF5ID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkUGFydDEwSGVhZGVyOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZUFycmF5J1wiO1xuICAgIH1cblxuICAgIHZhciBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtID0gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXkpO1xuXG4gICAgZnVuY3Rpb24gcmVhZFByZWZpeCgpXG4gICAge1xuICAgICAgbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5zZWVrKDEyOCk7XG4gICAgICB2YXIgcHJlZml4ID0gbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5yZWFkRml4ZWRTdHJpbmcoNCk7XG4gICAgICBpZihwcmVmaXggIT09IFwiRElDTVwiKVxuICAgICAge1xuICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRQYXJ0MTBIZWFkZXI6IERJQ00gcHJlZml4IG5vdCBmb3VuZCBhdCBsb2NhdGlvbiAxMzIgLSB0aGlzIGlzIG5vdCBhIHZhbGlkIERJQ09NIFAxMCBmaWxlLlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1haW4gZnVuY3Rpb24gaGVyZVxuICAgIGZ1bmN0aW9uIHJlYWRUaGVIZWFkZXIoKSB7XG4gICAgICAvLyBQZXIgdGhlIERJQ09NIHN0YW5kYXJkLCB0aGUgaGVhZGVyIGlzIGFsd2F5cyBlbmNvZGVkIGluIEV4cGxpY2l0IFZSIExpdHRsZSBFbmRpYW4gKHNlZSBQUzMuMTAsIHNlY3Rpb24gNy4xKVxuICAgICAgLy8gc28gdXNlIGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0gdGhyb3VnaG91dCB0aGlzIG1ldGhvZCByZWdhcmRsZXNzIG9mIHRoZSB0cmFuc2ZlciBzeW50YXhcbiAgICAgIHJlYWRQcmVmaXgoKTtcblxuICAgICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgICB2YXIgZWxlbWVudHMgPSB7fTtcbiAgICAgIHdoaWxlKGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ucG9zaXRpb24gPCBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50RXhwbGljaXQobGl0dGxlRW5kaWFuQnl0ZVN0cmVhbSwgd2FybmluZ3MpO1xuICAgICAgICBpZihlbGVtZW50LnRhZyA+ICd4MDAwMmZmZmYnKSB7XG4gICAgICAgICAgbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhY2hlIHRoZSBsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIgZm9yIG1ldGEgaGVhZGVyIGVsZW1lbnRzLCBzaW5jZSB0aGUgcmVzdCBvZiB0aGUgZGF0YSBzZXQgbWF5IGJlIGJpZyBlbmRpYW5cbiAgICAgICAgLy8gYW5kIHRoaXMgcGFyc2VyIHdpbGwgYmUgbmVlZGVkIGxhdGVyIGlmIHRoZSBtZXRhIGhlYWRlciB2YWx1ZXMgYXJlIHRvIGJlIHJlYWQuXG4gICAgICAgIGVsZW1lbnQucGFyc2VyID0gZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyO1xuICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuICAgICAgfVxuICAgICAgdmFyIG1ldGFIZWFkZXJEYXRhU2V0ID0gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQobGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBlbGVtZW50cyk7XG4gICAgICBtZXRhSGVhZGVyRGF0YVNldC53YXJuaW5ncyA9IGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ud2FybmluZ3M7XG4gICAgICBtZXRhSGVhZGVyRGF0YVNldC5wb3NpdGlvbiA9IGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICByZXR1cm4gbWV0YUhlYWRlckRhdGFTZXQ7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB3aGVyZSB3ZSBhY3R1YWxseSBzdGFydCBwYXJzaW5nXG4gICAgcmV0dXJuIHJlYWRUaGVIZWFkZXIoKTtcbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KShkaWNvbVBhcnNlcik7XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkRGljb21EYXRhU2V0RXhwbGljaXRVbmRlZmluZWRMZW5ndGgoYnl0ZVN0cmVhbSwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcblxuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRFeHBsaWNpdChieXRlU3RyZWFtLCB3YXJuaW5ncyk7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuXG4gICAgICAgICAgICAvLyB3ZSBoaXQgYW4gaXRlbSBkZWxpbWl0ZXIgdGFnLCByZXR1cm4gdGhlIGN1cnJlbnQgb2Zmc2V0IHRvIG1hcmtcbiAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhpcyBzZXF1ZW5jZSBpdGVtXG4gICAgICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gJ3hmZmZlZTAwZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwgZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBlb2YgZW5jb3VudGVyZWQgLSBsb2cgYSB3YXJuaW5nIGFuZCByZXR1cm4gd2hhdCB3ZSBoYXZlIGZvciB0aGUgZWxlbWVudFxuICAgICAgICB3YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgaXRlbSBkZWxpbWl0ZXIgdGFnIHdoaWxlIHJlYWRpbmcgc2VxdWVuY2UgaXRlbSBvZiB1bmRlZmluZWQgbGVuZ3RoJyk7XG4gICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuRGF0YVNldChieXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgYnl0ZVN0cmVhbS5ieXRlQXJyYXksIGVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU2VxdWVuY2VJdGVtRXhwbGljaXQoYnl0ZVN0cmVhbSwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW0oYnl0ZVN0cmVhbSk7XG5cbiAgICAgICAgaWYoaXRlbS5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW0uaGFkVW5kZWZpbmVkTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICAgIGl0ZW0uZGF0YVNldCA9IHJlYWREaWNvbURhdGFTZXRFeHBsaWNpdFVuZGVmaW5lZExlbmd0aChieXRlU3RyZWFtLCB3YXJuaW5ncyk7XG4gICAgICAgICAgICBpdGVtLmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBpdGVtLmRhdGFPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpdGVtLmRhdGFTZXQgPSBuZXcgZGljb21QYXJzZXIuRGF0YVNldChieXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgYnl0ZVN0cmVhbS5ieXRlQXJyYXksIHt9KTtcbiAgICAgICAgICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQoaXRlbS5kYXRhU2V0LCBieXRlU3RyZWFtLCBieXRlU3RyZWFtLnBvc2l0aW9uICsgaXRlbS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTUUVsZW1lbnRVbmRlZmluZWRMZW5ndGhFeHBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncylcbiAgICB7XG4gICAgICAgIHdoaWxlKChieXRlU3RyZWFtLnBvc2l0aW9uICsgNCkgPD0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gZW5kIHJlYWRpbmcgdGhpcyBzZXF1ZW5jZSBpZiB0aGUgbmV4dCB0YWcgaXMgdGhlIHNlcXVlbmNlIGRlbGltaXRhdGlvbiBpdGVtXG4gICAgICAgICAgdmFyIG5leHRUYWcgPSBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pO1xuICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlaygtNCk7XG4gICAgICAgICAgaWYgKG5leHRUYWcgPT09ICd4ZmZmZWUwZGQnKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoOCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gcmVhZFNlcXVlbmNlSXRlbUV4cGxpY2l0KGJ5dGVTdHJlYW0sIHdhcm5pbmdzKTtcbiAgICAgICAgICAgIGVsZW1lbnQuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgc2VxdWVuY2UgZGVsaW1pdGF0aW9uIHRhZyB3aGlsZSByZWFkaW5nIHNlcXVlbmNlIG9mIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTUUVsZW1lbnRLbm93bkxlbmd0aEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKVxuICAgIHtcbiAgICAgICAgdmFyIG1heFBvc2l0aW9uID0gZWxlbWVudC5kYXRhT2Zmc2V0ICsgZWxlbWVudC5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBtYXhQb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSByZWFkU2VxdWVuY2VJdGVtRXhwbGljaXQoYnl0ZVN0cmVhbSwgd2FybmluZ3MpO1xuICAgICAgICAgICAgZWxlbWVudC5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNFeHBsaWNpdCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zRXhwbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0V4cGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZWxlbWVudCdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuaXRlbXMgPSBbXTtcblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVhZFNRRWxlbWVudFVuZGVmaW5lZExlbmd0aEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlYWRTUUVsZW1lbnRLbm93bkxlbmd0aEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkRGljb21EYXRhU2V0SW1wbGljaXRVbmRlZmluZWRMZW5ndGgoYnl0ZVN0cmVhbSwgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuXG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0KGJ5dGVTdHJlYW0sIHVuZGVmaW5lZCwgdnJDYWxsYmFjayk7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuXG4gICAgICAgICAgICAvLyB3ZSBoaXQgYW4gaXRlbSBkZWxpbWl0ZXIgdGFnLCByZXR1cm4gdGhlIGN1cnJlbnQgb2Zmc2V0IHRvIG1hcmtcbiAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhpcyBzZXF1ZW5jZSBpdGVtXG4gICAgICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gJ3hmZmZlZTAwZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwgZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVvZiBlbmNvdW50ZXJlZCAtIGxvZyBhIHdhcm5pbmcgYW5kIHJldHVybiB3aGF0IHdlIGhhdmUgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgIGJ5dGVTdHJlYW0ud2FybmluZ3MucHVzaCgnZW9mIGVuY291bnRlcmVkIGJlZm9yZSBmaW5kaW5nIHNlcXVlbmNlIGl0ZW0gZGVsaW1pdGVyIGluIHNlcXVlbmNlIGl0ZW0gb2YgdW5kZWZpbmVkIGxlbmd0aCcpO1xuICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoYnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFNlcXVlbmNlSXRlbUltcGxpY2l0KGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW0oYnl0ZVN0cmVhbSk7XG5cbiAgICAgICAgaWYoaXRlbS5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW0uaGFkVW5kZWZpbmVkTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICAgIGl0ZW0uZGF0YVNldCA9IHJlYWREaWNvbURhdGFTZXRJbXBsaWNpdFVuZGVmaW5lZExlbmd0aChieXRlU3RyZWFtLCB2ckNhbGxiYWNrKTtcbiAgICAgICAgICAgIGl0ZW0ubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGl0ZW0uZGF0YU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW0uZGF0YVNldCA9IG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwge30pO1xuICAgICAgICAgICAgZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRJbXBsaWNpdChpdGVtLmRhdGFTZXQsIGJ5dGVTdHJlYW0sIGJ5dGVTdHJlYW0ucG9zaXRpb24gKyBpdGVtLmxlbmd0aCwge3ZyQ2FsbGJhY2s6IHZyQ2FsbGJhY2t9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU1FFbGVtZW50VW5kZWZpbmVkTGVuZ3RoSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHdoaWxlKChieXRlU3RyZWFtLnBvc2l0aW9uICsgNCkgPD0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gZW5kIHJlYWRpbmcgdGhpcyBzZXF1ZW5jZSBpZiB0aGUgbmV4dCB0YWcgaXMgdGhlIHNlcXVlbmNlIGRlbGltaXRhdGlvbiBpdGVtXG4gICAgICAgICAgdmFyIG5leHRUYWcgPSBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pO1xuICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlaygtNCk7XG4gICAgICAgICAgaWYgKG5leHRUYWcgPT09ICd4ZmZmZWUwZGQnKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoOCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXRlbSA9IHJlYWRTZXF1ZW5jZUl0ZW1JbXBsaWNpdChieXRlU3RyZWFtLCB2ckNhbGxiYWNrKTtcbiAgICAgICAgICBlbGVtZW50Lml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgc2VxdWVuY2UgZGVsaW1pdGVyIGluIHNlcXVlbmNlIG9mIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFNRRWxlbWVudEtub3duTGVuZ3RoSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IGVsZW1lbnQuZGF0YU9mZnNldCArIGVsZW1lbnQubGVuZ3RoO1xuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgbWF4UG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gcmVhZFNlcXVlbmNlSXRlbUltcGxpY2l0KGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spO1xuICAgICAgICAgICAgZWxlbWVudC5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgc2VxdWVuY2UgaXRlbXMgZm9yIGFuIGVsZW1lbnQgaW4gYW4gaW1wbGljaXQgbGl0dGxlIGVuZGlhbiBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtIHRoZSBpbXBsaWNpdCBsaXR0bGUgZW5kaWFuIGJ5dGUgc3RyZWFtXG4gICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gcmVhZCB0aGUgc2VxdWVuY2UgaXRlbXMgZm9yXG4gICAgICogQHBhcmFtIHZyQ2FsbGJhY2sgYW4gb3B0aW9uYWwgbWV0aG9kIHRoYXQgcmV0dXJucyBhIFZSIHN0cmluZyBnaXZlbiBhIHRhZ1xuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQgPSBmdW5jdGlvbihieXRlU3RyZWFtLCBlbGVtZW50LCB2ckNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0ltcGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZWxlbWVudCdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuaXRlbXMgPSBbXTtcblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVhZFNRRWxlbWVudFVuZGVmaW5lZExlbmd0aEltcGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHZyQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmVhZFNRRWxlbWVudEtub3duTGVuZ3RoSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgdnJDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSB0YWcgYW5kIGxlbmd0aCBvZiBhIHNlcXVlbmNlIGl0ZW0gYW5kIHJldHVybnMgdGhlbSBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcbiAgICAgKiAgdGFnIDogc3RyaW5nIGZvciB0aGUgdGFnIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgZm9ybWF0IHhnZ2dnZWVlZVxuICAgICAqICBsZW5ndGg6IHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBpdGVtIG9yIDQyOTQ5NjcyOTUgaWYgdW5kZWZpbmVkXG4gICAgICogIGRhdGFPZmZzZXQ6IHRoZSBvZmZzZXQgaW50byB0aGUgYnl0ZVN0cmVhbSBvZiB0aGUgZGF0YSBmb3IgdGhpcyBpdGVtXG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW0gdGhlIGJ5dGVcbiAgICAgKiBAcmV0dXJucyB7e3RhZzogc3RyaW5nLCBsZW5ndGg6IGludGVnZXIsIGRhdGFPZmZzZXQ6IGludGVnZXJ9fVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW0gPSBmdW5jdGlvbihieXRlU3RyZWFtKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW06IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICB0YWcgOiBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pLFxuICAgICAgICAgICAgbGVuZ3RoIDogYnl0ZVN0cmVhbS5yZWFkVWludDMyKCksXG4gICAgICAgICAgICBkYXRhT2Zmc2V0IDogIGJ5dGVTdHJlYW0ucG9zaXRpb25cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZWxlbWVudC50YWcgIT09ICd4ZmZmZWUwMDAnKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IGJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW06IGl0ZW0gdGFnIChGRkZFLEUwMDApIG5vdCBmb3VuZCBhdCBvZmZzZXQgXCIgKyBzdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgdGFnIChncm91cCBudW1iZXIgYW5kIGVsZW1lbnQgbnVtYmVyKSBmcm9tIGEgYnl0ZVN0cmVhbVxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtIHRoZSBieXRlIHN0cmVhbSB0byByZWFkIGZyb21cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdGFnIGluIGZvcm1hdCB4Z2dnZ2VlZWUgd2hlcmUgZ2dnZyBpcyB0aGUgbG93ZXJjYXNlIGhleCB2YWx1ZSBvZiB0aGUgZ3JvdXAgbnVtYmVyXG4gICAgICogYW5kIGVlZWUgaXMgdGhlIGxvd2VyIGNhc2UgaGV4IHZhbHVlIG9mIHRoZSBlbGVtZW50IG51bWJlclxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnJlYWRUYWcgPSBmdW5jdGlvbihieXRlU3RyZWFtKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRUYWc6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwTnVtYmVyID0gIGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpICogMjU2ICogMjU2O1xuICAgICAgICB2YXIgZWxlbWVudE51bWJlciA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgICAgICB2YXIgdGFnID0gXCJ4XCIgKyAoJzAwMDAwMDAwJyArIChncm91cE51bWJlciArIGVsZW1lbnROdW1iZXIpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC04KTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHNoYXJlZCBjb3B5IG9mIGEgYnl0ZUFycmF5XG4gKlxuICovXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdmlldyBvZiB0aGUgdW5kZXJseWluZyBieXRlQXJyYXkuICBUaGUgdmlldyBpcyBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBieXRlQXJyYXkgKGUuZy5cbiAgICogVWludDhBcnJheSBvciBCdWZmZXIpIGFuZCBzaGFyZXMgdGhlIHNhbWUgdW5kZXJseWluZyBtZW1vcnkgKGNoYW5naW5nIG9uZSBjaGFuZ2VzIHRoZSBvdGhlcilcbiAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgdW5kZXJseWluZyBieXRlQXJyYXkgKGVpdGhlciBVaW50OEFycmF5IG9yIEJ1ZmZlcilcbiAgICogQHBhcmFtIGJ5dGVPZmZzZXQgb2Zmc2V0IGludG8gdGhlIHVuZGVybHlpbmcgYnl0ZUFycmF5IHRvIGNyZWF0ZSB0aGUgdmlldyBvZlxuICAgKiBAcGFyYW0gbGVuZ3RoIG51bWJlciBvZiBieXRlcyBpbiB0aGUgdmlld1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBVaW50OEFycmF5IG9yIEJ1ZmZlciBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYnl0ZUFycmF5XG4gICAqL1xuICBkaWNvbVBhcnNlci5zaGFyZWRDb3B5ID0gZnVuY3Rpb24oYnl0ZUFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnl0ZUFycmF5IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICByZXR1cm4gYnl0ZUFycmF5LnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmKGJ5dGVBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlQXJyYXkuYnVmZmVyLCBieXRlQXJyYXkuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdkaWNvbVBhcnNlci5mcm9tOiB1bmtub3duIHR5cGUgZm9yIGJ5dGVBcnJheSc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogVmVyc2lvblxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgZGljb21QYXJzZXIudmVyc2lvbiA9IFwiMS43LjNcIjtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufSkpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjID0ganBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhTYW1wID0gMDsgLy8gSG9yaXpvbnRhbCBzYW1wbGluZyBmYWN0b3JcbiAgICB0aGlzLnF1YW50VGFibGVTZWwgPSAwOyAvLyBRdWFudGl6YXRpb24gdGFibGUgZGVzdGluYXRpb24gc2VsZWN0b3JcbiAgICB0aGlzLnZTYW1wID0gMDsgLy8gVmVydGljYWxcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IERhdGFWaWV3KGRhdGEsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB0aGlzLmluZGV4ID0gMDtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0ucHJvdG90eXBlLmdldDE2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuYnVmZmVyLmdldFVpbnQxNih0aGlzLmluZGV4LCBmYWxzZSk7XG4gICAgdGhpcy5pbmRleCArPSAyO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0ucHJvdG90eXBlLmdldDggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5idWZmZXIuZ2V0VWludDgodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbmRleCArPSAxO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZGF0YS1zdHJlYW0uanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgPSBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2h1ZmZtYW4tdGFibGUuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSA9IGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9xdWFudGl6YXRpb24tdGFibGUuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyID0ganBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vc2Nhbi1oZWFkZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciA9IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9mcmFtZS1oZWFkZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5VdGlscyA9IGpwZWcubG9zc2xlc3MuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlscy5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIgPSBqcGVnLmxvc3NsZXNzLkRlY29kZXIgfHwgZnVuY3Rpb24gKGJ1ZmZlciwgbnVtQnl0ZXMpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLmZyYW1lID0gbmV3IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIoKTtcbiAgICB0aGlzLmh1ZmZUYWJsZSA9IG5ldyBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSgpO1xuICAgIHRoaXMucXVhbnRUYWJsZSA9IG5ldyBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlKCk7XG4gICAgdGhpcy5zY2FuID0gbmV3IGpwZWcubG9zc2xlc3MuU2NhbkhlYWRlcigpO1xuICAgIHRoaXMuRFUgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDEwLCA0LCA2NCk7IC8vIGF0IG1vc3QgMTAgZGF0YSB1bml0cyBpbiBhIE1DVSwgYXQgbW9zdCA0IGRhdGEgdW5pdHMgaW4gb25lIGNvbXBvbmVudFxuICAgIHRoaXMuSHVmZlRhYiA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgMiwgNTAgKiAyNTYpO1xuICAgIHRoaXMuSURDVF9Tb3VyY2UgPSBbXTtcbiAgICB0aGlzLm5CbG9jayA9IFtdOyAvLyBudW1iZXIgb2YgYmxvY2tzIGluIHRoZSBpLXRoIENvbXAgaW4gYSBzY2FuXG4gICAgdGhpcy5hY1RhYiA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoMTAsIDEpOyAvLyBhYyBIdWZmVGFiIGZvciB0aGUgaS10aCBDb21wIGluIGEgc2NhblxuICAgIHRoaXMuZGNUYWIgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDEwLCAxKTsgLy8gZGMgSHVmZlRhYiBmb3IgdGhlIGktdGggQ29tcCBpbiBhIHNjYW5cbiAgICB0aGlzLnFUYWIgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDEwLCAxKTsgLy8gcXVhbnRpemF0aW9uIHRhYmxlIGZvciB0aGUgaS10aCBDb21wIGluIGEgc2NhblxuICAgIHRoaXMubWFya2VyID0gMDtcbiAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICB0aGlzLm51bUNvbXAgPSAwO1xuICAgIHRoaXMucmVzdGFydEludGVydmFsID0gMDtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IDA7XG4gICAgdGhpcy54RGltID0gMDtcbiAgICB0aGlzLnlEaW0gPSAwO1xuICAgIHRoaXMueExvYyA9IDA7XG4gICAgdGhpcy55TG9jID0gMDtcbiAgICB0aGlzLm51bUJ5dGVzID0gMDtcbiAgICB0aGlzLm91dHB1dERhdGEgPSBudWxsO1xuICAgIHRoaXMucmVzdGFydGluZyA9IGZhbHNlO1xuICAgIHRoaXMubWFzayA9IDA7XG5cbiAgICBpZiAodHlwZW9mIG51bUJ5dGVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMubnVtQnl0ZXMgPSBudW1CeXRlcztcbiAgICB9XG59O1xuXG5cbi8qKiogU3RhdGljIFBzZXVkby1jb25zdGFudHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuSURDVF9QID0gWzAsIDUsIDQwLCAxNiwgNDUsIDIsIDcsIDQyLCAyMSwgNTYsIDgsIDYxLCAxOCwgNDcsIDEsIDQsIDQxLCAyMywgNTgsIDEzLCAzMiwgMjQsIDM3LCAxMCwgNjMsIDE3LCA0NCwgMywgNiwgNDMsIDIwLFxuICAgIDU3LCAxNSwgMzQsIDI5LCA0OCwgNTMsIDI2LCAzOSwgOSwgNjAsIDE5LCA0NiwgMjIsIDU5LCAxMiwgMzMsIDMxLCA1MCwgNTUsIDI1LCAzNiwgMTEsIDYyLCAxNCwgMzUsIDI4LCA0OSwgNTIsIDI3LCAzOCwgMzAsIDUxLCA1NF07XG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuVEFCTEUgPSBbMCwgMSwgNSwgNiwgMTQsIDE1LCAyNywgMjgsIDIsIDQsIDcsIDEzLCAxNiwgMjYsIDI5LCA0MiwgMywgOCwgMTIsIDE3LCAyNSwgMzAsIDQxLCA0MywgOSwgMTEsIDE4LCAyNCwgMzEsIDQwLCA0NCwgNTMsXG4gICAgMTAsIDE5LCAyMywgMzIsIDM5LCA0NSwgNTIsIDU0LCAyMCwgMjIsIDMzLCAzOCwgNDYsIDUxLCA1NSwgNjAsIDIxLCAzNCwgMzcsIDQ3LCA1MCwgNTYsIDU5LCA2MSwgMzUsIDM2LCA0OCwgNDksIDU3LCA1OCwgNjIsIDYzXTtcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5NQVhfSFVGRk1BTl9TVUJUUkVFID0gNTA7XG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuTVNCID0gMHg4MDAwMDAwMDtcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5SRVNUQVJUX01BUktFUl9CRUdJTiA9IDB4RkZEMDtcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5SRVNUQVJUX01BUktFUl9FTkQgPSAweEZGRDc7XG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmRlY29tcHJlc3MgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZShidWZmZXIsIG9mZnNldCwgbGVuZ3RoKS5idWZmZXI7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbnVtQnl0ZXMpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY3VycmVudCwgc2Nhbk51bSA9IDAsIHByZWQgPSBbXSwgaSwgY29tcE4sIHRlbXAgPSBbXSwgaW5kZXggPSBbXSwgbWN1TnVtO1xuXG4gICAgaWYgKHR5cGVvZiBidWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1CeXRlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLm51bUJ5dGVzID0gbnVtQnl0ZXM7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJlYW0gPSBuZXcganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtKHRoaXMuYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuXG4gICAgdGhpcy54TG9jID0gMDtcbiAgICB0aGlzLnlMb2MgPSAwO1xuICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IDB4RkZEOCkgeyAvLyBTT0lcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgSlBFRyBmaWxlXCIpO1xuICAgIH1cblxuICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuXG4gICAgd2hpbGUgKCgoKGN1cnJlbnQgPj4gNCkgIT09IDB4MEZGQykgfHwgKGN1cnJlbnQgPT09IDB4RkZDNCkpKSB7IC8vIFNPRiAwfjE1XG4gICAgICAgIHN3aXRjaCAoY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSAweEZGQzQ6IC8vIERIVFxuICAgICAgICAgICAgICAgIHRoaXMuaHVmZlRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIHRoaXMuSHVmZlRhYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkZDQzogLy8gREFDXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbSBkb2Vzbid0IHN1cHBvcnQgYXJpdGhtZXRpYyBjb2RpbmcuIChmb3JtYXQgdGhyb3cgbmV3IElPRXhjZXB0aW9uKVwiKTtcbiAgICAgICAgICAgIGNhc2UgMHhGRkRCOlxuICAgICAgICAgICAgICAgIHRoaXMucXVhbnRUYWJsZS5yZWFkKHRoaXMuc3RyZWFtLCBqcGVnLmxvc3NsZXNzLkRlY29kZXIuVEFCTEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGREQ6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0SW50ZXJ2YWwgPSB0aGlzLnJlYWROdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRkUwOlxuICAgICAgICAgICAgY2FzZSAweEZGRTE6XG4gICAgICAgICAgICBjYXNlIDB4RkZFMjpcbiAgICAgICAgICAgIGNhc2UgMHhGRkUzOlxuICAgICAgICAgICAgY2FzZSAweEZGRTQ6XG4gICAgICAgICAgICBjYXNlIDB4RkZFNTpcbiAgICAgICAgICAgIGNhc2UgMHhGRkU2OlxuICAgICAgICAgICAgY2FzZSAweEZGRTc6XG4gICAgICAgICAgICBjYXNlIDB4RkZFODpcbiAgICAgICAgICAgIGNhc2UgMHhGRkU5OlxuICAgICAgICAgICAgY2FzZSAweEZGRUE6XG4gICAgICAgICAgICBjYXNlIDB4RkZFQjpcbiAgICAgICAgICAgIGNhc2UgMHhGRkVDOlxuICAgICAgICAgICAgY2FzZSAweEZGRUQ6XG4gICAgICAgICAgICBjYXNlIDB4RkZFRTpcbiAgICAgICAgICAgIGNhc2UgMHhGRkVGOlxuICAgICAgICAgICAgICAgIHRoaXMucmVhZEFwcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGRkU6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnQgPj4gOCkgIT09IDB4RkYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24hIChkZWNvZGUpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgIH1cblxuICAgIGlmICgoY3VycmVudCA8IDB4RkZDMCkgfHwgKGN1cnJlbnQgPiAweEZGQzcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBjb3VsZCBub3QgaGFuZGxlIGFyaXRobWV0aWMgY29kZSFcIik7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZS5yZWFkKHRoaXMuc3RyZWFtKTtcbiAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcblxuICAgIGRvIHtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IDB4MEZGREEpIHsgLy8gU09TXG4gICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZDNDogLy8gREhUXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHVmZlRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIHRoaXMuSHVmZlRhYik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkNDOiAvLyBEQUNcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbSBkb2Vzbid0IHN1cHBvcnQgYXJpdGhtZXRpYyBjb2RpbmcuIChmb3JtYXQgdGhyb3cgbmV3IElPRXhjZXB0aW9uKVwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZEQjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFudFRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIGpwZWcubG9zc2xlc3MuRGVjb2Rlci5UQUJMRSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkREOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRJbnRlcnZhbCA9IHRoaXMucmVhZE51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFODpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFOTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFQTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFQjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFQzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFRDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFRTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZFRjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQXBwKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkZFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudCA+PiA4KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24hIChQYXJzZXIuZGVjb2RlKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gdGhpcy5mcmFtZS5wcmVjaXNpb247XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHRoaXMuZnJhbWUuY29tcG9uZW50cztcblxuICAgICAgICBpZiAoIXRoaXMubnVtQnl0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtQnl0ZXMgPSBwYXJzZUludChNYXRoLmNlaWwodGhpcy5wcmVjaXNpb24gLyA4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5udW1CeXRlcyA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLm1hc2sgPSAweEZGO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXNrID0gMHhGRkZGO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2FuLnJlYWQodGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLm51bUNvbXAgPSB0aGlzLnNjYW4ubnVtQ29tcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNjYW4uc2VsZWN0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm51bUJ5dGVzID09PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5udW1Db21wID09PSAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSB0aGlzLmdldFZhbHVlUkdCO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyID0gdGhpcy5zZXRWYWx1ZVJHQjtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0UkdCO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldHRlciA9IHRoaXMuZ2V0VmFsdWU4O1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyID0gdGhpcy5zZXRWYWx1ZTg7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dFNpbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gdGhpcy5nZXRWYWx1ZTE2O1xuICAgICAgICAgICAgdGhpcy5zZXR0ZXIgPSB0aGlzLnNldFZhbHVlMTY7XG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0U2luZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0MztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Q0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Q3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3QxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2FuQ29tcHMgPSB0aGlzLnNjYW4uY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5xdWFudFRhYmxlcyA9IHRoaXMucXVhbnRUYWJsZS5xdWFudFRhYmxlcztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW1Db21wOyBpKz0xKSB7XG4gICAgICAgICAgICBjb21wTiA9IHRoaXMuc2NhbkNvbXBzW2ldLnNjYW5Db21wU2VsO1xuICAgICAgICAgICAgdGhpcy5xVGFiW2ldID0gdGhpcy5xdWFudFRhYmxlc1t0aGlzLmNvbXBvbmVudHNbY29tcE5dLnF1YW50VGFibGVTZWxdO1xuICAgICAgICAgICAgdGhpcy5uQmxvY2tbaV0gPSB0aGlzLmNvbXBvbmVudHNbY29tcE5dLnZTYW1wICogdGhpcy5jb21wb25lbnRzW2NvbXBOXS5oU2FtcDtcbiAgICAgICAgICAgIHRoaXMuZGNUYWJbaV0gPSB0aGlzLkh1ZmZUYWJbdGhpcy5zY2FuQ29tcHNbaV0uZGNUYWJTZWxdWzBdO1xuICAgICAgICAgICAgdGhpcy5hY1RhYltpXSA9IHRoaXMuSHVmZlRhYlt0aGlzLnNjYW5Db21wc1tpXS5hY1RhYlNlbF1bMV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnhEaW0gPSB0aGlzLmZyYW1lLmRpbVg7XG4gICAgICAgIHRoaXMueURpbSA9IHRoaXMuZnJhbWUuZGltWTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcih0aGlzLnhEaW0gKiB0aGlzLnlEaW0gKiB0aGlzLm51bUJ5dGVzICogdGhpcy5udW1Db21wKSk7XG5cbiAgICAgICAgc2Nhbk51bSs9MTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkgeyAvLyBEZWNvZGUgb25lIHNjYW5cbiAgICAgICAgICAgIHRlbXBbMF0gPSAwO1xuICAgICAgICAgICAgaW5kZXhbMF0gPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBwcmVkW2ldID0gKDEgPDwgKHRoaXMucHJlY2lzaW9uIC0gMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0YXJ0SW50ZXJ2YWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5kZWNvZGVVbml0KHByZWQsIHRlbXAsIGluZGV4KTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudCA9PT0gMCkgJiYgKCh0aGlzLnhMb2MgPCB0aGlzLnhEaW0pICYmICh0aGlzLnlMb2MgPCB0aGlzLnlEaW0pKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dChwcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuZGVjb2RlVW5pdChwcmVkLCB0ZW1wLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vY3VycmVudD1NQVJLRVJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChtY3VOdW0gPSAwOyBtY3VOdW0gPCB0aGlzLnJlc3RhcnRJbnRlcnZhbDsgbWN1TnVtKz0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0aW5nID0gKG1jdU51bSA9PSAwKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5kZWNvZGVVbml0KHByZWQsIHRlbXAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dChwcmVkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gKDB4RkYwMCB8IHRoaXMubWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISgoY3VycmVudCA+PSBqcGVnLmxvc3NsZXNzLkRlY29kZXIuUkVTVEFSVF9NQVJLRVJfQkVHSU4pICYmXG4gICAgICAgICAgICAgICAgKGN1cnJlbnQgPD0ganBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0VORCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vY3VycmVudD1NQVJLRVJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoY3VycmVudCA9PT0gMHhGRkRDKSAmJiAoc2Nhbk51bSA9PT0gMSkpIHsgLy9ETkxcbiAgICAgICAgICAgIHRoaXMucmVhZE51bWJlcigpO1xuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgoY3VycmVudCAhPT0gMHhGRkQ5KSAmJiAoKHRoaXMueExvYyA8IHRoaXMueERpbSkgJiYgKHRoaXMueUxvYyA8IHRoaXMueURpbSkpICYmIChzY2FuTnVtID09PSAwKSk7XG5cbiAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlVW5pdCA9IGZ1bmN0aW9uIChwcmV2LCB0ZW1wLCBpbmRleCkge1xuICAgIGlmICh0aGlzLm51bUNvbXAgPT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVTaW5nbGUocHJldiwgdGVtcCwgaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5udW1Db21wID09IDMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlUkdCKHByZXYsIHRlbXAsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0MSA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0MiA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0MyA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNYWShjb21wT2Zmc2V0KTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDQgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiAodGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSkgLSB0aGlzLmdldFByZXZpb3VzWFkoY29tcE9mZnNldCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZWxlY3Q1ID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyAoKHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpIC0gdGhpcy5nZXRQcmV2aW91c1hZKGNvbXBPZmZzZXQpKSA+PiAxKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDYgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSArICgodGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgLSB0aGlzLmdldFByZXZpb3VzWFkoY29tcE9mZnNldCkpID4+IDEpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0NyA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuICgodGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSkgLyAyKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmRlY29kZVJHQiA9IGZ1bmN0aW9uIChwcmV2LCB0ZW1wLCBpbmRleCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciB2YWx1ZSwgYWN0YWIsIGRjdGFiLCBxdGFiLCBjdHJDLCBpLCBrLCBqO1xuXG4gICAgcHJldlswXSA9IHRoaXMuc2VsZWN0b3IoMCk7XG4gICAgcHJldlsxXSA9IHRoaXMuc2VsZWN0b3IoMSk7XG4gICAgcHJldlsyXSA9IHRoaXMuc2VsZWN0b3IoMik7XG5cbiAgICBmb3IgKGN0ckMgPSAwOyBjdHJDIDwgdGhpcy5udW1Db21wOyBjdHJDKz0xKSB7XG4gICAgICAgIHF0YWIgPSB0aGlzLnFUYWJbY3RyQ107XG4gICAgICAgIGFjdGFiID0gdGhpcy5hY1RhYltjdHJDXTtcbiAgICAgICAgZGN0YWIgPSB0aGlzLmRjVGFiW2N0ckNdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5uQmxvY2tbY3RyQ107IGkrPTEpIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCB0aGlzLklEQ1RfU291cmNlLmxlbmd0aDsgays9MSkge1xuICAgICAgICAgICAgICAgIHRoaXMuSURDVF9Tb3VyY2Vba10gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SHVmZm1hblZhbHVlKGRjdGFiLCB0ZW1wLCBpbmRleCk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAweEZGMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZbY3RyQ10gPSB0aGlzLklEQ1RfU291cmNlWzBdID0gcHJldltjdHJDXSArIHRoaXMuZ2V0bihpbmRleCwgdmFsdWUsIHRlbXAsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuSURDVF9Tb3VyY2VbMF0gKj0gcXRhYlswXTtcblxuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IDY0OyBqKz0xKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEh1ZmZtYW5WYWx1ZShhY3RhYiwgdGVtcCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4RkYwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaiArPSAodmFsdWUgPj4gNCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHgwRikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA+PiA0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLklEQ1RfU291cmNlW2pwZWcubG9zc2xlc3MuRGVjb2Rlci5JRENUX1Bbal1dID0gdGhpcy5nZXRuKGluZGV4LCB2YWx1ZSAmIDB4MEYsIHRlbXAsIGluZGV4KSAqIHF0YWJbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVTaW5nbGUgPSBmdW5jdGlvbiAocHJldiwgdGVtcCwgaW5kZXgpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgdmFsdWUsIGksIG4sIG5SZXN0YXJ0O1xuXG4gICAgaWYgKHRoaXMucmVzdGFydGluZykge1xuICAgICAgICB0aGlzLnJlc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgcHJldlswXSA9ICgxIDw8ICh0aGlzLmZyYW1lLnByZWNpc2lvbiAtIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2WzBdID0gdGhpcy5zZWxlY3RvcigpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm5CbG9ja1swXTsgaSs9MSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SHVmZm1hblZhbHVlKHRoaXMuZGNUYWJbMF0sIHRlbXAsIGluZGV4KTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4RkYwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbiA9IHRoaXMuZ2V0bihwcmV2LCB2YWx1ZSwgdGVtcCwgaW5kZXgpO1xuICAgICAgICBuUmVzdGFydCA9IChuID4+IDgpO1xuXG4gICAgICAgIGlmICgoblJlc3RhcnQgPj0ganBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0JFR0lOKSAmJiAoblJlc3RhcnQgPD0ganBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0VORCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuUmVzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZbMF0gKz0gbjtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cblxuXG4vL1x0SHVmZm1hbiB0YWJsZSBmb3IgZmFzdCBzZWFyY2g6IChIdWZmVGFiKSA4LWJpdCBMb29rIHVwIHRhYmxlIDItbGF5ZXIgc2VhcmNoIGFyY2hpdGVjdHVyZSwgMXN0LWxheWVyIHJlcHJlc2VudCAyNTYgbm9kZSAoOCBiaXRzKSBpZiBjb2Rld29yZC1sZW5ndGggPiA4XG4vL1x0Yml0cywgdGhlbiB0aGUgZW50cnkgb2YgMXN0LWxheWVyID0gKCMgb2YgMm5kLWxheWVyIHRhYmxlKSB8IE1TQiBhbmQgaXQgaXMgc3RvcmVkIGluIHRoZSAybmQtbGF5ZXIgU2l6ZSBvZiB0YWJsZXMgaW4gZWFjaCBsYXllciBhcmUgMjU2LlxuLy9cdEh1ZmZUYWJbKl1bKl1bMC0yNTZdIGlzIGFsd2F5cyB0aGUgb25seSAxc3QtbGF5ZXIgdGFibGUuXG4vL1xuLy9cdEFuIGVudHJ5IGNhbiBiZTogKDEpICgjIG9mIDJuZC1sYXllciB0YWJsZSkgfCBNU0IgLCBmb3IgY29kZSBsZW5ndGggPiA4IGluIDFzdC1sYXllciAoMikgKENvZGUgbGVuZ3RoKSA8PCA4IHwgSHVmZlZhbFxuLy9cbi8vXHRIdWZmbWFuVmFsdWUodGFibGUgICBIdWZmVGFiW3hdW3ldIChleCkgSHVmZm1hblZhbHVlKEh1ZmZUYWJbMV1bMF0sLi4uKVxuLy9cdCAgICAgICAgICAgICAgICApOlxuLy9cdCAgICByZXR1cm46IEh1ZmZtYW4gVmFsdWUgb2YgdGFibGVcbi8vXHQgICAgICAgICAgICAweEZGPz8gaWYgaXQgcmVjZWl2ZXMgYSBNQVJLRVJcbi8vXHQgICAgUGFyYW1ldGVyOiAgdGFibGUgICBIdWZmVGFiW3hdW3ldIChleCkgSHVmZm1hblZhbHVlKEh1ZmZUYWJbMV1bMF0sLi4uKVxuLy9cdCAgICAgICAgICAgICAgICB0ZW1wICAgIHRlbXAgc3RvcmFnZSBmb3IgcmVtYWluZGVkIGJpdHNcbi8vXHQgICAgICAgICAgICAgICAgaW5kZXggICBpbmRleCB0byBiaXQgb2YgdGVtcFxuLy9cdCAgICAgICAgICAgICAgICBpbiAgICAgIEZJTEUgcG9pbnRlclxuLy9cdCAgICBFZmZlY3Q6XG4vL1x0ICAgICAgICB0ZW1wICBzdG9yZSBuZXcgcmVtYWluZGVkIGJpdHNcbi8vXHQgICAgICAgIGluZGV4IGNoYW5nZSB0byBuZXcgaW5kZXhcbi8vXHQgICAgICAgIGluICAgIGNoYW5nZSB0byBuZXcgcG9zaXRpb25cbi8vXHQgICAgTk9URTpcbi8vXHQgICAgICBJbml0aWFsIGJ5ICAgdGVtcD0wOyBpbmRleD0wO1xuLy9cdCAgICBOT1RFOiAoZXhwbGFpbiB0ZW1wIGFuZCBpbmRleClcbi8vXHQgICAgICB0ZW1wOiBpcyBhbHdheXMgaW4gdGhlIGZvcm0gYXQgY2FsbGluZyB0aW1lIG9yIHJldHVybmluZyB0aW1lXG4vL1x0ICAgICAgIHwgIGJ5dGUgNCAgfCAgYnl0ZSAzICB8ICBieXRlIDIgIHwgIGJ5dGUgMSAgfFxuLy9cdCAgICAgICB8ICAgICAwICAgIHwgICAgIDAgICAgfCAwMDAwMDAwMCB8IDAwMDAwPz8/IHwgIGlmIG5vdCBhIE1BUktFUlxuLy9cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXmluZGV4PTMgKGZyb20gMCB0byAxNSlcbi8vXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMyMVxuLy9cdCAgICBOT1RFIChtYXJrZXIgYW5kIG1hcmtlcl9pbmRleCk6XG4vL1x0ICAgICAgSWYgZ2V0IGEgTUFSS0VSIGZyb20gJ2luJywgbWFya2VyPXRoZSBsb3ctYnl0ZSBvZiB0aGUgTUFSS0VSXG4vL1x0ICAgICAgICBhbmQgbWFya2VyX2luZGV4PTlcbi8vXHQgICAgICBJZiBtYXJrZXJfaW5kZXg9OSB0aGVuIGluZGV4IGlzIGFsd2F5cyA+IDgsIG9yIEh1ZmZtYW5WYWx1ZSgpXG4vL1x0ICAgICAgICB3aWxsIG5vdCBiZSBjYWxsZWRcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0SHVmZm1hblZhbHVlID0gZnVuY3Rpb24gKHRhYmxlLCB0ZW1wLCBpbmRleCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjb2RlLCBpbnB1dCwgbWFzaztcbiAgICBtYXNrID0gMHhGRkZGO1xuXG4gICAgaWYgKGluZGV4WzBdIDwgOCkge1xuICAgICAgICB0ZW1wWzBdIDw8PSA4O1xuICAgICAgICBpbnB1dCA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgaWYgKGlucHV0ID09PSAweEZGKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlciAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSA5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhbMF0gLT0gODtcbiAgICB9XG5cbiAgICBjb2RlID0gdGFibGVbdGVtcFswXSA+PiBpbmRleFswXV07XG5cbiAgICBpZiAoKGNvZGUgJiBqcGVnLmxvc3NsZXNzLkRlY29kZXIuTVNCKSAhPT0gMCkge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXJJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gMHhGRjAwIHwgdGhpcy5tYXJrZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wWzBdICY9IChtYXNrID4+ICgxNiAtIGluZGV4WzBdKSk7XG4gICAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICAgIGlucHV0ID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gMHhGRikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgICAgIGNvZGUgPSB0YWJsZVsoKGNvZGUgJiAweEZGKSAqIDI1NikgKyAodGVtcFswXSA+PiBpbmRleFswXSldO1xuICAgICAgICBpbmRleFswXSArPSA4O1xuICAgIH1cblxuICAgIGluZGV4WzBdICs9IDggLSAoY29kZSA+PiA4KTtcblxuICAgIGlmIChpbmRleFswXSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXg9XCIgKyBpbmRleFswXSArIFwiIHRlbXA9XCIgKyB0ZW1wWzBdICsgXCIgY29kZT1cIiArIGNvZGUgKyBcIiBpbiBIdWZmbWFuVmFsdWUoKVwiKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXhbMF0gPCB0aGlzLm1hcmtlckluZGV4KSB7XG4gICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gMHhGRjAwIHwgdGhpcy5tYXJrZXI7XG4gICAgfVxuXG4gICAgdGVtcFswXSAmPSAobWFzayA+PiAoMTYgLSBpbmRleFswXSkpO1xuICAgIHJldHVybiBjb2RlICYgMHhGRjtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldG4gPSBmdW5jdGlvbiAoUFJFRCwgbiwgdGVtcCwgaW5kZXgpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgcmVzdWx0LCBvbmUsIG5fb25lLCBtYXNrLCBpbnB1dDtcbiAgICBvbmUgPSAxO1xuICAgIG5fb25lID0gLTE7XG4gICAgbWFzayA9IDB4RkZGRjtcblxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChuID09PSAxNikge1xuICAgICAgICBpZiAoUFJFRFswXSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTMyNzY4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDMyNzY4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXhbMF0gLT0gbjtcblxuICAgIGlmIChpbmRleFswXSA+PSAwKSB7XG4gICAgICAgIGlmICgoaW5kZXhbMF0gPCB0aGlzLm1hcmtlckluZGV4KSAmJiAhdGhpcy5pc0xhc3RQaXhlbCgpKSB7IC8vIHRoaXMgd2FzIGNvcnJ1cHRpbmcgdGhlIGxhc3QgcGl4ZWwgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gKDB4RkYwMCB8IHRoaXMubWFya2VyKSA8PCA4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGVtcFswXSA+PiBpbmRleFswXTtcbiAgICAgICAgdGVtcFswXSAmPSAobWFzayA+PiAoMTYgLSBpbmRleFswXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICAgIGlucHV0ID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gMHhGRikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgICAgIGluZGV4WzBdICs9IDg7XG5cbiAgICAgICAgaWYgKGluZGV4WzBdIDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VySW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDB4RkYwMCB8IHRoaXMubWFya2VyKSA8PCA4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZW1wWzBdIDw8PSA4O1xuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG5cbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gMHhGRikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlciAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgICAgICAgICBpbmRleFswXSArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4WzBdIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXg9XCIgKyBpbmRleFswXSArIFwiIGluIGdldG4oKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleFswXSA8IHRoaXMubWFya2VySW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICAgICAgcmV0dXJuICgweEZGMDAgfCB0aGlzLm1hcmtlcikgPDwgODtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRlbXBbMF0gPj4gaW5kZXhbMF07XG4gICAgICAgIHRlbXBbMF0gJj0gKG1hc2sgPj4gKDE2IC0gaW5kZXhbMF0pKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0IDwgKG9uZSA8PCAobiAtIDEpKSkge1xuICAgICAgICByZXN1bHQgKz0gKG5fb25lIDw8IG4pICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0UHJldmlvdXNYID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICBpZiAodGhpcy54TG9jID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoKCgodGhpcy55TG9jICogdGhpcy54RGltKSArIHRoaXMueExvYykgLSAxKSwgY29tcE9mZnNldCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnlMb2MgPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKDEgPDwgKHRoaXMuZnJhbWUucHJlY2lzaW9uIC0gMSkpO1xuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldFByZXZpb3VzWFkgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIGlmICgodGhpcy54TG9jID4gMCkgJiYgKHRoaXMueUxvYyA+IDApKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldHRlcigoKCgodGhpcy55TG9jIC0gMSkgKiB0aGlzLnhEaW0pICsgdGhpcy54TG9jKSAtIDEpLCBjb21wT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCk7XG4gICAgfVxufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0UHJldmlvdXNZID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICBpZiAodGhpcy55TG9jID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoKCgodGhpcy55TG9jIC0gMSkgKiB0aGlzLnhEaW0pICsgdGhpcy54TG9jKSwgY29tcE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpO1xuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmlzTGFzdFBpeGVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy54TG9jID09PSAodGhpcy54RGltIC0gMSkpICYmICh0aGlzLnlMb2MgPT09ICh0aGlzLnlEaW0gLSAxKSk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5vdXRwdXRTaW5nbGUgPSBmdW5jdGlvbiAoUFJFRCkge1xuICAgIGlmICgodGhpcy54TG9jIDwgdGhpcy54RGltKSAmJiAodGhpcy55TG9jIDwgdGhpcy55RGltKSkge1xuICAgICAgICB0aGlzLnNldHRlcigoKCh0aGlzLnlMb2MgKiB0aGlzLnhEaW0pICsgdGhpcy54TG9jKSksIHRoaXMubWFzayAmIFBSRURbMF0pO1xuXG4gICAgICAgIHRoaXMueExvYys9MTtcblxuICAgICAgICBpZiAodGhpcy54TG9jID49IHRoaXMueERpbSkge1xuICAgICAgICAgICAgdGhpcy55TG9jKz0xO1xuICAgICAgICAgICAgdGhpcy54TG9jID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLm91dHB1dFJHQiA9IGZ1bmN0aW9uIChQUkVEKSB7XG4gICAgdmFyIG9mZnNldCA9ICgodGhpcy55TG9jICogdGhpcy54RGltKSArIHRoaXMueExvYyk7XG5cbiAgICBpZiAoKHRoaXMueExvYyA8IHRoaXMueERpbSkgJiYgKHRoaXMueUxvYyA8IHRoaXMueURpbSkpIHtcbiAgICAgICAgdGhpcy5zZXR0ZXIob2Zmc2V0LCBQUkVEWzBdLCAwKTtcbiAgICAgICAgdGhpcy5zZXR0ZXIob2Zmc2V0LCBQUkVEWzFdLCAxKTtcbiAgICAgICAgdGhpcy5zZXR0ZXIob2Zmc2V0LCBQUkVEWzJdLCAyKTtcblxuICAgICAgICB0aGlzLnhMb2MrPTE7XG5cbiAgICAgICAgaWYgKHRoaXMueExvYyA+PSB0aGlzLnhEaW0pIHtcbiAgICAgICAgICAgIHRoaXMueUxvYys9MTtcbiAgICAgICAgICAgIHRoaXMueExvYyA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZXRWYWx1ZTE2ID0gZnVuY3Rpb24gKGluZGV4LCB2YWwpIHtcbiAgICB0aGlzLm91dHB1dERhdGEuc2V0SW50MTYoaW5kZXggKiAyLCB2YWwsIHRydWUpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0VmFsdWUxNiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dERhdGEuZ2V0SW50MTYoaW5kZXggKiAyLCB0cnVlKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNldFZhbHVlOCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XG4gICAgdGhpcy5vdXRwdXREYXRhLnNldEludDgoaW5kZXgsIHZhbCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRWYWx1ZTggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhLmdldEludDgoaW5kZXgpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2V0VmFsdWVSR0IgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbCwgY29tcE9mZnNldCkge1xuICAgIHRoaXMub3V0cHV0RGF0YS5zZXRVaW50OChpbmRleCAqIDMgKyBjb21wT2Zmc2V0LCB2YWwpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0VmFsdWVSR0IgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhLmdldFVpbnQ4KGluZGV4ICogMyArIGNvbXBPZmZzZXQpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUucmVhZEFwcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3VudCA9IDAsIGxlbmd0aCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHdoaWxlIChjb3VudCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuICAgIH1cblxuICAgIHJldHVybiBsZW5ndGg7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5yZWFkQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2IgPSBcIlwiLCBjb3VudCA9IDAsIGxlbmd0aDtcblxuICAgIGxlbmd0aCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHdoaWxlIChjb3VudCA8IGxlbmd0aCkge1xuICAgICAgICBzYiArPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuICAgIH1cblxuICAgIHJldHVybiBzYjtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnJlYWROdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgTGQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuXG4gICAgaWYgKExkICE9PSA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBEZWZpbmUgbnVtYmVyIGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24gW0xkIT00XVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbn07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5EZWNvZGVyO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5qcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMgPSBqcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9jb21wb25lbnQtc3BlYy5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbS5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyID0ganBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb21wb25lbnRzID0gW107IC8vIENvbXBvbmVudHNcbiAgICB0aGlzLmRpbVggPSAwOyAvLyBOdW1iZXIgb2Ygc2FtcGxlcyBwZXIgbGluZVxuICAgIHRoaXMuZGltWSA9IDA7IC8vIE51bWJlciBvZiBsaW5lc1xuICAgIHRoaXMubnVtQ29tcCA9IDA7IC8vIE51bWJlciBvZiBjb21wb25lbnQgaW4gdGhlIGZyYW1lXG4gICAgdGhpcy5wcmVjaXNpb24gPSAwOyAvLyBTYW1wbGUgUHJlY2lzaW9uIChmcm9tIHRoZSBvcmlnaW5hbCBpbWFnZSlcbn07XG5cblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGNvdW50ID0gMCwgbGVuZ3RoLCBpLCBjLCB0ZW1wO1xuXG4gICAgbGVuZ3RoID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB0aGlzLnByZWNpc2lvbiA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuXG4gICAgdGhpcy5kaW1ZID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB0aGlzLmRpbVggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHRoaXMubnVtQ29tcCA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuICAgIGZvciAoaSA9IDE7IGkgPD0gdGhpcy5udW1Db21wOyBpKz0xKSB7XG4gICAgICAgIGlmIChjb3VudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZyYW1lIGZvcm1hdCBlcnJvclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG5cbiAgICAgICAgaWYgKGNvdW50ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZyYW1lIGZvcm1hdCBlcnJvciBbYz49TGZdXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcblxuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50c1tjXSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW2NdID0gbmV3IGpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2NdLmhTYW1wID0gdGVtcCA+PiA0O1xuICAgICAgICB0aGlzLmNvbXBvbmVudHNbY10udlNhbXAgPSB0ZW1wICYgMHgwRjtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2NdLnF1YW50VGFibGVTZWwgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZyYW1lIGZvcm1hdCBlcnJvciBbTGYhPWNvdW50XVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXI7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuVXRpbHMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbHMuanMnKSA6IG51bGwpO1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgPSBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSg0LCAyLCAxNik7XG4gICAgdGhpcy50aCA9IFtdO1xuICAgIHRoaXMudiA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgMiwgMTYsIDIwMCk7XG4gICAgdGhpcy50YyA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgMik7XG5cbiAgICB0aGlzLnRjWzBdWzBdID0gMDtcbiAgICB0aGlzLnRjWzFdWzBdID0gMDtcbiAgICB0aGlzLnRjWzJdWzBdID0gMDtcbiAgICB0aGlzLnRjWzNdWzBdID0gMDtcbiAgICB0aGlzLnRjWzBdWzFdID0gMDtcbiAgICB0aGlzLnRjWzFdWzFdID0gMDtcbiAgICB0aGlzLnRjWzJdWzFdID0gMDtcbiAgICB0aGlzLnRjWzNdWzFdID0gMDtcbiAgICB0aGlzLnRoWzBdID0gMDtcbiAgICB0aGlzLnRoWzFdID0gMDtcbiAgICB0aGlzLnRoWzJdID0gMDtcbiAgICB0aGlzLnRoWzNdID0gMDtcbn07XG5cblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUuTVNCID0gMHg4MDAwMDAwMDtcblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihkYXRhLCBIdWZmVGFiKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGNvdW50ID0gMCwgbGVuZ3RoLCB0ZW1wLCB0LCBjLCBpLCBqO1xuXG4gICAgbGVuZ3RoID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgdCA9IHRlbXAgJiAweDBGO1xuICAgICAgICBpZiAodCA+IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIElEID4gM1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMgPSB0ZW1wID4+IDQ7XG4gICAgICAgIGlmIChjID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IEh1ZmZtYW4gdGFibGUgW1RhYmxlIGNsYXNzID4gMiBdXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aFt0XSA9IDE7XG4gICAgICAgIHRoaXMudGNbdF1bY10gPSAxO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSs9MSkge1xuICAgICAgICAgICAgdGhpcy5sW3RdW2NdW2ldID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSs9MSkge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMubFt0XVtjXVtpXTsgais9MSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogSHVmZm1hbiB0YWJsZSBmb3JtYXQgZXJyb3IgW2NvdW50PkxoXVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnZbdF1bY11baV1bal0gPSBkYXRhLmdldDgoKTtcbiAgICAgICAgICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3VudCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIGZvcm1hdCBlcnJvciBbY291bnQhPUxmXVwiKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSs9MSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMjsgais9MSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGNbaV1bal0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkSHVmZlRhYmxlKEh1ZmZUYWJbaV1bal0sIHRoaXMubFtpXVtqXSwgdGhpcy52W2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuXG5cbi8vXHRCdWlsZF9IdWZmVGFiKClcbi8vXHRQYXJhbWV0ZXI6ICB0ICAgICAgIHRhYmxlIElEXG4vL1x0ICAgICAgICAgICAgYyAgICAgICB0YWJsZSBjbGFzcyAoIDAgZm9yIERDLCAxIGZvciBBQyApXG4vL1x0ICAgICAgICAgICAgTFtpXSAgICAjIG9mIGNvZGV3b3JkcyB3aGljaCBsZW5ndGggaXMgaVxuLy9cdCAgICAgICAgICAgIFZbaV1bal0gSHVmZm1hbiBWYWx1ZSAobGVuZ3RoPWkpXG4vL1x0RWZmZWN0OlxuLy9cdCAgICBidWlsZCB1cCBIdWZmVGFiW3RdW2NdIHVzaW5nIEwgYW5kIFYuXG5qcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZS5wcm90b3R5cGUuYnVpbGRIdWZmVGFibGUgPSBmdW5jdGlvbih0YWIsIEwsIFYpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY3VycmVudFRhYmxlLCB0ZW1wLCBrLCBpLCBqLCBuO1xuICAgIHRlbXAgPSAyNTY7XG4gICAgayA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSs9MSkgeyAvLyBpKzEgaXMgQ29kZSBsZW5ndGhcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IExbaV07IGorPTEpIHtcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAodGVtcCA+PiAoaSArIDEpKTsgbis9MSkge1xuICAgICAgICAgICAgICAgIHRhYltrXSA9IFZbaV1bal0gfCAoKGkgKyAxKSA8PCA4KTtcbiAgICAgICAgICAgICAgICBrKz0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMTsgayA8IDI1NjsgaSs9MSwgays9MSkge1xuICAgICAgICB0YWJba10gPSBpIHwganBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUuTVNCO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYWJsZSA9IDE7XG4gICAgayA9IDA7XG5cbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrPTEpIHsgLy8gaSsxIGlzIENvZGUgbGVuZ3RoXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBMW2ldOyBqKz0xKSB7XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgKHRlbXAgPj4gKGkgLSA3KSk7IG4rPTEpIHtcbiAgICAgICAgICAgICAgICB0YWJbKGN1cnJlbnRUYWJsZSAqIDI1NikgKyBrXSA9IFZbaV1bal0gfCAoKGkgKyAxKSA8PCA4KTtcbiAgICAgICAgICAgICAgICBrKz0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoayA+PSAyNTYpIHtcbiAgICAgICAgICAgICAgICBpZiAoayA+IDI1Nikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogSHVmZm1hbiB0YWJsZSBlcnJvcigxKSFcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhYmxlKz0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGU7XG59XG4iLCIvKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYyA9IGpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2NvbXBvbmVudC1zcGVjLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuRGVjb2RlciA9IGpwZWcubG9zc2xlc3MuRGVjb2RlciB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RlY29kZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciA9IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9mcmFtZS1oZWFkZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgPSBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2h1ZmZtYW4tdGFibGUuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSA9IGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9xdWFudGl6YXRpb24tdGFibGUuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50ID0ganBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50IHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vc2Nhbi1jb21wb25lbnQuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyID0ganBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vc2Nhbi1oZWFkZXIuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5VdGlscyA9IGpwZWcubG9zc2xlc3MuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlscy5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlV0aWxzID0ganBlZy5sb3NzbGVzcy5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxzLmpzJykgOiBudWxsKTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgPSBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZWNpc2lvbiA9IFtdOyAvLyBRdWFudGl6YXRpb24gcHJlY2lzaW9uIDggb3IgMTZcbiAgICB0aGlzLnRxID0gW107IC8vIDE6IHRoaXMgdGFibGUgaXMgcHJlc2VudGVkXG4gICAgdGhpcy5xdWFudFRhYmxlcyA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgNjQpOyAvLyBUYWJsZXNcblxuICAgIHRoaXMudHFbMF0gPSAwO1xuICAgIHRoaXMudHFbMV0gPSAwO1xuICAgIHRoaXMudHFbMl0gPSAwO1xuICAgIHRoaXMudHFbM10gPSAwO1xufTtcblxuXG5cbi8qKiogU3RhdGljIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlLmVuaGFuY2VRdWFudGl6YXRpb25UYWJsZSA9IGZ1bmN0aW9uKHF0YWIsIHRhYmxlKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSs9MSkge1xuICAgICAgICBxdGFiW3RhYmxlWygwICogOCkgKyBpXV0gKj0gOTA7XG4gICAgICAgIHF0YWJbdGFibGVbKDQgKiA4KSArIGldXSAqPSA5MDtcbiAgICAgICAgcXRhYlt0YWJsZVsoMiAqIDgpICsgaV1dICo9IDExODtcbiAgICAgICAgcXRhYlt0YWJsZVsoNiAqIDgpICsgaV1dICo9IDQ5O1xuICAgICAgICBxdGFiW3RhYmxlWyg1ICogOCkgKyBpXV0gKj0gNzE7XG4gICAgICAgIHF0YWJbdGFibGVbKDEgKiA4KSArIGldXSAqPSAxMjY7XG4gICAgICAgIHF0YWJbdGFibGVbKDcgKiA4KSArIGldXSAqPSAyNTtcbiAgICAgICAgcXRhYlt0YWJsZVsoMyAqIDgpICsgaV1dICo9IDEwNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSs9MSkge1xuICAgICAgICBxdGFiW3RhYmxlWzAgKyAoOCAqIGkpXV0gKj0gOTA7XG4gICAgICAgIHF0YWJbdGFibGVbNCArICg4ICogaSldXSAqPSA5MDtcbiAgICAgICAgcXRhYlt0YWJsZVsyICsgKDggKiBpKV1dICo9IDExODtcbiAgICAgICAgcXRhYlt0YWJsZVs2ICsgKDggKiBpKV1dICo9IDQ5O1xuICAgICAgICBxdGFiW3RhYmxlWzUgKyAoOCAqIGkpXV0gKj0gNzE7XG4gICAgICAgIHF0YWJbdGFibGVbMSArICg4ICogaSldXSAqPSAxMjY7XG4gICAgICAgIHF0YWJbdGFibGVbNyArICg4ICogaSldXSAqPSAyNTtcbiAgICAgICAgcXRhYlt0YWJsZVszICsgKDggKiBpKV1dICo9IDEwNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrPTEpIHtcbiAgICAgICAgcXRhYltpXSA+Pj0gNjtcbiAgICB9XG59O1xuXG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGRhdGEsIHRhYmxlKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGNvdW50ID0gMCwgbGVuZ3RoLCB0ZW1wLCB0LCBpO1xuXG4gICAgbGVuZ3RoID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgdCA9IHRlbXAgJiAweDBGO1xuXG4gICAgICAgIGlmICh0ID4gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBJRCA+IDNcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZWNpc2lvblt0XSA9IHRlbXAgPj4gNDtcblxuICAgICAgICBpZiAodGhpcy5wcmVjaXNpb25bdF0gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlY2lzaW9uW3RdID0gODtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvblt0XSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5wcmVjaXNpb25bdF0gPSAxNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBRdWFudGl6YXRpb24gdGFibGUgcHJlY2lzaW9uIGVycm9yXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cVt0XSA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMucHJlY2lzaW9uW3RdID09PSA4KSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBmb3JtYXQgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5xdWFudFRhYmxlc1t0XVtpXSA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICAgICAgICAgIGNvdW50Kz0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlLmVuaGFuY2VRdWFudGl6YXRpb25UYWJsZSh0aGlzLnF1YW50VGFibGVzW3RdLCB0YWJsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBmb3JtYXQgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5xdWFudFRhYmxlc1t0XVtpXSA9IGRhdGEuZ2V0MTYoKTtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlLmVuaGFuY2VRdWFudGl6YXRpb25UYWJsZSh0aGlzLnF1YW50VGFibGVzW3RdLCB0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY291bnQgIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogUXVhbnRpemF0aW9uIHRhYmxlIGVycm9yIFtjb3VudCE9THFdXCIpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQgPSBqcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWNUYWJTZWwgPSAwOyAvLyBBQyB0YWJsZSBzZWxlY3RvclxuICAgIHRoaXMuZGNUYWJTZWwgPSAwOyAvLyBEQyB0YWJsZSBzZWxlY3RvclxuICAgIHRoaXMuc2NhbkNvbXBTZWwgPSAwOyAvLyBTY2FuIGNvbXBvbmVudCBzZWxlY3RvclxufTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQ7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCA9IGpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3NjYW4tY29tcG9uZW50LmpzJykgOiBudWxsKTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuU2NhbkhlYWRlciA9IGpwZWcubG9zc2xlc3MuU2NhbkhlYWRlciB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5haCA9IDA7XG4gICAgdGhpcy5hbCA9IDA7XG4gICAgdGhpcy5udW1Db21wID0gMDsgLy8gTnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIHNjYW5cbiAgICB0aGlzLnNlbGVjdGlvbiA9IDA7IC8vIFN0YXJ0IG9mIHNwZWN0cmFsIG9yIHByZWRpY3RvciBzZWxlY3Rpb25cbiAgICB0aGlzLnNwZWN0cmFsRW5kID0gMDsgLy8gRW5kIG9mIHNwZWN0cmFsIHNlbGVjdGlvblxuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xufTtcblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjb3VudCA9IDAsIGxlbmd0aCwgaSwgdGVtcDtcblxuICAgIGxlbmd0aCA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgdGhpcy5udW1Db21wID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQrPTE7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW1Db21wOyBpKz0xKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tpXSA9IG5ldyBqcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQoKTtcblxuICAgICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBzY2FuIGhlYWRlciBmb3JtYXQgZXJyb3JcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbaV0uc2NhbkNvbXBTZWwgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG5cbiAgICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcblxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbaV0uZGNUYWJTZWwgPSAodGVtcCA+PiA0KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2ldLmFjVGFiU2VsID0gKHRlbXAgJiAweDBGKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbGVjdGlvbiA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuXG4gICAgdGhpcy5zcGVjdHJhbEVuZCA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuXG4gICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgIHRoaXMuYWggPSAodGVtcCA+PiA0KTtcbiAgICB0aGlzLmFsID0gKHRlbXAgJiAweDBGKTtcbiAgICBjb3VudCs9MTtcblxuICAgIGlmIChjb3VudCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBzY2FuIGhlYWRlciBmb3JtYXQgZXJyb3IgW2NvdW50IT1Oc11cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuU2NhbkhlYWRlcjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5VdGlscyA9IGpwZWcubG9zc2xlc3MuVXRpbHMgfHwge307XG5cblxuLyoqKiBTdGF0aWMgbWV0aG9kcyAqKiovXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTY2MjI1L2hvdy1jYW4taS1jcmVhdGUtYS10d28tZGltZW5zaW9uYWwtYXJyYXktaW4tamF2YXNjcmlwdFxuanBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbmd0aCB8fCAwKSxcbiAgICAgICAgaSA9IGxlbmd0aDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHdoaWxlKGktLSkgYXJyW2xlbmd0aC0xIC0gaV0gPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG59O1xuXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg2Mzg5MDAvamF2YXNjcmlwdC1jcmMzMlxuanBlZy5sb3NzbGVzcy5VdGlscy5tYWtlQ1JDVGFibGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjO1xuICAgIHZhciBjcmNUYWJsZSA9IFtdO1xuICAgIGZvcih2YXIgbiA9MDsgbiA8IDI1NjsgbisrKXtcbiAgICAgICAgYyA9IG47XG4gICAgICAgIGZvcih2YXIgayA9MDsgayA8IDg7IGsrKyl7XG4gICAgICAgICAgICBjID0gKChjJjEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjcmNUYWJsZVtuXSA9IGM7XG4gICAgfVxuICAgIHJldHVybiBjcmNUYWJsZTtcbn07XG5cbmpwZWcubG9zc2xlc3MuVXRpbHMuY3JjMzIgPSBmdW5jdGlvbihkYXRhVmlldykge1xuICAgIHZhciBjcmNUYWJsZSA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JjVGFibGUgfHwgKGpwZWcubG9zc2xlc3MuVXRpbHMuY3JjVGFibGUgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLm1ha2VDUkNUYWJsZSgpKTtcbiAgICB2YXIgY3JjID0gMCBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFWaWV3LmJ5dGVMZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiBjcmNUYWJsZVsoY3JjIF4gZGF0YVZpZXcuZ2V0VWludDgoaSkpICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKSA+Pj4gMDtcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuVXRpbHM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBGVU5DVElPTjogYWJzKCB4IClcbipcdENvbXB1dGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IC0gaW5wdXQgdmFsdWVcbiogQHJldHVybnMge051bWJlcn0gYWJzb2x1dGUgdmFsdWVcbiovXG5mdW5jdGlvbiBhYnMoIHggKSB7XG5cdGlmICggeCA8IDAgKSB7XG5cdFx0cmV0dXJuIC14O1xuXHR9XG5cdGlmICggeCA9PT0gMCApIHtcblx0XHRyZXR1cm4gMDsgLy8gaGFuZGxlIG5lZ2F0aXZlIHplcm9cblx0fVxuXHRyZXR1cm4geDtcbn0gLy8gZW5kIEZVTkNUSU9OIGFicygpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFicztcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguY2VpbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZmxvb3IgPSByZXF1aXJlKCAnbWF0aC1mbG9vcicgKTtcblxuXG4vLyBESVYyIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogZGl2MiggeCApXG4qXHRDb252ZXJ0cyBhIG5vbm5lZ2F0aXZlIGludGVnZXIgdG8gYSBsaXRlcmFsIGJpdCByZXByZXNlbnRhdGlvbiB1c2luZyB0aGUgZGl2aWRlLWJ5LTIgYWxnb3JpdGhtLlxuKlxuKiBAcGFyYW0ge051bWJlcn0geCAtIG5vbm5lZ2F0aXZlIGludGVnZXJcbiogQHJldHVybnMge1N0cmluZ30gYml0IHJlcHJlc2VudGF0aW9uXG4qL1xuZnVuY3Rpb24gZGl2MiggeCApIHtcblx0dmFyIHN0ciA9ICcnO1xuXHR2YXIgeTtcblxuXHQvLyBXZSByZXBlYXRlZGx5IGRpdmlkZSBieSAyIGFuZCBjaGVjayBmb3IgYSByZW1haW5kZXIuIElmIGEgcmVtYWluZGVyIGV4aXN0cywgdGhlIG51bWJlciBpcyBvZGQgYW5kIHdlIGFkZCBhICcxJyBiaXQuLi5cblx0d2hpbGUgKCB4ID4gMCApIHtcblx0XHR5ID0geCAvIDI7XG5cdFx0eCA9IGZsb29yKCB5ICk7XG5cdFx0aWYgKCB5ID09PSB4ICkge1xuXHRcdFx0c3RyID0gJzAnICsgc3RyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHIgPSAnMScgKyBzdHI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdHI7XG59IC8vIGVuZCBGVU5DVElPTiBkaXYyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gZGl2MjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgcGluZiA9IHJlcXVpcmUoICdjb25zdC1waW5mLWZsb2F0MzInICk7XG52YXIgbmluZiA9IHJlcXVpcmUoICdjb25zdC1uaW5mLWZsb2F0MzInICk7XG52YXIgYWJzID0gcmVxdWlyZSggJ21hdGgtYWJzJyApO1xudmFyIGZsb29yID0gcmVxdWlyZSggJ21hdGgtZmxvb3InICk7XG52YXIgcnBhZCA9IHJlcXVpcmUoICd1dGlscy1yaWdodC1wYWQtc3RyaW5nJyApO1xudmFyIGxwYWQgPSByZXF1aXJlKCAndXRpbHMtbGVmdC1wYWQtc3RyaW5nJyApO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoICd1dGlscy1yZXBlYXQtc3RyaW5nJyApO1xudmFyIGRpdjIgPSByZXF1aXJlKCAnLi9kaXYyLmpzJyApO1xudmFyIG11bHQyID0gcmVxdWlyZSggJy4vbXVsdDIuanMnICk7XG5cblxuLy8gQ09OU1RBTlRTIC8vXG5cbnZhciBCSUFTID0gMTI3OyAvLyBleHBvbmVudCBiaWFzID0+ICgyKio4KS8yIC0gMVxuXG5cbi8vIEJJTkFSWSBTVFJJTkcgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBiaW5hcnlTdHJpbmcoIHggKVxuKlx0UmV0dXJucyBhIHN0cmluZyBnaXZpbmcgdGhlIGxpdGVyYWwgYml0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IC0gaW5wdXQgdmFsdWVcbiogQHJldHVybnMge1N0cmluZ30gYml0IHJlcHJlc2VudGF0aW9uXG4qL1xuZnVuY3Rpb24gYmluYXJ5U3RyaW5nKCB4ICkge1xuXHR2YXIgbmJpdHM7XG5cdHZhciBzaWduO1xuXHR2YXIgc3RyO1xuXHR2YXIgZXhwO1xuXHR2YXIgbjtcblx0dmFyIGY7XG5cdHZhciBpO1xuXG5cdC8vIENoZWNrIGZvciBhIG5lZ2F0aXZlIHZhbHVlIG9yIG5lZ2F0aXZlIHplcm8uLi5cblx0aWYgKCB4IDwgMCB8fCAxL3ggPT09IG5pbmYgKSB7XG5cdFx0c2lnbiA9ICcxJztcblx0fSBlbHNlIHtcblx0XHRzaWduID0gJzAnO1xuXHR9XG5cdC8vIFNwZWNpYWwgY2FzZTogKy1pbmZpbml0eVxuXHRpZiAoIHggPT09IHBpbmYgfHwgeCA9PT0gbmluZiApIHtcblx0XHQvLyBCYXNlZCBvbiBJRUVFIDc1NC0yMDA4Li4uXG5cdFx0ZXhwID0gcmVwZWF0KCAnMScsIDggKTsgLy8gYWxsIDFzXG5cdFx0c3RyID0gcmVwZWF0KCAnMCcsIDIzICk7IC8vIGFsbCAwc1xuXHRcdHJldHVybiBzaWduICsgZXhwICsgc3RyO1xuXHR9XG5cdC8vIFNwZWNpYWwgY2FzZTogTmFOXG5cdGlmICggeCAhPT0geCApIHtcblx0XHQvLyBCYXNlZCBvbiBJRUVFIDc1NC0yMDA4Li4uXG5cdFx0ZXhwID0gcmVwZWF0KCAnMScsIDggKTsgLy8gYWxsIDFzXG5cdFx0c3RyID0gJzEnICsgcmVwZWF0KCAnMCcsIDIyICk7IC8vIGNhbid0IGJlIGFsbCAwc1xuXHRcdHJldHVybiBzaWduICsgZXhwICsgc3RyO1xuXHR9XG5cdC8vIFNwZWNpYWwgY2FzZTogKy0wXG5cdGlmICggeCA9PT0gMCApIHtcblx0XHQvLyBCYXNlZCBvbiBJRUVFIDc1NC0yMDA4Li4uXG5cdFx0ZXhwID0gcmVwZWF0KCAnMCcsIDggKTsgLy8gYWxsIDBzXG5cdFx0c3RyID0gcmVwZWF0KCAnMCcsIDIzICk7IC8vIGFsbCAwc1xuXHRcdHJldHVybiBzaWduICsgZXhwICsgc3RyO1xuXHR9XG5cdHggPSBhYnMoIHggKTtcblxuXHQvLyBJc29sYXRlIHRoZSBpbnRlZ2VyIHBhcnQgKGRpZ2l0cyBiZWZvcmUgdGhlIGRlY2ltYWwpOlxuXHRuID0gZmxvb3IoIHggKTtcblxuXHQvLyBJc29sYXRlIHRoZSBmcmFjdGlvbmFsIHBhcnQgKGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCk6XG5cdGYgPSB4IC0gbjtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIHBhcnRzIHRvIGJpdCBzdHJpbmdzOlxuXHRuID0gZGl2MiggbiApO1xuXHRmID0gbXVsdDIoIGYgKTtcblxuXHQvLyBEZXRlcm1pbmUgdGhlIGV4cG9uZW50IG5lZWRlZCB0byBub3JtYWxpemUgdGhlIGludGVnZXIrZnJhY3Rpb25hbCBwYXJ0cy4uLlxuXHRpZiAoIG4gKSB7XG5cdFx0Ly8gTW92ZSB0aGUgZGVjaW1hbCBgZGAgZGlnaXRzIHRvIHRoZSBsZWZ0OlxuXHRcdGV4cCA9IG4ubGVuZ3RoIC0gMTtcblx0fSBlbHNlIHtcblx0XHQvLyBGaW5kIHRoZSBmaXJzdCAnMScgYml0Li4uXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBmLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCBmWyBpIF0gPT09ICcxJyApIHtcblx0XHRcdFx0bmJpdHMgPSBpICsgMTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE1vdmUgdGhlIGRlY2ltYWwgYGRgIGRpZ2l0cyB0byB0aGUgcmlnaHQ6XG5cdFx0ZXhwID0gLW5iaXRzO1xuXHR9XG5cdC8vIE5vcm1hbGl6ZSB0aGUgY29tYmluZWQgaW50ZWdlcitmcmFjdGlvbmFsIHN0cmluZy4uLlxuXHRzdHIgPSBuICsgZjtcblx0aWYgKCBleHAgPCAwICkge1xuXHRcdC8vIEhhbmRsZSBzdWJub3JtYWxzLi4uXG5cdFx0aWYgKCBleHAgPD0gLUJJQVMgKSB7XG5cdFx0XHQvLyBDYXAgdGhlIG51bWJlciBvZiBiaXRzIHJlbW92ZWQ6XG5cdFx0XHRuYml0cyA9IEJJQVMgLSAxO1xuXHRcdH1cblx0XHQvLyBSZW1vdmUgYWxsIGxlYWRpbmcgemVyb3MgYW5kIHRoZSBmaXJzdCAnMScgZm9yIG5vcm1hbCB2YWx1ZXMsIGFuZCwgZm9yIHN1Ym5vcm1hbHMsIHJlbW92ZSBhdCBtb3N0IEJJQVMtMSBsZWFkaW5nIGJpdHM6XG5cdFx0c3RyID0gc3RyLnN1YnN0cmluZyggbmJpdHMgKTtcblx0fSBlbHNlIHtcblx0XHQvLyBSZW1vdmUgdGhlIGxlYWRpbmcgJzEnIChpbXBsaWNpdC9oaWRkZW4gYml0KTpcblx0XHRzdHIgPSBzdHIuc3Vic3RyaW5nKCAxICk7XG5cdH1cblx0Ly8gQ29udmVydCB0aGUgZXhwb25lbnQgdG8gYSBiaXQgc3RyaW5nOlxuXHRleHAgPSBkaXYyKCBleHAgKyBCSUFTICk7XG5cdGV4cCA9IGxwYWQoIGV4cCwgOCwgJzAnICk7XG5cblx0Ly8gRmlsbCBpbiBhbnkgdHJhaWxpbmcgemVyb3MgYW5kIGVuc3VyZSB3ZSBoYXZlIG9ubHkgMjMgZnJhY3Rpb24gYml0czpcblx0c3RyID0gcnBhZCggc3RyLCAyMywgJzAnICkuc3Vic3RyaW5nKCAwLCAyMyApO1xuXG5cdC8vIFJldHVybiBhIGJpdCByZXByZXNlbnRhdGlvbjpcblx0cmV0dXJuIHNpZ24gKyBleHAgKyBzdHI7XG59IC8vIGVuZCBGVU5DVElPTiBiaW5hcnlTdHJpbmcoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5hcnlTdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgTUFYX0lURVIgPSAxNDk7IC8vIDEyNysyMiAoc3Vibm9ybWFscylcbnZhciBNQVhfQklUUyA9IDI0OyAvLyBvbmx5IDIzIGJpdHMgZm9yIGZyYWN0aW9uXG5cblxuLy8gTVVMVDIgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBtdWx0MiggeCApXG4qXHRDb252ZXJ0cyBhIGZyYWN0aW9uIHRvIGEgbGl0ZXJhbCBiaXQgcmVwcmVzZW50YXRpb24gdXNpbmcgdGhlIG11bHRpcGx5LWJ5LTIgYWxnb3JpdGhtLlxuKlxuKiBAcGFyYW0ge051bWJlcn0geCAtIG51bWJlciBsZXNzIHRoYW4gMVxuKiBAcmV0dXJucyB7U3RyaW5nfSBiaXQgcmVwcmVzZW50YXRpb25cbiovXG5mdW5jdGlvbiBtdWx0MiggeCApIHtcblx0dmFyIHN0cjtcblx0dmFyIHk7XG5cdHZhciBpO1xuXHR2YXIgajtcblxuXHRzdHIgPSAnJztcblx0aWYgKCB4ID09PSAwICkge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblx0aiA9IE1BWF9JVEVSO1xuXG5cdC8vIEVhY2ggdGltZSB3ZSBtdWx0aXBseSBieSAyIGFuZCBmaW5kIGEgb25lcyBkaWdpdCwgYWRkIGEgJzEnOyBvdGhlcndpc2UsIGFkZCBhICcwJy4uXG5cdGZvciAoIGkgPSAwOyBpIDwgTUFYX0lURVI7IGkrKyApIHtcblx0XHR5ID0geCAqIDI7XG5cdFx0aWYgKCB5ID49IDEgKSB7XG5cdFx0XHR4ID0geSAtIDE7XG5cdFx0XHRzdHIgKz0gJzEnO1xuXHRcdFx0aWYgKCBqID09PSBNQVhfSVRFUiApIHtcblx0XHRcdFx0aiA9IGk7IC8vIGZpcnN0ICcxJ1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0geTtcblx0XHRcdHN0ciArPSAnMCc7XG5cdFx0fVxuXHRcdC8vIFN0b3Agd2hlbiB3ZSBoYXZlIG5vIG1vcmUgZGVjaW1hbHMgdG8gcHJvY2VzcyBvciBpbiB0aGUgZXZlbnQgd2UgZm91bmQgYSBmcmFjdGlvbiB3aGljaCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gYSBmaW5pdGUgbnVtYmVyIG9mIGJpdHMuLi5cblx0XHRpZiAoIHkgPT09IDEgfHwgaS1qID4gTUFYX0JJVFMgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0cjtcbn0gLy8gZW5kIEZVTkNUSU9OIG11bHQyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbXVsdDI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZsb29yO1xuIiwiXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG5cbi8qKlxuICogbmlmdGlcbiAqIEB0eXBlIHsqfHt9fVxuICovXG52YXIgbmlmdGkgPSBuaWZ0aSB8fCB7fTtcbm5pZnRpLk5JRlRJMSA9IG5pZnRpLk5JRlRJMSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL25pZnRpMS5qcycpIDogbnVsbCk7XG5uaWZ0aS5OSUZUSTIgPSBuaWZ0aS5OSUZUSTIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9uaWZ0aTIuanMnKSA6IG51bGwpO1xubmlmdGkuVXRpbHMgPSBuaWZ0aS5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxpdGllcy5qcycpIDogbnVsbCk7XG5cbnZhciBwYWtvID0gcGFrbyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCdwYWtvJykgOiBudWxsKTtcblxuXG5cbi8qKiogU3RhdGljIE1ldGhvZHMgKioqL1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRhdGEgcmVwcmVzZW50cyBhIE5JRlRJLTEgaGVhZGVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm5pZnRpLmlzTklGVEkxID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgYnVmLCBtYWcxLCBtYWcyLCBtYWczO1xuXG4gICAgYnVmID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuICAgIG1hZzEgPSBidWYuZ2V0VWludDgobmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUl9MT0NBVElPTik7XG4gICAgbWFnMiA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OICsgMSk7XG4gICAgbWFnMyA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OICsgMik7XG5cbiAgICByZXR1cm4gISEoKG1hZzEgPT09IG5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJbMF0pICYmIChtYWcyID09PSBuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSWzFdKSAmJlxuICAgICAgICAobWFnMyA9PT0gbmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUlsyXSkpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRhdGEgcmVwcmVzZW50cyBhIE5JRlRJLTIgaGVhZGVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm5pZnRpLmlzTklGVEkyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgYnVmLCBtYWcxLCBtYWcyLCBtYWczO1xuXG4gICAgYnVmID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuICAgIG1hZzEgPSBidWYuZ2V0VWludDgobmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUl9MT0NBVElPTik7XG4gICAgbWFnMiA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OICsgMSk7XG4gICAgbWFnMyA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OICsgMik7XG5cbiAgICByZXR1cm4gISEoKG1hZzEgPT09IG5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJbMF0pICYmIChtYWcyID09PSBuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSWzFdKSAmJlxuICAgIChtYWczID09PSBuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSWzJdKSk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkYXRhIHJlcHJlc2VudHMgYSBOSUZUSSBoZWFkZXIuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubmlmdGkuaXNOSUZUSSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIChuaWZ0aS5pc05JRlRJMShkYXRhKSB8fCBuaWZ0aS5pc05JRlRJMihkYXRhKSk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkYXRhIGlzIEdaSVAgY29tcHJlc3NlZC5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5uaWZ0aS5pc0NvbXByZXNzZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBidWYsIG1hZ2ljQ29va2llMSwgbWFnaWNDb29raWUyO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgYnVmID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuXG4gICAgICAgIG1hZ2ljQ29va2llMSA9IGJ1Zi5nZXRVaW50OCgwKTtcbiAgICAgICAgbWFnaWNDb29raWUyID0gYnVmLmdldFVpbnQ4KDEpO1xuXG4gICAgICAgIGlmIChtYWdpY0Nvb2tpZTEgPT09IG5pZnRpLlV0aWxzLkdVTlpJUF9NQUdJQ19DT09LSUUxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYWdpY0Nvb2tpZTIgPT09IG5pZnRpLlV0aWxzLkdVTlpJUF9NQUdJQ19DT09LSUUyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgZGVjb21wcmVzc2VkIGRhdGEuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gKi9cbm5pZnRpLmRlY29tcHJlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBwYWtvLmluZmxhdGUoZGF0YSkuYnVmZmVyO1xufTtcblxuXG5cbi8qKlxuICogUmVhZHMgYW5kIHJldHVybnMgdGhlIGhlYWRlciBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7bmlmdGkuTklGVEkxfG5pZnRpLk5JRlRJMnxudWxsfVxuICovXG5uaWZ0aS5yZWFkSGVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgaGVhZGVyID0gbnVsbDtcblxuICAgIGlmIChuaWZ0aS5pc0NvbXByZXNzZWQoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IG5pZnRpLmRlY29tcHJlc3MoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKG5pZnRpLmlzTklGVEkxKGRhdGEpKSB7XG4gICAgICAgIGhlYWRlciA9IG5ldyBuaWZ0aS5OSUZUSTEoKTtcbiAgICB9IGVsc2UgaWYgKG5pZnRpLmlzTklGVEkyKGRhdGEpKSB7XG4gICAgICAgIGhlYWRlciA9IG5ldyBuaWZ0aS5OSUZUSTIoKTtcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIGhlYWRlci5yZWFkSGVhZGVyKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGF0IGZpbGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIE5JRlRJIVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgaGVhZGVyIGNvbnRhaW5zIGFuIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSB7bmlmdGkuTklGVEkxfG5pZnRpLk5JRlRJMn0gaGVhZGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubmlmdGkuaGFzRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGhlYWRlcikge1xuICAgIHJldHVybiAoaGVhZGVyLmV4dGVuc2lvbkZsYWdbMF0gIT0gMCk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbWFnZSBkYXRhLlxuICogQHBhcmFtIHtuaWZ0aS5OSUZUSTF8bmlmdGkuTklGVEkyfSBoZWFkZXJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAqL1xubmlmdGkucmVhZEltYWdlID0gZnVuY3Rpb24gKGhlYWRlciwgZGF0YSkge1xuICAgIHZhciBpbWFnZU9mZnNldCA9IGhlYWRlci52b3hfb2Zmc2V0LFxuICAgICAgICB0aW1lRGltID0gMSxcbiAgICAgICAgc3RhdERpbSA9IDE7XG5cbiAgICBpZiAoaGVhZGVyLmRpbXNbNF0pIHtcbiAgICAgICAgdGltZURpbSA9IGhlYWRlci5kaW1zWzRdO1xuICAgIH1cblxuICAgIGlmIChoZWFkZXIuZGltc1s1XSkge1xuICAgICAgICBzdGF0RGltID0gaGVhZGVyLmRpbXNbNV07XG4gICAgfVxuXG4gICAgdmFyIGltYWdlU2l6ZSA9IGhlYWRlci5kaW1zWzFdICogaGVhZGVyLmRpbXNbMl0gKiBoZWFkZXIuZGltc1szXSAqIHRpbWVEaW0gKiBzdGF0RGltICogKGhlYWRlci5udW1CaXRzUGVyVm94ZWwgLyA4KTtcbiAgICByZXR1cm4gZGF0YS5zbGljZShpbWFnZU9mZnNldCwgaW1hZ2VPZmZzZXQgKyBpbWFnZVNpemUpO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIGRhdGEgKGluY2x1ZGluZyBleHRlbnNpb24gaGVhZGVyKS5cbiAqIEBwYXJhbSB7bmlmdGkuTklGVEkxfG5pZnRpLk5JRlRJMn0gaGVhZGVyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gKi9cbm5pZnRpLnJlYWRFeHRlbnNpb24gPSBmdW5jdGlvbiAoaGVhZGVyLCBkYXRhKSB7XG4gICAgdmFyIGxvYyA9IGhlYWRlci5nZXRFeHRlbnNpb25Mb2NhdGlvbigpLFxuICAgICAgICBzaXplID0gaGVhZGVyLmV4dGVuc2lvblNpemU7XG5cbiAgICByZXR1cm4gZGF0YS5zbGljZShsb2MsIGxvYyArIHNpemUpO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIGRhdGEuXG4gKiBAcGFyYW0ge25pZnRpLk5JRlRJMXxuaWZ0aS5OSUZUSTJ9IGhlYWRlclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICovXG5uaWZ0aS5yZWFkRXh0ZW5zaW9uRGF0YSA9IGZ1bmN0aW9uIChoZWFkZXIsIGRhdGEpIHtcbiAgICB2YXIgbG9jID0gaGVhZGVyLmdldEV4dGVuc2lvbkxvY2F0aW9uKCksXG4gICAgICAgIHNpemUgPSBoZWFkZXIuZXh0ZW5zaW9uU2l6ZTtcblxuICAgIHJldHVybiBkYXRhLnNsaWNlKGxvYyArIDgsIGxvYyArIHNpemUgLSA4KTtcbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5pZnRpO1xufVxuIiwiXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cblxudmFyIG5pZnRpID0gbmlmdGkgfHwge307XG5uaWZ0aS5VdGlscyA9IG5pZnRpLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbGl0aWVzLmpzJykgOiBudWxsKTtcblxuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuXG4vKipcbiAqIFRoZSBOSUZUSTEgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGltX2luZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGRpbXMgLSBpbWFnZSBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AxXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhdHlwZUNvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1CaXRzUGVyVm94ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9zdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2VuZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHBpeERpbXMgLSB2b3hlbCBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gdm94X29mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjbF9zbG9wZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjbF9pbnRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHh5enRfdW5pdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYWxfbWF4XG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FsX21pblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2R1cmF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9mZnNldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXV4X2ZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnRlbnRfbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHFmb3JtX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZm9ybV9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9iXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9jXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9kXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl94XG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl95XG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl96XG4gKiBAcHJvcGVydHkge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGFmZmluZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1hZ2ljXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSERSIC0gaWYgaGRyL2ltZyBmb3JtYXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGV4dGVuc2lvbkZsYWdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBleHRlbnNpb25TaXplXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXh0ZW5zaW9uQ29kZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5uaWZ0aS5OSUZUSTEgPSBuaWZ0aS5OSUZUSTEgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gICAgdGhpcy5kaW1faW5mbyA9IDA7XG4gICAgdGhpcy5kaW1zID0gW107XG4gICAgdGhpcy5pbnRlbnRfcDEgPSAwO1xuICAgIHRoaXMuaW50ZW50X3AyID0gMDtcbiAgICB0aGlzLmludGVudF9wMyA9IDA7XG4gICAgdGhpcy5pbnRlbnRfY29kZSA9IDA7XG4gICAgdGhpcy5kYXRhdHlwZUNvZGUgPSAwO1xuICAgIHRoaXMubnVtQml0c1BlclZveGVsID0gMDtcbiAgICB0aGlzLnNsaWNlX3N0YXJ0ID0gMDtcbiAgICB0aGlzLnNsaWNlX2VuZCA9IDA7XG4gICAgdGhpcy5zbGljZV9jb2RlID0gMDtcbiAgICB0aGlzLnBpeERpbXMgPSBbXTtcbiAgICB0aGlzLnZveF9vZmZzZXQgPSAwO1xuICAgIHRoaXMuc2NsX3Nsb3BlID0gMTtcbiAgICB0aGlzLnNjbF9pbnRlciA9IDA7XG4gICAgdGhpcy54eXp0X3VuaXRzID0gMDtcbiAgICB0aGlzLmNhbF9tYXggPSAwO1xuICAgIHRoaXMuY2FsX21pbiA9IDA7XG4gICAgdGhpcy5zbGljZV9kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b2Zmc2V0ID0gMDtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICB0aGlzLmF1eF9maWxlID0gXCJcIjtcbiAgICB0aGlzLmludGVudF9uYW1lID0gXCJcIjtcbiAgICB0aGlzLnFmb3JtX2NvZGUgPSAwO1xuICAgIHRoaXMuc2Zvcm1fY29kZSA9IDA7XG4gICAgdGhpcy5xdWF0ZXJuX2IgPSAwO1xuICAgIHRoaXMucXVhdGVybl9jID0gMDtcbiAgICB0aGlzLnF1YXRlcm5fZCA9IDA7XG4gICAgdGhpcy5xb2Zmc2V0X3ggPSAwO1xuICAgIHRoaXMucW9mZnNldF95ID0gMDtcbiAgICB0aGlzLnFvZmZzZXRfeiA9IDA7XG4gICAgdGhpcy5hZmZpbmUgPSBbWzEsIDAsIDAsIDBdLCBbMCwgMSwgMCwgMF0sIFswLCAwLCAxLCAwXSwgWzAsIDAsIDAsIDFdXTtcbiAgICB0aGlzLm1hZ2ljID0gMDtcbiAgICB0aGlzLmlzSERSID0gZmFsc2U7XG4gICAgdGhpcy5leHRlbnNpb25GbGFnID0gWzAsIDAsIDAsIDBdO1xuICAgIHRoaXMuZXh0ZW5zaW9uU2l6ZSA9IDA7XG4gICAgdGhpcy5leHRlbnNpb25Db2RlID0gMDtcbn07XG5cblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxuLy8gZGF0YXR5cGUgY29kZXNcbm5pZnRpLk5JRlRJMS5UWVBFX05PTkUgICAgICAgICAgICA9IDA7XG5uaWZ0aS5OSUZUSTEuVFlQRV9CSU5BUlkgICAgICAgICAgPSAxO1xubmlmdGkuTklGVEkxLlRZUEVfVUlOVDggICAgICAgICAgID0gMjtcbm5pZnRpLk5JRlRJMS5UWVBFX0lOVDE2ICAgICAgICAgICA9IDQ7XG5uaWZ0aS5OSUZUSTEuVFlQRV9JTlQzMiAgICAgICAgICAgPSA4O1xubmlmdGkuTklGVEkxLlRZUEVfRkxPQVQzMiAgICAgICAgPSAxNjtcbm5pZnRpLk5JRlRJMS5UWVBFX0NPTVBMRVg2NCAgICAgID0gMzI7XG5uaWZ0aS5OSUZUSTEuVFlQRV9GTE9BVDY0ICAgICAgICA9IDY0O1xubmlmdGkuTklGVEkxLlRZUEVfUkdCMjQgICAgICAgICA9IDEyODtcbm5pZnRpLk5JRlRJMS5UWVBFX0lOVDggICAgICAgICAgPSAyNTY7XG5uaWZ0aS5OSUZUSTEuVFlQRV9VSU5UMTYgICAgICAgID0gNTEyO1xubmlmdGkuTklGVEkxLlRZUEVfVUlOVDMyICAgICAgICA9IDc2ODtcbm5pZnRpLk5JRlRJMS5UWVBFX0lOVDY0ICAgICAgICA9IDEwMjQ7XG5uaWZ0aS5OSUZUSTEuVFlQRV9VSU5UNjQgICAgICAgPSAxMjgwO1xubmlmdGkuTklGVEkxLlRZUEVfRkxPQVQxMjggICAgID0gMTUzNjtcbm5pZnRpLk5JRlRJMS5UWVBFX0NPTVBMRVgxMjggICA9IDE3OTI7XG5uaWZ0aS5OSUZUSTEuVFlQRV9DT01QTEVYMjU2ICAgPSAyMDQ4O1xuXG4vLyB0cmFuc2Zvcm0gY29kZXNcbm5pZnRpLk5JRlRJMS5YRk9STV9VTktOT1dOICAgICAgICA9IDA7XG5uaWZ0aS5OSUZUSTEuWEZPUk1fU0NBTk5FUl9BTkFUICAgPSAxO1xubmlmdGkuTklGVEkxLlhGT1JNX0FMSUdORURfQU5BVCAgID0gMjtcbm5pZnRpLk5JRlRJMS5YRk9STV9UQUxBSVJBQ0ggICAgICA9IDM7XG5uaWZ0aS5OSUZUSTEuWEZPUk1fTU5JXzE1MiAgICAgICAgPSA0O1xuXG4vLyB1bml0IGNvZGVzXG5uaWZ0aS5OSUZUSTEuU1BBVElBTF9VTklUU19NQVNLID0gMHgwNztcbm5pZnRpLk5JRlRJMS5URU1QT1JBTF9VTklUU19NQVNLID0gMHgzODtcbm5pZnRpLk5JRlRJMS5VTklUU19VTktOT1dOICAgICAgICA9IDA7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfTUVURVIgICAgICAgICAgPSAxO1xubmlmdGkuTklGVEkxLlVOSVRTX01NICAgICAgICAgICAgID0gMjtcbm5pZnRpLk5JRlRJMS5VTklUU19NSUNST04gICAgICAgICA9IDM7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfU0VDICAgICAgICAgICAgPSA4O1xubmlmdGkuTklGVEkxLlVOSVRTX01TRUMgICAgICAgICAgPSAxNjtcbm5pZnRpLk5JRlRJMS5VTklUU19VU0VDICAgICAgICAgID0gMjQ7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfSFogICAgICAgICAgICA9IDMyO1xubmlmdGkuTklGVEkxLlVOSVRTX1BQTSAgICAgICAgICAgPSA0MDtcbm5pZnRpLk5JRlRJMS5VTklUU19SQURTICAgICAgICAgID0gNDg7XG5cbi8vIG5pZnRpMSBjb2Rlc1xubmlmdGkuTklGVEkxLk1BR0lDX0NPT0tJRSA9IDM0ODtcbm5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJfTE9DQVRJT04gPSAzNDQ7XG5uaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSID0gWzB4NkUsIDB4MkIsIDB4MzFdOyAgLy8gbisxICgubmlpKVxubmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUjIgPSBbMHg2RSwgMHg2OSwgMHgzMV07ICAvLyBuaTEgKC5oZHIvLmltZylcbm5pZnRpLk5JRlRJMS5FWFRFTlNJT05fSEVBREVSX1NJWkUgPSA4O1xuXG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG4vKipcbiAqIFJlYWRzIHRoZSBoZWFkZXIgZGF0YS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5yZWFkSGVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgcmF3RGF0YSA9IG5ldyBEYXRhVmlldyhkYXRhKSxcbiAgICAgICAgbWFnaWNDb29raWVWYWwgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAwLCB0aGlzLmxpdHRsZUVuZGlhbiksXG4gICAgICAgIGN0cixcbiAgICAgICAgY3RyT3V0LFxuICAgICAgICBjdHJJbixcbiAgICAgICAgaW5kZXg7XG5cbiAgICBpZiAobWFnaWNDb29raWVWYWwgIT09IG5pZnRpLk5JRlRJMS5NQUdJQ19DT09LSUUpIHsgIC8vIHRyeSBhcyBsaXR0bGUgZW5kaWFuXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgICAgICAgbWFnaWNDb29raWVWYWwgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKG1hZ2ljQ29va2llVmFsICE9PSBuaWZ0aS5OSUZUSTEuTUFHSUNfQ09PS0lFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgTklGVEkgZmlsZSFcIik7XG4gICAgfVxuXG4gICAgdGhpcy5kaW1faW5mbyA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAzOSk7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGluZGV4ID0gNDAgKyAoY3RyICogMik7XG4gICAgICAgIHRoaXMuZGltc1tjdHJdID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZW50X3AxID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCA1NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X3AyID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCA2MCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X3AzID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCA2NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDY4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLmRhdGF0eXBlQ29kZSA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgNzAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLm51bUJpdHNQZXJWb3hlbCA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgNzIsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2xpY2Vfc3RhcnQgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDc0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGluZGV4ID0gNzYgKyAoY3RyICogNCk7XG4gICAgICAgIHRoaXMucGl4RGltc1tjdHJdID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIHRoaXMudm94X29mZnNldCA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTA4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNjbF9zbG9wZSA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTEyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zY2xfaW50ZXIgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDExNiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zbGljZV9lbmQgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDEyMCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuc2xpY2VfY29kZSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAxMjIpO1xuXG4gICAgdGhpcy54eXp0X3VuaXRzID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDEyMyk7XG5cbiAgICB0aGlzLmNhbF9tYXggPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDEyNCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuY2FsX21pbiA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTI4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNsaWNlX2R1cmF0aW9uID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAxMzIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnRvZmZzZXQgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDEzNiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDE0OCwgMjI4KTtcbiAgICB0aGlzLmF1eF9maWxlID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMjI4LCAyNTIpO1xuXG4gICAgdGhpcy5xZm9ybV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCAyNTIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnNmb3JtX2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDI1NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5xdWF0ZXJuX2IgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDI1NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucXVhdGVybl9jID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAyNjAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnF1YXRlcm5fZCA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMjY0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xb2Zmc2V0X3ggPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDI2OCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucW9mZnNldF95ID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAyNzIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnFvZmZzZXRfeiA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMjc2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ck91dCA9IDA7IGN0ck91dCA8IDM7IGN0ck91dCArPSAxKSB7XG4gICAgICAgIGZvciAoY3RySW4gPSAwOyBjdHJJbiA8IDQ7IGN0ckluICs9IDEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMjgwICsgKCgoY3RyT3V0ICogNCkgKyBjdHJJbikgKiA0KTtcbiAgICAgICAgICAgIHRoaXMuYWZmaW5lW2N0ck91dF1bY3RySW5dID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZmZpbmVbM11bMF0gPSAwO1xuICAgIHRoaXMuYWZmaW5lWzNdWzFdID0gMDtcbiAgICB0aGlzLmFmZmluZVszXVsyXSA9IDA7XG4gICAgdGhpcy5hZmZpbmVbM11bM10gPSAxO1xuXG4gICAgdGhpcy5pbnRlbnRfbmFtZSA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDMyOCwgMzQ0KTtcbiAgICB0aGlzLm1hZ2ljID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMzQ0LCAzNDgpO1xuXG4gICAgdGhpcy5pc0hEUiA9ICh0aGlzLm1hZ2ljID09PSBuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSMik7XG5cbiAgICBpZiAocmF3RGF0YS5ieXRlTGVuZ3RoID4gbmlmdGkuTklGVEkxLk1BR0lDX0NPT0tJRSkge1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMF0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMzQ4KTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzFdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDM0OCArIDEpO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMl0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMzQ4ICsgMik7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1szXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAzNDggKyAzKTtcblxuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25GbGFnWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvblNpemUgPSB0aGlzLmdldEV4dGVuc2lvblNpemUocmF3RGF0YSk7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbkNvZGUgPSB0aGlzLmdldEV4dGVuc2lvbkNvZGUocmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgb2YgaGVhZGVyIGZpZWxkcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUudG9Gb3JtYXR0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZtdCA9IG5pZnRpLlV0aWxzLmZvcm1hdE51bWJlcixcbiAgICAgICAgc3RyaW5nID0gXCJcIjtcblxuICAgIHN0cmluZyArPSAoXCJEaW0gSW5mbyA9IFwiICsgdGhpcy5kaW1faW5mbyArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkltYWdlIERpbWVuc2lvbnMgKDEtOCk6IFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzBdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzFdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzJdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzNdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzRdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzVdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzZdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzddICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW50ZW50IFBhcmFtZXRlcnMgKDEtMyk6IFwiICtcbiAgICAgICAgdGhpcy5pbnRlbnRfcDEgKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmludGVudF9wMiArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuaW50ZW50X3AzKSArIFwiXFxuXCI7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW50ZW50IENvZGUgPSBcIiArIHRoaXMuaW50ZW50X2NvZGUgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGF0YXR5cGUgPSBcIiArIHRoaXMuZGF0YXR5cGVDb2RlICsgIFwiIChcIiArIHRoaXMuZ2V0RGF0YXR5cGVDb2RlU3RyaW5nKHRoaXMuZGF0YXR5cGVDb2RlKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiQml0cyBQZXIgVm94ZWwgPSBcIiArIHRoaXMubnVtQml0c1BlclZveGVsICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlNsaWNlIFN0YXJ0ID0gXCIgKyB0aGlzLnNsaWNlX3N0YXJ0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlZveGVsIERpbWVuc2lvbnMgKDEtOCk6IFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1swXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzFdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1szXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzRdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbNV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s2XSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzddKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkltYWdlIE9mZnNldCA9IFwiICsgdGhpcy52b3hfb2Zmc2V0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRhdGEgU2NhbGU6ICBTbG9wZSA9IFwiICsgZm10KHRoaXMuc2NsX3Nsb3BlKSArIFwiICBJbnRlcmNlcHQgPSBcIiArIGZtdCh0aGlzLnNjbF9pbnRlcikgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgRW5kID0gXCIgKyB0aGlzLnNsaWNlX2VuZCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBDb2RlID0gXCIgKyB0aGlzLnNsaWNlX2NvZGUgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiVW5pdHMgQ29kZSA9IFwiICsgdGhpcy54eXp0X3VuaXRzICsgXCIgKFwiICsgdGhpcy5nZXRVbml0c0NvZGVTdHJpbmcobmlmdGkuTklGVEkxLlNQQVRJQUxfVU5JVFNfTUFTSyAmIHRoaXMueHl6dF91bml0cykgKyBcIiwgXCIgKyB0aGlzLmdldFVuaXRzQ29kZVN0cmluZyhuaWZ0aS5OSUZUSTEuVEVNUE9SQUxfVU5JVFNfTUFTSyAmIHRoaXMueHl6dF91bml0cykgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRpc3BsYXkgUmFuZ2U6ICBNYXggPSBcIiArIGZtdCh0aGlzLmNhbF9tYXgpICsgXCIgIE1pbiA9IFwiICsgZm10KHRoaXMuY2FsX21pbikgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgRHVyYXRpb24gPSBcIiArIHRoaXMuc2xpY2VfZHVyYXRpb24gKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiVGltZSBBeGlzIFNoaWZ0ID0gXCIgKyB0aGlzLnRvZmZzZXQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGVzY3JpcHRpb246IFxcXCJcIiArIHRoaXMuZGVzY3JpcHRpb24gKyBcIlxcXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkF1eGlsaWFyeSBGaWxlOiBcXFwiXCIgKyB0aGlzLmF1eF9maWxlICsgXCJcXFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJRLUZvcm0gQ29kZSA9IFwiICsgdGhpcy5xZm9ybV9jb2RlICsgXCIgKFwiICsgdGhpcy5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nKHRoaXMucWZvcm1fY29kZSkgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBDb2RlID0gXCIgKyB0aGlzLnNmb3JtX2NvZGUgKyBcIiAoXCIgKyB0aGlzLmdldFRyYW5zZm9ybUNvZGVTdHJpbmcodGhpcy5zZm9ybV9jb2RlKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiUXVhdGVybmlvbiBQYXJhbWV0ZXJzOiAgXCIgK1xuICAgICAgICBcImIgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fYikgKyBcIiAgXCIgK1xuICAgICAgICBcImMgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fYykgKyBcIiAgXCIgK1xuICAgICAgICBcImQgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fZCkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJRdWF0ZXJuaW9uIE9mZnNldHM6ICBcIiArXG4gICAgICAgIFwieCA9IFwiICsgdGhpcy5xb2Zmc2V0X3ggKyBcIiAgXCIgK1xuICAgICAgICBcInkgPSBcIiArIHRoaXMucW9mZnNldF95ICsgXCIgIFwiICtcbiAgICAgICAgXCJ6ID0gXCIgKyB0aGlzLnFvZmZzZXRfeiArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFg6IFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzBdWzBdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVswXVsxXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMF1bMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzBdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFk6IFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzFdWzBdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsxXVsxXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMV1bMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzFdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFo6IFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzJdWzBdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsyXVsxXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMl1bMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzJdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkludGVudCBOYW1lOiBcXFwiXCIgKyB0aGlzLmludGVudF9uYW1lICsgXCJcXFwiXFxuXCIpO1xuXG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9uRmxhZ1swXSkge1xuICAgICAgICBzdHJpbmcgKz0gKFwiRXh0ZW5zaW9uOiBTaXplID0gXCIgKyB0aGlzLmV4dGVuc2lvblNpemUgKyBcIiAgQ29kZSA9IFwiICsgdGhpcy5leHRlbnNpb25Db2RlICsgXCJcXG5cIik7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgb2YgZGF0YXR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXREYXRhdHlwZUNvZGVTdHJpbmcgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9VSU5UOCkge1xuICAgICAgICByZXR1cm4gXCIxLUJ5dGUgVW5zaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfSU5UMTYpIHtcbiAgICAgICAgcmV0dXJuIFwiMi1CeXRlIFNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9JTlQzMikge1xuICAgICAgICByZXR1cm4gXCI0LUJ5dGUgU2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX0ZMT0FUMzIpIHtcbiAgICAgICAgcmV0dXJuIFwiNC1CeXRlIEZsb2F0XCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9GTE9BVDY0KSB7XG4gICAgICAgIHJldHVybiBcIjgtQnl0ZSBGbG9hdFwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfUkdCMjQpIHtcbiAgICAgICAgcmV0dXJuIFwiUkdCXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9JTlQ4KSB7XG4gICAgICAgIHJldHVybiBcIjEtQnl0ZSBTaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfVUlOVDE2KSB7XG4gICAgICAgIHJldHVybiBcIjItQnl0ZSBVbnNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9VSU5UMzIpIHtcbiAgICAgICAgcmV0dXJuIFwiNC1CeXRlIFVuc2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX0lOVDY0KSB7XG4gICAgICAgIHJldHVybiBcIjgtQnl0ZSBTaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfVUlOVDY0KSB7XG4gICAgICAgIHJldHVybiBcIjgtQnl0ZSBVbnNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiVW5rbm93blwiO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIHRyYW5zZm9ybSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5YRk9STV9TQ0FOTkVSX0FOQVQpIHtcbiAgICAgICAgcmV0dXJuIFwiU2Nhbm5lclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlhGT1JNX0FMSUdORURfQU5BVCkge1xuICAgICAgICByZXR1cm4gXCJBbGlnbmVkXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuWEZPUk1fVEFMQUlSQUNIKSB7XG4gICAgICAgIHJldHVybiBcIlRhbGFpcmFjaFwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlhGT1JNX01OSV8xNTIpIHtcbiAgICAgICAgcmV0dXJuIFwiTU5JXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiVW5rbm93blwiO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIHNwYXRpYWwgYW5kIHRlbXBvcmFsIHVuaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0VW5pdHNDb2RlU3RyaW5nID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX01FVEVSKSB7XG4gICAgICAgIHJldHVybiBcIk1ldGVyc1wiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX01NKSB7XG4gICAgICAgIHJldHVybiBcIk1pbGxpbWV0ZXJzXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfTUlDUk9OKSB7XG4gICAgICAgIHJldHVybiBcIk1pY3JvbnNcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19TRUMpIHtcbiAgICAgICAgcmV0dXJuIFwiU2Vjb25kc1wiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX01TRUMpIHtcbiAgICAgICAgcmV0dXJuIFwiTWlsbGlzZWNvbmRzXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfVVNFQykge1xuICAgICAgICByZXR1cm4gXCJNaWNyb3NlY29uZHNcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19IWikge1xuICAgICAgICByZXR1cm4gXCJIelwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX1BQTSkge1xuICAgICAgICByZXR1cm4gXCJQUE1cIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19SQURTKSB7XG4gICAgICAgIHJldHVybiBcIlJhZHNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJVbmtub3duXCI7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHFmb3JtIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldFFmb3JtTWF0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnROaWZ0aVFGb3JtVG9OaWZ0aVNGb3JtKHRoaXMucXVhdGVybl9iLCB0aGlzLnF1YXRlcm5fYywgdGhpcy5xdWF0ZXJuX2QsIHRoaXMucW9mZnNldF94LFxuICAgICAgICB0aGlzLnFvZmZzZXRfeSwgdGhpcy5xb2Zmc2V0X3osIHRoaXMucGl4RGltc1sxXSwgdGhpcy5waXhEaW1zWzJdLCB0aGlzLnBpeERpbXNbM10sIHRoaXMucGl4RGltc1swXSk7XG59O1xuXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBxZm9ybSB0byBhbiBhZmZpbmUuICAoU2VlIGh0dHA6Ly9uaWZ0aS5uaW1oLm5paC5nb3YvcHViL2Rpc3Qvc3JjL25pZnRpbGliL25pZnRpMV9pby5jKVxuICogQHBhcmFtIHtudW1iZXJ9IHFiXG4gKiBAcGFyYW0ge251bWJlcn0gcWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBxZFxuICogQHBhcmFtIHtudW1iZXJ9IHF4XG4gKiBAcGFyYW0ge251bWJlcn0gcXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBxelxuICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gKiBAcGFyYW0ge251bWJlcn0gZHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkelxuICogQHBhcmFtIHtudW1iZXJ9IHFmYWNcbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmNvbnZlcnROaWZ0aVFGb3JtVG9OaWZ0aVNGb3JtID0gZnVuY3Rpb24gKHFiLCBxYywgcWQsIHF4LCBxeSwgcXosIGR4LCBkeSwgZHosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxZmFjKSB7XG4gICAgdmFyIFIgPSBbWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdXSxcbiAgICAgICAgYSxcbiAgICAgICAgYiA9IHFiLFxuICAgICAgICBjID0gcWMsXG4gICAgICAgIGQgPSBxZCxcbiAgICAgICAgeGQsXG4gICAgICAgIHlkLFxuICAgICAgICB6ZDtcblxuICAgIC8vIGxhc3Qgcm93IGlzIGFsd2F5cyBbIDAgMCAwIDEgXVxuICAgIFJbM11bMF0gPSBSWzNdWzFdID0gUlszXVsyXSA9IDAuMDtcbiAgICBSWzNdWzNdID0gMS4wO1xuXG4gICAgLy8gY29tcHV0ZSBhIHBhcmFtZXRlciBmcm9tIGIsYyxkXG4gICAgYSA9IDEuMCAtIChiICogYiArIGMgKiBjICsgZCAqIGQpO1xuICAgIGlmIChhIDwgMC4wMDAwMDAxKSB7ICAgICAgICAgICAgICAgICAgIC8qIHNwZWNpYWwgY2FzZSAqL1xuXG4gICAgICAgIGEgPSAxLjAgLyBNYXRoLnNxcnQoYiAqIGIgKyBjICogYyArIGQgKiBkKTtcbiAgICAgICAgYiAqPSBhO1xuICAgICAgICBjICo9IGE7XG4gICAgICAgIGQgKj0gYTsgICAgICAgIC8qIG5vcm1hbGl6ZSAoYixjLGQpIHZlY3RvciAqL1xuICAgICAgICBhID0gMC4wOyAgICAgICAgICAgICAgICAgICAgICAgIC8qIGEgPSAwID09PiAxODAgZGVncmVlIHJvdGF0aW9uICovXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBhID0gTWF0aC5zcXJ0KGEpOyAgICAgICAgICAgICAgICAgICAgIC8qIGFuZ2xlID0gMiphcmNjb3MoYSkgKi9cbiAgICB9XG5cbiAgICAvLyBsb2FkIHJvdGF0aW9uIG1hdHJpeCwgaW5jbHVkaW5nIHNjYWxpbmcgZmFjdG9ycyBmb3Igdm94ZWwgc2l6ZXNcbiAgICB4ZCA9IChkeCA+IDAuMCkgPyBkeCA6IDEuMDsgICAgICAgLyogbWFrZSBzdXJlIGFyZSBwb3NpdGl2ZSAqL1xuICAgIHlkID0gKGR5ID4gMC4wKSA/IGR5IDogMS4wO1xuICAgIHpkID0gKGR6ID4gMC4wKSA/IGR6IDogMS4wO1xuXG4gICAgaWYgKHFmYWMgPCAwLjApIHtcbiAgICAgICAgemQgPSAtemQ7ICAgICAgICAgLyogbGVmdCBoYW5kZWRuZXNzPyAqL1xuICAgIH1cblxuICAgIFJbMF1bMF0gPSAgICAgICAoYSAqIGEgKyBiICogYiAtIGMgKiBjIC0gZCAqIGQpICogeGQ7XG4gICAgUlswXVsxXSA9IDIuMCAqIChiICogYyAtIGEgKiBkKSAqIHlkO1xuICAgIFJbMF1bMl0gPSAyLjAgKiAoYiAqIGQgKyBhICogYykgKiB6ZDtcbiAgICBSWzFdWzBdID0gMi4wICogKGIgKiBjICsgYSAqIGQpICogeGQ7XG4gICAgUlsxXVsxXSA9ICAgICAgIChhICogYSArIGMgKiBjIC0gYiAqIGIgLSBkICogZCkgKiB5ZDtcbiAgICBSWzFdWzJdID0gMi4wICogKGMgKiBkIC0gYSAqIGIpICogemQ7XG4gICAgUlsyXVswXSA9IDIuMCAqIChiICogZCAtIGEgKiBjKSAqIHhkO1xuICAgIFJbMl1bMV0gPSAyLjAgKiAoYyAqIGQgKyBhICogYikgKiB5ZDtcbiAgICBSWzJdWzJdID0gICAgICAgKGEgKiBhICsgZCAqIGQgLSBjICogYyAtIGIgKiBiKSAqIHpkO1xuXG4gICAgLy8gbG9hZCBvZmZzZXRzXG4gICAgUlswXVszXSA9IHF4O1xuICAgIFJbMV1bM10gPSBxeTtcbiAgICBSWzJdWzNdID0gcXo7XG5cbiAgICByZXR1cm4gUjtcbn07XG5cblxuXG4vKipcbiAqIENvbnZlcnRzIHNmb3JtIHRvIGFuIG9yaWVudGF0aW9uIHN0cmluZyAoZS5nLiwgWFlaKy0tKS4gIChTZWUgaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxX2lvLmMpXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IFJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuY29udmVydE5pZnRpU0Zvcm1Ub05FTUEgPSBmdW5jdGlvbiAoUikge1xuICAgIHZhciB4aSwgeGosIHhrLCB5aSwgeWosIHlrLCB6aSwgemosIHprLCB2YWwsIGRldFEsIGRldFAsIGksIGosIGssIHAsIHEsIHIsIGliZXN0LCBqYmVzdCwga2Jlc3QsIHBiZXN0LCBxYmVzdCwgcmJlc3QsXG4gICAgICAgIE0sIHZiZXN0LCBRLCBQLCBpQ2hhciwgakNoYXIsIGtDaGFyLCBpU2Vuc2UsIGpTZW5zZSwga1NlbnNlO1xuICAgIGsgPSAwO1xuXG4gICAgUSA9IFtbMCwgMCwgMF0sIFswLCAwLCAwXSwgWzAsIDAsIDBdXTtcbiAgICBQID0gW1swLCAwLCAwXSwgWzAsIDAsIDBdLCBbMCwgMCwgMF1dO1xuXG4gICAgLy9pZiggaWNvZCA9PSBOVUxMIHx8IGpjb2QgPT0gTlVMTCB8fCBrY29kID09IE5VTEwgKSByZXR1cm4gOyAvKiBiYWQgKi9cblxuICAgIC8vKmljb2QgPSAqamNvZCA9ICprY29kID0gMCA7IC8qIHRoaXMuZXJyb3JNZXNzYWdlIHJldHVybnMsIGlmIHNoKnQgaGFwcGVucyAqL1xuXG4gICAgLyogbG9hZCBjb2x1bW4gdmVjdG9ycyBmb3IgZWFjaCAoaSxqLGspIGRpcmVjdGlvbiBmcm9tIG1hdHJpeCAqL1xuXG4gICAgLyotLSBpIGF4aXMgLS0qLyAvKi0tIGogYXhpcyAtLSovIC8qLS0gayBheGlzIC0tKi9cblxuICAgIHhpID0gUlswXVswXTtcbiAgICB4aiA9IFJbMF1bMV07XG4gICAgeGsgPSBSWzBdWzJdO1xuXG4gICAgeWkgPSBSWzFdWzBdO1xuICAgIHlqID0gUlsxXVsxXTtcbiAgICB5ayA9IFJbMV1bMl07XG5cbiAgICB6aSA9IFJbMl1bMF07XG4gICAgemogPSBSWzJdWzFdO1xuICAgIHprID0gUlsyXVsyXTtcblxuICAgIC8qIG5vcm1hbGl6ZSBjb2x1bW4gdmVjdG9ycyB0byBnZXQgdW5pdCB2ZWN0b3JzIGFsb25nIGVhY2ggaWprLWF4aXMgKi9cblxuICAgIC8qIG5vcm1hbGl6ZSBpIGF4aXMgKi9cbiAgICB2YWwgPSBNYXRoLnNxcnQoeGkgKiB4aSArIHlpICogeWkgKyB6aSAqIHppKTtcbiAgICBpZiAodmFsID09PSAwLjApIHsgIC8qIHN0dXBpZCBpbnB1dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB4aSAvPSB2YWw7XG4gICAgeWkgLz0gdmFsO1xuICAgIHppIC89IHZhbDtcblxuICAgIC8qIG5vcm1hbGl6ZSBqIGF4aXMgKi9cbiAgICB2YWwgPSBNYXRoLnNxcnQoeGogKiB4aiArIHlqICogeWogKyB6aiAqIHpqKTtcbiAgICBpZiAodmFsID09PSAwLjApIHsgIC8qIHN0dXBpZCBpbnB1dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB4aiAvPSB2YWw7XG4gICAgeWogLz0gdmFsO1xuICAgIHpqIC89IHZhbDtcblxuICAgIC8qIG9ydGhvZ29uYWxpemUgaiBheGlzIHRvIGkgYXhpcywgaWYgbmVlZGVkICovXG4gICAgdmFsID0geGkgKiB4aiArIHlpICogeWogKyB6aSAqIHpqOyAgICAvKiBkb3QgcHJvZHVjdCBiZXR3ZWVuIGkgYW5kIGogKi9cbiAgICBpZiAoTWF0aC5hYnModmFsKSA+IDEuRS00KSB7XG4gICAgICAgIHhqIC09IHZhbCAqIHhpO1xuICAgICAgICB5aiAtPSB2YWwgKiB5aTtcbiAgICAgICAgemogLT0gdmFsICogemk7XG4gICAgICAgIHZhbCA9IE1hdGguc3FydCh4aiAqIHhqICsgeWogKiB5aiArIHpqICogemopOyAgLyogbXVzdCByZW5vcm1hbGl6ZSAqL1xuICAgICAgICBpZiAodmFsID09PSAwLjApIHsgICAgICAgICAgICAgIC8qIGogd2FzIHBhcmFsbGVsIHRvIGk/ICovXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB4aiAvPSB2YWw7XG4gICAgICAgIHlqIC89IHZhbDtcbiAgICAgICAgemogLz0gdmFsO1xuICAgIH1cblxuICAgIC8qIG5vcm1hbGl6ZSBrIGF4aXM7IGlmIGl0IGlzIHplcm8sIG1ha2UgaXQgdGhlIGNyb3NzIHByb2R1Y3QgaSB4IGogKi9cbiAgICB2YWwgPSBNYXRoLnNxcnQoeGsgKiB4ayArIHlrICogeWsgKyB6ayAqIHprKTtcbiAgICBpZiAodmFsID09PSAwLjApIHtcbiAgICAgICAgeGsgPSB5aSAqIHpqIC0gemkgKiB5ajtcbiAgICAgICAgeWsgPSB6aSAqIHhqIC0gemogKiB4aTtcbiAgICAgICAgemsgPSB4aSAqIHlqIC0geWkgKiB4ajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB4ayAvPSB2YWw7XG4gICAgICAgIHlrIC89IHZhbDtcbiAgICAgICAgemsgLz0gdmFsO1xuICAgIH1cblxuICAgIC8qIG9ydGhvZ29uYWxpemUgayB0byBpICovXG4gICAgdmFsID0geGkgKiB4ayArIHlpICogeWsgKyB6aSAqIHprOyAgICAvKiBkb3QgcHJvZHVjdCBiZXR3ZWVuIGkgYW5kIGsgKi9cbiAgICBpZiAoTWF0aC5hYnModmFsKSA+IDEuRS00KSB7XG4gICAgICAgIHhrIC09IHZhbCAqIHhpO1xuICAgICAgICB5ayAtPSB2YWwgKiB5aTtcbiAgICAgICAgemsgLT0gdmFsICogemk7XG4gICAgICAgIHZhbCA9IE1hdGguc3FydCh4ayAqIHhrICsgeWsgKiB5ayArIHprICogemspO1xuICAgICAgICBpZiAodmFsID09PSAwLjApIHsgICAgLyogYmFkICovXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB4ayAvPSB2YWw7XG4gICAgICAgIHlrIC89IHZhbDtcbiAgICAgICAgemsgLz0gdmFsO1xuICAgIH1cblxuICAgIC8qIG9ydGhvZ29uYWxpemUgayB0byBqICovXG4gICAgdmFsID0geGogKiB4ayArIHlqICogeWsgKyB6aiAqIHprOyAgICAvKiBkb3QgcHJvZHVjdCBiZXR3ZWVuIGogYW5kIGsgKi9cbiAgICBpZiAoTWF0aC5hYnModmFsKSA+IDEuZS00KSB7XG4gICAgICAgIHhrIC09IHZhbCAqIHhqO1xuICAgICAgICB5ayAtPSB2YWwgKiB5ajtcbiAgICAgICAgemsgLT0gdmFsICogemo7XG4gICAgICAgIHZhbCA9IE1hdGguc3FydCh4ayAqIHhrICsgeWsgKiB5ayArIHprICogemspO1xuICAgICAgICBpZiAodmFsID09PSAwLjApIHsgICAgIC8qIGJhZCAqL1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgeGsgLz0gdmFsO1xuICAgICAgICB5ayAvPSB2YWw7XG4gICAgICAgIHprIC89IHZhbDtcbiAgICB9XG5cbiAgICBRWzBdWzBdID0geGk7XG4gICAgUVswXVsxXSA9IHhqO1xuICAgIFFbMF1bMl0gPSB4aztcbiAgICBRWzFdWzBdID0geWk7XG4gICAgUVsxXVsxXSA9IHlqO1xuICAgIFFbMV1bMl0gPSB5aztcbiAgICBRWzJdWzBdID0gemk7XG4gICAgUVsyXVsxXSA9IHpqO1xuICAgIFFbMl1bMl0gPSB6aztcblxuICAgIC8qIGF0IHRoaXMgcG9pbnQsIFEgaXMgdGhlIHJvdGF0aW9uIG1hdHJpeCBmcm9tIHRoZSAoaSxqLGspIHRvICh4LHkseikgYXhlcyAqL1xuXG4gICAgZGV0USA9IHRoaXMubmlmdGlfbWF0MzNfZGV0ZXJtKFEpO1xuICAgIGlmIChkZXRRID09PSAwLjApIHsgLyogc2hvdWxkbid0IGhhcHBlbiB1bmxlc3MgdXNlciBpcyBhIERVRklTICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qIEJ1aWxkIGFuZCB0ZXN0IGFsbCBwb3NzaWJsZSArMS8tMSBjb29yZGluYXRlIHBlcm11dGF0aW9uIG1hdHJpY2VzIFA7XG4gICAgIHRoZW4gZmluZCB0aGUgUCBzdWNoIHRoYXQgdGhlIHJvdGF0aW9uIG1hdHJpeCBNPVBRIGlzIGNsb3Nlc3QgdG8gdGhlXG4gICAgIGlkZW50aXR5LCBpbiB0aGUgc2Vuc2Ugb2YgTSBoYXZpbmcgdGhlIHNtYWxsZXN0IHRvdGFsIHJvdGF0aW9uIGFuZ2xlLiAqL1xuXG4gICAgLyogRGVzcGl0ZSB0aGUgZm9ybWlkYWJsZSBsb29raW5nIDYgbmVzdGVkIGxvb3BzLCB0aGVyZSBhcmVcbiAgICAgb25seSAzKjMqMyoyKjIqMiA9IDIxNiBwYXNzZXMsIHdoaWNoIHdpbGwgcnVuIHZlcnkgcXVpY2tseS4gKi9cblxuICAgIHZiZXN0ID0gLTY2Ni4wO1xuICAgIGliZXN0ID0gcGJlc3QgPSBxYmVzdCA9IHJiZXN0ID0gMTtcbiAgICBqYmVzdCA9IDI7XG4gICAga2Jlc3QgPSAzO1xuXG4gICAgZm9yIChpID0gMTsgaSA8PSAzOyBpICs9IDEpIHsgICAgIC8qIGkgPSBjb2x1bW4gbnVtYmVyIHRvIHVzZSBmb3Igcm93ICMxICovXG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gMzsgaiArPSAxKSB7ICAgIC8qIGogPSBjb2x1bW4gbnVtYmVyIHRvIHVzZSBmb3Igcm93ICMyICovXG4gICAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGsgPD0gMzsgayArPSAxKSB7ICAvKiBrID0gY29sdW1uIG51bWJlciB0byB1c2UgZm9yIHJvdyAjMyAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpID09PSBrIHx8IGogPT09IGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBQWzBdWzBdID0gUFswXVsxXSA9IFBbMF1bMl0gPSBQWzFdWzBdID0gUFsxXVsxXSA9IFBbMV1bMl0gPSBQWzJdWzBdID0gUFsyXVsxXSA9IFBbMl1bMl0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgPSAtMTsgcCA8PSAxOyBwICs9IDIpIHsgICAgLyogcCxxLHIgYXJlIC0xIG9yICsxICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSAtMTsgcSA8PSAxOyBxICs9IDIpIHsgICAvKiBhbmQgZ28gaW50byByb3dzICMxLDIsMyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHIgPSAtMTsgciA8PSAxOyByICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBbMF1baSAtIDFdID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBbMV1baiAtIDFdID0gcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBbMl1bayAtIDFdID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldFAgPSB0aGlzLm5pZnRpX21hdDMzX2RldGVybShQKTsgICAgICAgICAgIC8qIHNpZ24gb2YgcGVybXV0YXRpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGV0UCAqIGRldFEpID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTSA9IHRoaXMubmlmdGlfbWF0MzNfbXVsKFAsIFEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogYW5nbGUgb2YgTSByb3RhdGlvbiA9IDIuMCphY29zKDAuNSpzcXJ0KDEuMCt0cmFjZShNKSkpICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogd2Ugd2FudCBsYXJnZXN0IHRyYWNlKE0pID09IHNtYWxsZXN0IGFuZ2xlID09IE0gbmVhcmVzdCB0byBJICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBNWzBdWzBdICsgTVsxXVsxXSArIE1bMl1bMl07IC8qIHRyYWNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IHZiZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZiZXN0ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYmVzdCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpiZXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2Jlc3QgPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYmVzdCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFiZXN0ID0gcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJlc3QgPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gIC8qIGRvZXNuJ3QgbWF0Y2ggc2lnbiBvZiBRICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBBdCB0aGlzIHBvaW50IGliZXN0IGlzIDEgb3IgMiBvciAzOyBwYmVzdCBpcyAtMSBvciArMTsgZXRjLlxuXG4gICAgIFRoZSBtYXRyaXggUCB0aGF0IGNvcnJlc3BvbmRzIGlzIHRoZSBiZXN0IHBlcm11dGF0aW9uIGFwcHJveGltYXRpb25cbiAgICAgdG8gUS1pbnZlcnNlOyB0aGF0IGlzLCBQIChhcHByb3hpbWF0ZWx5KSB0YWtlcyAoeCx5LHopIGNvb3JkaW5hdGVzXG4gICAgIHRvIHRoZSAoaSxqLGspIGF4ZXMuXG5cbiAgICAgRm9yIGV4YW1wbGUsIHRoZSBmaXJzdCByb3cgb2YgUCAod2hpY2ggY29udGFpbnMgcGJlc3QgaW4gY29sdW1uIGliZXN0KVxuICAgICBkZXRlcm1pbmVzIHRoZSB3YXkgdGhlIGkgYXhpcyBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIGFuYXRvbWljYWxcbiAgICAgKHgseSx6KSBheGVzLiAgSWYgaWJlc3QgaXMgMiwgdGhlbiB0aGUgaSBheGlzIGlzIGFsb25nIHRoZSB5IGF4aXMsXG4gICAgIHdoaWNoIGlzIGRpcmVjdGlvbiBQMkEgKGlmIHBiZXN0ID4gMCkgb3IgQTJQIChpZiBwYmVzdCA8IDApLlxuXG4gICAgIFNvLCB1c2luZyBpYmVzdCBhbmQgcGJlc3QsIHdlIGNhbiBhc3NpZ24gdGhlIG91dHB1dCBjb2RlIGZvclxuICAgICB0aGUgaSBheGlzLiAgTXV0YXRpcyBtdXRhbmRpcyBmb3IgdGhlIGogYW5kIGsgYXhlcywgb2YgY291cnNlLiAqL1xuXG4gICAgaUNoYXIgPSBqQ2hhciA9IGtDaGFyID0gaVNlbnNlID0galNlbnNlID0ga1NlbnNlID0gMDtcblxuICAgIHN3aXRjaCAoaWJlc3QgKiBwYmVzdCkge1xuICAgICAgICBjYXNlIDE6IC8qaSA9IE5JRlRJX0wyUiovXG4gICAgICAgICAgICBpQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGlTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0xOiAvKmkgPSBOSUZUSV9SMkwqL1xuICAgICAgICAgICAgaUNoYXIgPSAnWCc7XG4gICAgICAgICAgICBpU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAvKmkgPSBOSUZUSV9QMkEqL1xuICAgICAgICAgICAgaUNoYXIgPSAnWSc7XG4gICAgICAgICAgICBpU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMjogLyppID0gTklGVElfQTJQKi9cbiAgICAgICAgICAgIGlDaGFyID0gJ1knO1xuICAgICAgICAgICAgaVNlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLyppID0gTklGVElfSTJTKi9cbiAgICAgICAgICAgIGlDaGFyID0gJ1onO1xuICAgICAgICAgICAgaVNlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTM6IC8qaSA9IE5JRlRJX1MySSovXG4gICAgICAgICAgICBpQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGlTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN3aXRjaCAoamJlc3QgKiBxYmVzdCkge1xuICAgICAgICBjYXNlIDE6IC8qaiA9IE5JRlRJX0wyUiovXG4gICAgICAgICAgICBqQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGpTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0xOiAvKmogPSBOSUZUSV9SMkwqL1xuICAgICAgICAgICAgakNoYXIgPSAnWCc7XG4gICAgICAgICAgICBqU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAvKmogPSBOSUZUSV9QMkEqL1xuICAgICAgICAgICAgakNoYXIgPSAnWSc7XG4gICAgICAgICAgICBqU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMjogLypqID0gTklGVElfQTJQKi9cbiAgICAgICAgICAgIGpDaGFyID0gJ1knO1xuICAgICAgICAgICAgalNlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLypqID0gTklGVElfSTJTKi9cbiAgICAgICAgICAgIGpDaGFyID0gJ1onO1xuICAgICAgICAgICAgalNlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTM6IC8qaiA9IE5JRlRJX1MySSovXG4gICAgICAgICAgICBqQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGpTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN3aXRjaCAoa2Jlc3QgKiByYmVzdCkge1xuICAgICAgICBjYXNlIDE6IC8qayA9IE5JRlRJX0wyUiovXG4gICAgICAgICAgICBrQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGtTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0xOiAvKmsgPSBOSUZUSV9SMkwqL1xuICAgICAgICAgICAga0NoYXIgPSAnWCc7XG4gICAgICAgICAgICBrU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAvKmsgPSBOSUZUSV9QMkEqL1xuICAgICAgICAgICAga0NoYXIgPSAnWSc7XG4gICAgICAgICAgICBrU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMjogLyprID0gTklGVElfQTJQKi9cbiAgICAgICAgICAgIGtDaGFyID0gJ1knO1xuICAgICAgICAgICAga1NlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLyprID0gTklGVElfSTJTKi9cbiAgICAgICAgICAgIGtDaGFyID0gJ1onO1xuICAgICAgICAgICAga1NlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTM6IC8qayA9IE5JRlRJX1MySSovXG4gICAgICAgICAgICBrQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGtTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAoaUNoYXIgKyBqQ2hhciArIGtDaGFyICsgaVNlbnNlICsgalNlbnNlICsga1NlbnNlKTtcbn07XG5cblxuXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLm5pZnRpX21hdDMzX211bCA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gICAgdmFyIEMgPSBbWzAsIDAsIDBdLCBbMCwgMCwgMF0sIFswLCAwLCAwXV0sXG4gICAgICAgIGksXG4gICAgICAgIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAzOyBqICs9IDEpIHtcbiAgICAgICAgICAgIENbaV1bal0gPSAgQVtpXVswXSAqIEJbMF1bal0gICsgQVtpXVsxXSAqIEJbMV1bal0gKyBBW2ldWzJdICogQlsyXVtqXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDO1xufTtcblxuXG5cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUubmlmdGlfbWF0MzNfZGV0ZXJtID0gZnVuY3Rpb24gKFIpIHtcbiAgICB2YXIgcjExLCByMTIsIHIxMywgcjIxLCByMjIsIHIyMywgcjMxLCByMzIsIHIzMztcbiAgICAvKiAgSU5QVVQgTUFUUklYOiAgKi9cbiAgICByMTEgPSBSWzBdWzBdO1xuICAgIHIxMiA9IFJbMF1bMV07XG4gICAgcjEzID0gUlswXVsyXTtcbiAgICByMjEgPSBSWzFdWzBdO1xuICAgIHIyMiA9IFJbMV1bMV07XG4gICAgcjIzID0gUlsxXVsyXTtcbiAgICByMzEgPSBSWzJdWzBdO1xuICAgIHIzMiA9IFJbMl1bMV07XG4gICAgcjMzID0gUlsyXVsyXTtcblxuICAgIHJldHVybiAocjExICogcjIyICogcjMzIC0gcjExICogcjMyICogcjIzIC0gcjIxICogcjEyICogcjMzICsgcjIxICogcjMyICogcjEzICsgcjMxICogcjEyICogcjIzIC0gcjMxICogcjIyICogcjEzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBieXRlIGluZGV4IG9mIHRoZSBleHRlbnNpb24uXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldEV4dGVuc2lvbkxvY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5pZnRpLk5JRlRJMS5NQUdJQ19DT09LSUUgKyA0O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBzaXplLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRFeHRlbnNpb25TaXplID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBuaWZ0aS5VdGlscy5nZXRJbnRBdChkYXRhLCB0aGlzLmdldEV4dGVuc2lvbkxvY2F0aW9uKCksIHRoaXMubGl0dGxlRW5kaWFuKTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBjb2RlLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRFeHRlbnNpb25Db2RlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBuaWZ0aS5VdGlscy5nZXRJbnRBdChkYXRhLCB0aGlzLmdldEV4dGVuc2lvbkxvY2F0aW9uKCkgKyA0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG59O1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5pZnRpLk5JRlRJMTtcbn1cbiIsIlxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG5cbnZhciBuaWZ0aSA9IG5pZnRpIHx8IHt9O1xubmlmdGkuVXRpbHMgPSBuaWZ0aS5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxpdGllcy5qcycpIDogbnVsbCk7XG5uaWZ0aS5OSUZUSTEgPSBuaWZ0aS5OSUZUSTEgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9uaWZ0aTEuanMnKSA6IG51bGwpO1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuXG4vKipcbiAqIFRoZSBOSUZUSTIgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGltX2luZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGRpbXMgLSBpbWFnZSBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AxXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X3AzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50ZW50X2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhdHlwZUNvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1CaXRzUGVyVm94ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9zdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2VuZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHBpeERpbXMgLSB2b3hlbCBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gdm94X29mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjbF9zbG9wZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjbF9pbnRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHh5enRfdW5pdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYWxfbWF4XG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FsX21pblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX2R1cmF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9mZnNldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXV4X2ZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnRlbnRfbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHFmb3JtX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZm9ybV9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9iXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9jXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl9kXG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl94XG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl95XG4gKiBAcHJvcGVydHkge251bWJlcn0gcXVhdGVybl96XG4gKiBAcHJvcGVydHkge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGFmZmluZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1hZ2ljXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBleHRlbnNpb25GbGFnXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbm5pZnRpLk5JRlRJMiA9IG5pZnRpLk5JRlRJMiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saXR0bGVFbmRpYW4gPSBmYWxzZTtcbiAgICB0aGlzLmRpbV9pbmZvID0gMDtcbiAgICB0aGlzLmRpbXMgPSBbXTtcbiAgICB0aGlzLmludGVudF9wMSA9IDA7XG4gICAgdGhpcy5pbnRlbnRfcDIgPSAwO1xuICAgIHRoaXMuaW50ZW50X3AzID0gMDtcbiAgICB0aGlzLmludGVudF9jb2RlID0gMDtcbiAgICB0aGlzLmRhdGF0eXBlQ29kZSA9IDA7XG4gICAgdGhpcy5udW1CaXRzUGVyVm94ZWwgPSAwO1xuICAgIHRoaXMuc2xpY2Vfc3RhcnQgPSAwO1xuICAgIHRoaXMuc2xpY2VfZW5kID0gMDtcbiAgICB0aGlzLnNsaWNlX2NvZGUgPSAwO1xuICAgIHRoaXMucGl4RGltcyA9IFtdO1xuICAgIHRoaXMudm94X29mZnNldCA9IDA7XG4gICAgdGhpcy5zY2xfc2xvcGUgPSAxO1xuICAgIHRoaXMuc2NsX2ludGVyID0gMDtcbiAgICB0aGlzLnh5enRfdW5pdHMgPSAwO1xuICAgIHRoaXMuY2FsX21heCA9IDA7XG4gICAgdGhpcy5jYWxfbWluID0gMDtcbiAgICB0aGlzLnNsaWNlX2R1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvZmZzZXQgPSAwO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIlwiO1xuICAgIHRoaXMuYXV4X2ZpbGUgPSBcIlwiO1xuICAgIHRoaXMuaW50ZW50X25hbWUgPSBcIlwiO1xuICAgIHRoaXMucWZvcm1fY29kZSA9IDA7XG4gICAgdGhpcy5zZm9ybV9jb2RlID0gMDtcbiAgICB0aGlzLnF1YXRlcm5fYiA9IDA7XG4gICAgdGhpcy5xdWF0ZXJuX2MgPSAwO1xuICAgIHRoaXMucXVhdGVybl9kID0gMDtcbiAgICB0aGlzLnFvZmZzZXRfeCA9IDA7XG4gICAgdGhpcy5xb2Zmc2V0X3kgPSAwO1xuICAgIHRoaXMucW9mZnNldF96ID0gMDtcbiAgICB0aGlzLmFmZmluZSA9IFtbMSwgMCwgMCwgMF0sIFswLCAxLCAwLCAwXSwgWzAsIDAsIDEsIDBdLCBbMCwgMCwgMCwgMV1dO1xuICAgIHRoaXMubWFnaWMgPSAwO1xuICAgIHRoaXMuZXh0ZW5zaW9uRmxhZyA9IFswLCAwLCAwLCAwXTtcbn07XG5cblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxubmlmdGkuTklGVEkyLk1BR0lDX0NPT0tJRSA9IDU0MDtcbm5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJfTE9DQVRJT04gPSA0O1xubmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUiA9IFsweDZFLCAweDJCLCAweDMyLCAwLCAweDBELCAweDBBLCAweDFBLCAweDBBXTsgIC8vIG4rMlxcMFxuXG5cblxuLyoqKiBQcm90b3R5cGUgTWV0aG9kcyAqKiovXG5cbi8qKlxuICogUmVhZHMgdGhlIGhlYWRlciBkYXRhLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLnJlYWRIZWFkZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciByYXdEYXRhID0gbmV3IERhdGFWaWV3KGRhdGEpLFxuICAgICAgICBtYWdpY0Nvb2tpZVZhbCA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDAsIHRoaXMubGl0dGxlRW5kaWFuKSxcbiAgICAgICAgY3RyLFxuICAgICAgICBjdHJPdXQsXG4gICAgICAgIGN0ckluLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgYXJyYXk7XG5cbiAgICBpZiAobWFnaWNDb29raWVWYWwgIT09IG5pZnRpLk5JRlRJMi5NQUdJQ19DT09LSUUpIHsgIC8vIHRyeSBhcyBsaXR0bGUgZW5kaWFuXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgICAgICAgbWFnaWNDb29raWVWYWwgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKG1hZ2ljQ29va2llVmFsICE9PSBuaWZ0aS5OSUZUSTIuTUFHSUNfQ09PS0lFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgTklGVEkgZmlsZSFcIik7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhdHlwZUNvZGUgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDEyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5udW1CaXRzUGVyVm94ZWwgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDE0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGluZGV4ID0gMTYgKyAoY3RyICogOCk7XG4gICAgICAgIHRoaXMuZGltc1tjdHJdID0gbmlmdGkuVXRpbHMuZ2V0TG9uZ0F0KHJhd0RhdGEsIGluZGV4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlbnRfcDEgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCA4MCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X3AyID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgODgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmludGVudF9wMyA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDk2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGluZGV4ID0gMTA0ICsgKGN0ciAqIDgpO1xuICAgICAgICB0aGlzLnBpeERpbXNbY3RyXSA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIGluZGV4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgdGhpcy52b3hfb2Zmc2V0ID0gbmlmdGkuVXRpbHMuZ2V0TG9uZ0F0KHJhd0RhdGEsIDE2OCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zY2xfc2xvcGUgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAxNzYsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnNjbF9pbnRlciA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDE4NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5jYWxfbWF4ID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMTkyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5jYWxfbWluID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMjAwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNsaWNlX2R1cmF0aW9uID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMjA4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnRvZmZzZXQgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAyMTYsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2xpY2Vfc3RhcnQgPSBuaWZ0aS5VdGlscy5nZXRMb25nQXQocmF3RGF0YSwgMjI0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zbGljZV9lbmQgPSBuaWZ0aS5VdGlscy5nZXRMb25nQXQocmF3RGF0YSwgMjMyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMjQwLCAyNDAgKyA4MCk7XG4gICAgdGhpcy5hdXhfZmlsZSA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDMyMCwgMzIwICsgMjQpO1xuXG4gICAgdGhpcy5xZm9ybV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgMzQ0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zZm9ybV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgMzQ4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnF1YXRlcm5fYiA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDM1MiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucXVhdGVybl9jID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMzYwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xdWF0ZXJuX2QgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAzNjgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnFvZmZzZXRfeCA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDM3NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucW9mZnNldF95ID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMzg0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xb2Zmc2V0X3ogPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAzOTIsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIGZvciAoY3RyT3V0ID0gMDsgY3RyT3V0IDwgMzsgY3RyT3V0ICs9IDEpIHtcbiAgICAgICAgZm9yIChjdHJJbiA9IDA7IGN0ckluIDwgNDsgY3RySW4gKz0gMSkge1xuICAgICAgICAgICAgaW5kZXggPSA0MDAgKyAoKChjdHJPdXQgKiA0KSArIGN0ckluKSAqIDgpO1xuICAgICAgICAgICAgdGhpcy5hZmZpbmVbY3RyT3V0XVtjdHJJbl0gPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZmZpbmVbM11bMF0gPSAwO1xuICAgIHRoaXMuYWZmaW5lWzNdWzFdID0gMDtcbiAgICB0aGlzLmFmZmluZVszXVsyXSA9IDA7XG4gICAgdGhpcy5hZmZpbmVbM11bM10gPSAxO1xuXG4gICAgdGhpcy5zbGljZV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgNDk2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy54eXp0X3VuaXRzID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgNTAwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5pbnRlbnRfY29kZSA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDUwNCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X25hbWUgPSBuaWZ0aS5VdGlscy5nZXRTdHJpbmdBdChyYXdEYXRhLCA1MDgsIDUwOCArIDE2KTtcblxuICAgIHRoaXMuZGltX2luZm8gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgNTI0KTtcblxuICAgIGlmIChyYXdEYXRhLmJ5dGVMZW5ndGggPiBuaWZ0aS5OSUZUSTIuTUFHSUNfQ09PS0lFKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1swXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCA1NDApO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMV0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgNTQwICsgMSk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1syXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCA1NDAgKyAyKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzNdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDU0MCArIDMpO1xuXG4gICAgICAgIGlmICh0aGlzLmV4dGVuc2lvbkZsYWdbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uU2l6ZSA9IHRoaXMuZ2V0RXh0ZW5zaW9uU2l6ZShyYXdEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uQ29kZSA9IHRoaXMuZ2V0RXh0ZW5zaW9uQ29kZShyYXdEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIG9mIGhlYWRlciBmaWVsZHMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLnRvRm9ybWF0dGVkU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbXQgPSBuaWZ0aS5VdGlscy5mb3JtYXROdW1iZXIsXG4gICAgICAgIHN0cmluZyA9IFwiXCI7XG5cbiAgICBzdHJpbmcgKz0gKFwiRGF0YXR5cGUgPSBcIiArICArIHRoaXMuZGF0YXR5cGVDb2RlICsgXCIgKFwiICsgdGhpcy5nZXREYXRhdHlwZUNvZGVTdHJpbmcodGhpcy5kYXRhdHlwZUNvZGUpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJCaXRzIFBlciBWb3hlbCA9IFwiICsgXCIgPSBcIiArIHRoaXMubnVtQml0c1BlclZveGVsICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkltYWdlIERpbWVuc2lvbnNcIiArIFwiICgxLTgpOiBcIiArXG4gICAgICAgIHRoaXMuZGltc1swXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1sxXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1syXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1szXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s0XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s1XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s2XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s3XSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkludGVudCBQYXJhbWV0ZXJzICgxLTMpOiBcIiArXG4gICAgICAgIHRoaXMuaW50ZW50X3AxICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5pbnRlbnRfcDIgKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmludGVudF9wMykgKyBcIlxcblwiO1xuXG4gICAgc3RyaW5nICs9IChcIlZveGVsIERpbWVuc2lvbnMgKDEtOCk6IFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1swXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzFdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbMl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1szXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzRdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbNV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s2XSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzddKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkltYWdlIE9mZnNldCA9IFwiICsgdGhpcy52b3hfb2Zmc2V0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRhdGEgU2NhbGU6ICBTbG9wZSA9IFwiICsgZm10KHRoaXMuc2NsX3Nsb3BlKSArIFwiICBJbnRlcmNlcHQgPSBcIiArIGZtdCh0aGlzLnNjbF9pbnRlcikgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGlzcGxheSBSYW5nZTogIE1heCA9IFwiICsgZm10KHRoaXMuY2FsX21heCkgKyBcIiAgTWluID0gXCIgKyBmbXQodGhpcy5jYWxfbWluKSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBEdXJhdGlvbiA9IFwiICsgdGhpcy5zbGljZV9kdXJhdGlvbiArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJUaW1lIEF4aXMgU2hpZnQgPSBcIiArIHRoaXMudG9mZnNldCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBTdGFydCA9IFwiICsgdGhpcy5zbGljZV9zdGFydCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBFbmQgPSBcIiArIHRoaXMuc2xpY2VfZW5kICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRlc2NyaXB0aW9uOiBcXFwiXCIgKyB0aGlzLmRlc2NyaXB0aW9uICsgXCJcXFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJBdXhpbGlhcnkgRmlsZTogXFxcIlwiICsgdGhpcy5hdXhfZmlsZSArIFwiXFxcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiUS1Gb3JtIENvZGUgPSBcIiArIHRoaXMucWZvcm1fY29kZSArIFwiIChcIiArIHRoaXMuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyh0aGlzLnFmb3JtX2NvZGUpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gQ29kZSA9IFwiICsgdGhpcy5zZm9ybV9jb2RlICsgXCIgKFwiICsgdGhpcy5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nKHRoaXMuc2Zvcm1fY29kZSkgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlF1YXRlcm5pb24gUGFyYW1ldGVyczogIFwiICtcbiAgICBcImIgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fYikgKyBcIiAgXCIgK1xuICAgIFwiYyA9IFwiICsgZm10KHRoaXMucXVhdGVybl9jKSArIFwiICBcIiArXG4gICAgXCJkID0gXCIgKyBmbXQodGhpcy5xdWF0ZXJuX2QpICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUXVhdGVybmlvbiBPZmZzZXRzOiAgXCIgK1xuICAgIFwieCA9IFwiICsgdGhpcy5xb2Zmc2V0X3ggKyBcIiAgXCIgK1xuICAgIFwieSA9IFwiICsgdGhpcy5xb2Zmc2V0X3kgKyBcIiAgXCIgK1xuICAgIFwieiA9IFwiICsgdGhpcy5xb2Zmc2V0X3ogKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gUGFyYW1ldGVycyBYOiBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzBdWzBdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzBdWzFdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzBdWzJdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzBdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFk6IFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMV1bMF0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMV1bMV0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMV1bMl0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMV1bM10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIFBhcmFtZXRlcnMgWjogXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsyXVswXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsyXVsxXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsyXVsyXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsyXVszXSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTbGljZSBDb2RlID0gXCIgKyB0aGlzLnNsaWNlX2NvZGUgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiVW5pdHMgQ29kZSA9IFwiICsgdGhpcy54eXp0X3VuaXRzICsgXCIgKFwiICsgdGhpcy5nZXRVbml0c0NvZGVTdHJpbmcobmlmdGkuTklGVEkxLlNQQVRJQUxfVU5JVFNfTUFTSyAmIHRoaXMueHl6dF91bml0cykgKyBcIiwgXCIgKyB0aGlzLmdldFVuaXRzQ29kZVN0cmluZyhuaWZ0aS5OSUZUSTEuVEVNUE9SQUxfVU5JVFNfTUFTSyAmIHRoaXMueHl6dF91bml0cykgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkludGVudCBDb2RlID0gXCIgKyB0aGlzLmludGVudF9jb2RlICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkludGVudCBOYW1lOiBcXFwiXCIgKyB0aGlzLmludGVudF9uYW1lICsgXCJcXFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkRpbSBJbmZvID0gXCIgKyB0aGlzLmRpbV9pbmZvICsgXCJcXG5cIik7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgYnl0ZSBpbmRleCBvZiB0aGUgZXh0ZW5zaW9uLlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRFeHRlbnNpb25Mb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuaWZ0aS5OSUZUSTIuTUFHSUNfQ09PS0lFICsgNDtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBzaXplLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRFeHRlbnNpb25TaXplID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRFeHRlbnNpb25TaXplO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gY29kZS5cbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uQ29kZSA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uQ29kZTtcblxuXG5cbi8qKlxuICogUmV0dXJucyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBvZiBkYXRhdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldERhdGF0eXBlQ29kZVN0cmluZyA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RGF0YXR5cGVDb2RlU3RyaW5nO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIHRyYW5zZm9ybSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZztcblxuXG5cbi8qKlxuICogUmV0dXJucyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBvZiBzcGF0aWFsIGFuZCB0ZW1wb3JhbCB1bml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldFVuaXRzQ29kZVN0cmluZyA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0VW5pdHNDb2RlU3RyaW5nO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBxZm9ybSBtYXRyaXguXG4gKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn1cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRRZm9ybU1hdCA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0UWZvcm1NYXQ7XG5cblxuXG4vKipcbiAqIENvbnZlcnRzIHFmb3JtIHRvIGFuIGFmZmluZS4gIChTZWUgaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxX2lvLmMpXG4gKiBAcGFyYW0ge251bWJlcn0gcWJcbiAqIEBwYXJhbSB7bnVtYmVyfSBxY1xuICogQHBhcmFtIHtudW1iZXJ9IHFkXG4gKiBAcGFyYW0ge251bWJlcn0gcXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBxeVxuICogQHBhcmFtIHtudW1iZXJ9IHF6XG4gKiBAcGFyYW0ge251bWJlcn0gZHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICogQHBhcmFtIHtudW1iZXJ9IGR6XG4gKiBAcGFyYW0ge251bWJlcn0gcWZhY1xuICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuY29udmVydE5pZnRpUUZvcm1Ub05pZnRpU0Zvcm0gPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmNvbnZlcnROaWZ0aVFGb3JtVG9OaWZ0aVNGb3JtO1xuXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBzZm9ybSB0byBhbiBvcmllbnRhdGlvbiBzdHJpbmcgKGUuZy4sIFhZWistLSkuICAoU2VlIGh0dHA6Ly9uaWZ0aS5uaW1oLm5paC5nb3YvcHViL2Rpc3Qvc3JjL25pZnRpbGliL25pZnRpMV9pby5jKVxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBSXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmNvbnZlcnROaWZ0aVNGb3JtVG9ORU1BID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5jb252ZXJ0TmlmdGlTRm9ybVRvTkVNQTtcblxuXG5cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUubmlmdGlfbWF0MzNfbXVsID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5uaWZ0aV9tYXQzM19tdWw7XG5cblxuXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLm5pZnRpX21hdDMzX2RldGVybSA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUubmlmdGlfbWF0MzNfZGV0ZXJtO1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5pZnRpLk5JRlRJMjtcbn1cbiIsIlxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xuXG52YXIgbmlmdGkgPSBuaWZ0aSB8fCB7fTtcbm5pZnRpLlV0aWxzID0gbmlmdGkuVXRpbHMgfHwge307XG5cblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxubmlmdGkuVXRpbHMuY3JjVGFibGUgPSBudWxsO1xubmlmdGkuVXRpbHMuR1VOWklQX01BR0lDX0NPT0tJRTEgPSAzMTtcbm5pZnRpLlV0aWxzLkdVTlpJUF9NQUdJQ19DT09LSUUyID0gMTM5O1xuXG5cblxuLyoqKiBTdGF0aWMgbWV0aG9kcyAqKiovXG5cbm5pZnRpLlV0aWxzLmdldFN0cmluZ0F0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc3RyID0gXCJcIiwgY3RyLCBjaDtcblxuICAgIGZvciAoY3RyID0gc3RhcnQ7IGN0ciA8IGVuZDsgY3RyICs9IDEpIHtcbiAgICAgICAgY2ggPSBkYXRhLmdldFVpbnQ4KGN0cik7XG5cbiAgICAgICAgaWYgKGNoICE9PSAwKSB7XG4gICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldEJ5dGVBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCkge1xuICAgIHJldHVybiBkYXRhLmdldEludDgoc3RhcnQpO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldFNob3J0QXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiBkYXRhLmdldEludDE2KHN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldEludEF0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZGF0YS5nZXRJbnQzMihzdGFydCwgbGl0dGxlRW5kaWFuKTtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5nZXRGbG9hdEF0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZGF0YS5nZXRGbG9hdDMyKHN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldERvdWJsZUF0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZGF0YS5nZXRGbG9hdDY0KHN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldExvbmdBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgdmFyIGN0ciwgYXJyYXkgPSBbXSwgdmFsdWUgPSAwO1xuXG4gICAgZm9yIChjdHIgPSAwOyBjdHIgPCA4OyBjdHIgKz0gMSkge1xuICAgICAgICBhcnJheVtjdHJdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KGRhdGEsIHN0YXJ0ICsgY3RyLCBsaXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIGZvciAoY3RyID0gYXJyYXkubGVuZ3RoIC0gMTsgY3RyID49IDA7IGN0ci0tKSB7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlICogMjU2KSArIGFycmF5W2N0cl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgdmFyIGFiLCB2aWV3LCBpO1xuXG4gICAgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XG4gICAgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgfVxuICAgIHJldHVybiBhYjtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5pc1N0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nKTtcbn07XG5cblxubmlmdGkuVXRpbHMuZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24gKG51bSwgc2hvcnRGb3JtYXQpIHtcbiAgICB2YXIgdmFsID0gMDtcblxuICAgIGlmIChuaWZ0aS5VdGlscy5pc1N0cmluZyhudW0pKSB7XG4gICAgICAgIHZhbCA9IE51bWJlcihudW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG51bTtcbiAgICB9XG5cbiAgICBpZiAoc2hvcnRGb3JtYXQpIHtcbiAgICAgICAgdmFsID0gdmFsLnRvUHJlY2lzaW9uKDUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHZhbC50b1ByZWNpc2lvbig3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xufTtcblxuXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg2Mzg5MDAvamF2YXNjcmlwdC1jcmMzMlxubmlmdGkuVXRpbHMubWFrZUNSQ1RhYmxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYztcbiAgICB2YXIgY3JjVGFibGUgPSBbXTtcbiAgICBmb3IodmFyIG4gPTA7IG4gPCAyNTY7IG4rKyl7XG4gICAgICAgIGMgPSBuO1xuICAgICAgICBmb3IodmFyIGsgPTA7IGsgPCA4OyBrKyspe1xuICAgICAgICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JjVGFibGVbbl0gPSBjO1xuICAgIH1cbiAgICByZXR1cm4gY3JjVGFibGU7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuY3JjMzIgPSBmdW5jdGlvbihkYXRhVmlldykge1xuICAgIHZhciBjcmNUYWJsZSA9IG5pZnRpLlV0aWxzLmNyY1RhYmxlIHx8IChuaWZ0aS5VdGlscy5jcmNUYWJsZSA9IG5pZnRpLlV0aWxzLm1ha2VDUkNUYWJsZSgpKTtcbiAgICB2YXIgY3JjID0gMCBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFWaWV3LmJ5dGVMZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiBjcmNUYWJsZVsoY3JjIF4gZGF0YVZpZXcuZ2V0VWludDgoaSkpICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKSA+Pj4gMDtcbn07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbmlmdGkuVXRpbHM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxudmFyIGxpbmVTZXBhcmF0b3JSRSA9IC9bIFxcZlxcdFxcdl0qXFxyP1xcbi87XG52YXIgTlJSRE1hZ2ljUkUgPSAvXk5SUkRcXGR7NH0kLztcbnZhciBsaW5lUkUgPSAvXihbXjpdKikoOlsgPV0pKC4qKSQvO1xudmFyIGRhdGFGaWxlTGlzdFJFID0gL15MSVNUKD86IChcXGQrKSk/JC87XG5cbi8vIFRoZSBtaW5pbWFsIG9iamVjdCB0aGlzIGFjY2VwdHMgaXMgZm9ybWVkIGxpa2UgdGhpczpcbi8vICAge2RhdGE6IFNvbWVUeXBlZEFycmF5LCBzaXplczogWy4uLl19XG4vLyBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgZGF0YSBpcyBub3QgZ2l2ZW4gaXQgbXVzdCBoYXZlIGEgZm9ybSBsaWtlIHRoaXM6XG4vLyAgIHtidWZmZXI6IFNvbWVBcnJheUJ1ZmZlciwgdHlwZTogLi4uLCBlbmRpYW46IC4uLiwgc2l6ZXM6IFsuLi5dfVxuLy8gT2YgY291cnNlLCBpZiAndHlwZScgaXMgYW4gOC1iaXQgdHlwZSwgZW5kaWFuIGlzIG5vdCBuZWVkZWQsIGFuZCBpZiAndHlwZScgZXF1YWxzICdibG9jaycsICdibG9ja1NpemUnIHNob3VsZCBiZSBzZXQgaW5zdGVhZCBvZiAnZW5kaWFuJy4gSW4gdGhpcyBjYXNlLCBubyBpbnRlcnByZXRhdGlvbiBvZiBidWZmZXIgaXMgZG9uZSAoYXQgYWxsLCBpdCBpcyB3cml0dGVuIHNlcmlhbGl6ZWQgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlcikuXG4vLyBUT0RPOiBGb3Igbm93IHRoaXMgb25seSBzdXBwb3J0cyBzZXJpYWxpemluZyBcImlubGluZVwiIGZpbGVzLCBvciBmaWxlcyBmb3Igd2hpY2ggeW91IGhhdmUgYWxyZWFkeSBwcmVwYXJlZCB0aGUgZGF0YS5cbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChucnJkT3JnKSB7XG4gICAgdmFyIGksIGJ1ZmZlciwgYXJyLCB0b3RhbExlbiA9IDEsIG5ycmQgPSB7fSwgcHJvcCwgbmF0aXZlVHlwZSwgbmF0aXZlU2l6ZSwgYnVmZmVyRGF0YSwgYXJyRGF0YSwgbGluZSwgbGluZXMgPSBbXSwgaGVhZGVyO1xuICAgIFxuICAgIC8vIENvcHkgbnJyZE9yZyB0byBucnJkIHRvIGFsbG93IG1vZGlmaWNhdGlvbnMgd2l0aG91dCBhbHRlcmluZyB0aGUgb3JpZ2luYWxcbiAgICBmb3IocHJvcCBpbiBucnJkT3JnKSB7XG4gICAgICAgIG5ycmRbcHJvcF0gPSBucnJkT3JnW3Byb3BdO1xuICAgIH1cbiAgICBcbiAgICAvLyBGb3Igc2F2aW5nIGZpbGVzIHdlIGFsbG93IGluZmVycmluZyBjZXJ0YWluIGluZm9ybWF0aW9uIGlmIGl0IGlzIG5vdCBleHBsaWNpdGx5IGdpdmVuLlxuICAgIC8vIEFsc28gd2Ugbm9ybWFsaXplIHNvbWUgZmllbGRzIHRvIG1ha2Ugb3VyIG93biBsaXZlcyBlYXNpZXIuXG4gICAgaWYgKG5ycmQuc2l6ZXM9PT11bmRlZmluZWQpIHsgLy8gJ3NpemVzJyBzaG91bGQgQUxXQVlTIGJlIGdpdmVuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpemVzIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kaW1lbnNpb249PT11bmRlZmluZWQpIHtcbiAgICAgICAgbnJyZC5kaW1lbnNpb24gPSBucnJkLnNpemVzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJpbnQ4XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcInVpbnQ4XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcImludDE2XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJ1aW50MTZcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwiaW50MzJcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcInVpbnQzMlwiO1xuICAgIC8vfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBJbnQ2NEFycmF5KSB7XG4gICAgLy8gICAgbmF0aXZlVHlwZSA9IFwiaW50NjRcIjtcbiAgICAvL30gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgVWludDY0QXJyYXkpIHtcbiAgICAvLyAgICBuYXRpdmVUeXBlID0gXCJ1aW50NjRcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJmbG9hdFwiO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcImRvdWJsZVwiO1xuICAgIH1cbiAgICBpZiAobnJyZC50eXBlPT09dW5kZWZpbmVkICYmIG5hdGl2ZVR5cGUhPT11bmRlZmluZWQpIHtcbiAgICAgICAgbnJyZC50eXBlID0gbmF0aXZlVHlwZTtcbiAgICB9IGVsc2UgaWYgKG5ycmQudHlwZT09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG9mIGRhdGEgaXMgbm90IGdpdmVuIGFuZCBjYW5ub3QgYmUgaW5mZXJyZWQhXCIpO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBucnJkLnR5cGUpID09IFwic3RyaW5nXCIgfHwgbnJyZC50eXBlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIG5ycmQudHlwZSA9IHBhcnNlTlJSRFR5cGUobnJyZC50eXBlKTtcbiAgICB9XG4gICAgaWYgKG5ycmQuZW5jb2Rpbmc9PT11bmRlZmluZWQpIHtcbiAgICAgICAgbnJyZC5lbmNvZGluZyA9IFwicmF3XCI7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIG5ycmQuZW5jb2RpbmcpID09IFwic3RyaW5nXCIgfHwgbnJyZC5lbmNvZGluZyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICBucnJkLmVuY29kaW5nID0gcGFyc2VOUlJERW5jb2RpbmcobnJyZC5lbmNvZGluZyk7XG4gICAgfVxuICAgIGlmIChucnJkLmRhdGEgJiYgbnJyZC50eXBlICE9ICdibG9jaycgJiYgbnJyZC50eXBlICE9ICdpbnQ4JyAmJiBucnJkLnR5cGUgIT0gJ3VpbnQ4JyAmJiBucnJkLmVuY29kaW5nICE9ICdhc2NpaScpIHtcbiAgICAgICAgbnJyZC5lbmRpYW4gPSBzeXN0ZW1FbmRpYW5uZXNzO1xuICAgIH0gZWxzZSBpZiAobnJyZC50eXBlID09ICdibG9jaycgfHwgbnJyZC50eXBlID09ICdpbnQ4JyB8fCBucnJkLnR5cGUgPT0gJ3VpbnQ4JyB8fCBucnJkLmVuY29kaW5nID09ICdhc2NpaScpIHtcbiAgICAgICAgbnJyZC5lbmRpYW4gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIG5ycmQuZW5kaWFuKSA9PSBcInN0cmluZ1wiIHx8IG5ycmQuZW5kaWFuIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIG5ycmQuZW5kaWFuID0gcGFyc2VOUlJERW5kaWFuKG5ycmQuZW5kaWFuKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGluZmVyIHNwYXRpYWwgZGltZW5zaW9uXG4gICAgdmFyIHNwYWNlRGltZW5zaW9uID0gdW5kZWZpbmVkO1xuICAgIGlmIChucnJkLnNwYWNlRGltZW5zaW9uIT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHNwYWNlRGltZW5zaW9uID0gbnJyZC5zcGFjZURpbWVuc2lvbjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuc3BhY2UhPT11bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoKG5ycmQuc3BhY2UpIHtcbiAgICAgICAgY2FzZSBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgICAgIGNhc2UgXCJSQVNcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdC1hbnRlcmlvci1zdXBlcmlvclwiOlxuICAgICAgICBjYXNlIFwiTEFTXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgICAgIGNhc2UgXCJMUFNcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICBcdCAgY2FzZSBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yLXRpbWVcIjpcbiAgICAgXHQgIGNhc2UgXCJSQVNUXCI6XG4gICAgIFx0ICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICBcdCAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdC1hbnRlcmlvci1zdXBlcmlvci10aW1lXCI6XG4gICAgICAgIGNhc2UgXCJMQVNUXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yLXRpbWVcIjpcbiAgICAgICAgY2FzZSBcIkxQU1RcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2Nhbm5lci14eXpcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2Nhbm5lci14eXotdGltZVwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIzRC1yaWdodC1oYW5kZWRcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiM0QtbGVmdC1oYW5kZWRcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiM0QtcmlnaHQtaGFuZGVkLXRpbWVcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiM0QtbGVmdC1oYW5kZWQtdGltZVwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgc3BhY2U6IFwiICsgbnJyZC5zcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTm93IGNoZWNrIHRoYXQgd2UgaGF2ZSBhIHZhbGlkIG5ycmQgc3RydWN0dXJlLlxuICAgIGNoZWNrTlJSRChucnJkKTtcblxuICAgIC8vIERldGVybWluZSBudW1iZXIgb2YgZWxlbWVudHMgYW5kIGNoZWNrIHRoYXQgd2UgaGF2ZSBlbm91Z2ggZGF0YSAoaWYgcG9zc2libGUpXG4gICAgZm9yKGk9MDsgaTxucnJkLnNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChucnJkLnNpemVzW2ldPD0wKSB0aHJvdyBuZXcgRXJyb3IoXCJTaXplcyBzaG91bGQgYmUgYSBsaXN0IG9mIHBvc2l0aXZlICg+MCkgaW50ZWdlcnMhXCIpO1xuICAgICAgICB0b3RhbExlbiAqPSBucnJkLnNpemVzW2ldO1xuICAgIH1cbiAgICBpZiAobnJyZC5kYXRhKSB7XG4gICAgICAgIGlmIChucnJkLmRhdGEubGVuZ3RoIDwgdG90YWxMZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGF0YSB0byBzZXJpYWxpemUhXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChucnJkLmJ1ZmZlcikge1xuICAgICAgICBpZiAobnJyZC5lbmNvZGluZyA9PSBcInJhd1wiKSB7XG4gICAgICAgICAgICBpZiAobnJyZC50eXBlPT1cImJsb2NrXCIgJiYgbnJyZC5ibG9ja1NpemUhPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVTaXplID0gbnJyZC5ibG9ja1NpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdGl2ZVNpemUgPSBnZXROUlJEVHlwZVNpemUobnJyZC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChucnJkLmJ1ZmZlci5ieXRlTGVuZ3RoIDwgdG90YWxMZW4qbmF0aXZlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGF0YSB0byBzZXJpYWxpemUhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGFGaWxlKSB7XG4gICAgICAgIC8vIE9rYXksIGlmIHlvdSBoYXZlIHlvdXIgZGF0YSByZWFkeSwgd2UnbGwganVzdCB3cml0ZSBhIGhlYWRlci5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWxsIG5vdCBzZXJpYWxpemUgYW4gZW1wdHkgTlJSRCBmaWxlIVwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgdGhlIGNvcnJlY3QgYnVmZmVyIGluIGJ1ZmZlckRhdGEuXG4gICAgaWYgKG5ycmQuZGF0YSkge1xuICAgICAgICBzd2l0Y2gobnJyZC5lbmNvZGluZykge1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgaWYgKG5ycmQudHlwZSA9PSBuYXRpdmVUeXBlICYmIG5ycmQuZW5kaWFuID09IHN5c3RlbUVuZGlhbm5lc3MpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gbnJyZC5kYXRhLmJ1ZmZlci5zbGljZShucnJkLmRhdGEuYnl0ZU9mZnNldCwgbnJyZC5kYXRhLmJ5dGVPZmZzZXQrbnJyZC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChucnJkLmVuZGlhbiA9PSBzeXN0ZW1FbmRpYW5uZXNzKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IGNhc3RUeXBlZEFycmF5KG5ycmQuZGF0YSwgbnJyZC50eXBlKTtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gYnVmZmVyRGF0YS5idWZmZXIuc2xpY2UoYnVmZmVyRGF0YS5ieXRlT2Zmc2V0LCBidWZmZXJEYXRhLmJ5dGVPZmZzZXQrYnVmZmVyRGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IHNlcmlhbGl6ZVRvQnVmZmVyKG5ycmQuZGF0YSwgbnJyZC50eXBlLCBucnJkLmVuZGlhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICAgICAgaWYgKG5ycmQudHlwZSA9PSBuYXRpdmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IHNlcmlhbGl6ZVRvVGV4dEJ1ZmZlcihucnJkLmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gc2VyaWFsaXplVG9UZXh0QnVmZmVyKGNhc3RUeXBlZEFycmF5KG5ycmQuZGF0YSwgbnJyZC50eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIE5SUkQgZW5jb2Rpbmc6IFwiICsgbnJyZC5lbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5ycmQuYnVmZmVyKSB7XG4gICAgICAgIGJ1ZmZlckRhdGEgPSBucnJkLmJ1ZmZlcjtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RhcnQgaGVhZGVyXG4gICAgbGluZXMucHVzaChcIk5SUkQwMDA1XCIpOyAvLyBUT0RPOiBBZGp1c3QgdmVyc2lvbiBiYXNlZCBvbiBmZWF0dXJlcyB0aGF0IGFyZSBhY3R1YWxseSB1c2VkIGFuZC9vciB0aGUgdmVyc2lvbiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgKGlmIGFueSkuXG4gICAgbGluZXMucHVzaChcIiMgR2VuZXJhdGVkIGJ5IG5ycmQtanNcIik7XG4gICAgXG4gICAgLy8gUHV0IGluIGRpbWVuc2lvbiBhbmQgc3BhY2UgZGltZW5zaW9uICh0aGUgTlJSRCBzcGVjIHJlcXVpcmVzIHRoYXQgdGhlc2UgYXJlIHByZXNlbnQgYmVmb3JlIGFueSBsaXN0cyB3aG9zZSBsZW5ndGggZGVwZW5kcyBvbiB0aGVtKVxuICAgIHZhciBmaXJzdFByb3BzID0gWydkaW1lbnNpb24nLCAnc3BhY2VEaW1lbnNpb24nLCAnc3BhY2UnXTtcbiAgICBmb3IoaT0wOyBpPGZpcnN0UHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IGZpcnN0UHJvcHNbaV07XG4gICAgICAgIGlmIChucnJkW3Byb3BdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAvLyBTa2lwIHRoaW5ncyB3ZSBleHBsaWNpdGx5IHNldCB0byB1bmRlZmluZWQuXG4gICAgICAgIGxpbmUgPSBzZXJpYWxpemVGaWVsZChwcm9wLCBucnJkW3Byb3BdLCBucnJkLmRpbWVuc2lvbiwgc3BhY2VEaW1lbnNpb24pO1xuICAgICAgICBpZiAobGluZSE9PXVuZGVmaW5lZCkgbGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUHV0IGluIGZpZWxkIHNwZWNpZmljYXRpb25zXG4gICAgZm9yKHByb3AgaW4gbnJyZCkge1xuICAgICAgICBpZiAobnJyZFtwcm9wXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gU2tpcCB0aGluZ3Mgd2UgZXhwbGljaXRseSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgICAgICBpZiAoZmlyc3RQcm9wcy5pbmRleE9mKHByb3ApPj0wKSBjb250aW51ZTsgLy8gU2tpcCB0aGUgZmllbGRzIHdlIGFscmVhZHkgb3V0cHV0LlxuICAgICAgICBsaW5lID0gc2VyaWFsaXplRmllbGQocHJvcCwgbnJyZFtwcm9wXSwgbnJyZC5kaW1lbnNpb24sIHNwYWNlRGltZW5zaW9uKTtcbiAgICAgICAgaWYgKGxpbmUhPT11bmRlZmluZWQpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFB1dCBpbiBrZXlzIChpZiBhbnkpXG4gICAgaWYgKG5ycmQua2V5cykgZm9yKHByb3AgaW4gbnJyZC5rZXlzKSB7XG4gICAgICAgIGlmIChwcm9wLmluZGV4T2YoXCI6PVwiKT49MCkgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbWJpbmF0aW9uICc6PScgaXMgbm90IGFsbG93ZWQgaW4gYW4gTlJSRCBrZXkhXCIpO1xuICAgICAgICBsaW5lcy5wdXNoKHByb3AgKyBcIjo9XCIgKyBlc2NhcGVWYWx1ZShucnJkW3Byb3BdKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFB1dCBpbiBkYXRhIGZpbGUgbGlzdCAoaWYgYW55KVxuICAgIGlmIChucnJkLmRhdGFGaWxlICYmIG5ycmQuZGF0YUZpbGUubGVuZ3RoKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCJkYXRhIGZpbGU6IExJU1RcIik7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpbmVzLCBucnJkLmRhdGFGaWxlKTtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YUZpbGUgJiYgbnJyZC5kYXRhRmlsZS5maWxlcyAmJiAnc3ViZGltJyBpbiBucnJkLmRhdGFGaWxlKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCJkYXRhIGZpbGU6IExJU1QgXCIgKyBucnJkLmRhdGFGaWxlLnN1YmRpbSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpbmVzLCBucnJkLmRhdGFGaWxlLmZpbGVzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUHV0IGluIGVtcHR5IGxpbmUgYW5kIGlubGluZSBkYXRhIChpZiB3ZSBoYXZlIGlubGluZSBkYXRhKSBhbmQgY29udmVydCBsaW5lcyB0byBidWZmZXJcbiAgICBpZiAoYnVmZmVyRGF0YSAmJiAhKCdkYXRhRmlsZScgaW4gbnJyZCkpIHtcbiAgICAgICAgbGluZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGluZXMucHVzaChcIlwiKTsgLy8gV2UgYWN0dWFsbHkgbmVlZCBhbiBleHRyYSBibGFuayBsaW5lIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgaXMgdGVybWluYXRlZC5cbiAgICAgICAgaGVhZGVyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGhlYWRlci5sZW5ndGggKyBidWZmZXJEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBhcnIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBmb3IoaT0wOyBpPGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyRGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckRhdGEpO1xuICAgICAgICBhcnIuc2V0KGFyckRhdGEsIGhlYWRlci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCJcIik7IC8vIEJsYW5rIGxpbmUgdG8gYXQgbGVhc3QgdGVybWluYXRlIHRoZSBsYXN0IGxpbmUuXG4gICAgICAgIGhlYWRlciA9IGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihoZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgZm9yKGk9MDsgaTxoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBUaGlzIGV4cGVjdHMgYW4gQXJyYXlCdWZmZXIuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICB2YXIgaSwgaGVhZGVyLCBkYXRhU3RhcnQsIHJldCA9IHtkYXRhOiB1bmRlZmluZWQvKiBwYXJzZWQgZGF0YSAqLywgYnVmZmVyOiB1bmRlZmluZWQvKiByYXcgYnVmZmVyIGhvbGRpbmcgZGF0YSAqLywga2V5czoge30sIHZlcnNpb246IHVuZGVmaW5lZH0sXG4gICAgICAgIGxpbmVzLCBtYXRjaCwgbWF0Y2gyLFxuICAgICAgICBidWY4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuICAgIC8vIEEgd29yay1hcm91bmQgZm9yIGluY29tcGF0aWJpbGl0aWVzIGJldHdlZW4gTm9kZSdzIEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIuXG4gICAgaWYgKGJ1ZjguYnVmZmVyICE9PSBidWZmZXIpIGJ1ZmZlciA9IGJ1ZjguYnVmZmVyO1xuXG4gICAgLy8gRmlyc3QgZmluZCB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIHRoZSBoZWFkZXIgYW5kIHRoZSBkYXRhIChpZiB0aGVyZSBpcyBvbmUpXG4gICAgLy8gTm90ZSB0aGF0IHdlIG5lZWQgdG8gZGVhbCB3aXRoIHdpdGggTEYgYW5kIENSTEYgYXMgcG9zc2libGUgbGluZSBlbmRpbmdzLlxuICAgIC8vIEx1Y2tpbHkgdGhpcyBtZWFucyB0aGUgbGluZSBhbHdheXMgZW5kcyB3aXRoIExGLCBzbyB3ZSBvbmx5IG5lZWQgdG8gY29uc2lkZXJcbiAgICAvLyBMRkxGIGFuZCBMRkNSTEYgYXMgcGF0dGVybnMgZm9yIHRoZSBzZXBhcmF0aW5nIGVtcHR5IGxpbmUuXG4gICAgaT0yOyAvLyBJdCBpcyBzYWZlIHRvIHN0YXJ0IGF0IHBvc2l0aW9uIDIgKGluIGZhY3QsIHdlIGNvdWxkIHN0YXJ0IGV2ZW4gbGF0ZXIpLCBhcyB0aGUgZmlsZSBIQVMgdG8gc3RhcnQgd2l0aCBhIG1hZ2ljIHdvcmQuXG4gICAgd2hpbGUoaTxidWY4Lmxlbmd0aCkge1xuICAgICAgICBpZiAoYnVmOFtpXSA9PSAxMCkgeyAvLyBXZSBoaXQgYW4gTEZcbiAgICAgICAgICAgIGlmIChidWY4W2ktMV0gPT0gMTAgfHwgKGJ1ZjhbaS0xXSA9PSAxMyAmJiBidWY4W2ktMl0gPT0gMTApKSB7IC8vIFNhZmUgYmVjYXVzZSB3ZSBzdGFydCBhdCBwb3NpdGlvbiAyIGFuZCBuZXZlciBtb3ZlIGJhY2t3YXJkc1xuICAgICAgICAgICAgICAgIGRhdGFTdGFydCA9IGkrMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrOyAvLyBNb3ZlIGZvcndhcmQganVzdCBvbmNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmOFtpXSA9PSAxMykgeyAvLyBXZSBoaXQgYSBDUlxuICAgICAgICAgICAgaSsrOyAvLyBNb3ZlIGZvcndhcmQganVzdCBvbmNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpICs9IDI7IC8vIE1vdmUgZm9yd2FyZCB0d28gcGxhY2VzLCBcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBOb3cgc3BsaXQgdXAgdGhlIGhlYWRlciBhbmQgZGF0YVxuICAgIGlmIChkYXRhU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWFkZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1ZjgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmOC5zdWJhcnJheSgwLGRhdGFTdGFydCkpO1xuICAgICAgICByZXQuYnVmZmVyID0gYnVmZmVyLnNsaWNlKGRhdGFTdGFydCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNwbGl0IGhlYWRlciBpbnRvIGxpbmVzLCByZW1vdmUgY29tbWVudHMgKGFuZCBibGFuayBsaW5lcykgYW5kIGNoZWNrIG1hZ2ljLlxuICAgIC8vIEFsbCByZW1haW5pbmcgbGluZXMgZXhjZXB0IHRoZSBmaXJzdCBzaG91bGQgYmUgZmllbGQgc3BlY2lmaWNhdGlvbnMgb3Iga2V5L3ZhbHVlIHBhaXJzLlxuICAgIC8vIFRPRE86IFRoaXMgZXhwbGljaXRseSByZW1vdmVzIGFueSB3aGl0ZXNwYWNlIGF0IHRoZSBlbmQgb2YgbGluZXMsIGhvd2V2ZXIsIEkgYW0gbm90IHN1cmUgdGhhdCB0aGlzIGlzIGFjdHVhbGx5IGRlc2lyZWQgYmVoYXZpb3VyIGZvciBhbGwga2luZHMgb2YgbGluZXMuXG4gICAgbGluZXMgPSBoZWFkZXIuc3BsaXQobGluZVNlcGFyYXRvclJFKTtcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5sZW5ndGg+MCAmJiBsWzBdICE9ICcjJzsgfSk7IC8vIFJlbW92ZSBjb21tZW50IGxpbmVzXG4gICAgaWYgKCFOUlJETWFnaWNSRS50ZXN0KGxpbmVzWzBdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIGlzIG5vdCBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH1cbiAgICByZXQudmVyc2lvbiA9IHBhcnNlSW50KGxpbmVzWzBdLnN1YnN0cmluZyg0LCA4KSwgMTApO1xuICAgIGlmIChyZXQudmVyc2lvbj41KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlJlYWRpbmcgYW4gdW5zdXBwb3J0ZWQgdmVyc2lvbiBvZiB0aGUgTlJSRCBmb3JtYXQ7IHRoaW5ncyBtYXkgZ28gaGF5d2lyZS5cIik7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgbGluZXNcbiAgICBmb3IoaT0xOyBpPGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgbGluZSBpbiBOUlJEIGhlYWRlcjogXCIgKyBsaW5lc1tpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMl0gPT0gJzogJykgeyAvLyBGaWVsZCBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICBtYXRjaFsxXSA9IG1hcE5SUkRUb0phdmFzY3JpcHQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgaWYgKCBtYXRjaFsxXSA9PSAnZGF0YUZpbGUnICYmXG4gICAgICAgICAgICAgICAgIChtYXRjaDIgPSBkYXRhRmlsZUxpc3RSRS5leGVjKG1hdGNoWzNdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB0aGUgbGFzdCBmaWVsZCBzcGVjaWZpY2F0aW9uLFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgcmVzdCBvZiB0aGUgbGluZXMgc2hvdWxkIGNvbnRhaW4gZmlsZSBuYW1lcy5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gyLmxlbmd0aCA9PSAyICYmIG1hdGNoMlsxXSkgeyAvLyBzdWJkaW0gc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICByZXRbbWF0Y2hbMV1dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXM6IGxpbmVzLnNsaWNlKGkrMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJkaW06IHBhcnNlTlJSREludGVnZXIobWF0Y2gyWzFdKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFttYXRjaFsxXV0gPSBsaW5lcy5zbGljZShpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcy5sZW5ndGggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRbbWF0Y2hbMV1dID0gcGFyc2VGaWVsZChtYXRjaFsxXSwgbWF0Y2hbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzJdID09ICc6PScpIHsgLy8gS2V5L3ZhbHVlIHBhaXJcbiAgICAgICAgICAgIHJldC5rZXlzW21hdGNoWzFdXSA9IHVuZXNjYXBlVmFsdWUobWF0Y2hbM10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9naWMgZXJyb3IgaW4gTlJSRCBwYXJzZXIuXCIpOyAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gKHVubGVzcyB0aGUgTlJSRCBzeW50YXggaXMgZXh0ZW5kZWQgYW5kIHRoZSByZWdleHAgaXMgdXBkYXRlZCwgYnV0IHRoaXMgc2VjdGlvbiBpcyBub3QsIG9yIHNvbWUgb3RoZXIgcHJvZ3JhbW1lciBlcnJvcikuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgc2F0aXNmaWVzIHRoZSByZXF1aXJlbWVudHMgb2YgdGhlIE5SUkQgZm9ybWF0XG4gICAgY2hlY2tOUlJEKHJldCk7XG4gICAgXG4gICAgLy8gXCJQYXJzZVwiIGRhdGFcbiAgICBpZiAoJ2RhdGFGaWxlJyBpbiByZXQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gc3VwcG9ydCBmb3IgZXh0ZXJuYWwgZGF0YSB5ZXQhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChyZXQuZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgICAgIHJldC5kYXRhID0gcGFyc2VOUlJEUmF3RGF0YShyZXQuYnVmZmVyLCByZXQudHlwZSwgcmV0LnNpemVzLCB7XG4gICAgICAgICAgICAgICAgZW5kaWFuOiByZXQuZW5kaWFuLCBibG9ja1NpemU6IHJldC5ibG9ja1NpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgICAgIHJldC5kYXRhID0gcGFyc2VOUlJEVGV4dERhdGEocmV0LmJ1ZmZlciwgcmV0LnR5cGUsIHJldC5zaXplcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIE5SUkQgZW5jb2Rpbmc6IFwiICsgcmV0LmVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gZXNjYXBlVmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKCdcXFxcJywgJ1xcXFxcXFxcJykucmVwbGFjZSgnXFxuJywgJ1xcXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlVmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIHZhbC5zcGxpdCgnXFxcXFxcXFwnKS5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgnXFxcXG4nLCAnXFxuJyk7IH1cbiAgICAgICAgKS5qb2luKCdcXFxcJyk7XG59XG5cbi8vIFNlcmlhbGl6ZXMgTlJSRCBmaWVsZHNcbmZ1bmN0aW9uIHNlcmlhbGl6ZUZpZWxkKHByb3AsIHZhbHVlLCBkaW1lbnNpb24sIHNwYWNlRGltZW5zaW9uKSB7XG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIHByb3BOUlJEID0gbWFwSmF2YXNjcmlwdFRvTlJSRChwcm9wKTtcbiAgICBzd2l0Y2gocHJvcCkge1xuICAgIC8vIG5ycmQtanMgc3R1ZmY6IHNraXBcbiAgICBjYXNlICdkYXRhJzpcbiAgICBjYXNlICdidWZmZXInOlxuICAgIGNhc2UgJ2tleXMnOlxuICAgIGNhc2UgJ3ZlcnNpb24nOlxuICAgICAgICBicmVhaztcbiAgICAvLyBMaXRlcmFsICh1bmludGVycHJldGVkKSBmaWVsZHNcbiAgICBjYXNlICdjb250ZW50JzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3NhbXBsZVVuaXRzJzpcbiAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAvLyBJbnRlZ2VycyAobm8gaW5maW5pdHkgb3Igd2hhdGV2ZXIsIGp1c3QgYSBwbGFpbiBpbnRlZ2VyLCBzbyB0aGUgZGVmYXVsdCBzZXJpYWxpemF0aW9uIGlzIGdvb2QgZW5vdWdoKVxuICAgIGNhc2UgJ2Jsb2NrU2l6ZSc6XG4gICAgY2FzZSAnbGluZVNraXAnOlxuICAgIGNhc2UgJ2J5dGVTa2lwJzpcbiAgICBjYXNlICdkaW1lbnNpb24nOlxuICAgIGNhc2UgJ3NwYWNlRGltZW5zaW9uJzpcbiAgICAgICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUpID09IFwibnVtYmVyXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGF0IGxlYXN0IGNvbnRhaW4gYSBudW1iZXIhXCIpO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gRmxvYXRzIChkZWZhdWx0IHNlcmlhbGl6YXRpb24gaXMgZ29vZCBlbm91Z2gsIGFzIE5hTiBjb250YWlucyBuYW4sIGlnbm9yaW5nIGNhc2UsIGFuZCBzaW1pbGFybHkgZm9yIEluZmluaXR5IGluZilcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ21heCc6XG4gICAgY2FzZSAnb2xkTWluJzpcbiAgICBjYXNlICdvbGRNYXgnOlxuICAgICAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSkgPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgY29udGFpbiBhIG51bWJlciFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAvLyBWZWN0b3JzXG4gICAgY2FzZSAnc3BhY2VPcmlnaW4nOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoID09PSBzcGFjZURpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBzcGFjZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcIm51bWJlclwiIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlciwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IChcIiArIHZhbHVlLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIHN0cmluZ3NcbiAgICBjYXNlICdsYWJlbHMnOlxuICAgIGNhc2UgJ3VuaXRzJzpcbiAgICBjYXNlICdzcGFjZVVuaXRzJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7IGFzc2VydCgodHlwZW9mIHZhbCkgPT0gXCJzdHJpbmdcIiB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmcsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCBvZiBudW1iZXJzIVwiKTsgfSk7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLm1hcChzZXJpYWxpemVOUlJEUXVvdGVkU3RyaW5nKS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgaW50ZWdlcnNcbiAgICBjYXNlICdzaXplcyc6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPT0gZGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbCkgeyBhc3NlcnQoKHR5cGVvZiB2YWwpID09IFwibnVtYmVyXCIgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgb2YgbnVtYmVycyFcIik7IH0pO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgZmxvYXRzXG4gICAgY2FzZSAnc3BhY2luZ3MnOlxuICAgIGNhc2UgJ3RoaWNrbmVzc2VzJzpcbiAgICBjYXNlICdheGlzTWlucyc6XG4gICAgY2FzZSAnYXhpc01heHMnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09IGRpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcIm51bWJlclwiIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlciwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIHZlY3RvcnMgKGRpbWVuc2lvbiBzaXplZClcbiAgICBjYXNlICdzcGFjZURpcmVjdGlvbnMnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmVjKSB7XG4gICAgICAgICAgYXNzZXJ0KHZlYyA9PT0gbnVsbCB8fCAodmVjLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZlYy5sZW5ndGggPT09IHNwYWNlRGltZW5zaW9uKSwgXCJUaGUgZWxlbWVudHMgb2YgZmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGxpc3RzIHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBzcGFjZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICAgIGlmICh2ZWMgIT09IG51bGwpIHZlYy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcIm51bWJlclwiIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlciwgXCJUaGUgZWxlbWVudHMgb2YgZmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGxpc3RzIG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLm1hcChmdW5jdGlvbih2ZWMpIHsgcmV0dXJuIHZlYyA9PT0gbnVsbCA/IFwibm9uZVwiIDogKFwiKFwiICsgdmVjLmpvaW4oXCIsXCIpICsgXCIpXCIpOyB9KS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgdmVjdG9ycyAoc3BhY2UgZGltZW5zaW9uIHNpemVkKVxuICAgIGNhc2UgJ21lYXN1cmVtZW50RnJhbWUnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09PSBzcGFjZURpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBzcGFjZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2ZWMpIHtcbiAgICAgICAgICBhc3NlcnQodmVjID09PSBudWxsIHx8ICh2ZWMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmVjLmxlbmd0aCA9PT0gc3BhY2VEaW1lbnNpb24pLCBcIlRoZSBlbGVtZW50cyBvZiBmaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgbGlzdHMgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIHNwYWNlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgICAgaWYgKHZlYyAhPT0gbnVsbCkgdmVjLmZvckVhY2goZnVuY3Rpb24gKHZhbCkgeyBhc3NlcnQoKHR5cGVvZiB2YWwpID09IFwibnVtYmVyXCIgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyLCBcIlRoZSBlbGVtZW50cyBvZiBmaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgbGlzdHMgb2YgbnVtYmVycyFcIik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUubWFwKGZ1bmN0aW9uKHZlYykgeyByZXR1cm4gdmVjID09PSBudWxsID8gXCJub25lXCIgOiAoXCIoXCIgKyB2ZWMuam9pbihcIixcIikgKyBcIilcIik7IH0pLmpvaW4oXCIgXCIpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBPbmUtb2YtYS1raW5kIGZpZWxkc1xuICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSkgPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZywgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgY29udGFpbiBhIHN0cmluZyFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdlbmNvZGluZyc6XG4gICAgICAgIGFzc2VydCgodHlwZW9mIHZhbHVlKSA9PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBjb250YWluIGEgc3RyaW5nIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZGlhbic6XG4gICAgICAgIGFzc2VydCgodHlwZW9mIHZhbHVlKSA9PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBjb250YWluIGEgc3RyaW5nIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RhdGFGaWxlJzpcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCB8fCAodmFsdWUuZmlsZXMgJiYgJ3N1YmRpbScgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIGRhdGEgZmlsZXM6IHNraXAgZm9yIG5vd1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgc2VyaWFsaXplTlJSRERhdGFGaWxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXJzJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUubWFwKHNlcmlhbGl6ZU5SUkRPcHRpb25hbCkuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2tpbmRzJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUubWFwKHNlcmlhbGl6ZU5SUkRPcHRpb25hbCkuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIFNvbWV0aGluZyB1bmtub3duXG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgZmllbGQ6IFwiICsgcHJvcCArIFwiLCBza2lwcGluZy5cIik7XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuXG4vLyBQYXJzZXMgYW5kIG5vcm1hbGl6ZXMgTlJSRCBmaWVsZHMsIGFzc3VtZXMgdGhlIGZpZWxkIG5hbWVzIGFyZSBhbHJlYWR5IGxvd2VyIGNhc2UuXG5mdW5jdGlvbiBwYXJzZUZpZWxkKGlkZW50aWZpZXIsIGRlc2NyaXB0b3IpIHtcbiAgICBzd2l0Y2goaWRlbnRpZmllcikge1xuICAgIC8vIExpdGVyYWwgKHVuaW50ZXJwcmV0ZWQpIGZpZWxkc1xuICAgIGNhc2UgJ2NvbnRlbnQnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc2FtcGxlVW5pdHMnOlxuICAgICAgICBicmVhaztcbiAgICAvLyBJbnRlZ2Vyc1xuICAgIGNhc2UgJ2RpbWVuc2lvbic6XG4gICAgY2FzZSAnYmxvY2tTaXplJzpcbiAgICBjYXNlICdsaW5lU2tpcCc6XG4gICAgY2FzZSAnYnl0ZVNraXAnOlxuICAgIGNhc2UgJ3NwYWNlRGltZW5zaW9uJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSREludGVnZXIoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIEZsb2F0c1xuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbWF4JzpcbiAgICBjYXNlICdvbGRNaW4nOlxuICAgIGNhc2UgJ29sZE1heCc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRGbG9hdChkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gVmVjdG9yc1xuICAgIGNhc2UgJ3NwYWNlT3JpZ2luJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFZlY3RvcihkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2Ygc3RyaW5nc1xuICAgIGNhc2UgJ2xhYmVscyc6XG4gICAgY2FzZSAndW5pdHMnOlxuICAgIGNhc2UgJ3NwYWNlVW5pdHMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJEUXVvdGVkU3RyaW5nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgaW50ZWdlcnNcbiAgICBjYXNlICdzaXplcyc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRXaGl0ZXNwYWNlU2VwYXJhdGVkTGlzdChkZXNjcmlwdG9yLCBwYXJzZU5SUkRJbnRlZ2VyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgZmxvYXRzXG4gICAgY2FzZSAnc3BhY2luZ3MnOlxuICAgIGNhc2UgJ3RoaWNrbmVzc2VzJzpcbiAgICBjYXNlICdheGlzTWlucyc6XG4gICAgY2FzZSAnYXhpc01heHMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJERmxvYXQpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiB2ZWN0b3JzXG4gICAgY2FzZSAnc3BhY2VEaXJlY3Rpb25zJzpcbiAgICBjYXNlICdtZWFzdXJlbWVudEZyYW1lJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KGRlc2NyaXB0b3IsIHBhcnNlTlJSRFZlY3Rvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIE9uZS1vZi1hLWtpbmQgZmllbGRzXG4gICAgY2FzZSAndHlwZSc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRUeXBlKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdlbmNvZGluZyc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRFbmNvZGluZyhkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kaWFuJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSREVuZGlhbihkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGF0YUZpbGUnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJERGF0YUZpbGUoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlcnMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJEQ2VudGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAna2luZHMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJES2luZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFNwYWNlKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBTb21ldGhpbmcgdW5rbm93blxuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBOUlJEIGZpZWxkOiBcIiArIGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cblxuLy8gVGhpcyBvbmx5IGluY2x1ZGVzIG5hbWVzIHdob3NlIGxvd2VyIGNhc2UgZm9ybSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgSmF2YXNjcmlwdCBmb3JtLlxudmFyIG1hcE5SUkRUb0phdmFzY3JpcHRTdGF0aWMgPSB7XG4gICAgJ2Jsb2NrIHNpemUnOiAnYmxvY2tTaXplJyxcbiAgICAnYmxvY2tzaXplJzogJ2Jsb2NrU2l6ZScsXG4gICAgJ29sZCBtaW4nOiAnb2xkTWluJyxcbiAgICAnb2xkbWluJzogJ29sZE1pbicsXG4gICAgJ29sZCBtYXgnOiAnb2xkTWF4JyxcbiAgICAnb2xkbWF4JzogJ29sZE1heCcsXG4gICAgJ2RhdGEgZmlsZSc6ICdkYXRhRmlsZScsXG4gICAgJ2RhdGFmaWxlJzogJ2RhdGFGaWxlJyxcbiAgICAnbGluZSBza2lwJzogJ2xpbmVTa2lwJyxcbiAgICAnbGluZXNraXAnOiAnbGluZVNraXAnLFxuICAgICdieXRlIHNraXAnOiAnYnl0ZVNraXAnLFxuICAgICdieXRlc2tpcCc6ICdieXRlU2tpcCcsXG4gICAgJ3NhbXBsZSB1bml0cyc6ICdzYW1wbGVVbml0cycsXG4gICAgJ3NhbXBsZXVuaXRzJzogJ3NhbXBsZVVuaXRzJyxcbiAgICAnYXhpcyBtaW5zJzogJ2F4aXNNaW5zJyxcbiAgICAnYXhpcyBtYXhzJzogJ2F4aXNNYXhzJyxcbiAgICAnY2VudGVycyc6ICdjZW50ZXJzJywgLy8gTm90IGRpZmZlcmVudCwganVzdCBpbmNsdWRlZCBzbyBpdCBpcyBjbGVhciB3aHkgY2VudGVyaW5ncyBtYXBzIHRvIGNlbnRlcnNcbiAgICAnY2VudGVyaW5ncyc6ICdjZW50ZXJzJyxcbiAgICAnc3BhY2UgZGltZW5zaW9uJzogJ3NwYWNlRGltZW5zaW9uJyxcbiAgICAnc3BhY2UgdW5pdHMnOiAnc3BhY2VVbml0cycsXG4gICAgJ3NwYWNlIG9yaWdpbic6ICdzcGFjZU9yaWdpbicsXG4gICAgJ3NwYWNlIGRpcmVjdGlvbnMnOiAnc3BhY2VEaXJlY3Rpb25zJyxcbiAgICAnbWVhc3VyZW1lbnQgZnJhbWUnOiAnbWVhc3VyZW1lbnRGcmFtZSdcbn07XG52YXIgbWFwSmF2YXNjcmlwdFRvTlJSRFN0YXRpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWQsIG0gPSB7fTtcbiAgZm9yKGlkIGluIG1hcE5SUkRUb0phdmFzY3JpcHRTdGF0aWMpIHtcbiAgICBtW21hcE5SUkRUb0phdmFzY3JpcHRTdGF0aWNbaWRdXSA9IGlkO1xuICB9XG4gIHJldHVybiBtO1xufSgpO1xuZnVuY3Rpb24gbWFwTlJSRFRvSmF2YXNjcmlwdChpZCkge1xuICAgIC8vIEluIGFueSBjYXNlLCB1c2UgdGhlIGxvd2VyIGNhc2UgdmVyc2lvbiBvZiB0aGUgaWRcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgZmllbGRzIGZvciB3aGljaCB3ZSBoYXZlIGFuIGV4cGxpY2l0IEphdmFzY3JpcHQgbmFtZVxuICAgIGlmIChpZCBpbiBtYXBOUlJEVG9KYXZhc2NyaXB0U3RhdGljKSByZXR1cm4gbWFwTlJSRFRvSmF2YXNjcmlwdFN0YXRpY1tpZF07XG4gICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiB0aGUgKGxvd2VyIGNhc2UpIGlkXG4gICAgcmV0dXJuIGlkO1xufVxuZnVuY3Rpb24gbWFwSmF2YXNjcmlwdFRvTlJSRChpZCkge1xuICAgIC8vIEZpbHRlciBvdXQgYW55IGZpZWxkcyBmb3Igd2hpY2ggd2UgaGF2ZSBhbiBleHBsaWNpdCBOUlJEIG5hbWVcbiAgICBpZiAoaWQgaW4gbWFwSmF2YXNjcmlwdFRvTlJSRFN0YXRpYykgcmV0dXJuIG1hcEphdmFzY3JpcHRUb05SUkRTdGF0aWNbaWRdO1xuICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gdGhlIGlkXG4gICAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRJbnRlZ2VyKHN0cikge1xuICAgIHZhciB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbCkpIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBOUlJEIGludGVnZXI6IFwiICsgc3RyKTtcbiAgICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRGbG9hdChzdHIpIHtcbiAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoc3RyLmluZGV4T2YoJ25hbicpPj0wKSByZXR1cm4gTmFOO1xuICAgIGlmIChzdHIuaW5kZXhPZignLWluZicpPj0wKSByZXR1cm4gLUluZmluaXR5O1xuICAgIGlmIChzdHIuaW5kZXhPZignaW5mJyk+PTApIHJldHVybiBJbmZpbml0eTtcbiAgICB2YXIgdmFsID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odmFsKSkgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIE5SUkQgZmxvYXQ6IFwiICsgc3RyKTtcbiAgICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRWZWN0b3Ioc3RyKSB7XG4gICAgaWYgKHN0ciA9PSBcIm5vbmVcIikgcmV0dXJuIG51bGw7XG4gICAgaWYgKHN0ci5sZW5ndGg8MiB8fCBzdHJbMF0hPT1cIihcIiB8fCBzdHJbc3RyLmxlbmd0aC0xXSE9PVwiKVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgTlJSRCB2ZWN0b3I6IFwiICsgc3RyKTtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDEsIC0xKS5zcGxpdChcIixcIikubWFwKHBhcnNlTlJSREZsb2F0KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJEUXVvdGVkU3RyaW5nKHN0cikge1xuICAgIGlmIChsZW5ndGg8MiB8fCBzdHJbMF0hPSdcIicgfHwgc3RyW3N0ci5sZW5ndGgtMV0hPSdcIicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBOUlJEIHF1b3RlZCBzdHJpbmc6IFwiICsgc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zbGljZSgxLCAtMSkucmVwbGFjZSgnXFxcXFwiJywgJ1wiJyk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5SUkRRdW90ZWRTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZSgnXCInLCAnXFxcXFwiJykgKyAnXCInO1xufVxuXG52YXIgd2hpdGVzcGFjZUxpc3RTZXBhcmF0b3IgPSAvWyBcXHRdKy87IC8vIE5vdGUgdGhhdCB0aGlzIGV4Y2x1ZGVzIG90aGVyIHR5cGVzIG9mIHdoaXRlc3BhY2Ugb24gcHVycG9zZSFcbmZ1bmN0aW9uIHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KHN0ciwgcGFyc2VFbGVtZW50KSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCh3aGl0ZXNwYWNlTGlzdFNlcGFyYXRvcikubWFwKHBhcnNlRWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSRFR5cGUoZGVzY3JpcHRvcikge1xuICAgIHN3aXRjaChkZXNjcmlwdG9yLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwic2lnbmVkIGNoYXJcIjpcbiAgICBjYXNlIFwiaW50OFwiOlxuICAgIGNhc2UgXCJpbnQ4X3RcIjpcbiAgICAgICAgcmV0dXJuICdpbnQ4JztcbiAgICBjYXNlIFwidWNoYXJcIjpcbiAgICBjYXNlIFwidW5zaWduZWQgY2hhclwiOlxuICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgIGNhc2UgXCJ1aW50OF90XCI6XG4gICAgICAgIHJldHVybiAndWludDgnO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgIGNhc2UgXCJzaG9ydCBpbnRcIjpcbiAgICBjYXNlIFwic2lnbmVkIHNob3J0XCI6XG4gICAgY2FzZSBcInNpZ25lZCBzaG9ydCBpbnRcIjpcbiAgICBjYXNlIFwiaW50MTZcIjpcbiAgICBjYXNlIFwiaW50MTZfdFwiOlxuICAgICAgICByZXR1cm4gJ2ludDE2JztcbiAgICBjYXNlIFwidXNob3J0XCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIHNob3J0XCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIHNob3J0IGludFwiOlxuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICBjYXNlIFwidWludDE2X3RcIjpcbiAgICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgIGNhc2UgXCJpbnRcIjpcbiAgICBjYXNlIFwic2lnbmVkIGludFwiOlxuICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgIGNhc2UgXCJpbnQzMl90XCI6XG4gICAgICAgIHJldHVybiAnaW50MzInO1xuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIGludFwiOlxuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICBjYXNlIFwidWludDMyX3RcIjpcbiAgICAgICAgcmV0dXJuICd1aW50MzInO1xuICAgIGNhc2UgXCJsb25nbG9uZ1wiOlxuICAgIGNhc2UgXCJsb25nIGxvbmdcIjpcbiAgICBjYXNlIFwibG9uZyBsb25nIGludFwiOlxuICAgIGNhc2UgXCJzaWduZWQgbG9uZyBsb25nXCI6XG4gICAgY2FzZSBcInNpZ25lZCBsb25nIGxvbmcgaW50XCI6XG4gICAgY2FzZSBcImludDY0XCI6XG4gICAgY2FzZSBcImludDY0X3RcIjpcbiAgICAgICAgcmV0dXJuICdpbnQ2NCc7XG4gICAgY2FzZSBcInVsb25nbG9uZ1wiOlxuICAgIGNhc2UgXCJ1bnNpZ25lZCBsb25nIGxvbmdcIjpcbiAgICBjYXNlIFwidW5zaWduZWQgbG9uZyBsb25nIGludFwiOlxuICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICBjYXNlIFwidWludDY0X3RcIjpcbiAgICAgICAgcmV0dXJuICd1aW50NjQnO1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0JztcbiAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIHJldHVybiAnZG91YmxlJztcbiAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgcmV0dXJuICdibG9jayc7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgdHlwZTogXCIgKyBkZXNjcmlwdG9yKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIHN3aXRjaChlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcInJhd1wiOlxuICAgICAgICByZXR1cm4gXCJyYXdcIjtcbiAgICBjYXNlIFwidHh0XCI6XG4gICAgY2FzZSBcInRleHRcIjpcbiAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgcmV0dXJuIFwiYXNjaWlcIjtcbiAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgIHJldHVybiBcImhleFwiO1xuICAgIGNhc2UgXCJnelwiOlxuICAgIGNhc2UgXCJnemlwXCI6XG4gICAgICAgIHJldHVybiBcImd6aXBcIjtcbiAgICBjYXNlIFwiYnoyXCI6XG4gICAgY2FzZSBcImJ6aXAyXCI6XG4gICAgICAgIHJldHVybiBcImJ6aXAyXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgZW5jb2Rpbmc6IFwiICsgZW5jb2RpbmcpO1xuICAgICAgICByZXR1cm4gZW5jb2Rpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRTcGFjZShzcGFjZSkge1xuICAgIHN3aXRjaChzcGFjZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgY2FzZSBcInJhc1wiOlxuICAgICAgICByZXR1cm4gXCJyaWdodC1hbnRlcmlvci1zdXBlcmlvclwiO1xuICAgIGNhc2UgXCJsZWZ0LWFudGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgY2FzZSBcImxhc1wiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LWFudGVyaW9yLXN1cGVyaW9yXCI7XG4gICAgY2FzZSBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgY2FzZSBcImxwc1wiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LXBvc3Rlcmlvci1zdXBlcmlvclwiO1xuIFx0ICBjYXNlIFwicmlnaHQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiOlxuIFx0ICBjYXNlIFwicmFzdFwiOlxuICAgICAgICByZXR1cm4gXCJyaWdodC1hbnRlcmlvci1zdXBlcmlvci10aW1lXCI7XG4gICAgY2FzZSBcImxlZnQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiOlxuICAgIGNhc2UgXCJsYXN0XCI6XG4gICAgICAgIHJldHVybiBcImxlZnQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiO1xuICAgIGNhc2UgXCJsZWZ0LXBvc3Rlcmlvci1zdXBlcmlvci10aW1lXCI6XG4gICAgY2FzZSBcImxwc3RcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1wb3N0ZXJpb3Itc3VwZXJpb3ItdGltZVwiO1xuICAgIGNhc2UgXCJzY2FubmVyLXh5elwiOlxuICAgICAgICByZXR1cm4gXCJzY2FubmVyLXh5elwiO1xuICAgIGNhc2UgXCJzY2FubmVyLXh5ei10aW1lXCI6XG4gICAgICAgIHJldHVybiBcInNjYW5uZXIteHl6LXRpbWVcIjtcbiAgICBjYXNlIFwiM2QtcmlnaHQtaGFuZGVkXCI6XG4gICAgICAgIHJldHVybiBcIjNELXJpZ2h0LWhhbmRlZFwiO1xuICAgIGNhc2UgXCIzZC1sZWZ0LWhhbmRlZFwiOlxuICAgICAgICByZXR1cm4gXCIzRC1sZWZ0LWhhbmRlZFwiO1xuICAgIGNhc2UgXCIzZC1yaWdodC1oYW5kZWQtdGltZVwiOlxuICAgICAgICByZXR1cm4gXCIzRC1yaWdodC1oYW5kZWQtdGltZVwiO1xuICAgIGNhc2UgXCIzZC1sZWZ0LWhhbmRlZC10aW1lXCI6XG4gICAgICAgIHJldHVybiBcIjNELWxlZnQtaGFuZGVkLXRpbWVcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgc3BhY2U6IFwiICsgc3BhY2UpO1xuICAgICAgICByZXR1cm4gc3BhY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRFbmRpYW4oZW5kaWFuKSB7XG4gICAgc3dpdGNoKGVuZGlhbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnbGl0dGxlJzpcbiAgICAgICAgcmV0dXJuICdsaXR0bGUnO1xuICAgIGNhc2UgJ2JpZyc6XG4gICAgICAgIHJldHVybiAnYmlnJztcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCBlbmRpYW5uZXNzOiBcIiArIGVuZGlhbik7XG4gICAgICAgIHJldHVybiBlbmRpYW47XG4gICAgfVxufVxuXG4vLyBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIG5ldmVyIGVuY291bnRlciB0aGUgTElTVCBkYXRhIGZpbGUgc3BlY2lmaWNhdGlvbiBmb3JtYXQsIGFzIHRoaXMgaXMgaGFuZGxlZCBlbHNld2hlcmUuXG52YXIgZGF0YUZpbGVGb3JtYXRSRSA9IC8gKC0/XFxkKykgKC0/XFxkKykgKC0/XFxkKykoPzogKFxcZCspKT8kLztcbmZ1bmN0aW9uIHBhcnNlTlJSRERhdGFGaWxlKGRhdGFGaWxlKSB7XG4gICAgdmFyIG1hdGNoID0gZGF0YUZpbGVGb3JtYXRSRS5leGVjKGRhdGFGaWxlKTtcbiAgICBpZiAobWF0Y2gpIHsgLy8gV2UgaGF2ZSBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uXG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPT0gNSAmJiBtYXRjaFs0XSkgeyAvLyBzdWJkaW0gc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGRhdGFGaWxlLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCksXG4gICAgICAgICAgICAgICAgbWluOiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICBtYXg6IHBhcnNlTlJSREludGVnZXIobWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHBhcnNlTlJSREludGVnZXIobWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIHN1YmRpbTogcGFyc2VOUlJESW50ZWdlcihtYXRjaFs0XSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogZGF0YUZpbGUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgICAgICBtaW46IHBhcnNlTlJSREludGVnZXIobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgIG1heDogcGFyc2VOUlJESW50ZWdlcihtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgc3RlcDogcGFyc2VOUlJESW50ZWdlcihtYXRjaFszXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBKdXN0IGEgZmlsZVxuICAgICAgICByZXR1cm4gZGF0YUZpbGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVOUlJERGF0YUZpbGUoZGF0YUZpbGUpIHtcbiAgICBpZiAoKHR5cGVvZiBkYXRhRmlsZSkgPT0gXCJzdHJpbmdcIiB8fCBkYXRhRmlsZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gZGF0YUZpbGU7XG4gICAgfSBlbHNlIGlmICgnZm9ybWF0JyBpbiBkYXRhRmlsZSAmJiAnbWluJyBpbiBkYXRhRmlsZSAmJiAnbWF4JyBpbiBkYXRhRmlsZSAmJiAnc3RlcCcgaW4gZGF0YUZpbGUpIHtcbiAgICAgICAgaWYgKCdzdWJkaW0nIGluIGRhdGFGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUZpbGUuZm9ybWF0ICsgXCIgXCIgKyBkYXRhRmlsZS5taW4gKyBcIiBcIiArIGRhdGFGaWxlLm1heCArIFwiIFwiICsgZGF0YUZpbGUuc3RlcCArIFwiIFwiICsgZGF0YUZpbGUuc3ViZGltO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFGaWxlLmZvcm1hdCArIFwiIFwiICsgZGF0YUZpbGUubWluICsgXCIgXCIgKyBkYXRhRmlsZS5tYXggKyBcIiBcIiArIGRhdGFGaWxlLnN0ZXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZGF0YSBmaWxlIGZvcm1hdCFcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRDZW50ZXIoY2VudGVyKSB7XG4gICAgc3dpdGNoKGNlbnRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImNlbGxcIjpcbiAgICAgICAgcmV0dXJuIFwiY2VsbFwiO1xuICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICAgIHJldHVybiBcIm5vZGVcIjtcbiAgICBjYXNlIFwiPz8/XCI6XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgY2VudGVyOiBcIiArIGNlbnRlcik7XG4gICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgfVxufVxuXG52YXIgTlJSREtpbmRzID0ge1xuICAgIFwiZG9tYWluXCI6IFwiZG9tYWluXCIsXG4gICAgXCJzcGFjZVwiOiBcInNwYWNlXCIsXG4gICAgXCJ0aW1lXCI6IFwidGltZVwiLFxuICAgIFwibGlzdFwiOiBcImxpc3RcIixcbiAgICBcInBvaW50XCI6IFwicG9pbnRcIixcbiAgICBcInZlY3RvclwiOiBcInZlY3RvclwiLFxuICAgIFwiY292YXJpYW50LXZlY3RvclwiOiBcImNvdmFyaWFudC12ZWN0b3JcIixcbiAgICBcIm5vcm1hbFwiOiBcIm5vcm1hbFwiLFxuICAgIFwic3R1YlwiOiBcInN0dWJcIixcbiAgICBcInNjYWxhclwiOiBcInNjYWxhclwiLFxuICAgIFwiY29tcGxleFwiOiBcImNvbXBsZXhcIixcbiAgICBcIjItdmVjdG9yXCI6IFwiMi12ZWN0b3JcIixcbiAgICBcIjMtY29sb3JcIjogXCIzLWNvbG9yXCIsXG4gICAgXCJyZ2ItY29sb3JcIjogXCJSR0ItY29sb3JcIixcbiAgICBcImhzdi1jb2xvclwiOiBcIkhTVi1jb2xvclwiLFxuICAgIFwieHl6LWNvbG9yXCI6IFwiWFlaLWNvbG9yXCIsXG4gICAgXCI0LWNvbG9yXCI6IFwiNC1jb2xvclwiLFxuICAgIFwicmdiYS1jb2xvclwiOiBcIlJHQkEtY29sb3JcIixcbiAgICBcIjMtdmVjdG9yXCI6IFwiMy12ZWN0b3JcIixcbiAgICBcIjMtZ3JhZGllbnRcIjogXCIzLWdyYWRpZW50XCIsXG4gICAgXCIzLW5vcm1hbFwiOiBcIjMtbm9ybWFsXCIsXG4gICAgXCI0LXZlY3RvclwiOiBcIjQtdmVjdG9yXCIsXG4gICAgXCJxdWF0ZXJuaW9uXCI6IFwicXVhdGVybmlvblwiLFxuICAgIFwiMmQtc3ltbWV0cmljLW1hdHJpeFwiOiBcIjJELXN5bW1ldHJpYy1tYXRyaXhcIixcbiAgICBcIjJkLW1hc2tlZC1zeW1tZXRyaWMtbWF0cml4XCI6IFwiMkQtbWFza2VkLXN5bW1ldHJpYy1tYXRyaXhcIixcbiAgICBcIjJkLW1hdHJpeFwiOiBcIjJELW1hdHJpeFwiLFxuICAgIFwiMmQtbWFza2VkLW1hdHJpeFwiOiBcIjJELW1hc2tlZC1tYXRyaXhcIixcbiAgICBcIjNkLXN5bW1ldHJpYy1tYXRyaXhcIjogXCIzRC1zeW1tZXRyaWMtbWF0cml4XCIsXG4gICAgXCIzZC1tYXNrZWQtc3ltbWV0cmljLW1hdHJpeFwiOiBcIjNELW1hc2tlZC1zeW1tZXRyaWMtbWF0cml4XCIsXG4gICAgXCIzZC1tYXRyaXhcIjogXCIzRC1tYXRyaXhcIixcbiAgICBcIjNkLW1hc2tlZC1tYXRyaXhcIjogXCIzRC1tYXNrZWQtbWF0cml4XCIsXG4gICAgXCI/Pz9cIjogbnVsbCxcbiAgICBcIm5vbmVcIjogbnVsbFxufTtcbmZ1bmN0aW9uIHBhcnNlTlJSREtpbmQoa2luZCkge1xuICAgIHZhciBraW5kTEMgPSBraW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGtpbmRMQyBpbiBOUlJES2luZHMpIHJldHVybiBOUlJES2luZHNba2luZExDXTtcbiAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCBraW5kOiBcIiArIGtpbmQpO1xuICAgIHJldHVybiBraW5kO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVOUlJET3B0aW9uYWwoYSkge1xuICAgIHJldHVybiBhPT09bnVsbCA/IFwiPz8/XCIgOiBhO1xufVxuXG52YXIgc3lzdGVtRW5kaWFubmVzcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDQpLFxuICAgICAgICBpbnRBcnIgPSBuZXcgVWludDMyQXJyYXkoYnVmKSxcbiAgICAgICAgYnl0ZUFyciA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgaW50QXJyWzBdID0gMHgwMTAyMDMwNDtcbiAgICBpZiAoYnl0ZUFyclswXT09MSAmJiBieXRlQXJyWzFdPT0yICYmIGJ5dGVBcnJbMl09PTMgJiYgYnl0ZUFyclszXT09NCkge1xuICAgICAgICByZXR1cm4gJ2JpZyc7XG4gICAgfSBlbHNlIGlmIChieXRlQXJyWzBdPT00ICYmIGJ5dGVBcnJbMV09PTMgJiYgYnl0ZUFyclsyXT09MiAmJiBieXRlQXJyWzNdPT0xKSB7XG4gICAgICAgIHJldHVybiAnbGl0dGxlJztcbiAgICB9XG4gICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIHN5c3RlbSBlbmRpYW5uZXNzIVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufSkoKTtcblxuZnVuY3Rpb24gcGFyc2VOUlJEUmF3RGF0YShidWZmZXIsIHR5cGUsIHNpemVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGksIGFyciwgdmlldywgdG90YWxMZW4gPSAxLCBlbmRpYW5GbGFnO1xuICAgIGZvcihpPTA7IGk8c2l6ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNpemVzW2ldPD0wKSB0aHJvdyBuZXcgRXJyb3IoXCJTaXplcyBzaG91bGQgYmUgYSBsaXN0IG9mIHBvc2l0aXZlICg+MCkgaW50ZWdlcnMhXCIpO1xuICAgICAgICB0b3RhbExlbiAqPSBzaXplc1tpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ2Jsb2NrJykge1xuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBzcGVjaWFsLCBqdXN0IHJldHVybiB0aGUgc2xpY2UgY29udGFpbmluZyBhbGwgYmxvY2tzLlxuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qb3B0aW9ucy5ibG9ja1NpemUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnaW50OCcgfHwgdHlwZSA9PSAndWludDgnIHx8IG9wdGlvbnMuZW5kaWFuID09IHN5c3RlbUVuZGlhbm5lc3MpIHtcbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKSk7XG4gICAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKSk7XG4gICAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjIpKTtcbiAgICAgICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbioyKSk7XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjQpKTtcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio0KSk7XG4gICAgICAgIC8vY2FzZSBcImludDY0XCI6XG4gICAgICAgIC8vICAgIGNoZWNrU2l6ZSg4KTtcbiAgICAgICAgLy8gICAgcmV0dXJuIG5ldyBJbnQ2NEFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjgpKTtcbiAgICAgICAgLy9jYXNlIFwidWludDY0XCI6XG4gICAgICAgIC8vICAgIGNoZWNrU2l6ZSg4KTtcbiAgICAgICAgLy8gICAgcmV0dXJuIG5ldyBVaW50NjRBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio4KSk7XG4gICAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qNCkpO1xuICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBjaGVja1NpemUoOCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio4KSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBOUlJEIHR5cGU6IFwiICsgdHlwZSArIFwiLCByZXR1cm5pbmcgcmF3IGJ1ZmZlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKG9wdGlvbnMuZW5kaWFuKSB7XG4gICAgICAgIGNhc2UgJ2JpZyc6XG4gICAgICAgICAgICBlbmRpYW5GbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGl0dGxlJzpcbiAgICAgICAgICAgIGVuZGlhbkZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBlbmRpYW5uZXNzIGluIE5SUkQgZmlsZTogXCIgKyBvcHRpb25zLmVuZGlhbik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludDhcIjogLy8gTm90ZSB0aGF0IGhlcmUgd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlciwgYXMgdGhlIERhdGFWaWV3LmdldCBtZXRob2RzIHNob3VsZCB0aHJvdyBhbiBleGNlcHRpb24gaWYgd2UgcmVhZCBiZXlvbmQgdGhlIGJ1ZmZlci5cbiAgICAgICAgICAgIGFyciA9IG5ldyBJbnQ4QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRJbnQ4KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldFVpbnQ4KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgSW50MTZBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldEludDE2KGkqMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDE2QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRVaW50MTYoaSoyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IEludDMyQXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRJbnQzMihpKjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQzMkFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0VWludDMyKGkqNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAvL2Nhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAvLyAgICBhcnIgPSBuZXcgSW50NjRBcnJheSh0b3RhbExlbik7XG4gICAgICAgIC8vICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAvLyAgICAgICAgYXJyW2ldID0gdmlldy5nZXRJbnQ2NChpKjgpO1xuICAgICAgICAvLyAgICB9XG4gICAgICAgIC8vICAgIHJldHVybiBhcnI7XG4gICAgICAgIC8vY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAvLyAgICBhcnIgPSBuZXcgVWludDY0QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAvLyAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgLy8gICAgICAgIGFycltpXSA9IHZpZXcuZ2V0VWludDY0KGkqOCk7XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy8gICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgRmxvYXQzMkFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0RmxvYXQzMihpKjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IEZsb2F0NjRBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldEZsb2F0NjQoaSo4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBOUlJEIHR5cGU6IFwiICsgdHlwZSArIFwiLCByZXR1cm5pbmcgcmF3IGJ1ZmZlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2l6ZShzaXplT2ZUeXBlKSB7XG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aDx0b3RhbExlbipzaXplT2ZUeXBlKSB0aHJvdyBuZXcgRXJyb3IoXCJOUlJEIGZpbGUgZG9lcyBub3QgY29udGFpbiBlbm91Z2ggZGF0YSFcIik7XG4gICAgfVxufVxuXG52YXIgd2hpdGVzcGFjZURhdGFWYWx1ZUxpc3RTZXBhcmF0b3JSRSA9IC9bIFxcdFxcblxcclxcdlxcZl0rLztcbmZ1bmN0aW9uIHBhcnNlTlJSRFRleHREYXRhKGJ1ZmZlciwgdHlwZSwgc2l6ZXMpIHtcbiAgICB2YXIgaSwgYnVmOCwgc3RyLCBzdHJMaXN0LCB0b3RhbExlbiA9IDE7XG4gICAgZm9yKGk9MDsgaTxzaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2l6ZXNbaV08PTApIHRocm93IG5ldyBFcnJvcihcIlNpemVzIHNob3VsZCBiZSBhIGxpc3Qgb2YgcG9zaXRpdmUgKD4wKSBpbnRlZ2VycyFcIik7XG4gICAgICAgIHRvdGFsTGVuICo9IHNpemVzW2ldO1xuICAgIH1cbiAgICBidWY4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1ZjgpO1xuICAgIHN0ckxpc3QgPSBzdHIuc3BsaXQod2hpdGVzcGFjZURhdGFWYWx1ZUxpc3RTZXBhcmF0b3JSRSk7XG4gICAgaWYgKHN0ckxpc3QubGVuZ3RoPHRvdGFsTGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBlbm91Z2ggZGF0YSBpbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAoc3RyTGlzdC5sZW5ndGg+dG90YWxMZW4pIHtcbiAgICAgICAgaWYgKHN0ckxpc3RbMF0gPT09ICcnKSBzdHJMaXN0ID0gc3RyTGlzdC5zbGljZSgxKTsgLy8gU3RyaWN0bHkgc3BlYWtpbmcgdGhlIHNwZWMgZG9lc24ndCAoZXhwbGljaXRseSkgYWxsb3cgd2hpdGVzcGFjZSBpbiBmcm9udCBvZiB0aGUgZmlyc3QgbnVtYmVyLCBidXQgbGV0J3MgYmUgbGVuaWVudC5cbiAgICAgICAgc3RyTGlzdCA9IHN0ckxpc3Quc2xpY2UoMCwgdG90YWxMZW4pO1xuICAgIH1cbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgLy9jYXNlIFwiaW50NjRcIjpcbiAgICAvLyAgICByZXR1cm4gbmV3IEludDY0QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIC8vY2FzZSBcInVpbnQ2NFwiOlxuICAgIC8vICAgIHJldHVybiBuZXcgVWludDY0QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRGbG9hdCkpO1xuICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJERmxvYXQpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBOUlJEIHR5cGU6IFwiICsgdHlwZSArIFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbi8vIFRoaXMgQUxXQVlTIHJldHVybnMgYW4gaW50ZWdlciwgb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbmZ1bmN0aW9uIGdldE5SUkRUeXBlU2l6ZSh0eXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgICByZXR1cm4gMTtcbiAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgIHJldHVybiA4O1xuICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGtub3cgdGhlIHNpemUgb2YgTlJSRCB0eXBlOiBcIiArIHR5cGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOUlJEKHJldCkge1xuICAgIC8vIEFsd2F5cyBuZWNlc3NhcnkgZmllbGRzXG4gICAgaWYgKHJldC5kaW1lbnNpb249PT11bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnR5cGU9PT11bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5lbmNvZGluZz09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvZGluZyBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5zaXplcz09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplcyBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU29tZXRpbWVzIG5lY2Vzc2FyeSBmaWVsZHNcbiAgICBpZiAocmV0LnR5cGUgIT0gJ2Jsb2NrJyAmJiByZXQudHlwZSAhPSAnaW50OCcgJiYgcmV0LnR5cGUgIT0gJ3VpbnQ4JyAmJlxuICAgICAgICAgIHJldC5lbmNvZGluZyAhPSAnYXNjaWknICYmIHJldC5lbmRpYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmRpYW5uZXNzIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnR5cGUgPT0gJ2Jsb2NrJyAmJiByZXQuYmxvY2tTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBibG9jayBzaXplIGluIE5SUkQgZmlsZSFcIik7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGRpbWVuc2lvbiBhbmQgcGVyLWF4aXMgZmllbGQgbGVuZ3Roc1xuICAgIGlmIChyZXQuZGltZW5zaW9uID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlplcm8tZGltZW5zaW9uYWwgTlJSRCBmaWxlP1wiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5kaW1lbnNpb24gIT0gcmV0LnNpemVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ3NpemVzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnNwYWNpbmdzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LnNwYWNpbmdzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ3NwYWNpbmdzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnRoaWNrbmVzc2VzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LnRoaWNrbmVzc2VzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ3RoaWNrbmVzc2VzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LmF4aXNNaW5zICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LmF4aXNNaW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ2F4aXMgbWlucycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5heGlzTWF4cyAmJiByZXQuZGltZW5zaW9uICE9IHJldC5heGlzTWF4cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdheGlzIG1heHMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQuY2VudGVycyAmJiByZXQuZGltZW5zaW9uICE9IHJldC5jZW50ZXJzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ2NlbnRlcnMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQubGFiZWxzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LmxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdsYWJlbHMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQudW5pdHMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQudW5pdHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAndW5pdHMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQua2luZHMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQua2luZHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAna2luZHMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfVxuICAgIFxuICAgIC8vIFRPRE86IENoZWNrIHNwYWNlL29yaWVudGF0aW9uIGZpZWxkcy5cbiAgICBcbiAgICAvLyBXZSBzaG91bGQgZWl0aGVyIGhhdmUgaW5saW5lIGRhdGEgb3IgZXh0ZXJuYWwgZGF0YVxuICAgIGlmICgocmV0LmRhdGEgPT09IHVuZGVmaW5lZCB8fCByZXQuZGF0YS5sZW5ndGggPT09IDApICYmIChyZXQuYnVmZmVyID09PSB1bmRlZmluZWQgfHwgcmV0LmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSAmJiByZXQuZGF0YUZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOUlJEIGZpbGUgaGFzIG5laXRoZXIgaW5saW5lIG9yIGV4dGVybmFsIGRhdGEhXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FzdFR5cGVkQXJyYXkoZGF0YSwgdHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoZGF0YSk7XG4gICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShkYXRhKTtcbiAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAvL2Nhc2UgXCJpbnQ2NFwiOlxuICAgIC8vICAgIHJldHVybiBuZXcgSW50NjRBcnJheShkYXRhKTtcbiAgICAvL2Nhc2UgXCJ1aW50NjRcIjpcbiAgICAvLyAgICByZXR1cm4gbmV3IFVpbnQ2NEFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGRhdGEpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYXN0IHRvIE5SUkQgdHlwZTogXCIgKyB0eXBlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRvQnVmZmVyKGRhdGEsIHR5cGUsIGVuZGlhbikge1xuICAgIHZhciBpLCBlbmRpYW5GbGFnLCB2aWV3LCBuYXRpdmVTaXplID0gZ2V0TlJSRFR5cGVTaXplKHR5cGUpLCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YS5sZW5ndGgqbmF0aXZlU2l6ZSk7XG4gICAgc3dpdGNoKGVuZGlhbikge1xuICAgIGNhc2UgJ2JpZyc6XG4gICAgICAgIGVuZGlhbkZsYWcgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGl0dGxlJzpcbiAgICAgICAgZW5kaWFuRmxhZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIGVuZGlhbm5lc3MgaW4gTlJSRCBmaWxlOiBcIiArIGVuZGlhbik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgXCJpbnQ4XCI6IC8vIE5vdGUgdGhhdCBoZXJlIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIHRoZSBzaXplIG9mIHRoZSBidWZmZXIsIGFzIHRoZSBEYXRhVmlldy5nZXQgbWV0aG9kcyBzaG91bGQgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHdlIHJlYWQgYmV5b25kIHRoZSBidWZmZXIuXG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRJbnQ4KGksIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChpLCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50MTYoaSoyLCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQxNihpKjIsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRJbnQzMihpKjQsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKGkqNCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAvL2Nhc2UgXCJpbnQ2NFwiOlxuICAgIC8vICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICB2aWV3LnNldEludDY0KGkqOCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgLy8gICAgfVxuICAgIC8vICAgIHJldHVybiBidWZmZXI7XG4gICAgLy9jYXNlIFwidWludDY0XCI6XG4gICAgLy8gICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgICAgIHZpZXcuc2V0VWludDY0KGkqOCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgLy8gICAgfVxuICAgIC8vICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDMyKGkqNCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDY0KGkqOCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJDYW5ub3Qgc2VyaWFsaXplIE5SUkQgdHlwZTogXCIgKyB0eXBlICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplVG9UZXh0QnVmZmVyKGRhdGEpIHtcbiAgICB2YXIgaSwgc3RycyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCksIHN0ciwgYnVmZmVyLCBhcnI7XG4gICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0cnNbaV0gPSAnJyArIGRhdGFbaV07XG4gICAgfVxuICAgIHN0ciA9IHN0cnMuam9pbihcIiBcIik7XG4gICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHN0ci5sZW5ndGgpO1xuICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgZm9yKGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG4iLCIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMvY29tbW9uJykuYXNzaWduO1xuXG52YXIgZGVmbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xudmFyIGluZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG52YXIgcGFrbyA9IHt9O1xuXG5hc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWtvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnNoIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2c7IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnNoIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG4gIHZhciBkaWN0O1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICAgIGlmICh0eXBlb2YgZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWN0ID0gZGljdGlvbmFyeTtcbiAgICAgIH1cblxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHtcbiAgICAgIHN0YXR1cyA9IGMuWl9PSztcbiAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBubyBtb3JlIGlucHV0IGRhdGEsIHdlIHNob3VsZCBjaGVjayB0aGF0IGludGVybmFsIGluZmxhdGUgYnVmZmVyc1xuICAgIC8vIGFyZSBmbHVzaGVkLiBUaGUgb25seSB3YXkgdG8gZG8gaXQgd2hlbiBhdmFpbF9vdXQgPSAwIC0gcnVuIG9uZSBtb3JlXG4gICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuXG4gICAgLy8gSGVyZSB3ZSBzZXQgZmxhZyB0byBwcm9jZXNzIHRoaXMgZXJyb3IgcHJvcGVybHkuXG4gICAgLy9cbiAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2hcbiAgICAvLyBsb2dpYy5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7XG5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHtcbiAgICBfbW9kZSA9IGMuWl9GSU5JU0g7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoYy5aX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsbGlnbmVkIHN0cmluZ3MgdG8gb25EYXRhXG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB7IHRocm93IGluZmxhdG9yLm1zZzsgfVxuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbmV4cG9ydHMudW5nemlwICA9IGluZmxhdGU7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcnlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIHVzZSBmYWxsYmFjayBmb3IgYmlnIGFycmF5cyB0byBhdm9pZCBzdGFjayBvdmVyZmxvd1xuICBpZiAobGVuIDwgNjU1MzcpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICBzLmRfYnVmID0gcy5saXRfYnVmc2l6ZSA+PiAxO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xuICB9IGNhdGNoIChfKSB7fSBmaW5hbGx5IHtcbiAgICBpZiAoIVN0cmVhbSkgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICB9XG59KSgpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9IEJ1ZmZlci5pc0J1ZmZlcihjaHVuayk7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBidWZmZXJTaGltLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLXN0cmluZy1wcmltaXRpdmUnICk7XG52YXIgaXNOb25OZWdhdGl2ZUludGVnZXIgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tbm9ubmVnYXRpdmUtaW50ZWdlcicgKTtcbnZhciBjZWlsID0gcmVxdWlyZSggJ21hdGgtY2VpbCcgKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCAndXRpbHMtcmVwZWF0LXN0cmluZycgKTtcblxuXG4vLyBDT05TVEFOVFMgLy9cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOyAvLyAyKio1MyAtIDFcblxuXG4vLyBMRUZUIFBBRCAvL1xuXG4vKipcbiogRlVOQ1RJT046IGxwYWQoIHN0ciwgbGVuWywgcGFkXSApXG4qXHRMZWZ0IHBhZHMgYSBzdHJpbmcgc3VjaCB0aGF0IHRoZSBwYWRkZWQgc3RyaW5nIGhhcyBhIGxlbmd0aCBvZiBhdCBsZWFzdCBgbGVuYC5cbipcbiogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byBwYWRcbiogQHBhcmFtIHtOdW1iZXJ9IGxlbiAtIG1pbmltdW0gc3RyaW5nIGxlbmd0aFxuKiBAcGFyYW0ge1N0cmluZ30gW3BhZD0nICddIC0gc3RyaW5nIHVzZWQgdG8gcGFkXG4qIEByZXR1cm5zIHtTdHJpbmd9IHBhZGRlZCBzdHJpbmdcbiovXG5mdW5jdGlvbiBscGFkKCBzdHIsIGxlbiwgcGFkICkge1xuXHR2YXIgbjtcblx0dmFyIHA7XG5cdGlmICggIWlzU3RyaW5nKCBzdHIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZy4gVmFsdWU6IGAnICsgc3RyICsgJ2AuJyApO1xuXHR9XG5cdGlmICggIWlzTm9uTmVnYXRpdmVJbnRlZ2VyKCBsZW4gKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLiBWYWx1ZTogYCcgKyBsZW4gKyAnYC4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMiApIHtcblx0XHRwID0gcGFkO1xuXHRcdGlmICggIWlzU3RyaW5nKCBwICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gVGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZy4gVmFsdWU6IGAnICsgcCArICdgLicgKTtcblx0XHR9XG5cdFx0aWYgKCBwLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gUGFkIHN0cmluZyBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuJyApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRwID0gJyAnO1xuXHR9XG5cdGlmICggbGVuID4gTUFYX1NBRkVfSU5URUdFUiApIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIE91dHB1dCBzdHJpbmcgbGVuZ3RoIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHN0cmluZyBsZW5ndGguJyApO1xuXHR9XG5cdG4gPSAoIGxlbiAtIHN0ci5sZW5ndGggKSAvIHAubGVuZ3RoO1xuXHRpZiAoIG4gPD0gMCApIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cdG4gPSBjZWlsKCBuICk7XG5cdHJldHVybiByZXBlYXQoIHAsIG4gKSArIHN0cjtcbn0gLy8gZW5kIEZVTkNUSU9OIGxwYWQoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBscGFkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1zdHJpbmctcHJpbWl0aXZlJyApO1xudmFyIGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW5vbm5lZ2F0aXZlLWludGVnZXInICk7XG5cblxuLy8gTk9URVMgLy9cblxuLyoqXG4qIFRoZSBhbGdvcml0aG1pYyB0cmljayB1c2VkIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyB0byB0cmVhdCBzdHJpbmcgY29uY2F0ZW5hdGlvbiB0aGUgc2FtZSBhcyBiaW5hcnkgYWRkaXRpb24gKGkuZS4sIGFueSBuYXR1cmFsIG51bWJlciAobm9ubmVnYXRpdmUgaW50ZWdlcikgY2FuIGJlIGV4cHJlc3NlZCBhcyBhIHN1bSBvZiBwb3dlcnMgb2YgdHdvKS5cbipcbiogRm9yIGV4YW1wbGUsXG4qXG4qICBuID0gMTAgPT4gMTAxMCA9PiAyXjMgKyAyXjAgKyAyXjEgKyAyXjBcbipcbiogV2UgY2FuIHByb2R1Y2UgYSAxMC1yZXBlYXQgc3RyaW5nIGJ5IFwiYWRkaW5nXCIgdGhlIHJlc3VsdHMgb2YgYSA4LXJlcGVhdCBzdHJpbmcgYW5kIGEgMi1yZXBlYXQgc3RyaW5nLlxuKlxuKiBUaGUgaW1wbGVtZW50YXRpb24gaXMgdGhlbiBhcyBmb2xsb3dzOlxuKiAgOiBMZXQgYHNgIGJlIHRoZSBzdHJpbmcgdG8gYmUgcmVwZWF0ZWQgYW5kIGBvYCBiZSBhbiBvdXRwdXQgc3RyaW5nLlxuKiAgMCkgSW5pdGlhbGl6ZSBhbiBvdXRwdXQgc3RyaW5nIGBvYC5cbiogIDEpIENoZWNrIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGBzYCBzdHJpbmcgc2hvdWxkIGJlIFwiYWRkZWRcIiB0byB0aGUgb3V0cHV0IFwidG90YWxcIi5cbiogICAgIC0gaWYgdGhlIGJpdCBpcyBhIG9uZSwgYWRkXG4qICAgICAtIG90aGVyd2lzZSwgbW92ZSBvblxuKiAgMikgRG91YmxlIHRoZSBzdHJpbmcgYHNgIGJ5IGFkZGluZyBgc2AgdG8gYHNgLlxuKiAgMykgUmlnaHQtc2hpZnQgdGhlIGJpdHMgb2YgYG5gLlxuKiAgNCkgQ2hlY2sgaWYgd2UgaGF2ZSBzaGlmdGVkIG9mZiBhbGwgYml0cy5cbiogICAgIC0gaWYgeWVzLCBkb25lLlxuKiAgICAgLSBvdGhlcndpc2UsIG1vdmUgb25cbiogIDUpIFJlcGVhdCAxLTQuXG4qXG4qIFRoZSByZXN1bHQgaXMgdGhhdCwgYXMgdGhlIHN0cmluZyBpcyByZXBlYXRlZCwgd2UgY29udGludWFsbHkgY2hlY2sgdG8gc2VlIGlmIHRoZSBkb3VibGVkIHN0cmluZyBpcyBvbmUgd2hpY2ggd2Ugd2FudCB0byBhZGQgdG8gb3VyIFwidG90YWxcIi5cbipcbiogVGhlIGFsZ29yaXRobSBydW5zIGluIE8obG9nXzIobikpIGNvbXBhcmVkIHRvIE8obikuXG4qL1xuXG5cbi8vIENPTlNUQU5UUyAvL1xuXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7IC8vIDIqKjUzIC0gMVxuXG5cbi8vIFJFUEVBVCAvL1xuXG4vKipcbiogRlVOQ1RJT046IHJlcGVhdCggc3RyLCBuIClcbipcdFJlcGVhdHMgYSBzdHJpbmcgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzIGFuZCByZXR1cm5zIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0LlxuKlxuKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHJlcGVhdFxuKiBAcGFyYW0ge051bWJlcn0gbiAtIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZ1xuKiBAcmV0dXJucyB7U3RyaW5nfVxuKi9cbmZ1bmN0aW9uIHJlcGVhdCggc3RyLCBuICkge1xuXHR2YXIgcnB0O1xuXHR2YXIgY250O1xuXHRpZiAoICFpc1N0cmluZyggc3RyICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcuIFZhbHVlOiBgJyArIHN0ciArICdgLicgKTtcblx0fVxuXHRpZiAoICFpc05vbk5lZ2F0aXZlSW50ZWdlciggbiApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXIuIFZhbHVlOiBgJyArIG4gKyAnYC4nICk7XG5cdH1cblx0aWYgKCBzdHIubGVuZ3RoID09PSAwIHx8IG4gPT09IDAgKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdC8vIENoZWNrIHRoYXQgb3V0cHV0IHN0cmluZyB3aWxsIG5vdCBleGNlZWQgdGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aDpcblx0aWYgKCBzdHIubGVuZ3RoICogbiA+IE1BWF9TQUZFX0lOVEVHRVIgKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBPdXRwdXQgc3RyaW5nIGxlbmd0aCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzdHJpbmcgbGVuZ3RoLicgKTtcblx0fVxuXHRycHQgPSAnJztcblx0Y250ID0gbjtcblx0Zm9yKCA7IDsgKSB7XG5cdFx0Ly8gSWYgdGhlIGNvdW50IGlzIG9kZCwgYXBwZW5kIHRoZSBjdXJyZW50IGNvbmNhdGVuYXRlZCBzdHJpbmc6XG5cdFx0aWYgKCAoY250JjEpID09PSAxICkge1xuXHRcdFx0cnB0ICs9IHN0cjtcblx0XHR9XG5cdFx0Ly8gUmlnaHQtc2hpZnQgdGhlIGJpdHM6XG5cdFx0Y250ID4+Pj0gMTtcblx0XHRpZiAoIGNudCA9PT0gMCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvLyBEb3VibGUgdGhlIHN0cmluZzpcblx0XHRzdHIgKz0gc3RyO1xuXHR9XG5cdHJldHVybiBycHQ7XG59IC8vIGVuZCBGVU5DVElPTiByZXBlYXQoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSByZXBlYXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLXN0cmluZy1wcmltaXRpdmUnICk7XG52YXIgaXNOb25OZWdhdGl2ZUludGVnZXIgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tbm9ubmVnYXRpdmUtaW50ZWdlcicgKTtcbnZhciBjZWlsID0gcmVxdWlyZSggJ21hdGgtY2VpbCcgKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCAndXRpbHMtcmVwZWF0LXN0cmluZycgKTtcblxuXG4vLyBDT05TVEFOVFMgLy9cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOyAvLyAyKio1MyAtIDFcblxuXG4vLyBSSUdIVCBQQUQgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBycGFkKCBzdHIsIGxlblssIHBhZF0gKVxuKlx0UmlnaHQgcGFkcyBhIHN0cmluZyBzdWNoIHRoYXQgdGhlIHBhZGRlZCBzdHJpbmcgaGFzIGEgbGVuZ3RoIG9mIGF0IGxlYXN0IGBsZW5gLlxuKlxuKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHBhZFxuKiBAcGFyYW0ge051bWJlcn0gbGVuIC0gbWluaW11bSBzdHJpbmcgbGVuZ3RoXG4qIEBwYXJhbSB7U3RyaW5nfSBbcGFkPScgJ10gLSBzdHJpbmcgdXNlZCB0byBwYWRcbiogQHJldHVybnMge1N0cmluZ30gcGFkZGVkIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIHJwYWQoIHN0ciwgbGVuLCBwYWQgKSB7XG5cdHZhciBuO1xuXHR2YXIgcDtcblx0aWYgKCAhaXNTdHJpbmcoIHN0ciApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLiBWYWx1ZTogYCcgKyBzdHIgKyAnYC4nICk7XG5cdH1cblx0aWYgKCAhaXNOb25OZWdhdGl2ZUludGVnZXIoIGxlbiApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXIuIFZhbHVlOiBgJyArIGxlbiArICdgLicgKTtcblx0fVxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAyICkge1xuXHRcdHAgPSBwYWQ7XG5cdFx0aWYgKCAhaXNTdHJpbmcoIHAgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBUaGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLiBWYWx1ZTogYCcgKyBwICsgJ2AuJyApO1xuXHRcdH1cblx0XHRpZiAoIHAubGVuZ3RoID09PSAwICkge1xuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBQYWQgc3RyaW5nIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZy4nICk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHAgPSAnICc7XG5cdH1cblx0aWYgKCBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSICkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gT3V0cHV0IHN0cmluZyBsZW5ndGggZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc3RyaW5nIGxlbmd0aC4nICk7XG5cdH1cblx0biA9ICggbGVuIC0gc3RyLmxlbmd0aCApIC8gcC5sZW5ndGg7XG5cdGlmICggbiA8PSAwICkge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblx0biA9IGNlaWwoIG4gKTtcblx0cmV0dXJuIHN0ciArIHJlcGVhdCggcCwgbiApO1xufSAvLyBlbmQgRlVOQ1RJT04gcnBhZCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJwYWQ7XG4iLCIvKipcbipcbipcdFZBTElEQVRFOiBpbnRlZ2VyXG4qXG4qXG4qXHRERVNDUklQVElPTjpcbipcdFx0LSBWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW51bWJlcicgKTtcblxuXG4vLyBJU0lOVEVHRVIgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBpc0ludGVnZXIoIHZhbHVlIClcbipcdFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIGJlIHZhbGlkYXRlZFxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gaW50ZWdlclxuKi9cbmZ1bmN0aW9uIGlzSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiBpc051bWJlciggdmFsdWUgKSAmJiB2YWx1ZSUxID09PSAwO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNJbnRlZ2VyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyO1xuIiwiLyoqXG4qXG4qXHRWQUxJREFURTogbm9ubmVnYXRpdmUtaW50ZWdlclxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gVmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNS4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTUuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1pbnRlZ2VyJyApO1xuXG5cbi8vIElTIE5PTk5FR0FUSVZFIElOVEVHRVIgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBpc05vbk5lZ2F0aXZlSW50ZWdlciggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gYmUgdmFsaWRhdGVkXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIG5vbm5lZ2F0aXZlIGludGVnZXJcbiovXG5mdW5jdGlvbiBpc05vbk5lZ2F0aXZlSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiBpc0ludGVnZXIoIHZhbHVlICkgJiYgdmFsdWUgPj0gMDtcbn0gLy8gZW5kIEZVTkNUSU9OIGlzTm9uTmVnYXRpdmVJbnRlZ2VyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb25OZWdhdGl2ZUludGVnZXI7XG4iLCIvKipcbipcbipcdFZBTElEQVRFOiBudW1iZXJcbipcbipcbipcdERFU0NSSVBUSU9OOlxuKlx0XHQtIFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBGVU5DVElPTjogaXNOdW1iZXIoIHZhbHVlIClcbipcdFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gYmUgdmFsaWRhdGVkXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhIG51bWJlclxuKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKCB2YWx1ZSApIHtcblx0cmV0dXJuICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIHZhbHVlICkgPT09ICdbb2JqZWN0IE51bWJlcl0nICkgJiYgdmFsdWUudmFsdWVPZigpID09PSB2YWx1ZS52YWx1ZU9mKCk7XG59IC8vIGVuZCBGVU5DVElPTiBpc051bWJlcigpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyBwcmltaXRpdmUuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byB0ZXN0XG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyBwcmltaXRpdmVcbiovXG5mdW5jdGlvbiBpc1N0cmluZyggdmFsdWUgKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNTdHJpbmcoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiYW1pLmpzXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuMC4xNi1kZXZcIixcbiAgXCJtYWluXCI6IFwibGliL2FtaS5qc1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImFtaVwiLFxuICAgIFwiYW1pLmpzXCIsXG4gICAgXCJ0aHJlZS5qc1wiLFxuICAgIFwid2ViZ2xcIixcbiAgICBcImRpY29tXCIsXG4gICAgXCJuaWZ0aVwiLFxuICAgIFwiYXdlc29tZVwiLFxuICAgIFwibWVkaWNhbFwiLFxuICAgIFwiaW1hZ2luZ1wiLFxuICAgIFwieHRrXCIsXG4gICAgXCJucnJkXCIsXG4gICAgXCJ2dGtcIixcbiAgICBcInN0bFwiLFxuICAgIFwidHJrXCJcbiAgXSxcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIk5pY29sYXMgUmFubm91XCIsXG4gICAgXCJlbWFpbFwiOiBcIm5pY29sYXNAZXVuYXRlLmNoXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2V1bmF0ZS5jaFwiXG4gIH0sXG4gIFwibGljZW5zZVwiOiBcIkFwYWNoZS0yLjBcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZm5uZHNjLmdpdGh1Yi5pby9hbWlcIlxuICB9LFxuICBcImNvbmZpZ1wiOiB7XG4gICAgXCJ0aHJlZVZlcnNpb25cIjogXCJyODNcIixcbiAgICBcImFtaUNETlwiOiBcImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2FtaS5qcy9cIixcbiAgICBcImdhS2V5XCI6IFwiVUEtMzkzMDMwMjItM1wiLFxuICAgIFwidHJhbnNmb3Jtc1wiOiBcIi10IFtiYWJlbGlmeSAtLXByZXNldHMgWyBlczIwMTUgXSBdXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZGljb20tcGFyc2VyXCI6IFwiMS43LjNcIixcbiAgICBcImltYWdlLUpQRUcyMDAwXCI6IFwiT0hJRi9pbWFnZS1KUEVHMjAwMCNtYXN0ZXJcIixcbiAgICBcImpwZWctbG9zc2xlc3MtZGVjb2Rlci1qc1wiOiBcIjEuMi4zXCIsXG4gICAgXCJtYXRoLWZsb2F0MzItdG8tYmluYXJ5LXN0cmluZ1wiOiBcIl4xLjAuMFwiLFxuICAgIFwibmlmdGktcmVhZGVyLWpzXCI6IFwidjAuNS4zXCIsXG4gICAgXCJucnJkLWpzXCI6IFwiXjAuMi4xXCIsXG4gICAgXCJwYWtvXCI6IFwiMS4wLjFcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiZGlzdDpwcmVwYXJlXCI6IFwibm9kZSAuL3NjcmlwdHMvJG5wbV9wYWNrYWdlX2NvbmZpZ19tb2RlLmpzIC0tZGlzdFwiLFxuICAgIFwiZGlzdDp3YXRjaEFtaVwiOiBcIndhdGNoaWZ5IC1kIHNyYy9hbWkgJG5wbV9wYWNrYWdlX2NvbmZpZ190cmFuc2Zvcm1zIC0tc3RhbmRhbG9uZSBBTUkgLW8gZGlzdC9idWlsZC9hbWkuanMgLXZcIixcbiAgICBcImRpc3Q6d2F0Y2hcIjogXCJ3YXRjaGlmeSAkbnBtX3BhY2thZ2VfY29uZmlnX3RhcmdldCAtZCAkbnBtX3BhY2thZ2VfY29uZmlnX3RyYW5zZm9ybXMgLW8gZGlzdC8kbnBtX3BhY2thZ2VfY29uZmlnX3RhcmdldCAtdlwiLFxuICAgIFwiZGlzdFwiOiBcIm5wbSBydW4gZGlzdDpwcmVwYXJlIC0tYW1pLmpzOm1vZGU9JG5wbV9wYWNrYWdlX2NvbmZpZ19tb2RlICYmIChsaXZlLXNlcnZlciBkaXN0IC0tb3Blbj0kbnBtX3BhY2thZ2VfY29uZmlnX29wZW4gJiBucG0gcnVuIGRpc3Q6d2F0Y2ggLS1hbWkuanM6dGFyZ2V0PSRucG1fcGFja2FnZV9jb25maWdfdGFyZ2V0KVwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIm5wbSBydW4gY2xlYW4gJiYgbm9kZSAuL3NjcmlwdHMvcm91dGVyLmpzIGV4YW1wbGVzIFwiLFxuICAgIFwibGVzc29uXCI6IFwibnBtIHJ1biBjbGVhbiAmJiBta2RpciBkaXN0L2J1aWxkICYmIHRvdWNoIGRpc3QvYnVpbGQvYW1pLmpzICYmIG5vZGUgLi9zY3JpcHRzL3JvdXRlci5qcyBsZXNzb25zIFwiLFxuICAgIFwiZGVtb1wiOiBcIm5vZGUgLi9zY3JpcHRzL2xlc3NvbnMuanMgLS1kZW1vXCIsXG4gICAgXCJsaW50XCI6IFwiZXNsaW50ICoqLyouanMgLS1xdWlldFwiLFxuICAgIFwiYnVpbGQ6ZXhhbXBsZXNcIjogXCJucG0gcnVuIGRpc3Q6cHJlcGFyZSAtLWFtaS5qczptb2RlPWV4YW1wbGVzICYmIGZpbmQgZXhhbXBsZXMgLW5hbWUgJyouanMnIC1wcmludDAgfCB4YXJncyAtMCAtbjEgLUl7fSBiYXNoIC1jIFxcXCJlY2hvIEJ1aWxkaW5nIHt9OyBicm93c2VyaWZ5IHt9IC1kIC12ICRucG1fcGFja2FnZV9jb25maWdfdHJhbnNmb3JtcyA+IGRpc3Qve30gXFxcIlwiLFxuICAgIFwiYnVpbGQ6YW1pXCI6IFwiYnJvd3NlcmlmeSBzcmMvYW1pLmpzIC1kIC12ICRucG1fcGFja2FnZV9jb25maWdfdHJhbnNmb3JtcyAtLXN0YW5kYWxvbmUgQU1JID4gYnVpbGQvYW1pLmpzICYmIHVnbGlmeWpzIGJ1aWxkL2FtaS5qcyAtbyBidWlsZC9hbWkubWluLmpzXCIsXG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gY2xlYW4gJiYgY3AgaW5kZXguaHRtbCBkaXN0L2luZGV4Lmh0bWwgJiYgbnBtIHJ1biBidWlsZDpleGFtcGxlcyAmJiBucG0gcnVuIGRvY1wiLFxuICAgIFwiYnVpbGQtY2pzXCI6IFwicmltcmFmIGxpYiAmJiBjcm9zcy1lbnYgQkFCRUxfRU5WPWNqcyBiYWJlbCAuL3NyYyAtZCBsaWJcIixcbiAgICBcImNsZWFuXCI6IFwicm0gLXJmIGRpc3QvKlwiLFxuICAgIFwidGVzdFwiOiBcImthcm1hIHN0YXJ0XCIsXG4gICAgXCJkb2NcIjogXCJqc2RvYyAtcCAtciAtUiBSRUFETUUubWQgLWMganNkb2MuY29uZiAtZCBkaXN0L2RvYyBzcmNcIixcbiAgICBcImFtaVwiOiBcIm5wbSBydW4gbGludCAmJiBucG0gcnVuIGRlbW8gJiYgbnBtIHJ1biBidWlsZDphbWkgJiYgbnBtIHJ1biB0ZXN0XCIsXG4gICAgXCJkZXBsb3lcIjogXCJucG0gcnVuIGJ1aWxkICYmIGdoLXBhZ2VzIC1kIGRpc3RcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJiYWJlbC1jbGlcIjogXCJsYXRlc3RcIixcbiAgICBcImJhYmVsLXBsdWdpbi1hZGQtbW9kdWxlLWV4cG9ydHNcIjogXCJeMC4yLjFcIixcbiAgICBcImJhYmVsLXBvbHlmaWxsXCI6IFwiXjYuMTMuMFwiLFxuICAgIFwiYmFiZWwtcHJlc2V0LWVzMjAxNVwiOiBcIl42LjEzLjJcIixcbiAgICBcImJhYmVsaWZ5XCI6IFwiNy4zLjBcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTMuMS4wXCIsXG4gICAgXCJjcm9zcy1lbnZcIjogXCJeMy4yLjNcIixcbiAgICBcImVzbGludFwiOiBcImxhdGVzdFwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy1nb29nbGVcIjogXCJsYXRlc3RcIixcbiAgICBcImdoLXBhZ2VzXCI6IFwibGF0ZXN0XCIsXG4gICAgXCJnbHNsaWZ5XCI6IFwiNS4xLjBcIixcbiAgICBcImphc21pbmUtY29yZVwiOiBcImxhdGVzdFwiLFxuICAgIFwianNkb2NcIjogXCJqc2RvYzMvanNkb2MjbWFzdGVyXCIsXG4gICAgXCJrYXJtYVwiOiBcImxhdGVzdFwiLFxuICAgIFwia2FybWEtYnJvd3NlcmlmeVwiOiBcImxhdGVzdFwiLFxuICAgIFwia2FybWEtamFzbWluZVwiOiBcImxhdGVzdFwiLFxuICAgIFwia2FybWEtcGhhbnRvbWpzLWxhdW5jaGVyXCI6IFwiMS4wLjRcIixcbiAgICBcImthcm1hLXNpbm9uXCI6IFwiXjEuMC41XCIsXG4gICAgXCJrYXJtYS1zcGVjLXJlcG9ydGVyXCI6IFwibGF0ZXN0XCIsXG4gICAgXCJsaXZlLXNlcnZlclwiOiBcIl4xLjEuMFwiLFxuICAgIFwicGhhbnRvbWpzLXByZWJ1aWx0XCI6IFwiMi4xLjE0XCIsXG4gICAgXCJyaW1yYWZcIjogXCJeMi42LjFcIixcbiAgICBcInNoZWxsanNcIjogXCJsYXRlc3RcIixcbiAgICBcInNpbm9uXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCJeMi43LjNcIixcbiAgICBcIndhdGNoaWZ5XCI6IFwiMy43LjBcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49Ni45LjBcIlxuICB9LFxuICBcImJyb3dzZXJpZnlcIjoge1xuICAgIFwidHJhbnNmb3JtXCI6IFtcbiAgICAgIFwiYmFiZWxpZnlcIlxuICAgIF1cbiAgfVxufVxuIiwiaW1wb3J0IENhbWVyYXMgZnJvbSAnLi9jYW1lcmFzL2NhbWVyYXMnO1xuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4vY29udHJvbHMvY29udHJvbHMnO1xuaW1wb3J0IENvcmUgZnJvbSAnLi9jb3JlL2NvcmUnO1xuaW1wb3J0IEdlb21ldHJpZXMgZnJvbSAnLi9nZW9tZXRyaWVzL2dlb21ldHJpZXMnO1xuaW1wb3J0IEhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzL2hlbHBlcnMnO1xuaW1wb3J0IExvYWRlcnMgZnJvbSAnLi9sb2FkZXJzL2xvYWRlcnMnO1xuaW1wb3J0IE1vZGVscyBmcm9tICcuL21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IFBhcnNlcnMgZnJvbSAnLi9wYXJzZXJzL3BhcnNlcnMnO1xuaW1wb3J0IFNoYWRlcnMgZnJvbSAnLi9zaGFkZXJzL3NoYWRlcnMnO1xuaW1wb3J0IFdpZGdldHMgZnJvbSAnLi93aWRnZXRzL3dpZGdldHMnO1xuXG5jb25zdCBwY2tnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbmV4cG9ydCBkZWZhdWx0e1xuICBDYW1lcmFzLFxuICBDb250cm9scyxcbiAgQ29yZSxcbiAgR2VvbWV0cmllcyxcbiAgSGVscGVycyxcbiAgTG9hZGVycyxcbiAgTW9kZWxzLFxuICBQYXJzZXJzLFxuICBTaGFkZXJzLFxuICBXaWRnZXRzLFxufTtcblxud2luZG93LmNvbnNvbGUubG9nKGBBTUkgJHtwY2tnLnZlcnNpb259ICggVGhyZWVKUyAke3Bja2cuY29uZmlnLnRocmVlVmVyc2lvbn0pYCk7XG4iLCJpbXBvcnQgT3J0aG9ncmFwaGljIGZyb20gJy4vY2FtZXJhcy5vcnRob2dyYXBoaWMnO1xuXG4vKipcbiAqIEBtb2R1bGUgY2FtZXJhc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIE9ydGhvZ3JhcGhpYyxcbn07XG4iLCJpbXBvcnQgSW50ZXJzZWN0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuaW50ZXJzZWN0aW9ucyc7XG5pbXBvcnQgVmFsaWRhdG9ycyBmcm9tICcuLi9jb3JlL2NvcmUudmFsaWRhdG9ycyc7XG5cbi8qKlxuICogT3J0aG9ncmFwaGljIGNhbWVyYSBmcm9tIFRIUkVFLkpTIHdpdGggc29tZSBleHRyYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb25hbGl0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvL1xuICogLy9cbiAqXG4gKiBAbW9kdWxlIGNhbWVyYXMvb3J0aG9ncmFwaGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYXNPcnRob2dyYXBoaWMgZXh0ZW5kcyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEge1xuICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcikge1xuICAgIHN1cGVyKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKTtcblxuICAgIHRoaXMuX2Zyb250ID0gbnVsbDtcbiAgICB0aGlzLl9iYWNrID0gbnVsbDtcblxuICAgIHRoaXMuX2RpcmVjdGlvbnMgPSBbXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSksXG4gICAgICBdO1xuXG4gICAgdGhpcy5fZGlyZWN0aW9uc0xhYmVsID0gW1xuICAgICAgJ0EnLCAnUCcsIC8vIFRPUC9CT1RUT01cbiAgICAgICdMJywgJ1InLCAvLyBMRUZUL1JJR0hUXG4gICAgICAnSScsICdTJywgLy8gRlJPTS9UT1xuICAgIF07XG5cbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdkZWZhdWx0JztcbiAgICB0aGlzLl9jb252ZW50aW9uID0gJ3JhZGlvJztcbiAgICB0aGlzLl9zdGFja09yaWVudGF0aW9uID0gMDtcblxuICAgIHRoaXMuX3JpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLl91cCA9IG51bGw7XG4gICAgdGhpcy5fZGlyZWN0aW9uID0gbnVsbDtcblxuICAgIHRoaXMuX2NvbnRyb2xzID0gbnVsbDtcbiAgICB0aGlzLl9ib3ggPSBudWxsO1xuICAgIHRoaXMuX2NhbnZhcyA9IHtcbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsLFxuICAgIH07XG5cbiAgICB0aGlzLl9mcm9tRnJvbnQgPSB0cnVlO1xuICAgIHRoaXMuX2FuZ2xlID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIG9ydGhvZ3JhcGhpYyBjYW1lcmEgdmFyaWFibGVzXG4gICAqL1xuICBpbml0KHhDb3NpbmUsIHlDb3NpbmUsIHpDb3NpbmUsIGNvbnRyb2xzLCBib3gsIGNhbnZhcykge1xuICAgIC8vIERFUFJFQ0FURURcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgY2FtZXJhcy5vcnRob2dyYXBoaWMuaW5pdCguLi4pIGlzIGRlcHJlY2F0ZWQuXG4gICAgICBVc2UgLmNvc2luZXMsIC5jb250cm9scywgLmJveCBhbmQgLmNhbnZhcyBpbnN0ZWFkLmApO1xuXG4gICAgLy9cbiAgICBpZiAoIShWYWxpZGF0b3JzLnZlY3RvcjMoeENvc2luZSkgJiZcbiAgICAgIFZhbGlkYXRvcnMudmVjdG9yMyh5Q29zaW5lKSAmJlxuICAgICAgVmFsaWRhdG9ycy52ZWN0b3IzKHpDb3NpbmUpICYmXG4gICAgICBWYWxpZGF0b3JzLmJveChib3gpICYmXG4gICAgICBjb250cm9scykpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBpbnB1dCBwcm92aWRlZC4nKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3JpZ2h0ID0geENvc2luZTtcbiAgICB0aGlzLl91cCA9IHRoaXMuX2FkanVzdFRvcERpcmVjdGlvbih4Q29zaW5lLCB5Q29zaW5lKTtcbiAgICB0aGlzLl9kaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyh0aGlzLl9yaWdodCwgdGhpcy5fdXApO1xuICAgIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XG4gICAgdGhpcy5fYm94ID0gYm94O1xuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcblxuICAgIGxldCByYXkgPSB7XG4gICAgICBwb3NpdGlvbjogdGhpcy5fYm94LmNlbnRlcixcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5fZGlyZWN0aW9uLFxuICAgIH07XG5cbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9XG4gICAgICB0aGlzLl9vcmRlckludGVyc2VjdGlvbnMoXG4gICAgICAgIEludGVyc2VjdGlvbnMucmF5Qm94KHJheSwgdGhpcy5fYm94KSxcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICB0aGlzLl9mcm9udCA9IGludGVyc2VjdGlvbnNbMF07XG4gICAgdGhpcy5fYmFjayA9IGludGVyc2VjdGlvbnNbMV07XG5cbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICB0aGlzLnVwLnNldCh0aGlzLl91cC54LCB0aGlzLl91cC55LCB0aGlzLl91cC56KTtcbiAgICB0aGlzLl91cGRhdGVDYW52YXMoKTtcbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldCh0aGlzLl9mcm9udCwgdGhpcy5fYmFjayk7XG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgLy8gaHR0cDovL3d3dy5ncmFoYW13aWRlbWFuLmNvbS9ndy9icmFpbi9vcmllbnRhdGlvbi9vcmllbnR0ZXJtcy5odG1cbiAgICAvLyBkbyBtYWdpY3MgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uIGFuZCBjb252ZW50aW9uXG4gICAgLy8gYWxzbyBuZWVkcyBhIGRlZmF1bHQgbW9kZVxuXG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSAnZGVmYXVsdCcpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fZ2V0TWF4SW5kZXgodGhpcy5fZGlyZWN0aW9uc1syXSkpIHtcblxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnc2FnaXR0YWwnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdjb3JvbmFsJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnYXhpYWwnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnZnJlZSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSAnZnJlZScpIHtcbiAgICAgIHRoaXMuX3JpZ2h0ID0gdGhpcy5fZGlyZWN0aW9uc1swXTtcbiAgICAgIHRoaXMuX3VwID0gdGhpcy5fZGlyZWN0aW9uc1sxXTtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbnNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsZWZ0SW5kZXggPSB0aGlzLmxlZnREaXJlY3Rpb24oKTtcbiAgICAgIGxldCBsZWZ0RGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uc1tsZWZ0SW5kZXhdO1xuICAgICAgbGV0IHBvc3RlcmlvckluZGV4ID0gdGhpcy5wb3N0ZXJpb3JEaXJlY3Rpb24oKTtcbiAgICAgIGxldCBwb3N0ZXJpb3JEaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb25zW3Bvc3RlcmlvckluZGV4XTtcbiAgICAgIGxldCBzdXBlcmlvckluZGV4ID0gdGhpcy5zdXBlcmlvckRpcmVjdGlvbigpO1xuICAgICAgbGV0IHN1cGVyaW9yRGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uc1tzdXBlcmlvckluZGV4XTtcblxuICAgICAgaWYgKHRoaXMuX2NvbnZlbnRpb24gPT09ICdyYWRpbycpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuX29yaWVudGF0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2F4aWFsJzpcbiAgICAgICAgICAgICAgLy8gdXAgdmVjdG9yIGlzICdhbnRlcmlvcidcbiAgICAgICAgICAgICAgaWYgKHBvc3RlcmlvckRpcmVjdGlvbi55ID4gMCkge1xuICAgICAgICAgICAgICAgIHBvc3RlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyBzdXBlcmlvclxuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gbGVmdERpcmVjdGlvbjsgLy8gZG9lcyBub3QgbWF0dGVyIHJpZ2h0L2xlZnRcbiAgICAgICAgICAgICAgdGhpcy5fdXAgPSBwb3N0ZXJpb3JEaXJlY3Rpb247XG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHN1cGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY29yb25hbCc6XG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnc3VwZXJpb3InXG4gICAgICAgICAgICAgIGlmIChzdXBlcmlvckRpcmVjdGlvbi56IDwgMCkge1xuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIHBvc3RlcmlvclxuICAgICAgICAgICAgICBpZiAocG9zdGVyaW9yRGlyZWN0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcG9zdGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSBsZWZ0RGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxuICAgICAgICAgICAgICB0aGlzLl91cCA9IHN1cGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBwb3N0ZXJpb3JEaXJlY3Rpb247XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzYWdpdHRhbCc6XG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnc3VwZXJpb3InXG4gICAgICAgICAgICAgIGlmIChzdXBlcmlvckRpcmVjdGlvbi56IDwgMCkge1xuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIHJpZ2h0XG4gICAgICAgICAgICAgIGlmIChsZWZ0RGlyZWN0aW9uLnggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGVmdERpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcG9zdGVyaW9yRGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxuICAgICAgICAgICAgICB0aGlzLl91cCA9IHN1cGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBsZWZ0RGlyZWN0aW9uO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYFwiJHt0aGlzLl9vcmllbnRhdGlvbn1cIiBvcmllbnRhdGlvbiBpcyBub3QgdmFsaWQuXG4gICAgICAgICAgICAgICAgKGNob2ljZXM6IGF4aWFsLCBjb3JvbmFsLCBzYWdpdHRhbClgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbnZlbnRpb24gPT09ICduZXVybycpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuX29yaWVudGF0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2F4aWFsJzpcbiAgICAgICAgICAgICAgLy8gdXAgdmVjdG9yIGlzICdhbnRlcmlvcidcbiAgICAgICAgICAgICAgaWYgKHBvc3RlcmlvckRpcmVjdGlvbi55ID4gMCkge1xuICAgICAgICAgICAgICAgIHBvc3RlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyBpbmZlcmlvclxuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA+IDApIHtcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gbGVmdERpcmVjdGlvbjsgLy8gZG9lcyBub3QgbWF0dGVyIHJpZ2h0L2xlZnRcbiAgICAgICAgICAgICAgdGhpcy5fdXAgPSBwb3N0ZXJpb3JEaXJlY3Rpb247XG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHN1cGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY29yb25hbCc6XG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnc3VwZXJpb3InXG4gICAgICAgICAgICAgIGlmIChzdXBlcmlvckRpcmVjdGlvbi56IDwgMCkge1xuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIGFudGVyaW9yXG4gICAgICAgICAgICAgIGlmIChwb3N0ZXJpb3JEaXJlY3Rpb24ueSA+IDApIHtcbiAgICAgICAgICAgICAgICBwb3N0ZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IGxlZnREaXJlY3Rpb247IC8vIGRvZXMgbm90IG1hdHRlciByaWdodC9sZWZ0XG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gc3VwZXJpb3JEaXJlY3Rpb247XG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHBvc3RlcmlvckRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NhZ2l0dGFsJzpcbiAgICAgICAgICAgICAgLy8gdXAgdmVjdG9yIGlzICdzdXBlcmlvcidcbiAgICAgICAgICAgICAgaWYgKHN1cGVyaW9yRGlyZWN0aW9uLnogPCAwKSB7XG4gICAgICAgICAgICAgICAgc3VwZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBsb29raW5nIHRvd2FyZHMgcmlnaHRcbiAgICAgICAgICAgICAgaWYgKGxlZnREaXJlY3Rpb24ueCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZWZ0RGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSBwb3N0ZXJpb3JEaXJlY3Rpb247IC8vIGRvZXMgbm90IG1hdHRlciByaWdodC9sZWZ0XG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gc3VwZXJpb3JEaXJlY3Rpb247XG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGxlZnREaXJlY3Rpb247XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBgXCIke3RoaXMuX29yaWVudGF0aW9ufVwiIG9yaWVudGF0aW9uIGlzIG5vdCB2YWxpZC5cbiAgICAgICAgICAgICAgICAoY2hvaWNlczogYXhpYWwsIGNvcm9uYWwsIHNhZ2l0dGFsKWApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYCR7dGhpcy5fY29udmVudGlvbn0gaXMgbm90IHZhbGlkIChjaG9pY2VzOiByYWRpbywgbmV1cm8pYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhhdCBpcyB3aGF0IGRldGVybWluZXMgbGVmdC9yaWdodFxuICAgIGxldCByYXkgPSB7XG4gICAgICBwb3NpdGlvbjogdGhpcy5fYm94LmNlbnRlcixcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5fZGlyZWN0aW9uLFxuICAgIH07XG5cbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9XG4gICAgICB0aGlzLl9vcmRlckludGVyc2VjdGlvbnMoXG4gICAgICAgIEludGVyc2VjdGlvbnMucmF5Qm94KHJheSwgdGhpcy5fYm94KSxcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICB0aGlzLl9mcm9udCA9IGludGVyc2VjdGlvbnNbMF07XG4gICAgdGhpcy5fYmFjayA9IGludGVyc2VjdGlvbnNbMV07XG5cbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICB0aGlzLnVwLnNldCh0aGlzLl91cC54LCB0aGlzLl91cC55LCB0aGlzLl91cC56KTtcbiAgICB0aGlzLl91cGRhdGVDYW52YXMoKTtcbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldCh0aGlzLl9mcm9udCwgdGhpcy5fYmFjayk7XG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XG4gIH1cblxuICBsZWZ0RGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kTWF4SW5kZXgodGhpcy5fZGlyZWN0aW9ucywgMCk7XG4gIH1cblxuICBwb3N0ZXJpb3JEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb25zLCAxKTtcbiAgfVxuXG4gIHN1cGVyaW9yRGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kTWF4SW5kZXgodGhpcy5fZGlyZWN0aW9ucywgMik7XG4gIH1cblxuICAvKipcbiAgICogSW52ZXJ0IHJvd3MgaW4gdGhlIGN1cnJlbnQgc2xpY2UuXG4gICAqIEludmVydGluZyByb3dzIGluIDIgc3RlcHM6XG4gICAqICAgKiBGbGlwIHRoZSBcInVwXCIgdmVjdG9yXG4gICAqICAgKiBMb29rIGF0IHRoZSBzbGljZSBmcm9tIHRoZSBvdGhlciBzaWRlXG4gICAqL1xuICBpbnZlcnRSb3dzKCkge1xuICAgIC8vIGZsaXAgXCJ1cFwiIHZlY3RvclxuICAgIC8vIHdlIGZsaXAgdXAgZmlyc3QgYmVjYXVzZSBpbnZlcnRDb2x1bW5zIHVwZGF0ZSBwcm9qZWN0aW8gbWF0cmljZXNcbiAgICB0aGlzLnVwLm11bHRpcGx5U2NhbGFyKC0xKTtcbiAgICB0aGlzLmludmVydENvbHVtbnMoKTtcblxuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZlcnQgcm93cyBpbiB0aGUgY3VycmVudCBzbGljZS5cbiAgICogSW52ZXJ0aW5nIHJvd3MgaW4gMSBzdGVwOlxuICAgKiAgICogTG9vayBhdCB0aGUgc2xpY2UgZnJvbSB0aGUgb3RoZXIgc2lkZVxuICAgKi9cbiAgaW52ZXJ0Q29sdW1ucygpIHtcbiAgICB0aGlzLmNlbnRlcigpO1xuICAgIC8vIHJvdGF0ZSAxODAgZGVncmVlcyBhcm91bmQgdGhlIHVwIHZlY3Rvci4uLlxuICAgIGxldCBvcHBvc2l0ZVBvc2l0aW9uID0gdGhpcy5fb3Bwb3NpdGVQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcblxuICAgIC8vIHVwZGF0ZSBwb3Npc3Rpb24gYW5kIHRhcmdldFxuICAgIC8vIGNsb25lIGlzIG5lZWRlZCBiZWNhdXNlIHRoaXMucG9zaXRpb24gaXMgb3ZlcndyaXR0ZW4gaW4gbWV0aG9kXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb25BbmRUYXJnZXQob3Bwb3NpdGVQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xuICAgIHRoaXMuX2Zyb21Gcm9udCA9ICF0aGlzLl9mcm9tRnJvbnQ7XG5cbiAgICB0aGlzLl9hbmdsZSAlPSAzNjA7XG4gICAgdGhpcy5fYW5nbGUgPSAzNjAgLSB0aGlzLl9hbmdsZTtcblxuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDZW50ZXIgc2xpY2UgaW4gdGhlIGNhbWVyYSBGT1YuXG4gICAqIEl0IGFsc28gdXBkYXRlcyB0aGUgY29udHJvbGxlcnMgcHJvcGVybHkuXG4gICAqIFdlIGNhbiBjZW50ZXIgYSBjYW1lcmEgZnJvbSB0aGUgZnJvbnQgb3IgZnJvbSB0aGUgYmFjay5cbiAgICovXG4gIGNlbnRlcigpIHtcbiAgICBpZiAodGhpcy5fZnJvbUZyb250KSB7XG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldCh0aGlzLl9mcm9udCwgdGhpcy5fYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uQW5kVGFyZ2V0KHRoaXMuX2JhY2ssIHRoaXMuX2Zyb250KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQaS8yIHJvdGF0aW9uIGFyb3VuZCB0aGUgekNvc2luZSBheGlzLlxuICAgKiBDbG9jay13aXNlIHJvdGF0aW9uIGZyb20gdGhlIHVzZXIgcG9pbnQgb2Ygdmlldy5cbiAgICovXG4gIHJvdGF0ZShhbmdsZT1udWxsKSB7XG4gICAgdGhpcy5jZW50ZXIoKTtcblxuICAgIGxldCBjb21wdXRlZEFuZ2xlID0gOTA7XG5cbiAgICBsZXQgY2xvY2t3aXNlID0gMTtcbiAgICBpZiAoIXRoaXMuX2Zyb21Gcm9udCkge1xuICAgICAgY2xvY2t3aXNlID0gLTE7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlID09PSBudWxsKSB7XG4gICAgICBjb21wdXRlZEFuZ2xlICo9IC1jbG9ja3dpc2U7XG4gICAgICB0aGlzLl9hbmdsZSArPSA5MDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZWRBbmdsZSA9IDM2MCAtIGNsb2Nrd2lzZSAqIChhbmdsZSAtIHRoaXMuX2FuZ2xlKTtcbiAgICAgIHRoaXMuX2FuZ2xlID0gYW5nbGU7XG4gICAgfVxuXG4gICAgdGhpcy5fYW5nbGUgJT0gMzYwO1xuXG4gICAgLy8gUm90YXRlIHRoZSB1cCB2ZWN0b3IgYXJvdW5kIHRoZSBcInpDb3NpbmVcIlxuICAgIGxldCByb3RhdGlvbiA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVJvdGF0aW9uQXhpcyhcbiAgICAgIHRoaXMuX2RpcmVjdGlvbixcbiAgICAgIGNvbXB1dGVkQW5nbGUgKiBNYXRoLlBJLzE4MCk7XG4gICAgdGhpcy51cC5hcHBseU1hdHJpeDQocm90YXRpb24pO1xuXG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XG4gIH1cblxuICAvLyBkaW1lbnNpb25zWzBdIC8vIHdpZHRoXG4gIC8vIGRpbWVuc2lvbnNbMV0gLy8gaGVpZ2h0XG4gIC8vIGRpcmVjdGlvbj0gMCB3aWR0aCwgMSBoZWlnaHQsIDIgYmVzdFxuICAvLyBmYWN0b3JcbiAgZml0Qm94KGRpcmVjdGlvbiA9IDAsIGZhY3Rvcj0xLjUpIHtcbiAgICAvL1xuICAgIC8vIGlmICghKGRpbWVuc2lvbnMgJiYgZGltZW5zaW9ucy5sZW5ndGggPj0gMikpIHtcbiAgICAvLyAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBkaW1lbnNpb25zIGNvbnRhaW5lci4nKTtcbiAgICAvLyAgIHdpbmRvdy5jb25zb2xlLmxvZyhkaW1lbnNpb25zKTtcblxuICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIH1cblxuICAgIC8vXG4gICAgbGV0IHpvb20gPSAxO1xuXG4gICAgLy8gdXBkYXRlIHpvb21cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB6b29tID0gZmFjdG9yICogdGhpcy5fY29tcHV0ZVpvb20odGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9yaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB6b29tID0gZmFjdG9yICogdGhpcy5fY29tcHV0ZVpvb20odGhpcy5fY2FudmFzLmhlaWdodCwgdGhpcy5fdXApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgem9vbSA9IGZhY3RvciAqIChNYXRoLm1pbihcbiAgICAgICAgICB0aGlzLl9jb21wdXRlWm9vbSh0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX3JpZ2h0KSxcbiAgICAgICAgICB0aGlzLl9jb21wdXRlWm9vbSh0aGlzLl9jYW52YXMuaGVpZ2h0LCB0aGlzLl91cClcbiAgICAgICAgKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCF6b29tKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy56b29tID0gem9vbTtcblxuICAgIHRoaXMuY2VudGVyKCk7XG4gIH1cblxuICBfYWRqdXN0VG9wRGlyZWN0aW9uKGhvcml6b250YWxEaXJlY3Rpb24sIHZlcnRpY2FsRGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgdk1heEluZGV4ID0gdGhpcy5fZ2V0TWF4SW5kZXgodmVydGljYWxEaXJlY3Rpb24pO1xuXG4gICAgLy8gc2hvdWxkIGhhbmRsZSB2TWF4IGluZGV4ID09PSAwXG4gICAgaWYgKCh2TWF4SW5kZXggPT09IDIgJiYgdmVydGljYWxEaXJlY3Rpb24uZ2V0Q29tcG9uZW50KHZNYXhJbmRleCkgPCAwKSB8fFxuICAgICAgICAodk1heEluZGV4ID09PSAxICYmIHZlcnRpY2FsRGlyZWN0aW9uLmdldENvbXBvbmVudCh2TWF4SW5kZXgpID4gMCkgfHxcbiAgICAgICAgKHZNYXhJbmRleCA9PT0gMCAmJiB2ZXJ0aWNhbERpcmVjdGlvbi5nZXRDb21wb25lbnQodk1heEluZGV4KSA+IDApKSB7XG4gICAgICB2ZXJ0aWNhbERpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICB9XG5cbiAgIHJldHVybiB2ZXJ0aWNhbERpcmVjdGlvbjtcbiAgfVxuXG4gIF9nZXRNYXhJbmRleCh2ZWN0b3IpIHtcbiAgICAvLyBpbml0IHdpdGggWCB2YWx1ZVxuICAgIGxldCBtYXhWYWx1ZSA9IE1hdGguYWJzKHZlY3Rvci54KTtcbiAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgaWYgKE1hdGguYWJzKHZlY3Rvci55KSA+IG1heFZhbHVlKSB7XG4gICAgICBtYXhWYWx1ZSA9IE1hdGguYWJzKHZlY3Rvci55KTtcbiAgICAgIGluZGV4ID0gMTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnModmVjdG9yLnopID4gbWF4VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBfZmluZE1heEluZGV4KGRpcmVjdGlvbnMsIHRhcmdldCkge1xuICAgIC8vIGdldCBpbmRleCBvZiB0aGUgbW9zdCBzdXBlcmlvciBkaXJlY3Rpb25cbiAgICBsZXQgbWF4SW5kaWNlcyA9IHRoaXMuX2dldE1heEluZGljZXMoZGlyZWN0aW9ucyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtYXhJbmRpY2VzW2ldID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldE1heEluZGljZXMoZGlyZWN0aW9ucykge1xuICAgIGxldCBpbmRpY2VzID0gW107XG4gICAgaW5kaWNlcy5wdXNoKHRoaXMuX2dldE1heEluZGV4KGRpcmVjdGlvbnNbMF0pKTtcbiAgICBpbmRpY2VzLnB1c2godGhpcy5fZ2V0TWF4SW5kZXgoZGlyZWN0aW9uc1sxXSkpO1xuICAgIGluZGljZXMucHVzaCh0aGlzLl9nZXRNYXhJbmRleChkaXJlY3Rpb25zWzJdKSk7XG5cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfVxuXG4gIF9vcmRlckludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgb3JkZXJlZCA9XG4gICAgICBpbnRlcnNlY3Rpb25zWzBdLmRvdChkaXJlY3Rpb24pIDwgaW50ZXJzZWN0aW9uc1sxXS5kb3QoZGlyZWN0aW9uKTtcblxuICAgIGlmICghb3JkZXJlZCkge1xuICAgICAgICByZXR1cm4gW2ludGVyc2VjdGlvbnNbMV0sIGludGVyc2VjdGlvbnNbMF1dO1xuICAgIH1cblxuICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICBfdXBkYXRlQ2FudmFzKCkge1xuICAgIGxldCBjYW1GYWN0b3IgPSAyO1xuICAgIHRoaXMubGVmdCA9IC10aGlzLl9jYW52YXMud2lkdGggLyBjYW1GYWN0b3I7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMuX2NhbnZhcy53aWR0aCAvIGNhbUZhY3RvcjtcbiAgICB0aGlzLnRvcCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgLyBjYW1GYWN0b3I7XG4gICAgdGhpcy5ib3R0b20gPSAtdGhpcy5fY2FudmFzLmhlaWdodCAvIGNhbUZhY3RvcjtcblxuICAgIHRoaXMuX3VwZGF0ZU1hdHJpY2VzKCk7XG4gICAgdGhpcy5jb250cm9scy5oYW5kbGVSZXNpemUoKTtcbiAgfVxuXG4gIF9vcHBvc2l0ZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgbGV0IG9wcG9zaXRlUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIC8vIGNlbnRlciB3b3JsZCBwb3N0aW9uIGFyb3VuZCBib3ggY2VudGVyXG4gICAgb3Bwb3NpdGVQb3NpdGlvbi5zdWIodGhpcy5fYm94LmNlbnRlcik7XG4gICAgLy8gcm90YXRlXG4gICAgbGV0IHJvdGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25BeGlzKFxuICAgICAgdGhpcy51cCxcbiAgICAgIE1hdGguUEkpO1xuXG4gICAgb3Bwb3NpdGVQb3NpdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb24pO1xuICAgIC8vIHRyYW5zbGF0ZSBiYWNrIHRvIHdvcmxkIHBvc2l0aW9uXG4gICAgb3Bwb3NpdGVQb3NpdGlvbi5hZGQodGhpcy5fYm94LmNlbnRlcik7XG4gICAgcmV0dXJuIG9wcG9zaXRlUG9zaXRpb247XG4gIH1cblxuICBfY29tcHV0ZVpvb20oZGltZW5zaW9uLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoIShkaW1lbnNpb24gJiYgZGltZW5zaW9uID4gMCkpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBkaW1lbnNpb24gcHJvdmlkZWQuJyk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coZGltZW5zaW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyByYXlcbiAgICBsZXQgcmF5ID0ge1xuICAgICAgcG9zaXRpb246IHRoaXMuX2JveC5jZW50ZXIuY2xvbmUoKSxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgIH07XG5cbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9IEludGVyc2VjdGlvbnMucmF5Qm94KHJheSwgdGhpcy5fYm94KTtcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0NhbiBub3QgYWRqdXN0IHRoZSBjYW1lcmEgKCA8IDIgaW50ZXJzZWN0aW9ucykuJyk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cocmF5KTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzLl9ib3gpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBkaW1lbnNpb24gLyBpbnRlcnNlY3Rpb25zWzBdLmRpc3RhbmNlVG8oaW50ZXJzZWN0aW9uc1sxXSk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb25BbmRUYXJnZXQocG9zaXRpb24sIHRhcmdldCkge1xuICAgICAgLy8gcG9zaXRpb25cbiAgICAgIHRoaXMucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuXG4gICAgICAvLyB0YXJnZXRzXG4gICAgICB0aGlzLmxvb2tBdCh0YXJnZXQueCwgdGFyZ2V0LnksIHRhcmdldC56KTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLnRhcmdldC5zZXQodGFyZ2V0LngsIHRhcmdldC55LCB0YXJnZXQueik7XG4gIH1cblxuICBfdXBkYXRlTWF0cmljZXMoKSB7XG4gICAgdGhpcy5fY29udHJvbHMudXBkYXRlKCk7XG4gICAgLy8gVEhFTiBjYW1lcmFcbiAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cblxuICBfdXBkYXRlTGFiZWxzKCkge1xuICAgIHRoaXMuX2RpcmVjdGlvbnNMYWJlbCA9IFtcbiAgICAgIHRoaXMuX3ZlY3RvcjJMYWJlbCh0aGlzLl91cCksXG4gICAgICB0aGlzLl92ZWN0b3IyTGFiZWwodGhpcy5fdXAuY2xvbmUoKS5uZWdhdGUoKSksXG4gICAgICB0aGlzLl92ZWN0b3IyTGFiZWwodGhpcy5fcmlnaHQpLFxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX3JpZ2h0LmNsb25lKCkubmVnYXRlKCkpLFxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX2RpcmVjdGlvbiksXG4gICAgICB0aGlzLl92ZWN0b3IyTGFiZWwodGhpcy5fZGlyZWN0aW9uLmNsb25lKCkubmVnYXRlKCkpLFxuICAgIF07XG4gIH1cblxuICBfdmVjdG9yMkxhYmVsKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZ2V0TWF4SW5kZXgoZGlyZWN0aW9uKTtcbiAgICAvLyBzZXQgdmVjdG9yIG1heCB2YWx1ZSB0byAxXG4gICAgY29uc3Qgc2NhbGVkRGlyZWN0aW9uID1cbiAgICAgIGRpcmVjdGlvbi5jbG9uZSgpLmRpdmlkZVNjYWxhcihNYXRoLmFicyhkaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGluZGV4KSkpO1xuICAgIGNvbnN0IGRlbHRhID0gMC4yO1xuICAgIGxldCBsYWJlbCA9ICcnO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxuICAgIGZvciAobGV0IGkgPSAwOyBpPDM7IGkrKykge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgaWYgKHNjYWxlZERpcmVjdGlvbi5nZXRDb21wb25lbnQoaSkgKyBkZWx0YSA+PSAxKSB7XG4gICAgICAgICAgbGFiZWwgKz0gJ0wnO1xuICAgICAgICB9IGVsc2UgaWYgKHNjYWxlZERpcmVjdGlvbi5nZXRDb21wb25lbnQoaSkgLSBkZWx0YSA8PSAtMSkge1xuICAgICAgICAgIGxhYmVsICs9ICdSJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSArIGRlbHRhID49IDEpIHtcbiAgICAgICAgICBsYWJlbCArPSAnUCc7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSAtIGRlbHRhIDw9IC0xKSB7XG4gICAgICAgICAgbGFiZWwgKz0gJ0EnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgIGlmIChzY2FsZWREaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGkpICsgZGVsdGEgPj0gMSkge1xuICAgICAgICAgIGxhYmVsICs9ICdTJztcbiAgICAgICAgfSBlbHNlIGlmIChzY2FsZWREaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGkpIC0gZGVsdGEgPD0gLTEpIHtcbiAgICAgICAgICBsYWJlbCArPSAnSSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWw7XG4gIH1cblxuICBfdXBkYXRlRGlyZWN0aW9ucygpIHtcbiAgICAvLyB1cCBpcyBjb3JyZWN0XG4gICAgdGhpcy5fdXAgPSB0aGlzLnVwLmNsb25lKCk7XG5cbiAgICAvLyBkaXJlY3Rpb25cbiAgICBsZXQgcExvY2FsID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgLTEpO1xuICAgIGxldCBwV29ybGQgPSBwTG9jYWwuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IHBXb3JsZC5zdWIodGhpcy5wb3NpdGlvbikubm9ybWFsaXplKCk7XG5cbiAgICAvLyByaWdodFxuICAgIHRoaXMuX3JpZ2h0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnModGhpcy5fZGlyZWN0aW9uLCB0aGlzLnVwKTtcblxuICAgIC8vIHVwZGF0ZSBsYWJlbHMgYWNjb3JkaW5nbHlcbiAgICB0aGlzLl91cGRhdGVMYWJlbHMoKTtcbiAgfVxuXG4gIHNldCBjb250cm9scyhjb250cm9scykge1xuICAgIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XG4gIH1cblxuICBnZXQgY29udHJvbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzO1xuICB9XG5cbiAgc2V0IGJveChib3gpIHtcbiAgICB0aGlzLl9ib3ggPSBib3g7XG4gIH1cblxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLl9ib3g7XG4gIH1cblxuICBzZXQgY2FudmFzKGNhbnZhcykge1xuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLl91cGRhdGVDYW52YXMoKTtcbiAgfVxuXG4gIGdldCBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgfVxuXG4gIHNldCBhbmdsZShhbmdsZSkge1xuICAgIHRoaXMucm90YXRlKGFuZ2xlKTtcbiAgfVxuXG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5nbGU7XG4gIH1cblxuICBzZXQgZGlyZWN0aW9ucyhkaXJlY3Rpb25zKSB7XG4gICAgdGhpcy5fZGlyZWN0aW9ucyA9IGRpcmVjdGlvbnM7XG4gIH1cblxuICBnZXQgZGlyZWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9ucztcbiAgfVxuXG4gIHNldCBjb252ZW50aW9uKGNvbnZlbnRpb24pIHtcbiAgICB0aGlzLl9jb252ZW50aW9uID0gY29udmVudGlvbjtcbiAgfVxuXG4gIGdldCBjb252ZW50aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jb252ZW50aW9uO1xuICB9XG5cbiAgc2V0IG9yaWVudGF0aW9uKG9yaWVudGF0aW9uKSB7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgfVxuXG4gIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb247XG4gIH1cblxuICBzZXQgZGlyZWN0aW9uc0xhYmVsKGRpcmVjdGlvbnNMYWJlbCkge1xuICAgIHRoaXMuX2RpcmVjdGlvbnNMYWJlbCA9IGRpcmVjdGlvbnNMYWJlbDtcbiAgfVxuXG4gIGdldCBkaXJlY3Rpb25zTGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbnNMYWJlbDtcbiAgfVxuXG4gIHNldCBzdGFja09yaWVudGF0aW9uKHN0YWNrT3JpZW50YXRpb24pIHtcbiAgICB0aGlzLl9zdGFja09yaWVudGF0aW9uID0gc3RhY2tPcmllbnRhdGlvbjtcblxuICAgIGlmICh0aGlzLl9zdGFja09yaWVudGF0aW9uID09PSAwKSB7XG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdkZWZhdWx0JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4SW5kZXggPVxuICAgICAgICB0aGlzLl9nZXRNYXhJbmRleChcbiAgICAgICAgICB0aGlzLl9kaXJlY3Rpb25zWyh0aGlzLl9zdGFja09yaWVudGF0aW9uICsgMikgJSAzXSk7XG5cbiAgICAgIGlmIChtYXhJbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdzYWdpdHRhbCc7XG4gICAgICB9IGVsc2UgaWYgKG1heEluZGV4ID09PSAxKSB7XG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ2Nvcm9uYWwnO1xuICAgICAgfSBlbHNlIGlmIChtYXhJbmRleCA9PT0gMikge1xuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdheGlhbCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YWNrT3JpZW50YXRpb24oKSB7XG4gICAgLy9cbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gPT09ICdkZWZhdWx0Jykge1xuICAgICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXhJbmRleCA9IHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbik7XG5cbiAgICAgIGlmIChtYXhJbmRleCA9PT0gdGhpcy5fZ2V0TWF4SW5kZXgodGhpcy5fZGlyZWN0aW9uc1syXSkpIHtcbiAgICAgICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1heEluZGV4ID09PSB0aGlzLl9nZXRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb25zWzBdKSkge1xuICAgICAgICB0aGlzLl9zdGFja09yaWVudGF0aW9uID0gMTtcbiAgICAgIH0gZWxzZSBpZiAobWF4SW5kZXggPT09IHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnNbMV0pKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrT3JpZW50YXRpb24gPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdGFja09yaWVudGF0aW9uO1xuICB9XG5cbn1cbiIsImltcG9ydCBUcmFja2JhbGwgZnJvbSAnLi9jb250cm9scy50cmFja2JhbGwnO1xuaW1wb3J0IFRyYWNrYmFsbE9ydGhvIGZyb20gJy4vY29udHJvbHMudHJhY2tiYWxsb3J0aG8nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFRyYWNrYmFsbCxcbiAgVHJhY2tiYWxsT3J0aG8sXG59O1xuIiwiLyoqXG4gKiBPcmlnaW5hbCBhdXRob3JzIGZyb20gVEhSRUVKUyByZXBvXG4gKiBAYXV0aG9yIEViZXJoYXJkIEdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIE1hcmsgTHVuZGluICAvIGh0dHA6Ly9tYXJrLWx1bmRpbi5jb21cbiAqIEBhdXRob3IgU2ltb25lIE1hbmluaSAvIGh0dHA6Ly9kYXJvbjEzMzcuZ2l0aHViLmlvXG4gKiBAYXV0aG9yIEx1Y2EgQW50aWdhICAvIGh0dHA6Ly9sYW50aWdhLmdpdGh1Yi5pb1xuICovXG5cbiBleHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFja2JhbGwgZXh0ZW5kcyBUSFJFRS5FdmVudERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIGRvbUVsZW1lbnQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBsZXQgU1RBVEUgPSB7Tk9ORTogLTEsIFJPVEFURTogMCwgWk9PTTogMSwgUEFOOiAyLCBUT1VDSF9ST1RBVEU6IDMsIFRPVUNIX1pPT006IDQsIFRPVUNIX1BBTjogNSwgQ1VTVE9NOiA5OX07XG5cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSAoZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblxuICAgIC8vIEFQSVxuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuc2NyZWVuID0ge2xlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMH07XG5cbiAgICB0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xuICAgIHRoaXMuem9vbVNwZWVkID0gMS4yO1xuICAgIHRoaXMucGFuU3BlZWQgPSAwLjM7XG5cbiAgICB0aGlzLm5vUm90YXRlID0gZmFsc2U7XG4gICAgdGhpcy5ub1pvb20gPSBmYWxzZTtcbiAgICB0aGlzLm5vUGFuID0gZmFsc2U7XG4gICAgdGhpcy5ub0N1c3RvbSA9IGZhbHNlO1xuXG4gICAgdGhpcy5mb3JjZVN0YXRlID0gLTE7XG5cbiAgICB0aGlzLnN0YXRpY01vdmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IgPSAwLjI7XG5cbiAgICB0aGlzLm1pbkRpc3RhbmNlID0gMDtcbiAgICB0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICB0aGlzLmtleXMgPSBbNjUgLyogQSovLCA4MyAvKiBTKi8sIDY4XTtcblxuICAgIC8vIGludGVybmFsc1xuXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgbGV0IEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgbGV0IGxhc3RQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBsZXQgX3N0YXRlID0gU1RBVEUuTk9ORSxcbiAgICBfcHJldlN0YXRlID0gU1RBVEUuTk9ORSxcblxuICAgIF9leWUgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgX21vdmVQcmV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAgICBfbW92ZUN1cnIgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuXG4gICAgX2xhc3RBeGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICBfbGFzdEFuZ2xlID0gMCxcblxuICAgIF96b29tU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICAgIF96b29tRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcblxuICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gMCxcbiAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSAwLFxuXG4gICAgX3BhblN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAgICBfcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcblxuICAgIF9jdXN0b21TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgX2N1c3RvbUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAvLyBmb3IgcmVzZXRcblxuICAgIHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgIHRoaXMudXAwID0gdGhpcy5vYmplY3QudXAuY2xvbmUoKTtcblxuICAgIC8vIGV2ZW50c1xuXG4gICAgbGV0IGNoYW5nZUV2ZW50ID0ge3R5cGU6ICdjaGFuZ2UnfTtcbiAgICBsZXQgc3RhcnRFdmVudCA9IHt0eXBlOiAnc3RhcnQnfTtcbiAgICBsZXQgZW5kRXZlbnQgPSB7dHlwZTogJ2VuZCd9O1xuXG4gICAgLy8gbWV0aG9kc1xuXG4gICAgdGhpcy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuc2NyZWVuLmxlZnQgPSAwO1xuICAgICAgICB0aGlzLnNjcmVlbi50b3AgPSAwO1xuICAgICAgICB0aGlzLnNjcmVlbi53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYm94ID0gdGhpcy5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAvLyBhZGp1c3RtZW50cyBjb21lIGZyb20gc2ltaWxhciBjb2RlIGluIHRoZSBqcXVlcnkgb2Zmc2V0KCkgZnVuY3Rpb25cbiAgICAgICAgbGV0IGQgPSB0aGlzLmRvbUVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc2NyZWVuLmxlZnQgPSBib3gubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCAtIGQuY2xpZW50TGVmdDtcbiAgICAgICAgdGhpcy5zY3JlZW4udG9wID0gYm94LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCAtIGQuY2xpZW50VG9wO1xuICAgICAgICB0aGlzLnNjcmVlbi53aWR0aCA9IGJveC53aWR0aDtcbiAgICAgICAgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gYm94LmhlaWdodDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXNbZXZlbnQudHlwZV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2V2ZW50LnR5cGVdKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGdldE1vdXNlT25TY3JlZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICB2ZWN0b3Iuc2V0KFxuICAgICAgICAgICAgKHBhZ2VYIC0gX3RoaXMuc2NyZWVuLmxlZnQpIC8gX3RoaXMuc2NyZWVuLndpZHRoLFxuICAgICAgICAgICAgKHBhZ2VZIC0gX3RoaXMuc2NyZWVuLnRvcCkgLyBfdGhpcy5zY3JlZW4uaGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIGxldCBnZXRNb3VzZU9uQ2lyY2xlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdmVjdG9yLnNldChcbiAgICAgICAgICAgICgocGFnZVggLSBfdGhpcy5zY3JlZW4ud2lkdGggKiAwLjUgLSBfdGhpcy5zY3JlZW4ubGVmdCkgLyAoX3RoaXMuc2NyZWVuLndpZHRoICogMC41KSksXG4gICAgICAgICAgICAoKF90aGlzLnNjcmVlbi5oZWlnaHQgKyAyICogKF90aGlzLnNjcmVlbi50b3AgLSBwYWdlWSkpIC8gX3RoaXMuc2NyZWVuLndpZHRoKSAvLyBzY3JlZW4ud2lkdGggaW50ZW50aW9uYWxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdmVjdG9yO1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgdGhpcy5yb3RhdGVDYW1lcmEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCksXG4gICAgICAgICAgZXllRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICBvYmplY3RVcERpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgb2JqZWN0U2lkZXdheXNEaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgIG1vdmVEaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgIGFuZ2xlO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vdmVEaXJlY3Rpb24uc2V0KF9tb3ZlQ3Vyci54IC0gX21vdmVQcmV2LngsIF9tb3ZlQ3Vyci55IC0gX21vdmVQcmV2LnksIDApO1xuICAgICAgICBhbmdsZSA9IG1vdmVEaXJlY3Rpb24ubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgX2V5ZS5jb3B5KF90aGlzLm9iamVjdC5wb3NpdGlvbikuc3ViKF90aGlzLnRhcmdldCk7XG5cbiAgICAgICAgICBleWVEaXJlY3Rpb24uY29weShfZXllKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICBvYmplY3RVcERpcmVjdGlvbi5jb3B5KF90aGlzLm9iamVjdC51cCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgb2JqZWN0U2lkZXdheXNEaXJlY3Rpb24uY3Jvc3NWZWN0b3JzKG9iamVjdFVwRGlyZWN0aW9uLCBleWVEaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgb2JqZWN0VXBEaXJlY3Rpb24uc2V0TGVuZ3RoKF9tb3ZlQ3Vyci55IC0gX21vdmVQcmV2LnkpO1xuICAgICAgICAgIG9iamVjdFNpZGV3YXlzRGlyZWN0aW9uLnNldExlbmd0aChfbW92ZUN1cnIueCAtIF9tb3ZlUHJldi54KTtcblxuICAgICAgICAgIG1vdmVEaXJlY3Rpb24uY29weShvYmplY3RVcERpcmVjdGlvbi5hZGQob2JqZWN0U2lkZXdheXNEaXJlY3Rpb24pKTtcblxuICAgICAgICAgIGF4aXMuY3Jvc3NWZWN0b3JzKG1vdmVEaXJlY3Rpb24sIF9leWUpLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgYW5nbGUgKj0gX3RoaXMucm90YXRlU3BlZWQ7XG4gICAgICAgICAgcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKTtcblxuICAgICAgICAgIF9leWUuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICAgICAgICAgIF90aGlzLm9iamVjdC51cC5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG5cbiAgICAgICAgICBfbGFzdEF4aXMuY29weShheGlzKTtcbiAgICAgICAgICBfbGFzdEFuZ2xlID0gYW5nbGU7XG4gICAgICAgIH0gZWxzZSBpZiAoIV90aGlzLnN0YXRpY01vdmluZyAmJiBfbGFzdEFuZ2xlKSB7XG4gICAgICAgICAgX2xhc3RBbmdsZSAqPSBNYXRoLnNxcnQoMS4wIC0gX3RoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IpO1xuICAgICAgICAgIF9leWUuY29weShfdGhpcy5vYmplY3QucG9zaXRpb24pLnN1YihfdGhpcy50YXJnZXQpO1xuICAgICAgICAgIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShfbGFzdEF4aXMsIF9sYXN0QW5nbGUpO1xuICAgICAgICAgIF9leWUuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICAgICAgICAgIF90aGlzLm9iamVjdC51cC5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgdGhpcy56b29tQ2FtZXJhID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZmFjdG9yO1xuXG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5UT1VDSF9aT09NKSB7XG4gICAgICAgIGZhY3RvciA9IF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0IC8gX3RvdWNoWm9vbURpc3RhbmNlRW5kO1xuICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IF90b3VjaFpvb21EaXN0YW5jZUVuZDtcbiAgICAgICAgX2V5ZS5tdWx0aXBseVNjYWxhcihmYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yID0gMS4wICsgKF96b29tRW5kLnkgLSBfem9vbVN0YXJ0LnkpICogX3RoaXMuem9vbVNwZWVkO1xuXG4gICAgICAgIGlmIChmYWN0b3IgIT09IDEuMCAmJiBmYWN0b3IgPiAwLjApIHtcbiAgICAgICAgICBfZXllLm11bHRpcGx5U2NhbGFyKGZhY3Rvcik7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuc3RhdGljTW92aW5nKSB7XG4gICAgICAgICAgICBfem9vbVN0YXJ0LmNvcHkoX3pvb21FbmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfem9vbVN0YXJ0LnkgKz0gKF96b29tRW5kLnkgLSBfem9vbVN0YXJ0LnkpICogdGhpcy5keW5hbWljRGFtcGluZ0ZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wYW5DYW1lcmEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbW91c2VDaGFuZ2UgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICAgICAgICAgIG9iamVjdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICBwYW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vdXNlQ2hhbmdlLmNvcHkoX3BhbkVuZCkuc3ViKF9wYW5TdGFydCk7XG5cbiAgICAgICAgaWYgKG1vdXNlQ2hhbmdlLmxlbmd0aFNxKCkpIHtcbiAgICAgICAgICBtb3VzZUNoYW5nZS5tdWx0aXBseVNjYWxhcihfZXllLmxlbmd0aCgpICogX3RoaXMucGFuU3BlZWQpO1xuXG4gICAgICAgICAgcGFuLmNvcHkoX2V5ZSkuY3Jvc3MoX3RoaXMub2JqZWN0LnVwKS5zZXRMZW5ndGgobW91c2VDaGFuZ2UueCk7XG4gICAgICAgICAgcGFuLmFkZChvYmplY3RVcC5jb3B5KF90aGlzLm9iamVjdC51cCkuc2V0TGVuZ3RoKG1vdXNlQ2hhbmdlLnkpKTtcblxuICAgICAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGQocGFuKTtcbiAgICAgICAgICBfdGhpcy50YXJnZXQuYWRkKHBhbik7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuc3RhdGljTW92aW5nKSB7XG4gICAgICAgICAgICBfcGFuU3RhcnQuY29weShfcGFuRW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3BhblN0YXJ0LmFkZChtb3VzZUNoYW5nZS5zdWJWZWN0b3JzKF9wYW5FbmQsIF9wYW5TdGFydCkubXVsdGlwbHlTY2FsYXIoX3RoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIHRoaXMuY2hlY2tEaXN0YW5jZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghX3RoaXMubm9ab29tIHx8ICFfdGhpcy5ub1Bhbikge1xuICAgICAgICBpZiAoX2V5ZS5sZW5ndGhTcSgpID4gX3RoaXMubWF4RGlzdGFuY2UgKiBfdGhpcy5tYXhEaXN0YW5jZSkge1xuICAgICAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGRWZWN0b3JzKF90aGlzLnRhcmdldCwgX2V5ZS5zZXRMZW5ndGgoX3RoaXMubWF4RGlzdGFuY2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfZXllLmxlbmd0aFNxKCkgPCBfdGhpcy5taW5EaXN0YW5jZSAqIF90aGlzLm1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmFkZFZlY3RvcnMoX3RoaXMudGFyZ2V0LCBfZXllLnNldExlbmd0aChfdGhpcy5taW5EaXN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBfZXllLnN1YlZlY3RvcnMoX3RoaXMub2JqZWN0LnBvc2l0aW9uLCBfdGhpcy50YXJnZXQpO1xuXG4gICAgICBpZiAoIV90aGlzLm5vUm90YXRlKSB7XG4gICAgICAgIF90aGlzLnJvdGF0ZUNhbWVyYSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLm5vWm9vbSkge1xuICAgICAgICBfdGhpcy56b29tQ2FtZXJhKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3RoaXMubm9QYW4pIHtcbiAgICAgICAgX3RoaXMucGFuQ2FtZXJhKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3RoaXMubm9DdXN0b20pIHtcbiAgICAgICAgX3RoaXMuY3VzdG9tKF9jdXN0b21TdGFydCwgX2N1c3RvbUVuZCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGRWZWN0b3JzKF90aGlzLnRhcmdldCwgX2V5ZSk7XG5cbiAgICAgIF90aGlzLmNoZWNrRGlzdGFuY2VzKCk7XG5cbiAgICAgIF90aGlzLm9iamVjdC5sb29rQXQoX3RoaXMudGFyZ2V0KTtcblxuICAgICAgaWYgKGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZChfdGhpcy5vYmplY3QucG9zaXRpb24pID4gRVBTKSB7XG4gICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuXG4gICAgICAgIGxhc3RQb3NpdGlvbi5jb3B5KF90aGlzLm9iamVjdC5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICBfcHJldlN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgX3RoaXMudGFyZ2V0LmNvcHkoX3RoaXMudGFyZ2V0MCk7XG4gICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uY29weShfdGhpcy5wb3NpdGlvbjApO1xuICAgICAgX3RoaXMub2JqZWN0LnVwLmNvcHkoX3RoaXMudXAwKTtcblxuICAgICAgX2V5ZS5zdWJWZWN0b3JzKF90aGlzLm9iamVjdC5wb3NpdGlvbiwgX3RoaXMudGFyZ2V0KTtcblxuICAgICAgX3RoaXMub2JqZWN0Lmxvb2tBdChfdGhpcy50YXJnZXQpO1xuXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcblxuICAgICAgbGFzdFBvc2l0aW9uLmNvcHkoX3RoaXMub2JqZWN0LnBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHRhcmdldFN0YXRlKSB7XG4gICAgICBfdGhpcy5mb3JjZVN0YXRlID0gdGFyZ2V0U3RhdGU7XG4gICAgICBfcHJldlN0YXRlID0gdGFyZ2V0U3RhdGU7XG4gICAgICBfc3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5jdXN0b20gPSBmdW5jdGlvbihjdXN0b21TdGFydCwgY3VzdG9tRW5kKSB7XG5cbiAgICB9O1xuXG4gICAgLy8gbGlzdGVuZXJzXG5cbiAgICBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duKTtcblxuICAgICAgX3ByZXZTdGF0ZSA9IF9zdGF0ZTtcblxuICAgICAgaWYgKF9zdGF0ZSAhPT0gU1RBVEUuTk9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbU1RBVEUuUk9UQVRFXSAmJiAhX3RoaXMubm9Sb3RhdGUpIHtcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuUk9UQVRFO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzW1NUQVRFLlpPT01dICYmICFfdGhpcy5ub1pvb20pIHtcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuWk9PTTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1tTVEFURS5QQU5dICYmICFfdGhpcy5ub1Bhbikge1xuICAgICAgICBfc3RhdGUgPSBTVEFURS5QQU47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBfc3RhdGUgPSBfcHJldlN0YXRlO1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZWRvd24oZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgX3N0YXRlID0gZXZlbnQuYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5ST1RBVEUgJiYgIV90aGlzLm5vUm90YXRlKSB7XG4gICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XG4gICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuWk9PTSAmJiAhX3RoaXMubm9ab29tKSB7XG4gICAgICAgIF96b29tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgICBfem9vbUVuZC5jb3B5KF96b29tU3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlBBTiAmJiAhX3RoaXMubm9QYW4pIHtcbiAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuQ1VTVE9NICYmICFfdGhpcy5ub0N1c3RvbSkge1xuICAgICAgICBfY3VzdG9tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgICBfY3VzdG9tRW5kLmNvcHkoX3BhblN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCwgZmFsc2UpO1xuXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICYmICFfdGhpcy5ub1JvdGF0ZSkge1xuICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xuICAgICAgICBfbW92ZUN1cnIuY29weShnZXRNb3VzZU9uQ2lyY2xlKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlpPT00gJiYgIV90aGlzLm5vWm9vbSkge1xuICAgICAgICBfem9vbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUEFOICYmICFfdGhpcy5ub1Bhbikge1xuICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5DVVNUT00gJiYgIV90aGlzLm5vQ3VzdG9tKSB7XG4gICAgICAgIF9jdXN0b21FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmIChfdGhpcy5mb3JjZVN0YXRlID09PSAtMSkge1xuICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXApO1xuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V3aGVlbChldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgbGV0IGRlbHRhID0gMDtcblxuICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcblxuICAgICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyA0MDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gLy8gRmlyZWZveFxuXG4gICAgICAgIGRlbHRhID0gLWV2ZW50LmRldGFpbCAvIDM7XG4gICAgICB9XG5cbiAgICAgIGlmIChfc3RhdGUgIT09IFNUQVRFLkNVU1RPTSkge1xuICAgICAgICBfem9vbVN0YXJ0LnkgKz0gZGVsdGEgKiAwLjAxO1xuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLkNVU1RPTSkge1xuICAgICAgICBfY3VzdG9tU3RhcnQueSArPSBkZWx0YSAqIDAuMDE7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0KGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgaWYgKF90aGlzLmZvcmNlU3RhdGUgPT09IC0xKSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfWk9PTTtcbiAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XG4gICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xuICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XG4gICAgICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8geyBOT05FOiAtMSwgUk9UQVRFOiAwLCBaT09NOiAxLCBQQU46IDIsIFRPVUNIX1JPVEFURTogMywgVE9VQ0hfWk9PTV9QQU46IDQsIENVU1RPTTogOTkgfTtcbiAgICAgICAgc3dpdGNoIChfc3RhdGUpIHtcblxuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIDEgb3IgMiBmaW5nZXJzLCBzbWFlIGJlaGF2aW9yXG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XG4gICAgICAgICAgICBfbW92ZUN1cnIuY29weShnZXRNb3VzZU9uQ2lyY2xlKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcbiAgICAgICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9aT09NO1xuICAgICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XG4gICAgICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlpPT007XG4gICAgICAgICAgICAgIF96b29tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcbiAgICAgICAgICAgICAgX3pvb21FbmQuY29weShfem9vbVN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcbiAgICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XG4gICAgICAgICAgICAgIF9wYW5FbmQuY29weShfcGFuU3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuUEFOO1xuICAgICAgICAgICAgICBfcGFuU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcbiAgICAgICAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTk6XG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5DVVNUT007XG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgIF9jdXN0b21TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xuICAgICAgICAgICAgX2N1c3RvbUVuZC5jb3B5KF9jdXN0b21TdGFydCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b3VjaG1vdmUoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmIChfdGhpcy5mb3JjZVN0YXRlID09PSAtMSkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHsgTk9ORTogLTEsIFJPVEFURTogMCwgWk9PTTogMSwgUEFOOiAyLCBUT1VDSF9ST1RBVEU6IDMsIFRPVUNIX1pPT01fUEFOOiA0LCBDVVNUT006IDk5IH07XG4gICAgICAgIHN3aXRjaCAoX3N0YXRlKSB7XG5cbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF96b29tRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgLy8gMiBmaW5nZXJzIVxuICAgICAgICAgICAgLy8gVE9VQ0ggWk9PTVxuICAgICAgICAgICAgdmFyIGR4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XG4gICAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcbiAgICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIC8vIDIgZmluZ2Vyc1xuICAgICAgICAgICAgLy8gVE9VQ0hfUEFOXG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5OTpcbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XG4gICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xuICAgICAgICAgICAgX2N1c3RvbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG91Y2hlbmQoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBpZiAoX3RoaXMuZm9yY2VTdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IDA7XG5cbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XG4gICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xuICAgICAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xuICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoX3BhbkVuZCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoX3N0YXRlKSB7XG5cbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIC8vIFRPVUNIIFpPT01cbiAgICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gMDtcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlpPT007XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIC8vIFRPVUNIIFpPT01cbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XG4gICAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoX3BhbkVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5QQU47XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTk6XG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgIF9jdXN0b21FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICAgIF9jdXN0b21TdGFydC5jb3B5KF9jdXN0b21FbmQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn0sIGZhbHNlKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZWRvd24sIGZhbHNlKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbCwgZmFsc2UpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIG1vdXNld2hlZWwsIGZhbHNlKTsgLy8gZmlyZWZveFxuXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlLCBmYWxzZSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24sIGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cCwgZmFsc2UpO1xuXG4gICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcblxuICAgIC8vIGZvcmNlIGFuIHVwZGF0ZSBhdCBzdGFydFxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGF1dGhvciBFYmVyaGFyZCBHcmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciBNYXJrIEx1bmRpbiAgLyBodHRwOi8vbWFyay1sdW5kaW4uY29tXG4gKiBAYXV0aG9yIFBhdHJpY2sgRnVsbGVyIC8gaHR0cDovL3BhdHJpY2stZnVsbGVyLmNvbVxuICogQGF1dGhvciBNYXggU21vbGVucyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9tc21vbGVuc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYWNrYmFsbG9ydGhvIGV4dGVuZHMgVEhSRUUuRXZlbnREaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50LCBzdGF0ZSA9IHtOT05FOiAtMSwgUk9UQVRFOiAxLCBaT09NOiAyLCBQQU46IDAsIFNDUk9MTDogNCwgVE9VQ0hfUk9UQVRFOiA0LCBUT1VDSF9aT09NX1BBTjogNX0pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBsZXQgU1RBVEUgPSBzdGF0ZTtcblxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IChkb21FbGVtZW50ICE9PSB1bmRlZmluZWQpID8gZG9tRWxlbWVudCA6IGRvY3VtZW50O1xuXG4gICAgLy8gQVBJXG5cbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5zY3JlZW4gPSB7bGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwfTtcblxuICAgIHRoaXMucmFkaXVzID0gMDtcblxuICAgIHRoaXMuem9vbVNwZWVkID0gMS4yO1xuXG4gICAgdGhpcy5ub1pvb20gPSBmYWxzZTtcbiAgICB0aGlzLm5vUGFuID0gZmFsc2U7XG5cbiAgICB0aGlzLnN0YXRpY01vdmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IgPSAwLjI7XG5cbiAgICB0aGlzLmtleXMgPSBbNjUgLyogQSovLCA4MyAvKiBTKi8sIDY4XTtcblxuICAgIC8vIGludGVybmFsc1xuXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgbGV0IEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgbGV0IF9jaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGxldCBfc3RhdGUgPSBTVEFURS5OT05FLFxuICAgIF9wcmV2U3RhdGUgPSBTVEFURS5OT05FLFxuXG4gICAgX2V5ZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICBfem9vbVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAgICBfem9vbUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG5cbiAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IDAsXG4gICAgX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gMCxcblxuICAgIF9wYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgX3BhbkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAvLyB3aW5kb3cgbGV2ZWwgZmlyZSBhZnRlci4uLlxuXG4gICAgLy8gZm9yIHJlc2V0XG5cbiAgICB0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuICAgIHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnVwMCA9IHRoaXMub2JqZWN0LnVwLmNsb25lKCk7XG5cbiAgICB0aGlzLmxlZnQwID0gdGhpcy5vYmplY3QubGVmdDtcbiAgICB0aGlzLnJpZ2h0MCA9IHRoaXMub2JqZWN0LnJpZ2h0O1xuICAgIHRoaXMudG9wMCA9IHRoaXMub2JqZWN0LnRvcDtcbiAgICB0aGlzLmJvdHRvbTAgPSB0aGlzLm9iamVjdC5ib3R0b207XG5cbiAgICAvLyBldmVudHNcblxuICAgIGxldCBjaGFuZ2VFdmVudCA9IHt0eXBlOiAnY2hhbmdlJ307XG4gICAgbGV0IHN0YXJ0RXZlbnQgPSB7dHlwZTogJ3N0YXJ0J307XG4gICAgbGV0IGVuZEV2ZW50ID0ge3R5cGU6ICdlbmQnfTtcblxuICAgIC8vIG1ldGhvZHNcblxuICAgIHRoaXMuaGFuZGxlUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnNjcmVlbi5sZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5zY3JlZW4udG9wID0gMDtcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGJveCA9IHRoaXMuZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gYWRqdXN0bWVudHMgY29tZSBmcm9tIHNpbWlsYXIgY29kZSBpbiB0aGUganF1ZXJ5IG9mZnNldCgpIGZ1bmN0aW9uXG4gICAgICAgIGxldCBkID0gdGhpcy5kb21FbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB0aGlzLnNjcmVlbi5sZWZ0ID0gYm94LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgLSBkLmNsaWVudExlZnQ7XG4gICAgICAgIHRoaXMuc2NyZWVuLnRvcCA9IGJveC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgLSBkLmNsaWVudFRvcDtcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IGJveC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmFkaXVzID0gMC41ICogTWF0aC5taW4odGhpcy5zY3JlZW4ud2lkdGgsIHRoaXMuc2NyZWVuLmhlaWdodCk7XG5cbiAgICAgIHRoaXMubGVmdDAgPSB0aGlzLm9iamVjdC5sZWZ0O1xuICAgICAgdGhpcy5yaWdodDAgPSB0aGlzLm9iamVjdC5yaWdodDtcbiAgICAgIHRoaXMudG9wMCA9IHRoaXMub2JqZWN0LnRvcDtcbiAgICAgIHRoaXMuYm90dG9tMCA9IHRoaXMub2JqZWN0LmJvdHRvbTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXNbZXZlbnQudHlwZV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2V2ZW50LnR5cGVdKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGdldE1vdXNlT25TY3JlZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldE1vdXNlT25TY3JlZW4ocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIHZlY3Rvci5zZXQoXG4gICAgICAgICAgKHBhZ2VYIC0gX3RoaXMuc2NyZWVuLmxlZnQpIC8gX3RoaXMuc2NyZWVuLndpZHRoLFxuICAgICAgICAgIChwYWdlWSAtIF90aGlzLnNjcmVlbi50b3ApIC8gX3RoaXMuc2NyZWVuLmhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICB0aGlzLnpvb21DYW1lcmEgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLlRPVUNIX1pPT01fUEFOKSB7XG4gICAgICAgIHZhciBmYWN0b3IgPSBfdG91Y2hab29tRGlzdGFuY2VFbmQgLyBfdG91Y2hab29tRGlzdGFuY2VTdGFydDtcbiAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSBfdG91Y2hab29tRGlzdGFuY2VFbmQ7XG5cbiAgICAgICAgX3RoaXMub2JqZWN0Lnpvb20gKj0gZmFjdG9yO1xuXG4gICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmYWN0b3IgPSAxLjAgKyAoX3pvb21FbmQueSAtIF96b29tU3RhcnQueSkgKiBfdGhpcy56b29tU3BlZWQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGZhY3RvciAtIDEuMCkgPiBFUFMgJiYgZmFjdG9yID4gMC4wKSB7XG4gICAgICAgICAgX3RoaXMub2JqZWN0Lnpvb20gLz0gZmFjdG9yO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnN0YXRpY01vdmluZykge1xuICAgICAgICAgICAgX3pvb21TdGFydC5jb3B5KF96b29tRW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3pvb21TdGFydC55ICs9IChfem9vbUVuZC55IC0gX3pvb21TdGFydC55KSAqIHRoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucGFuQ2FtZXJhID0gKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IG1vdXNlQ2hhbmdlID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAgICAgICAgb2JqZWN0VXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBwYW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcGFuQ2FtZXJhKCkge1xuICAgICAgICBtb3VzZUNoYW5nZS5jb3B5KF9wYW5FbmQpLnN1YihfcGFuU3RhcnQpO1xuXG4gICAgICAgIGlmIChtb3VzZUNoYW5nZS5sZW5ndGhTcSgpKSB7XG4gICAgICAgICAgLy8gU2NhbGUgbW92ZW1lbnQgdG8ga2VlcCBjbGlja2VkL2RyYWdnZWQgcG9zaXRpb24gdW5kZXIgY3Vyc29yXG4gICAgICAgICAgbGV0IHNjYWxlX3ggPSAoX3RoaXMub2JqZWN0LnJpZ2h0IC0gX3RoaXMub2JqZWN0LmxlZnQpIC8gX3RoaXMub2JqZWN0Lnpvb207XG4gICAgICAgICAgbGV0IHNjYWxlX3kgPSAoX3RoaXMub2JqZWN0LnRvcCAtIF90aGlzLm9iamVjdC5ib3R0b20pIC8gX3RoaXMub2JqZWN0Lnpvb207XG4gICAgICAgICAgbW91c2VDaGFuZ2UueCAqPSBzY2FsZV94O1xuICAgICAgICAgIG1vdXNlQ2hhbmdlLnkgKj0gc2NhbGVfeTtcblxuICAgICAgICAgIHBhbi5jb3B5KF9leWUpLmNyb3NzKF90aGlzLm9iamVjdC51cCkuc2V0TGVuZ3RoKG1vdXNlQ2hhbmdlLngpO1xuICAgICAgICAgIHBhbi5hZGQob2JqZWN0VXAuY29weShfdGhpcy5vYmplY3QudXApLnNldExlbmd0aChtb3VzZUNoYW5nZS55KSk7XG5cbiAgICAgICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uYWRkKHBhbik7XG4gICAgICAgICAgX3RoaXMudGFyZ2V0LmFkZChwYW4pO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnN0YXRpY01vdmluZykge1xuICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoX3BhbkVuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9wYW5TdGFydC5hZGQobW91c2VDaGFuZ2Uuc3ViVmVjdG9ycyhfcGFuRW5kLCBfcGFuU3RhcnQpLm11bHRpcGx5U2NhbGFyKF90aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgX2V5ZS5zdWJWZWN0b3JzKF90aGlzLm9iamVjdC5wb3NpdGlvbiwgX3RoaXMudGFyZ2V0KTtcblxuICAgICAgaWYgKCFfdGhpcy5ub1pvb20pIHtcbiAgICAgICAgX3RoaXMuem9vbUNhbWVyYSgpO1xuXG4gICAgICAgIGlmIChfY2hhbmdlZCkge1xuICAgICAgICAgIF90aGlzLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFfdGhpcy5ub1Bhbikge1xuICAgICAgICBfdGhpcy5wYW5DYW1lcmEoKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmFkZFZlY3RvcnMoX3RoaXMudGFyZ2V0LCBfZXllKTtcblxuICAgICAgX3RoaXMub2JqZWN0Lmxvb2tBdChfdGhpcy50YXJnZXQpO1xuXG4gICAgICBpZiAoX2NoYW5nZWQpIHtcbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG5cbiAgICAgICAgX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgIF9wcmV2U3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICBfdGhpcy50YXJnZXQuY29weShfdGhpcy50YXJnZXQwKTtcbiAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5jb3B5KF90aGlzLnBvc2l0aW9uMCk7XG4gICAgICBfdGhpcy5vYmplY3QudXAuY29weShfdGhpcy51cDApO1xuXG4gICAgICBfZXllLnN1YlZlY3RvcnMoX3RoaXMub2JqZWN0LnBvc2l0aW9uLCBfdGhpcy50YXJnZXQpO1xuXG4gICAgICBfdGhpcy5vYmplY3QubGVmdCA9IF90aGlzLmxlZnQwO1xuICAgICAgX3RoaXMub2JqZWN0LnJpZ2h0ID0gX3RoaXMucmlnaHQwO1xuICAgICAgX3RoaXMub2JqZWN0LnRvcCA9IF90aGlzLnRvcDA7XG4gICAgICBfdGhpcy5vYmplY3QuYm90dG9tID0gX3RoaXMuYm90dG9tMDtcblxuICAgICAgX3RoaXMub2JqZWN0Lmxvb2tBdChfdGhpcy50YXJnZXQpO1xuXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcblxuICAgICAgX2NoYW5nZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gbGlzdGVuZXJzXG5cbiAgICBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duKTtcblxuICAgICAgX3ByZXZTdGF0ZSA9IF9zdGF0ZTtcblxuICAgICAgaWYgKF9zdGF0ZSAhPT0gU1RBVEUuTk9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbU1RBVEUuUk9UQVRFXSAmJiAhX3RoaXMubm9Sb3RhdGUpIHtcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuUk9UQVRFO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzW1NUQVRFLlpPT01dICYmICFfdGhpcy5ub1pvb20pIHtcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuWk9PTTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1tTVEFURS5QQU5dICYmICFfdGhpcy5ub1Bhbikge1xuICAgICAgICBfc3RhdGUgPSBTVEFURS5QQU47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBfc3RhdGUgPSBfcHJldlN0YXRlO1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZWRvd24oZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgX3N0YXRlID0gZXZlbnQuYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5ST1RBVEUgJiYgIV90aGlzLm5vUm90YXRlKSB7XG5cbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5aT09NICYmICFfdGhpcy5ub1pvb20pIHtcbiAgICAgICAgX3pvb21TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XG4gICAgICAgIF96b29tRW5kLmNvcHkoX3pvb21TdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUEFOICYmICFfdGhpcy5ub1Bhbikge1xuICAgICAgICBfcGFuU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCwgZmFsc2UpO1xuXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICYmICFfdGhpcy5ub1JvdGF0ZSkge1xuXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuWk9PTSAmJiAhX3RoaXMubm9ab29tKSB7XG4gICAgICAgIF96b29tRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5QQU4gJiYgIV90aGlzLm5vUGFuKSB7XG4gICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCk7XG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBsZXQgZGVsdGEgPSAwO1xuXG4gICAgICBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgICAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcblxuICAgICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyA0MDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAgIC8vIEZpcmVmb3hcblxuICAgICAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xuICAgICAgfVxuXG4gICAgICAvLyBGSVJFIFNDUk9MTCBFVkVOVFxuXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ09uU2Nyb2xsJyxcbiAgICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIF96b29tU3RhcnQueSArPSBkZWx0YSAqIDAuMDE7XG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG91Y2hzdGFydChldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlRPVUNIX1pPT01fUEFOO1xuICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xuICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XG4gICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICBfcGFuU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgIH1cbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG91Y2htb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgY2FzZSAxOlxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xuICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvdWNoZW5kKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xuXG4gICAgICAgIGNhc2UgMTpcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IDA7XG5cbiAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xuICAgICAgICAgIF9wYW5TdGFydC5jb3B5KF9wYW5FbmQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG5cbiAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250ZXh0bWVudShldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGNvbnRleHRtZW51LCBmYWxzZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2Vkb3duLCBmYWxzZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIG1vdXNld2hlZWwsIGZhbHNlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgbW91c2V3aGVlbCwgZmFsc2UpOyAvLyBmaXJlZm94XG5cbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmUsIGZhbHNlKTtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCwgZmFsc2UpO1xuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24sIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGtleXVwLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGNvbnRleHRtZW51LCBmYWxzZSk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlZG93biwgZmFsc2UpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbCwgZmFsc2UpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgbW91c2V3aGVlbCwgZmFsc2UpOyAvLyBmaXJlZm94XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZCwgZmFsc2UpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmUsIGZhbHNlKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93biwgZmFsc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGtleXVwLCBmYWxzZSk7XG5cbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuXG4gICAgLy8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxufVxuXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvcnMge1xuXG4gIC8vIGh0dHA6Ly93d3cuZWFzeXJnYi5jb20vaW5kZXgucGhwP1g9TUFUSCZIPTA4I3RleHQ4XG4gIHN0YXRpYyBjaWVsYWIyWFlaKGwsIGEsIGIpIHtcbiAgICBjb25zdCByZWZYID0gOTUuMDQ3O1xuICAgIGNvbnN0IHJlZlkgPSAxMDAuMDA7XG4gICAgY29uc3QgcmVmWiA9IDEwOC44ODM7XG5cbiAgICBsZXQgeSA9IChsICsgMTYpIC8gMTE2O1xuICAgIGxldCB4ID0gYSAvIDUwMCArIHk7XG4gICAgbGV0IHogPSB5IC0gYiAvIDIwMDtcblxuICAgIGlmIChNYXRoLnBvdyh5LCAzKSA+IDAuMDA4ODU2KSB7XG4gICAgICB5ID0gTWF0aC5wb3coeSwgMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSAoeSAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICAgIH1cblxuICAgIGlmIChNYXRoLnBvdyh4LCAzKSA+IDAuMDA4ODU2KSB7XG4gICAgICB4ID0gTWF0aC5wb3coeCwgMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAoeCAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICAgIH1cblxuICAgIGlmIChNYXRoLnBvdyh6LCAzKSA+IDAuMDA4ODU2KSB7XG4gICAgICB6ID0gTWF0aC5wb3coeiwgMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSAoeiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICAgIH1cblxuICAgIHJldHVybiBbcmVmWCAqIHgsIHJlZlkgKiB5LCByZWZaICogel07XG4gIH1cblxuICBzdGF0aWMgeHl6MlJHQih4LCB5LCB6KSB7XG4gICAgeCAvPSAxMDA7XG4gICAgeSAvPSAxMDA7XG4gICAgeiAvPSAxMDA7XG4gICAgbGV0IHIgPSB4ICogMy4yNDA2ICsgeSAqIC0xLjUzNzIgKyB6ICogLTAuNDk4NjtcbiAgICBsZXQgZyA9IHggKiAtMC45Njg5ICsgeSAqIDEuODc1OCArIHogKiAwLjA0MTU7XG4gICAgbGV0IGIgPSB4ICogMC4wNTU3ICsgeSAqIC0wLjIwNDAgKyB6ICogMS4wNTcwO1xuXG4gICAgaWYgKHIgPiAwLjAwMzEzMDgpIHtcbiAgICAgIHIgPSAxLjA1NSAqIChNYXRoLnBvdyhyLCAxIC8gMi40KSkgLSAwLjA1NTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IDEyLjkyICogcjtcbiAgICB9XG5cbiAgICBpZiAoZyA+IDAuMDAzMTMwOCkge1xuICAgICAgZyA9IDEuMDU1ICogKE1hdGgucG93KGcsIDEgLyAyLjQpKSAtIDAuMDU1O1xuICAgIH0gZWxzZSB7XG4gICAgICBnID0gMTIuOTIgKiBnO1xuICAgIH1cblxuICAgIGlmIChiID4gMC4wMDMxMzA4KSB7XG4gICAgICBiID0gMS4wNTUgKiAoTWF0aC5wb3coYiwgMSAvIDIuNCkpIC0gMC4wNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSAxMi45MiAqIGI7XG4gICAgfVxuXG4gICAgciA9IHIgKiAyNTU7XG4gICAgZyA9IGcgKiAyNTU7XG4gICAgYiA9IGIgKiAyNTU7XG5cbiAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9XG5cbiAgc3RhdGljIGNpZWxhYjJSR0IobCA9IDUwLCBhID0gMCwgYiA9IDApIHtcbiAgICBpZighKGwgPj0gMCAmJiBsIDw9IDEwMCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB4eXogPSB0aGlzLmNpZWxhYjJYWVoobCwgYSwgYik7XG4gICAgcmV0dXJuIHRoaXMueHl6MlJHQiguLi54eXopO1xuICB9XG5cbn1cbiIsImltcG9ydCBDb3JlVXRpbHMgZnJvbSAnLi9jb3JlLnV0aWxzJztcbmltcG9ydCBWYWxpZGF0b3JzIGZyb20gJy4vY29yZS52YWxpZGF0b3JzJztcblxuLyoqXG4gKiBDb21wdXRlL3Rlc3QgaW50ZXJzZWN0aW9uIGJldHdlZW4gZGlmZmVyZW50IG9iamVjdHMuXG4gKlxuICogQG1vZHVsZSBjb3JlL2ludGVyc2VjdGlvbnNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnNlY3Rpb25zIHtcblxuLyoqXG4gKiBDb21wdXRlIGludGVyc2VjdGlvbiBiZXR3ZWVuIG9yaWVudGVkIGJvdW5kaW5nIGJveCBhbmQgYSBwbGFuZS5cbiAqXG4gKiBSZXR1cm5zIGludGVyc2VjdGlvbiBpbiBwbGFuZSdzIHNwYWNlLlxuICpcbiAqIFNob3VsZCByZXR1cm4gYXQgbGVhc3QgMyBpbnRlcnNlY3Rpb25zLiBJZiBub3QsIHRoZSBwbGFuZSBhbmQgdGhlIGJveCBkbyBub3RcbiAqIGludGVyc2VjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYWFiYiAtIEF4ZSBBbGlnbmVkIEJvdW5kaW5nIEJveCByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gYWFiYi5oYWxmRGltZW5zaW9ucyAtIEhhbGYgZGltZW5zaW9ucyBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBhYWJiLmNlbnRlciAtIENlbnRlciBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtUSFJFRS5NYXRyaXg0fSBhYWJiLnRvQUFCQiAtIFRyYW5zZm9ybSB0byBnbyBmcm9tIHBsYW5lIHNwYWNlIHRvIGJveCBzcGFjZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGFuZSAtIFBsYW5lIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHBsYW5lLnBvc2l0aW9uIC0gcG9zaXRpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcGxhbmUuXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHBsYW5lLmRpcmVjdGlvbiAtIERpcmVjdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSBwbGFuZS5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8VEhSRUUuVmVjdG9yMz59IExpc3Qgb2YgYWxsIGludGVyc2VjdGlvbnMgaW4gcGxhbmUncyBzcGFjZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpcyBpbnZhbGlkIGlucHV0IHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvL1JldHVybnMgYXJyYXkgd2l0aCBpbnRlcnNlY3Rpb24gTiBpbnRlcnNlY3Rpb25zXG4gKiBsZXQgYWFiYiA9IHtcbiAqICAgY2VudGVyOiBuZXcgVEhSRUUuVmVjdG9yMygxNTAsIDE1MCwgMTUwKSxcbiAqICAgaGFsZkRpbWVuc2lvbnM6IG5ldyBUSFJFRS5WZWN0b3IzKDUwLCA2MCwgNzApLFxuICogICB0b0FBQkI6IG5ldyBUSFJFRS5NYXRyaXg0KClcbiAqIH1cbiAqIGxldCBwbGFuZSA9IHtcbiAqICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKDExMCwgMTIwLCAxMzApLFxuICogICBkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApXG4gKiB9XG4gKlxuICogbGV0IGludGVyc2VjdGlvbnMgPSBDb3JlSW50ZXJzZWN0aW9ucy5hYWJiUGxhbmUoYWFiYiwgcGxhbmUpO1xuICogLy8gaW50ZXJzZWN0aW9ucyA9PVxuICogLy9bIHsgeCA6IDExMCwgeSA6IDkwLCAgeiA6IDgwIH0sXG4gKiAvLyAgeyB4IDogMTEwLCB5IDogMjEwLCB6IDogMjIwIH0sXG4gKiAvLyAgeyB4IDogMTEwLCB5IDogMjEwLCB6IDogODAgfSxcbiAqIC8vICB7IHggOiAxMTAsIHkgOiA5MCwgIHogOiAyMjAgfSBdXG4gKlxuICogLy9SZXR1cm5zIGVtcHR5IGFycmF5IHdpdGggMCBpbnRlcnNlY3Rpb25zXG4gKiBsZXQgYWFiYiA9IHtcbiAqXG4gKiB9XG4gKiBsZXQgcGxhbmUgPSB7XG4gKlxuICogfVxuICpcbiAqIGxldCBpbnRlcnNlY3Rpb25zID0gVkpTLkNvcmUuVmFsaWRhdG9ycy5tYXRyaXg0KG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xuICpcbiAqIC8vUmV0dXJucyBmYWxzZSBpZiBpbnZhbGlkIGlucHV0P1xuICpcbiAqL1xuICBzdGF0aWMgYWFiYlBsYW5lKGFhYmIsIHBsYW5lKSB7XG4gICAgLy9cbiAgICAvLyBvYmIgPSB7IGhhbGZEaW1lbnNpb25zLCBvcmllbnRhdGlvbiwgY2VudGVyLCB0b0FBQkIgfVxuICAgIC8vIHBsYW5lID0geyBwb3NpdGlvbiwgZGlyZWN0aW9uIH1cbiAgICAvL1xuICAgIC8vXG4gICAgLy8gTE9HSUM6XG4gICAgLy9cbiAgICAvLyBUZXN0IGludGVyc2VjdGlvbiBvZiBlYWNoIGVkZ2Ugb2YgdGhlIE9yaWVudGVkIEJvdW5kaW5nIEJveCB3aXRoIHRoZSBQbGFuZVxuICAgIC8vXG4gICAgLy8gQUxMIEVER0VTXG4gICAgLy9cbiAgICAvLyAgICAgIC4rLS0tLS0tLStcbiAgICAvLyAgICAuJyB8ICAgICAuJ3xcbiAgICAvLyAgICstLS0rLS0tKycgIHxcbiAgICAvLyAgIHwgICB8ICAgfCAgIHxcbiAgICAvLyAgIHwgICwrLS0tKy0tLStcbiAgICAvLyAgIHwuJyAgICAgfCAuJ1xuICAgIC8vICAgKy0tLS0tLS0rJ1xuICAgIC8vXG4gICAgLy8gU1BBQ0UgT1JJRU5UQVRJT05cbiAgICAvL1xuICAgIC8vICAgICAgICtcbiAgICAvLyAgICAgaiB8XG4gICAgLy8gICAgICAgfFxuICAgIC8vICAgICAgIHwgICBpXG4gICAgLy8gICBrICAsKy0tLS0tLS0rXG4gICAgLy8gICAgLidcbiAgICAvLyAgICtcbiAgICAvL1xuICAgIC8vXG4gICAgLy8gMS0gTW92ZSBQbGFuZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gaW4gSUpLIHNwYWNlXG4gICAgLy8gMi0gVGVzdCBFZGdlcy8gSUpLIFBsYW5lIGludGVyc2VjdGlvbnNcbiAgICAvLyAzLSBSZXR1cm4gaW50ZXJzZWN0aW9uIEVkZ2UvIElKSyBQbGFuZSBpZiBpdCB0b3VjaGVzIHRoZSBPcmllbnRlZCBCQm94XG5cbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy52YWxpZGF0ZUFhYmIoYWFiYikgJiZcbiAgICAgICB0aGlzLnZhbGlkYXRlUGxhbmUocGxhbmUpKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIgb3IgcGxhbmUgcHJvdmlkZWQuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaW52ZXJ0IHNwYWNlIG1hdHJpeFxuICAgIGxldCBmcm9tQUFCQiA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgZnJvbUFBQkIuZ2V0SW52ZXJzZShhYWJiLnRvQUFCQik7XG5cbiAgICBsZXQgdDEgPSBwbGFuZS5kaXJlY3Rpb24uY2xvbmUoKS5hcHBseU1hdHJpeDQoYWFiYi50b0FBQkIpO1xuICAgIGxldCB0MCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLmFwcGx5TWF0cml4NChhYWJiLnRvQUFCQik7XG5cbiAgICBsZXQgcGxhbmVBQUJCID0gdGhpcy5wb3NkaXIoXG4gICAgICBwbGFuZS5wb3NpdGlvbi5jbG9uZSgpLmFwcGx5TWF0cml4NChhYWJiLnRvQUFCQiksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyh0MS54IC0gdDAueCwgdDEueSAtIHQwLnksIHQxLnogLSB0MC56KS5ub3JtYWxpemUoKVxuICAgICk7XG5cbiAgICBsZXQgYmJveCA9IENvcmVVdGlscy5iYm94KGFhYmIuY2VudGVyLCBhYWJiLmhhbGZEaW1lbnNpb25zKTtcblxuICAgIGxldCBvcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpKTtcblxuICAgIC8vIDEyIGVkZ2VzIChpLmUuIHJheSkvcGxhbmUgaW50ZXJzZWN0aW9uIHRlc3RzXG4gICAgLy8gUkFZUyBTVEFSVElORyBGUk9NIFRIRSBGSVJTVCBDT1JORVIgKDAsIDAsIDApXG4gICAgLy9cbiAgICAvLyAgICAgICArXG4gICAgLy8gICAgICAgfFxuICAgIC8vICAgICAgIHxcbiAgICAvLyAgICAgICB8XG4gICAgLy8gICAgICAsKy0tLSstLS0rXG4gICAgLy8gICAgLidcbiAgICAvLyAgICtcblxuICAgIGxldCByYXkgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBhYWJiLmNlbnRlci54IC0gYWFiYi5oYWxmRGltZW5zaW9ucy54LFxuICAgICAgICBhYWJiLmNlbnRlci55IC0gYWFiYi5oYWxmRGltZW5zaW9ucy55LFxuICAgICAgICBhYWJiLmNlbnRlci56IC0gYWFiYi5oYWxmRGltZW5zaW9ucy56KSxcbiAgICAgIG9yaWVudGF0aW9uLnhcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgcmF5LmRpcmVjdGlvbiA9IG9yaWVudGF0aW9uLnk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICByYXkuZGlyZWN0aW9uID0gb3JpZW50YXRpb24uejtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIC8vIFJBWVMgU1RBUlRJTkcgRlJPTSBUSEUgTEFTVCBDT1JORVJcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICAgK1xuICAgIC8vICAgICAgICAgICAgIC4nXG4gICAgLy8gICArLS0tLS0tLSsnXG4gICAgLy8gICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICB8XG4gICAgLy8gICAgICAgICAgICtcbiAgICAvL1xuXG4gICAgbGV0IHJheTIgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBhYWJiLmNlbnRlci54ICsgYWFiYi5oYWxmRGltZW5zaW9ucy54LFxuICAgICAgICBhYWJiLmNlbnRlci55ICsgYWFiYi5oYWxmRGltZW5zaW9ucy55LFxuICAgICAgICBhYWJiLmNlbnRlci56ICsgYWFiYi5oYWxmRGltZW5zaW9ucy56KSxcbiAgICAgIG9yaWVudGF0aW9uLnhcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5MiwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIHJheTIuZGlyZWN0aW9uID0gb3JpZW50YXRpb24ueTtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTIsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICByYXkyLmRpcmVjdGlvbiA9IG9yaWVudGF0aW9uLno7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXkyLCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgLy8gUkFZUyBTVEFSVElORyBGUk9NIFRIRSBTRUNPTkQgQ09STkVSXG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICtcbiAgICAvLyAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICtcbiAgICAvLyAgICAgICAgICAgICAuJ1xuICAgIC8vICAgICAgICAgICArJ1xuXG4gICAgbGV0IHJheTMgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBhYWJiLmNlbnRlci54ICsgYWFiYi5oYWxmRGltZW5zaW9ucy54LFxuICAgICAgICBhYWJiLmNlbnRlci55IC0gYWFiYi5oYWxmRGltZW5zaW9ucy55LFxuICAgICAgICBhYWJiLmNlbnRlci56IC0gYWFiYi5oYWxmRGltZW5zaW9ucy56KSxcbiAgICAgIG9yaWVudGF0aW9uLnlcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5MywgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIHJheTMuZGlyZWN0aW9uID0gb3JpZW50YXRpb24uejtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTMsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICAvLyBSQVlTIFNUQVJUSU5HIEZST00gVEhFIFRISVJEIENPUk5FUlxuICAgIC8vXG4gICAgLy8gICAgICAuKy0tLS0tLS0rXG4gICAgLy8gICAgLidcbiAgICAvLyAgICtcbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuXG4gICAgbGV0IHJheTQgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBhYWJiLmNlbnRlci54IC0gYWFiYi5oYWxmRGltZW5zaW9ucy54LFxuICAgICAgICBhYWJiLmNlbnRlci55ICsgYWFiYi5oYWxmRGltZW5zaW9ucy55LFxuICAgICAgICBhYWJiLmNlbnRlci56IC0gYWFiYi5oYWxmRGltZW5zaW9ucy56KSxcbiAgICAgIG9yaWVudGF0aW9uLnhcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5NCwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIHJheTQuZGlyZWN0aW9uID0gb3JpZW50YXRpb24uejtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTQsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICAvLyBSQVlTIFNUQVJUSU5HIEZST00gVEhFIEZPVVJUSCBDT1JORVJcbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyAgICtcbiAgICAvLyAgIHxcbiAgICAvLyAgIHxcbiAgICAvLyAgIHxcbiAgICAvLyAgICstLS0tLS0tK1xuXG4gICAgbGV0IHJheTUgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBhYWJiLmNlbnRlci54IC0gYWFiYi5oYWxmRGltZW5zaW9ucy54LFxuICAgICAgICBhYWJiLmNlbnRlci55IC0gYWFiYi5oYWxmRGltZW5zaW9ucy55LFxuICAgICAgICBhYWJiLmNlbnRlci56ICsgYWFiYi5oYWxmRGltZW5zaW9ucy56KSxcbiAgICAgIG9yaWVudGF0aW9uLnhcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5NSwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIHJheTUuZGlyZWN0aW9uID0gb3JpZW50YXRpb24ueTtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTUsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICAvLyBAdG9kbyBtYWtlIHN1cmUgb2JqZWN0cyBhcmUgdW5pcXVlLi4uXG5cbiAgICAvLyBiYWNrIHRvIG9yaWdpbmFsIHNwYWNlXG4gICAgaW50ZXJzZWN0aW9ucy5tYXAoXG4gICAgICBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmFwcGx5TWF0cml4NChmcm9tQUFCQik7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbi8qKlxuICogQ29tcHV0ZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBhIHJheSBhbmQgYSBwbGFuZS5cbiAqXG4gKiBAbWVtYmVyT2YgdGhpc1xuICogQHB1YmxpY1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByYXkgLSBSYXkgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHJheS5wb3NpdGlvbiAtIHBvc2l0aW9uIG9mIG5vcm1hbCB3aGljaCBkZXNjcmliZXMgdGhlIHJheS5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcmF5LmRpcmVjdGlvbiAtIERpcmVjdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSByYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gcGxhbmUgLSBQbGFuZSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBwbGFuZS5wb3NpdGlvbiAtIHBvc2l0aW9uIG9mIG5vcm1hbCB3aGljaCBkZXNjcmliZXMgdGhlIHBsYW5lLlxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBwbGFuZS5kaXJlY3Rpb24gLSBEaXJlY3Rpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcGxhbmUuXG4gKlxuICogQHJldHVybnMge1RIUkVFLlZlY3RvcjN8bnVsbH0gSW50ZXJzZWN0aW9uIGJldHdlZW4gcmF5IGFuZCBwbGFuZSBvciBudWxsLlxuICovXG4gIHN0YXRpYyByYXlQbGFuZShyYXksIHBsYW5lKSB7XG4gIC8vIHJheToge3Bvc2l0aW9uLCBkaXJlY3Rpb259XG4gIC8vIHBsYW5lOiB7cG9zaXRpb24sIGRpcmVjdGlvbn1cblxuICBpZiAocmF5LmRpcmVjdGlvbi5kb3QocGxhbmUuZGlyZWN0aW9uKSAhPT0gMCkge1xuICAgIC8vXG4gICAgLy8gbm90IHBhcmFsbGVsLCBtb3ZlIGZvcndhcmRcbiAgICAvL1xuICAgIC8vIExPR0lDOlxuICAgIC8vXG4gICAgLy8gUmF5IGVxdWF0aW9uOiBQID0gUDAgKyB0VlxuICAgIC8vIFAgPSA8UHgsIFB5LCBQej5cbiAgICAvLyBQMCA9IDxyYXkucG9zaXRpb24ueCwgcmF5LnBvc2l0aW9uLnksIHJheS5wb3NpdGlvbi56PlxuICAgIC8vIFYgPSA8cmF5LmRpcmVjdGlvbi54LCByYXkuZGlyZWN0aW9uLnksIHJheS5kaXJlY3Rpb24uej5cbiAgICAvL1xuICAgIC8vIFRoZXJlZm9yZTpcbiAgICAvLyBQeCA9IHJheS5wb3NpdGlvbi54ICsgdCpyYXkuZGlyZWN0aW9uLnhcbiAgICAvLyBQeSA9IHJheS5wb3NpdGlvbi55ICsgdCpyYXkuZGlyZWN0aW9uLnlcbiAgICAvLyBQeiA9IHJheS5wb3NpdGlvbi56ICsgdCpyYXkuZGlyZWN0aW9uLnpcbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyBQbGFuZSBlcXVhdGlvbjogYXggKyBieSArIGN6ICsgZCA9IDBcbiAgICAvLyBhID0gcGxhbmUuZGlyZWN0aW9uLnhcbiAgICAvLyBiID0gcGxhbmUuZGlyZWN0aW9uLnlcbiAgICAvLyBjID0gcGxhbmUuZGlyZWN0aW9uLnpcbiAgICAvLyBkID0gLSggcGxhbmUuZGlyZWN0aW9uLngqcGxhbmUucG9zaXRpb24ueCArXG4gICAgLy8gICAgICAgIHBsYW5lLmRpcmVjdGlvbi55KnBsYW5lLnBvc2l0aW9uLnkgK1xuICAgIC8vICAgICAgICBwbGFuZS5kaXJlY3Rpb24ueipwbGFuZS5wb3NpdGlvbi56IClcbiAgICAvL1xuICAgIC8vXG4gICAgLy8gMS0gaW4gdGhlIHBsYW5lIGVxdWF0aW9uLCB3ZSByZXBsYWNlIHgsIHkgYW5kIHogYnkgUHgsIFB5IGFuZCBQelxuICAgIC8vIDItIGZpbmQgdFxuICAgIC8vIDMtIHJlcGxhY2UgdCBpbiBQeCwgUHkgYW5kIFB6IHRvIGdldCB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgaW50ZXJzZWN0aW9uXG4gICAgLy9cbiAgICBsZXQgdCA9IChwbGFuZS5kaXJlY3Rpb24ueCAqIChwbGFuZS5wb3NpdGlvbi54IC0gcmF5LnBvc2l0aW9uLngpICsgcGxhbmUuZGlyZWN0aW9uLnkgKiAocGxhbmUucG9zaXRpb24ueSAtIHJheS5wb3NpdGlvbi55KSArIHBsYW5lLmRpcmVjdGlvbi56ICogKHBsYW5lLnBvc2l0aW9uLnogLSByYXkucG9zaXRpb24ueikpIC9cbiAgICAgICAgKHBsYW5lLmRpcmVjdGlvbi54ICogcmF5LmRpcmVjdGlvbi54ICsgcGxhbmUuZGlyZWN0aW9uLnkgKiByYXkuZGlyZWN0aW9uLnkgKyBwbGFuZS5kaXJlY3Rpb24ueiAqIHJheS5kaXJlY3Rpb24ueik7XG5cbiAgICBsZXQgaW50ZXJzZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIHJheS5wb3NpdGlvbi54ICsgdCAqIHJheS5kaXJlY3Rpb24ueCxcbiAgICAgICAgcmF5LnBvc2l0aW9uLnkgKyB0ICogcmF5LmRpcmVjdGlvbi55LFxuICAgICAgICByYXkucG9zaXRpb24ueiArIHQgKiByYXkuZGlyZWN0aW9uLnopO1xuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgcmF5IGFuZCBhIGJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmF5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib3hcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgcmF5Qm94KHJheSwgYm94KSB7XG4gICAgLy8gc2hvdWxkIGFsc28gZG8gdGhlIHNwYWNlIHRyYW5zZm9ybXMgaGVyZVxuICAgIC8vIHJheToge3Bvc2l0aW9uLCBkaXJlY3Rpb259XG4gICAgLy8gYm94OiB7aGFsZkRpbWVuc2lvbnMsIGNlbnRlcn1cblxuICAgIGxldCBpbnRlcnNlY3Rpb25zID0gW107XG5cbiAgICBsZXQgYmJveCA9IENvcmVVdGlscy5iYm94KGJveC5jZW50ZXIsIGJveC5oYWxmRGltZW5zaW9ucyk7XG5cbiAgICAvLyB3aW5kb3cuY29uc29sZS5sb2coYmJveCk7XG5cbiAgICAvLyBYIG1pblxuICAgIGxldCBwbGFuZSA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGJib3gubWluLngsXG4gICAgICAgIGJveC5jZW50ZXIueSxcbiAgICAgICAgYm94LmNlbnRlci56KSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKC0xLCAwLCAwKVxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIC8vIFggbWF4XG4gICAgcGxhbmUgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBiYm94Lm1heC54LFxuICAgICAgICBib3guY2VudGVyLnksXG4gICAgICAgIGJveC5jZW50ZXIueiksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKVxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIC8vIFkgbWluXG4gICAgcGxhbmUgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBib3guY2VudGVyLngsXG4gICAgICAgIGJib3gubWluLnksXG4gICAgICAgIGJveC5jZW50ZXIueiksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAtMSwgMClcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZSwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICAvLyBZIG1heFxuICAgIHBsYW5lID0gdGhpcy5wb3NkaXIoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgYm94LmNlbnRlci54LFxuICAgICAgICBiYm94Lm1heC55LFxuICAgICAgICBib3guY2VudGVyLnopLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMClcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZSwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICAvLyBaIG1pblxuICAgIHBsYW5lID0gdGhpcy5wb3NkaXIoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgYm94LmNlbnRlci54LFxuICAgICAgICBib3guY2VudGVyLnksXG4gICAgICAgIGJib3gubWluLnopLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgLTEpXG4gICAgKTtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmUsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgLy8gWiBtYXhcbiAgICBwbGFuZSA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGJveC5jZW50ZXIueCxcbiAgICAgICAgYm94LmNlbnRlci55LFxuICAgICAgICBiYm94Lm1heC56KSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpXG4gICAgKTtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmUsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJzZWN0aW9uIGJldHdlZW4gcmF5IGFuZCBhIHBsYW5lIHRoYXQgYXJlIGluIGEgYm94LlxuICAgKiBAcGFyYW0geyp9IHJheVxuICAgKiBAcGFyYW0geyp9IHBsYW5lQUFCQlxuICAgKiBAcGFyYW0geyp9IGJib3hcbiAgICogQHBhcmFtIHsqfSBpbnRlcnNlY3Rpb25zXG4gICAqL1xuICBzdGF0aWMgcmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpIHtcbiAgICBsZXQgaW50ZXJzZWN0aW9uID0gdGhpcy5yYXlQbGFuZShyYXksIHBsYW5lQUFCQik7XG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGludGVyc2VjdGlvbik7XG4gICAgaWYgKGludGVyc2VjdGlvbiAmJiB0aGlzLmluQkJveChpbnRlcnNlY3Rpb24sIGJib3gpKSB7XG4gICAgICBpZiAoIWludGVyc2VjdGlvbnMuZmluZCh0aGlzLmZpbmRJbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9uKSkpIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgaW50ZXJzZWN0aW9uIGluIGFycmF5XG4gICAqIEBwYXJhbSB7Kn0gbXlpbnRlcnNlY3Rpb25cbiAgICovXG4gIHN0YXRpYyBmaW5kSW50ZXJzZWN0aW9uKG15aW50ZXJzZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZvdW5kKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICAgICAgaWYgKG15aW50ZXJzZWN0aW9uLnggPT09IGVsZW1lbnQueCAmJlxuICAgICAgICBteWludGVyc2VjdGlvbi55ID09PSBlbGVtZW50LnkgJiZcbiAgICAgICAgbXlpbnRlcnNlY3Rpb24ueiA9PT0gZWxlbWVudC56KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyBwb2ludCBpbiBib3guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFxuICAgKiBAcGFyYW0ge09iamVjdH0gYmJveFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGluQkJveChwb2ludCwgYmJveCkge1xuICAgIC8vXG4gICAgbGV0IGVwc2lsb24gPSAwLjAwMDE7XG4gICAgaWYgKHBvaW50ICYmXG4gICAgICAgIHBvaW50LnggPj0gYmJveC5taW4ueCAtIGVwc2lsb24gJiZcbiAgICAgICAgcG9pbnQueSA+PSBiYm94Lm1pbi55IC0gZXBzaWxvbiAmJlxuICAgICAgICBwb2ludC56ID49IGJib3gubWluLnogLSBlcHNpbG9uICYmXG4gICAgICAgIHBvaW50LnggPD0gYmJveC5tYXgueCArIGVwc2lsb24gJiZcbiAgICAgICAgcG9pbnQueSA8PSBiYm94Lm1heC55ICsgZXBzaWxvbiAmJlxuICAgICAgICBwb2ludC56IDw9IGJib3gubWF4LnogKyBlcHNpbG9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIHBvc2Rpcihwb3NpdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHtwb3NpdGlvbiwgZGlyZWN0aW9ufTtcbiAgfVxuXG4gIHN0YXRpYyB2YWxpZGF0ZVBsYW5lKHBsYW5lKSB7XG4gICAgLy9cbiAgICBpZiAocGxhbmUgPT09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBwbGFuZS4nKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhwbGFuZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIVZhbGlkYXRvcnMudmVjdG9yMyhwbGFuZS5wb3NpdGlvbikpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBwbGFuZS5wb3NpdGlvbi4nKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhwbGFuZS5wb3NpdGlvbik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIVZhbGlkYXRvcnMudmVjdG9yMyhwbGFuZS5kaXJlY3Rpb24pKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgcGxhbmUuZGlyZWN0aW9uLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHBsYW5lLmRpcmVjdGlvbik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyB2YWxpZGF0ZUFhYmIoYWFiYikge1xuICAgIC8vXG4gICAgaWYgKGFhYmIgPT09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBhYWJiLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGFhYmIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghVmFsaWRhdG9ycy5tYXRyaXg0KGFhYmIudG9BQUJCKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIudG9BQUJCOiAnKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhYWJiLnRvQUFCQik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIVZhbGlkYXRvcnMudmVjdG9yMyhhYWJiLmNlbnRlcikpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBhYWJiLmNlbnRlci4nKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhYWJiLmNlbnRlcik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIShWYWxpZGF0b3JzLnZlY3RvcjMoYWFiYi5oYWxmRGltZW5zaW9ucykgJiZcbiAgICAgICBhYWJiLmhhbGZEaW1lbnNpb25zLnggPj0gMCAmJlxuICAgICAgIGFhYmIuaGFsZkRpbWVuc2lvbnMueSA+PSAwICYmXG4gICAgICAgYWFiYi5oYWxmRGltZW5zaW9ucy56ID49IDApKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgYWFiYi5oYWxmRGltZW5zaW9ucy4nKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhYWJiLmhhbGZEaW1lbnNpb25zKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cbiIsImltcG9ydCBDb2xvcnMgZnJvbSAnLi9jb3JlLmNvbG9ycyc7XG5pbXBvcnQgSW50ZXJzZWN0aW9ucyBmcm9tICcuL2NvcmUuaW50ZXJzZWN0aW9ucyc7XG5pbXBvcnQgUGFjayBmcm9tICcuL2NvcmUucGFjayc7XG5pbXBvcnQgVmFsaWRhdG9ycyBmcm9tICcuL2NvcmUudmFsaWRhdG9ycyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9jb3JlLnV0aWxzJztcblxuLyoqXG4gKiBAbW9kdWxlIGNvcmVcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBDb2xvcnMsXG4gIEludGVyc2VjdGlvbnMsXG4gIFV0aWxzLFxuICBWYWxpZGF0b3JzLFxufTtcbiIsIi8qKlxuICogUGFja2luZyBmdW5jdGlvbnMuXG4gKlxuICogQG1vZHVsZSBjb3JlL3BhY2sgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFjayB7XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICAvLyBzdGF0aWMgcGFja1RvOEJpdHNUZXh0dXJlKGJpdHMsIGNoYW5uZWxzLCBmcmFtZSwgdGV4dHVyZVNpemUsIHN0YXJ0Vm94ZWwsIHN0b3BWb3hlbCkge1xuICAvLyAgIGxldCBwYWNrZWQgPSB7XG4gIC8vICAgICB0ZXh0dXJlVHlwZTogbnVsbCxcbiAgLy8gICAgIGRhdGE6IG51bGxcbiAgLy8gICB9O1xuXG4gIC8vICAgbGV0IHBhY2tJbmRleCA9IDA7XG4gIC8vICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAvLyAgIGxldCBpbkZyYW1lSW5kZXggPSAwO1xuICAvLyAgIGxldCBmcmFtZURpbWVuc2lvbiA9IGZyYW1lWzBdLnJvd3MgKiBmcmFtZVswXS5jb2x1bW5zO1xuICAvLyAgIGxldCBkYXRhID0gbnVsbDtcblxuICAvLyAgIGlmIChiaXRzID09PSA4ICYmIGNoYW5uZWxzID09PSAxKSB7XG4gIC8vICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiAxKTtcbiAgLy8gICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xuICAvLyAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcbiAgLy8gICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IHRydWUqL1xuXG4gIC8vICAgICAgIGRhdGFbcGFja0luZGV4XSA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdO1xuICAvLyAgICAgICBwYWNrSW5kZXgrKztcblxuICAvLyAgICAgfVxuICAvLyAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuUkdCRm9ybWF0O1xuICAvLyAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xuICAvLyAgIH0gZWxzZSBpZiAoYml0cyA9PT0gMTYgJiYgY2hhbm5lbHMgPT09IDEpIHtcbiAgLy8gICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDIpO1xuICAvLyAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXG4gIC8vICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAvLyAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogdHJ1ZSovXG5cbiAgLy8gICAgICAgLy8gc2xvdyFcbiAgLy8gICAgICAgLy9sZXQgYXNiID0gVkpTLmNvcmUucGFjay51aW50MTZUb0FscGhhTHVtaW5hbmNlKGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdKTtcbiAgLy8gICAgICAgbGV0IHJhdyA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdO1xuXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cbiAgLy8gICAgICAgbGV0IGxzYiA9IHJhdyAmIDB4MDBGRjtcbiAgLy8gICAgICAgbGV0IG1zYiA9IChyYXcgPj4+IDgpICYgMHgwMEZGO1xuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cbiAgLy8gICAgICAgZGF0YVsyICogcGFja0luZGV4XSA9IGxzYjtcbiAgLy8gICAgICAgZGF0YVsyICogcGFja0luZGV4ICsgMV0gPSBtc2I7XG4gIC8vICAgICAgIHBhY2tJbmRleCsrO1xuICAvLyAgICAgfVxuICAvLyAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQ7XG4gIC8vICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XG4gIC8vICAgfSBlbHNlIGlmIChiaXRzID09PSAzMiAmJiBjaGFubmVscyA9PT0gMSkge1xuXG4gIC8vICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiA0KTtcbiAgLy8gICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xuICAvLyAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcbiAgLy8gICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IHRydWUqL1xuXG4gIC8vICAgICAgIC8vIHNsb3chXG4gIC8vICAgICAgIC8vbGV0IGFzYiA9IFZKUy5jb3JlLnBhY2sudWludDE2VG9BbHBoYUx1bWluYW5jZShmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XSk7XG4gIC8vICAgICAgIGxldCByYXcgPSBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcblxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXG4gIC8vICAgICAgIGxldCBiMCA9IHJhdyAmIDB4MDAwMDAwRkY7XG4gIC8vICAgICAgIGxldCBiMSA9IChyYXcgPj4+IDgpICYgMHgwMDAwMDBGRjtcbiAgLy8gICAgICAgbGV0IGIyID0gKHJhdyA+Pj4gOCkgJiAweDAwMDAwMEZGO1xuICAvLyAgICAgICBsZXQgYjMgPSAocmF3ID4+PiA4KSAmIDB4MDAwMDAwRkY7XG4gIC8vICAgICAgIC8vIGxldCBsc2IxID0gcmF3ICYgMHhGRjtcbiAgLy8gICAgICAgLy8gbGV0IG1zYjEgPSAocmF3ID4+IDgpICYgMHhGRjtcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogdHJ1ZSovXG4gIC8vICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleF0gPSBiMDtcbiAgLy8gICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMV0gPSBiMTtcbiAgLy8gICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMl0gPSBiMjtcbiAgLy8gICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgM10gPSBiMztcbiAgLy8gICAgICAgcGFja0luZGV4Kys7XG4gIC8vICAgICB9XG4gIC8vICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JBRm9ybWF0O1xuICAvLyAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xuICAvLyAgIH0gZWxzZSBpZiAoYml0cyA9PT0gOCAmJiBjaGFubmVscyA9PT0gMykge1xuICAvLyAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlU2l6ZSAqIHRleHR1cmVTaXplICogMyk7XG4gIC8vICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cbiAgLy8gICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XG4gIC8vICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cblxuICAvLyAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXhdID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXhdO1xuICAvLyAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXggKyAxXSA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVszICogaW5GcmFtZUluZGV4ICsgMV07XG4gIC8vICAgICAgIGRhdGFbMyAqIHBhY2tJbmRleCArIDJdID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXggKyAyXTtcbiAgLy8gICAgICAgcGFja0luZGV4Kys7XG5cbiAgLy8gICAgIH1cbiAgLy8gICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLkx1bWluYW5jZUZvcm1hdDtcbiAgLy8gICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcbiAgLy8gICB9XG5cbiAgLy8gICByZXR1cm4gcGFja2VkO1xuXG4gIC8vIH1cbn1cblxuLy8gJ3VzZSBzdHJpY3QnO1xuXG4vLyB2YXIgVkpTID0gVkpTIHx8IHt9O1xuLy8gVkpTLmNvcmUgPSBWSlMuY29yZSB8fCB7fTtcblxuLy8gLyoqXG4vLyAgKiBAY29uc3RydWN0b3Jcbi8vICAqIEBjbGFzc1xuLy8gICogQG1lbWJlck9mIFZKUy5jb3JlXG4vLyAgKiBAcHVibGljXG4vLyAqL1xuLy8gVkpTLmNvcmUucGFjayA9IFZKUy5jb3JlLnBhY2sgfHwge307XG5cbi8vIC8vIERlYWwgd2l0aCBlbmRpYW5lc3Ncbi8vIC8vIGRvIG5vdCBhZGQgYSBpZiB0aGVyZSBhZiBpcyBpcyBzbG93IGluIGJvZyBsb29wc1xuLy8gLy8gYWRkIG1vcmUgZnVuY3Rpb25zXG4vLyBWSlMuY29yZS5wYWNrLnVpbnQxNlRvQWxwaGFMdW1pbmFuY2UgPSBmdW5jdGlvbih1aW50MTYsIGFiKSB7XG4vLyAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cbi8vICAgdmFyIGxzYiA9IHVpbnQxNiAmIDB4RkY7XG4vLyAgIHZhciBtc2IgPSAodWludDE2ID4+IDgpICYgMHhGRjtcbi8vICAgLypqc2hpbnQgYml0d2lzZTogdHJ1ZSovXG4vLyAgIGFiID0gW2xzYiwgbXNiXTtcbi8vIH07XG5cbi8vIFZKUy5jb3JlLnBhY2sudWludDhUb0x1bWluYW5jZSA9IGZ1bmN0aW9uKHVpbnQ4KSB7XG4vLyAgIHJldHVybiB1aW50ODtcbi8vIH07XG5cbi8vIFZKUy5jb3JlLnBhY2sudWludDhWM1RvUkdCID0gZnVuY3Rpb24odWludDhWMykge1xuLy8gICByZXR1cm4gdWludDhWMztcbi8vIH07XG5cbi8vIC8qKiogRXhwb3J0cyAqKiovXG5cbi8vIHZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbi8vIGlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4vLyAgIG1vZHVsZS5leHBvcnRzID0gVkpTLmNvcmUucGFjaztcbi8vIH1cbiIsImNvbnN0IFVSTCA9IHJlcXVpcmUoJ3VybCcpO1xuaW1wb3J0IFZhbGlkYXRvcnMgZnJvbSAnLi9jb3JlLnZhbGlkYXRvcnMnO1xuXG4vKipcbiAqIEdlbmVyYWwgcHVycG9zZSBmdW5jdGlvbnMuXG4gKlxuICogQG1vZHVsZSBjb3JlL3V0aWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVVdGlscyB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgYm91ZGluZyBib3ggb2JqZWN0LlxuICAgKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGNlbnRlciAtIENlbnRlciBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGhhbGZEaW1lbnNpb25zIC0gSGFsZiBEaW1lbnNpb25zIG9mIHRoZSBib3guXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGJvdW5kaW5nIGJveCBvYmplY3QuIHtPYmplY3QubWlufSBpcyBhIHtUSFJFRS5WZWN0b3IzfVxuICAgKiBjb250YWluaW5nIHRoZSBtaW4gYm91bmRzLiB7T2JqZWN0Lm1heH0gaXMgYSB7VEhSRUUuVmVjdG9yM30gY29udGFpbmluZyB0aGVcbiAgICogbWF4IGJvdW5kcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UgaW5wdXQgTk9UIHZhbGlkLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBSZXR1cm5zXG4gICAqIC8veyBtaW46IHsgeCA6IDAsIHkgOiAwLCAgeiA6IDAgfSxcbiAgICogLy8gIG1heDogeyB4IDogMiwgeSA6IDQsICB6IDogNiB9XG4gICAqIC8vfVxuICAgKiBWSlMuQ29yZS5VdGlscy5iYm94KFxuICAgKiAgIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDIsIDMpLCBuZXcgVEhSRUUuVmVjdG9yMygxLCAyLCAzKSk7XG4gICAqXG4gICAqIC8vUmV0dXJucyBmYWxzZVxuICAgKiBWSlMuQ29yZS5VdGlscy5iYm94KG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5NYXRyaXg0KCkpO1xuICAgKlxuICAgKi9cbiAgc3RhdGljIGJib3goY2VudGVyLCBoYWxmRGltZW5zaW9ucykge1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHZhbGlkIGlucHV0c1xuICAgIGlmICghKFZhbGlkYXRvcnMudmVjdG9yMyhjZW50ZXIpICYmXG4gICAgICBWYWxpZGF0b3JzLnZlY3RvcjMoaGFsZkRpbWVuc2lvbnMpKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGNlbnRlciBvciBwbGFuZSBoYWxmRGltZW5zaW9ucy4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgaGFsZiBkaW1lbnNpb25zIGFyZSA+PSAwXG4gICAgaWYgKCEoaGFsZkRpbWVuc2lvbnMueCA+PSAwICYmXG4gICAgICBoYWxmRGltZW5zaW9ucy55ID49IDAgJiZcbiAgICAgIGhhbGZEaW1lbnNpb25zLnogPj0gMCkpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnaGFsZkRpbWVuc2lvbnMgbXVzdCBiZSA+PSAwLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGhhbGZEaW1lbnNpb25zKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBtaW4vbWF4IGJvdW5kXG4gICAgbGV0IG1pbiA9IGNlbnRlci5jbG9uZSgpLnN1YihoYWxmRGltZW5zaW9ucyk7XG4gICAgbGV0IG1heCA9IGNlbnRlci5jbG9uZSgpLmFkZChoYWxmRGltZW5zaW9ucyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmluZCBtaW4vbWF4IHZhbHVlcyBpbiBhbiBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1pbk1heChkYXRhID0gW10pIHtcbiAgICBsZXQgbWluTWF4ID0gWzY1NTM1LCAtMzI3NjhdO1xuICAgIGxldCBudW1QaXhlbHMgPSBkYXRhLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBudW1QaXhlbHM7IGluZGV4KyspIHtcbiAgICAgIGxldCBzcHYgPSBkYXRhW2luZGV4XTtcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgc3B2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluTWF4O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIEhUTUxFbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9ialxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRWxlbWVudChvYmopIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNpbmcgVzMgRE9NMiAod29ya3MgZm9yIEZGLCBPcGVyYSBhbmQgQ2hyb20pXG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gQnJvd3NlcnMgbm90IHN1cHBvcnRpbmcgVzMgRE9NMiBkb24ndCBoYXZlIEhUTUxFbGVtZW50IGFuZFxuICAgICAgLy8gYW4gZXhjZXB0aW9uIGlzIHRocm93biBhbmQgd2UgZW5kIHVwIGhlcmUuIFRlc3Rpbmcgc29tZVxuICAgICAgLy8gcHJvcGVydGllcyB0aGF0IGFsbCBlbGVtZW50cyBoYXZlLiAod29ya3Mgb24gSUU3KVxuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgKG9iai5ub2RlVHlwZSA9PT0gMSkgJiYgKHR5cGVvZiBvYmouc3R5bGUgPT09ICdvYmplY3QnKSAmJlxuICAgICAgICAodHlwZW9mIG9iai5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB1cmxcbiAgICogQHBhcmFtIHsqfSB1cmxcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIHBhcnNlVXJsKHVybCkge1xuICAgIC8vXG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGRhdGEuZmlsZW5hbWUgPSAnJztcbiAgICBkYXRhLmV4dGVuc2lvbiA9ICcnO1xuICAgIGRhdGEucGF0aG5hbWUgPSAnJztcbiAgICBkYXRhLnF1ZXJ5ID0gJyc7XG5cbiAgICBsZXQgcGFyc2VkVXJsID0gVVJMLnBhcnNlKHVybCk7XG4gICAgZGF0YS5wYXRobmFtZSA9IHBhcnNlZFVybC5wYXRobmFtZTtcbiAgICBkYXRhLnF1ZXJ5ID0gcGFyc2VkVXJsLnF1ZXJ5O1xuXG4gICAgLy8gZ2V0IGZpbGUgbmFtZVxuICAgIGRhdGEuZmlsZW5hbWUgPSBkYXRhLnBhdGhuYW1lLnNwbGl0KCcvJykucG9wKCk7XG5cbiAgICAvLyBmaW5kIGV4dGVuc2lvblxuICAgIGxldCBzcGxpdHRlZE5hbWUgPSBkYXRhLmZpbGVuYW1lLnNwbGl0KCcuJyk7XG4gICAgaWYgKHNwbGl0dGVkTmFtZS5sZW5ndGggPD0gMSkge1xuICAgICAgZGF0YS5leHRlbnNpb24gPSAnZGljb20nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLmV4dGVuc2lvbiA9IGRhdGEuZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGRhdGEuZXh0ZW5zaW9uKSkge1xuICAgICAgZGF0YS5leHRlbnNpb24gPSAnZGljb20nO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnF1ZXJ5ICYmXG4gICAgICBkYXRhLnF1ZXJ5LmluY2x1ZGVzKCdjb250ZW50VHlwZT1hcHBsaWNhdGlvbiUyRmRpY29tJykpIHtcbiAgICAgIGRhdGEuZXh0ZW5zaW9uID0gJ2RpY29tJztcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIElKSyB0byBMUFMgdHJhbmZvcm0uXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0geENvc1xuICAgKiBAcGFyYW0geyp9IHlDb3NcbiAgICogQHBhcmFtIHsqfSB6Q29zXG4gICAqIEBwYXJhbSB7Kn0gc3BhY2luZ1xuICAgKiBAcGFyYW0geyp9IG9yaWdpblxuICAgKiBAcGFyYW0geyp9IHJlZ2lzdHJhdGlvbk1hdHJpeFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3RhdGljIGlqazJMUFMoXG4gICAgeENvcywgeUNvcywgekNvcyxcbiAgICBzcGFjaW5nLCBvcmlnaW4sXG4gICAgcmVnaXN0cmF0aW9uTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSkge1xuICAgIGNvbnN0IGlqazJMUFMgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIGlqazJMUFMuc2V0KFxuICAgICAgeENvcy54ICogc3BhY2luZy54LCB5Q29zLnggKiBzcGFjaW5nLnksIHpDb3MueCAqIHNwYWNpbmcueiwgb3JpZ2luLngsXG4gICAgICB4Q29zLnkgKiBzcGFjaW5nLngsIHlDb3MueSAqIHNwYWNpbmcueSwgekNvcy55ICogc3BhY2luZy56LCBvcmlnaW4ueSxcbiAgICAgIHhDb3MueiAqIHNwYWNpbmcueCwgeUNvcy56ICogc3BhY2luZy55LCB6Q29zLnogKiBzcGFjaW5nLnosIG9yaWdpbi56LFxuICAgICAgMCwgMCwgMCwgMSk7XG4gICAgaWprMkxQUy5wcmVtdWx0aXBseShyZWdpc3RyYXRpb25NYXRyaXgpO1xuXG4gICAgcmV0dXJuIGlqazJMUFM7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBBQUJCIHRvIExQUyB0cmFuc2Zvcm0uXG4gICAqIEFBQkI6IEF4ZSBBbGlnbmVkIEJvdW5kaW5nIEJveC5cbiAgICogQHBhcmFtIHsqfSB4Q29zXG4gICAqIEBwYXJhbSB7Kn0geUNvc1xuICAgKiBAcGFyYW0geyp9IHpDb3NcbiAgICogQHBhcmFtIHsqfSBvcmlnaW5cbiAgICovXG4gIHN0YXRpYyBhYWJiMkxQUyhcbiAgICB4Q29zLCB5Q29zLCB6Q29zLFxuICAgIG9yaWdpbikge1xuICAgIGNvbnN0IGFhYmIyTFBTID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICBhYWJiMkxQUy5zZXQoXG4gICAgICAgIHhDb3MueCwgeUNvcy54LCB6Q29zLngsIG9yaWdpbi54LFxuICAgICAgICB4Q29zLnksIHlDb3MueSwgekNvcy55LCBvcmlnaW4ueSxcbiAgICAgICAgeENvcy56LCB5Q29zLnosIHpDb3Mueiwgb3JpZ2luLnosXG4gICAgICAgIDAsIDAsIDAsIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBjb29yZGluYXRlcyBmcm9tIHdvcmxkIGNvb3JkaW5hdGUgdG8gZGF0YVxuICAgKlxuICAgKiBAcGFyYW0geyp9IGxwczJJSktcbiAgICogQHBhcmFtIHsqfSB3b3JsZENvb3JkaW5hdGVzXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICAgIHN0YXRpYyB3b3JsZFRvRGF0YShscHMySUpLLCB3b3JsZENvb3JkaW5hdGVzKSB7XG4gICAgbGV0IGRhdGFDb29yZGluYXRlID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgICAgLmNvcHkod29ybGRDb29yZGluYXRlcylcbiAgICAgIC5hcHBseU1hdHJpeDQobHBzMklKSyk7XG5cbiAgICAvLyBzYW1lIHJvdW5kaW5nIGluIHRoZSBzaGFkZXJzXG4gICAgZGF0YUNvb3JkaW5hdGUuYWRkU2NhbGFyKDAuNSkuZmxvb3IoKTtcblxuICAgIHJldHVybiBkYXRhQ29vcmRpbmF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdm94ZWwgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGFja1xuICAgKiBAcGFyYW0geyp9IGNvb3JkaW5hdGVcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN0YXRpYyB2YWx1ZShzdGFjaywgY29vcmRpbmF0ZSkge1xuICAgIGlmIChjb29yZGluYXRlLnogPj0gMCAmJlxuICAgICAgICBjb29yZGluYXRlLnogPCBzdGFjay5fZnJhbWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3RhY2suX2ZyYW1lW2Nvb3JkaW5hdGUuel0uXG4gICAgICAgIHZhbHVlKGNvb3JkaW5hdGUueCwgY29vcmRpbmF0ZS55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHNsb3BlL2ludGVyY2VwdCB0byBhIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBzbG9wZVxuICAgKiBAcGFyYW0geyp9IGludGVyY2VwdFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3RhdGljIHJlc2NhbGVTbG9wZUludGVyY2VwdCh2YWx1ZSwgc2xvcGUsIGludGVyY2VwdCkge1xuICAgIHJldHVybiB2YWx1ZSAqIHNsb3BlICsgaW50ZXJjZXB0O1xuICB9XG5cbn1cbiIsIi8qKlxuICogVmFsaWRhdGUgYmFzaWMgc3RydWN0dXJlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy9SZXR1cm5zIHRydWVcbiAqIFZKUy5Db3JlLlZhbGlkYXRvcnMubWF0cml4NChuZXcgVEhSRUUuTWF0cml4NCgpKTtcbiAqXG4gKiAvL1JldHVybnMgZmFsc2VcbiAqIFZKUy5Db3JlLlZhbGlkYXRvcnMubWF0cml4NChuZXcgVEhSRUUuVmVjdG9yMygpKTtcbiAqXG4gKiBAbW9kdWxlIGNvcmUvdmFsaWRhdG9yc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhbGlkYXRvcnMge1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYSBtYXRyaXggYXMgYSBUSFJFRUpTLk1hdHJpeDRcbiAgICogbGlua1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0VG9UZXN0IC0gVGhlIG9iamVjdCB0byBiZSB0ZXN0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsaWQgTWF0cml4NCwgZmFsc2UgaWYgTk9ULlxuICAgKi9cbiAgc3RhdGljIG1hdHJpeDQob2JqZWN0VG9UZXN0KSB7XG4gICAgaWYoIShvYmplY3RUb1Rlc3QgIT09IG51bGwgJiZcbiAgICAgICB0eXBlb2Ygb2JqZWN0VG9UZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgnZWxlbWVudHMnKSAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5lbGVtZW50cy5sZW5ndGggPT09IDE2ICYmXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdC5pZGVudGl0eSA9PT0gJ2Z1bmN0aW9uJyYmXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdC5jb3B5ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdC5kZXRlcm1pbmFudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAqIFZhbGlkYXRlcyBhIHZlY3RvciBhcyBhIFRIUkVFSlMuVmVjdG9yM1xuICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RUb1Rlc3QgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIFZlY3RvcjMsIGZhbHNlIGlmIE5PVC5cbiAgKi9cbiAgc3RhdGljIHZlY3RvcjMob2JqZWN0VG9UZXN0KSB7XG4gICAgaWYoIShvYmplY3RUb1Rlc3QgIT09IG51bGwgJiZcbiAgICAgICB0eXBlb2Ygb2JqZWN0VG9UZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgneCcpICYmXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCd5JykgJiZcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ3onKSAmJlxuICAgICAgICFvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ3cnKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gLyoqXG4gICogVmFsaWRhdGVzIGEgYm94LlxuICAqXG4gICogQGV4YW1wbGVcbiAgKiAvLyBhIGJveCBpcyBkZWZpbmVkIGFzXG4gICogbGV0IGJveCA9IHtcbiAgKiAgIGNlbnRlcjogVEhSRUUuVmVjdG9yMyxcbiAgKiAgIGhhbGZEaW1lbnNpb25zOiBUSFJFRS5WZWN0b3IzXG4gICogfVxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFRvVGVzdCAtIFRoZSBvYmplY3QgdG8gYmUgdGVzdGVkLlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsaWQgYm94LCBmYWxzZSBpZiBOT1QuXG4gICovXG4gIHN0YXRpYyBib3gob2JqZWN0VG9UZXN0KSB7XG4gICAgaWYoIShvYmplY3RUb1Rlc3QgIT09IG51bGwgJiZcbiAgICAgICB0eXBlb2Ygb2JqZWN0VG9UZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgnY2VudGVyJykgJiZcbiAgICAgICB0aGlzLnZlY3RvcjMob2JqZWN0VG9UZXN0LmNlbnRlcikgJiZcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ2hhbGZEaW1lbnNpb25zJykgJiZcbiAgICAgICB0aGlzLnZlY3RvcjMob2JqZWN0VG9UZXN0LmhhbGZEaW1lbnNpb25zKSAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5oYWxmRGltZW5zaW9ucy54ID49IDAgJiZcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFsZkRpbWVuc2lvbnMueSA+PSAwICYmXG4gICAgICAgb2JqZWN0VG9UZXN0LmhhbGZEaW1lbnNpb25zLnogPj0gMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gLyoqXG4gICogVmFsaWRhdGVzIGEgcmF5LlxuICAqXG4gICogQGV4YW1wbGVcbiAgKiAvLyBhIHJheSBpcyBkZWZpbmVkIGFzXG4gICogbGV0IHJheSA9IHtcbiAgKiAgIHBvc3Rpb246IFRIUkVFLlZlY3RvcjMsXG4gICogICBkaXJlY3Rpb246IFRIUkVFLlZlY3RvcjNcbiAgKiB9XG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0VG9UZXN0IC0gVGhlIG9iamVjdCB0byBiZSB0ZXN0ZWQuXG4gICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCByYXksIGZhbHNlIGlmIE5PVC5cbiAgKi9cbiAgc3RhdGljIHJheShvYmplY3RUb1Rlc3QpIHtcbiAgICBpZighKG9iamVjdFRvVGVzdCAhPT0gbnVsbCAmJlxuICAgICAgIHR5cGVvZiBvYmplY3RUb1Rlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCdwb3NpdGlvbicpICYmXG4gICAgICAgdGhpcy52ZWN0b3IzKG9iamVjdFRvVGVzdC5wb3NpdGlvbikgJiZcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ2RpcmVjdGlvbicpICYmXG4gICAgICAgdGhpcy52ZWN0b3IzKG9iamVjdFRvVGVzdC5kaXJlY3Rpb24pKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCJpbXBvcnQgU2xpY2UgZnJvbSAnLi9nZW9tZXRyaWVzLnNsaWNlJztcbmltcG9ydCBWb3hlbCBmcm9tICcuL2dlb21ldHJpZXMudm94ZWwnO1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VvbWV0cmllc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgU2xpY2UsXG4gIFZveGVsLFxufTtcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IGNvcmVJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcblxuLyoqXG4gKlxuICogSXQgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIGNyZWF0aW5nIGFuIGlycmVndWxhciAzRCBwbGFuYXIgc2hhcGUgZ2l2ZW4gYSBib3ggYW5kIHRoZSBjdXQtcGxhbmUuXG4gKlxuICogRGVtbzoge0BsaW5rIGh0dHBzOi8vZm5uZHNjLmdpdGh1Yi5pby92anMjZ2VvbWV0cnlfc2xpY2V9XG4gKlxuICogQG1vZHVsZSBnZW9tZXRyaWVzL3NsaWNlXG4gKlxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBoYWxmRGltZW5zaW9ucyAtIEhhbGYtZGltZW5zaW9ucyBvZiB0aGUgYm94IHRvIGJlIHNsaWNlZC5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gY2VudGVyIC0gQ2VudGVyIG9mIHRoZSBib3ggdG8gYmUgc2xpY2VkLlxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzPFRIUkVFLlZlY3RvcjM+fSBvcmllbnRhdGlvbiAtIE9yaWVudGF0aW9uIG9mIHRoZSBib3ggdG8gYmUgc2xpY2VkLiAobWlnaHQgbm90IGJlIG5lY2Vzc2FyeS4uPylcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcG9zaXRpb24gLSBQb3NpdGlvbiBvZiB0aGUgY3V0dGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gZGlyZWN0aW9uIC0gQ3Jvc3MgZGlyZWN0aW9uIG9mIHRoZSBjdXR0aW5nIHBsYW5lLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBEZWZpbmUgYm94IHRvIGJlIHNsaWNlZFxuICogbGV0IGhhbGZEaW1lbnNpb25zID0gbmV3IFRIUkVFLlZlY3RvcigxMjMsIDQ1LCA2Nyk7XG4gKiBsZXQgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG4gKiBsZXQgb3JpZW50YXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApLFxuICogICBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKVxuICogKTtcbiAqXG4gKiAvLyBEZWZpbmUgc2xpY2UgcGxhbmVcbiAqIGxldCBwb3NpdGlvbiA9IGNlbnRlci5jbG9uZSgpO1xuICogbGV0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKC0wLjIsIDAuNSwgMC4zKTtcbiAqXG4gKiAvLyBDcmVhdGUgdGhlIHNsaWNlIGdlb21ldHJ5ICYgbWF0ZXJpYWxzXG4gKiBsZXQgc2xpY2VHZW9tZXRyeSA9IG5ldyBWSlMuZ2VvbWV0cmllcy5zbGljZShoYWxmRGltZW5zaW9ucywgY2VudGVyLCBvcmllbnRhdGlvbiwgcG9zaXRpb24sIGRpcmVjdGlvbik7XG4gKiBsZXQgc2xpY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICdzaWRlJzogVEhSRUUuRG91YmxlU2lkZSxcbiAqICAgJ2NvbG9yJzogMHhGRjU3MjJcbiAqIH0pO1xuICpcbiAqICAvLyBDcmVhdGUgbWVzaCBhbmQgYWRkIGl0IHRvIHRoZSBzY2VuZVxuICogIGxldCBzbGljZSA9IG5ldyBUSFJFRS5NZXNoKHNsaWNlR2VvbWV0cnksIHNsaWNlTWF0ZXJpYWwpO1xuICogIHNjZW5lLmFkZChzbGljZSk7XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvbWV0cmllc1NsaWNlIGV4dGVuZHMgVEhSRUUuU2hhcGVHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IoaGFsZkRpbWVuc2lvbnMsIGNlbnRlciwgcG9zaXRpb24sIGRpcmVjdGlvbiwgdG9BQUJCID0gbmV3IFRIUkVFLk1hdHJpeDQoKSkge1xuICAgICAgLy9cbiAgICAgIC8vIHByZXBhcmUgZGF0YSBmb3IgdGhlIHNoYXBlIVxuICAgICAgLy9cbiAgICAgIGxldCBhYWJiID0ge1xuICAgICAgICBoYWxmRGltZW5zaW9ucyxcbiAgICAgICAgY2VudGVyLFxuICAgICAgICB0b0FBQkIsXG4gICAgICB9O1xuXG4gICAgICBsZXQgcGxhbmUgPSB7XG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICB9O1xuXG4gICAgICAvLyBCT09NIVxuICAgICAgbGV0IGludGVyc2VjdGlvbnMgPSBjb3JlSW50ZXJzZWN0aW9ucy5hYWJiUGxhbmUoYWFiYiwgcGxhbmUpO1xuXG4gICAgICAvLyBjYW4gbm90IGV4aXN0IGJlZm9yZSBjYWxsaW5nIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoIDwgMykge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1dBUk5JTkc6IExlc3MgdGhhbiAzIGludGVyc2VjdGlvbnMgYmV0d2VlbiBBQUJCIGFuZCBQbGFuZS4nKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdBQUJCJyk7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhYWJiKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdQbGFuZScpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cocGxhbmUpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2V4aXRpbmcuLi4nKTtcbiAgICAgICAgLy8gb3IgdGhyb3cgZXJyb3I/XG4gICAgICAgIHRocm93ICdnZW9tZXRyaWVzLnNsaWNlIGhhcyBsZXNzIHRoYW4gMyBpbnRlcnNlY3Rpb25zLCBjYW4gbm90IGNyZWF0ZSBhIHZhbGlkIGdlb21ldHJ5Lic7XG4gICAgICB9XG5cbiAgICAgIGxldCBvcmRlcmVkSW50ZXJzZWN0aW9ucyA9IEdlb21ldHJpZXNTbGljZS5vcmRlckludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgZGlyZWN0aW9uKTtcbiAgICAgIGxldCBzbGljZVNoYXBlID0gR2VvbWV0cmllc1NsaWNlLnNoYXBlKG9yZGVyZWRJbnRlcnNlY3Rpb25zKTtcblxuICAgICAgLy9cbiAgICAgIC8vIEdlbmVyYXRlIEdlb21ldHJ5IGZyb20gc2hhcGVcbiAgICAgIC8vIEl0IGRvZXMgdHJpYW5ndWxhdGlvbiBmb3IgdXMhXG4gICAgICAvL1xuICAgICAgc3VwZXIoc2xpY2VTaGFwZSk7XG4gICAgICB0aGlzLnR5cGUgPSAnU2xpY2VHZW9tZXRyeSc7XG5cbiAgICAgIC8vIHVwZGF0ZSByZWFsIHBvc2l0aW9uIG9mIGVhY2ggdmVydGV4ISAobm90IGluIDJkKVxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG9yZGVyZWRJbnRlcnNlY3Rpb25zO1xuICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBzaGFwZShwb2ludHMpIHtcbiAgICAgIC8vXG4gICAgICAvLyBDcmVhdGUgU2hhcGVcbiAgICAgIC8vXG4gICAgICBsZXQgc2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICAgIC8vIG1vdmUgdG8gZmlyc3QgcG9pbnQhXG4gICAgICBzaGFwZS5tb3ZlVG8ocG9pbnRzWzBdLnh5LngsIHBvaW50c1swXS54eS55KTtcblxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBwb2ludHMhXG4gICAgICBmb3IgKGxldCBsID0gMTsgbCA8IHBvaW50cy5sZW5ndGg7IGwrKykge1xuICAgICAgICAvLyBwcm9qZWN0IGVhY2ggb24gcGxhbmUhXG4gICAgICAgIHNoYXBlLmxpbmVUbyhwb2ludHNbbF0ueHkueCwgcG9pbnRzW2xdLnh5LnkpO1xuICAgICAgfVxuXG4gICAgICAvLyBjbG9zZSB0aGUgc2hhcGUhXG4gICAgICBzaGFwZS5saW5lVG8ocG9pbnRzWzBdLnh5LngsIHBvaW50c1swXS54eS55KTtcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG5cbiAvKipcbiAgKlxuICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGV4dHJhY3QgY2VudGVyIG9mIG1hc3MgZnJvbSBsaXN0IG9mIHBvaW50cy5cbiAgKlxuICAqIEBwcml2YXRlXG4gICpcbiAgKiBAcGFyYW0ge0FycmF5PFRIUkVFLlZlY3RvcjM+fSBwb2ludHMgLSBTZXQgb2YgcG9pbnRzIGZyb20gd2hpY2ggd2Ugd2FudCB0byBleHRyYWN0IHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgKlxuICAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfSBDZW50ZXIgb2YgbWFzcyBmcm9tIGdpdmVuIHBvaW50cy5cbiAgKi9cbiAgc3RhdGljIGNlbnRlck9mTWFzcyhwb2ludHMpIHtcbiAgICBsZXQgY2VudGVyT2ZNYXNzID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNlbnRlck9mTWFzcy54ICs9IHBvaW50c1tpXS54O1xuICAgICAgY2VudGVyT2ZNYXNzLnkgKz0gcG9pbnRzW2ldLnk7XG4gICAgICBjZW50ZXJPZk1hc3MueiArPSBwb2ludHNbaV0uejtcbiAgICB9XG4gICAgY2VudGVyT2ZNYXNzLmRpdmlkZVNjYWxhcihwb2ludHMubGVuZ3RoKTtcblxuICAgIHJldHVybiBjZW50ZXJPZk1hc3M7XG4gIH1cblxuIC8qKlxuICAqXG4gICogT3JkZXIgM0QgcGxhbmFyIHBvaW50cyBhcm91bmQgYSByZWZlbmNlIHBvaW50LlxuICAqXG4gICogQHByaXZhdGVcbiAgKlxuICAqIEBwYXJhbSB7QXJyYXk8VEhSRUUuVmVjdG9yMz59IHBvaW50cyAtIFNldCBvZiBwbGFuYXIgM0QgcG9pbnRzIHRvIGJlIG9yZGVyZWQuXG4gICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBkaXJlY3Rpb24gLSBEaXJlY3Rpb24gb2YgdGhlIHBsYW5lIGluIHdoaWNoIHBvaW50cyBhbmQgcmVmZXJlbmNlIGFyZSBzaXR0aW5nLlxuICAqXG4gICogQHJldHVybnMge0FycmF5PE9iamVjdD59IFNldCBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBvcmRlcmVkIHBvaW50cy5cbiAgKi9cbiAgc3RhdGljIG9yZGVySW50ZXJzZWN0aW9ucyhwb2ludHMsIGRpcmVjdGlvbikge1xuICAgIGxldCByZWZlcmVuY2UgPSBHZW9tZXRyaWVzU2xpY2UuY2VudGVyT2ZNYXNzKHBvaW50cyk7XG4gICAgLy8gZGlyZWN0aW9uIGZyb20gZmlyc3QgcG9pbnQgdG8gcmVmZXJlbmNlXG4gICAgbGV0IHJlZmVyZW5jZURpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgcG9pbnRzWzBdLnggLSByZWZlcmVuY2UueCxcbiAgICAgIHBvaW50c1swXS55IC0gcmVmZXJlbmNlLnksXG4gICAgICBwb2ludHNbMF0ueiAtIHJlZmVyZW5jZS56XG4gICAgICApLm5vcm1hbGl6ZSgpO1xuXG4gICAgbGV0IGJhc2UgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKVxuICAgICAgICAuY3Jvc3NWZWN0b3JzKHJlZmVyZW5jZURpcmVjdGlvbiwgZGlyZWN0aW9uKVxuICAgICAgICAubm9ybWFsaXplKCk7XG5cbiAgICBsZXQgb3JkZXJlZHBvaW50cyA9IFtdO1xuXG4gICAgLy8gb3RoZXIgbGluZXMgLy8gaWYgaW50ZXIsIHJldHVybiBsb2NhdGlvbiArIGFuZ2xlXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBwb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBwb2ludHNbal0ueCxcbiAgICAgICAgcG9pbnRzW2pdLnksXG4gICAgICAgIHBvaW50c1tqXS56KTtcbiAgICAgIHBvaW50LmRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBwb2ludHNbal0ueCAtIHJlZmVyZW5jZS54LFxuICAgICAgICBwb2ludHNbal0ueSAtIHJlZmVyZW5jZS55LFxuICAgICAgICBwb2ludHNbal0ueiAtIHJlZmVyZW5jZS56KS5ub3JtYWxpemUoKTtcblxuICAgICAgbGV0IHggPSByZWZlcmVuY2VEaXJlY3Rpb24uZG90KHBvaW50LmRpcmVjdGlvbik7XG4gICAgICBsZXQgeSA9IGJhc2UuZG90KHBvaW50LmRpcmVjdGlvbik7XG4gICAgICBwb2ludC54eSA9IHt4LCB5fTtcblxuICAgICAgbGV0IHRoZXRhID0gTWF0aC5hdGFuMih5LCB4KSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgIHBvaW50LmFuZ2xlID0gdGhldGE7XG5cbiAgICAgIG9yZGVyZWRwb2ludHMucHVzaChwb2ludCk7XG4gICAgfVxuXG4gICAgb3JkZXJlZHBvaW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmFuZ2xlIC0gYi5hbmdsZTtcbiAgICB9KTtcblxuICAgIGxldCBub0R1cHMgPSBbb3JkZXJlZHBvaW50c1swXV07XG4gICAgbGV0IGVwc2lsb24gPSAwLjAwMDE7XG4gICAgZm9yKGxldCBpPTE7IGk8b3JkZXJlZHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoTWF0aC5hYnMob3JkZXJlZHBvaW50c1tpLTFdLmFuZ2xlIC0gb3JkZXJlZHBvaW50c1tpXS5hbmdsZSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIG5vRHVwcy5wdXNoKG9yZGVyZWRwb2ludHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub0R1cHM7XG4gIH1cblxufVxuIiwiLyoqXG4gKlxuICogQG1vZHVsZSBnZW9tZXRyaWVzL3ZveGVsXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvbWV0cmllc1ZveGVsIGV4dGVuZHMgVEhSRUUuQm94R2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihkYXRhUG9zaXRpb24pIHtcbiAgICBzdXBlcigxLCAxLCAxKTtcblxuICAgIHRoaXMuX2xvY2F0aW9uID0gZGF0YVBvc2l0aW9uO1xuXG4gICAgdGhpcy5hcHBseU1hdHJpeChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbihcbiAgICAgIHRoaXMuX2xvY2F0aW9uLngsXG4gICAgICB0aGlzLl9sb2NhdGlvbi55LFxuICAgICAgdGhpcy5fbG9jYXRpb24ueikpO1xuXG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgcmVzZXRWZXJ0aWNlcygpIHtcbiAgICB0aGlzLnZlcnRpY2VzWzBdLnNldCgwLjUsIDAuNSwgMC41KTtcbiAgICB0aGlzLnZlcnRpY2VzWzFdLnNldCgwLjUsIDAuNSwgLTAuNSk7XG4gICAgdGhpcy52ZXJ0aWNlc1syXS5zZXQoMC41LCAtMC41LCAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbM10uc2V0KDAuNSwgLTAuNSwgLTAuNSk7XG4gICAgdGhpcy52ZXJ0aWNlc1s0XS5zZXQoLTAuNSwgMC41LCAtMC41KTtcbiAgICB0aGlzLnZlcnRpY2VzWzVdLnNldCgtMC41LCAwLjUsIDAuNSk7XG4gICAgdGhpcy52ZXJ0aWNlc1s2XS5zZXQoLTAuNSwgLTAuNSwgLTAuNSk7XG4gICAgdGhpcy52ZXJ0aWNlc1s3XS5zZXQoLTAuNSwgLTAuNSwgMC41KTtcbiAgfVxuXG4gIHNldCBsb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XG5cbiAgICAvLyB1cGRhdGUgdmVydGljZXMgZnJvbSBsb2NhdGlvblxuICAgIHRoaXMudmVydGljZXNbMF0uc2V0KCsgMC41LCArIDAuNSwgKyAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbMV0uc2V0KCsgMC41LCArIDAuNSwgLSAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbMl0uc2V0KCsgMC41LCAtIDAuNSwgKyAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbM10uc2V0KCsgMC41LCAtIDAuNSwgLSAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbNF0uc2V0KC0gMC41LCArIDAuNSwgLSAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbNV0uc2V0KC0gMC41LCArIDAuNSwgKyAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbNl0uc2V0KC0gMC41LCAtIDAuNSwgLSAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbN10uc2V0KC0gMC41LCAtIDAuNSwgKyAwLjUpO1xuXG4gICAgdGhpcy5hcHBseU1hdHJpeChcbiAgICAgIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKFxuICAgICAgICB0aGlzLl9sb2NhdGlvbi54LFxuICAgICAgICB0aGlzLl9sb2NhdGlvbi55LFxuICAgICAgICB0aGlzLl9sb2NhdGlvbi56KSk7XG5cbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBnZXQgbG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uO1xuICB9XG5cblxufVxuIiwiLyoqICogSW1wb3J0cyAqKiovXG5cbi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2JvcmRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzQm9yZGVyIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3RvcihoZWxwZXJzU2xpY2UpIHtcbiAgICAvL1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9oZWxwZXJzU2xpY2UgPSBoZWxwZXJzU2xpY2U7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9jb2xvciA9IDB4ZmYwMDAwO1xuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG4gIHNldCBoZWxwZXJzU2xpY2UoaGVscGVyc1NsaWNlKSB7XG4gICAgdGhpcy5faGVscGVyc1NsaWNlID0gaGVscGVyc1NsaWNlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGhlbHBlcnNTbGljZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVscGVyc1NsaWNlO1xuICB9XG5cbiAgc2V0IHZpc2libGUodmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgIGlmICh0aGlzLl9tZXNoKSB7XG4gICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IGNvbG9yKGNvbG9yKSB7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgfVxuXG4gIF9jcmVhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogdGhpcy5fY29sb3IsXG4gICAgICAgIGxpbmV3aWR0aDogMSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vXG4gICAgaWYgKCF0aGlzLl9oZWxwZXJzU2xpY2UuZ2VvbWV0cnkudmVydGljZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGVscGVyc1NsaWNlLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hlbHBlcnNTbGljZS5nZW9tZXRyeS52ZXJ0aWNlc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGVscGVyc1NsaWNlLmdlb21ldHJ5LnZlcnRpY2VzWzBdKTtcblxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgIGlmICh0aGlzLl9oZWxwZXJzU2xpY2UuYWFiYlNwYWNlID09PSAnSUpLJykge1xuICAgICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9oZWxwZXJzU2xpY2Uuc3RhY2suaWprMkxQUyk7XG4gICAgfVxuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG5cbiAgICAvLyBhbmQgYWRkIGl0IVxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICAvLyB1cGRhdGUgc2xpY2VcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvYm91bmRpbmdib3hcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzQm91bmRpbmdCb3ggZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG4gIGNvbnN0cnVjdG9yKHN0YWNrKSB7XG4gICAgLy9cbiAgICBzdXBlcigpO1xuXG4gICAgLy8gcHJpdmF0ZSB2YXJzXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9jb2xvciA9IDB4RkZGRkZGO1xuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICAvLyBjcmVhdGUgb2JqZWN0XG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cblxuICAvLyBnZXR0ZXJzL3NldHRlcnNcbiAgc2V0IHZpc2libGUodmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgIGlmICh0aGlzLl9tZXNoKSB7XG4gICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IGNvbG9yKGNvbG9yKSB7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuICBfY3JlYXRlKCkge1xuICAgIC8vIENvbnZlbmllbmNlIHZhcnNcbiAgICBsZXQgZGltZW5zaW9ucyA9IHRoaXMuX3N0YWNrLmRpbWVuc2lvbnNJSks7XG4gICAgbGV0IGhhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XG4gICAgbGV0IG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKC0wLjUsIC0wLjUsIC0wLjUpO1xuXG4gICAgLy8gR2VvbWV0cnlcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcbiAgICAgIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLnopO1xuICAgIC8vIHBvc2l0aW9uIGJib3ggaW4gaW1hZ2Ugc3BhY2VcbiAgICB0aGlzLl9nZW9tZXRyeSAuYXBwbHlNYXRyaXgobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oXG4gICAgICBoYWxmRGltZW5zaW9ucy54ICsgb2Zmc2V0LngsXG4gICAgICBoYWxmRGltZW5zaW9ucy55ICsgb2Zmc2V0LnksXG4gICAgICBoYWxmRGltZW5zaW9ucy56ICsgb2Zmc2V0LnopKTtcblxuXG4gICAgLy8gTWVzaFxuICAgIGxldCBib3hNZXNoID1cbiAgICAgIG5ldyBUSFJFRS5NZXNoKHRoaXMuX2dlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoMHhmZjAwMDApKTtcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLkJveEhlbHBlcihib3hNZXNoLCB0aGlzLl9jb2xvcik7XG5cbiAgICAvLyBNYXRlcmlhbFxuICAgIHRoaXMuX21hdGVyaWFsID0gdGhpcy5fbWVzaC5tYXRlcmlhbDtcblxuICAgIC8vIHBvc2l0aW9uIGJib3ggaW4gd29ybGQgc3BhY2VcbiAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX3N0YWNrLmlqazJMUFMpO1xuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG5cbiAgICAvLyBhbmQgYWRkIGl0IVxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICAvLyB1cGRhdGUgc2xpY2VcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgdGhpcy5fbWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9tZXNoLm1hdGVyaWFsID0gbnVsbDtcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gIH1cbn1cbiIsImltcG9ydCBCb3JkZXIgZnJvbSAnLi9oZWxwZXJzLmJvcmRlcic7XG5pbXBvcnQgQm91bmRpbmdCb3ggZnJvbSAnLi9oZWxwZXJzLmJvdW5kaW5nYm94JztcbmltcG9ydCBMb2NhbGl6ZXIgZnJvbSAnLi9oZWxwZXJzLmxvY2FsaXplcic7XG5pbXBvcnQgTHV0IGZyb20gJy4vaGVscGVycy5sdXQnO1xuaW1wb3J0IFByb2dyZXNzQmFyIGZyb20gJy4vaGVscGVycy5wcm9ncmVzc2Jhcic7XG5pbXBvcnQgUHJvZ3Jlc3NCYXJFdmVudEJhc2VkIGZyb20gJy4vaGVscGVycy5wcm9ncmVzc2Jhci5ldmVudGJhc2VkJztcbmltcG9ydCBTbGljZSBmcm9tICcuL2hlbHBlcnMuc2xpY2UnO1xuaW1wb3J0IFN0YWNrIGZyb20gJy4vaGVscGVycy5zdGFjayc7XG5pbXBvcnQgVm9sdW1lUmVuZGVyaW5nIGZyb20gJy4vaGVscGVycy52b2x1bWVyZW5kZXJpbmcnO1xuaW1wb3J0IFggZnJvbSAnLi94L2hlbHBlcnMueCc7XG5cbi8qKlxuICogQG1vZHVsZSBoZWxwZXJzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBCb3JkZXIsXG4gIEJvdW5kaW5nQm94LFxuICBMb2NhbGl6ZXIsXG4gIEx1dCxcbiAgUHJvZ3Jlc3NCYXIsXG4gIFByb2dyZXNzQmFyRXZlbnRCYXNlZCxcbiAgU2xpY2UsXG4gIFN0YWNrLFxuICBWb2x1bWVSZW5kZXJpbmcsXG4gIFgsXG59O1xuIiwiLyoqICogSW1wb3J0cyAqKiovXG5pbXBvcnQgU2hhZGVyc1VuaWZvcm0gZnJvbVxuICAnLi4vc2hhZGVycy9zaGFkZXJzLmxvY2FsaXplci51bmlmb3JtJztcbmltcG9ydCBTaGFkZXJzVmVydGV4IGZyb21cbiAgJy4uL3NoYWRlcnMvc2hhZGVycy5sb2NhbGl6ZXIudmVydGV4JztcbmltcG9ydCBTaGFkZXJzRnJhZ21lbnQgZnJvbVxuICAnLi4vc2hhZGVycy9zaGFkZXJzLmxvY2FsaXplci5mcmFnbWVudCc7XG5cbi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2xvY2FsaXplclxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNMb2NhbGl6ZXIgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG4gIGNvbnN0cnVjdG9yKHN0YWNrLCBnZW9tZXRyeSwgcmVmZXJlbmNlUGxhbmUpIHtcbiAgICAvL1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuX3JlZmVyZW5jZVBsYW5lID0gcmVmZXJlbmNlUGxhbmU7XG4gICAgdGhpcy5fcGxhbmUxID0gbnVsbDtcbiAgICB0aGlzLl9jb2xvcjEgPSBudWxsO1xuICAgIHRoaXMuX3BsYW5lMiA9IG51bGw7XG4gICAgdGhpcy5fY29sb3IyID0gbnVsbDtcbiAgICB0aGlzLl9wbGFuZTMgPSBudWxsO1xuICAgIHRoaXMuX2NvbG9yMyA9IG51bGw7XG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XG4gICAgdGhpcy5fc2hhZGVyc0ZyYWdtZW50ID0gU2hhZGVyc0ZyYWdtZW50O1xuICAgIHRoaXMuX3NoYWRlcnNWZXJ0ZXggPSBTaGFkZXJzVmVydGV4O1xuICAgIHRoaXMuX3VuaWZvcm1zID0gU2hhZGVyc1VuaWZvcm0udW5pZm9ybXMoKTtcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgX2NyZWF0ZSgpIHtcbiAgICB0aGlzLl9wcmVwYXJlTWF0ZXJpYWwoKTtcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcbiAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX3N0YWNrLl9pamsyTFBTKTtcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcbiAgfVxuXG4gIF9wcmVwYXJlTWF0ZXJpYWwoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGVyaWFsKSB7XG4gICAgICAvLyByZWZlcmVuY2UgcGxhbmVcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVTbGljZS52YWx1ZSA9IHRoaXMuX3JlZmVyZW5jZVBsYW5lO1xuXG4gICAgICAvLyBsb2NhbGl6ZXIgcGxhbmVzXG4gICAgICBpZiAodGhpcy5fcGxhbmUxKSB7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZTEudmFsdWUgPSB0aGlzLl9wbGFuZTE7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZUNvbG9yMS52YWx1ZSA9IHRoaXMuX2NvbG9yMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BsYW5lMikge1xuICAgICAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmUyLnZhbHVlID0gdGhpcy5fcGxhbmUyO1xuICAgICAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmVDb2xvcjIudmFsdWUgPSB0aGlzLl9jb2xvcjI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wbGFuZTMpIHtcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lMy52YWx1ZSA9IHRoaXMuX3BsYW5lMztcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lQ29sb3IzLnZhbHVlID0gdGhpcy5fY29sb3IzO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc1dpZHRoLnZhbHVlID0gdGhpcy5fY2FudmFzV2lkdGg7XG4gICAgICB0aGlzLl91bmlmb3Jtcy51Q2FudmFzSGVpZ2h0LnZhbHVlID0gdGhpcy5fY2FudmFzSGVpZ2h0O1xuXG4gICAgICAvLyBnZW5lcmF0ZSBtYXRlcmlhbFxuICAgICAgbGV0IGZzID0gbmV3IFNoYWRlcnNGcmFnbWVudCh0aGlzLl91bmlmb3Jtcyk7XG4gICAgICBsZXQgdnMgPSBuZXcgU2hhZGVyc1ZlcnRleCgpO1xuICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoXG4gICAgICAgIHtzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuICAgICAgICAgdW5pZm9ybXM6IHRoaXMuX3VuaWZvcm1zLFxuICAgICAgICAgdmVydGV4U2hhZGVyOiB2cy5jb21wdXRlKCksXG4gICAgICAgICBmcmFnbWVudFNoYWRlcjogZnMuY29tcHV0ZSgpLFxuICAgICAgICB9KTtcbiAgICAgIHRoaXMuX21hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX21lc2gpIHtcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuX21lc2gpO1xuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5ID0gbnVsbDtcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuXG4gIHNldCBnZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cblxuICBnZXQgcmVmZXJlbmNlUGxhbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmVyZW5jZVBsYW5lO1xuICB9XG5cbiAgc2V0IHJlZmVyZW5jZVBsYW5lKHJlZmVyZW5jZVBsYW5lKSB7XG4gICAgdGhpcy5fcmVmZXJlbmNlUGxhbmUgPSByZWZlcmVuY2VQbGFuZTtcbiAgICB0aGlzLl91bmlmb3Jtcy51U2xpY2UudmFsdWUgPSB0aGlzLl9yZWZlcmVuY2VQbGFuZTtcbiAgfVxuXG4gIGdldCBwbGFuZTEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lMTtcbiAgfVxuXG4gIHNldCBwbGFuZTEocGxhbmUxKSB7XG4gICAgdGhpcy5fcGxhbmUxID0gcGxhbmUxO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZTEudmFsdWUgPSB0aGlzLl9wbGFuZTE7XG4gIH1cblxuICBnZXQgY29sb3IxKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjE7XG4gIH1cblxuICBzZXQgY29sb3IxKGNvbG9yMSkge1xuICAgIHRoaXMuX2NvbG9yMSA9IGNvbG9yMTtcbiAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmVDb2xvcjEudmFsdWUgPSB0aGlzLl9jb2xvcjE7XG4gIH1cblxuICBnZXQgcGxhbmUyKCkge1xuICAgIHJldHVybiB0aGlzLl9wbGFuZTI7XG4gIH1cblxuICBzZXQgcGxhbmUyKHBsYW5lMikge1xuICAgIHRoaXMuX3BsYW5lMiA9IHBsYW5lMjtcbiAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmUyLnZhbHVlID0gdGhpcy5fcGxhbmUyO1xuICB9XG5cbiAgZ2V0IGNvbG9yMigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3IyO1xuICB9XG5cbiAgc2V0IGNvbG9yMihjb2xvcjIpIHtcbiAgICB0aGlzLl9jb2xvcjIgPSBjb2xvcjI7XG4gICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lQ29sb3IyLnZhbHVlID0gdGhpcy5fY29sb3IyO1xuICB9XG5cbiAgZ2V0IHBsYW5lMygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxhbmUzO1xuICB9XG5cbiAgc2V0IHBsYW5lMyhwbGFuZTMpIHtcbiAgICB0aGlzLl9wbGFuZTMgPSBwbGFuZTM7XG4gICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lMy52YWx1ZSA9IHRoaXMuX3BsYW5lMztcbiAgfVxuXG4gIGdldCBjb2xvcjMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yMztcbiAgfVxuXG4gIHNldCBjb2xvcjMoY29sb3IzKSB7XG4gICAgdGhpcy5fY29sb3IzID0gY29sb3IzO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZUNvbG9yMy52YWx1ZSA9IHRoaXMuX2NvbG9yMztcbiAgfVxuXG4gIGdldCBjYW52YXNXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzV2lkdGg7XG4gIH1cblxuICBzZXQgY2FudmFzV2lkdGgoY2FudmFzV2lkdGgpIHtcbiAgICB0aGlzLl9jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNXaWR0aC52YWx1ZSA9IHRoaXMuX2NhbnZhc1dpZHRoO1xuICB9XG5cbiAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzSGVpZ2h0O1xuICB9XG5cbiAgc2V0IGNhbnZhc0hlaWdodChjYW52YXNIZWlnaHQpIHtcbiAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc0hlaWdodC52YWx1ZSA9IHRoaXMuX2NhbnZhc0hlaWdodDtcbiAgfVxufVxuIiwiXG4vKipcbiAqIEBtb2R1bGUgaGVscGVycy9sdXRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzTHV0IHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVySUQsXG4gICAgICAgICAgICAgIGx1dCA9ICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgbHV0TyA9ICdsaW5lYXInLFxuICAgICAgICAgICAgICBjb2xvciA9IFtbMCwgMCwgMCwgMF0sIFsxLCAxLCAxLCAxXV0sXG4gICAgICAgICAgICAgIG9wYWNpdHkgPSBbWzAsIDBdLCBbMSwgMV1dLFxuICAgICAgICAgICAgICBkaXNjcmV0ZSA9IGZhbHNlKSB7XG4gICAgLy8gbWluL21heCAoMC0xIG9yIHJlYWwgaW50ZW5zaXRpZXMpXG4gICAgLy8gc2hvdy9oaWRlXG4gICAgLy8gaG9yaXpvbnRhbC92ZXJ0aWNhbFxuICAgIHRoaXMuX2NvbnRhaW5lcklEID0gY29udGFpbmVySUQ7XG5cbiAgICB0aGlzLl9kaXNjcmV0ZSA9IGRpc2NyZXRlO1xuICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy5fbHV0ID0gbHV0O1xuICAgIHRoaXMuX2x1dHMgPSB7W2x1dF06IGNvbG9yfTtcblxuICAgIHRoaXMuX29wYWNpdHkgPSBvcGFjaXR5O1xuICAgIHRoaXMuX2x1dE8gPSBsdXRPO1xuICAgIHRoaXMuX2x1dHNPID0ge1tsdXRPXTogb3BhY2l0eX07XG5cbiAgICB0aGlzLmluaXRDYW52YXMoKTtcbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIC8vIGNvbnRhaW5lclxuICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lciA9IHRoaXMuaW5pdENhbnZhc0NvbnRhaW5lcih0aGlzLl9jb250YWluZXJJRCk7XG4gICAgLy8gYmFja2dyb3VuZFxuICAgIHRoaXMuX2NhbnZhc0JnID0gdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzQmcpO1xuICAgIC8vIGZvcmVncm91bmRcbiAgICB0aGlzLl9jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuICB9XG5cbiAgaW5pdENhbnZhc0NvbnRhaW5lcihjYW52YXNDb250YWluZXJJZCkge1xuICAgIGxldCBjYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNDb250YWluZXJJZCk7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gJzI1NiBweCc7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMjggcHgnO1xuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICNGOUY5RjknO1xuICAgIHJldHVybiBjYW52YXNDb250YWluZXI7XG4gIH1cblxuICBjcmVhdGVDYW52YXMoKSB7XG4gICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxNjtcbiAgICBjYW52YXMud2lkdGggPSAyNTY7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIHBhaW50Q2FudmFzKCkge1xuICAgIC8vIHNldHVwIGNvbnRleHRcbiAgICBsZXQgY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgLy8gYXBwbHkgY29sb3JcbiAgICBpZiAoIXRoaXMuX2Rpc2NyZXRlKSB7XG4gICAgICBsZXQgY29sb3IgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY29sb3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29sb3IuYWRkQ29sb3JTdG9wKHRoaXMuX2NvbG9yW2ldWzBdLCBgcmdiYSggJHtNYXRoLnJvdW5kKHRoaXMuX2NvbG9yW2ldWzFdICogMjU1KX0sICR7TWF0aC5yb3VuZCh0aGlzLl9jb2xvcltpXVsyXSAqIDI1NSl9LCAke01hdGgucm91bmQodGhpcy5fY29sb3JbaV1bM10gKiAyNTUpfSwgMSlgKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lV2lkdGg9Mip0aGlzLl9jYW52YXMuaGVpZ2h0O1xuXG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fY29sb3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSB0aGlzLl9jb2xvcltpXVswXTtcbiAgICAgICAgbGV0IG5leHRQb3MgPSAxO1xuICAgICAgICBpZiAoaSA8IHRoaXMuX2NvbG9yLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBuZXh0UG9zID0gdGhpcy5fY29sb3JbaSsxXVswXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldmlvdXNQb3MgPSAwO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBwcmV2aW91c1BvcyA9IHRoaXMuX2NvbG9yW2ktMV1bMF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZnJvbSA9IHByZXZpb3VzUG9zICsgKGN1cnJlbnRQb3MgLSBwcmV2aW91c1BvcykvMjtcbiAgICAgICAgbGV0IHRvID0gY3VycmVudFBvcyArIChuZXh0UG9zIC0gY3VycmVudFBvcykvMjtcbiAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5fY29sb3JbaV07XG4gICAgICAgIGxldCBvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eVtpXSA/IHRoaXMuX29wYWNpdHlbaV1bMV0gOiAxO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYHJnYmEoICR7TWF0aC5yb3VuZChjb2xvclsxXSAqIDI1NSl9LCAke01hdGgucm91bmQoY29sb3JbMl0gKiAyNTUpfSwgJHtNYXRoLnJvdW5kKGNvbG9yWzNdICogMjU1KX0sICR7b3BhY2l0eX0pYDtcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tKnRoaXMuX2NhbnZhcy53aWR0aCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8odG8qdGhpcy5fY2FudmFzLndpZHRoLCAwKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kaXNjcmV0ZSkge1xuICAgICAgLy8gaWYgZGlzY3JldGUsIHdlIGFscmVhZHkgdG9vayBjYXJlIG9mIHRoZSBvcGFjaXR5LlxuICAgICAgLy8gc2V0dXAgY29udGV4dFxuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG5cbiAgICAgIC8vIGFwcGx5IG9wYWNpdHlcbiAgICAgIGxldCBvcGFjaXR5ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX29wYWNpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3BhY2l0eS5hZGRDb2xvclN0b3AodGhpcy5fb3BhY2l0eVtpXVswXSwgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgJyArIHRoaXMuX29wYWNpdHlbaV1bMV0gKyAnKScpO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wYWNpdHk7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBnZXQgdGV4dHVyZSgpIHtcbiAgICBsZXQgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKHRoaXMuX2NhbnZhcyk7XG4gICAgdGV4dHVyZS5tYXBwaW5nID0gVEhSRUUuVVZNYXBwaW5nO1xuICAgIHRleHR1cmUud3JhcFMgPSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcbiAgICB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSB0cnVlO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG5cbiAgc2V0IGx1dCh0YXJnZXRMVVQpIHtcbiAgICB0aGlzLl9jb2xvciA9IHRoaXMuX2x1dHNbdGFyZ2V0TFVUXTtcbiAgICB0aGlzLl9sdXQgPSB0YXJnZXRMVVQ7XG5cbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XG4gIH1cblxuICBnZXQgbHV0KCkge1xuICAgIHJldHVybiB0aGlzLl9sdXQ7XG4gIH1cblxuICBzZXQgbHV0cyhuZXdMdXRzKSB7XG4gICAgdGhpcy5fbHV0cyA9IG5ld0x1dHM7XG4gIH1cblxuICBnZXQgbHV0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbHV0cztcbiAgfVxuXG4gIHNldCBsdXRPKHRhcmdldExVVE8pIHtcbiAgICB0aGlzLl9vcGFjaXR5ID0gdGhpcy5fbHV0c09bdGFyZ2V0TFVUT107XG4gICAgdGhpcy5fbHV0TyA9IHRhcmdldExVVE87XG5cbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XG4gIH1cblxuICBnZXQgbHV0TygpIHtcbiAgICByZXR1cm4gdGhpcy5fbHV0TztcbiAgfVxuXG4gIHNldCBsdXRzTyhuZXdMdXRzTykge1xuICAgIHRoaXMuX2x1dHNPID0gbmV3THV0c087XG4gIH1cblxuICBnZXQgbHV0c08oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2x1dHNPO1xuICB9XG5cbiAgc2V0IGRpc2NyZXRlKGRpc2NyZXRlKSB7XG4gICAgdGhpcy5fZGlzY3JldGUgPSBkaXNjcmV0ZTtcblxuICAgIHRoaXMucGFpbnRDYW52YXMoKTtcbiAgfVxuXG4gIGdldCBkaXNjcmV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzY3JldGU7XG4gIH1cblxuICBsdXRzQXZhaWxhYmxlKHR5cGUgPSAnY29sb3InKSB7XG4gICAgbGV0IGF2YWlsYWJsZSA9IFtdO1xuICAgIGxldCBsdXRzID0gdGhpcy5fbHV0cztcblxuICAgIGlmICh0eXBlICE9PSAnY29sb3InKSB7XG4gICAgICBsdXRzID0gdGhpcy5fbHV0c087XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSBpbiBsdXRzKSB7XG4gICAgICBhdmFpbGFibGUucHVzaChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXZhaWxhYmxlO1xuICB9XG5cbiAgLy8gYWRkIGx1dHMgdG8gY2xhc3MnIGx1dCAoc28gYSB1c2VyIGNhbiBhZGQgaXRzIG93biBhcyB3ZWxsKVxuICBzdGF0aWMgcHJlc2V0THV0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2RlZmF1bHQnOiBbWzAsIDAsIDAsIDBdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ3NwZWN0cnVtJzogW1swLCAwLCAwLCAwXSwgWzAuMSwgMCwgMCwgMV0sIFswLjMzLCAwLCAxLCAxXSwgWzAuNSwgMCwgMSwgMF0sIFswLjY2LCAxLCAxLCAwXSwgWzAuOSwgMSwgMCwgMF0sIFsxLCAxLCAxLCAxXV0sXG4gICAgICAnaG90X2FuZF9jb2xkJzogW1swLCAwLCAwLCAxXSwgWzAuMTUsIDAsIDEsIDFdLCBbMC4zLCAwLCAxLCAwXSwgWzAuNDUsIDAsIDAsIDBdLCBbMC41LCAwLCAwLCAwXSwgWzAuNTUsIDAsIDAsIDBdLCBbMC43LCAxLCAxLCAwXSwgWzAuODUsIDEsIDAsIDBdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ2dvbGQnOiBbWzAsIDAsIDAsIDBdLCBbMC4xMywgMC4xOSwgMC4wMywgMF0sIFswLjI1LCAwLjM5LCAwLjEyLCAwXSwgWzAuMzgsIDAuNTksIDAuMjYsIDBdLCBbMC41MCwgMC44MCwgMC40NiwgMC4wOF0sIFswLjYzLCAwLjk5LCAwLjcxLCAwLjIxXSwgWzAuNzUsIDAuOTksIDAuODgsIDAuMzRdLCBbMC44OCwgMC45OSwgMC45OSwgMC40OF0sIFsxLCAwLjkwLCAwLjk1LCAwLjYxXV0sXG4gICAgICAncmVkJzogW1swLCAwLjc1LCAwLCAwXSwgWzAuNSwgMSwgMC41LCAwXSwgWzAuOTUsIDEsIDEsIDBdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ2dyZWVuJzogW1swLCAwLCAwLjc1LCAwXSwgWzAuNSwgMC41LCAxLCAwXSwgWzAuOTUsIDEsIDEsIDBdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ2JsdWUnOiBbWzAsIDAsIDAsIDFdLCBbMC41LCAwLCAwLjUsIDFdLCBbMC45NSwgMCwgMSwgMV0sIFsxLCAxLCAxLCAxXV0sXG4gICAgICAnd2Fsa2luZ19kZWFkJzogW1swLCAwLjEsIDEsIDFdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ3JhbmRvbSc6IFtbMCwgMCwgMCwgMF0sIFswLjI3LCAwLjE4LCAwLjE4LCAwLjE4XSwgWzAuNDEsIDEsIDEsIDFdLCBbMC43LCAxLCAwLCAwXSwgWzEsIDEsIDEsIDFdXSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHByZXNldEx1dHNPKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnbGluZWFyJzogW1swLCAwXSwgWzEsIDFdXSxcbiAgICAgICdsb3dwYXNzJzogW1swLCAwLjhdLCBbMC4yLCAwLjZdLCBbMC4zLCAwLjFdLCBbMSwgMF1dLFxuICAgICAgJ2JhbmRwYXNzJzogW1swLCAwXSwgWzAuNCwgMC44XSwgWzAuNiwgMC44XSwgWzEsIDBdXSxcbiAgICAgICdoaWdocGFzcyc6IFtbMCwgMF0sIFswLjcsIDAuMV0sIFswLjgsIDAuNl0sIFsxLCAwLjhdXSxcbiAgICAgICdmbGF0JzogW1swLCAuN10sIFsxLCAxXV0sXG4gICAgICAncmFuZG9tJzogW1swLCAwLl0sIFswLjM4LCAwLl0sIFswLjU1LCAxLl0sIFswLjcyLCAxLl0sIFsxLCAwLjA1XV0sXG4gICAgfTtcbiAgfVxuXG59XG4iLCIvKipcbiAqIEhlbHBlcnMgbWF0ZXJpYWwgbWl4aW4uXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL21hdGVyaWFsL21peGluXG4gKi9cblxubGV0IEhlcmxwZXJzTWF0ZXJpYWxNaXhpbiA9IChzdXBlcmNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIHN1cGVyY2xhc3Mge1xuXG4gIF9jcmVhdGVNYXRlcmlhbChleHRyYU9wdGlvbnMpIHtcbiAgICAvLyBnZW5lcmF0ZSBzaGFkZXJzIG9uLWRlbWFuZCFcbiAgICBsZXQgZnMgPSBuZXcgdGhpcy5fc2hhZGVyc0ZyYWdtZW50KHRoaXMuX3VuaWZvcm1zKTtcbiAgICBsZXQgdnMgPSBuZXcgdGhpcy5fc2hhZGVyc1ZlcnRleCgpO1xuXG4gICAgLy8gbWF0ZXJpYWxcbiAgICBsZXQgZ2xvYmFsT3B0aW9ucyA9IHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLl91bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnMuY29tcHV0ZSgpLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzLmNvbXB1dGUoKSxcbiAgICB9O1xuXG4gICAgbGV0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGV4dHJhT3B0aW9ucywgZ2xvYmFsT3B0aW9ucyk7XG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwob3B0aW9ucyk7XG4gICAgdGhpcy5fbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgX3VwZGF0ZU1hdGVyaWFsKCkge1xuICAgIC8vIGdlbmVyYXRlIHNoYWRlcnMgb24tZGVtYW5kIVxuICAgIGxldCBmcyA9IG5ldyB0aGlzLl9zaGFkZXJzRnJhZ21lbnQodGhpcy5fdW5pZm9ybXMpO1xuICAgIGxldCB2cyA9IG5ldyB0aGlzLl9zaGFkZXJzVmVydGV4KCk7XG5cbiAgICB0aGlzLl9tYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSB2cy5jb21wdXRlKCk7XG4gICAgdGhpcy5fbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBmcy5jb21wdXRlKCk7XG5cbiAgICB0aGlzLl9tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBfcHJlcGFyZVRleHR1cmUoKSB7XG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMuX3N0YWNrLl9yYXdEYXRhLmxlbmd0aDsgbSsrKSB7XG4gICAgICBsZXQgdGV4ID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKFxuICAgICAgICB0aGlzLl9zdGFjay5yYXdEYXRhW21dLFxuICAgICAgICB0aGlzLl9zdGFjay50ZXh0dXJlU2l6ZSxcbiAgICAgICAgdGhpcy5fc3RhY2sudGV4dHVyZVNpemUsXG4gICAgICAgIHRoaXMuX3N0YWNrLnRleHR1cmVUeXBlLFxuICAgICAgICBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlLFxuICAgICAgICBUSFJFRS5VVk1hcHBpbmcsXG4gICAgICAgIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsXG4gICAgICAgIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsXG4gICAgICAgIFRIUkVFLk5lYXJlc3RGaWx0ZXIsXG4gICAgICAgIFRIUkVFLk5lYXJlc3RGaWx0ZXIpO1xuICAgICAgdGV4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRleC5mbGlwWSA9IHRydWU7XG4gICAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKHRleCk7XG4gICAgfVxuICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhlcmxwZXJzTWF0ZXJpYWxNaXhpbjtcbiIsImltcG9ydCBDb3JlVXRpbHMgZnJvbSAnLi4vY29yZS9jb3JlLnV0aWxzJztcbi8qKlxuICogRXZlbnQgQmFzZWQgcHJvZ3Jlc3NiYXJcbiAqIEBtb2R1bGUgaGVscGVycy9wcm9ncmVzc0JhclxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogbGV0IGxvYWRlciA9IG5ldyBMb2FkZXJzVm9sdW1lKCk7XG4gKiBjb25zdCBkb21Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZ3Jlc3NiYXInKTtcbiAqIGNvbnN0IHBiID0gbmV3IEhlbHBlcnNQcm9ncmVzc0JhckV2ZW50QmFzZWQobG9hZGVyLCBkb21Db250YWluZXIpO1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNQcm9ncmVzc0JhckV2ZW50QmFzZWQge1xuICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBkb21UYXJnZXQpIHtcbiAgICBpZiAoIWVtaXR0ZXIgfHwgIXRoaXMuX2lzRnVuY3Rpb24oZW1pdHRlci5lbWl0KSkge1xuICAgICAgY29uc29sZS5lcnJvcigncGxlYXNlIGdpdmUgdGhlIHRoaXMuX2VtaXR0ZXIgaW5zdGFuY2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQ29yZVV0aWxzLmlzU3RyaW5nKGRvbVRhcmdldCkpIHtcbiAgICAgIHRoaXMuX2RvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRvbVRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RvbSA9IGRvbVRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoIUNvcmVVdGlscy5pc0VsZW1lbnQodGhpcy5fZG9tKSkge1xuICAgICAgY29uc29sZS5lcnJvcigncGxlYXNlIGdpdmUgdGhlIGlkIG9mIGNvbnRhaW5lciBkb20gb3IgZGlyZWN0bHkgYSBkb20gaW5zdGFuY2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5pbml0Q29udGFpbmVyRG9tKCk7XG4gICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5uZXIoKTtcbiAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgdGhpcy50b3RhbEZpbGUgPSAwO1xuICB9XG5cbiAgX2lzRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfVxuXG4gIGluaXRFdmVudExpc3Rlbm5lcigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2xvYWQtc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgY29uc3QgdG90YWxGaWxlcyA9IGV2ZW50LnRvdGFsRmlsZXM7XG4gICAgICBzZWxmLnRvdGFsRmlsZSA9IHRvdGFsRmlsZXM7XG4gICAgICBzZWxmLl9kb21Ub3RhbEZpbGUuaW5uZXJIVE1MID0gdG90YWxGaWxlcztcbiAgICB9KTtcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2ZldGNoLXN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGNvbnN0IGZldGNoTGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gICAgICBjb25zdCBmaWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBmaWxlVGFnLmlubmVySFRNTCA9ICdmaWxlOiAnICsgZXZlbnQuZmlsZTtcbiAgICAgIGZpbGVUYWcuc3R5bGUuY29sb3IgPSAnI2ZmZmZmZic7XG4gICAgICBmZXRjaExpLmFwcGVuZChmaWxlVGFnKTtcblxuICAgICAgZmV0Y2hMaS5jbGFzc05hbWUgPSAnZmV0Y2gtZmlsZSc7XG4gICAgICBmZXRjaExpLmlkID0gJ2ZpbGUtJyArIGV2ZW50LmZpbGU7XG4gICAgICBmZXRjaExpLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICc3cHgnO1xuICAgICAgZmV0Y2hMaS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICNmZmZmZmY7JztcbiAgICAgIGZldGNoTGkuc3R5bGUud2lkdGggPSAnNjAlJztcbiAgICAgIGNvbnN0IGZldGNocHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGZldGNocHJvZ3Jlc3MuaWQgPSAnZmlsZS1mZXRjaC0nICsgZXZlbnQuZmlsZTtcbiAgICAgIGZldGNocHJvZ3Jlc3Muc3R5bGUud2lkdGggPSAnMCUnO1xuICAgICAgZmV0Y2hMaS5hcHBlbmQoZmV0Y2hwcm9ncmVzcyk7XG4gICAgICBzZWxmLl9kb21Qcm9jZXNzTGlzdC5hcHBlbmQoZmV0Y2hMaSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC1wcm9ncmVzcycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjb25zdCBpZCA9ICdmaWxlLWZldGNoLScgKyBldmVudC5maWxlO1xuICAgICAgY29uc3QgZmlsZUZldGNoRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgZmlsZUZldGNoRG9tLnN0eWxlLndpZHRoID0gKGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKSAqIDEwMCArICclJztcbiAgICAgIGZpbGVGZXRjaERvbS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHJlZCc7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC1zdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIHNob3cgcmVzdWx0XG4gICAgICBjb25zdCBsaVBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlLScgKyBldmVudC5maWxlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcmVzdWx0LmlkID0gJ2ZpbGUtcmVzdWx0LScgKyBldmVudC5maWxlO1xuICAgICAgcmVzdWx0LmlubmVySFRNTCA9ICdmZXRjaC1zdWNjZXNzJztcbiAgICAgIHJlc3VsdC5zdHlsZS5jb2xvciA9ICcjZmZmZmZmJztcbiAgICAgIGxpUGFyZW50LmFwcGVuZChyZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtZXJyb3InLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtYWJvcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2ZldGNoLXRpbWVvdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbigncGFyc2Utc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgY29uc3QgbGlQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZS0nICsgZXZlbnQuZmlsZSlcbiAgICAgIGNvbnN0IHBhcnNlcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBhcnNlcHJvZ3Jlc3MuaWQgPSAnZmlsZS1wYXJzZS0nICsgZXZlbnQuZmlsZTtcbiAgICAgIHBhcnNlcHJvZ3Jlc3Muc3R5bGUud2lkdGggPSAnMCUnO1xuICAgICAgbGlQYXJlbnQuYXBwZW5kKHBhcnNlcHJvZ3Jlc3MpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbigncGFyc2luZycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjb25zdCBpZCA9ICdmaWxlLXBhcnNlLScgKyBldmVudC5maWxlO1xuICAgICAgY29uc3QgZmlsZVBhcnNlRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgZmlsZVBhcnNlRG9tLnN0eWxlLndpZHRoID0gKGV2ZW50LnBhcnNlZCAvIGV2ZW50LnRvdGFsKSAqIDEwMCArICclJztcbiAgICAgIGZpbGVQYXJzZURvbS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHllbGxvdyc7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdwYXJzZS1zdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHNlbGYubG9hZGVkICs9IDE7XG4gICAgICBzZWxmLl9kb21DdXJyZW50RmlsZS5pbm5lckhUTUwgPSBzZWxmLmxvYWRlZDtcbiAgICAgIHNlbGYuX2RvbUN1cnJlbnRQcm9ncmVzcy5zdHlsZS53aWR0aCA9IChzZWxmLmxvYWRlZCAvIHNlbGYudG90YWxGaWxlKSAqXG4gICAgICAgIDEwMCArICclJztcbiAgICAgIC8vIHNob3cgcmVzdWx0XG4gICAgICBjb25zdCBsaVBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlLScgKyBldmVudC5maWxlKVxuICAgICAgY29uc3QgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICByZXN1bHQuaWQgPSAnZmlsZS1yZXN1bHQtJyArIGV2ZW50LmZpbGU7XG4gICAgICByZXN1bHQuaW5uZXJIVE1MID0gJ3BhcnNlLXN1Y2Nlc3MnO1xuICAgICAgcmVzdWx0LnN0eWxlLmNvbG9yID0gJyNmZmZmZmYnO1xuICAgICAgbGlQYXJlbnQuYXBwZW5kKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICBpbml0Q29udGFpbmVyRG9tKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lckRvbSA9XG4gICAgICBcIjxkaXYgaWQ9J2FtaS1wcm9ncmVzcy1iYXItY29udGFpbmVyJyBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjogcmdiKDMzLCAzMywgMzMpOyBjb2xvcjogI2ZmZmZmZjsnPlwiICtcbiAgICAgIFwiPGRpdj5cIiArXG4gICAgICBcIjxsYWJlbCBmb3I9J3Byb2dyZXNzLWJhcicgaWQ9J3Byb2dyZXNzLWxhYmVsJyBzdHlsZT0nd2lkdGg6IDYwJTsgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjsgdGV4dC1hbGlnbjogY2VudGVyOyc+XCIgK1xuICAgICAgXCI8c3BhbiBpZD0nY3VycmVudC1maWxlLWluZGV4Jz4wPC9zcGFuPlwiICtcbiAgICAgIFwiL1wiICtcbiAgICAgIFwiPHNwYW4gaWQ9J3RvdGFsLWZpbGUnPjA8L3NwYW4+XCIgK1xuICAgICAgXCI8L2xhYmVsPlwiICtcbiAgICAgIFwiPGRpdiBpZD0ncHJvZ3Jlc3MtYmFyJyBzdHlsZT0nd2lkdGg6IDYwJTsgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjsgdGV4dC1hbGlnbjogY2VudGVyOyc+XCIgK1xuICAgICAgXCI8ZGl2IGlkPSdjdXJyZW50LXByb2dyZXNzJyBzdHlsZT0nYm9yZGVyOiAxcHggc29saWQgcmVkOyB3aWR0aDogMCU7Jz48L2Rpdj5cIiArXG4gICAgICBcIjwvZGl2PlwiICtcbiAgICAgIFwiPC9kaXY+XCIgK1xuICAgICAgXCI8dWwgaWQ9J3Byb2Nlc3MtbGlzdCcgc3R5bGU9J2xpc3Qtc3R5bGUtdHlwZTogbm9uZTsgcGFkZGluZzogMDsgb3ZlcmZsb3cteTogYXV0bzsnPlwiICtcbiAgICAgIC8vIFwiPGxpIGNsYXNzPSdmZXRjaC1maWxlJz5cIiArXG4gICAgICAvLyBcIjxkaXYgaWQ9J2ZpbGUtZmV0Y2gteHh4eHhpZCc+PC9kaXY+XCIgK1xuICAgICAgLy8gXCI8ZGl2IGlkPSdmaWxlLXBhcnNlLXh4eHh4aWQnPjwvZGl2PlwiICtcbiAgICAgIC8vIFwiPC9saT5cIiArXG4gICAgICBcIjwvdWw+XCIgK1xuICAgICAgXCI8L2Rpdj5cIjtcbiAgICBjb25zdCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcC5pbm5lckhUTUwgPSBjb250YWluZXJEb207XG4gICAgdGhpcy5fZG9tLmFwcGVuZCh3cmFwKTtcbiAgICAvLyBkb20gaW50ZXJmYWNlXG4gICAgdGhpcy5fZG9tQ3VycmVudEZpbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudC1maWxlLWluZGV4Jyk7XG4gICAgdGhpcy5fZG9tVG90YWxGaWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsLWZpbGUnKTtcbiAgICB0aGlzLl9kb21Qcm9jZXNzTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9jZXNzLWxpc3QnKTtcbiAgICB0aGlzLl9kb21DdXJyZW50UHJvZ3Jlc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudC1wcm9ncmVzcycpO1xuICB9XG59XG4iLCJcbi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL3Byb2dyZXNzQmFyXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc1Byb2dyZXNzQmFyIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX21vZGVzID0ge1xuICAgICAgJ2xvYWQnOiB7XG4gICAgICAgICduYW1lJzogJ2xvYWQnLFxuICAgICAgICAnY29sb3InOiAnI0ZGRjU2RicsXG4gICAgICB9LFxuICAgICAgJ3BhcnNlJzoge1xuICAgICAgICAnbmFtZSc6ICdwYXJzZScsXG4gICAgICAgICdjb2xvcic6ICcjMjE5NkYzJyxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSUQgPSBudWxsO1xuXG4gICAgdGhpcy5fbW9kZSA9IG51bGw7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX3RvdGFsID0gbnVsbDtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgZnJlZSgpIHtcbiAgICBsZXQgcHJvZ3Jlc3NDb250YWluZXJzID0gdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Byb2dyZXNzIGNvbnRhaW5lcicpO1xuICAgIGlmIChwcm9ncmVzc0NvbnRhaW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgcHJvZ3Jlc3NDb250YWluZXJzWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJvZ3Jlc3NDb250YWluZXJzWzBdKTtcbiAgICB9XG4gICAgcHJvZ3Jlc3NDb250YWluZXJzID0gbnVsbDtcbiAgICAvLyBzdG9wIHJlbmRlcmluZyBsb29wXG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSUQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBsZXQgcHJvZ3Jlc3NDb250YWluZXIgPSB0aGlzLl9kb21Db250YWluZXIoKTtcblxuICAgIGZvciAobGV0IG1vZGUgaW4gdGhpcy5fbW9kZXMpIHtcbiAgICAgIGlmICh0aGlzLl9tb2Rlcy5oYXNPd25Qcm9wZXJ0eShtb2RlKSkge1xuICAgICAgICBsZXQgYmFyID0gdGhpcy5fZG9tQmFyKHRoaXMuX21vZGVzW21vZGVdKTtcbiAgICAgICAgcHJvZ3Jlc3NDb250YWluZXIuYXBwZW5kQ2hpbGQoYmFyKTtcbiAgICAgICAgYmFyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQocHJvZ3Jlc3NDb250YWluZXIpO1xuICAgIHByb2dyZXNzQ29udGFpbmVyID0gbnVsbDtcblxuICAgIC8vIHN0YXJ0IHJlbmRlcmluZyBsb29wXG4gICAgdGhpcy51cGRhdGVVSSgpO1xuICB9XG5cbiAgdXBkYXRlKHZhbHVlLCB0b3RhbCwgbW9kZSkge1xuICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgLy8gZGVwZW5kaW5nIG9uIENETiwgdG90YWwgcmV0dXJuIHRvIFhIVFRQUmVxdWVzdCBjYW4gYmUgMC5cbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciB0byBhbmltYXRlIHRoZSBwcm9ncmVzc2JhclxuICAgIGlmICh0b3RhbCA9PT0gMCkge1xuICAgICAgdGhpcy5fdG90YWwgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gTWF0aC5yYW5kb20oKSp2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdG90YWwgPSB0b3RhbDtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVVSSgpIHtcbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+e1xuICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCEodGhpcy5fbW9kZXMuaGFzT3duUHJvcGVydHkodGhpcy5fbW9kZSkgJiZcbiAgICAgIHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmhhc093blByb3BlcnR5KCduYW1lJykgJiZcbiAgICAgIHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmhhc093blByb3BlcnR5KCdjb2xvcicpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnJztcbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgucm91bmQoKHRoaXMuX3ZhbHVlIC8gdGhpcy5fdG90YWwpICogMTAwKTtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmNvbG9yO1xuXG4gICAgbGV0IHByb2dyZXNzQmFyID0gdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Byb2dyZXNzICcgKyB0aGlzLl9tb2Rlc1t0aGlzLl9tb2RlXS5uYW1lKTtcbiAgICBpZiAocHJvZ3Jlc3NCYXIubGVuZ3RoID4gMCkge1xuICAgICAgcHJvZ3Jlc3NCYXJbMF0uc3R5bGUuYm9yZGVyQ29sb3IgPSBjb2xvcjtcbiAgICAgIHByb2dyZXNzQmFyWzBdLnN0eWxlLndpZHRoID0gcHJvZ3Jlc3MgKyAnJSc7XG4gICAgfVxuICAgIHByb2dyZXNzQmFyID0gbnVsbDtcbiAgfVxuXG4gIF9kb21Db250YWluZXIoKSB7XG4gICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgLy8gY2xhc3MgaXRcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgncHJvZ3Jlc3MnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY29udGFpbmVyJyk7XG5cbiAgICAvLyBzdHlsZSBpdFxuICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzhweCc7XG4gICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBjb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMTU4LCAxNTgsIDE1OCwgMC41KSc7XG4gICAgY29udGFpbmVyLnN0eWxlLnRvcCA9ICcwJztcbiAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gJzEnO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIF9kb21CYXIobW9kZSkge1xuICAgIGlmICghKG1vZGUuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJlxuICAgICAgKG1vZGUuaGFzT3duUHJvcGVydHkoJ2NvbG9yJykpKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIG1vZGUgcHJvdmlkZWQuJyk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cobW9kZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAvLyBjbGFzcyBpdFxuICAgIGJhci5jbGFzc0xpc3QuYWRkKG1vZGUubmFtZSk7XG4gICAgYmFyLmNsYXNzTGlzdC5hZGQoJ3Byb2dyZXNzJyk7XG5cbiAgICAvLyBzdHlsZSBpdFxuICAgIGJhci5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICcgKyBtb2RlLmNvbG9yO1xuICAgIGJhci5zdHlsZS53aWR0aCA9ICcwJSc7XG5cbiAgICByZXR1cm4gYmFyO1xuICB9XG5cbn1cbiIsIi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IEdlb21ldHJpZXNTbGljZSBmcm9tICcuLi9nZW9tZXRyaWVzL2dlb21ldHJpZXMuc2xpY2UnO1xuaW1wb3J0IFNoYWRlcnNVbmlmb3JtIGZyb20gJy4uL3NoYWRlcnMvc2hhZGVycy5kYXRhLnVuaWZvcm0nO1xuaW1wb3J0IFNoYWRlcnNWZXJ0ZXggZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLmRhdGEudmVydGV4JztcbmltcG9ydCBTaGFkZXJzRnJhZ21lbnQgZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLmRhdGEuZnJhZ21lbnQnO1xuXG5pbXBvcnQgSGVscGVyc01hdGVyaWFsTWl4aW4gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGVyaWFsLm1peGluJztcblxuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvc2xpY2VcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzU2xpY2UgZXh0ZW5kcyBIZWxwZXJzTWF0ZXJpYWxNaXhpbihUSFJFRS5PYmplY3QzRCkge1xuICBjb25zdHJ1Y3RvcihzdGFjayxcbiAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLFxuICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKSxcbiAgICAgICAgICAgICAgYWFiYlNwYWNlID0gJ0lKSycpIHtcbiAgICAvL1xuICAgIHN1cGVyKCk7XG5cbiAgICAvLyBwcml2YXRlIHZhcnNcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuXG4gICAgLy8gaW1hZ2Ugc2V0dGluZ3NcbiAgICAvLyBpbmRleCBvbmx5IHVzZWQgdG8gZ3JhYiB3aW5kb3cvbGV2ZWwgYW5kIGludGVyY2VwdC9zbG9wZVxuICAgIHRoaXMuX2ludmVydCA9IHRoaXMuX3N0YWNrLmludmVydDtcblxuICAgIHRoaXMuX2x1dCA9ICdub25lJztcbiAgICB0aGlzLl9sdXRUZXh0dXJlID0gbnVsbDtcbiAgICAvLyBpZiBhdXRvID09PSB0cnVlLCBnZXQgZnJvbSBpbmRleFxuICAgIC8vIGVsc2UgZnJvbSBzdGFjayB3aGljaCBob2xkcyB0aGUgZGVmYXVsdCB2YWx1ZXNcbiAgICB0aGlzLl9pbnRlbnNpdHlBdXRvID0gdHJ1ZTtcbiAgICB0aGlzLl9pbnRlcnBvbGF0aW9uID0gMTsgLy8gZGVmYXVsdCB0byB0cmlsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIC8vIHN0YXJ0cyBhdCAwXG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gbnVsbDtcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSBudWxsO1xuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSBudWxsO1xuXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyQ29sb3IgPSBudWxsO1xuXG4gICAgLy8gT2JqZWN0M0Qgc2V0dGluZ3NcbiAgICAvLyBzaGFwZVxuICAgIHRoaXMuX3BsYW5lUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB0aGlzLl9wbGFuZURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAvLyBjaGFuZ2UgYWFCQlNwYWNlIGNoYW5nZXMgdGhlIGJveCBkaW1lbnNpb25zXG4gICAgLy8gYWxzbyBjaGFuZ2VzIHRoZSB0cmFuc2Zvcm1cbiAgICAvLyB0aGVyZSBpcyBhbHNvIGEgc3dpdGNoIHRvIG1vdmUgYmFjayBtZXNoIHRvIExQUyBzcGFjZSBhdXRvbWF0aWNhbGx5XG4gICAgdGhpcy5fYWFCQnNwYWNlID0gYWFiYlNwYWNlOyAvLyBvciBMUFMgLT4gZGlmZmVyZW50IHRyYW5zZm9ybXMsIGVzcCBmb3IgdGhlIGdlb21ldHJ5L21lc2hcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLl9zaGFkZXJzRnJhZ21lbnQgPSBTaGFkZXJzRnJhZ21lbnQ7XG4gICAgdGhpcy5fc2hhZGVyc1ZlcnRleCA9IFNoYWRlcnNWZXJ0ZXg7XG4gICAgdGhpcy5fdW5pZm9ybXMgPSBTaGFkZXJzVW5pZm9ybS51bmlmb3JtcygpO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcblxuICAgIC8vIHVwZGF0ZSBkaW1lbnNpb25zLCBjZW50ZXIsIGV0Yy5cbiAgICAvLyBkZXBlbmRpbmcgb24gYWFCQlNwYWNlXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgLy8gdXBkYXRlIG9iamVjdFxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgLy8gZ2V0dGVycy9zZXR0ZXJzXG5cbiAgZ2V0IHN0YWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgfVxuXG4gIHNldCBzdGFjayhzdGFjaykge1xuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gIH1cblxuICBnZXQgd2luZG93V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd1dpZHRoO1xuICB9XG5cbiAgc2V0IHdpbmRvd1dpZHRoKHdpbmRvd1dpZHRoKSB7XG4gICAgdGhpcy5fd2luZG93V2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcbiAgfVxuXG4gIGdldCB3aW5kb3dDZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd0NlbnRlcjtcbiAgfVxuXG4gIHNldCB3aW5kb3dDZW50ZXIod2luZG93Q2VudGVyKSB7XG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gd2luZG93Q2VudGVyO1xuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xuICB9XG5cbiAgZ2V0IHJlc2NhbGVTbG9wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZVNsb3BlO1xuICB9XG5cbiAgc2V0IHJlc2NhbGVTbG9wZShyZXNjYWxlU2xvcGUpIHtcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSByZXNjYWxlU2xvcGU7XG4gICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCk7XG4gIH1cblxuICBnZXQgcmVzY2FsZUludGVyY2VwdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZUludGVyY2VwdDtcbiAgfVxuXG4gIHNldCByZXNjYWxlSW50ZXJjZXB0KHJlc2NhbGVJbnRlcmNlcHQpIHtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gcmVzY2FsZUludGVyY2VwdDtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcbiAgfVxuXG4gIGdldCBpbnZlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludmVydDtcbiAgfVxuXG4gIHNldCBpbnZlcnQoaW52ZXJ0KSB7XG4gICAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xuICB9XG5cbiAgZ2V0IGx1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbHV0O1xuICB9XG5cbiAgc2V0IGx1dChsdXQpIHtcbiAgICB0aGlzLl9sdXQgPSBsdXQ7XG4gIH1cblxuICBnZXQgbHV0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbHV0VGV4dHVyZTtcbiAgfVxuXG4gIHNldCBsdXRUZXh0dXJlKGx1dFRleHR1cmUpIHtcbiAgICB0aGlzLl9sdXRUZXh0dXJlID0gbHV0VGV4dHVyZTtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcbiAgfVxuXG4gIGdldCBpbnRlbnNpdHlBdXRvKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlbnNpdHlBdXRvO1xuICB9XG5cbiAgc2V0IGludGVuc2l0eUF1dG8oaW50ZW5zaXR5QXV0bykge1xuICAgIHRoaXMuX2ludGVuc2l0eUF1dG8gPSBpbnRlbnNpdHlBdXRvO1xuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3MoKTtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcbiAgfVxuXG4gIGdldCBpbnRlcnBvbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgc2V0IGludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHRoaXMuX2ludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xuICAgIHRoaXMuX3VwZGF0ZU1hdGVyaWFsKCk7XG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG5cbiAgc2V0IGluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIHNldCBwbGFuZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgdGhpcy5fcGxhbmVQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IHBsYW5lUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lUG9zaXRpb247XG4gIH1cblxuICBzZXQgcGxhbmVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5fcGxhbmVEaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBnZXQgcGxhbmVEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lRGlyZWN0aW9uO1xuICB9XG5cbiAgc2V0IGhhbGZEaW1lbnNpb25zKGhhbGZEaW1lbnNpb25zKSB7XG4gICAgdGhpcy5faGFsZkRpbWVuc2lvbnMgPSBoYWxmRGltZW5zaW9ucztcbiAgfVxuXG4gIGdldCBoYWxmRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5faGFsZkRpbWVuc2lvbnM7XG4gIH1cblxuICBzZXQgY2VudGVyKGNlbnRlcikge1xuICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcbiAgfVxuXG4gIGdldCBjZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcbiAgfVxuXG4gIHNldCBhYWJiU3BhY2UoYWFiYlNwYWNlKSB7XG4gICAgdGhpcy5fYWFCQnNwYWNlID0gYWFiYlNwYWNlO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIGdldCBhYWJiU3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FhQkJzcGFjZTtcbiAgfVxuXG4gIHNldCBtZXNoKG1lc2gpIHtcbiAgICB0aGlzLl9tZXNoID0gbWVzaDtcbiAgfVxuXG4gIGdldCBtZXNoKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNoO1xuICB9XG5cbiAgc2V0IGdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgfVxuXG4gIGdldCBnZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG4gIH1cblxuICBzZXQgY2FudmFzV2lkdGgoY2FudmFzV2lkdGgpIHtcbiAgICB0aGlzLl9jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNXaWR0aC52YWx1ZSA9IHRoaXMuX2NhbnZhc1dpZHRoO1xuICB9XG5cbiAgZ2V0IGNhbnZhc1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXNXaWR0aDtcbiAgfVxuXG4gIHNldCBjYW52YXNIZWlnaHQoY2FudmFzSGVpZ2h0KSB7XG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNIZWlnaHQudmFsdWUgPSB0aGlzLl9jYW52YXNIZWlnaHQ7XG4gIH1cblxuICBnZXQgY2FudmFzSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXNIZWlnaHQ7XG4gIH1cblxuICBzZXQgYm9yZGVyQ29sb3IoYm9yZGVyQ29sb3IpIHtcbiAgICB0aGlzLl9ib3JkZXJDb2xvciA9IGJvcmRlckNvbG9yO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVCb3JkZXJDb2xvci52YWx1ZSA9IG5ldyBUSFJFRS5Db2xvcihib3JkZXJDb2xvcik7XG4gIH1cblxuICBnZXQgYm9yZGVyQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JvcmRlckNvbG9yO1xuICB9XG5cbiAgX2luaXQoKSB7XG4gICAgaWYgKCF0aGlzLl9zdGFjayB8fCAhdGhpcy5fc3RhY2suX3ByZXBhcmVkIHx8ICF0aGlzLl9zdGFjay5fcGFja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FhQkJzcGFjZSA9PT0gJ0lKSycpIHtcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XG4gICAgICB0aGlzLl9jZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSksueCAtIDAuNSxcbiAgICAgICAgdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSksueSAtIDAuNSxcbiAgICAgICAgdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSksueiAtIDAuNSk7XG4gICAgICB0aGlzLl90b0FBQkIgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMUFNcbiAgICAgIGxldCBhYUJCb3ggPSB0aGlzLl9zdGFjay5BQUJCb3goKTtcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zID0gYWFCQm94LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMC41KTtcbiAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YWNrLmNlbnRlckFBQkJveCgpO1xuICAgICAgdGhpcy5fdG9BQUJCID0gdGhpcy5fc3RhY2subHBzMkFBQkI7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gIF9jcmVhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9zdGFjayB8fCAhdGhpcy5fc3RhY2sucHJlcGFyZWQgfHwgIXRoaXMuX3N0YWNrLnBhY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIHZhcnNcbiAgICB0cnkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1NsaWNlKFxuICAgICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucyxcbiAgICAgICAgdGhpcy5fY2VudGVyLFxuICAgICAgICB0aGlzLl9wbGFuZVBvc2l0aW9uLFxuICAgICAgICB0aGlzLl9wbGFuZURpcmVjdGlvbixcbiAgICAgICAgdGhpcy5fdG9BQUJCKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coZSk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2ludmFsaWQgc2xpY2UgZ2VvbWV0cnkgLSBleGl0aW5nLi4uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWF0ZXJpYWwpIHtcbiAgICAgIC8vXG4gICAgICB0aGlzLl91bmlmb3Jtcy51VGV4dHVyZVNpemUudmFsdWUgPSB0aGlzLl9zdGFjay50ZXh0dXJlU2l6ZTtcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVEYXRhRGltZW5zaW9ucy52YWx1ZSA9IFt0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLnpdO1xuICAgICAgdGhpcy5fdW5pZm9ybXMudVdvcmxkVG9EYXRhLnZhbHVlID0gdGhpcy5fc3RhY2subHBzMklKSztcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVOdW1iZXJPZkNoYW5uZWxzLnZhbHVlID0gdGhpcy5fc3RhY2subnVtYmVyT2ZDaGFubmVscztcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVQaXhlbFR5cGUudmFsdWUgPSB0aGlzLl9zdGFjay5waXhlbFR5cGU7XG4gICAgICB0aGlzLl91bmlmb3Jtcy51Qml0c0FsbG9jYXRlZC52YWx1ZSA9IHRoaXMuX3N0YWNrLmJpdHNBbGxvY2F0ZWQ7XG4gICAgICB0aGlzLl91bmlmb3Jtcy51UGFja2VkUGVyUGl4ZWwudmFsdWUgPSB0aGlzLl9zdGFjay5wYWNrZWRQZXJQaXhlbDtcbiAgICAgIC8vIGNvbXB1dGUgdGV4dHVyZSBpZiBtYXRlcmlhbCBleGlzdFxuICAgICAgdGhpcy5fcHJlcGFyZVRleHR1cmUoKTtcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlQ29udGFpbmVyLnZhbHVlID0gdGhpcy5fdGV4dHVyZXM7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZU1hdGVyaWFsKHtcbiAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBpbnRlbnNpdHkgcmVsYXRlZCBzdHVmZlxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3MoKTtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgbWVzaCFcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcbiAgICBpZiAodGhpcy5fYWFCQnNwYWNlID09PSAnSUpLJykge1xuICAgICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9zdGFjay5pamsyTFBTKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuXG4gICAgLy8gYW5kIGFkZCBpdCFcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcbiAgfVxuXG4gIHVwZGF0ZUludGVuc2l0eVNldHRpbmdzKCkge1xuICAgIC8vIGlmIGF1dG8sIGdldCBmcm9tIGZyYW1lIGluZGV4XG4gICAgaWYgKHRoaXMuX2ludGVuc2l0eUF1dG8pIHtcbiAgICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZygnd2luZG93Q2VudGVyJyk7XG4gICAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmcoJ3dpbmRvd1dpZHRoJyk7XG4gICAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmcoJ3Jlc2NhbGVTbG9wZScpO1xuICAgICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nKCdyZXNjYWxlSW50ZXJjZXB0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl93aW5kb3dDZW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fd2luZG93Q2VudGVyID0gdGhpcy5fc3RhY2sud2luZG93Q2VudGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fX3dpbmRvd1dpZHRoID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gdGhpcy5fc3RhY2sud2luZG93V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZXNjYWxlU2xvcGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gdGhpcy5fc3RhY2sucmVzY2FsZVNsb3BlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVzY2FsZUludGVyY2VwdCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gdGhpcy5fc3RhY2sucmVzY2FsZUludGVyY2VwdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCkge1xuICAgIC8vIGNvbXBlbnNhdGUgZm9yIHRoZSBvZmZzZXQgdG8gb25seSBwYXNzID4gMCB2YWx1ZXMgdG8gc2hhZGVyc1xuICAgIC8vIG1vZGVscyA+IG1vZGVscy5zdGFjay5qcyA6IF9wYWNrVG84Qml0c1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGlmICh0aGlzLl9zdGFjay5fbWluTWF4WzBdIDwgMCkge1xuICAgICAgb2Zmc2V0IC09IHRoaXMuX3N0YWNrLl9taW5NYXhbMF07XG4gICAgfVxuXG4gICAgLy8gc2V0IHNsaWNlIHdpbmRvdyBjZW50ZXIgYW5kIHdpZHRoXG4gICAgdGhpcy5fdW5pZm9ybXMudVJlc2NhbGVTbG9wZUludGVyY2VwdC52YWx1ZSA9XG4gICAgICBbdGhpcy5fcmVzY2FsZVNsb3BlLCB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0XTtcbiAgICB0aGlzLl91bmlmb3Jtcy51V2luZG93Q2VudGVyV2lkdGgudmFsdWUgPVxuICAgICAgW29mZnNldCArIHRoaXMuX3dpbmRvd0NlbnRlciwgdGhpcy5fd2luZG93V2lkdGhdO1xuXG4gICAgLy8gaW52ZXJ0XG4gICAgdGhpcy5fdW5pZm9ybXMudUludmVydC52YWx1ZSA9IHRoaXMuX2ludmVydCA9PT0gdHJ1ZSA/IDEgOiAwO1xuXG4gICAgLy8gaW50ZXJwb2xhdGlvblxuICAgIHRoaXMuX3VuaWZvcm1zLnVJbnRlcnBvbGF0aW9uLnZhbHVlID0gdGhpcy5faW50ZXJwb2xhdGlvbjtcblxuICAgIC8vIGx1dFxuICAgIGlmICh0aGlzLl9sdXQgPT09ICdub25lJykge1xuICAgICAgdGhpcy5fdW5pZm9ybXMudUx1dC52YWx1ZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVMdXQudmFsdWUgPSAxO1xuICAgICAgdGhpcy5fdW5pZm9ybXMudVRleHR1cmVMVVQudmFsdWUgPSB0aGlzLl9sdXRUZXh0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUludGVuc2l0eVNldHRpbmcoc2V0dGluZykge1xuICAgIGlmICh0aGlzLl9zdGFjay5mcmFtZVt0aGlzLl9pbmRleF0gJiZcbiAgICAgICAgdGhpcy5fc3RhY2suZnJhbWVbdGhpcy5faW5kZXhdW3NldHRpbmddKSB7XG4gICAgICB0aGlzWydfJyArIHNldHRpbmddID0gdGhpcy5fc3RhY2suZnJhbWVbdGhpcy5faW5kZXhdW3NldHRpbmddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzWydfJyArIHNldHRpbmddID0gdGhpcy5fc3RhY2tbc2V0dGluZ107XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICAvLyB1cGRhdGUgc2xpY2VcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZGlzcG9zZSB0aGUgdGV4dHVyZSFcbiAgICAgIC8vIHRoaXMuX21lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgLy8gdGhpcy5fbWVzaC5tYXRlcmlhbCA9IG51bGw7XG4gICAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgLy8gUmVsZWFzZSBtZW1vcnlcbiAgICBmb3IodmFyIGogPTA7IGo8IHRoaXMuX3RleHR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlc1tqXS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl90ZXh0dXJlc1tqXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmVzID0gbnVsbDtcbiAgICB0aGlzLl9zaGFkZXJzRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuX3NoYWRlcnNWZXJ0ZXggPSBudWxsO1xuXG4gICAgdGhpcy5fdW5pZm9ybXMgPSBudWxsO1xuXG4gICAgLy8gbWF0ZXJpYWwsIGdlb21ldHJ5IGFuZCBtZXNoXG4gICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fbWVzaC5nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgdGhpcy5fbWVzaC5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsLnZlcnRleFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsLnVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLl9tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgdGhpcy5fc3RhY2sgPSBudWxsO1xuICB9XG5cbiAgY2FydGVzaWFuRXF1YXRpb24oKSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBnZW9tZXRyeVxuICAgIGlmICghdGhpcy5fZ2VvbWV0cnkgfHxcbiAgICAgICAhdGhpcy5fZ2VvbWV0cnkudmVydGljZXMgfHxcbiAgICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQoKTtcbiAgICB9XG5cbiAgICBsZXQgdmVydGljZXMgPSB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcztcbiAgICBsZXQgZGF0YVRvV29ybGQgPSB0aGlzLl9zdGFjay5pamsyTFBTO1xuICAgIGxldCBwMSA9IG5ldyBUSFJFRS5WZWN0b3IzKHZlcnRpY2VzWzBdLngsIHZlcnRpY2VzWzBdLnksIHZlcnRpY2VzWzBdLnopXG4gICAgICAuYXBwbHlNYXRyaXg0KGRhdGFUb1dvcmxkKTtcbiAgICBsZXQgcDIgPSBuZXcgVEhSRUUuVmVjdG9yMyh2ZXJ0aWNlc1sxXS54LCB2ZXJ0aWNlc1sxXS55LCB2ZXJ0aWNlc1sxXS56KVxuICAgICAgLmFwcGx5TWF0cml4NChkYXRhVG9Xb3JsZCk7XG4gICAgbGV0IHAzID0gbmV3IFRIUkVFLlZlY3RvcjModmVydGljZXNbMl0ueCwgdmVydGljZXNbMl0ueSwgdmVydGljZXNbMl0ueilcbiAgICAgIC5hcHBseU1hdHJpeDQoZGF0YVRvV29ybGQpO1xuICAgIGxldCB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0bGV0IHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBsZXQgbm9ybWFsID0gdjFcbiAgICAgIC5zdWJWZWN0b3JzKHAzLCBwMilcbiAgICAgIC5jcm9zcyh2Mi5zdWJWZWN0b3JzKHAxLCBwMikpXG4gICAgICAubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQoXG4gICAgICBub3JtYWwueCxcbiAgICAgIG5vcm1hbC55LFxuICAgICAgbm9ybWFsLnosXG4gICAgICAtIG5vcm1hbC5kb3QocDEpXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqICogSW1wb3J0cyAqKiovXG5pbXBvcnQgSGVscGVyc0JvcmRlciBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuYm9yZGVyJztcbmltcG9ydCBIZWxwZXJzQm91bmRpbmdCb3ggZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmJvdW5kaW5nYm94JztcbmltcG9ydCBIZWxwZXJzU2xpY2UgZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNsaWNlJztcblxuLyoqXG4gKiBIZWxwZXIgdG8gZWFzaWx5IGRpc3BsYXkgYW5kIGludGVyYWN0IHdpdGggYSBzdGFjay48YnI+XG4gKjxicj5cbiAqIERlZmF1bHRzOjxicj5cbiAqICAgLSBvcmllbnRhdGlvbjogMCAoYWNxdWlzaXRpb24gZGlyZWN0aW9uKTxicj5cbiAqICAgLSBpbmRleDogbWlkZGxlIHNsaWNlIGluIGFjcXVpc2l0aW9uIGRpcmVjdGlvbjxicj5cbiAqPGJyPlxuICogRmVhdHVyZXM6PGJyPlxuICogICAtIHNsaWNlIGZyb20gdGhlIHN0YWNrIChpbiBhbnkgZGlyZWN0aW9uKTxicj5cbiAqICAgLSBzbGljZSBib3JkZXI8YnI+XG4gKiAgIC0gc3RhY2sgYm91bmRpbmcgYm94PGJyPlxuICo8YnI+XG4gKiBMaXZlIGRlbW8gYXQ6IHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2doL2dldC9saWJyYXJ5L3B1cmUvZm5uZHNjL2FtaS90cmVlL21hc3Rlci9sZXNzb25zLzAxI3J1bnxMZXNzb24gMDF9XG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBzdGFjayA9IG5ldyBWSlMuTW9kZWxzLlN0YWNrKCk7XG4gKiAuLi4gLy8gcHJlcGFyZSB0aGUgc3RhY2tcbiAqXG4gKiBsZXQgc3RhY2tIZWxwZXIgPSBuZXcgVkpTLkhlbHBlcnMuU3RhY2soc3RhY2spO1xuICogc3RhY2tIZWxwZXIuYmJveC5jb2xvciA9IDB4RjlGOUY5O1xuICogc3RhY2tIZWxwZXIuYm9yZGVyLmNvbG9yID0gMHhGOUY5Rjk7XG4gKlxuICogbGV0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gKiBzY2VuZS5hZGQoc3RhY2tIZWxwZXIpO1xuICpcbiAqIEBleHRlbmRzIFRIUkVFLk9iamVjdDNEXG4gKlxuICogQHNlZSBtb2R1bGU6aGVscGVycy9ib3JkZXJcbiAqIEBzZWUgbW9kdWxlOmhlbHBlcnMvYm91bmRpbmdib3hcbiAqIEBzZWUgbW9kdWxlOmhlbHBlcnMvc2xpY2VcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvc3RhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc1N0YWNrIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3RvcihzdGFjaykge1xuICAgIC8vXG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5fYkJveCA9IG51bGw7XG4gICAgdGhpcy5fc2xpY2UgPSBudWxsO1xuICAgIHRoaXMuX2JvcmRlciA9IG51bGw7XG4gICAgdGhpcy5fZHVtbXkgPSBudWxsO1xuXG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSAwO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcblxuICAgIHRoaXMuX3VuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLl9hdXRvV2luZG93TGV2ZWwgPSBmYWxzZTtcbiAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IGZhbHNlO1xuICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSAwO1xuXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyQ29sb3IgPSBudWxsO1xuXG5cbiAgICAvLyB0aGlzLl9hcnJvdyA9IHtcbiAgICAvLyAgIHZpc2libGU6IHRydWUsXG4gICAgLy8gICBjb2xvcjogMHhGRkYzMzYsXG4gICAgLy8gICBsZW5ndGg6IDIwLFxuICAgIC8vICAgbWF0ZXJpYWw6IG51bGwsXG4gICAgLy8gICBnZW9tZXRyeTogbnVsbCxcbiAgICAvLyAgIG1lc2g6IG51bGxcbiAgICAvLyB9O1xuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gUFVCTElDIE1FVEhPRFNcbiAgLy9cblxuICAvL1xuICAvLyBTRVRURVJTL0dFVFRFUlNcbiAgLy9cblxuICAvKipcbiAgICogR2V0IHN0YWNrLlxuICAgKlxuICAgKiBAdHlwZSB7TW9kZWxzU3RhY2t9XG4gICAqL1xuICBnZXQgc3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzdGFjay5cbiAgICpcbiAgICogQHR5cGUge01vZGVsc1N0YWNrfVxuICAgKi9cbiAgc2V0IHN0YWNrKHN0YWNrKSB7XG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYm91bmRpbmcgYm94IGhlbHBlci5cbiAgICpcbiAgICogQHR5cGUge0hlbHBlcnNCb3VuZGluZ0JveH1cbiAgICovXG4gIGdldCBiYm94KCkge1xuICAgIHJldHVybiB0aGlzLl9iQm94O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzbGljZSBoZWxwZXIuXG4gICAqXG4gICAqIEB0eXBlIHtIZWxwZXJzU2xpY2V9XG4gICAqL1xuICBnZXQgc2xpY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBib3JkZXIgaGVscGVyLlxuICAgKlxuICAgKiBAdHlwZSB7SGVscGVyc1NsaWNlfVxuICAgKi9cbiAgZ2V0IGJvcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYm9yZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldC9nZXQgY3VycmVudCBzbGljZSBpbmRleC48YnI+XG4gICAqIFNldHMgb3V0T2ZCb3VuZHMgZmxhZyB0byBrbm93IGlmIHRhcmdldCBpbmRleCBpcyBpbi9vdXQgc3RhY2sgYm91bmRpbmcgYm94Ljxicj5cbiAgICogPGJyPlxuICAgKiBJbnRlcm5hbGx5IHVwZGF0ZXMgdGhlIHNsaWNlSGVscGVyIGluZGV4IGFuZCBwb3NpdGlvbi4gQWxzbyB1cGRhdGVzIHRoZVxuICAgKiBib3JkZXJIZWxwZXIgd2l0aCB0aGUgdXBkYXRlZCBzbGljZUhlbHBlci5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gIH1cblxuICBzZXQgaW5kZXgoaW5kZXgpIHtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzbGljZVxuICAgIHRoaXMuX3NsaWNlLmluZGV4ID0gaW5kZXg7XG4gICAgbGV0IGhhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XG4gICAgdGhpcy5fc2xpY2UucGxhbmVQb3NpdGlvbiA9IHRoaXMuX3ByZXBhcmVTbGljZVBvc2l0aW9uKGhhbGZEaW1lbnNpb25zLCB0aGlzLl9pbmRleCk7XG5cbiAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgYm9yZGVyXG4gICAgdGhpcy5fYm9yZGVyLmhlbHBlcnNTbGljZSA9IHRoaXMuX3NsaWNlO1xuXG4gICAgLy8gdXBkYXRlIG91ck9mQm91bmRzIGZsYWdcbiAgICB0aGlzLl9pc0luZGV4T3V0T2ZCb3VuZHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQvZ2V0IGN1cnJlbnQgc2xpY2Ugb3JpZW50YXRpb24uPGJyPlxuICAgKiBWYWx1ZXM6IDxicj5cbiAgICogICAtIDA6IGFjcXVpc2l0aW9uIGRpcmVjdGlvbiAoc2xpY2Ugbm9ybWFsIGlzIHpfY29zaW5lKTxicj5cbiAgICogICAtIDE6IG5leHQgZGlyZWN0aW9uIChzbGljZSBub3JtYWwgaXMgeF9jb3NpbmUpPGJyPlxuICAgKiAgIC0gMjogbmV4dCBkaXJlY3Rpb24gKHNsaWNlIG5vcm1hbCBpcyB5X2Nvc2luZSk8YnI+XG4gICAqICAgLSBuOiBzZXQgb3JpZW50YXRpb24gdG8gMDxicj5cbiAgICogPGJyPlxuICAgKiBJbnRlcm5hbGx5IHVwZGF0ZXMgdGhlIHNsaWNlSGVscGVyIGRpcmVjdGlvbi4gQWxzbyB1cGRhdGVzIHRoZVxuICAgKiBib3JkZXJIZWxwZXIgd2l0aCB0aGUgdXBkYXRlZCBzbGljZUhlbHBlci5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCBvcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgdGhpcy5fY29tcHV0ZU9yaWVudGF0aW9uTWF4SW5kZXgoKTtcblxuICAgIHRoaXMuX3NsaWNlLnBsYW5lRGlyZWN0aW9uID0gdGhpcy5fcHJlcGFyZURpcmVjdGlvbih0aGlzLl9vcmllbnRhdGlvbik7XG5cbiAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgYm9yZGVyXG4gICAgdGhpcy5fYm9yZGVyLmhlbHBlcnNTbGljZSA9IHRoaXMuX3NsaWNlO1xuICB9XG5cbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQvZ2V0IHRoZSBvdXRPZkJvdW5kIGZsYWcuXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc2V0IG91dE9mQm91bmRzKG91dE9mQm91bmRzKSB7XG4gICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSBvdXRPZkJvdW5kcztcbiAgfVxuXG4gIGdldCBvdXRPZkJvdW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3V0T2ZCb3VuZHM7XG4gIH1cblxuICAvKipcbiAgICogU2V0L2dldCB0aGUgb3JpZW50YXRpb25NYXhJbmRleCBmbGFnLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBvcmllbnRhdGlvbk1heEluZGV4KG9yaWVudGF0aW9uTWF4SW5kZXgpIHtcbiAgICB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4ID0gb3JpZW50YXRpb25NYXhJbmRleDtcbiAgfVxuXG4gIGdldCBvcmllbnRhdGlvbk1heEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4O1xuICB9XG5cbiAgc2V0IGNhbnZhc1dpZHRoKGNhbnZhc1dpZHRoKSB7XG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICB0aGlzLl9zbGljZS5jYW52YXNXaWR0aCA9IHRoaXMuX2NhbnZhc1dpZHRoO1xuICB9XG5cbiAgZ2V0IGNhbnZhc1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXNXaWR0aDtcbiAgfVxuXG4gIHNldCBjYW52YXNIZWlnaHQoY2FudmFzSGVpZ2h0KSB7XG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIHRoaXMuX3NsaWNlLmNhbnZhc0hlaWdodCA9IHRoaXMuX2NhbnZhc0hlaWdodDtcbiAgfVxuXG4gIGdldCBjYW52YXNIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhc0hlaWdodDtcbiAgfVxuXG4gIHNldCBib3JkZXJDb2xvcihib3JkZXJDb2xvcikge1xuICAgIHRoaXMuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgdGhpcy5fYm9yZGVyLmNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgdGhpcy5fc2xpY2UuYm9yZGVyQ29sb3IgPSB0aGlzLl9ib3JkZXJDb2xvcjtcbiAgfVxuXG4gIGdldCBib3JkZXJDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYm9yZGVyQ29sb3I7XG4gIH1cblxuICAvL1xuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgLy9cblxuICAvKipcbiAgICogSW5pdGlhbCBzZXR1cCwgaW5jbHVkaW5nIHN0YWNrIHByZXBhcmUsIGJib3ggcHJlcGFyZSwgc2xpY2UgcHJlcGFyZSBhbmRcbiAgICogYm9yZGVyIHByZXBhcmUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlKCkge1xuICAgIGlmICh0aGlzLl9zdGFjaykge1xuICAgICAgLy8gcHJlcGFyZSBzdGhlIHN0YWNrIGludGVybmFsc1xuICAgICAgdGhpcy5fcHJlcGFyZVN0YWNrKCk7XG5cbiAgICAgIC8vIHByZXBhcmUgdmlzdWFsIG9iamVjdHNcbiAgICAgIHRoaXMuX3ByZXBhcmVCQm94KCk7XG4gICAgICB0aGlzLl9wcmVwYXJlU2xpY2UoKTtcbiAgICAgIHRoaXMuX3ByZXBhcmVCb3JkZXIoKTtcbiAgICAgIC8vIHRvZG86IEFycm93XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnbm8gc3RhY2sgdG8gYmUgcHJlcGFyZWQuLi4nKTtcbiAgICB9XG4gIH1cblxuICBfY29tcHV0ZU9yaWVudGF0aW9uTWF4SW5kZXgoKSB7XG4gICAgbGV0IGRpbWVuc2lvbnNJSksgPSB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLO1xuICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSAwO1xuICAgIHN3aXRjaCAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCA9IGRpbWVuc2lvbnNJSksueiAtIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4ID0gZGltZW5zaW9uc0lKSy54IC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSBkaW1lbnNpb25zSUpLLnkgLSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmchXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBvcmllbnRhdGlvbiwgY2hlY2sgaWYgaW5kZXggaXMgaW4vb3V0IG9mIGJvdW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc0luZGV4T3V0T2ZCb3VuZHMoKSB7XG4gICAgdGhpcy5fY29tcHV0ZU9yaWVudGF0aW9uTWF4SW5kZXgoKTtcbiAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCB8fCB0aGlzLl9pbmRleCA8IDApIHtcbiAgICAgIHRoaXMuX291dE9mQm91bmRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhIHN0YWNrIGZvciB2aXN1YWxpemF0aW9uLiAoaW1hZ2UgdG8gd29ybGQgdHJhbnNmb3JtLCBmcmFtZXMgb3JkZXIsXG4gICAqIHBhY2sgZGF0YSBpbnRvIDggYml0cyB0ZXh0dXJlcywgZXRjLilcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcmVwYXJlU3RhY2soKSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZywgaWYgbm90IHRocm93IGFuIGVycm9yXG4gICAgLy8gY29tcHV0ZSBpbWFnZSB0byB3b3JrZCB0cmFuc2Zvcm0sIG9yZGVyIGZyYW1lcywgZXRjLlxuICAgIGlmICghdGhpcy5fc3RhY2sucHJlcGFyZWQpIHtcbiAgICAgIHRoaXMuX3N0YWNrLnByZXBhcmUoKTtcbiAgICB9XG4gICAgLy8gcGFjayBkYXRhIGludG8gOCBiaXRzIHJnYmEgdGV4dHVyZSBmb3IgdGhlIHNoYWRlclxuICAgIC8vIHRoaXMgb25lIGNhbiBiZSBzbG93Li4uXG4gICAgaWYgKCF0aGlzLl9zdGFjay5wYWNrZWQpIHtcbiAgICAgIHRoaXMuX3N0YWNrLnBhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgYm91bmRpbmcgYm94IGhlbHBlciBnaXZlbiBwcmVwYXJlZCBzdGFjayBhbmQgYWRkIGJvdW5kaW5nIGJveCBoZWxwZXJcbiAgICogdG8gc3RhY2sgaGVscGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVCQm94KCkge1xuICAgIHRoaXMuX2JCb3ggPSBuZXcgSGVscGVyc0JvdW5kaW5nQm94KHRoaXMuX3N0YWNrKTtcbiAgICB0aGlzLmFkZCh0aGlzLl9iQm94KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBib3JkZXIgaGVscGVyIGdpdmVuIHNsaWNlIGhlbHBlciBhbmQgYWRkIGJvcmRlciBoZWxwZXJcbiAgICogdG8gc3RhY2sgaGVscGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVCb3JkZXIoKSB7XG4gICAgdGhpcy5fYm9yZGVyID0gbmV3IEhlbHBlcnNCb3JkZXIodGhpcy5fc2xpY2UpO1xuICAgIHRoaXMuYWRkKHRoaXMuX2JvcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgc2xpY2UgaGVscGVyIGdpdmVuIHByZXBhcmVkIHN0YWNrIGhlbHBlciBhbmQgYWRkIHNsaWNlIGhlbHBlclxuICAgKiB0byBzdGFjayBoZWxwZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlcGFyZVNsaWNlKCkge1xuICAgIGxldCBoYWxmRGltZW5zaW9uc0lKSyA9IHRoaXMuX3N0YWNrLmhhbGZEaW1lbnNpb25zSUpLO1xuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCBpbmRleCBnaXZlbiBvcmllbnRhdGlvblxuICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fcHJlcGFyZVNsaWNlSW5kZXgoaGFsZkRpbWVuc2lvbnNJSkspO1xuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCBwb3NpdGlvbiBnaXZlbiBvcmllbnRhdGlvbiBhbmQgaW5kZXhcbiAgICBsZXQgcG9zaXRpb24gPSB0aGlzLl9wcmVwYXJlU2xpY2VQb3NpdGlvbihoYWxmRGltZW5zaW9uc0lKSywgdGhpcy5faW5kZXgpO1xuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCBkaXJlY3Rpb24gb3JpZW50YXRpb25cbiAgICBsZXQgZGlyZWN0aW9uID0gdGhpcy5fcHJlcGFyZURpcmVjdGlvbih0aGlzLl9vcmllbnRhdGlvbik7XG5cbiAgICB0aGlzLl9zbGljZSA9IG5ldyBIZWxwZXJzU2xpY2UodGhpcy5fc3RhY2ssIHRoaXMuX2luZGV4LCBwb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB0aGlzLmFkZCh0aGlzLl9zbGljZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBzbGljZSBpbmRleCBkZXBlbmRpbmcgb24gb3JpZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gaW5kaWNlcyAtIEluZGljZXMgaW4gZWFjaCBkaXJlY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNsaWNlIGluZGV4IGFjY29yZGluZyB0byBjdXJyZW50IG9yaWVudGF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVTbGljZUluZGV4KGluZGljZXMpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHN3aXRjaCAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGljZXMueik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kaWNlcy54KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRpY2VzLnkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmchXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBzbGljZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gb3JpZW50YXRpb24uXG4gICAqIFNldHMgaW5kZXggaW4gcHJvcGVyIGxvY2F0aW9uIG9mIHJlZmVyZW5jZSBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSByUG9zaXRpb24gLSBSZWZlcmVuY2UgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEN1cnJlbnQgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNsaWNlIGluZGV4IGFjY29yZGluZyB0byBjdXJyZW50IG9yaWVudGF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVTbGljZVBvc2l0aW9uKHJQb3NpdGlvbiwgaW5kZXgpIHtcbiAgICBsZXQgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKTtcbiAgICBzd2l0Y2ggKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgTWF0aC5mbG9vcihyUG9zaXRpb24ueCksXG4gICAgICAgICAgTWF0aC5mbG9vcihyUG9zaXRpb24ueSksXG4gICAgICAgICAgaW5kZXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBNYXRoLmZsb29yKHJQb3NpdGlvbi55KSxcbiAgICAgICAgICBNYXRoLmZsb29yKHJQb3NpdGlvbi56KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgIE1hdGguZmxvb3IoclBvc2l0aW9uLngpLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIE1hdGguZmxvb3IoclBvc2l0aW9uLnopKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBkbyBub3RoaW5nIVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgc2xpY2UgZGlyZWN0aW9uIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWVudGF0aW9uIC0gU2xpY2Ugb3JpZW50YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfSBTbGljZSBkaXJlY3Rpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcmVwYXJlRGlyZWN0aW9uKG9yaWVudGF0aW9uKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmchXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZSB0aGUgc3RhY2sgaGVscGVyIG1lbW9yeSBpbmNsdWRpbmcgdGhlIHNsaWNlIG1lbW9yeS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9zbGljZSk7XG4gICAgdGhpcy5fc2xpY2UuZGlzcG9zZSgpO1xuICAgIHRoaXMuX3NsaWNlID0gbnVsbDtcbiAgICB0aGlzLl9iQm94LmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9iQm94ID0gIG51bGw7XG4gICAgdGhpcy5fYm9yZGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9ib3JkZXIgPSAgbnVsbDtcbiAgfVxuXG59XG4iLCIvKiogKiBJbXBvcnRzICoqKi9cbmltcG9ydCBTaGFkZXJzVW5pZm9ybSBmcm9tICcuLi9zaGFkZXJzL3NoYWRlcnMudnIudW5pZm9ybSc7XG5pbXBvcnQgU2hhZGVyc1ZlcnRleCBmcm9tICcuLi9zaGFkZXJzL3NoYWRlcnMudnIudmVydGV4JztcbmltcG9ydCBTaGFkZXJzRnJhZ21lbnQgZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLnZyLmZyYWdtZW50JztcblxuaW1wb3J0IEhlbHBlcnNNYXRlcmlhbE1peGluIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRlcmlhbC5taXhpbic7XG5cblxuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdm9sdW1lcmVuZGVyaW5nXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc1ZvbHVtZVJlbmRlcmluZyBleHRlbmRzIEhlbHBlcnNNYXRlcmlhbE1peGluKFRIUkVFLk9iamVjdDNEKSB7XG4gIGNvbnN0cnVjdG9yKHN0YWNrKSB7XG4gICAgLy9cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMuX3NoYWRlcnNGcmFnbWVudCA9IFNoYWRlcnNGcmFnbWVudDtcbiAgICB0aGlzLl9zaGFkZXJzVmVydGV4ID0gU2hhZGVyc1ZlcnRleDtcbiAgICB0aGlzLl91bmlmb3JtcyA9IFNoYWRlcnNVbmlmb3JtLnVuaWZvcm1zKCk7XG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcblxuICAgIHRoaXMuX2ludGVycG9sYXRpb24gPSAxOyAvLyBkZWZhdWx0IHRvIHRyaWxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG4gIF9jcmVhdGUoKSB7XG4gICAgdGhpcy5fcHJlcGFyZVN0YWNrKCk7XG4gICAgdGhpcy5fcHJlcGFyZVRleHR1cmUoKTtcbiAgICB0aGlzLl9wcmVwYXJlTWF0ZXJpYWwoKTtcbiAgICB0aGlzLl9wcmVwYXJlR2VvbWV0cnkoKTtcblxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTWVzaCh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xuICB9XG5cbiAgX3ByZXBhcmVTdGFjaygpIHtcbiAgICBpZiAoIXRoaXMuX3N0YWNrLnByZXBhcmVkKSB7XG4gICAgICB0aGlzLl9zdGFjay5wcmVwYXJlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zdGFjay5wYWNrZWQpIHtcbiAgICAgIHRoaXMuX3N0YWNrLnBhY2soKTtcbiAgICB9XG4gIH1cblxuICBfcHJlcGFyZU1hdGVyaWFsKCkge1xuICAgIC8vIGNvbXBlbnNhdGUgZm9yIHRoZSBvZmZzZXQgdG8gb25seSBwYXNzID4gMCB2YWx1ZXMgdG8gc2hhZGVyc1xuICAgIC8vIG1vZGVscyA+IG1vZGVscy5zdGFjay5qcyA6IF9wYWNrVG84Qml0c1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGlmICh0aGlzLl9zdGFjay5fbWluTWF4WzBdIDwgMCkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5fc3RhY2suX21pbk1heFswXTtcbiAgICB9XG5cbiAgICAvLyB1bmlmb3Jtc1xuICAgIHRoaXMuX3VuaWZvcm1zID0gU2hhZGVyc1VuaWZvcm0udW5pZm9ybXMoKTtcbiAgICB0aGlzLl91bmlmb3Jtcy51V29ybGRCQm94LnZhbHVlID0gdGhpcy5fc3RhY2sud29ybGRCb3VuZGluZ0JveCgpO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlU2l6ZS52YWx1ZSA9IHRoaXMuX3N0YWNrLnRleHR1cmVTaXplO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlQ29udGFpbmVyLnZhbHVlID0gdGhpcy5fdGV4dHVyZXM7XG4gICAgdGhpcy5fdW5pZm9ybXMudVdvcmxkVG9EYXRhLnZhbHVlID0gdGhpcy5fc3RhY2subHBzMklKSztcbiAgICB0aGlzLl91bmlmb3Jtcy51TnVtYmVyT2ZDaGFubmVscy52YWx1ZSA9IHRoaXMuX3N0YWNrLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgdGhpcy5fdW5pZm9ybXMudVBpeGVsVHlwZS52YWx1ZSA9IHRoaXMuX3N0YWNrLnBpeGVsVHlwZTtcbiAgICB0aGlzLl91bmlmb3Jtcy51Qml0c0FsbG9jYXRlZC52YWx1ZSA9IHRoaXMuX3N0YWNrLmJpdHNBbGxvY2F0ZWQ7XG4gICAgdGhpcy5fdW5pZm9ybXMudVBhY2tlZFBlclBpeGVsLnZhbHVlID0gdGhpcy5fc3RhY2sucGFja2VkUGVyUGl4ZWw7XG4gICAgdGhpcy5fdW5pZm9ybXMudVdpbmRvd0NlbnRlcldpZHRoLnZhbHVlID0gW29mZnNldCArIHRoaXMuX3N0YWNrLndpbmRvd0NlbnRlciwgdGhpcy5fc3RhY2sud2luZG93V2lkdGggKiAwLjhdO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVSZXNjYWxlU2xvcGVJbnRlcmNlcHQudmFsdWUgPSBbdGhpcy5fc3RhY2sucmVzY2FsZVNsb3BlLCB0aGlzLl9zdGFjay5yZXNjYWxlSW50ZXJjZXB0XTtcbiAgICB0aGlzLl91bmlmb3Jtcy51RGF0YURpbWVuc2lvbnMudmFsdWUgPSBbdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy56XTtcbiAgICB0aGlzLl91bmlmb3Jtcy51SW50ZXJwb2xhdGlvbi52YWx1ZSA9IHRoaXMuX2ludGVycG9sYXRpb247XG5cbiAgICB0aGlzLl9jcmVhdGVNYXRlcmlhbCh7XG4gICAgICBzaWRlOiBUSFJFRS5Gcm9udFNpZGUsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIF9wcmVwYXJlR2VvbWV0cnkoKSB7XG4gICAgbGV0IHdvcmxkQkJveCA9IHRoaXMuX3N0YWNrLndvcmxkQm91bmRpbmdCb3goKTtcbiAgICBsZXQgY2VudGVyTFBTID0gdGhpcy5fc3RhY2sud29ybGRDZW50ZXIoKTtcblxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuICAgICAgd29ybGRCQm94WzFdIC0gd29ybGRCQm94WzBdLFxuICAgICAgd29ybGRCQm94WzNdIC0gd29ybGRCQm94WzJdLFxuICAgICAgd29ybGRCQm94WzVdIC0gd29ybGRCQm94WzRdKTtcbiAgICB0aGlzLl9nZW9tZXRyeS5hcHBseU1hdHJpeChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbihcbiAgICAgIGNlbnRlckxQUy54LCBjZW50ZXJMUFMueSwgY2VudGVyTFBTLnopKTtcbiAgfVxuXG4gIGdldCB1bmlmb3JtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdW5pZm9ybXM7XG4gIH1cblxuICBzZXQgdW5pZm9ybXModW5pZm9ybXMpIHtcbiAgICB0aGlzLl91bmlmb3JtcyA9IHVuaWZvcm1zO1xuICB9XG5cbiAgZ2V0IHN0YWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgfVxuXG4gIHNldCBzdGFjayhzdGFjaykge1xuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gIH1cblxuICBnZXQgaW50ZXJwb2xhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHNldCBpbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb24pIHtcbiAgICB0aGlzLl9pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICB0aGlzLl91bmlmb3Jtcy51SW50ZXJwb2xhdGlvbi52YWx1ZSA9IHRoaXMuX2ludGVycG9sYXRpb247XG4gICAgdGhpcy5fdXBkYXRlTWF0ZXJpYWwoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9pbnRlcmFjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVyYWN0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuICBfY3JlYXRlKCkge1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgfVxuXG59XG4iLCJpbXBvcnQgSW50ZXJhY3RvciBmcm9tICcuL2hlbHBlcnMueC5pbnRlcmFjdG9yJztcbmltcG9ydCBNZXNoIGZyb20gJy4vaGVscGVycy54Lm1lc2gnO1xuaW1wb3J0IFJlbmRlcmVyM0QgZnJvbSAnLi9oZWxwZXJzLngucmVuZGVyZXIzZCc7XG5pbXBvcnQgUmVuZGVyZXIyRCBmcm9tICcuL2hlbHBlcnMueC5yZW5kZXJlcjJkJztcbmltcG9ydCBWb2x1bWUgZnJvbSAnLi9oZWxwZXJzLngudm9sdW1lJztcblxuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEludGVyYWN0b3IsXG4gIE1lc2gsXG4gIFJlbmRlcmVyM0QsXG4gIFJlbmRlcmVyMkQsXG4gIFZvbHVtZSxcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy94L21lc2hcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xuXG4gICAgdGhpcy5fM2pzVlRLX2xvYWRlciA9IG5ldyBUSFJFRS5WVEtMb2FkZXIoKTtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB0aGlzLl9tYXRlcmlhbENvbG9yID0gMHhFOTFFNjM7XG4gICAgdGhpcy5fUkFTdG9MUFMgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuX21hdGVyaWFsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgfVxuXG4gIC8vIGFjY2Vzc29yIHByb3BlcnRpZXNcbiAgZ2V0IGZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGU7XG4gIH1cblxuICBzZXQgZmlsZShmbmFtZSkge1xuICAgIHRoaXMuX2ZpbGUgPSBmbmFtZTtcbiAgfVxuXG4gIGdldCBtYXRlcmlhbENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbENvbG9yO1xuICB9XG5cbiAgc2V0IG1hdGVyaWFsQ29sb3IoY29sb3IpIHtcbiAgICB0aGlzLl9tYXRlcmlhbENvbG9yID0gY29sb3I7XG4gIH1cblxuICAvLyBsb2FkIGZ1bmN0aW9uXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5fM2pzVlRLX2xvYWRlci5sb2FkKHRoaXMuZmlsZSxcbiAgICAgICAgICAoZ2VvbWV0cnkpID0+IHtcbiAgICAgICAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgICAgICAgIHRoaXMuX1JBU3RvTFBTID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fUkFTdG9MUFMuc2V0KC0xLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIC0xLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgIHRoaXMuX21lc2guYXBwbHlNYXRyaXgodGhpcy5fUkFTdG9MUFMpO1xuICAgICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIGFuZCByZXR1cm4gdGhlIG1lc2hcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9tZXNoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHt9LFxuICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkbid0IGxvYWQgZmlsZTogJHt0aGlzLmZpbGV9LmAsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHttZXNzYWdlOiBgRmlsZSBpcyBub3QgZGVmaW5lZDogJHt0aGlzLmZpbGV9LmB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9yZW5kZXJlcjJkXG4gKi9cbmltcG9ydCBDYW1lcmFzT3J0aG9ncmFwaGljIGZyb20gJy4uLy4uL2NhbWVyYXMvY2FtZXJhcy5vcnRob2dyYXBoaWMnO1xuaW1wb3J0IENvbnRyb2xzT3J0aG9ncmFwaGljIGZyb20gJy4uLy4uL2NvbnRyb2xzL2NvbnRyb2xzLnRyYWNrYmFsbG9ydGhvJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJJZD0ncjJkJywgb3JpZW50YXRpb249J2RlZmF1bHQnKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLl9jb250cm9scyA9IG51bGw7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB0aGlzLl9zY2VuZSA9IG51bGw7XG4gICAgdGhpcy5fb2JqZWN0ID0gbnVsbDtcblxuICAgIHRoaXMuX2luaXRSZW5kZXJlcihjb250YWluZXJJZCk7XG4gICAgdGhpcy5faW5pdENhbWVyYSgpO1xuICAgIHRoaXMuX2luaXRTY2VuZSgpO1xuICAgIHRoaXMuX2luaXRDb250cm9scygpO1xuXG4gICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fb25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uV2luZG93UmVzaXplID0gdGhpcy5fb25XaW5kb3dSZXNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBhZGQob2JqZWN0KSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMuX3NjZW5lLmFkZCh0aGlzLl9vYmplY3QpO1xuXG4gICAgdGhpcy5fc2V0dXBDYW1lcmEodGhpcy5fb2JqZWN0LnN0YWNrKTtcbiAgICB0aGlzLl9vcmllbnRDYW1lcmEodGhpcy5fb2JqZWN0LCB0aGlzLl9vcmllbnRhdGlvbik7XG5cbiAgICB0aGlzLl9vYmplY3QuY2FudmFzV2lkdGggPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5fb2JqZWN0LmNhbnZhc0hlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdPblNjcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplLCBmYWxzZSk7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdPblNjcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCBmYWxzZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplLCBmYWxzZSk7XG4gIH1cblxuICBhbmltYXRlKCkge1xuICAgIHRoaXMuX2NvbnRyb2xzLnVwZGF0ZSgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcblxuICAgIC8vIHJlcXVlc3QgbmV3IGZyYW1lXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuXG4gIF9pbml0UmVuZGVyZXIoY29udGFpbmVySWQpIHtcbiAgICAvLyByZW5kZXJlclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcklkKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICB9KTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTaXplKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgyMTIxMjEsIDEpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgfVxuXG4gIF9pbml0Q2FtZXJhKCkge1xuICAgIHRoaXMuX2NhbWVyYSA9IG5ldyBDYW1lcmFzT3J0aG9ncmFwaGljKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAvIC0yLFxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIC8gMiwgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCAvIDIsXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IC8gLTIsIDEsIDEwMDApO1xuICB9XG5cbiAgX2luaXRTY2VuZSgpIHtcbiAgICB0aGlzLl9zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICB9XG5cbiAgX2luaXRDb250cm9scygpIHtcbiAgICAvLyBjb250cm9sc1xuICAgIHRoaXMuX2NvbnRyb2xzID0gbmV3IENvbnRyb2xzT3J0aG9ncmFwaGljKHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9jb250cm9scy5zdGF0aWNNb3ZpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2NvbnRyb2xzLm5vUm90YXRlID0gdHJ1ZTtcbiAgICB0aGlzLl9jYW1lcmEuY29udHJvbHMgPSB0aGlzLl9jb250cm9scztcbiAgfVxuXG4gIF9zZXR1cENhbWVyYShzdGFjaykge1xuICAgIC8vIHNldCBjYW1lcmFcbiAgICBsZXQgd29ybGRiYiA9IHN0YWNrLndvcmxkQm91bmRpbmdCb3goKTtcbiAgICBsZXQgbHBzRGltcyA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgd29ybGRiYlsxXSAtIHdvcmxkYmJbMF0sXG4gICAgICB3b3JsZGJiWzNdIC0gd29ybGRiYlsyXSxcbiAgICAgIHdvcmxkYmJbNV0gLSB3b3JsZGJiWzRdXG4gICAgKTtcblxuICAgIC8vIGJveDoge2hhbGZEaW1lbnNpb25zLCBjZW50ZXJ9XG4gICAgbGV0IGJveCA9IHtcbiAgICAgIGNlbnRlcjogc3RhY2sud29ybGRDZW50ZXIoKS5jbG9uZSgpLFxuICAgICAgaGFsZkRpbWVuc2lvbnM6IG5ldyBUSFJFRS5WZWN0b3IzKGxwc0RpbXMueCArIDEwLCBscHNEaW1zLnkgKyAxMCxcbiAgICAgICAgbHBzRGltcy56ICsgMTApLFxuICAgIH07XG5cbiAgICAvLyBpbml0IGFuZCB6b29tXG4gICAgbGV0IGNhbnZhcyA9IHtcbiAgICAgICAgd2lkdGg6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgfTtcblxuICAgIHRoaXMuX2NhbWVyYS5kaXJlY3Rpb25zID0gW3N0YWNrLnhDb3NpbmUsIHN0YWNrLnlDb3NpbmUsIHN0YWNrLnpDb3NpbmVdO1xuICAgIHRoaXMuX2NhbWVyYS5ib3ggPSBib3g7XG4gICAgdGhpcy5fY2FtZXJhLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLl9jYW1lcmEudXBkYXRlKCk7XG4gICAgdGhpcy5fY2FtZXJhLmZpdEJveCgyKTtcbiAgfVxuXG4gIF9vcmllbnRDYW1lcmEodGFyZ2V0LCBvcmllbnRhdGlvbj0nZGVmYXVsdCcpIHtcbiAgICAgIHRoaXMuX2NhbWVyYS5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgICAgdGhpcy5fY2FtZXJhLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5fY2FtZXJhLmZpdEJveCgyKTtcbiAgICAgIHRhcmdldC5vcmllbnRhdGlvbiA9IHRoaXMuX2NhbWVyYS5zdGFja09yaWVudGF0aW9uO1xuICB9XG5cbiAgX29uV2luZG93UmVzaXplKCkge1xuICAgICAgdGhpcy5fY2FtZXJhLmNhbnZhcyA9IHtcbiAgICAgICAgd2lkdGg6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgfTtcbiAgICAgIHRoaXMuX2NhbWVyYS5maXRCb3goMik7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTaXplKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gICAgICB0aGlzLl9vYmplY3QuY2FudmFzV2lkdGggPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICB0aGlzLl9vYmplY3QuY2FudmFzSGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIF9vblNjcm9sbChldmVudCkge1xuICAgIGlmIChldmVudC5kZWx0YSA+IDApIHtcbiAgICAgIGlmICh0aGlzLl9vYmplY3QuaW5kZXggPj0gdGhpcy5fb2JqZWN0Lm9yaWVudGF0aW9uTWF4SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fb2JqZWN0LmluZGV4ICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9vYmplY3QuaW5kZXggPD0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9vYmplY3QuaW5kZXggLT0gMTtcbiAgICB9XG4gIH1cblxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9yZW5kZXJlcjNkXG4gKi9cbmltcG9ydCBDb250cm9sc1RyYWNrYmFsbCBmcm9tICcuLi8uLi9jb250cm9scy9jb250cm9scy50cmFja2JhbGwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcklkPSdyM2QnKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLl9jb250cm9scyA9IG51bGw7XG4gICAgdGhpcy5fc2NlbmUgPSBudWxsO1xuXG4gICAgdGhpcy5faW5pdFJlbmRlcmVyKGNvbnRhaW5lcklkKTtcbiAgICB0aGlzLl9pbml0Q2FtZXJhKCk7XG4gICAgdGhpcy5faW5pdFNjZW5lKCk7XG4gICAgdGhpcy5faW5pdENvbnRyb2xzKCk7XG5cbiAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9vbldpbmRvd1Jlc2l6ZSA9IHRoaXMuX29uV2luZG93UmVzaXplLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgc2V0IGNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gIH1cblxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIH1cblxuICBhZGQob2JqKSB7XG4gICAgdGhpcy5fc2NlbmUuYWRkKG9iaik7XG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUsIGZhbHNlKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICB9XG5cbiAgY2VudGVyKHdvcmxkUG9zaXRpb24pIHtcbiAgICAvLyB1cGRhdGUgY2FtcmVhJ3MgYW5kIGNvbnRyb2wncyB0YXJnZXRcbiAgICB0aGlzLl9jYW1lcmEubG9va0F0KHdvcmxkUG9zaXRpb24ueCwgd29ybGRQb3NpdGlvbi55LCB3b3JsZFBvc2l0aW9uLnopO1xuICAgIHRoaXMuX2NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5fY29udHJvbHMudGFyZ2V0LnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSxcbiAgICAgIHdvcmxkUG9zaXRpb24ueik7XG4gIH1cblxuICBhbmltYXRlKCkge1xuICAgIHRoaXMuX2NvbnRyb2xzLnVwZGF0ZSgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcblxuICAgIC8vIHJlcXVlc3QgbmV3IGZyYW1lXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuXG4gIF9vbldpbmRvd1Jlc2l6ZSgpIHtcbiAgICB0aGlzLl9jYW1lcmEuYXNwZWN0ID1cbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAvIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgdGhpcy5fY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFNpemUodGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gIH1cblxuICBfaW5pdFJlbmRlcmVyKGNvbnRhaW5lcklkKSB7XG4gICAgLy8gcmVuZGVyZXJcbiAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJZCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgfSk7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U2l6ZSh0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4NDI0MjQyLCAxKTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gIH1cblxuICBfaW5pdENhbWVyYSgpIHtcbiAgICB0aGlzLl9jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggLyB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0LCAxLCAxMDAwMDAwMCk7XG4gICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnggPSAyNTA7XG4gICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnkgPSAyNTA7XG4gICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnogPSAyNTA7XG4gIH1cblxuICBfaW5pdFNjZW5lKCkge1xuICAgIC8vIGFkZCBzb21lIGxpZ2h0cyB0byB0aGUgc2NlbmUgYnkgZGVmYXVsdFxuICAgIHRoaXMuX3NjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cbiAgICAvLyBhbWJpZW50XG4gICAgdGhpcy5fc2NlbmUuYWRkKG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHgzNTM1MzUpKTtcblxuICAgIC8vIGRpcmVjdGlvbmFsIDFcbiAgICBsZXQgZGlyZWN0aW9uYWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcbiAgICBkaXJlY3Rpb25hbExpZ2h0LnBvc2l0aW9uLnNldCgyMDAsIDIwMCwgMTAwMCkubm9ybWFsaXplKCk7XG4gICAgdGhpcy5fc2NlbmUuYWRkKGRpcmVjdGlvbmFsTGlnaHQpO1xuXG4gICAgLy8gZGlyZWN0aW9uYWwgMlxuICAgIGxldCBkaXJlY3Rpb25hbExpZ2h0MiA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcbiAgICBkaXJlY3Rpb25hbExpZ2h0Mi5wb3NpdGlvbi5zZXQoLTIwMCwgLTIwMCwgLTEwMDApLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuX3NjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0Mik7XG4gIH1cblxuICBfaW5pdENvbnRyb2xzKCkge1xuICAgIC8vIGNvbnRyb2xzXG4gICAgdGhpcy5fY29udHJvbHMgPSBuZXcgQ29udHJvbHNUcmFja2JhbGwodGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgIHRoaXMuX2NvbnRyb2xzLnJvdGF0ZVNwZWVkID0gMS40O1xuICAgIHRoaXMuX2NvbnRyb2xzLnpvb21TcGVlZCA9IDEuMjtcbiAgICB0aGlzLl9jb250cm9scy5wYW5TcGVlZCA9IDAuODtcbiAgfVxuXG59XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy94L3ZvbHVtZVxuICovXG5cbmltcG9ydCBIZWxwZXJzU3RhY2sgZnJvbSAnLi4vaGVscGVycy5zdGFjayc7XG5pbXBvcnQgTG9hZGVyc1ZvbHVtZSBmcm9tICcuLi8uLi9sb2FkZXJzL2xvYWRlcnMudm9sdW1lJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xuICAgIHRoaXMuX3Byb2dyZXNzYmFyQ29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLl9zdGFjayA9IG51bGw7XG4gICAgdGhpcy5fY2VudGVyTFBTID0gbnVsbDtcbiAgICB0aGlzLl94U2xpY2UgPSBudWxsO1xuICAgIHRoaXMuX3lTbGljZSA9IG51bGw7XG4gICAgdGhpcy5felNsaWNlID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFjY2Vzc29yIHByb3BlcnRpZXNcbiAgZ2V0IGZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGU7XG4gIH1cblxuICBzZXQgZmlsZShmbmFtZSkge1xuICAgIHRoaXMuX2ZpbGUgPSBmbmFtZTtcbiAgfVxuXG4gIHNldCBwcm9ncmVzc2JhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2JhckNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBjZW50ZXJMUFMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NlbnRlckxQUztcbiAgfVxuXG4gIGdldCBzdGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2s7XG4gIH1cblxuICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgX2NyZWF0ZVNsaWNlKG9yaWVudGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3N0YWNrKSB7XG4gICAgICBjb25zdCBzdGFja0hlbHBlciA9IG5ldyBIZWxwZXJzU3RhY2sodGhpcy5fc3RhY2spO1xuICAgICAgc3RhY2tIZWxwZXIub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblxuICAgICAgaWYgKG9yaWVudGF0aW9uPT09MCkge1xuICAgICAgICBzdGFja0hlbHBlci5ib3JkZXIuY29sb3IgPSAweEY0NDMzNjtcbiAgICAgICAgdGhpcy5feFNsaWNlID0gc3RhY2tIZWxwZXI7XG4gICAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uPT09MSkge1xuICAgICAgICBzdGFja0hlbHBlci5iYm94LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgc3RhY2tIZWxwZXIuYm9yZGVyLmNvbG9yID0gMHg0Q0FGNTA7XG4gICAgICAgIHRoaXMuX3lTbGljZSA9IHN0YWNrSGVscGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2tIZWxwZXIuYmJveC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHN0YWNrSGVscGVyLmJvcmRlci5jb2xvciA9IDB4MjE5NkYzO1xuICAgICAgICB0aGlzLl96U2xpY2UgPSBzdGFja0hlbHBlcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2VudGVyTFBTID0gc3RhY2tIZWxwZXIuc3RhY2sud29ybGRDZW50ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvLyBwdWJsaWMgbWV0aG9kc1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgIC8vIGluc3RhbnRpYXRlIHRoZSBsb2FkZXJcbiAgICAgIC8vIGl0IGxvYWRzIGFuZCBwYXJzZXMgdGhlIGRpY29tIGltYWdlXG4gICAgICBjb25zdCBsb2FkZXIgPSBuZXcgTG9hZGVyc1ZvbHVtZSh0aGlzLl9wcm9ncmVzc2JhckNvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbG9hZGVyLmxvYWQodGhpcy5maWxlKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpZiAobG9hZGVyLmRhdGEubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Qoe21lc3NhZ2U6IGBObyBkYXRhIGxvYWRlZDogJHtsb2FkZXIuZGF0YX0uYH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdGhyZWUgc2xpY2VzIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBsb2FkZWRcbiAgICAgICAgICBjb25zdCBzZXJpZXMgPSBsb2FkZXIuZGF0YVswXS5tZXJnZVNlcmllcyhsb2FkZXIuZGF0YSlbMF07XG4gICAgICAgICAgbG9hZGVyLmZyZWUoKTtcblxuICAgICAgICAgIHRoaXMuX3N0YWNrID0gc2VyaWVzLnN0YWNrWzBdO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZVNsaWNlKDApO1xuICAgICAgICAgIHRoaXMuYWRkKHRoaXMuX3hTbGljZSk7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlU2xpY2UoMSk7XG4gICAgICAgICAgdGhpcy5hZGQodGhpcy5feVNsaWNlKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTbGljZSgyKTtcbiAgICAgICAgICB0aGlzLmFkZCh0aGlzLl96U2xpY2UpO1xuXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgbG9hZGVyLmZyZWUoKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdTb21ldGhpbmcgd2VudCB3cm9uZyBsb2FkaW5nIHRoZSB2b2x1bWUuLi4nKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7bWVzc2FnZTogYEZpbGUgbm90IGRlZmluZWQ6ICR7dGhpcy5maWxlfS5gfSk7XG4gIH1cbn1cbiIsIi8qKiBJbXBvcnRzICoqL1xuaW1wb3J0IEhlbHBlcnNQcm9ncmVzc0JhciBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMucHJvZ3Jlc3NiYXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuXG5cbi8qKlxuICpcbiAqIEl0IGlzIHR5cGljYWxseSB1c2VkIHRvIGxvYWQgYSBESUNPTSBpbWFnZS4gVXNlIGxvYWRpbmcgbWFuYWdlciBmb3JcbiAqIGFkdmFuY2VkIHVzYWdlLCBzdWNoIGFzIG11bHRpcGxlIGZpbGVzIGhhbmRsaW5nLlxuICpcbiAqIERlbW86IHtAbGluayBodHRwczovL2ZubmRzYy5naXRodWIuaW8vdmpzI2xvYWRlcl9kaWNvbX1cbiAqXG4gKiBAbW9kdWxlIGxvYWRlcnMvYmFzZVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpbGVzID0gWycvZGF0YS9kY20vZnJ1aXQnXTtcbiAqXG4gKiAvLyBJbnN0YW50aWF0ZSBhIGRpY29tIGxvYWRlclxuICogdmFyIGxEaWNvbW9hZGVyID0gbmV3IGRpY29tKCk7XG4gKlxuICogLy8gbG9hZCBhIHJlc291cmNlXG4gKiBsb2FkZXIubG9hZChcbiAqICAgLy8gcmVzb3VyY2UgVVJMXG4gKiAgIGZpbGVzWzBdLFxuICogICAvLyBGdW5jdGlvbiB3aGVuIHJlc291cmNlIGlzIGxvYWRlZFxuICogICBmdW5jdGlvbihvYmplY3QpIHtcbiAqICAgICAvL3NjZW5lLmFkZCggb2JqZWN0ICk7XG4gKiAgICAgd2luZG93LmNvbnNvbGUubG9nKG9iamVjdCk7XG4gKiAgIH1cbiAqICk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRlcnNCYXNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIExvYWRlci5cbiAgICogQHBhcmFtIHtkb219IGNvbnRhaW5lciAtIFRoZSBkb20gY29udGFpbmVyIG9mIGxvYWRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IFByb2dyZXNzQmFyIC0gVGhlIHByb2dyZXNzYmFyIG9mIGxvYWRlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciA9IG51bGwsIFByb2dyZXNzQmFyID0gSGVscGVyc1Byb2dyZXNzQmFyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9sb2FkZWQgPSAtMTtcbiAgICB0aGlzLl90b3RhbExvYWRlZCA9IC0xO1xuICAgIHRoaXMuX3BhcnNlZCA9IC0xO1xuICAgIHRoaXMuX3RvdGFsUGFyc2VkID0gLTE7XG5cbiAgICB0aGlzLl9kYXRhID0gW107XG5cbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5fcHJvZ3Jlc3NCYXIgPSBudWxsO1xuICAgIGlmICh0aGlzLl9jb250YWluZXIgJiYgUHJvZ3Jlc3NCYXIpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyID0gbmV3IFByb2dyZXNzQmFyKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGZyZWUgdGhlIHJlZmVyZW5jZS5cbiAgICovXG4gIGZyZWUoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgICAvLyB0aGlzLl9oZWxwZXJzUHJvZ3Jlc3NCYXIgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0Jhci5mcmVlKCk7XG4gICAgICB0aGlzLl9wcm9ncmVzc0JhciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGxvYWQgdGhlIHJlc291cmNlIGJ5IHVybC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHJlc291cmNlIHVybC5cbiAgICogQHJldHVybiB7cHJvbWlzZX0gcHJvbWlzZS5cbiAgICovXG4gIGZldGNoKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuICAgICAgcmVxdWVzdC5vbmxvYWRzdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAvLyBlbWl0ICdmZXRjaC1zdGFydCcgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1zdGFydCcsIHtcbiAgICAgICAgICBmaWxlOiB1cmwsXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICAgICAgICB0aGlzLl90b3RhbExvYWRlZCA9IGV2ZW50LnRvdGFsO1xuXG4gICAgICAgICAgLy8gd2lsbCBiZSByZW1vdmVkIGFmdGVyIGV2ZW50ZXIgc2V0IHVwXG4gICAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0Jhci51cGRhdGUodGhpcy5fbG9hZGVkLCB0aGlzLl90b3RhbExvYWRlZCxcbiAgICAgICAgICAgICAgJ2xvYWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgYnVmZmVyID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGVtaXQgJ2ZldGNoLXN1Y2Nlc3MnIGV2ZW50XG4gICAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1zdWNjZXNzJywge1xuICAgICAgICAgICAgZmlsZTogdXJsLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHRvdGFsTG9hZGVkOiBldmVudC50b3RhbCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLWVycm9yJyBldmVudFxuICAgICAgICB0aGlzLmVtaXQoJ2ZldGNoLWVycm9yJywge1xuICAgICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9KTtcblxuICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXNUZXh0KTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IChldmVudCkgPT4ge1xuICAgICAgICAvLyBlbWl0ICdmZXRjaC1zdGFydCcgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1hYm9ydCcsIHtcbiAgICAgICAgICBmaWxlOiB1cmwsXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVqZWN0KHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgLy8gZW1pdCAnZmV0Y2gtdGltZW91dCcgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC10aW1lb3V0Jywge1xuICAgICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9KTtcblxuICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXNUZXh0KTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgICAgIHRoaXMuX3RvdGFsTG9hZGVkID0gZXZlbnQudG90YWw7XG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLXByb2dyZXNzJyBldmVudFxuICAgICAgICB0aGlzLmVtaXQoJ2ZldGNoLXByb2dyZXNzJywge1xuICAgICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgICB0b3RhbDogZXZlbnQudG90YWwsXG4gICAgICAgICAgbG9hZGVkOiBldmVudC5sb2FkZWQsXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBldmVudGVyIHNldCB1cFxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgICB0aGlzLl9wcm9ncmVzc0Jhci51cGRhdGUodGhpcy5fbG9hZGVkLCB0aGlzLl90b3RhbExvYWRlZCxcbiAgICAgICAgICAgICdsb2FkJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLWVuZCcgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1lbmQnLCB7XG4gICAgICAgICAgZmlsZTogdXJsLFxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBqdXN0IHVzZSBvbmxvYWQgd2hlbiBzdWNjZXNzIGFuZCBvbmVycm9yIHdoZW4gZmFpbHVyZSwgZXRjIG9uYWJvcnRcbiAgICAgICAgLy8gcmVqZWN0KHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSB0aGUgZGF0YSBsb2FkZWRcbiAgICogU0hPVUxEIEJFIGltcGxlbWVudGQgYnkgZGV0YWlsIGxvYWRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIC0gbG9hZGVkIGRhdGEuXG4gICAqIEByZXR1cm4ge3Byb21pc2V9IHByb21pc2UuXG4gICAqL1xuICBwYXJzZShyZXNwb25zZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWZhdWx0IGxvYWQgc2VxdWVuY2UgZ3JvdXAgcHJvbWlzZS5cbiAgICogQHBhcmFtIHthcnJheX0gdXJsIC0gcmVzb3VyY2UgdXJsLlxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlLlxuICAgKi9cbiAgbG9hZFNlcXVlbmNlR3JvdXAodXJsKSB7XG4gICAgY29uc3QgZmV0Y2hTZXF1ZW5jZSA9IFtdO1xuXG4gICAgdXJsLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGZldGNoU2VxdWVuY2UucHVzaChcbiAgICAgICAgdGhpcy5mZXRjaChmaWxlKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChmZXRjaFNlcXVlbmNlKVxuICAgICAgLnRoZW4oKHJhd2RhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UocmF3ZGF0YSk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdvb3BzLi4uIHNvbWV0aGluZyB3ZW50IHdyb25nLi4uJyk7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWZhdWx0IGxvYWQgc2VxdWVuY2UgcHJvbWlzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHJlc291cmNlIHVybC5cbiAgICogQHJldHVybiB7cHJvbWlzZX0gcHJvbWlzZS5cbiAgICovXG4gIGxvYWRTZXF1ZW5jZSh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwpXG4gICAgICAudGhlbigocmF3ZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShyYXdkYXRhKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLl9kYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ29vcHMuLi4gc29tZXRoaW5nIHdlbnQgd3JvbmcuLi4nKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGxvYWQgdGhlIGRhdGEgYnkgdXJsKHVybHMpXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB1cmwgLSByZXNvdXJjZSB1cmwuXG4gICAqIEByZXR1cm4ge3Byb21pc2V9IHByb21pc2VcbiAgICovXG4gIGxvYWQodXJsKSB7XG4gICAgLy8gaWYgd2UgbG9hZCBhIHNpbmdsZSBmaWxlLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVybCkpIHtcbiAgICAgIHVybCA9IFt1cmxdO1xuICAgIH1cblxuICAgIC8vIGVtaXQgJ2xvYWQtc3RhcnQnIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdsb2FkLXN0YXJ0Jywge1xuICAgICAgZmlsZXM6IHVybCxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCksXG4gICAgfSk7XG5cbiAgICBjb25zdCBsb2FkU2VxdWVuY2VzID0gW107XG4gICAgdXJsLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShmaWxlKSkge1xuICAgICAgICBsb2FkU2VxdWVuY2VzLnB1c2goXG4gICAgICAgICAgdGhpcy5sb2FkU2VxdWVuY2UoZmlsZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRTZXF1ZW5jZXMucHVzaChcbiAgICAgICAgICB0aGlzLmxvYWRTZXF1ZW5jZUdyb3VwKGZpbGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRTZXF1ZW5jZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkYXRhXG4gICAqIEBwYXJhbSB7YXJyYXl9IGRhdGFcbiAgICovXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YVxuICAgKiBAcmV0dXJuIHthcnJheX0gZGF0YSBsb2FkZWRcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG5cbn1cbiIsImltcG9ydCBWb2x1bWUgZnJvbSAnLi9sb2FkZXJzLnZvbHVtZSc7XG5cbi8qKlxuICogQG1vZHVsZSBsb2FkZXJzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBWb2x1bWUsXG59O1xuIiwiLyoqICogSW1wb3J0cyAqKiovXG5jb25zdCBQQUtPID0gcmVxdWlyZSgncGFrbycpO1xuXG5pbXBvcnQgTG9hZGVyc0Jhc2UgZnJvbSAnLi9sb2FkZXJzLmJhc2UnO1xuaW1wb3J0IENvcmVVdGlscyBmcm9tICcuLi9jb3JlL2NvcmUudXRpbHMnO1xuaW1wb3J0IE1vZGVsc1NlcmllcyBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLnNlcmllcyc7XG5pbXBvcnQgTW9kZWxzU3RhY2sgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5zdGFjayc7XG5pbXBvcnQgTW9kZWxzRnJhbWUgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5mcmFtZSc7XG5pbXBvcnQgUGFyc2Vyc0RpY29tIGZyb20gJy4uL3BhcnNlcnMvcGFyc2Vycy5kaWNvbSc7XG5pbXBvcnQgUGFyc2Vyc01oZCBmcm9tICcuLi9wYXJzZXJzL3BhcnNlcnMubWhkJztcbmltcG9ydCBQYXJzZXJzTmlmdGkgZnJvbSAnLi4vcGFyc2Vycy9wYXJzZXJzLm5pZnRpJztcbmltcG9ydCBQYXJzZXJzTnJyZCBmcm9tICcuLi9wYXJzZXJzL3BhcnNlcnMubnJyZCc7XG5cbi8qKlxuICpcbiAqIEl0IGlzIHR5cGljYWxseSB1c2VkIHRvIGxvYWQgYSBESUNPTSBpbWFnZS4gVXNlIGxvYWRpbmcgbWFuYWdlciBmb3JcbiAqIGFkdmFuY2VkIHVzYWdlLCBzdWNoIGFzIG11bHRpcGxlIGZpbGVzIGhhbmRsaW5nLlxuICpcbiAqIERlbW86IHtAbGluayBodHRwczovL2ZubmRzYy5naXRodWIuaW8vdmpzI2xvYWRlcl9kaWNvbX1cbiAqXG4gKiBAbW9kdWxlIGxvYWRlcnMvdm9sdW1lc1xuICogQGV4dGVuZHMgTG9hZGVyc0Jhc2VcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmlsZXMgPSBbJy9kYXRhL2RjbS9mcnVpdCddO1xuICpcbiAqIC8vIEluc3RhbnRpYXRlIGEgZGljb20gbG9hZGVyXG4gKiB2YXIgbERpY29tb2FkZXIgPSBuZXcgZGljb20oKTtcbiAqXG4gKiAvLyBsb2FkIGEgcmVzb3VyY2VcbiAqIGxvYWRlci5sb2FkKFxuICogICAvLyByZXNvdXJjZSBVUkxcbiAqICAgZmlsZXNbMF0sXG4gKiAgIC8vIEZ1bmN0aW9uIHdoZW4gcmVzb3VyY2UgaXMgbG9hZGVkXG4gKiAgIGZ1bmN0aW9uKG9iamVjdCkge1xuICogICAgIC8vc2NlbmUuYWRkKCBvYmplY3QgKTtcbiAqICAgICB3aW5kb3cuY29uc29sZS5sb2cob2JqZWN0KTtcbiAqICAgfVxuICogKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGVyc1ZvbHVtZXMgZXh0ZW5kcyBMb2FkZXJzQmFzZSB7XG5cbiAgLyoqXG4gICAqIFBhcnNlIHJlc3BvbnNlLlxuICAgKiByZXNwb25zZSBpcyBmb3JtYXRlZCBhczpcbiAgICogICAge1xuICAgKiAgICAgIHVybDogJ3Jlc291cmNlIHVybCcsXG4gICAqICAgICAgYnVmZmVyOiB4bWxyZXNwb25zZSxcbiAgICogICAgfVxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgLSByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlXG4gICAqL1xuICBwYXJzZShyZXNwb25zZSkge1xuICAgIC8vIGVtaXQgJ3BhcnNlLXN0YXJ0JyBldmVudFxuICAgIHRoaXMuZW1pdCgncGFyc2Utc3RhcnQnLCB7XG4gICAgICBmaWxlOiByZXNwb25zZS51cmwsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgIH0pO1xuICAgIC8vIGdpdmUgYSBjaGFuY2UgdG8gdGhlIFVJIHRvIHVwZGF0ZSBiZWNhdXNlXG4gICAgLy8gYWZ0ZXIgdGhlIHJlbmRlcmluZyB3aWxsIGJlIGJsb2NrZWQgd2l0aCBpbnRlbnNpdmUgSlNcbiAgICAvLyB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgZXZlbnRlciBzZXQgdXBcbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NCYXIpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyLnVwZGF0ZSgwLCAxMDAsICdwYXJzZScpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGxldCBkYXRhID0gcmVzcG9uc2U7XG5cbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXByb2Nlc3MoZGF0YXNldCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHJhdy9taGQgcGFpclxuICAgICAgICAgICAgICAgIGxldCBtaGRGaWxlID1cbiAgICAgICAgICAgICAgICAgIGRhdGEuZmlsdGVyKHRoaXMuX2ZpbHRlckJ5RXh0ZW5zaW9uLmJpbmQobnVsbCwgJ01IRCcpKTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3RmlsZSA9XG4gICAgICAgICAgICAgICAgICBkYXRhLmZpbHRlcih0aGlzLl9maWx0ZXJCeUV4dGVuc2lvbi5iaW5kKG51bGwsICdSQVcnKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIG1oZEZpbGUubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHJhd0ZpbGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnVybCA9IG1oZEZpbGVbMF0udXJsO1xuICAgICAgICAgICAgICAgICAgZGF0YS5leHRlbnNpb24gPSBtaGRGaWxlWzBdLmV4dGVuc2lvbjtcbiAgICAgICAgICAgICAgICAgIGRhdGEubWhkQnVmZmVyID0gbWhkRmlsZVswXS5idWZmZXI7XG4gICAgICAgICAgICAgICAgICBkYXRhLnJhd0J1ZmZlciA9IHJhd0ZpbGVbMF0uYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBQYXJzZXIgPSB0aGlzLl9wYXJzZXIoZGF0YS5leHRlbnNpb24pO1xuICAgICAgICAgICAgICBpZiAoIVBhcnNlcikge1xuICAgICAgICAgICAgICAgIC8vIGVtaXQgJ3BhcnNlLWVycm9yJyBldmVudFxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGFyc2UtZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICBmaWxlOiByZXNwb25zZS51cmwsXG4gICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGRhdGEuZmlsZW5hbWUgKyAnY2FuIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWplY3QoZGF0YS5maWxlbmFtZSArICcgY2FuIG5vdCBiZSBwYXJzZWQuJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBjaGVjayBleHRlbnNpb25cbiAgICAgICAgICAgICAgbGV0IHZvbHVtZVBhcnNlciA9IG51bGw7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdm9sdW1lUGFyc2VyID0gbmV3IFBhcnNlcihkYXRhLCAwKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICAvLyBlbWl0ICdwYXJzZS1lcnJvcicgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BhcnNlLWVycm9yJywge1xuICAgICAgICAgICAgICAgICAgZmlsZTogcmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHNlcmllc1xuICAgICAgICAgICAgICBsZXQgc2VyaWVzID0gbmV3IE1vZGVsc1NlcmllcygpO1xuICAgICAgICAgICAgICAvLyBnbG9iYWwgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luc3RhbmNlVUlEID0gdm9sdW1lUGFyc2VyLnNlcmllc0luc3RhbmNlVUlEKCk7XG4gICAgICAgICAgICAgIHNlcmllcy50cmFuc2ZlclN5bnRheFVJRCA9IHZvbHVtZVBhcnNlci50cmFuc2ZlclN5bnRheFVJRCgpO1xuICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzRGVzY3JpcHRpb24gPSB2b2x1bWVQYXJzZXIuc2VyaWVzRGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgc2VyaWVzLnN0dWR5RGVzY3JpcHRpb24gPSB2b2x1bWVQYXJzZXIuc3R1ZHlEZXNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICBzZXJpZXMubnVtYmVyT2ZGcmFtZXMgPSB2b2x1bWVQYXJzZXIubnVtYmVyT2ZGcmFtZXMoKTtcbiAgICAgICAgICAgICAgaWYgKCFzZXJpZXMubnVtYmVyT2ZGcmFtZXMpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMubnVtYmVyT2ZGcmFtZXMgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlcmllcy5udW1iZXJPZkNoYW5uZWxzID0gdm9sdW1lUGFyc2VyLm51bWJlck9mQ2hhbm5lbHMoKTtcbiAgICAgICAgICAgICAgc2VyaWVzLm1vZGFsaXR5ID0gdm9sdW1lUGFyc2VyLm1vZGFsaXR5KCk7XG4gICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgc2VnbWVudGF0aW9uLCBhdHRhY2ggZXh0cmEgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgaWYgKHNlcmllcy5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xvcnNcbiAgICAgICAgICAgICAgICAvLyBsYWJlbHNcbiAgICAgICAgICAgICAgICAvLyBldGMuXG4gICAgICAgICAgICAgICAgc2VyaWVzLnNlZ21lbnRhdGlvblR5cGUgPSB2b2x1bWVQYXJzZXIuc2VnbWVudGF0aW9uVHlwZSgpO1xuICAgICAgICAgICAgICAgIHNlcmllcy5zZWdtZW50YXRpb25TZWdtZW50cyA9XG4gICAgICAgICAgICAgICAgICB2b2x1bWVQYXJzZXIuc2VnbWVudGF0aW9uU2VnbWVudHMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBwYXRpZW50IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50SUQgPSB2b2x1bWVQYXJzZXIucGF0aWVudElEKCk7XG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50TmFtZSA9IHZvbHVtZVBhcnNlci5wYXRpZW50TmFtZSgpO1xuICAgICAgICAgICAgICBzZXJpZXMucGF0aWVudEFnZSA9IHZvbHVtZVBhcnNlci5wYXRpZW50QWdlKCk7XG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50QmlydGhkYXRlID0gdm9sdW1lUGFyc2VyLnBhdGllbnRCaXJ0aGRhdGUoKTtcbiAgICAgICAgICAgICAgc2VyaWVzLnBhdGllbnRTZXggPSB2b2x1bWVQYXJzZXIucGF0aWVudFNleCgpO1xuXG4gICAgICAgICAgICAgIC8vIGp1c3QgY3JlYXRlIDEgZHVtbXkgc3RhY2sgZm9yIG5vd1xuICAgICAgICAgICAgICBsZXQgc3RhY2sgPSBuZXcgTW9kZWxzU3RhY2soKTtcbiAgICAgICAgICAgICAgc3RhY2subnVtYmVyT2ZDaGFubmVscyA9IHZvbHVtZVBhcnNlci5udW1iZXJPZkNoYW5uZWxzKCk7XG4gICAgICAgICAgICAgIHN0YWNrLnBpeGVsUmVwcmVzZW50YXRpb24gPVxuICAgICAgICAgICAgICAgIHZvbHVtZVBhcnNlci5waXhlbFJlcHJlc2VudGF0aW9uKCk7XG4gICAgICAgICAgICAgIHN0YWNrLnBpeGVsVHlwZSA9IHZvbHVtZVBhcnNlci5waXhlbFR5cGUoKTtcbiAgICAgICAgICAgICAgc3RhY2suaW52ZXJ0ID0gdm9sdW1lUGFyc2VyLmludmVydCgpO1xuICAgICAgICAgICAgICBzdGFjay5zcGFjaW5nQmV0d2VlblNsaWNlcyA9XG4gICAgICAgICAgICAgICAgdm9sdW1lUGFyc2VyLnNwYWNpbmdCZXR3ZWVuU2xpY2VzKCk7XG4gICAgICAgICAgICAgIHN0YWNrLm1vZGFsaXR5ID0gc2VyaWVzLm1vZGFsaXR5O1xuICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIHNlZ21lbnRhdGlvbiwgYXR0YWNoIGV4dHJhIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgIGlmIChzdGFjay5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xvcnNcbiAgICAgICAgICAgICAgICAvLyBsYWJlbHNcbiAgICAgICAgICAgICAgICAvLyBldGMuXG4gICAgICAgICAgICAgICAgc3RhY2suc2VnbWVudGF0aW9uVHlwZSA9IHNlcmllcy5zZWdtZW50YXRpb25UeXBlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnNlZ21lbnRhdGlvblNlZ21lbnRzID0gc2VyaWVzLnNlZ21lbnRhdGlvblNlZ21lbnRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlcmllcy5zdGFjay5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlIGNhbGwgZm9yIGVhY2ggZnJhbWVcbiAgICAgICAgICAgICAgLy8gYmV0dGVyIHRoYW4gZm9yIGxvb3AgdG8gYmUgYWJsZVxuICAgICAgICAgICAgICAvLyB0byB1cGRhdGUgZG9tIHdpdGggXCJwcm9ncmVzc1wiIGNhbGxiYWNrXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUZyYW1lKFxuICAgICAgICAgICAgICAgICAgc2VyaWVzLCBzdGFjaywgcmVzcG9uc2UudXJsLCAwLFxuICAgICAgICAgICAgICAgICAgdm9sdW1lUGFyc2VyLCByZXNvbHZlLCByZWplY3QpLCAwKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWN1cnNpdmUgcGFyc2UgZnJhbWVcbiAgICogQHBhcmFtIHtNb2RlbHNTZXJpZXN9IHNlcmllcyAtIGRhdGEgc2VyaWVzXG4gICAqIEBwYXJhbSB7TW9kZWxzU3RhY2t9IHN0YWNrIC0gZGF0YSBzdGFja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gcmVzb3VyY2UgdXJsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIC0gZnJhbWUgaW5kZXhcbiAgICogQHBhcmFtIHtwYXJzZXJ9IGRhdGFQYXJzZXIgLSBzZWxlY3RlZCBwYXJzZXJcbiAgICogQHBhcmFtIHtwcm9taXNlLnJlc29sdmV9IHJlc29sdmUgLSBwcm9taXNlIHJlc29sdmUgYXJnc1xuICAgKiBAcGFyYW0ge3Byb21pc2UucmVqZWN0fSByZWplY3QgLSBwcm9taXNlIHJlamVjdCBhcmdzXG4gICAqL1xuICBwYXJzZUZyYW1lKHNlcmllcywgc3RhY2ssIHVybCwgaSwgZGF0YVBhcnNlciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGV0IGZyYW1lID0gbmV3IE1vZGVsc0ZyYW1lKCk7XG4gICAgZnJhbWUuc29wSW5zdGFuY2VVSUQgPSBkYXRhUGFyc2VyLnNvcEluc3RhbmNlVUlEKGkpO1xuICAgIGZyYW1lLnVybCA9IHVybDtcbiAgICBmcmFtZS5pbmRleCA9IGk7XG4gICAgZnJhbWUucm93cyA9IGRhdGFQYXJzZXIucm93cyhpKTtcbiAgICBmcmFtZS5jb2x1bW5zID0gZGF0YVBhcnNlci5jb2x1bW5zKGkpO1xuICAgIGZyYW1lLm51bWJlck9mQ2hhbm5lbHMgPSBzdGFjay5udW1iZXJPZkNoYW5uZWxzO1xuICAgIGZyYW1lLnBpeGVsUmVwcmVzZW50YXRpb24gPSBzdGFjay5waXhlbFJlcHJlc2VudGF0aW9uO1xuICAgIGZyYW1lLnBpeGVsVHlwZSA9IHN0YWNrLnBpeGVsVHlwZTtcbiAgICBmcmFtZS5waXhlbERhdGEgPSBkYXRhUGFyc2VyLmV4dHJhY3RQaXhlbERhdGEoaSk7XG4gICAgZnJhbWUucGl4ZWxTcGFjaW5nID0gZGF0YVBhcnNlci5waXhlbFNwYWNpbmcoaSk7XG4gICAgZnJhbWUuc3BhY2luZ0JldHdlZW5TbGljZXMgPSBkYXRhUGFyc2VyLnNwYWNpbmdCZXR3ZWVuU2xpY2VzKGkpO1xuICAgIGZyYW1lLnNsaWNlVGhpY2tuZXNzID0gZGF0YVBhcnNlci5zbGljZVRoaWNrbmVzcyhpKTtcbiAgICBmcmFtZS5pbWFnZU9yaWVudGF0aW9uID0gZGF0YVBhcnNlci5pbWFnZU9yaWVudGF0aW9uKGkpO1xuICAgIGZyYW1lLnJpZ2h0SGFuZGVkID0gZGF0YVBhcnNlci5yaWdodEhhbmRlZCgpO1xuICAgIHN0YWNrLnJpZ2h0SGFuZGVkID0gZnJhbWUucmlnaHRIYW5kZWQ7XG4gICAgaWYgKGZyYW1lLmltYWdlT3JpZW50YXRpb24gPT09IG51bGwpIHtcbiAgICAgIGZyYW1lLmltYWdlT3JpZW50YXRpb24gPSBbMSwgMCwgMCwgMCwgMSwgMF07XG4gICAgfVxuICAgIGZyYW1lLmltYWdlUG9zaXRpb24gPSBkYXRhUGFyc2VyLmltYWdlUG9zaXRpb24oaSk7XG4gICAgaWYgKGZyYW1lLmltYWdlUG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIGZyYW1lLmltYWdlUG9zaXRpb24gPSBbMCwgMCwgaV07XG4gICAgfVxuICAgIGZyYW1lLmRpbWVuc2lvbkluZGV4VmFsdWVzID0gZGF0YVBhcnNlci5kaW1lbnNpb25JbmRleFZhbHVlcyhpKTtcbiAgICBmcmFtZS5iaXRzQWxsb2NhdGVkID0gZGF0YVBhcnNlci5iaXRzQWxsb2NhdGVkKGkpO1xuICAgIGZyYW1lLmluc3RhbmNlTnVtYmVyID0gZGF0YVBhcnNlci5pbnN0YW5jZU51bWJlcihpKTtcbiAgICBmcmFtZS53aW5kb3dDZW50ZXIgPSBkYXRhUGFyc2VyLndpbmRvd0NlbnRlcihpKTtcbiAgICBmcmFtZS53aW5kb3dXaWR0aCA9IGRhdGFQYXJzZXIud2luZG93V2lkdGgoaSk7XG4gICAgZnJhbWUucmVzY2FsZVNsb3BlID0gZGF0YVBhcnNlci5yZXNjYWxlU2xvcGUoaSk7XG4gICAgZnJhbWUucmVzY2FsZUludGVyY2VwdCA9IGRhdGFQYXJzZXIucmVzY2FsZUludGVyY2VwdChpKTtcbiAgICAvLyBzaG91bGQgcGFzcyBmcmFtZSBpbmRleCBmb3IgY29uc2lzdGVuY3kuLi5cbiAgICBmcmFtZS5taW5NYXggPSBkYXRhUGFyc2VyLm1pbk1heFBpeGVsRGF0YShmcmFtZS5waXhlbERhdGEpO1xuXG4gICAgLy8gaWYgc2VyaWVzLm1vXG4gICAgaWYgKHNlcmllcy5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcbiAgICAgIGZyYW1lLnJlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gZGF0YVBhcnNlci5yZWZlcmVuY2VkU2VnbWVudE51bWJlcihpKTtcbiAgICB9XG5cbiAgICBzdGFjay5mcmFtZS5wdXNoKGZyYW1lKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0dXNcbiAgICB0aGlzLl9wYXJzZWQgPSBpICsgMTtcbiAgICB0aGlzLl90b3RhbFBhcnNlZCA9IHNlcmllcy5udW1iZXJPZkZyYW1lcztcblxuICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBldmVudGVyIHNldCB1cFxuICAgIGlmICh0aGlzLl9wcm9ncmVzc0Jhcikge1xuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIudXBkYXRlKHRoaXMuX3BhcnNlZCwgdGhpcy5fdG90YWxQYXJzZWQsICdwYXJzZScpO1xuICAgIH1cblxuICAgIC8vIGVtaXQgJ3BhcnNpbmcnIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdwYXJzaW5nJywge1xuICAgICAgZmlsZTogdXJsLFxuICAgICAgdG90YWw6IHRoaXMuX3RvdGFsUGFyc2VkLFxuICAgICAgcGFyc2VkOiB0aGlzLl9wYXJzZWQsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNlZCA9PT0gdGhpcy5fdG90YWxQYXJzZWQpIHtcbiAgICAgIC8vIGVtaXQgJ3BhcnNlLXN1Y2Nlc3MnIGV2ZW50XG4gICAgICB0aGlzLmVtaXQoJ3BhcnNlLXN1Y2Nlc3MnLCB7XG4gICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgdG90YWw6IHRoaXMuX3RvdGFsUGFyc2VkLFxuICAgICAgICBwYXJzZWQ6IHRoaXMuX3BhcnNlZCxcbiAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgIH0pO1xuXG4gICAgICByZXNvbHZlKHNlcmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgIHRoaXMucGFyc2VGcmFtZShcbiAgICAgICAgICBzZXJpZXMsIHN0YWNrLCB1cmwsIHRoaXMuX3BhcnNlZCwgZGF0YVBhcnNlciwgcmVzb2x2ZSwgcmVqZWN0KSwgMFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHBhcnNlciBnaXZlbiBhbiBleHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvbiAtIGV4dGVuc2lvblxuICAgKiBAcmV0dXJuIHtwYXJzZXJ9IHNlbGVjdGVkIHBhcnNlclxuICAgKi9cbiAgX3BhcnNlcihleHRlbnNpb24pIHtcbiAgICBsZXQgUGFyc2VyID0gbnVsbDtcblxuICAgIHN3aXRjaCAoZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ05JSSc6XG4gICAgICBjYXNlICdOSUlfJzpcbiAgICAgICAgUGFyc2VyID0gUGFyc2Vyc05pZnRpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0RDTSc6XG4gICAgICBjYXNlICdESUNPTSc6XG4gICAgICBjYXNlICdJTUEnOlxuICAgICAgY2FzZSAnJzpcbiAgICAgICAgUGFyc2VyID0gUGFyc2Vyc0RpY29tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ01IRCc6XG4gICAgICAgIFBhcnNlciA9IFBhcnNlcnNNaGQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTlJSRCc6XG4gICAgICAgIFBhcnNlciA9IFBhcnNlcnNOcnJkO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygndW5zdXBwb3J0ZWQgZXh0ZW5zaW9uOiAnICsgZXh0ZW5zaW9uKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VyO1xuICB9XG5cblxuICAvKipcbiAgICogUHJlLXByb2Nlc3MgZGF0YSB0byBiZSBwYXJzZWQgKGZpbmQgZGF0YSB0eXBlIGFuZCBkZS1jb21wcmVzcylcbiAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAqL1xuICBfcHJlcHJvY2VzcyhkYXRhKSB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gQ29yZVV0aWxzLnBhcnNlVXJsKGRhdGEudXJsKTtcbiAgICAvLyB1cGRhdGUgZGF0YVxuICAgIGRhdGEuZmlsZW5hbWUgPSBwYXJzZWRVcmwuZmlsZW5hbWU7XG4gICAgZGF0YS5leHRlbnNpb24gPSBwYXJzZWRVcmwuZXh0ZW5zaW9uO1xuICAgIGRhdGEucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gICAgZGF0YS5xdWVyeSA9IHBhcnNlZFVybC5xdWVyeTtcblxuICAgIC8vIHVuemlwIGlmIGV4dGVuc2lvbiBpcyAnLmd6J1xuICAgIGlmIChkYXRhLmV4dGVuc2lvbiA9PT0gJ2d6Jykge1xuICAgICAgZGF0YS5nemNvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgZGF0YS5leHRlbnNpb24gPVxuICAgICAgICBkYXRhLmZpbGVuYW1lLnNwbGl0KCcuZ3onKS5zaGlmdCgpLnNwbGl0KCcuJykucG9wKCk7XG4gICAgICBsZXQgZGVjb21wcmVzc2VkRGF0YSA9IFBBS08uaW5mbGF0ZShkYXRhLmJ1ZmZlcik7XG4gICAgICBkYXRhLmJ1ZmZlciA9IGRlY29tcHJlc3NlZERhdGEuYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLmd6Y29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaWx0ZXIgZGF0YSBieSBleHRlbnNpb25cbiAgICogQHBhcmFtIHsqfSBleHRlbnNpb25cbiAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICovXG4gIF9maWx0ZXJCeUV4dGVuc2lvbihleHRlbnNpb24sIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5leHRlbnNpb24udG9VcHBlckNhc2UoKSA9PT0gZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQmFzZSBvYmplY3QuXG4gKlxuICogQG1vZHVsZSBtb2RlbHMvYmFzZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc0Jhc2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pZCA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZSAyIGFycmF5cyBvZiBtb2RlbHMuXG4gICAqIE1lcmdlIHRoZSB0YXJnZXQgYXJyYXkgaW50byB0aGUgcmVmZXJlbmNlIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxNb2RlbHM+fSByZWZlcmVuY2VBcnJheSAtIEFycmF5IHRvIGJlIG1lcmdlIGFnYWluc3RcbiAgICogQHBhcmFtIHtBcnJheS48TW9kZWxzPn0gdGFyZ2V0QXJyYXkgLSBBcnJheSB0byBiZSBtZXJnZWQgYWdhaW5zdCByZWZlcmVuY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWVyZ2Ugd2FzIHN1Y2Vzc2Z1bC4gRmFsc2UgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAqL1xuICBtZXJnZU1vZGVscyhyZWZlcmVuY2VBcnJheSwgdGFyZ2V0QXJyYXkpIHtcbiAgICBpZiAoISh0aGlzLl92YWxpZGF0ZU1vZGVsQXJyYXkocmVmZXJlbmNlQXJyYXkpICYmXG4gICAgICB0aGlzLl92YWxpZGF0ZU1vZGVsQXJyYXkodGFyZ2V0QXJyYXkpKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdpbnZhbGlkIGlucHV0cyBwcm92aWRlZC4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyB0ZXN0IHRhcmdldEFycmF5IGFnYWluc3QgZXhpc3RpbmcgdGFyZ2V0QXJyYXlcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVmZXJlbmNlQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZUFycmF5W2pdLm1lcmdlKHRhcmdldEFycmF5W2ldKSkge1xuICAgICAgICAgIC8vIG1lcmdlZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChqID09PSByZWZlcmVuY2VBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gbGFzdCBtZXJnZSB3YXMgbm90IHN1Y2Nlc3NmdWxcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IHRhcmdldEFycmF5XG4gICAgICAgICAgcmVmZXJlbmNlQXJyYXkucHVzaCh0YXJnZXRBcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBtb2RlbCBhZ2FpbnN0IGN1cnJlbnQgbW9kZWwuXG4gICAqL1xuICBtZXJnZShtb2RlbCkge1xuICAgIC8vIG1ha2Ugc3VyZSBtb2RlbCBpcyB2YWxpZFxuICAgIGlmKCEodGhpcy52YWxpZGF0ZShtb2RlbCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gdGhleSBjYW4gYmUgbWVyZ2VkIGlmIHRoZXkgbWF0Y2hcbiAgICBpZih0aGlzLl9pZCA9PT0gbW9kZWwuX2lkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgbW9kZWwuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW9kZWwgaXMgdmFsaWQuIEZhbHNlIGlmIG5vdC5cbiAgICovXG4gIHZhbGlkYXRlKG1vZGVsKSB7XG4gICAgaWYgKCEobW9kZWwgJiZcbiAgICAgIG1vZGVsICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgbW9kZWwubWVyZ2UgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYXJyYXkgb2YgbW9kZWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxNb2RlbHM+fSBtb2RlbEFycmF5IC0gQXJyYXkgY29udGFpbmluZyBtb2RlbHMuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYXJyYXkgaXMgdmFsaWQuIEZhbHNlIGlmIG5vdC5cbiAgICovXG4gIF92YWxpZGF0ZU1vZGVsQXJyYXkobW9kZWxBcnJheSkge1xuICAgIGlmICghKG1vZGVsQXJyYXkgIT09IG51bGwgJiYgQXJyYXkgPT09IG1vZGVsQXJyYXkuY29uc3RydWN0b3IpKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2ludmFsaWQgbW9kZWwgYXJyYXkgcHJvdmlkZWQuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIShtb2RlbEFycmF5W2ldICYmXG4gICAgICAgIG1vZGVsQXJyYXlbaV0gIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIG1vZGVsQXJyYXlbaV0udmFsaWRhdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgbW9kZWxBcnJheVtpXS52YWxpZGF0ZShtb2RlbEFycmF5W2ldKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKiogKiBJbXBvcnRzICoqKi9cbmltcG9ydCBNb2RlbHNCYXNlIGZyb20gJy4uL21vZGVscy9tb2RlbHMuYmFzZSc7XG5cbi8qKlxuICogRnJhbWUgb2JqZWN0LlxuICpcbiAqIEBtb2R1bGUgbW9kZWxzL2ZyYW1lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc0ZyYW1lIGV4dGVuZHMgTW9kZWxzQmFzZSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fc29wSW5zdGFuY2VVSUQgPSBudWxsO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fc3RhY2tJRCA9IC0xO1xuICAgIHRoaXMuX3Jvd3MgPSAwO1xuICAgIHRoaXMuX2NvbHVtbnMgPSAwO1xuICAgIHRoaXMuX2RpbWVuc2lvbkluZGV4VmFsdWVzID0gW107XG4gICAgdGhpcy5faW1hZ2VQb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NsaWNlVGhpY2tuZXNzID0gMTtcbiAgICB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcyA9IG51bGw7XG4gICAgdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbiA9IDA7XG4gICAgdGhpcy5fcGl4ZWxUeXBlID0gMDtcbiAgICB0aGlzLl9waXhlbFNwYWNpbmcgPSBudWxsO1xuICAgIHRoaXMuX3BpeGVsQXNwZWN0UmF0aW8gPSBudWxsO1xuICAgIHRoaXMuX3BpeGVsRGF0YSA9IG51bGw7XG5cbiAgICB0aGlzLl9pbnN0YW5jZU51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gbnVsbDtcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gbnVsbDtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gbnVsbDtcblxuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSA4O1xuXG4gICAgdGhpcy5fbWluTWF4ID0gbnVsbDtcbiAgICB0aGlzLl9kaXN0ID0gbnVsbDtcblxuICAgIHRoaXMuX2luZGV4ID0gLTE7XG5cbiAgICB0aGlzLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlciA9IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBtb2RlbFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdmFsaWRhdGUobW9kZWwpIHtcbiAgICBpZiAoIShzdXBlci52YWxpZGF0ZShtb2RlbCkgJiZcbiAgICAgIHR5cGVvZiBtb2RlbC5jb3NpbmVzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgbW9kZWwuc3BhY2luZ1hZID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX3NvcEluc3RhbmNlVUlEJykgJiZcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfZGltZW5zaW9uSW5kZXhWYWx1ZXMnKSAmJlxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19pbWFnZU9yaWVudGF0aW9uJykgJiZcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfaW1hZ2VQb3NpdGlvbicpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGN1cnJlbnQgZnJhbWUgd2l0aCBwcm92aWRlZCBmcmFtZS5cbiAgICpcbiAgICogRnJhbWVzIGNhbiBiZSBtZXJnZWQgKGkuZS4gYXJlIGlkZW50aWNhbCkgaWYgZm9sbG93aW5nIGFyZSBlcXVhbHM6XG4gICAqICAtIGRpbWVuc2lvbkluZGV4VmFsdWVzXG4gICAqICAtIGltYWdlT3JpZW50YXRpb25cbiAgICogIC0gaW1hZ2VQb3NpdGlvblxuICAgKiAgLSBpbnN0YW5jZU51bWJlclxuICAgKiAgLSBzb3BJbnN0YW5jZVVJRFxuICAgKlxuICAgKiBAcGFyYW0geyp9IGZyYW1lXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZnJhbWVzIGNvdWxkIGJlIG1lcmdlLiBGYWxzZSBpZiBub3QuXG4gICAqL1xuICBtZXJnZShmcmFtZSkge1xuICAgIGlmICghdGhpcy52YWxpZGF0ZShmcmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29tcGFyZUFycmF5cyhcbiAgICAgICAgICB0aGlzLl9kaW1lbnNpb25JbmRleFZhbHVlcywgZnJhbWUuZGltZW5zaW9uSW5kZXhWYWx1ZXMpICYmXG4gICAgICAgIHRoaXMuX2NvbXBhcmVBcnJheXMoXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbiwgZnJhbWUuaW1hZ2VPcmllbnRhdGlvbikgJiZcbiAgICAgICAgdGhpcy5fY29tcGFyZUFycmF5cyhcbiAgICAgICAgICB0aGlzLl9pbWFnZVBvc2l0aW9uLCBmcmFtZS5pbWFnZVBvc2l0aW9uKSAmJlxuICAgICAgICB0aGlzLl9pbnN0YW5jZU51bWJlciA9PT0gZnJhbWUuaW5zdGFuY2VOdW1iZXIgJiZcbiAgICAgICAgdGhpcy5fc29wSW5zdGFuY2VVSUQgPT09IGZyYW1lLnNvcEluc3RhbmNlVUlEKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBYLCB5IGFuZCBaIGNvc2luZXMgZnJvbSBpbWFnZSBvcmllbnRhdGlvblxuICAgKiBSZXR1cm5zIGRlZmF1bHQgb3JpZW50YXRpb24gaWYgX2ltYWdlT3JpZW50YXRpb24gd2FzIGludmFsaWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHthcnJheX0gQXJyYXlbM10gY29udGFpbmluZyBjb3NpbmVzWCwgWSBhbmQgWi5cbiAgICovXG4gIGNvc2luZXMoKSB7XG4gICAgbGV0IGNvc2luZXMgPSBbbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpXTtcblxuICAgICBpZiAodGhpcy5faW1hZ2VPcmllbnRhdGlvbiAmJlxuICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbi5sZW5ndGggPT09IDYpIHtcbiAgICAgIGxldCB4Q29zID1cbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvblswXSxcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uWzFdLFxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb25bMl0pO1xuICAgICAgbGV0IHlDb3MgPVxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uWzNdLFxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb25bNF0sXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbls1XSk7XG5cbiAgICAgIGlmICh4Q29zLmxlbmd0aCgpID4gMCAmJiB5Q29zLmxlbmd0aCgpID4gMCkge1xuICAgICAgICBjb3NpbmVzWzBdID0geENvcztcbiAgICAgICAgY29zaW5lc1sxXSA9IHlDb3M7XG4gICAgICAgIGNvc2luZXNbMl0gPVxuICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLlxuICAgICAgICAgIGNyb3NzVmVjdG9ycyhjb3NpbmVzWzBdLCBjb3NpbmVzWzFdKS5cbiAgICAgICAgICBub3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdObyB2YWxpZCBpbWFnZSBvcmllbnRhdGlvbiBmb3IgZnJhbWUnKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnUmV0dXJuaW5nIGRlZmF1bHQgb3JpZW50YXRpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9yaWdodEhhbmRlZCkge1xuICAgICAgY29zaW5lc1syXS5uZWdhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29zaW5lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgeC95IHNwYWNpbmcgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHNwYWNpbmdYWSgpIHtcbiAgICBsZXQgc3BhY2luZ1hZID0gWzEuMCwgMS4wXTtcblxuICAgIGlmICh0aGlzLnBpeGVsU3BhY2luZykge1xuICAgICAgc3BhY2luZ1hZWzBdID0gdGhpcy5waXhlbFNwYWNpbmdbMF07XG5cbiAgICAgIHNwYWNpbmdYWVsxXSA9IHRoaXMucGl4ZWxTcGFjaW5nWzFdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5waXhlbEFzcGVjdFJhdGlvKSB7XG4gICAgICBzcGFjaW5nWFlbMF0gPSAxLjA7XG4gICAgICBzcGFjaW5nWFlbMV0gPSAxLjAgKiB0aGlzLnBpeGVsQXNwZWN0UmF0aW9bMV0gLyB0aGlzLnBpeGVsQXNwZWN0UmF0aW9bMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYWNpbmdYWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNvbHVtblxuICAgKiBAcGFyYW0geyp9IHJvd1xuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdmFsdWUoY29sdW1uLCByb3cpIHtcbiAgICByZXR1cm4gdGhpcy5waXhlbERhdGFbY29sdW1uICsgdGhpcy5fY29sdW1ucyAqIHJvd107XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZSAyIGFycmF5cy5cbiAgICpcbiAgICogMiBudWxsIGFycmF5cyByZXR1cm4gdHJ1ZS5cbiAgICogRG8gbm8gcGVyZm9ybSBzdHJpY3QgdHlwZSBjaGVja2luZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSByZWZlcmVuY2VcbiAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhcnJheXMgYXJlIGlkZW50aWNhbHMuIEZhbHNlIGlmIG5vdC5cbiAgICovXG4gIF9jb21wYXJlQXJyYXlzKHJlZmVyZW5jZSwgdGFyZ2V0KSB7XG4gICAgLy8gY291bGQgYm90aCBiZSBudWxsXG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBub3QgbnVsbC4uLi5cbiAgICBpZiAocmVmZXJlbmNlICYmXG4gICAgICAgIHRhcmdldCAmJlxuICAgICAgICByZWZlcmVuY2Uuam9pbigpID09PSB0YXJnZXQuam9pbigpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgcm93cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm93cztcbiAgfVxuXG4gIHNldCByb3dzKHJvd3MpIHtcbiAgICB0aGlzLl9yb3dzID0gcm93cztcbiAgfVxuXG4gIGdldCBjb2x1bW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xuICB9XG5cbiAgc2V0IGNvbHVtbnMoY29sdW1ucykge1xuICAgIHRoaXMuX2NvbHVtbnMgPSBjb2x1bW5zO1xuICB9XG5cbiAgZ2V0IHNwYWNpbmdCZXR3ZWVuU2xpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcztcbiAgfVxuXG4gIHNldCBzcGFjaW5nQmV0d2VlblNsaWNlcyhzcGFjaW5nQmV0d2VlblNsaWNlcykge1xuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gc3BhY2luZ0JldHdlZW5TbGljZXM7XG4gIH1cblxuICBnZXQgc2xpY2VUaGlja25lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlVGhpY2tuZXNzO1xuICB9XG5cbiAgc2V0IHNsaWNlVGhpY2tuZXNzKHNsaWNlVGhpY2tuZXNzKSB7XG4gICAgdGhpcy5fc2xpY2VUaGlja25lc3MgPSBzbGljZVRoaWNrbmVzcztcbiAgfVxuXG4gIGdldCBpbWFnZVBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbWFnZVBvc2l0aW9uO1xuICB9XG5cbiAgc2V0IGltYWdlUG9zaXRpb24oaW1hZ2VQb3NpdGlvbikge1xuICAgIHRoaXMuX2ltYWdlUG9zaXRpb24gPSBpbWFnZVBvc2l0aW9uO1xuICB9XG5cbiAgZ2V0IGltYWdlT3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlT3JpZW50YXRpb247XG4gIH1cblxuICBzZXQgaW1hZ2VPcmllbnRhdGlvbihpbWFnZU9yaWVudGF0aW9uKSB7XG4gICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbiA9IGltYWdlT3JpZW50YXRpb247XG4gIH1cblxuICBnZXQgd2luZG93V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd1dpZHRoO1xuICB9XG5cbiAgc2V0IHdpbmRvd1dpZHRoKHdpbmRvd1dpZHRoKSB7XG4gICAgdGhpcy5fd2luZG93V2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgfVxuXG4gIGdldCB3aW5kb3dDZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd0NlbnRlcjtcbiAgfVxuXG4gIHNldCB3aW5kb3dDZW50ZXIod2luZG93Q2VudGVyKSB7XG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gd2luZG93Q2VudGVyO1xuICB9XG5cbiAgZ2V0IHJlc2NhbGVTbG9wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZVNsb3BlO1xuICB9XG5cbiAgc2V0IHJlc2NhbGVTbG9wZShyZXNjYWxlU2xvcGUpIHtcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSByZXNjYWxlU2xvcGU7XG4gIH1cblxuICBnZXQgcmVzY2FsZUludGVyY2VwdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZUludGVyY2VwdDtcbiAgfVxuXG4gIHNldCByZXNjYWxlSW50ZXJjZXB0KHJlc2NhbGVJbnRlcmNlcHQpIHtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gcmVzY2FsZUludGVyY2VwdDtcbiAgfVxuXG4gIGdldCBiaXRzQWxsb2NhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRzQWxsb2NhdGVkO1xuICB9XG5cbiAgc2V0IGJpdHNBbGxvY2F0ZWQoYml0c0FsbG9jYXRlZCkge1xuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSBiaXRzQWxsb2NhdGVkO1xuICB9XG5cbiAgZ2V0IGRpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3Q7XG4gIH1cblxuICBzZXQgZGlzdChkaXN0KSB7XG4gICAgdGhpcy5fZGlzdCA9IGRpc3Q7XG4gIH1cblxuICBnZXQgcGl4ZWxTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9waXhlbFNwYWNpbmc7XG4gIH1cblxuICBzZXQgcGl4ZWxTcGFjaW5nKHBpeGVsU3BhY2luZykge1xuICAgIHRoaXMuX3BpeGVsU3BhY2luZyA9IHBpeGVsU3BhY2luZztcbiAgfVxuXG4gIGdldCBwaXhlbEFzcGVjdFJhdGlvKCkge1xuICAgIHJldHVybiB0aGlzLl9waXhlbEFzcGVjdFJhdGlvO1xuICB9XG5cbiAgc2V0IHBpeGVsQXNwZWN0UmF0aW8ocGl4ZWxBc3BlY3RSYXRpbykge1xuICAgIHRoaXMuX3BpeGVsQXNwZWN0UmF0aW8gPSBwaXhlbEFzcGVjdFJhdGlvO1xuICB9XG5cbiAgZ2V0IG1pbk1heCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluTWF4O1xuICB9XG5cbiAgc2V0IG1pbk1heChtaW5NYXgpIHtcbiAgICB0aGlzLl9taW5NYXggPSBtaW5NYXg7XG4gIH1cblxuICBnZXQgZGltZW5zaW9uSW5kZXhWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpbWVuc2lvbkluZGV4VmFsdWVzO1xuICB9XG5cbiAgc2V0IGRpbWVuc2lvbkluZGV4VmFsdWVzKGRpbWVuc2lvbkluZGV4VmFsdWVzKSB7XG4gICAgdGhpcy5fZGltZW5zaW9uSW5kZXhWYWx1ZXMgPSBkaW1lbnNpb25JbmRleFZhbHVlcztcbiAgfVxuXG4gIGdldCBpbnN0YW5jZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VOdW1iZXI7XG4gIH1cblxuICBzZXQgaW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VOdW1iZXIpIHtcbiAgICB0aGlzLl9pbnN0YW5jZU51bWJlciA9IGluc3RhbmNlTnVtYmVyO1xuICB9XG5cbiAgZ2V0IHBpeGVsRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxEYXRhO1xuICB9XG5cbiAgc2V0IHBpeGVsRGF0YShwaXhlbERhdGEpIHtcbiAgICB0aGlzLl9waXhlbERhdGEgPSBwaXhlbERhdGE7XG4gIH1cblxuICBzZXQgc29wSW5zdGFuY2VVSUQoc29wSW5zdGFuY2VVSUQpIHtcbiAgICB0aGlzLl9zb3BJbnN0YW5jZVVJRCA9IHNvcEluc3RhbmNlVUlEO1xuICB9XG5cbiAgZ2V0IHNvcEluc3RhbmNlVUlEKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3BJbnN0YW5jZVVJRDtcbiAgfVxuXG4gIGdldCBwaXhlbFJlcHJlc2VudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9waXhlbFJlcHJlc2VudGF0aW9uO1xuICB9XG5cbiAgc2V0IHBpeGVsUmVwcmVzZW50YXRpb24ocGl4ZWxSZXByZXNlbnRhdGlvbikge1xuICAgIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb24gPSBwaXhlbFJlcHJlc2VudGF0aW9uO1xuICB9XG5cbiAgZ2V0IHBpeGVsVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxUeXBlO1xuICB9XG5cbiAgc2V0IHBpeGVsVHlwZShwaXhlbFR5cGUpIHtcbiAgICB0aGlzLl9waXhlbFR5cGUgPSBwaXhlbFR5cGU7XG4gIH1cblxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICBzZXQgdXJsKHVybCkge1xuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgfVxuXG4gIGdldCByZWZlcmVuY2VkU2VnbWVudE51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlZFNlZ21lbnROdW1iZXI7XG4gIH1cblxuICBzZXQgcmVmZXJlbmNlZFNlZ21lbnROdW1iZXIocmVmZXJlbmNlZFNlZ21lbnROdW1iZXIpIHtcbiAgICB0aGlzLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlciA9IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xuICB9XG5cbiAgZ2V0IHJpZ2h0SGFuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9yaWdodEhhbmRlZDtcbiAgfVxuXG4gIHNldCByaWdodEhhbmRlZChyaWdodEhhbmRlZCkge1xuICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gcmlnaHRIYW5kZWQ7XG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG5cbiAgc2V0IGluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgfVxufVxuIiwiaW1wb3J0IEZyYW1lIGZyb20gJy4vbW9kZWxzLmZyYW1lJztcbmltcG9ydCBTdGFjayBmcm9tICcuL21vZGVscy5zdGFjayc7XG5pbXBvcnQgU2VyaWVzIGZyb20gJy4vbW9kZWxzLnNlcmllcyc7XG5pbXBvcnQgVm94ZWwgZnJvbSAnLi9tb2RlbHMudm94ZWwnO1xuXG4vKipcbiAqIEBtb2R1bGUgbW9kZWxzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBGcmFtZSxcbiAgU3RhY2ssXG4gIFNlcmllcyxcbiAgVm94ZWwsXG59O1xuIiwiLyoqICogSW1wb3J0cyAqKiovXG5pbXBvcnQgTW9kZWxzQmFzZSBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLmJhc2UnO1xuXG4vKipcbiAqIFNlcmllcyBvYmplY3QuXG4gKlxuICogQG1vZHVsZSBtb2RlbHMvc2VyaWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc1NlcmllcyBleHRlbmRzIE1vZGVsc0Jhc2Uge1xuICAvKipcbiAgICogTW9kZWxzIHNlcmllcyBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbmNhdGVuYXRpb25VSUQgPSAtMTtcbiAgICB0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRCA9IC0xO1xuICAgIHRoaXMuX3RyYW5zZmVyU3ludGF4VUlEID0gJyc7XG4gICAgdGhpcy5fc2VyaWVzTnVtYmVyID0gLTE7XG4gICAgdGhpcy5fc2VyaWVzRGVzY3JpcHRpb24gPSAnJztcbiAgICB0aGlzLl9zdHVkeURlc2NyaXB0aW9uID0gJyc7XG4gICAgdGhpcy5fbW9kYWxpdHkgPSAnTW9kYWxpdHkgbm90IHNldCc7XG4gICAgdGhpcy5fZGltZW5zaW9uSW5kZXhTZXF1ZW5jZSA9IFtdO1xuICAgIC8vIGl0IGlzIHVzZWQgaW4gdGhlIGxvYWRlciBpbiBjYXNlIGEgZGljb20vbmlmdGkgY29udGFpbnMgbXVsdGlwbGUgZnJhbWVzXG4gICAgLy8gc2hvdWxkIGJlIHVwZGF0ZWQgYWZ0ZXIgbWVyZ2Ugb3IgcmVuYW1lZFxuICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gMDtcbiAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID0gMTtcblxuICAgIC8vIHBhdGllbnQgaW5mb3JtYXRpb25cbiAgICB0aGlzLl9wYXRpZW50SUQgPSAnJztcbiAgICB0aGlzLl9wYXRpZW50TmFtZSA9ICcnO1xuICAgIHRoaXMuX3BhdGllbnRBZ2UgPSAnJztcbiAgICB0aGlzLl9wYXRpZW50QmlydGhkYXRlID0gJyc7XG4gICAgdGhpcy5fcGF0aWVudFNleCA9ICcnO1xuXG4gICAgLy8gU0VHTUVOVEFUSU9OIFNUVUZGXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IG51bGw7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMgPSBbXTtcblxuICAgIC8vIFNUQUNLXG4gICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHNlcmllcy5cbiAgICpcbiAgICogUmVxdWlyZW1lbnRzOlxuICAgKiAgIC0gbWVyZ2VTZXJpZXMgbWV0aG9kXG4gICAqICAgLSBfc2VyaWVzSW5zdGFuY2VVSURcbiAgICogICAtIF9udW1iZXJPZkZyYW1lc1xuICAgKiAgIC0gX251bWJlck9mQ2hhbm5lbHNcbiAgICogICBfIF9zdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsc1Nlcmllc30gbW9kZWwgLSBNb2RlbCB0byBiZSB2YWxpZGF0ZWQgYXMgc2VyaWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHNlcmllcyBpcyB2YWxpZC4gRmFsc2UgaWYgbm90LlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHZhbGlkYXRlKG1vZGVsKSB7XG4gICAgaWYgKCEoc3VwZXIudmFsaWRhdGUobW9kZWwpICYmXG4gICAgICB0eXBlb2YgbW9kZWwubWVyZ2VTZXJpZXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfc2VyaWVzSW5zdGFuY2VVSUQnKSAmJlxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19udW1iZXJPZkZyYW1lcycpICYmXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX251bWJlck9mQ2hhbm5lbHMnKSAmJlxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19zdGFjaycpICYmXG4gICAgICB0eXBlb2YgbW9kZWwuX3N0YWNrICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgQXJyYXkgPT09IG1vZGVsLl9zdGFjay5jb25zdHJ1Y3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBjdXJyZW50IHNlcmllcyB3aXRoIHByb3ZpZGVkIHNlcmllcy5cbiAgICogMiBzZXJpZXMgY2FuIE9OTFkgYmUgbWVyZ2UgaWYgdGhleSBoYXZlIHRoZSBzYW1lIFNlcmllc0luc3RhbmNlVUlELlxuICAgKlxuICAgKiBBbHNvIG1lcmdlcyB0aGUgc3RhY2tzIGluc2lkZSBhIHNlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbHNTZXJpZXN9IHNlcmllcyAtIFNlcmllcyB0byBiZSBtZXJnZWQgYWdhaW5zdCBjdXJyZW50IHNlcmllcy5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBzZXJpZXMgY291bGQgYmUgbWVyZ2UuIEZhbHNlIGlmIG5vdC5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBtZXJnZShzZXJpZXMpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGUoc2VyaWVzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRCA9PT0gc2VyaWVzLnNlcmllc0luc3RhbmNlVUlEKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXJnZU1vZGVscyh0aGlzLl9zdGFjaywgc2VyaWVzLnN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBjdXJyZW50IHNlcmllcyB3aXRoIHByb3ZpZGVkIGFycmF5IG9mIHNlcmllcy5cbiAgICogMiBzZXJpZXMgY2FuIE9OTFkgYmUgbWVyZ2UgaWYgdGhleSBoYXZlIHRoZSBzYW1lIFNlcmllc0luc3RhbmNlVUlELlxuICAgKlxuICAgKiBBbHNvIG1lcmdlcyB0aGUgc3RhY2tzIGluc2lkZSBhIHNlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48TW9kZWxzU2VyaWVzPn0gdGFyZ2V0IC0gU2VyaWVzIHRvIGJlIG1lcmdlZCBhZ2FpbnN0IGN1cnJlbnQgc2VyaWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheS48TW9kZWxzU2VyaWVzPn0gQXJyYXkgb2Ygc2VyaWVzIHByb3Blcmx5IG1lcmdlZC5cbiAgICovXG4gIG1lcmdlU2VyaWVzKHRhcmdldCkge1xuICAgIGxldCBzZXJpZXNDb250YWluZXIgPSBbdGhpc107XG4gICAgdGhpcy5tZXJnZU1vZGVscyhzZXJpZXNDb250YWluZXIsIHRhcmdldCk7XG4gICAgcmV0dXJuIHNlcmllc0NvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpZXMgaW5zdGFuY2UgVUlEIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHNlcmllc0luc3RhbmNlVUlEXG4gICAqL1xuICBzZXQgc2VyaWVzSW5zdGFuY2VVSUQoc2VyaWVzSW5zdGFuY2VVSUQpIHtcbiAgICB0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRCA9IHNlcmllc0luc3RhbmNlVUlEO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmllcyBpbnN0YWNlIFVJRCBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWVzSW5zdGFuY2VVSUQ7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgc3ludGF4IFVJRCBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHsqfSB0cmFuc2ZlclN5bnRheFVJRFxuICAgKi9cbiAgc2V0IHRyYW5zZmVyU3ludGF4VUlEKHRyYW5zZmVyU3ludGF4VUlEKSB7XG4gICAgdGhpcy5fdHJhbnNmZXJTeW50YXhVSUQgPSB0cmFuc2ZlclN5bnRheFVJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBzeW50YXggVUlEIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0IHRyYW5zZmVyU3ludGF4VUlEKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2ZlclN5bnRheFVJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBzeW50YXggVUlEIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0IHRyYW5zZmVyU3ludGF4VUlETGFiZWwoKSB7XG4gICAgc3dpdGNoICh0aGlzLl90cmFuc2ZlclN5bnRheFVJRCkge1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC45MCc6XG4gICAgICAgIHJldHVybiAnSlBFRyAyMDAwIExvc3NsZXNzJztcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjQuOTEnOlxuICAgICAgICByZXR1cm4gJ0pQRUcgMjAwMCBMb3NzeSc7XG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi40LjU3JzpcbiAgICAgICAgcmV0dXJuICdKUEVHIExvc3NsZXNzLCBOb25oaWVyYXJjaGljYWwgKFByb2Nlc3NlcyAxNCknO1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC43MCc6XG4gICAgICAgIHJldHVybiAnSlBFRyBMb3NzbGVzcywgTm9uaGllcmFyY2hpY2FsIChQcm9jZXNzZXMgMTQgW1NlbGVjdGlvbiAxXSknO1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41MCc6XG4gICAgICAgIHJldHVybiAnSlBFRyBCYXNlbGluZSBsb3NzeSBwcm9jZXNzIDEgKDggYml0KSc7XG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi40LjUxJzpcbiAgICAgICAgcmV0dXJuICdKUEVHIEJhc2VsaW5lIGxvc3N5IHByb2Nlc3MgMiAmIDQgKDEyIGJpdCknO1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjInOlxuICAgICAgICByZXR1cm4gJ0ltcGxpY2l0IFZSIExpdHRsZSBFbmRpYW4nO1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuMSc6XG4gICAgICAgIHJldHVybiAnRXhwbGljaXQgVlIgTGl0dGxlIEVuZGlhbic7XG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi4yJzpcbiAgICAgICAgcmV0dXJuICdFeHBsaWNpdCBWUiBCaWcgRW5kaWFuJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgVW5rbm93biB0cmFuc2ZlcnN5bnRheDogJHt0aGlzLl90cmFuc2ZlclN5bnRheFVJRH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHVkeSBkZXNjcmlwaXRpb24gc2V0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc3R1ZHlEZXNjcmlwdGlvblxuICAgKi9cbiAgc2V0IHN0dWR5RGVzY3JpcHRpb24oc3R1ZHlEZXNjcmlwdGlvbikge1xuICAgIHRoaXMuX3N0dWR5RGVzY3JpcHRpb24gPSBzdHVkeURlc2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0dWR5IGRlc2NyaXB0aW9uIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0IHN0dWR5RGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0dWR5RGVzY3JpcHRpb247XG4gIH1cblxuICAvKipcbiAgICogU2VyaWVzIGRlc2NyaXBpdGlvbiBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzZXJpZXNEZXNjcmlwdGlvblxuICAgKi9cbiAgc2V0IHNlcmllc0Rlc2NyaXB0aW9uKHNlcmllc0Rlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5fc2VyaWVzRGVzY3JpcHRpb24gPSBzZXJpZXNEZXNjcmlwdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpZXMgZGVzY3JpcHRpb24gZ2V0dGVyXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXQgc2VyaWVzRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlcmllc0Rlc2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgSUQgc2V0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gcGF0aWVudElEXG4gICAqL1xuICBzZXQgcGF0aWVudElEKHBhdGllbnRJRCkge1xuICAgIHRoaXMuX3BhdGllbnRJRCA9IHBhdGllbnRJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IElEIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0IHBhdGllbnRJRCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aWVudElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgbmFtZSBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHsqfSBwYXRpZW50TmFtZVxuICAgKi9cbiAgc2V0IHBhdGllbnROYW1lKHBhdGllbnROYW1lKSB7XG4gICAgdGhpcy5fcGF0aWVudE5hbWUgPSBwYXRpZW50TmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IG5hbWUgZ2V0dGVyXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXQgcGF0aWVudE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGllbnROYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgYWdlIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHBhdGllbnRBZ2VcbiAgICovXG4gIHNldCBwYXRpZW50QWdlKHBhdGllbnRBZ2UpIHtcbiAgICB0aGlzLl9wYXRpZW50QWdlID0gcGF0aWVudEFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IGFnZSBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBwYXRpZW50QWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRpZW50QWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgYmlydGhkYXRlIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHBhdGllbnRCaXJ0aGRhdGVcbiAgICovXG4gIHNldCBwYXRpZW50QmlydGhkYXRlKHBhdGllbnRCaXJ0aGRhdGUpIHtcbiAgICB0aGlzLl9wYXRpZW50QmlydGhkYXRlID0gcGF0aWVudEJpcnRoZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IGJpcnRoZGF0ZSBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBwYXRpZW50QmlydGhkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRpZW50QmlydGhkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgc2V4IHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHBhdGllbnRTZXhcbiAgICovXG4gIHNldCBwYXRpZW50U2V4KHBhdGllbnRTZXgpIHtcbiAgICB0aGlzLl9wYXRpZW50U2V4ID0gcGF0aWVudFNleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IHNleCBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBwYXRpZW50U2V4KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRpZW50U2V4O1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBmcmFtZXMgc2V0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbnVtYmVyT2ZGcmFtZXNcbiAgICovXG4gIHNldCBudW1iZXJPZkZyYW1lcyhudW1iZXJPZkZyYW1lcykge1xuICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gbnVtYmVyT2ZGcmFtZXM7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGZyYW1lcyBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBudW1iZXJPZkZyYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZGcmFtZXM7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGNoYW5uZWxzIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IG51bWJlck9mQ2hhbm5lbHNcbiAgICovXG4gIHNldCBudW1iZXJPZkNoYW5uZWxzKG51bWJlck9mQ2hhbm5lbHMpIHtcbiAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID0gbnVtYmVyT2ZDaGFubmVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgY2hhbm5lbHMgZ2V0dGVyXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXQgbnVtYmVyT2ZDaGFubmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZDaGFubmVscztcbiAgfVxuXG4gIHNldCBzdGFjayhzdGFjaykge1xuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gIH1cblxuICBnZXQgc3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICB9XG5cbiAgc2V0IG1vZGFsaXR5KG1vZGFsaXR5KSB7XG4gICAgdGhpcy5fbW9kYWxpdHkgPSBtb2RhbGl0eTtcbiAgfVxuXG4gIGdldCBtb2RhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kYWxpdHk7XG4gIH1cblxuICBzZXQgc2VnbWVudGF0aW9uVHlwZShzZWdtZW50YXRpb25UeXBlKSB7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IHNlZ21lbnRhdGlvblR5cGU7XG4gIH1cblxuICBnZXQgc2VnbWVudGF0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uVHlwZTtcbiAgfVxuXG4gIHNldCBzZWdtZW50YXRpb25TZWdtZW50cyhzZWdtZW50YXRpb25TZWdtZW50cykge1xuICAgIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzID0gc2VnbWVudGF0aW9uU2VnbWVudHM7XG4gIH1cblxuICBnZXQgc2VnbWVudGF0aW9uU2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzO1xuICB9XG59XG4iLCIvKiogKiBJbXBvcnRzICoqKi9cbmltcG9ydCBDb3JlQ29sb3JzIGZyb20gJy4uL2NvcmUvY29yZS5jb2xvcnMnO1xuaW1wb3J0IENvcmVVdGlscyBmcm9tICcuLi9jb3JlL2NvcmUudXRpbHMnO1xuaW1wb3J0IE1vZGVsc0Jhc2UgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5iYXNlJztcblxuY29uc3QgYmluYXJ5U3RyaW5nID0gcmVxdWlyZSgnbWF0aC1mbG9hdDMyLXRvLWJpbmFyeS1zdHJpbmcnKTtcblxuLyoqXG4gKiBTdGFjayBvYmplY3QuXG4gKlxuICogQG1vZHVsZSBtb2RlbHMvc3RhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxzU3RhY2sgZXh0ZW5kcyBNb2RlbHNCYXNlIHtcbiAgLyoqXG4gICAqIE1vZGVscyBTdGFjayBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3VpZCA9IG51bGw7XG4gICAgdGhpcy5fc3RhY2tJRCA9IC0xO1xuXG4gICAgdGhpcy5fZnJhbWUgPSBbXTtcbiAgICB0aGlzLl9udW1iZXJPZkZyYW1lcyA9IDA7XG5cbiAgICB0aGlzLl9yb3dzID0gMDtcbiAgICB0aGlzLl9jb2x1bW5zID0gMDtcbiAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID0gMTtcbiAgICB0aGlzLl9iaXRzQWxsb2NhdGVkID0gODtcbiAgICB0aGlzLl9waXhlbFR5cGUgPSAwO1xuICAgIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb24gPSAwO1xuXG4gICAgdGhpcy5fdGV4dHVyZVNpemUgPSA0MDk2O1xuICAgIHRoaXMuX25iVGV4dHVyZXMgPSA3O1xuICAgIHRoaXMuX3Jhd0RhdGEgPSBbXTtcblxuICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IDA7XG4gICAgdGhpcy5fd2luZG93V2lkdGggPSAwO1xuXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gMTtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gMDtcblxuICAgIHRoaXMuX21pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcblxuICAgIC8vIFRSQU5TRk9STUFUSU9OIE1BVFJJQ0VTXG4gICAgdGhpcy5fcmVnTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIHRoaXMuX2lqazJMUFMgPSBudWxsO1xuICAgIHRoaXMuX2xwczJJSksgPSBudWxsO1xuXG4gICAgdGhpcy5fYWFiYjJMUFMgPSBudWxsO1xuICAgIHRoaXMuX2xwczJBQUJCID0gbnVsbDtcblxuICAgIC8vXG4gICAgLy8gSUpLIGRpbWVuc2lvbnNcbiAgICB0aGlzLl9kaW1lbnNpb25zSUpLID0gbnVsbDtcbiAgICB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSyA9IG51bGw7XG4gICAgdGhpcy5fc3BhY2luZyA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpO1xuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gMDtcbiAgICB0aGlzLl9zbGljZVRoaWNrbmVzcyA9IDA7XG4gICAgdGhpcy5fb3JpZ2luID0gbnVsbDtcbiAgICB0aGlzLl9yaWdodEhhbmRlZCA9IHRydWU7XG4gICAgdGhpcy5feENvc2luZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApO1xuICAgIHRoaXMuX3lDb3NpbmUgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKTtcbiAgICB0aGlzLl96Q29zaW5lID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSk7XG5cbiAgICAvLyBjb252ZW5pZW5jZSB2YXJzXG4gICAgdGhpcy5fcHJlcGFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWNrZWRQZXJQaXhlbCA9IDE7XG5cbiAgICAvL1xuICAgIHRoaXMuX21vZGFsaXR5ID0gJ01vZGFsaXR5IG5vdCBzZXQnO1xuXG4gICAgLy8gU0VHTUVOVEFUSU9OIFNUVUZGXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IG51bGw7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMgPSBbXTtcbiAgICB0aGlzLl9zZWdtZW50YXRpb25EZWZhdWx0Q29sb3IgPSBbNjMsIDE3NCwgMTI4XTtcbiAgICB0aGlzLl9mcmFtZVNlZ21lbnQgPSBbXTtcbiAgICB0aGlzLl9zZWdtZW50YXRpb25MVVQgPSBbXTtcbiAgICB0aGlzLl9zZWdtZW50YXRpb25MVVRPID0gW107XG5cbiAgICAvLyBwaG90b21ldHJpY0ludGVycHJldGF0aW9uIE1vbm9jaHJvbWUxIFZTIE1vbm9jaHJvbWUyXG4gICAgdGhpcy5faW52ZXJ0ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBzZWdtZW50YXRpb24gc3RhY2suXG4gICAqIEEgc2VnbWVudGF0aW9uIHN0YWNrIGNhbiBob2xkIHggZnJhbWVzIHRoYXQgYXJlIGF0IHRoZSBzYW1lIGxvY2F0aW9uXG4gICAqIGJ1dCBzZWdtZW50YXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb246XG4gICAqIC0gRnJhbWUgWCBjb250YWlucyB2b3hlbHMgZm9yIHNlZ21lbnRhdGlvbiBBLlxuICAgKiAtIEZyYW1lIFkgY29udGFpbnMgdm94ZWxzIGZvciBzZWdtZW50dGF0aW9uIEIuXG4gICAqIC0gRnJhbWUgWCBhbmQgWSBhcmUgYXQgdGhlIHNhbWUgbG9jYXRpb24uXG4gICAqXG4gICAqIFdlIGN1cnJlbnRseSBtZXJnZSBvdmVybGFwaW5nIGZyYW1lcyBpbnRvIDEuXG4gICAqL1xuICBwcmVwYXJlU2VnbWVudGF0aW9uKCkge1xuICAgIC8vIHN0b3JlIGZyYW1lIGFuZCBkbyBzcGVjaWFsIHByZS1wcm9jZXNzaW5nXG4gICAgdGhpcy5fZnJhbWVTZWdtZW50ID0gdGhpcy5fZnJhbWU7XG4gICAgbGV0IG1lcmdlZEZyYW1lcyA9IFtdO1xuXG4gICAgLy8gb3JkZXIgZnJhbWVzXG4gICAgdGhpcy5jb21wdXRlQ29zaW5lcygpO1xuICAgIHRoaXMuX2ZyYW1lLm1hcCh0aGlzLl9jb21wdXRlRGlzdGFuY2VBcnJheU1hcC5iaW5kKG51bGwsIHRoaXMuX3pDb3NpbmUpKTtcbiAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX3NvcnREaXN0YW5jZUFycmF5U29ydCk7XG5cbiAgICAvLyBtZXJnZSBmcmFtZXNcbiAgICBsZXQgcHJldkluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGk8dGhpcy5fZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0gfHxcbiAgICAgICAgICBtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5fZGlzdCAhPSB0aGlzLl9mcmFtZVtpXS5fZGlzdCkge1xuICAgICAgICBtZXJnZWRGcmFtZXMucHVzaCh0aGlzLl9mcmFtZVtpXSk7XG4gICAgICAgIHByZXZJbmRleCsrO1xuXG4gICAgICAgIC8vIFNjYWxlIGZyYW1lXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgZWFjaCBmcmFtZSBjb250YWlucyBiaW5hcnkgZGF0YSBhYm91dCBhIHNlZ21lbnRhdGlvbi5cbiAgICAgICAgLy8gd2Ugc2NhbGUgaXQgYnkgdGhlIHJlZmVyZW5jZVNlZ21lbnROdW1iZXIgaW4gb3JkZXIgdG8gaGF2ZSBhXG4gICAgICAgIC8vIHNlZ21lbnRhdGlvbiBzcGVjaWZpYyB2b3hlbCB2YWx1ZSByYXRoZXIgdGhhbiAwIG9yIDEuXG4gICAgICAgIC8vIFRoYXQgYWxsb3dzIHVzIHRvIG1lcmdlIGZyYW1lcyBsYXRlciBvbi5cbiAgICAgICAgLy8gSWYgd2UgbWVyZ2UgZnJhbWVzIHdpdGhvdXQgc2NhbGluZywgdGhlbiB3ZSBjYW4gbm90IGRpZmZlcmVuY2lhdGVcbiAgICAgICAgLy8gdm94ZWxzIGZyb20gc2VnbWVudGF0aW9uIEEgb3IgQiBhcyB0aGUgdmFsdWUgaXMgMCBvciAxIGluIGJvdGggY2FzZXMuXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgbGV0IGs9MDtcbiAgICAgICAgICBrPG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9yb3dzICogbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX2NvbHVtbnM7XG4gICAgICAgICAgaysrKSB7XG4gICAgICAgICAgbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX3BpeGVsRGF0YVtrXSAqPVxuICAgICAgICAgICAgdGhpcy5fZnJhbWVbaV0uX3JlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmcmFtZSBhbHJlYWR5IGV4c2l0cyBhdCB0aGlzIGxvY2F0aW9uLlxuICAgICAgICAvLyBtZXJnZSBkYXRhIGZyb20gdGhpcyBzZWdtZW50YXRpb24gaW50byBleGlzdGluZyBmcmFtZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGxldCBrPTA7XG4gICAgICAgICAgazxtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5fcm93cyAqIG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9jb2x1bW5zO1xuICAgICAgICAgIGsrKykge1xuICAgICAgICAgIG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9waXhlbERhdGFba10gKz1cbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lW2ldLnBpeGVsRGF0YVtrXSAqXG4gICAgICAgICAgICAgIHRoaXMuX2ZyYW1lW2ldLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5taW5NYXggPVxuICAgICAgICBDb3JlVXRpbHMubWluTWF4KG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9waXhlbERhdGEpO1xuICAgIH1cblxuICAgIC8vIGdldCBpbmZvcm1hdGlvbiBhYm91dCBzZWdtZW50c1xuICAgIGxldCBkaWN0ID0ge307XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGk8dGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1heCA9XG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIG1heCwgcGFyc2VJbnQodGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0uc2VnbWVudE51bWJlciwgMTApKTtcblxuICAgICAgbGV0IGNvbG9yID0gdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0ucmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiO1xuICAgICAgaWYgKGNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIGRpY3RbdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0uc2VnbWVudE51bWJlcl0gPVxuICAgICAgICAgIHRoaXMuX3NlZ21lbnRhdGlvbkRlZmF1bHRDb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3RbdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0uc2VnbWVudE51bWJlcl0gPVxuICAgICAgICAgIENvcmVDb2xvcnMuY2llbGFiMlJHQiguLi5jb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgTFVUc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heDsgaSsrKSB7XG4gICAgICBsZXQgaW5kZXggPSBpIC8gbWF4O1xuICAgICAgbGV0IG9wYWNpdHkgPSBpID8gMSA6IDA7XG4gICAgICBsZXQgcmdiID0gWzAsIDAsIDBdO1xuICAgICAgaWYgKGRpY3QuaGFzT3duUHJvcGVydHkoaS50b1N0cmluZygpKSkge1xuICAgICAgICByZ2IgPSBkaWN0W2kudG9TdHJpbmcoKV07XG4gICAgICB9XG5cbiAgICAgIHJnYlswXSAvPSAyNTU7XG4gICAgICByZ2JbMV0gLz0gMjU1O1xuICAgICAgcmdiWzJdIC89IDI1NTtcblxuICAgICAgdGhpcy5fc2VnbWVudGF0aW9uTFVULnB1c2goW2luZGV4LCAuLi5yZ2JdKTtcbiAgICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVE8ucHVzaChbaW5kZXgsIG9wYWNpdHldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mcmFtZSA9IG1lcmdlZEZyYW1lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGNvc2luZXNcbiAgICogT3JkZXIgZnJhbWVzXG4gICAqIGNvbXB1dGVTcGFjaW5nXG4gICAqIHNhbml0eUNoZWNrXG4gICAqIGluaXQgc29tZSB2YXJzXG4gICAqIGNvbXB1dGUgbWluL21heFxuICAgKiBjb21wdXRlIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIC8vIGlmIHNlZ21lbnRhdGlvbiwgbWVyZ2Ugc29tZSBmcmFtZXMuLi5cbiAgICBpZiAodGhpcy5fbW9kYWxpdHkgPT09ICdTRUcnKSB7XG4gICAgICB0aGlzLnByZXBhcmVTZWdtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIGF0IGxlYXN0IDEgZnJhbWVcbiAgICBpZiAodGhpcy5fZnJhbWUgJiYgdGhpcy5fZnJhbWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fbnVtYmVyT2ZGcmFtZXMgPSB0aGlzLl9mcmFtZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnX2ZyYW1lIGRvZXNuXFwndCBjb250YWluIGFueXRoaW5nLi4uLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2ZyYW1lKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBwYXNzIHBhcmFtZXRlcnMgZnJvbSBmcmFtZSB0byBzdGFja1xuICAgIHRoaXMuX3Jvd3MgPSB0aGlzLl9mcmFtZVswXS5yb3dzO1xuICAgIHRoaXMuX2NvbHVtbnMgPSB0aGlzLl9mcmFtZVswXS5jb2x1bW5zO1xuICAgIHRoaXMuX2RpbWVuc2lvbnNJSksgPVxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjModGhpcy5fY29sdW1ucywgdGhpcy5fcm93cywgdGhpcy5fbnVtYmVyT2ZGcmFtZXMpO1xuICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zSUpLID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnggLyAyLFxuICAgICAgdGhpcy5fZGltZW5zaW9uc0lKSy55IC8gMixcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueiAvIDJcbiAgICApO1xuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gdGhpcy5fZnJhbWVbMF0uc3BhY2luZ0JldHdlZW5TbGljZXM7XG4gICAgdGhpcy5fc2xpY2VUaGlja25lc3MgPSB0aGlzLl9mcmFtZVswXS5zbGljZVRoaWNrbmVzcztcblxuICAgIC8vIGNvbXB1dGUgZGlyZWN0aW9uIGNvc2luZXNcbiAgICB0aGlzLmNvbXB1dGVDb3NpbmVzKCk7XG5cbiAgICAvLyBvcmRlciB0aGUgZnJhbWVzXG4gICAgdGhpcy5vcmRlckZyYW1lcygpO1xuXG4gICAgLy8gY29tcHV0ZS9ndWVzcyBzcGFjaW5nXG4gICAgdGhpcy5jb21wdXRlU3BhY2luZygpO1xuICAgIC8vIHNldCBleHRyYSB2YXJzIGlmIG51bGxzXG4gICAgLy8gZG8gaXQgbm93IGJlY2F1c2UgYmVmb3JlIHdlIHdvdWxkIHRoaW5rIGltYWdlIHBvc2l0aW9uL29yaWVudGF0aW9uXG4gICAgLy8gYXJlIGRlZmluZWQgYW5kIHdlIHdvdWxkIHVzZSBpdCB0byBjb21wdXRlIHNwYWNpbmcuXG4gICAgaWYgKCF0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uKSB7XG4gICAgICB0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uID0gWzAsIDAsIDBdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2ZyYW1lWzBdLmltYWdlT3JpZW50YXRpb24pIHtcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmltYWdlT3JpZW50YXRpb24gPSBbMSwgMCwgMCwgMCwgMSwgMF07XG4gICAgfVxuXG4gICAgdGhpcy5fb3JpZ2luID0gdGhpcy5fYXJyYXlUb1ZlY3RvcjModGhpcy5fZnJhbWVbMF0uaW1hZ2VQb3NpdGlvbiwgMCk7XG5cbiAgICAvLyBjb21wdXRlIHRyYW5zZm9ybXNcbiAgICB0aGlzLmNvbXB1dGVJSksyTFBTKCk7XG5cbiAgICB0aGlzLmNvbXB1dGVMUFMyQUFCQigpO1xuICAgIC8vIHRoaXMucGFja0VjaG9zKCk7XG5cbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSB0aGlzLl9mcmFtZVswXS5yZXNjYWxlU2xvcGUgfHwgMTtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gdGhpcy5fZnJhbWVbMF0ucmVzY2FsZUludGVyY2VwdCB8fCAwO1xuXG4gICAgLy8gcmVzY2FsZS9zbG9wZSBtaW4gbWF4XG4gICAgdGhpcy5jb21wdXRlTWluTWF4SW50ZW5zaXRpZXMoKTtcbiAgICB0aGlzLl9taW5NYXhbMF0gPSBNb2RlbHNTdGFjay52YWx1ZVJlc2NhbGVTbG9wZUludGVyY2VwdChcbiAgICAgIHRoaXMuX21pbk1heFswXSxcbiAgICAgIHRoaXMuX3Jlc2NhbGVTbG9wZSxcbiAgICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQpO1xuICAgIHRoaXMuX21pbk1heFsxXSA9IE1vZGVsc1N0YWNrLnZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0KFxuICAgICAgdGhpcy5fbWluTWF4WzFdLFxuICAgICAgdGhpcy5fcmVzY2FsZVNsb3BlLFxuICAgICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCk7XG5cbiAgICBsZXQgd2lkdGggPSB0aGlzLl9mcmFtZVswXS53aW5kb3dXaWR0aCB8fCB0aGlzLl9taW5NYXhbMV0gLSB0aGlzLl9taW5NYXhbMF07XG4gICAgdGhpcy5fd2luZG93V2lkdGggPSB0aGlzLl9yZXNjYWxlU2xvcGUgKiB3aWR0aCArIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQ7XG5cbiAgICBsZXQgY2VudGVyID0gdGhpcy5fZnJhbWVbMF0ud2luZG93Q2VudGVyIHx8IHRoaXMuX21pbk1heFswXSArIHdpZHRoIC8gMjtcbiAgICB0aGlzLl93aW5kb3dDZW50ZXIgPSB0aGlzLl9yZXNjYWxlU2xvcGUgKiBjZW50ZXIgKyB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0O1xuXG4gICAgdGhpcy5fYml0c0FsbG9jYXRlZCA9IHRoaXMuX2ZyYW1lWzBdLmJpdHNBbGxvY2F0ZWQ7XG4gICAgdGhpcy5fcHJlcGFyZWQgPSB0cnVlO1xuICB9XG5cbiAgcGFja0VjaG9zKCkge1xuICAgIC8vIDQgZWNobyB0aW1lcy4uLlxuICAgIGxldCBlY2hvcyA9IDQ7XG4gICAgbGV0IHBhY2tlZEVjaG8gPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IHRoaXMuX2ZyYW1lLmxlbmd0aDsgaSs9ZWNob3MpIHtcbiAgICAgIGxldCBmcmFtZSA9IHRoaXMuX2ZyYW1lW2ldO1xuICAgICAgZm9yIChsZXQgaz0wOyBrPHRoaXMuX3Jvd3MgKiB0aGlzLl9jb2x1bW5zOyBrKyspIHtcbiAgICAgICAgZm9yIChsZXQgaj0xOyBqPGVjaG9zOyBqKyspIHtcbiAgICAgICAgICBmcmFtZS5waXhlbERhdGFba10gKz0gdGhpcy5fZnJhbWVbaStqXS5waXhlbERhdGFba107XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUucGl4ZWxEYXRhW2tdIC89IGVjaG9zO1xuICAgICAgfVxuICAgICAgcGFja2VkRWNoby5wdXNoKGZyYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fZnJhbWUgPSBwYWNrZWRFY2hvO1xuICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gdGhpcy5fZnJhbWUubGVuZ3RoO1xuICAgIHRoaXMuX2RpbWVuc2lvbnNJSksgPVxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjModGhpcy5fY29sdW1ucywgdGhpcy5fcm93cywgdGhpcy5fbnVtYmVyT2ZGcmFtZXMpO1xuICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zSUpLID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnggLyAyLFxuICAgICAgdGhpcy5fZGltZW5zaW9uc0lKSy55IC8gMixcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueiAvIDJcbiAgICApO1xuICB9XG5cbiAgLy8gZnJhbWUuY29zaW5lcyAtIHJldHVybnMgYXJyYXkgW3gsIHksIHpdXG4gIGNvbXB1dGVDb3NpbmVzKCkge1xuICAgIGlmICh0aGlzLl9mcmFtZSAmJlxuICAgICAgdGhpcy5fZnJhbWVbMF0pIHtcbiAgICAgIGxldCBjb3NpbmVzID0gdGhpcy5fZnJhbWVbMF0uY29zaW5lcygpO1xuICAgICAgdGhpcy5feENvc2luZSA9IGNvc2luZXNbMF07XG4gICAgICB0aGlzLl95Q29zaW5lID0gY29zaW5lc1sxXTtcbiAgICAgIHRoaXMuX3pDb3NpbmUgPSBjb3NpbmVzWzJdO1xuICAgIH1cbiAgfVxuXG4gIG9yZGVyRnJhbWVzKCkge1xuICAgIC8vIG9yZGVyIHRoZSBmcmFtZXMgYmFzZWQgb24gdGhlaXJzIGRpbWVuc2lvbiBpbmRpY2VzXG4gICAgLy8gZmlyc3QgaW5kZXggaXMgdGhlIG1vc3QgaW1wb3J0YW50LlxuICAgIC8vIDEsMSwxLDEgd2lsbGwgYmUgZmlyc3RcbiAgICAvLyAxLDEsMiwxIHdpbGwgYmUgbmV4dFxuICAgIC8vIDEsMSwyLDMgd2lsbCBiZSBuZXh0XG4gICAgLy8gMSwxLDMsMSB3aWwgYmUgbmV4dFxuICAgIGlmICh0aGlzLl9mcmFtZVswXS5kaW1lbnNpb25JbmRleFZhbHVlcykge1xuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9vcmRlckZyYW1lT25EaW1lbnNpb25JbmRpY2VzQXJyYXlTb3J0KTtcblxuICAgIC8vIGVsc2Ugb3JkZXIgd2l0aCBpbWFnZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb25cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fZnJhbWVbMF0uaW1hZ2VQb3NpdGlvbiAmJiB0aGlzLl9mcmFtZVswXS5pbWFnZU9yaWVudGF0aW9uICYmXG4gICAgICB0aGlzLl9mcmFtZVsxXSAmJlxuICAgICAgdGhpcy5fZnJhbWVbMV0uaW1hZ2VQb3NpdGlvbiAmJiB0aGlzLl9mcmFtZVsxXS5pbWFnZU9yaWVudGF0aW9uICYmXG4gICAgICB0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uLmpvaW4oKSAhPT0gdGhpcy5fZnJhbWVbMV0uaW1hZ2VQb3NpdGlvbi5qb2luKCkpIHtcbiAgICAgIC8vIGNvbXB1dGUgYW5kIHNvcnQgYnkgZGlzdCBpbiB0aGlzIHNlcmllc1xuICAgICAgdGhpcy5fZnJhbWUubWFwKHRoaXMuX2NvbXB1dGVEaXN0YW5jZUFycmF5TWFwLmJpbmQobnVsbCwgdGhpcy5fekNvc2luZSkpO1xuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0RGlzdGFuY2VBcnJheVNvcnQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9mcmFtZVswXS5pbnN0YW5jZU51bWJlciAhPT0gbnVsbCAmJlxuICAgICAgdGhpcy5fZnJhbWVbMV0gJiYgdGhpcy5fZnJhbWVbMV0uaW5zdGFuY2VOdW1iZXIgIT09IG51bGwgJiZcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmluc3RhbmNlTnVtYmVyICE9PSB0aGlzLl9mcmFtZVsxXS5pbnN0YW5jZU51bWJlcikge1xuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0SW5zdGFuY2VOdW1iZXJBcnJheVNvcnQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9mcmFtZVswXS5zb3BJbnN0YW5jZVVJRCAmJlxuICAgICAgdGhpcy5fZnJhbWVbMV0gJiYgdGhpcy5fZnJhbWVbMV0uc29wSW5zdGFuY2VVSUQgJiZcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLnNvcEluc3RhbmNlVUlEICE9PSB0aGlzLl9mcmFtZVsxXS5zb3BJbnN0YW5jZVVJRCkge1xuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0U29wSW5zdGFuY2VVSURBcnJheVNvcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZnJhbWVbMF0pO1xuICAgICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2ZyYW1lWzFdKTtcbiAgICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzLl9mcmFtZVswXS5pbnN0YW5jZU51bWJlciAhPT0gbnVsbCAmJiB0cnVlKTtcbiAgICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyhcbiAgICAgIC8vIHRoaXMuX2ZyYW1lWzBdLmluc3RhbmNlTnVtYmVyICE9PSB0aGlzLl9mcmFtZVsxXS5pbnN0YW5jZU51bWJlcik7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2RvIG5vdCBrbm93IGhvdyB0byBvcmRlciB0aGUgZnJhbWVzLi4uJyk7XG4gICAgICAvLyBlbHNlIHNsaWNlIGxvY2F0aW9uXG4gICAgICAvLyBpbWFnZSBudW1iZXJcbiAgICAgIC8vIE9SREVSSU5HIEJBU0VEIE9OIGluc3RhbmNlIG51bWJlclxuICAgICAgLy8gX29yZGVyaW5nID0gJ2luc3RhbmNlX251bWJlcic7XG4gICAgICAvLyBmaXJzdF9pbWFnZS5zb3J0KGZ1bmN0aW9uKGEsYil7XG4gICAgICAvLyByZXR1cm4gYVtcImluc3RhbmNlX251bWJlclwiXS1iW1wiaW5zdGFuY2VfbnVtYmVyXCJdfSk7XG4gICAgfVxuICB9XG5cbiAgY29tcHV0ZVNwYWNpbmcoKSB7XG4gICAgdGhpcy54eVNwYWNpbmcoKTtcbiAgICB0aGlzLnpTcGFjaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBzdGFjayB6IHNwYWNpbmdcbiAgICovXG4gIHpTcGFjaW5nKCkge1xuICAgIGlmICh0aGlzLl9udW1iZXJPZkZyYW1lcyA+IDEpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFtZVswXS5waXhlbFNwYWNpbmcgJiYgdGhpcy5fZnJhbWVbMF0ucGl4ZWxTcGFjaW5nWzJdKSB7XG4gICAgICAgIHRoaXMuX3NwYWNpbmcueiA9IHRoaXMuX2ZyYW1lWzBdLnBpeGVsU3BhY2luZ1syXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbXB1dGUgYW5kIHNvcnQgYnkgZGlzdCBpbiB0aGlzIHNlcmllc1xuICAgICAgICB0aGlzLl9mcmFtZS5tYXAoXG4gICAgICAgICAgdGhpcy5fY29tcHV0ZURpc3RhbmNlQXJyYXlNYXAuYmluZChudWxsLCB0aGlzLl96Q29zaW5lKSk7XG5cbiAgICAgICAgLy8gaWYgZGlzdGFuY2VzIGFyZSBkaWZmZXJlbnQsIHJlLXNvcnQgYXJyYXlcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lWzFdLmRpc3QgIT09IHRoaXMuX2ZyYW1lWzBdLmRpc3QpIHtcbiAgICAgICAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX3NvcnREaXN0YW5jZUFycmF5U29ydCk7XG4gICAgICAgICAgdGhpcy5fc3BhY2luZy56ID0gdGhpcy5fZnJhbWVbMV0uZGlzdCAtIHRoaXMuX2ZyYW1lWzBdLmRpc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXMpIHtcbiAgICAgICAgICB0aGlzLl9zcGFjaW5nLnogPSB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9mcmFtZVswXS5zbGljZVRoaWNrbmVzcykge1xuICAgICAgICAgIHRoaXMuX3NwYWNpbmcueiA9IHRoaXMuX2ZyYW1lWzBdLnNsaWNlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BhY2luZ1xuICAgIC8vIGNhbiBub3QgYmUgMCBpZiBub3QgbWF0cml4IGNhbiBub3QgYmUgaW52ZXJ0ZWQuXG4gICAgaWYgKHRoaXMuX3NwYWNpbmcueiA9PT0gMCkge1xuICAgICAgdGhpcy5fc3BhY2luZy56ID0gMTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEZSQU1FIENBTiBETyBJVFxuICAgKi9cbiAgeHlTcGFjaW5nKCkge1xuICAgIGlmICh0aGlzLl9mcmFtZSAmJlxuICAgICAgdGhpcy5fZnJhbWVbMF0pIHtcbiAgICAgIGxldCBzcGFjaW5nWFkgPSB0aGlzLl9mcmFtZVswXS5zcGFjaW5nWFkoKTtcbiAgICAgIHRoaXMuX3NwYWNpbmcueCA9IHNwYWNpbmdYWVswXTtcbiAgICAgIHRoaXMuX3NwYWNpbmcueSA9IHNwYWNpbmdYWVsxXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCBtaW4gYW5kIG1heCBpbnRlbnNpdGllcyBhbW9uZyBhbGwgZnJhbWVzLlxuICAgKi9cbiAgY29tcHV0ZU1pbk1heEludGVuc2l0aWVzKCkge1xuICAgIC8vIHdoYXQgYWJvdXQgY29sb3JzISEhIT9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBnZXQgbWluL21heFxuICAgICAgdGhpcy5fbWluTWF4WzBdID0gTWF0aC5taW4odGhpcy5fbWluTWF4WzBdLCB0aGlzLl9mcmFtZVtpXS5taW5NYXhbMF0pO1xuICAgICAgdGhpcy5fbWluTWF4WzFdID0gTWF0aC5tYXgodGhpcy5fbWluTWF4WzFdLCB0aGlzLl9mcmFtZVtpXS5taW5NYXhbMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIElKSyB0byBMUFMgYW5kIGludmVydCB0cmFuc2Zvcm1zXG4gICAqL1xuICBjb21wdXRlSUpLMkxQUygpIHtcbiAgICAvLyBpamsgdG8gbHBzXG4gICAgdGhpcy5faWprMkxQUyA9IENvcmVVdGlscy5pamsyTFBTKFxuICAgICAgdGhpcy5feENvc2luZSwgdGhpcy5feUNvc2luZSwgdGhpcy5fekNvc2luZSxcbiAgICAgIHRoaXMuX3NwYWNpbmcsIHRoaXMuX29yaWdpbixcbiAgICAgIHRoaXMuX3JlZ01hdHJpeFxuICAgICk7XG5cbiAgICAvLyBscHMgMiBpamtcbiAgICB0aGlzLl9scHMySUpLID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB0aGlzLl9scHMySUpLLmdldEludmVyc2UodGhpcy5faWprMkxQUyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBMUFMgdG8gQUFCQiBhbmQgaW52ZXJ0IHRyYW5zZm9ybXNcbiAgICovXG4gIGNvbXB1dGVMUFMyQUFCQigpIHtcbiAgICB0aGlzLl9hYWJiMkxQUyA9IENvcmVVdGlscy5hYWJiMkxQUyhcbiAgICAgIHRoaXMuX3hDb3NpbmUsIHRoaXMuX3lDb3NpbmUsIHRoaXMuX3pDb3NpbmUsXG4gICAgICB0aGlzLl9vcmlnaW5cbiAgICApO1xuXG4gICAgdGhpcy5fbHBzMkFBQkIgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHRoaXMuX2xwczJBQUJCLmdldEludmVyc2UodGhpcy5fYWFiYjJMUFMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHN0YWNrc1xuICAgKlxuICAgKiBAcGFyYW0geyp9IHN0YWNrXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBtZXJnZShzdGFjaykge1xuICAgIC8vIGFsc28gbWFrZSBzdXJlIHgveS96IGNvc2luZXMgYXJlIGEgbWF0Y2ghXG4gICAgaWYgKHRoaXMuX3N0YWNrSUQgPT09IHN0YWNrLnN0YWNrSUQpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lcmdlTW9kZWxzKHRoaXMuX2ZyYW1lLCBzdGFjay5mcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFjayBjdXJyZW50IHN0YWNrIHBpeGVsIGRhdGEgaW50byA4IGJpdHMgYXJyYXkgYnVmZmVyc1xuICAgKi9cbiAgcGFjaygpIHtcbiAgICAvLyBHZXQgdG90YWwgbnVtYmVyIG9mIHZveGVsc1xuICAgIGNvbnN0IG5iVm94ZWxzID1cbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueCAqIHRoaXMuX2RpbWVuc2lvbnNJSksueSAqIHRoaXMuX2RpbWVuc2lvbnNJSksuejtcblxuICAgIC8vIFBhY2tpbmcgc3R5bGVcbiAgICBpZiAodGhpcy5fYml0c0FsbG9jYXRlZCA9PT0gMTYgJiYgdGhpcy5fbnVtYmVyT2ZDaGFubmVscyA9PT0gMSkge1xuICAgICAgdGhpcy5fcGFja2VkUGVyUGl4ZWwgPSAyO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHRleHR1cmVzIHdlIG5lZWRcbiAgICBjb25zdCB0ZXh0dXJlRGltZW5zaW9uID0gdGhpcy5fdGV4dHVyZVNpemUgKiB0aGlzLl90ZXh0dXJlU2l6ZTtcbiAgICBjb25zdCByZXF1aXJlZFRleHR1cmVzID1cbiAgICAgIE1hdGguY2VpbChuYlZveGVscyAvICh0ZXh0dXJlRGltZW5zaW9uICogdGhpcy5fcGFja2VkUGVyUGl4ZWwpKTtcbiAgICBsZXQgdm94ZWxJbmRleFN0YXJ0ID0gMDtcbiAgICBsZXQgdm94ZWxJbmRleFN0b3AgPSB0aGlzLl9wYWNrZWRQZXJQaXhlbCAqIHRleHR1cmVEaW1lbnNpb247XG4gICAgaWYgKHZveGVsSW5kZXhTdG9wID4gbmJWb3hlbHMpIHtcbiAgICAgIHZveGVsSW5kZXhTdG9wID0gbmJWb3hlbHM7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHJlcXVpcmVkVGV4dHVyZXM7IGlpKyspIHtcbiAgICAgIGxldCBwYWNrZWQgPVxuICAgICAgICB0aGlzLl9wYWNrVG84Qml0cyhcbiAgICAgICAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgIHRoaXMuX2ZyYW1lLFxuICAgICAgICAgIHRoaXMuX3RleHR1cmVTaXplLFxuICAgICAgICAgIHZveGVsSW5kZXhTdGFydCxcbiAgICAgICAgICB2b3hlbEluZGV4U3RvcCk7XG4gICAgICB0aGlzLl90ZXh0dXJlVHlwZSA9IHBhY2tlZC50ZXh0dXJlVHlwZTtcbiAgICAgIHRoaXMuX3Jhd0RhdGEucHVzaChwYWNrZWQuZGF0YSk7XG5cbiAgICAgIHZveGVsSW5kZXhTdGFydCArPSB0aGlzLl9wYWNrZWRQZXJQaXhlbCAqIHRleHR1cmVEaW1lbnNpb247XG4gICAgICB2b3hlbEluZGV4U3RvcCArPSB0aGlzLl9wYWNrZWRQZXJQaXhlbCAqIHRleHR1cmVEaW1lbnNpb247XG4gICAgICBpZiAodm94ZWxJbmRleFN0b3AgPiBuYlZveGVscykge1xuICAgICAgICB2b3hlbEluZGV4U3RvcCA9IG5iVm94ZWxzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3BhY2tlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUGFjayBmcmFtZSBkYXRhIHRvIDMyIGJpdHMgdGV4dHVyZVxuICAgKiBAcGFyYW0geyp9IGNoYW5uZWxzXG4gICAqIEBwYXJhbSB7Kn0gZnJhbWVcbiAgICogQHBhcmFtIHsqfSB0ZXh0dXJlU2l6ZVxuICAgKiBAcGFyYW0geyp9IHN0YXJ0Vm94ZWxcbiAgICogQHBhcmFtIHsqfSBzdG9wVm94ZWxcbiAgICovXG4gIF9wYWNrVG84Qml0cyhjaGFubmVscywgZnJhbWUsIHRleHR1cmVTaXplLCBzdGFydFZveGVsLCBzdG9wVm94ZWwpIHtcbiAgICBjb25zdCBwYWNrZWQgPSB7XG4gICAgICB0ZXh0dXJlVHlwZTogbnVsbCxcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgfTtcblxuICAgIGNvbnN0IGJpdHNBbGxvY2F0ZWQgPSBmcmFtZVswXS5iaXRzQWxsb2NhdGVkO1xuICAgIGNvbnN0IHBpeGVsVHlwZSA9IGZyYW1lWzBdLnBpeGVsVHlwZTtcblxuICAgIC8vIHRyYW5zZm9ybSBzaWduZWQgdG8gdW5zaWduZWQgZm9yIGNvbnZlbmllbmNlXG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMuX21pbk1heFswXSA8IDApIHtcbiAgICAgIG9mZnNldCAtPSB0aGlzLl9taW5NYXhbMF07XG4gICAgfVxuXG4gICAgbGV0IHBhY2tJbmRleCA9IDA7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBpbkZyYW1lSW5kZXggPSAwO1xuICAgIC8vIGZyYW1lIHNob3VsZCByZXR1cm4gaXQhXG4gICAgY29uc3QgZnJhbWVEaW1lbnNpb24gPSBmcmFtZVswXS5yb3dzICogZnJhbWVbMF0uY29sdW1ucztcblxuICAgIGlmIChiaXRzQWxsb2NhdGVkID09PSA4ICYmIGNoYW5uZWxzID09PSAxIHx8IGJpdHNBbGxvY2F0ZWQgPT09IDEpIHtcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xuICAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcbiAgICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XG5cbiAgICAgICAgZGF0YVtwYWNrSW5kZXhdID0gb2Zmc2V0ICsgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XG4gICAgICAgIHBhY2tJbmRleCsrO1xuICAgICAgfVxuICAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0O1xuICAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAoYml0c0FsbG9jYXRlZCA9PT0gMTYgJiYgY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDQpO1xuICAgICAgbGV0IGNvb3JkaW5hdGUgPSAwO1xuICAgICAgbGV0IGNoYW5uZWxPZmZzZXQgPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcblxuXG4gICAgICAgIGxldCByYXcgPSBvZmZzZXQgKyBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcbiAgICAgICAgZGF0YVs0ICogY29vcmRpbmF0ZSArIDIgKiBjaGFubmVsT2Zmc2V0XSA9IHJhdyAmIDB4MDBGRjtcbiAgICAgICAgZGF0YVs0ICogY29vcmRpbmF0ZSArIDIgKiBjaGFubmVsT2Zmc2V0ICsgMV0gPSAocmF3ID4+PiA4KSAmIDB4MDBGRjtcblxuICAgICAgICBwYWNrSW5kZXgrKztcbiAgICAgICAgY29vcmRpbmF0ZSA9IE1hdGguZmxvb3IocGFja0luZGV4IC8gMik7XG4gICAgICAgIGNoYW5uZWxPZmZzZXQgPSBwYWNrSW5kZXggJSAyO1xuICAgICAgfVxuXG4gICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JBRm9ybWF0O1xuICAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAoYml0c0FsbG9jYXRlZCA9PT0gMzIgJiYgY2hhbm5lbHMgPT09IDEgJiYgcGl4ZWxUeXBlID09PSAwKSB7XG4gICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcbiAgICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XG4gICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xuXG4gICAgICAgIGxldCByYXcgPSBvZmZzZXQgKyBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4XSA9IHJhdyAmIDB4MDAwMDAwRkY7XG4gICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDFdID0gKHJhdyA+Pj4gOCkgJiAweDAwMDAwMEZGO1xuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAyXSA9IChyYXcgPj4+IDE2KSAmIDB4MDAwMDAwRkY7XG4gICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDNdID0gKHJhdyA+Pj4gMjQpICYgMHgwMDAwMDBGRjtcblxuICAgICAgICBwYWNrSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkFGb3JtYXQ7XG4gICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XG4gICAgfSBlbHNlIGlmIChiaXRzQWxsb2NhdGVkID09PSAzMiAmJiBjaGFubmVscyA9PT0gMSAmJiBwaXhlbFR5cGUgPT09IDEpIHtcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDQpO1xuXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcblxuICAgICAgICBsZXQgcmF3ID0gb2Zmc2V0ICsgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XG4gICAgICAgIGxldCBiaXRTdHJpbmcgPSBiaW5hcnlTdHJpbmcocmF3KTtcbiAgICAgICAgbGV0IGJpdFN0cmluZ0FycmF5ID0gYml0U3RyaW5nLm1hdGNoKC8uezEsOH0vZyk7XG5cbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4XSA9IHBhcnNlSW50KGJpdFN0cmluZ0FycmF5WzBdLCAyKTtcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMV0gPSBwYXJzZUludChiaXRTdHJpbmdBcnJheVsxXSwgMik7XG4gICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDJdID0gcGFyc2VJbnQoYml0U3RyaW5nQXJyYXlbMl0sIDIpO1xuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAzXSA9IHBhcnNlSW50KGJpdFN0cmluZ0FycmF5WzNdLCAyKTtcblxuICAgICAgICBwYWNrSW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuUkdCQUZvcm1hdDtcbiAgICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDggJiYgY2hhbm5lbHMgPT09IDMpIHtcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDMpO1xuXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcblxuICAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXhdID1cbiAgICAgICAgICBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleF07XG4gICAgICAgIGRhdGFbMyAqIHBhY2tJbmRleCArIDFdID1cbiAgICAgICAgICBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleCArIDFdO1xuICAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXggKyAyXSA9XG4gICAgICAgICAgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXggKyAyXTtcbiAgICAgICAgcGFja0luZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkZvcm1hdDtcbiAgICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFja2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhY2sgd29ybGQgY2VudGVyXG4gICAqXG4gICAqQHJldHVybiB7Kn1cbiAgICovXG4gIHdvcmxkQ2VudGVyKCkge1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSy5jbG9uZSgpLmFkZFNjYWxhcigtMC41KVxuICAgICAgLmFwcGx5TWF0cml4NCh0aGlzLl9pamsyTFBTKTtcbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhY2sgd29ybGQgYm91bmRpbmcgYm94XG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICB3b3JsZEJvdW5kaW5nQm94KCkge1xuICAgIGxldCBiYm94ID0gW1xuICAgICAgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NSU5fVkFMVUUsXG4gICAgICBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgIF07XG5cbiAgICBjb25zdCBkaW1zID0gdGhpcy5fZGltZW5zaW9uc0lKSztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRpbXMueDsgaSArPSBkaW1zLngpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGRpbXMueTsgaiArPSBkaW1zLnkpIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPD0gZGltcy56OyBrICs9IGRpbXMueikge1xuICAgICAgICAgIGxldCB3b3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKGksIGosIGspLmFwcGx5TWF0cml4NCh0aGlzLl9pamsyTFBTKTtcbiAgICAgICAgICBiYm94ID0gW1xuICAgICAgICAgICAgTWF0aC5taW4oYmJveFswXSwgd29ybGQueCksIE1hdGgubWF4KGJib3hbMV0sIHdvcmxkLngpLCAvLyB4IG1pbi9tYXhcbiAgICAgICAgICAgIE1hdGgubWluKGJib3hbMl0sIHdvcmxkLnkpLCBNYXRoLm1heChiYm94WzNdLCB3b3JsZC55KSxcbiAgICAgICAgICAgIE1hdGgubWluKGJib3hbNF0sIHdvcmxkLnopLCBNYXRoLm1heChiYm94WzVdLCB3b3JsZC56KSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmJveDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQUFCQiBzaXplIGluIExQUyBzcGFjZS5cbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIEFBQkJveCgpIHtcbiAgICBsZXQgd29ybGQwID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5hZGRTY2FsYXIoLTAuNSlcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5faWprMkxQUylcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5fbHBzMkFBQkIpO1xuXG4gICAgbGV0IHdvcmxkNyA9IHRoaXMuX2RpbWVuc2lvbnNJSksuY2xvbmUoKS5hZGRTY2FsYXIoLTAuNSlcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5faWprMkxQUylcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5fbHBzMkFBQkIpO1xuXG4gICAgbGV0IG1pbkJCb3ggPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgIE1hdGguYWJzKHdvcmxkMC54IC0gd29ybGQ3LngpLFxuICAgICAgTWF0aC5hYnMod29ybGQwLnkgLSB3b3JsZDcueSksXG4gICAgICBNYXRoLmFicyh3b3JsZDAueiAtIHdvcmxkNy56KVxuICAgICk7XG5cbiAgICByZXR1cm4gbWluQkJveDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQUFCQiBjZW50ZXIgaW4gTFBTIHNwYWNlXG4gICAqL1xuICBjZW50ZXJBQUJCb3goKSB7XG4gICAgbGV0IGNlbnRlckJCb3ggPSB0aGlzLndvcmxkQ2VudGVyKCk7XG4gICAgY2VudGVyQkJveC5hcHBseU1hdHJpeDQodGhpcy5fbHBzMkFBQkIpO1xuICAgIHJldHVybiBjZW50ZXJCQm94O1xuICB9XG5cbiAgc3RhdGljIGluZGV4SW5EaW1lbnNpb25zKGluZGV4LCBkaW1lbnNpb25zKSB7XG4gICAgaWYgKGluZGV4LnggPj0gMCAmJlxuICAgICAgICAgaW5kZXgueSA+PSAwICYmXG4gICAgICAgICBpbmRleC56ID49IDAgJiZcbiAgICAgICAgIGluZGV4LnggPCBkaW1lbnNpb25zLnggJiZcbiAgICAgICAgIGluZGV4LnkgPCBkaW1lbnNpb25zLnkgJiZcbiAgICAgICAgIGluZGV4LnogPCBkaW1lbnNpb25zLnopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9hcnJheVRvVmVjdG9yMyhhcnJheSwgaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICBhcnJheVtpbmRleF0sXG4gICAgICBhcnJheVtpbmRleCArIDFdLFxuICAgICAgYXJyYXlbaW5kZXggKyAyXVxuICAgICAgKTtcbiAgfVxuXG4gIF9vcmRlckZyYW1lT25EaW1lbnNpb25JbmRpY2VzQXJyYXlTb3J0KGEsIGIpIHtcbiAgICBpZiAoJ2RpbWVuc2lvbkluZGV4VmFsdWVzJyBpbiBhICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhLmRpbWVuc2lvbkluZGV4VmFsdWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAnZGltZW5zaW9uSW5kZXhWYWx1ZXMnIGluIGIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIuZGltZW5zaW9uSW5kZXhWYWx1ZXMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEuZGltZW5zaW9uSW5kZXhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnNlSW50KGEuZGltZW5zaW9uSW5kZXhWYWx1ZXNbaV0sIDEwKSA+IHBhcnNlSW50KGIuZGltZW5zaW9uSW5kZXhWYWx1ZXNbaV0sIDEwKSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZUludChhLmRpbWVuc2lvbkluZGV4VmFsdWVzW2ldLCAxMCkgPCBwYXJzZUludChiLmRpbWVuc2lvbkluZGV4VmFsdWVzW2ldLCAxMCkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdPbmUgb2YgdGhlIGZyYW1lcyBkb2VzblxcJ3QgaGF2ZSBhIGRpbWVuc2lvbkluZGV4VmFsdWVzIGFycmF5LicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGEpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGIpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgX2NvbXB1dGVEaXN0YW5jZUFycmF5TWFwKG5vcm1hbCwgZnJhbWUpIHtcbiAgICBmcmFtZS5kaXN0ID0gZnJhbWUuaW1hZ2VQb3NpdGlvblswXSAqIG5vcm1hbC54ICtcbiAgICAgIGZyYW1lLmltYWdlUG9zaXRpb25bMV0gKiBub3JtYWwueSArXG4gICAgICBmcmFtZS5pbWFnZVBvc2l0aW9uWzJdICogbm9ybWFsLno7XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgX3NvcnREaXN0YW5jZUFycmF5U29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZGlzdCAtIGIuZGlzdDtcbiAgfVxuICBfc29ydEluc3RhbmNlTnVtYmVyQXJyYXlTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYS5pbnN0YW5jZU51bWJlciAtIGIuaW5zdGFuY2VOdW1iZXI7XG4gIH1cbiAgX3NvcnRTb3BJbnN0YW5jZVVJREFycmF5U29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGEuc29wSW5zdGFuY2VVSUQgLSBiLnNvcEluc3RhbmNlVUlEO1xuICB9XG5cbiAgc2V0IG51bWJlck9mQ2hhbm5lbHMobnVtYmVyT2ZDaGFubmVscykge1xuICAgIHRoaXMuX251bWJlck9mQ2hhbm5lbHMgPSBudW1iZXJPZkNoYW5uZWxzO1xuICB9XG5cbiAgZ2V0IG51bWJlck9mQ2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX251bWJlck9mQ2hhbm5lbHM7XG4gIH1cblxuICBzZXQgZnJhbWUoZnJhbWUpIHtcbiAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xuICB9XG5cbiAgZ2V0IGZyYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgfVxuXG4gIHNldCBwcmVwYXJlZChwcmVwYXJlZCkge1xuICAgIHRoaXMuX3ByZXBhcmVkID0gcHJlcGFyZWQ7XG4gIH1cblxuICBnZXQgcHJlcGFyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXBhcmVkO1xuICB9XG5cbiAgc2V0IHBhY2tlZChwYWNrZWQpIHtcbiAgICB0aGlzLl9wYWNrZWQgPSBwYWNrZWQ7XG4gIH1cblxuICBnZXQgcGFja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWNrZWQ7XG4gIH1cblxuICBzZXQgcGFja2VkUGVyUGl4ZWwocGFja2VkUGVyUGl4ZWwpIHtcbiAgICB0aGlzLl9wYWNrZWRQZXJQaXhlbCA9IHBhY2tlZFBlclBpeGVsO1xuICB9XG5cbiAgZ2V0IHBhY2tlZFBlclBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWNrZWRQZXJQaXhlbDtcbiAgfVxuXG4gIHNldCBkaW1lbnNpb25zSUpLKGRpbWVuc2lvbnNJSkspIHtcbiAgICB0aGlzLl9kaW1lbnNpb25zSUpLID0gZGltZW5zaW9uc0lKSztcbiAgfVxuXG4gIGdldCBkaW1lbnNpb25zSUpLKCkge1xuICAgIHJldHVybiB0aGlzLl9kaW1lbnNpb25zSUpLO1xuICB9XG5cbiAgc2V0IGhhbGZEaW1lbnNpb25zSUpLKGhhbGZEaW1lbnNpb25zSUpLKSB7XG4gICAgdGhpcy5faGFsZkRpbWVuc2lvbnNJSksgPSBoYWxmRGltZW5zaW9uc0lKSztcbiAgfVxuXG4gIGdldCBoYWxmRGltZW5zaW9uc0lKSygpIHtcbiAgICByZXR1cm4gdGhpcy5faGFsZkRpbWVuc2lvbnNJSks7XG4gIH1cblxuICBzZXQgcmVnTWF0cml4KHJlZ01hdHJpeCkge1xuICAgIHRoaXMuX3JlZ01hdHJpeCA9IHJlZ01hdHJpeDtcbiAgfVxuXG4gIGdldCByZWdNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZ01hdHJpeDtcbiAgfVxuXG4gIHNldCBpamsyTFBTKGlqazJMUFMpIHtcbiAgICB0aGlzLl9pamsyTFBTID0gaWprMkxQUztcbiAgfVxuXG4gIGdldCBpamsyTFBTKCkge1xuICAgIHJldHVybiB0aGlzLl9pamsyTFBTO1xuICB9XG5cbiAgc2V0IGxwczJJSksobHBzMklKSykge1xuICAgIHRoaXMuX2xwczJJSksgPSBscHMySUpLO1xuICB9XG5cbiAgZ2V0IGxwczJJSksoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xwczJJSks7XG4gIH1cblxuICBzZXQgbHBzMkFBQkIobHBzMkFBQkIpIHtcbiAgICB0aGlzLl9scHMyQUFCQiA9IGxwczJBQUJCO1xuICB9XG5cbiAgZ2V0IGxwczJBQUJCKCkge1xuICAgIHJldHVybiB0aGlzLl9scHMyQUFCQjtcbiAgfVxuXG4gIHNldCB0ZXh0dXJlU2l6ZSh0ZXh0dXJlU2l6ZSkge1xuICAgIHRoaXMuX3RleHR1cmVTaXplID0gdGV4dHVyZVNpemU7XG4gIH1cblxuICBnZXQgdGV4dHVyZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVTaXplO1xuICB9XG5cbiAgc2V0IHRleHR1cmVUeXBlKHRleHR1cmVUeXBlKSB7XG4gICAgdGhpcy5fdGV4dHVyZVR5cGUgPSB0ZXh0dXJlVHlwZTtcbiAgfVxuXG4gIGdldCB0ZXh0dXJlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVR5cGU7XG4gIH1cblxuICBzZXQgYml0c0FsbG9jYXRlZChiaXRzQWxsb2NhdGVkKSB7XG4gICAgdGhpcy5fYml0c0FsbG9jYXRlZCA9IGJpdHNBbGxvY2F0ZWQ7XG4gIH1cblxuICBnZXQgYml0c0FsbG9jYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0c0FsbG9jYXRlZDtcbiAgfVxuXG4gIHNldCByYXdEYXRhKHJhd0RhdGEpIHtcbiAgICB0aGlzLl9yYXdEYXRhID0gcmF3RGF0YTtcbiAgfVxuXG4gIGdldCByYXdEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9yYXdEYXRhO1xuICB9XG5cbiAgZ2V0IHdpbmRvd1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aW5kb3dXaWR0aDtcbiAgfVxuXG4gIHNldCB3aW5kb3dXaWR0aCh3aW5kb3dXaWR0aCkge1xuICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gd2luZG93V2lkdGg7XG4gIH1cblxuICBnZXQgd2luZG93Q2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLl93aW5kb3dDZW50ZXI7XG4gIH1cblxuICBzZXQgd2luZG93Q2VudGVyKHdpbmRvd0NlbnRlcikge1xuICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IHdpbmRvd0NlbnRlcjtcbiAgfVxuXG4gIGdldCByZXNjYWxlU2xvcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2NhbGVTbG9wZTtcbiAgfVxuXG4gIHNldCByZXNjYWxlU2xvcGUocmVzY2FsZVNsb3BlKSB7XG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gcmVzY2FsZVNsb3BlO1xuICB9XG5cbiAgZ2V0IHJlc2NhbGVJbnRlcmNlcHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQ7XG4gIH1cblxuICBzZXQgcmVzY2FsZUludGVyY2VwdChyZXNjYWxlSW50ZXJjZXB0KSB7XG4gICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCA9IHJlc2NhbGVJbnRlcmNlcHQ7XG4gIH1cblxuICBnZXQgeENvc2luZSgpIHtcbiAgICByZXR1cm4gdGhpcy5feENvc2luZTtcbiAgfVxuXG4gIHNldCB4Q29zaW5lKHhDb3NpbmUpIHtcbiAgICB0aGlzLl94Q29zaW5lID0geENvc2luZTtcbiAgfVxuXG4gIGdldCB5Q29zaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl95Q29zaW5lO1xuICB9XG5cbiAgc2V0IHlDb3NpbmUoeUNvc2luZSkge1xuICAgIHRoaXMuX3lDb3NpbmUgPSB5Q29zaW5lO1xuICB9XG5cbiAgZ2V0IHpDb3NpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pDb3NpbmU7XG4gIH1cblxuICBzZXQgekNvc2luZSh6Q29zaW5lKSB7XG4gICAgdGhpcy5fekNvc2luZSA9IHpDb3NpbmU7XG4gIH1cblxuICBnZXQgbWluTWF4KCkge1xuICAgIHJldHVybiB0aGlzLl9taW5NYXg7XG4gIH1cblxuICBzZXQgbWluTWF4KG1pbk1heCkge1xuICAgIHRoaXMuX21pbk1heCA9IG1pbk1heDtcbiAgfVxuXG4gIGdldCBzdGFja0lEKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFja0lEO1xuICB9XG5cbiAgc2V0IHN0YWNrSUQoc3RhY2tJRCkge1xuICAgIHRoaXMuX3N0YWNrSUQgPSBzdGFja0lEO1xuICB9XG5cbiAgZ2V0IHBpeGVsVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxUeXBlO1xuICB9XG5cbiAgc2V0IHBpeGVsVHlwZShwaXhlbFR5cGUpIHtcbiAgICB0aGlzLl9waXhlbFR5cGUgPSBwaXhlbFR5cGU7XG4gIH1cblxuICBnZXQgcGl4ZWxSZXByZXNlbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbjtcbiAgfVxuXG4gIHNldCBwaXhlbFJlcHJlc2VudGF0aW9uKHBpeGVsUmVwcmVzZW50YXRpb24pIHtcbiAgICB0aGlzLl9waXhlbFJlcHJlc2VudGF0aW9uID0gcGl4ZWxSZXByZXNlbnRhdGlvbjtcbiAgfVxuXG4gIHNldCBpbnZlcnQoaW52ZXJ0KSB7XG4gICAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xuICB9XG5cbiAgZ2V0IGludmVydCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52ZXJ0O1xuICB9XG5cbiAgc2V0IG1vZGFsaXR5KG1vZGFsaXR5KSB7XG4gICAgdGhpcy5fbW9kYWxpdHkgPSBtb2RhbGl0eTtcbiAgfVxuXG4gIGdldCBtb2RhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kYWxpdHk7XG4gIH1cblxuICBnZXQgcmlnaHRIYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0SGFuZGVkO1xuICB9XG5cbiAgc2V0IHJpZ2h0SGFuZGVkKHJpZ2h0SGFuZGVkKSB7XG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSByaWdodEhhbmRlZDtcbiAgfVxuXG4gIGdldCBzcGFjaW5nQmV0d2VlblNsaWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXM7XG4gIH1cblxuICBzZXQgc3BhY2luZ0JldHdlZW5TbGljZXMoc3BhY2luZ0JldHdlZW5TbGljZXMpIHtcbiAgICB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcyA9IHNwYWNpbmdCZXR3ZWVuU2xpY2VzO1xuICB9XG5cbiAgc2V0IHNlZ21lbnRhdGlvblNlZ21lbnRzKHNlZ21lbnRhdGlvblNlZ21lbnRzKSB7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMgPSBzZWdtZW50YXRpb25TZWdtZW50cztcbiAgfVxuXG4gIGdldCBzZWdtZW50YXRpb25TZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHM7XG4gIH1cblxuICBzZXQgc2VnbWVudGF0aW9uVHlwZShzZWdtZW50YXRpb25UeXBlKSB7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IHNlZ21lbnRhdGlvblR5cGU7XG4gIH1cblxuICBnZXQgc2VnbWVudGF0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uVHlwZTtcbiAgfVxuXG4gIHNldCBzZWdtZW50YXRpb25MVVQoc2VnbWVudGF0aW9uTFVUKSB7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uTFVUID0gc2VnbWVudGF0aW9uTFVUO1xuICB9XG5cbiAgZ2V0IHNlZ21lbnRhdGlvbkxVVCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uTFVUO1xuICB9XG5cbiAgc2V0IHNlZ21lbnRhdGlvbkxVVE8oc2VnbWVudGF0aW9uTFVUTykge1xuICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVE8gPSBzZWdtZW50YXRpb25MVVRPO1xuICB9XG5cbiAgZ2V0IHNlZ21lbnRhdGlvbkxVVE8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRhdGlvbkxVVE87XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIEZVTkNUSU9OXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGZvciBjb3JlLnV0aWxzLnZhbHVlXG4gICAqXG4gICAqIEdldCB2b3hlbCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGFja1xuICAgKiBAcGFyYW0geyp9IGNvb3JkaW5hdGVcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN0YXRpYyB2YWx1ZShzdGFjaywgY29vcmRpbmF0ZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBtb2RlbHMuc3RhY2sudmFsdWUgaXMgZGVwcmVjYXRlZC5cbiAgICAgICBQbGVhc2UgdXNlIGNvcmUudXRpbHMudmFsdWUgaW5zdGVhZC5gKTtcbiAgICByZXR1cm4gQ29yZVV0aWxzLnZhbHVlKHN0YWNrLCBjb29yZGluYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBmb3IgY29yZS51dGlscy5yZXNjYWxlU2xvcGVJbnRlcmNlcHRcbiAgICpcbiAgICogQXBwbHkgc2xvcGUvaW50ZXJjZXB0IHRvIGEgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBzbG9wZVxuICAgKiBAcGFyYW0geyp9IGludGVyY2VwdFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3RhdGljIHZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0KHZhbHVlLCBzbG9wZSwgaW50ZXJjZXB0KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYG1vZGVscy5zdGFjay52YWx1ZVJlc2NhbGVTbG9wZUludGVyY2VwdCBpcyBkZXByZWNhdGVkLlxuICAgICAgIFBsZWFzZSB1c2UgY29yZS51dGlscy5yZXNjYWxlU2xvcGVJbnRlcmNlcHQgaW5zdGVhZC5gKTtcbiAgICByZXR1cm4gQ29yZVV0aWxzLnJlc2NhbGVTbG9wZUludGVyY2VwdChcbiAgICAgIHZhbHVlLCBzbG9wZSwgaW50ZXJjZXB0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBmb3IgY29yZS51dGlscy53b3JsZFRvRGF0YVxuICAgKlxuICAgKiBUcmFuc2Zvcm0gY29vcmRpbmF0ZXMgZnJvbSB3b3JsZCBjb29yZGluYXRlIHRvIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGFja1xuICAgKiBAcGFyYW0geyp9IHdvcmxkQ29vcmRpbmF0ZXNcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN0YXRpYyB3b3JsZFRvRGF0YShzdGFjaywgd29ybGRDb29yZGluYXRlcykge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBtb2RlbHMuc3RhY2sud29ybGRUb0RhdGEgaXMgZGVwcmVjYXRlZC5cbiAgICAgICBQbGVhc2UgdXNlIGNvcmUudXRpbHMud29ybGRUb0RhdGEgaW5zdGVhZC5gKTtcblxuICAgIHJldHVybiBDb3JlVXRpbHMud29ybGRUb0RhdGEoc3RhY2suX2xwczJJSkssIHdvcmxkQ29vcmRpbmF0ZXMpO1xuICB9XG59XG5cbi8vIFNsaWNlciB3YXkgdG8gaGFuZGxlIGltYWdlc1xuLy8gc2hvdWxkIGZvbGxvdyBpdC4uLlxuIC8vIDg5NyAgIGlmICggKHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdICE9IGlkeFNlcmllc0luc3RhbmNlVUlEICYmIHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdID49IDAgJiYgaWR4U2VyaWVzSW5zdGFuY2VVSUQgPj0gMCkgfHxcbiAvLyA4OTggICAgICAgICh0aGlzLT5JbmRleENvbnRlbnRUaW1lW2tdICE9IGlkeENvbnRlbnRUaW1lICYmIHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gPj0gMCAmJiBpZHhDb250ZW50VGltZSA+PSAwKSB8fFxuIC8vIDg5OSAgICAgICAgKHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gIT0gaWR4VHJpZ2dlclRpbWUgJiYgdGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSA+PSAwICYmIGlkeFRyaWdnZXJUaW1lID49IDApIHx8XG4gLy8gOTAwICAgICAgICAodGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSAhPSBpZHhFY2hvTnVtYmVycyAmJiB0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdID49IDAgJiYgaWR4RWNob051bWJlcnMgPj0gMCkgfHxcbiAvLyA5MDEgICAgICAgICh0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gIT0gaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiAgJiYgdGhpcy0+SW5kZXhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uW2tdID49IDAgJiYgaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiA+PSAwKSB8fFxuIC8vIDkwMiAgICAgICAgKHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSAhPSBpZHhTbGljZUxvY2F0aW9uICYmIHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSA+PSAwICYmIGlkeFNsaWNlTG9jYXRpb24gPj0gMCkgfHxcbiAvLyA5MDMgICAgICAgICh0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdICE9IGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ICYmIHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gPj0gMCAmJiBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCA+PSAwKSApXG4gLy8gOTA0ICAgICB7XG4gLy8gOTA1ICAgICAgIGNvbnRpbnVlO1xuIC8vIDkwNiAgICAgfVxuIiwiLyoqXG4gKiBAbW9kdWxlIG1vZGVscy92b3hlbFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc1ZveGVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faWQgPSAtMTtcbiAgICB0aGlzLl93b3JsZENvb3JkaW5hdGVzID0gbnVsbDtcbiAgICB0aGlzLl9kYXRhQ29vcmRpbmF0ZXMgPSBudWxsO1xuICAgIHRoaXMuX3NjcmVlbkNvb3JkaW5hdGVzID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gIH1cblxuICBzZXQgd29ybGRDb29yZGluYXRlcyh3b3JsZENvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5fd29ybGRDb29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZXM7XG4gIH1cblxuICBnZXQgd29ybGRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fd29ybGRDb29yZGluYXRlcztcbiAgfVxuXG4gIHNldCBkYXRhQ29vcmRpbmF0ZXMoZGF0YUNvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5fZGF0YUNvb3JkaW5hdGVzID0gZGF0YUNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZ2V0IGRhdGFDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkaW5hdGVzO1xuICB9XG5cbiAgc2V0IHNjcmVlbkNvb3JkaW5hdGVzKHNjcmVlbkNvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5fc2NyZWVuQ29vcmRpbmF0ZXMgPSBzY3JlZW5Db29yZGluYXRlcztcbiAgfVxuXG4gIGdldCBzY3JlZW5Db29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuQ29vcmRpbmF0ZXM7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIHNldCBpZChpZCkge1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG59XG4iLCIvLyBmdHA6Ly9tZWRpY2FsLm5lbWEub3JnL01FRElDQUwvRGljb20vMjAxNGMvb3V0cHV0L2NodG1sL3BhcnQwNS9zZWN0XzYuMi5odG1sL1xuXG4vLyBTbGljZXIgd2F5IHRvIGhhbmRsZSBpbWFnZXNcbi8vIHNob3VsZCBmb2xsb3cgaXQuLi5cbi8vIDg5NyAgIGlmICggKHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdICE9IGlkeFNlcmllc0luc3RhbmNlVUlEICYmIHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdID49IDAgJiYgaWR4U2VyaWVzSW5zdGFuY2VVSUQgPj0gMCkgfHxcbi8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XG4vLyA4OTkgICAgICAgICh0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdICE9IGlkeFRyaWdnZXJUaW1lICYmIHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gPj0gMCAmJiBpZHhUcmlnZ2VyVGltZSA+PSAwKSB8fFxuLy8gOTAwICAgICAgICAodGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSAhPSBpZHhFY2hvTnVtYmVycyAmJiB0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdID49IDAgJiYgaWR4RWNob051bWJlcnMgPj0gMCkgfHxcbi8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XG4vLyA5MDIgICAgICAgICh0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gIT0gaWR4U2xpY2VMb2NhdGlvbiAmJiB0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gPj0gMCAmJiBpZHhTbGljZUxvY2F0aW9uID49IDApIHx8XG4vLyA5MDMgICAgICAgICh0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdICE9IGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ICYmIHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gPj0gMCAmJiBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCA+PSAwKSApXG4vLyA5MDQgICAgIHtcbi8vIDkwNSAgICAgICBjb250aW51ZTtcbi8vIDkwNiAgICAgfVxuXG4vKiogKiBJbXBvcnRzICoqKi9cbmltcG9ydCBQYXJzZXJzVm9sdW1lIGZyb20gJy4vcGFyc2Vycy52b2x1bWUnO1xuXG5sZXQgRGljb21QYXJzZXIgPSByZXF1aXJlKCdkaWNvbS1wYXJzZXInKTtcbmxldCBKcGVnID0gcmVxdWlyZSgnanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzJyk7XG5sZXQgSnBlZ0Jhc2VsaW5lID0gcmVxdWlyZSgnLi4vLi4vZXh0ZXJuYWwvc2NyaXB0cy9qcGVnJyk7XG5sZXQgSnB4ID0gcmVxdWlyZSgnLi4vLi4vZXh0ZXJuYWwvc2NyaXB0cy9qcHgnKTtcblxuLyoqXG4gKiBEaWNvbSBwYXJzZXIgaXMgYSBjb21iaW5hdGlvbiBvZiB1dGlsaXRpZXMgdG8gZ2V0IGEgVkpTIGltYWdlIGZyb20gZGljb20gZmlsZXMuXG4gKnNjcmlwdHNcbiAqIFJlbGllcyBvbiBkY21qcywganF1ZXJ5LCBIVE1MNSBmZXRjaCBBUEksIEhUTUw1IHByb21pc2UgQVBJLlxuICpcbiAqIEBtb2R1bGUgcGFyc2Vycy9kaWNvbVxuICpcbiAqIEBwYXJhbSBhcnJheUJ1ZmZlciB7YXJyYXlidWZmZXJ9IC0gTGlzdCBvZiBmaWxlcyB0byBiZSBwYXJzZWQuIEl0IGlzIHVybHMgZnJvbSB3aGljaFxuICogVkpTLnBhcnNlcnMuZGljb20gY2FuIHB1bGwgdGhlIGRhdGEgZnJvbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc0RpY29tIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5faWQgPSBpZDtcblxuICAgIHRoaXMuX2FycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XG5cbiAgICBsZXQgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYXJyYXlCdWZmZXIpO1xuXG4gICAgLy8gY2F0Y2ggZXJyb3JcbiAgICAvLyB0aHJvdyBlcnJvciBpZiBhbnkhXG4gICAgdGhpcy5fZGF0YVNldCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fZGF0YVNldCA9IERpY29tUGFyc2VyLnBhcnNlRGljb20oYnl0ZUFycmF5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coZSk7XG4gICAgICB0aHJvdyAncGFyc2Vycy5kaWNvbSBjb3VsZCBub3QgcGFyc2UgdGhlIGZpbGUnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGltYWdlL2ZyYW1lIHNwZWNpZmljXG4gIHNlcmllc0luc3RhbmNlVUlEKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMjAwMDBlJyk7XG4gIH1cblxuICBzdHVkeUluc3RhbmNlVUlEKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMjAwMDBkJyk7XG4gIH1cblxuICBtb2RhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDA2MCcpO1xuICB9XG5cbiAgc2VnbWVudGF0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDYyMDAwMScpO1xuICB9XG5cbiAgc2VnbWVudGF0aW9uU2VnbWVudHMoKSB7XG4gICAgbGV0IHNlZ21lbnRhdGlvblNlZ21lbnRzID0gW107XG4gICAgbGV0IHNlZ21lbnRTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDAwNjIwMDAyO1xuXG4gICAgaWYgKCFzZWdtZW50U2VxdWVuY2UpIHtcbiAgICAgIHJldHVybiBzZWdtZW50YXRpb25TZWdtZW50cztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaTwgc2VnbWVudFNlcXVlbmNlLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiID1cbiAgICAgICAgdGhpcy5fcmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiKHNlZ21lbnRTZXF1ZW5jZS5pdGVtc1tpXSk7XG4gICAgICBsZXQgc2VnbWVudGF0aW9uQ29kZSA9IHRoaXMuX3NlZ21lbnRhdGlvbkNvZGUoc2VnbWVudFNlcXVlbmNlLml0ZW1zW2ldKTtcbiAgICAgIGxldCBzZWdtZW50TnVtYmVyID0gc2VnbWVudFNlcXVlbmNlLml0ZW1zW2ldLmRhdGFTZXQudWludDE2KCd4MDA2MjAwMDQnKTtcbiAgICAgIGxldCBzZWdtZW50TGFiZWwgPSBzZWdtZW50U2VxdWVuY2UuaXRlbXNbaV0uZGF0YVNldC5zdHJpbmcoJ3gwMDYyMDAwNScpO1xuICAgICAgbGV0IHNlZ21lbnRBbGdvcml0aG1UeXBlID1cbiAgICAgICAgc2VnbWVudFNlcXVlbmNlLml0ZW1zW2ldLmRhdGFTZXQuc3RyaW5nKCd4MDA2MjAwMDgnKTtcblxuICAgICAgc2VnbWVudGF0aW9uU2VnbWVudHMucHVzaCh7XG4gICAgICAgIHJlY29tbWVuZGVkRGlzcGxheUNJRUxhYixcbiAgICAgICAgc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3I6XG4gICAgICAgICAgc2VnbWVudGF0aW9uQ29kZVsnc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3InXSxcbiAgICAgICAgc2VnbWVudGF0aW9uQ29kZVZhbHVlOiBzZWdtZW50YXRpb25Db2RlWydzZWdtZW50YXRpb25Db2RlVmFsdWUnXSxcbiAgICAgICAgc2VnbWVudGF0aW9uQ29kZU1lYW5pbmc6IHNlZ21lbnRhdGlvbkNvZGVbJ3NlZ21lbnRhdGlvbkNvZGVNZWFuaW5nJ10sXG4gICAgICAgIHNlZ21lbnROdW1iZXIsXG4gICAgICAgIHNlZ21lbnRMYWJlbCxcbiAgICAgICAgc2VnbWVudEFsZ29yaXRobVR5cGUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VnbWVudGF0aW9uU2VnbWVudHM7XG4gIH1cblxuICBfc2VnbWVudGF0aW9uQ29kZShzZWdtZW50KSB7XG4gICAgbGV0IHNlZ21lbnRhdGlvbkNvZGVEZXNpZ25hdG9yID0gJ3Vua25vd24nO1xuICAgIGxldCBzZWdtZW50YXRpb25Db2RlVmFsdWUgPSAndW5rbm93bic7XG4gICAgbGV0IHNlZ21lbnRhdGlvbkNvZGVNZWFuaW5nID0gJ3Vua25vd24nO1xuICAgIGxldCBlbGVtZW50ID0gc2VnbWVudC5kYXRhU2V0LmVsZW1lbnRzLngwMDA4MjIxODtcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXRlbXMgJiYgZWxlbWVudC5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBzZWdtZW50YXRpb25Db2RlRGVzaWduYXRvciA9IGVsZW1lbnQuaXRlbXNbMF0uZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDEwMicpO1xuICAgICAgc2VnbWVudGF0aW9uQ29kZVZhbHVlID0gZWxlbWVudC5pdGVtc1swXS5kYXRhU2V0LnN0cmluZygneDAwMDgwMTAwJyk7XG4gICAgICBzZWdtZW50YXRpb25Db2RlTWVhbmluZyA9IGVsZW1lbnQuaXRlbXNbMF0uZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDEwNCcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZWdtZW50YXRpb25Db2RlRGVzaWduYXRvcixcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVWYWx1ZSxcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVNZWFuaW5nLFxuICAgIH07XG4gIH1cblxuICBfcmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiKHNlZ21lbnQpIHtcbiAgICBpZiAoIXNlZ21lbnQuZGF0YVNldC5lbGVtZW50cy54MDA2MjAwMGQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBvZmZzZXQgPSBzZWdtZW50LmRhdGFTZXQuZWxlbWVudHMueDAwNjIwMDBkLmRhdGFPZmZzZXQ7XG4gICAgbGV0IGxlbmd0aCA9IHNlZ21lbnQuZGF0YVNldC5lbGVtZW50cy54MDA2MjAwMGQubGVuZ3RoO1xuICAgIGxldCBieXRlQXJyYXkgPSBzZWdtZW50LmRhdGFTZXQuYnl0ZUFycmF5LnNsaWNlKG9mZnNldCwgb2Zmc2V0KyBsZW5ndGgpO1xuXG4gICAgLy8gaHR0cHM6Ly93d3cuZGFic29mdC5jaC9kaWNvbS8zL0MuMTAuNy4xLjEvXG4gICAgbGV0IENJRUxhYlNjYWxlZCA9IG5ldyBVaW50MTZBcnJheShsZW5ndGgvMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGk8bGVuZ3RoLzI7IGkrKykge1xuICAgICAgQ0lFTGFiU2NhbGVkW2ldID0gKGJ5dGVBcnJheVsyKmkgKyAxXSA8PCA4KSArIGJ5dGVBcnJheVsyKmldO1xuICAgIH1cblxuICAgIGxldCBDSUVMYWJOb3JtYWxpemVkID0gW1xuICAgICAgQ0lFTGFiU2NhbGVkWzBdIC8gNjU1MzUgKiAxMDAsXG4gICAgICBDSUVMYWJTY2FsZWRbMV0gLyA2NTUzNSAqIDI1NSAtIDEyOCxcbiAgICAgIENJRUxhYlNjYWxlZFsyXSAvIDY1NTM1ICogMjU1IC0gMTI4LFxuICAgIF07XG5cbiAgICByZXR1cm4gQ0lFTGFiTm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTT1AgSW5zdGFuY2UgVUlEXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZnJhbWVJbmRleFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc29wSW5zdGFuY2VVSUQoZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgc29wSW5zdGFuY2VVSUQgPVxuICAgICAgdGhpcy5fZmluZFN0cmluZ0V2ZXJ5d2hlcmUoJ3gyMDA1MTQwZicsICd4MDAwODAwMTgnLCBmcmFtZUluZGV4KTtcbiAgICByZXR1cm4gc29wSW5zdGFuY2VVSUQ7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgc3ludGF4IFVJRFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdHJhbnNmZXJTeW50YXhVSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAwMjAwMTAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHVkeSBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3R1ZHlEZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDA4MTAzMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmllcyBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc2VyaWVzRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAwODEwM2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IG5hbWVcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAwMDEwJyk7XG4gIH1cblxuICAvKipcbiAgICogUGF0aWVudCBJRFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcGF0aWVudElEKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAwMDIwJyk7XG4gIH1cblxuICAvKipcbiAgICogUGF0aWVudCBiaXJ0aGRhdGVcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnRCaXJ0aGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAxMDAwMzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IHNleFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcGF0aWVudFNleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDEwMDA0MCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgYWdlXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBwYXRpZW50QWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAxMDEwJyk7XG4gIH1cblxuICAvKipcbiAgICogUGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb25cbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAyODAwMDQnKTtcbiAgfVxuXG4gIHBsYW5hckNvbmZpZ3VyYXRpb24oKSB7XG4gICAgbGV0IHBsYW5hckNvbmZpZ3VyYXRpb24gPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMDA2Jyk7XG5cbiAgICBpZiAodHlwZW9mIHBsYW5hckNvbmZpZ3VyYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwbGFuYXJDb25maWd1cmF0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGxhbmFyQ29uZmlndXJhdGlvbjtcbiAgfVxuXG4gIHNhbXBsZXNQZXJQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDAwMicpO1xuICB9XG5cbiAgbnVtYmVyT2ZGcmFtZXMoKSB7XG4gICAgbGV0IG51bWJlck9mRnJhbWVzID0gdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDI4MDAwOCcpO1xuXG4gICAgLy8gbmVlZCBzb21ldGhpbmcgc21hcnRlciFcbiAgICBpZiAodHlwZW9mIG51bWJlck9mRnJhbWVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbnVtYmVyT2ZGcmFtZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXJPZkZyYW1lcztcbiAgfVxuXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSAxO1xuICAgIGxldCBwaG90b21ldHJpY0ludGVycHJldGF0aW9uID0gdGhpcy5waG90b21ldHJpY0ludGVycHJldGF0aW9uKCk7XG5cbiAgICBpZiAoIShwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnUkdCJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnUEFMRVRURSBDT0xPUicgJiZcbiAgICAgICAgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiAhPT0gJ1lCUl9GVUxMJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX0ZVTExfNDIyJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX1BBUlRJQUxfNDIyJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX1BBUlRJQUxfNDIwJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX1JDVCcpKSB7XG4gICAgICBudW1iZXJPZkNoYW5uZWxzID0gMztcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcbiAgICByZXR1cm4gbnVtYmVyT2ZDaGFubmVscztcbiAgfVxuXG4gIGludmVydCgpIHtcbiAgICBsZXQgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9IHRoaXMucGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbigpO1xuXG4gICAgcmV0dXJuICgocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9PT0gJ01PTk9DSFJPTUUxJykgPyB0cnVlIDogZmFsc2UpO1xuICB9XG5cbiAgaW1hZ2VPcmllbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxuICAgIGxldCBpbWFnZU9yaWVudGF0aW9uID0gdGhpcy5fZmluZFN0cmluZ0V2ZXJ5d2hlcmUoJ3gwMDIwOTExNicsICd4MDAyMDAwMzcnLCBmcmFtZUluZGV4KTtcblxuICAgIC8vIGZvcm1hdCBpbWFnZSBvcmllbnRhdGlvbiAoJzFcXDBcXDBcXDBcXDFcXDAnKSB0byBhcnJheSBjb250YWluaW5nIDYgbnVtYmVyc1xuICAgIGlmIChpbWFnZU9yaWVudGF0aW9uKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcbiAgICAgIC8vIG1pZ2h0IG5vdCBuZWVkIHRvIHNwbGl0IChmbG9hdFN0cmluZyArIGluZGV4KVxuICAgICAgaW1hZ2VPcmllbnRhdGlvbiA9IGltYWdlT3JpZW50YXRpb24uc3BsaXQoJ1xcXFwnKS5tYXAoTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VPcmllbnRhdGlvbjtcbiAgfVxuXG4gIHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gLTE7XG4gICAgbGV0IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyRWxlbWVudCA9IHRoaXMuX2ZpbmRJbkdyb3VwU2VxdWVuY2UoJ3g1MjAwOTIzMCcsICd4MDA2MjAwMGEnLCBmcmFtZUluZGV4KTtcblxuICAgIGlmIChyZWZlcmVuY2VkU2VnbWVudE51bWJlckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gcmVmZXJlbmNlZFNlZ21lbnROdW1iZXJFbGVtZW50LnVpbnQxNigneDAwNjIwMDBiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xuICB9XG5cbiAgcGl4ZWxBc3BlY3RSYXRpbygpIHtcbiAgICBsZXQgcGl4ZWxBc3BlY3RSYXRpbyA9IFtcbiAgICAgIHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyODAwMzQnLCAwKSxcbiAgICAgIHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyODAwMzQnLCAxKSxcbiAgICBdO1xuXG4gICAgLy8gbmVlZCBzb21ldGhpbmcgc21hcnRlciFcbiAgICBpZiAodHlwZW9mIHBpeGVsQXNwZWN0UmF0aW9bMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwaXhlbEFzcGVjdFJhdGlvID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcbiAgICByZXR1cm4gcGl4ZWxBc3BlY3RSYXRpbztcbiAgfVxuXG4gIGltYWdlUG9zaXRpb24oZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgaW1hZ2VQb3NpdGlvbiA9IHRoaXMuX2ZpbmRTdHJpbmdFdmVyeXdoZXJlKCd4MDAyMDkxMTMnLCAneDAwMjAwMDMyJywgZnJhbWVJbmRleCk7XG5cbiAgICAvLyBmb3JtYXQgaW1hZ2Ugb3JpZW50YXRpb24gKCcxXFwwXFwwXFwwXFwxXFwwJykgdG8gYXJyYXkgY29udGFpbmluZyA2IG51bWJlcnNcbiAgICBpZiAoaW1hZ2VQb3NpdGlvbikge1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIG51bWJlciEgKG5vdCBhIHN0cmluZyEpXG4gICAgICBpbWFnZVBvc2l0aW9uID0gaW1hZ2VQb3NpdGlvbi5zcGxpdCgnXFxcXCcpLm1hcChOdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZVBvc2l0aW9uO1xuICB9XG5cbiAgaW5zdGFuY2VOdW1iZXIoZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xuICAgIC8vIGZpcnN0IGxvb2sgZm9yIGZyYW1lIVxuICAgIC8vIHBlciBmcmFtZSBmdW5jdGlvbm5hbCBncm91cCBzZXF1ZW5jZVxuICAgIGxldCBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDUyMDA5MjMwO1xuXG4gICAgaWYgKHR5cGVvZiBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxuICAgICAgICAgICAgICAuaXRlbXNbZnJhbWVJbmRleF0uZGF0YVNldC5lbGVtZW50cy54MjAwNTE0MGYpIHtcbiAgICAgICAgbGV0IHBsYW5lT3JpZW50YXRpb25TZXF1ZW5jZSA9IHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlXG4gICAgICAgICAgICAuaXRlbXNbZnJhbWVJbmRleF0uZGF0YVNldC5lbGVtZW50cy54MjAwNTE0MGYuaXRlbXNbMF0uZGF0YVNldDtcbiAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBwbGFuZU9yaWVudGF0aW9uU2VxdWVuY2UuaW50U3RyaW5nKCd4MDAyMDAwMTMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlTnVtYmVyID0gdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDIwMDAxMycpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2VOdW1iZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNob3VsZCB3ZSBkZWZhdWx0IHRvIHVuZGVmaW5lZD8/XG4gICAgICAvLyBkZWZhdWx0IG9yaWVudGF0aW9uXG4gICAgICBpbnN0YW5jZU51bWJlciA9IHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyMDAwMTMnKTtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZU51bWJlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZU51bWJlcjtcbiAgfVxuXG4gIHBpeGVsU3BhY2luZyhmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxuICAgIGxldCBwaXhlbFNwYWNpbmcgPSB0aGlzLl9maW5kU3RyaW5nRXZlcnl3aGVyZSgneDAwMjg5MTEwJywgJ3gwMDI4MDAzMCcsIGZyYW1lSW5kZXgpO1xuXG4gICAgLy8gZm9ybWF0IGltYWdlIG9yaWVudGF0aW9uICgnMVxcMFxcMFxcMFxcMVxcMCcpIHRvIGFycmF5IGNvbnRhaW5pbmcgNiBudW1iZXJzXG4gICAgLy8gc2hvdWxkIHdlIGRlZmF1bHQgdG8gdW5kZWZpbmVkPz9cbiAgICBpZiAocGl4ZWxTcGFjaW5nKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGFycmF5IG9mIG51bWJlcnMhIChub3Qgc3RyaW5ncyEpXG4gICAgICBwaXhlbFNwYWNpbmcgPSBwaXhlbFNwYWNpbmcuc3BsaXQoJ1xcXFwnKS5tYXAoTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGl4ZWxTcGFjaW5nO1xuICB9XG5cbiAgcm93cyhmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCByb3dzID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDAxMCcpO1xuXG4gICAgaWYgKHR5cGVvZiByb3dzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcm93cyA9IG51bGw7XG4gICAgICAvLyBwcmludCB3YXJuaW5nIGF0IGxlYXN0Li4uXG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBjb2x1bW5zKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGNvbHVtbnMgPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMDExJyk7XG5cbiAgICBpZiAodHlwZW9mIGNvbHVtbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb2x1bW5zID0gbnVsbDtcbiAgICAgIC8vIHByaW50IHdhcm5pbmcgYXQgbGVhc3QuLi5cbiAgICB9XG5cbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIHBpeGVsVHlwZShmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIDAgaW50ZWdlciwgMSBmbG9hdFxuICAgIC8vIGRpY29tIG9ubHkgc3VwcG9ydCBpbnRlZ2Vyc1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcGl4ZWxSZXByZXNlbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBwaXhlbFJlcHJlc2VudGF0aW9uID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDEwMycpO1xuICAgIHJldHVybiBwaXhlbFJlcHJlc2VudGF0aW9uO1xuICB9XG5cbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDEwMCcpO1xuICAgIHJldHVybiBiaXRzQWxsb2NhdGVkO1xuICB9XG5cbiAgaGlnaEJpdChmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxuICAgIGxldCBoaWdoQml0ID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDEwMicpO1xuICAgIHJldHVybiBoaWdoQml0O1xuICB9XG5cbiAgcmVzY2FsZUludGVyY2VwdChmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kRmxvYXRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShcbiAgICAgICd4MDAyODkxNDUnLCAneDAwMjgxMDUyJywgZnJhbWVJbmRleCk7XG4gIH1cblxuICByZXNjYWxlU2xvcGUoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZmluZEZsb2F0U3RyaW5nSW5GcmFtZUdyb3VwU2VxdWVuY2UoXG4gICAgICAneDAwMjg5MTQ1JywgJ3gwMDI4MTA1MycsIGZyYW1lSW5kZXgpO1xuICB9XG5cbiAgd2luZG93Q2VudGVyKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxuICAgICAgJ3gwMDI4OTEzMicsICd4MDAyODEwNTAnLCBmcmFtZUluZGV4KTtcbiAgfVxuXG4gIHdpbmRvd1dpZHRoKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxuICAgICAgJ3gwMDI4OTEzMicsICd4MDAyODEwNTEnLCBmcmFtZUluZGV4KTtcbiAgfVxuXG4gIHNsaWNlVGhpY2tuZXNzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxuICAgICAgJ3gwMDI4OTExMCcsICd4MDAxODAwNTAnLCBmcmFtZUluZGV4KTtcbiAgfVxuXG4gIHNwYWNpbmdCZXR3ZWVuU2xpY2VzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IHNwYWNpbmcgPSB0aGlzLl9kYXRhU2V0LmludFN0cmluZygneDAwMTgwMDg4Jyk7XG5cbiAgICBpZiAodHlwZW9mIHNwYWNpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzcGFjaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BhY2luZztcbiAgfVxuXG4gIGRpbWVuc2lvbkluZGV4VmFsdWVzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGRpbWVuc2lvbkluZGV4VmFsdWVzID0gbnVsbDtcblxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXAgc2VxdWVuY2VcbiAgICBsZXQgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng1MjAwOTIzMDtcblxuICAgIGlmICh0eXBlb2YgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQgZnJhbWVDb250ZW50U2VxdWVuY2UgPSBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxuICAgICAgICAgIC5pdGVtc1tmcmFtZUluZGV4XS5kYXRhU2V0LmVsZW1lbnRzLngwMDIwOTExMTtcbiAgICAgIGlmIChmcmFtZUNvbnRlbnRTZXF1ZW5jZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgZnJhbWVDb250ZW50U2VxdWVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgZnJhbWVDb250ZW50U2VxdWVuY2UgPSBmcmFtZUNvbnRlbnRTZXF1ZW5jZS5pdGVtc1swXS5kYXRhU2V0O1xuICAgICAgICBsZXQgZGltZW5zaW9uSW5kZXhWYWx1ZXNFbHQgPSBmcmFtZUNvbnRlbnRTZXF1ZW5jZS5lbGVtZW50cy54MDAyMDkxNTc7XG4gICAgICAgIGlmIChkaW1lbnNpb25JbmRleFZhbHVlc0VsdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkaW1lbnNpb25JbmRleFZhbHVlc0VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIC80IGJlY2F1c2UgVUxcbiAgICAgICAgICBsZXQgbmJWYWx1ZXMgPSBkaW1lbnNpb25JbmRleFZhbHVlc0VsdC5sZW5ndGggLyA0O1xuICAgICAgICAgIGRpbWVuc2lvbkluZGV4VmFsdWVzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iVmFsdWVzOyBpKyspIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbkluZGV4VmFsdWVzLnB1c2goXG4gICAgICAgICAgICAgIGZyYW1lQ29udGVudFNlcXVlbmNlLnVpbnQzMigneDAwMjA5MTU3JywgaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaW1lbnNpb25JbmRleFZhbHVlcztcbiAgfVxuXG4gIGluU3RhY2tQb3NpdGlvbk51bWJlcihmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBpblN0YWNrUG9zaXRpb25OdW1iZXIgPSBudWxsO1xuXG4gICAgLy8gdHJ5IHRvIGdldCBpdCBmcm9tIGVuaGFuY2VkIE1SIGltYWdlc1xuICAgIC8vIHBlci1mcmFtZSBmdW5jdGlvbm5hbCBncm91cCBzZXF1ZW5jZVxuICAgIGxldCBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDUyMDA5MjMwO1xuXG4gICAgaWYgKHR5cGVvZiBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE5PVCBBIFBISUxJUFMgVFJJQ0shXG4gICAgICBsZXQgcGhpbGlwc1ByaXZhdGVTZXF1ZW5jZSA9IHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlXG4gICAgICAgICAgLml0ZW1zW2ZyYW1lSW5kZXhdLmRhdGFTZXQuZWxlbWVudHMueDAwMjA5MTExLml0ZW1zWzBdLmRhdGFTZXQ7XG4gICAgICBpblN0YWNrUG9zaXRpb25OdW1iZXIgPSBwaGlsaXBzUHJpdmF0ZVNlcXVlbmNlLnVpbnQzMigneDAwMjA5MDU3Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluU3RhY2tQb3NpdGlvbk51bWJlciA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYGluc3RhY2sgcG9zaXRpb24gJHtpblN0YWNrUG9zaXRpb25OdW1iZXJ9YCk7XG5cbiAgICByZXR1cm4gaW5TdGFja1Bvc2l0aW9uTnVtYmVyO1xuICB9XG5cbiAgc3RhY2tJRChmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBzdGFja0lEID0gbnVsbDtcblxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXAgc2VxdWVuY2VcbiAgICBsZXQgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng1MjAwOTIzMDtcblxuICAgIGlmICh0eXBlb2YgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBOT1QgQSBQSElMSVBTIFRSSUNLIVxuICAgICAgbGV0IHBoaWxpcHNQcml2YXRlU2VxdWVuY2UgPSBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxuICAgICAgICAgIC5pdGVtc1tmcmFtZUluZGV4XS5kYXRhU2V0LmVsZW1lbnRzLngwMDIwOTExMS5pdGVtc1swXS5kYXRhU2V0O1xuICAgICAgc3RhY2tJRCA9IHBoaWxpcHNQcml2YXRlU2VxdWVuY2UuaW50U3RyaW5nKCd4MDAyMDkwNTYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhY2tJRCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrSUQ7XG4gIH1cblxuICBleHRyYWN0UGl4ZWxEYXRhKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgLy8gZGVjb21wcmVzc1xuICAgIGxldCBkZWNvbXByZXNzZWREYXRhID0gdGhpcy5fZGVjb2RlUGl4ZWxEYXRhKGZyYW1lSW5kZXgpO1xuXG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcblxuICAgIGlmIChudW1iZXJPZkNoYW5uZWxzID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRDb2xvclNwYWNlKGRlY29tcHJlc3NlZERhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVjb21wcmVzc2VkRGF0YTtcbiAgICB9XG4gIH1cblxuICBtaW5NYXhQaXhlbERhdGEocGl4ZWxEYXRhID0gW10pIHtcbiAgICBsZXQgbWluTWF4ID0gWzY1NTM1LCAtMzI3NjhdO1xuICAgIGxldCBudW1QaXhlbHMgPSBwaXhlbERhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVBpeGVsczsgaW5kZXgrKykge1xuICAgICAgbGV0IHNwdiA9IHBpeGVsRGF0YVtpbmRleF07XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHNwdik7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIHNwdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbk1heDtcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuICAvL1xuXG4gIF9maW5kSW5Hcm91cFNlcXVlbmNlKHNlcXVlbmNlLCBzdWJzZXF1ZW5jZSwgaW5kZXgpIHtcbiAgICBsZXQgZnVuY3Rpb25hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzW3NlcXVlbmNlXTtcblxuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQgaW5TZXF1ZW5jZSA9IGZ1bmN0aW9uYWxHcm91cFNlcXVlbmNlLml0ZW1zW2luZGV4XS5kYXRhU2V0LmVsZW1lbnRzW3N1YnNlcXVlbmNlXTtcblxuICAgICAgaWYgKHR5cGVvZiBpblNlcXVlbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gaW5TZXF1ZW5jZS5pdGVtc1swXS5kYXRhU2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2ZpbmRTdHJpbmdJbkdyb3VwU2VxdWVuY2Uoc2VxdWVuY2UsIHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XG4gICAgLy8gaW5kZXggPSAwIGlmIHNoYXJlZCEhIVxuICAgIGxldCBkYXRhU2V0ID0gdGhpcy5fZmluZEluR3JvdXBTZXF1ZW5jZShzZXF1ZW5jZSwgc3Vic2VxdWVuY2UsIGluZGV4KTtcblxuICAgIGlmIChkYXRhU2V0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGF0YVNldC5zdHJpbmcodGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9maW5kU3RyaW5nSW5GcmFtZUdyb3VwU2VxdWVuY2Uoc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluZFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjI5Jywgc3Vic2VxdWVuY2UsIHRhZywgMCkgfHxcbiAgICAgICAgdGhpcy5fZmluZFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjMwJywgc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpO1xuICB9XG5cbiAgX2ZpbmRTdHJpbmdFdmVyeXdoZXJlKHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XG4gICAgbGV0IHRhcmdldFN0cmluZyA9IHRoaXMuX2ZpbmRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShzdWJzZXF1ZW5jZSwgdGFnLCBpbmRleCk7XG5cbiAgICBpZiAodGFyZ2V0U3RyaW5nID09PSBudWxsKSB7XG4gICAgICB0YXJnZXRTdHJpbmcgPSB0aGlzLl9kYXRhU2V0LnN0cmluZyh0YWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0U3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGFyZ2V0U3RyaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0U3RyaW5nO1xuICB9XG5cbiAgX2ZpbmRGbG9hdFN0cmluZ0luR3JvdXBTZXF1ZW5jZShzZXF1ZW5jZSwgc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpIHtcbiAgICBsZXQgZGF0YUluR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZmxvYXRTdHJpbmcodGFnKTtcblxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXBcbiAgICBpZiAodHlwZW9mIGRhdGFJbkdyb3VwU2VxdWVuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhSW5Hcm91cFNlcXVlbmNlID0gdGhpcy5fZmluZEluR3JvdXBTZXF1ZW5jZShzZXF1ZW5jZSwgc3Vic2VxdWVuY2UsIGluZGV4KTtcblxuICAgICAgaWYgKGRhdGFJbkdyb3VwU2VxdWVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFJbkdyb3VwU2VxdWVuY2UuZmxvYXRTdHJpbmcodGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhSW5Hcm91cFNlcXVlbmNlO1xuICB9XG5cbiAgX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjI5Jywgc3Vic2VxdWVuY2UsIHRhZywgMCkgfHxcbiAgICAgICAgdGhpcy5fZmluZEZsb2F0U3RyaW5nSW5Hcm91cFNlcXVlbmNlKCd4NTIwMDkyMzAnLCBzdWJzZXF1ZW5jZSwgdGFnLCBpbmRleCk7XG4gIH1cblxuICBfZGVjb2RlUGl4ZWxEYXRhKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgLy8gaWYgY29tcHJlc3NlZC4uP1xuICAgIGxldCB0cmFuc2ZlclN5bnRheFVJRCA9IHRoaXMudHJhbnNmZXJTeW50YXhVSUQoKTtcblxuICAgIC8vIGZpbmQgY29tcHJlc3Npb24gc2NoZW1lXG4gICAgaWYgKFxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi40LjkwJyB8fFxuICAgICAgLy8gSlBFRyAyMDAwIExvc3NsZXNzXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjQuOTEnKSB7XG4gICAgICAvLyBKUEVHIDIwMDAgTG9zc3lcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVKMksoZnJhbWVJbmRleCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41NycgfHxcbiAgICAgIC8vIEpQRUcgTG9zc2xlc3MsIE5vbmhpZXJhcmNoaWNhbCAoUHJvY2Vzc2VzIDE0KVxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi40LjcwJykge1xuICAgICAgLy8gSlBFRyBMb3NzbGVzcywgTm9uaGllcmFyY2hpY2FsIChQcm9jZXNzZXMgMTQgW1NlbGVjdGlvbiAxXSlcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVKUEVHTG9zc2xlc3MoZnJhbWVJbmRleCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41MCcgfHxcbiAgICAgIC8vIEpQRUcgQmFzZWxpbmUgbG9zc3kgcHJvY2VzcyAxICg4IGJpdClcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41MScpIHtcbiAgICAgIC8vIEpQRUcgQmFzZWxpbmUgbG9zc3kgcHJvY2VzcyAyICYgNCAoMTIgYml0KVxuICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUpQRUdCYXNlbGluZShmcmFtZUluZGV4KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMicgfHxcbiAgICAgIC8vIEltcGxpY2l0IFZSIExpdHRsZSBFbmRpYW5cbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMScpIHtcbiAgICAgIC8vIEV4cGxpY2l0IFZSIExpdHRsZSBFbmRpYW5cbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVVbmNvbXByZXNzZWQoZnJhbWVJbmRleCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMicpIHtcbiAgICAgIC8vIEV4cGxpY2l0IFZSIEJpZyBFbmRpYW5cbiAgICAgIGxldCBmcmFtZSA9IHRoaXMuX2RlY29kZVVuY29tcHJlc3NlZChmcmFtZUluZGV4KTtcbiAgICAgIC8vIGFuZCBzYXdwIGl0IVxuICAgICAgcmV0dXJuIHRoaXMuX3N3YXBGcmFtZShmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHtcbiAgICAgICAgZXJyb3I6IGBubyBkZWNvZGVyIGZvciB0cmFuc2ZlciBzeW50YXggJHt0cmFuc2ZlclN5bnRheFVJRH1gLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBfZGVjb2RlSjJLKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGVuY29kZWRQaXhlbERhdGEgPSBEaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhKHRoaXMuX2RhdGFTZXQsIHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwLCBmcmFtZUluZGV4KTtcbiAgICAvLyBsZXQgcGl4ZWxEYXRhRWxlbWVudCA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwO1xuICAgIC8vIGxldCBwaXhlbERhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLl9kYXRhU2V0LmJ5dGVBcnJheS5idWZmZXIsIHBpeGVsRGF0YUVsZW1lbnQuZGF0YU9mZnNldCwgcGl4ZWxEYXRhRWxlbWVudC5sZW5ndGgpO1xuICAgIGxldCBqcHhJbWFnZSA9IG5ldyBKcHgoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vT0hJRi9pbWFnZS1KUEVHMjAwMC9pc3N1ZXMvNlxuICAgIC8vIEl0IGN1cnJlbnRseSByZXR1cm5zIGVpdGhlciBJbnQxNiBvciBVaW50MTYgYmFzZWQgb24gd2hldGhlciB0aGUgY29kZXN0cmVhbSBpcyBzaWduZWQgb3Igbm90LlxuICAgIGpweEltYWdlLnBhcnNlKGVuY29kZWRQaXhlbERhdGEpO1xuXG4gICAgLy8gbGV0IGoya1dpZHRoID0ganB4SW1hZ2Uud2lkdGg7XG4gICAgLy8gbGV0IGoya0hlaWdodCA9IGpweEltYWdlLmhlaWdodDtcblxuICAgIGxldCBjb21wb25lbnRzQ291bnQgPSBqcHhJbWFnZS5jb21wb25lbnRzQ291bnQ7XG4gICAgaWYgKGNvbXBvbmVudHNDb3VudCAhPT0gMSkge1xuICAgICAgdGhyb3cgJ0pQRUcyMDAwIGRlY29kZXIgcmV0dXJuZWQgYSBjb21wb25lbnRDb3VudCBvZiAke2NvbXBvbmVudHNDb3VudH0sIHdoZW4gMSBpcyBleHBlY3RlZCc7XG4gICAgfVxuICAgIGxldCB0aWxlQ291bnQgPSBqcHhJbWFnZS50aWxlcy5sZW5ndGg7XG5cbiAgICBpZiAodGlsZUNvdW50ICE9PSAxKSB7XG4gICAgICB0aHJvdyAnSlBFRzIwMDAgZGVjb2RlciByZXR1cm5lZCBhIHRpbGVDb3VudCBvZiAke3RpbGVDb3VudH0sIHdoZW4gMSBpcyBleHBlY3RlZCc7XG4gICAgfVxuXG4gICAgbGV0IHRpbGVDb21wb25lbnRzID0ganB4SW1hZ2UudGlsZXNbMF07XG4gICAgbGV0IHBpeGVsRGF0YSA9IHRpbGVDb21wb25lbnRzLml0ZW1zO1xuXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGoya1dpZHRoLCBqMmtIZWlnaHQpO1xuXG4gICAgcmV0dXJuIHBpeGVsRGF0YTtcbiAgfVxuXG4gIC8vIGZyb20gY29ybmVyc3RvbmVcbiAgX2RlY29kZUpQRUdMb3NzbGVzcyhmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBlbmNvZGVkUGl4ZWxEYXRhID0gRGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YSh0aGlzLl9kYXRhU2V0LCB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng3ZmUwMDAxMCwgZnJhbWVJbmRleCk7XG4gICAgbGV0IHBpeGVsUmVwcmVzZW50YXRpb24gPSB0aGlzLnBpeGVsUmVwcmVzZW50YXRpb24oZnJhbWVJbmRleCk7XG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCk7XG4gICAgbGV0IGJ5dGVPdXRwdXQgPSBiaXRzQWxsb2NhdGVkIDw9IDggPyAxIDogMjtcbiAgICBsZXQgZGVjb2RlciA9IG5ldyBKcGVnLmxvc3NsZXNzLkRlY29kZXIoKTtcbiAgICBsZXQgZGVjb21wcmVzc2VkRGF0YSA9IGRlY29kZXIuZGVjb2RlKGVuY29kZWRQaXhlbERhdGEuYnVmZmVyLCBlbmNvZGVkUGl4ZWxEYXRhLmJ5dGVPZmZzZXQsIGVuY29kZWRQaXhlbERhdGEubGVuZ3RoLCBieXRlT3V0cHV0KTtcblxuICAgIGlmIChwaXhlbFJlcHJlc2VudGF0aW9uID09PSAwKSB7XG4gICAgICBpZiAoYnl0ZU91dHB1dCA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGRlY29tcHJlc3NlZERhdGEuYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVudGVzdGVkIVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjb21wcmVzc2VkRGF0YS5idWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoZGVjb21wcmVzc2VkRGF0YS5idWZmZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWNvZGVKUEVHQmFzZWxpbmUoZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgZW5jb2RlZFBpeGVsRGF0YSA9IERpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGEodGhpcy5fZGF0YVNldCwgdGhpcy5fZGF0YVNldC5lbGVtZW50cy54N2ZlMDAwMTAsIGZyYW1lSW5kZXgpO1xuICAgIGxldCByb3dzID0gdGhpcy5yb3dzKGZyYW1lSW5kZXgpO1xuICAgIGxldCBjb2x1bW5zID0gdGhpcy5jb2x1bW5zKGZyYW1lSW5kZXgpO1xuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gdGhpcy5iaXRzQWxsb2NhdGVkKGZyYW1lSW5kZXgpO1xuICAgIGxldCBqcGVnQmFzZWxpbmUgPSBuZXcgSnBlZ0Jhc2VsaW5lKCk7XG4gICAganBlZ0Jhc2VsaW5lLnBhcnNlKGVuY29kZWRQaXhlbERhdGEpO1xuXG4gICAgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDgpIHtcbiAgICAgIHJldHVybiBqcGVnQmFzZWxpbmUuZ2V0RGF0YShjb2x1bW5zLCByb3dzKTtcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDE2KSB7XG4gICAgICByZXR1cm4ganBlZ0Jhc2VsaW5lLmdldERhdGExNihjb2x1bW5zLCByb3dzKTtcbiAgICB9XG4gIH1cblxuICBfZGVjb2RlVW5jb21wcmVzc2VkKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IHBpeGVsUmVwcmVzZW50YXRpb24gPSB0aGlzLnBpeGVsUmVwcmVzZW50YXRpb24oZnJhbWVJbmRleCk7XG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCk7XG4gICAgbGV0IHBpeGVsRGF0YUVsZW1lbnQgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng3ZmUwMDAxMDtcbiAgICBsZXQgcGl4ZWxEYXRhT2Zmc2V0ID0gcGl4ZWxEYXRhRWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKCk7XG4gICAgbGV0IG51bVBpeGVscyA9XG4gICAgICB0aGlzLnJvd3MoZnJhbWVJbmRleCkgKiB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCkgKiBudW1iZXJPZkNoYW5uZWxzO1xuICAgIGxldCBmcmFtZU9mZnNldCA9IDA7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2RhdGFTZXQuYnl0ZUFycmF5LmJ1ZmZlcjtcblxuICAgIGlmIChwaXhlbFJlcHJlc2VudGF0aW9uID09PSAwICYmIGJpdHNBbGxvY2F0ZWQgPT09IDgpIHtcbiAgICAgIC8vIHVuc2lnbmVkIDggYml0XG4gICAgICBmcmFtZU9mZnNldCA9IHBpeGVsRGF0YU9mZnNldCArIGZyYW1lSW5kZXggKiBudW1QaXhlbHM7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDAgJiYgYml0c0FsbG9jYXRlZCA9PT0gMTYpIHtcbiAgICAgIC8vIHVuc2lnbmVkIDE2IGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICogMjtcbiAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDEgJiYgYml0c0FsbG9jYXRlZCA9PT0gMTYpIHtcbiAgICAgIC8vIHNpZ25lZCAxNiBiaXRcbiAgICAgIGZyYW1lT2Zmc2V0ID0gcGl4ZWxEYXRhT2Zmc2V0ICsgZnJhbWVJbmRleCAqIG51bVBpeGVscyAqIDI7XG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDAgJiYgYml0c0FsbG9jYXRlZCA9PT0gMzIpIHtcbiAgICAgIC8vIHVuc2lnbmVkIDMyIGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICogNDtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDAgJiYgYml0c0FsbG9jYXRlZCA9PT0gMSkge1xuICAgICAgbGV0IG5ld0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihudW1QaXhlbHMpO1xuICAgICAgbGV0IG5ld0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkobmV3QnVmZmVyKTtcblxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xuICAgICAgbGV0IGluZGV4ID0gMDtcblxuICAgICAgbGV0IGJpdFN0YXJ0ID0gZnJhbWVJbmRleCAqIG51bVBpeGVscztcbiAgICAgIGxldCBiaXRFbmQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICsgbnVtUGl4ZWxzO1xuXG4gICAgICBsZXQgYnl0ZVN0YXJ0ID0gTWF0aC5mbG9vcihiaXRTdGFydCAvIDgpO1xuICAgICAgbGV0IGJpdFN0YXJ0T2Zmc2V0ID0gYml0U3RhcnQgLSBieXRlU3RhcnQgKiA4O1xuICAgICAgbGV0IGJ5dGVFbmQgPSBNYXRoLmNlaWwoYml0RW5kIC8gOCk7XG5cbiAgICAgIGxldCB0YXJnZXRCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIsIHBpeGVsRGF0YU9mZnNldCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSBieXRlU3RhcnQ7IGkgPD0gYnl0ZUVuZDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChiaXRTdGFydE9mZnNldCA8IDgpIHtcbiAgICAgICAgICBzd2l0Y2ggKGJpdFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMSAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMiAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMyAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNCAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNSAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNiAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNyAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiaXRTdGFydE9mZnNldCsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgLy8gaWYgcmV0dXJuLi5cbiAgICAgICAgICBpZiAoaW5kZXggPj0gbnVtUGl4ZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJpdFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY29udmVydENvbG9yU3BhY2UodW5jb21wcmVzc2VkRGF0YSkge1xuICAgIGxldCByZ2JEYXRhID0gbnVsbDtcbiAgICBsZXQgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9IHRoaXMucGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbigpO1xuICAgIGxldCBwbGFuYXJDb25maWd1cmF0aW9uID0gdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uKCk7XG5cbiAgICBpZiAocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9PT0gJ1JHQicgJiZcbiAgICAgICAgcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMCkge1xuICAgICAgLy8gQUxMIEdPT0QsIEFMUkVBRFkgT1JERVJFRFxuICAgICAgLy8gcGxhbmFyIG9yIG5vbiBwbGFuYXIgcGxhbmFyQ29uZmlndXJhdGlvblxuICAgICAgcmdiRGF0YSA9IHVuY29tcHJlc3NlZERhdGE7XG4gICAgfSBlbHNlIGlmIChwaG90b21ldHJpY0ludGVycHJldGF0aW9uID09PSAnUkdCJyAmJlxuICAgICAgICBwbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgICAgICByZ2JEYXRhID0gbmV3IEludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJnYkRhdGEgPSBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSB7XG4gICAgICAgIHJnYkRhdGEgPSBuZXcgSW50MTZBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICByZ2JEYXRhID0gbmV3IFVpbnQxNkFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICd1bnN1cG9ydGVkIHR5cGVkIGFycmF5OiAke3VuY29tcHJlc3NlZERhdGF9JztcbiAgICAgIH1cblxuICAgICAgbGV0IG51bVBpeGVscyA9IHVuY29tcHJlc3NlZERhdGEubGVuZ3RoIC8gMztcbiAgICAgIGxldCByZ2JhSW5kZXggPSAwO1xuICAgICAgbGV0IHJJbmRleCA9IDA7XG4gICAgICBsZXQgZ0luZGV4ID0gbnVtUGl4ZWxzO1xuICAgICAgbGV0IGJJbmRleCA9IG51bVBpeGVscyAqIDI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBpeGVsczsgaSsrKSB7XG4gICAgICAgIHJnYkRhdGFbcmdiYUluZGV4KytdID0gdW5jb21wcmVzc2VkRGF0YVtySW5kZXgrK107IC8vIHJlZFxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHVuY29tcHJlc3NlZERhdGFbZ0luZGV4KytdOyAvLyBncmVlblxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHVuY29tcHJlc3NlZERhdGFbYkluZGV4KytdOyAvLyBibHVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwaG90b21ldHJpY0ludGVycHJldGF0aW9uID09PSAnWUJSX0ZVTEwnKSB7XG4gICAgICBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgICAgICByZ2JEYXRhID0gbmV3IEludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJnYkRhdGEgPSBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSB7XG4gICAgICAgIHJnYkRhdGEgPSBuZXcgSW50MTZBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICByZ2JEYXRhID0gbmV3IFVpbnQxNkFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICd1bnN1cG9ydGVkIHR5cGVkIGFycmF5OiAke3VuY29tcHJlc3NlZERhdGF9JztcbiAgICAgIH1cblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYWZleS9jb3JuZXJzdG9uZVdBRE9JbWFnZUxvYWRlci9ibG9iL21hc3Rlci9zcmMvZGVjb2RlWUJSRnVsbC5qc1xuICAgICAgbGV0IG5QaXhlbHMgPSB1bmNvbXByZXNzZWREYXRhLmxlbmd0aCAvIDM7XG4gICAgICBsZXQgeWJySW5kZXggPSAwO1xuICAgICAgbGV0IHJnYmFJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5QaXhlbHM7IGkrKykge1xuICAgICAgICBsZXQgeSA9IHVuY29tcHJlc3NlZERhdGFbeWJySW5kZXgrK107XG4gICAgICAgIGxldCBjYiA9IHVuY29tcHJlc3NlZERhdGFbeWJySW5kZXgrK107XG4gICAgICAgIGxldCBjciA9IHVuY29tcHJlc3NlZERhdGFbeWJySW5kZXgrK107XG4gICAgICAgIHJnYkRhdGFbcmdiYUluZGV4KytdID0geSArIDEuNDAyMDAgKiAoY3IgLSAxMjgpOy8vIHJlZFxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHkgLSAwLjM0NDE0ICogKGNiIC0gMTI4KSAtIDAuNzE0MTQgKiAoY3IgLSAxMjgpOyAvLyBncmVlblxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHkgKyAxLjc3MjAwICogKGNiIC0gMTI4KTsgLy8gYmx1ZVxuICAgICAgICAvLyByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IDI1NTsgLy9hbHBoYVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAncGhvdG9tZXRyaWMgaW50ZXJwb2xhdGlvbiBub3Qgc3VwcG9ydGVkOiAke3Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb259JztcbiAgICB9XG5cbiAgICByZXR1cm4gcmdiRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIGJ5dGVzIGluIGZyYW1lLlxuICAgKi9cbiAgX3N3YXBGcmFtZShmcmFtZSkge1xuICAgIC8vIHN3YXAgYnl0ZXMgKCBpZiA4Yml0cyAoMWJ5dGUpLCBub3RoaW5nIHRvIHN3YXApXG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoKTtcblxuICAgIGlmIChiaXRzQWxsb2NhdGVkID09PSAxNikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFtZVtpXSA9IHRoaXMuX3N3YXAxNihmcmFtZVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaXRzQWxsb2NhdGVkID09PSAzMikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFtZVtpXSA9IHRoaXMuX3N3YXAzMihmcmFtZVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbn1cblxuLy8gVkpTLnBhcnNlcnMuZGljb20ucHJvdG90eXBlLmZyYW1lT2ZSZWZlcmVuY2VVSUQgPSBmdW5jdGlvbihpbWFnZUpxdWVyeURvbSkge1xuLy8gICAvLyB0cnkgdG8gYWNjZXNzIGZyYW1lIG9mIHJlZmVyZW5jZSBVSUQgdGhyb3VnaCBpdHMgRElDT00gdGFnXG4vLyAgIGxldCBzZXJpZXNOdW1iZXIgPSBpbWFnZUpxdWVyeURvbS5maW5kKCdbdGFnPVwiMDAyMDAwNTJcIl0gVmFsdWUnKS50ZXh0KCk7XG5cbi8vICAgLy8gaWYgbm90IGF2YWlsYWJsZSwgYXNzdW1lIHdlIG9ubHkgaGF2ZSAxIGZyYW1lXG4vLyAgIGlmIChzZXJpZXNOdW1iZXIgPT09ICcnKSB7XG4vLyAgICAgc2VyaWVzTnVtYmVyID0gMTtcbi8vICAgfVxuLy8gICByZXR1cm4gc2VyaWVzTnVtYmVyO1xuLy8gfTtcblxuLy9cbi8vIEVORElBTiBORVNTIE5PVCBUQUtFTiBDQVJFIE9GXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzUzMjA0MzkvaG93LWRvLWktc3dhcC1lbmRpYW4tbmVzcy1ieXRlLW9yZGVyLW9mLWEtbGV0aWFibGUtaW4tamF2YXNjcmlwdFxuLy8gaHR0cDovL3d3dy5iYXJyZS5ub20uZnIvbWVkaWNhbC9zYW1wbGVzL1xuLy9cbi8vXG4iLCJpbXBvcnQgRGljb20gZnJvbSAnLi9wYXJzZXJzLmRpY29tJztcbmltcG9ydCBOaWZ0aSBmcm9tICcuL3BhcnNlcnMubmlmdGknO1xuaW1wb3J0IE5ycmQgZnJvbSAnLi9wYXJzZXJzLm5ycmQnO1xuXG4vKipcbiAqIEBtb2R1bGUgcGFyc2Vyc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRGljb20sXG4gIE5pZnRpLFxuICBOcnJkLFxufTtcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XG5cbi8qKlxuICogQG1vZHVsZSBwYXJzZXJzL21oZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzTUhEIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAgKiBAbWVtYmVyXG4gICAgICAqIEB0eXBlIHthcnJheWJ1ZmZlcn1cbiAgICAqL1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5fdXJsID0gZGF0YS51cmw7XG4gICAgdGhpcy5faGVhZGVyID0ge307XG4gICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBwYXJzZSBoZWFkZXIgKG1oZCkgZGF0YVxuICAgICAgbGV0IGxpbmVzID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEubWhkQnVmZmVyKS5zcGxpdCgnXFxuJyk7XG4gICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgbGV0IGtleXZhbHVlID0gbGluZS5zcGxpdCgnPScpO1xuICAgICAgICAgIGlmIChrZXl2YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcltrZXl2YWx1ZVswXS50cmltKCldID0ga2V5dmFsdWVbMV0udHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9oZWFkZXIuRGltU2l6ZSA9IHRoaXMuX2hlYWRlci5EaW1TaXplLnNwbGl0KCcgJyk7XG4gICAgICB0aGlzLl9oZWFkZXIuRWxlbWVudFNwYWNpbmcgPSB0aGlzLl9oZWFkZXIuRWxlbWVudFNwYWNpbmcuc3BsaXQoJyAnKTtcbiAgICAgIHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXggPSB0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4LnNwbGl0KCcgJyk7XG4gICAgICB0aGlzLl9oZWFkZXIuT2Zmc2V0ID0gdGhpcy5faGVhZGVyLk9mZnNldC5zcGxpdCgnICcpO1xuICAgICAgLy9cbiAgICAgIHRoaXMuX2J1ZmZlciA9IGRhdGEucmF3QnVmZmVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ29vb3BzLi4uIDooJyk7XG4gICAgfVxuICB9XG5cbiAgcmlnaHRIYW5kZWQoKSB7XG4gICAgbGV0IGFuYXRvbWljYWxPcmllbnRhdGlvbiA9IHRoaXMuX2hlYWRlci5BbmF0b21pY2FsT3JpZW50YXRpb247XG4gICAgaWYgKGFuYXRvbWljYWxPcmllbnRhdGlvbiA9PT0gJ1JBUycgfHxcbiAgICAgICAgYW5hdG9taWNhbE9yaWVudGF0aW9uID09PSAnUlBJJyB8fFxuICAgICAgICBhbmF0b21pY2FsT3JpZW50YXRpb24gPT09ICdMUFMnIHx8XG4gICAgICAgIGFuYXRvbWljYWxPcmllbnRhdGlvbiA9PT0gJ0xBSScpIHtcbiAgICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmlnaHRIYW5kZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmlnaHRIYW5kZWQ7XG4gIH1cblxuICBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcbiAgICAvLyB1c2UgZmlsZW5hbWUgKyB0aW1lc3RhbXAuLj9cbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgbnVtYmVyT2ZGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2hlYWRlci5EaW1TaXplWzJdLCAxMCk7XG4gIH1cblxuICBzb3BJbnN0YW5jZVVJRChmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBmcmFtZUluZGV4O1xuICB9XG5cbiAgcm93cyhmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9oZWFkZXIuRGltU2l6ZVsxXSwgMTApO1xuICB9XG5cbiAgY29sdW1ucyhmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9oZWFkZXIuRGltU2l6ZVswXSwgMTApO1xuICB9XG5cbiAgcGl4ZWxUeXBlKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgLy8gMCAtIGludFxuICAgIC8vIDEgLSBmbG9hdFxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gMTtcblxuICAgIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVUNIQVInIHx8XG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9DSEFSJykge1xuICAgICAgYml0c0FsbG9jYXRlZCA9IDg7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1VTSE9SVCcgfHxcbiAgICAgICAgdGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1NIT1JUJykge1xuICAgICAgYml0c0FsbG9jYXRlZCA9IDE2O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9VRkxPQVQnIHx8XG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9GTE9BVCcpIHtcbiAgICAgIGJpdHNBbGxvY2F0ZWQgPSAzMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYml0c0FsbG9jYXRlZDtcbiAgfVxuXG4gIHBpeGVsU3BhY2luZyhmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCB4ID0gcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuRWxlbWVudFNwYWNpbmdbMF0sIDEwKTtcbiAgICBsZXQgeSA9IHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLkVsZW1lbnRTcGFjaW5nWzFdLCAxMCk7XG4gICAgbGV0IHogPSBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5FbGVtZW50U3BhY2luZ1syXSwgMTApO1xuICAgIHJldHVybiBbeCwgeSwgel07XG4gIH1cblxuICBpbWFnZU9yaWVudGF0aW9uKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGludmVydFggPSB0aGlzLl9oZWFkZXIuQW5hdG9taWNhbE9yaWVudGF0aW9uLm1hdGNoKC9MLykgPyAtMSA6IDE7XG4gICAgbGV0IGludmVydFkgPSB0aGlzLl9oZWFkZXIuQW5hdG9taWNhbE9yaWVudGF0aW9uLm1hdGNoKC9QLykgPyAtMSA6IDE7XG5cbiAgICBsZXQgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4WzBdKSAqIGludmVydFgsXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXhbMV0pICogaW52ZXJ0WSxcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeFsyXSkpO1xuICAgIHgubm9ybWFsaXplKCk7XG5cbiAgICBsZXQgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4WzNdKSAqIGludmVydFgsXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXhbNF0pICogaW52ZXJ0WSxcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeFs1XSkpO1xuICAgIHkubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgeC54LCB4LnksIHgueixcbiAgICAgIHkueCwgeS55LCB5LnosXG4gICAgICBdO1xuICB9XG5cbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBbXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5PZmZzZXRbMF0pLFxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuT2Zmc2V0WzFdKSxcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLk9mZnNldFsyXSksXG4gICAgXTtcbiAgfVxuXG4gIG1pbk1heFBpeGVsRGF0YShwaXhlbERhdGEgPSBbXSkge1xuICAgIGxldCBtaW5NYXggPSBbNjU1MzUsIC0zMjc2OF07XG4gICAgbGV0IG51bVBpeGVscyA9IHBpeGVsRGF0YS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVBpeGVsczsgaW5kZXgrKykge1xuICAgICAgbGV0IHNwdiA9IHBpeGVsRGF0YVtpbmRleF07XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHNwdik7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIHNwdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbk1heDtcbiAgfVxuXG4gIGV4dHJhY3RQaXhlbERhdGEoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjb21wcmVzc1VuY29tcHJlc3NlZChmcmFtZUluZGV4KTtcbiAgfVxuXG4gIF9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMubnVtYmVyT2ZDaGFubmVscygpO1xuICAgIGxldCBudW1QaXhlbHMgPVxuICAgICAgdGhpcy5yb3dzKGZyYW1lSW5kZXgpICogdGhpcy5jb2x1bW5zKGZyYW1lSW5kZXgpICogbnVtYmVyT2ZDaGFubmVscztcbiAgICBpZiAoIXRoaXMucmlnaHRIYW5kZWQoKSkge1xuICAgICAgZnJhbWVJbmRleCA9IHRoaXMubnVtYmVyT2ZGcmFtZXMoKSAtIDEgLSBmcmFtZUluZGV4O1xuICAgIH1cbiAgICBsZXQgZnJhbWVPZmZzZXQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xuXG4gICAgaWYgKHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9DSEFSJykge1xuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldDtcbiAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVUNIQVInKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0O1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfU0hPUlQnKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1VTSE9SVCcpIHtcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQgKiAyO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX0ZMT0FUJykge1xuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gdXNlIG5pZnRpLWpzIGFuZCBqdXN0IHBhcnNlIGhlYWRlci4/Pz9cblxuLy8gU2xpY2VyIHdheSB0byBoYW5kbGUgaW1hZ2VzXG4vLyBzaG91bGQgZm9sbG93IGl0Li4uXG4gLy8gODk3ICAgaWYgKCAodGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gIT0gaWR4U2VyaWVzSW5zdGFuY2VVSUQgJiYgdGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gPj0gMCAmJiBpZHhTZXJpZXNJbnN0YW5jZVVJRCA+PSAwKSB8fFxuIC8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XG4gLy8gODk5ICAgICAgICAodGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSAhPSBpZHhUcmlnZ2VyVGltZSAmJiB0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdID49IDAgJiYgaWR4VHJpZ2dlclRpbWUgPj0gMCkgfHxcbiAvLyA5MDAgICAgICAgICh0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdICE9IGlkeEVjaG9OdW1iZXJzICYmIHRoaXMtPkluZGV4RWNob051bWJlcnNba10gPj0gMCAmJiBpZHhFY2hvTnVtYmVycyA+PSAwKSB8fFxuIC8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XG4gLy8gOTAyICAgICAgICAodGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdICE9IGlkeFNsaWNlTG9jYXRpb24gJiYgdGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdID49IDAgJiYgaWR4U2xpY2VMb2NhdGlvbiA+PSAwKSB8fFxuIC8vIDkwMyAgICAgICAgKHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gIT0gaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgJiYgdGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSA+PSAwICYmIGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ID49IDApIClcbiAvLyA5MDQgICAgIHtcbiAvLyA5MDUgICAgICAgY29udGludWU7XG4gLy8gOTA2ICAgICB9XG5cbi8vIGh0dHA6Ly9icmFpbmRlci5vcmcvMjAxMi8wOS8yMy90aGUtbmlmdGktZmlsZS1mb3JtYXQvXG5cbi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XG5cbmxldCBOaWZ0aVJlYWRlciA9IHJlcXVpcmUoJ25pZnRpLXJlYWRlci1qcycpO1xuLyoqXG4gKiBAbW9kdWxlIHBhcnNlcnMvbmlmdGlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc05pZnRpIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAgKiBAbWVtYmVyXG4gICAgICAqIEB0eXBlIHthcnJheWJ1ZmZlcn1cbiAgICAqL1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5fYXJyYXlCdWZmZXIgPSBkYXRhLmJ1ZmZlcjtcbiAgICB0aGlzLl91cmwgPSBkYXRhLnVybDtcbiAgICB0aGlzLl9kYXRhU2V0ID0gbnVsbDtcbiAgICB0aGlzLl9uaWZ0aUhlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbmlmdGlJbWFnZSA9IG51bGw7XG4gICAgdGhpcy5fb3JkZXJlZCA9IHRydWU7XG4gICAgdGhpcy5fb3JkZXJlZERhdGEgPSBudWxsO1xuXG4gICAgLy9cbiAgICB0aGlzLl9xZmFjID0gMS4wO1xuXG4gICAgaWYgKE5pZnRpUmVhZGVyLmlzTklGVEkodGhpcy5fYXJyYXlCdWZmZXIpKSB7XG4gICAgICB0aGlzLl9kYXRhU2V0ID0gTmlmdGlSZWFkZXIucmVhZEhlYWRlcih0aGlzLl9hcnJheUJ1ZmZlcik7XG4gICAgICB0aGlzLl9uaWZ0aUltYWdlID1cbiAgICAgICAgTmlmdGlSZWFkZXIucmVhZEltYWdlKHRoaXMuX2RhdGFTZXQsIHRoaXMuX2FycmF5QnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ3BhcnNlcnMubmlmdGkgY291bGQgbm90IHBhcnNlIHRoZSBmaWxlJztcbiAgICB9XG4gIH1cblxuICBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcbiAgICAvLyB1c2UgZmlsZW5hbWUgKyB0aW1lc3RhbXAuLj9cbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgbnVtYmVyT2ZGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuZGltc1szXTtcbiAgfVxuXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSAxO1xuXG4gICAgLy8gY2FuIGRpbXNbMF0gPj0gNSBhbmQgbm90IG11bHRpIGNoYW5uZWxzIHdpdGggUkdCIGRhdGF0eXBlY29kZT9cblxuICAgIGlmICh0aGlzLl9kYXRhU2V0LmRpbXNbMF0gPj0gNSkge1xuICAgICAgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMuX2RhdGFTZXQuZGltc1s1XTtcbiAgICAgIHRoaXMuX29yZGVyZWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAxMjgpIHtcbiAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSAzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDIzMDQpIHtcbiAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSA0O1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXJPZkNoYW5uZWxzO1xuICB9XG5cbiAgc29wSW5zdGFuY2VVSUQoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcbiAgfVxuXG4gIHJvd3MoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5kaW1zWzJdO1xuICB9XG5cbiAgY29sdW1ucyhmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LmRpbXNbMV07XG4gIH1cblxuICBwaXhlbFR5cGUoZnJhbWVJbmRleCA9IDApIHtcbiAgICAgICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQ4ICAgICAgICAgICA9IDI7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDE2ICAgICAgICAgICA9IDQ7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDMyICAgICAgICAgICA9IDg7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUMzIgICAgICAgID0gMTY7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVg2NCAgICAgID0gMzI7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUNjQgICAgICAgID0gNjQ7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1JHQjI0ICAgICAgICAgPSAxMjg7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDggICAgICAgICAgPSAyNTY7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQxNiAgICAgICAgPSA1MTI7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQzMiAgICAgICAgPSA3Njg7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDY0ICAgICAgICA9IDEwMjQ7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQ2NCAgICAgICA9IDEyODA7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUMTI4ICAgICA9IDE1MzY7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVgxMjggICA9IDE3OTI7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVgyNTYgICA9IDIwNDg7XG5cbiAgICAvLyAwIGludGVnZXIsIDEgZmxvYXRcblxuICAgIGxldCBwaXhlbFR5cGUgPSAwO1xuICAgIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMTYgfHxcbiAgICAgIHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA2NCB8fFxuICAgICAgdGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDE1MzYpIHtcbiAgICAgIHBpeGVsVHlwZSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBwaXhlbFR5cGU7XG4gIH1cblxuICBiaXRzQWxsb2NhdGVkKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQubnVtQml0c1BlclZveGVsO1xuICB9XG5cbiAgcGl4ZWxTcGFjaW5nKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuX2RhdGFTZXQucGl4RGltc1sxXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQucGl4RGltc1syXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQucGl4RGltc1szXSxcbiAgICAgIF07XG4gIH1cblxuICBzbGljZVRoaWNrbmVzcygpIHtcbiAgICAvLyBzaG91bGQgYmUgYSBzdHJpbmcuLi5cbiAgICByZXR1cm4gbnVsbDsvLyB0aGlzLl9kYXRhU2V0LnBpeERpbXNbM10udG9TdHJpbmcoKTtcbiAgfVxuXG4gIGltYWdlT3JpZW50YXRpb24oZnJhbWVJbmRleCA9IDApIHtcbiAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZGF0YVNldCk7XG4gICAgLy8gaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxLmhcbiAgICAvLyBodHRwOi8vbmlmdGkubmltaC5uaWguZ292L3B1Yi9kaXN0L3NyYy9uaWZ0aWxpYi9uaWZ0aTFfaW8uY1xuICAgIGlmICh0aGlzLl9kYXRhU2V0LnFmb3JtX2NvZGUgPiAwKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vS2l0d2FyZS9JVEsvYmxvYi9tYXN0ZXIvTW9kdWxlcy9JTy9OSUZUSS9zcmMvaXRrTmlmdGlJbWFnZUlPLmN4eFxuICAgICAgbGV0IGEgPSAwLjA7XG4gICAgICBsZXQgYiA9IHRoaXMuX2RhdGFTZXQucXVhdGVybl9iO1xuICAgICAgbGV0IGMgPSB0aGlzLl9kYXRhU2V0LnF1YXRlcm5fYztcbiAgICAgIGxldCBkID0gdGhpcy5fZGF0YVNldC5xdWF0ZXJuX2Q7XG4gICAgICAvLyBjb21wdXRlIGFcbiAgICAgIGEgPSAxLjAgLSAoYipiICsgYypjICsgZCpkKTtcbiAgICAgIGlmIChhIDwgMC4wMDAwMDAxKSB7XG4gICAgICAgICAgICAgICAgICAgLyogc3BlY2lhbCBjYXNlICovXG5cbiAgICAgICAgYSA9IDEuMCAvIE1hdGguc3FydChiKmIrYypjK2QqZCk7XG4gICAgICAgIGIgKj0gYTsgYyAqPSBhOyBkICo9IGE7ICAgICAgICAvKiBub3JtYWxpemUgKGIsYyxkKSB2ZWN0b3IgKi9cbiAgICAgICAgYSA9IDAuMDsgICAgICAgICAgICAgICAgICAgICAgIC8qIGEgPSAwID09PiAxODAgZGVncmVlIHJvdGF0aW9uICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gTWF0aC5zcXJ0KGEpOyAgICAgICAgICAgICAgICAgICAgIC8qIGFuZ2xlID0gMiphcmNjb3MoYSkgKi9cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2RhdGFTZXQucGl4RGltc1swXSA8IDAuMCkge1xuICAgICAgICB0aGlzLl9yaWdodEhhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAtKGEqYStiKmItYypjLWQqZCksXG4gICAgICAgICAgLTIqKGIqYythKmQpLFxuICAgICAgICAgIDIqKGIqZC1hKmMpLFxuICAgICAgICAgIC0yKihiKmMtYSpkKSxcbiAgICAgICAgICAtKGEqYStjKmMtYipiLWQqZCksXG4gICAgICAgICAgMiooYypkK2EqYiksXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LnNmb3JtX2NvZGUgPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnc2Zvcm0gPiAwJyk7XG5cbiAgICAgIGxldCBzeCA9IHRoaXMuX2RhdGFTZXQuc3Jvd194O1xuICAgICAgbGV0IHN5ID0gdGhpcy5fZGF0YVNldC5zcm93X3k7XG4gICAgICBsZXQgc3ogPSB0aGlzLl9kYXRhU2V0LnNyb3dfejtcbiAgICAgIC8vIGZpbGwgSUpLVG9SQVNcbiAgICAgIC8vIGdvb2cudmVjLk1hdDQuc2V0Um93VmFsdWVzKElKS1RvUkFTLCAwLCBzeFswXSwgc3hbMV0sIHN4WzJdLCBzeFszXSk7XG4gICAgICAvLyBnb29nLnZlYy5NYXQ0LnNldFJvd1ZhbHVlcyhJSktUb1JBUywgMSwgc3lbMF0sIHN5WzFdLCBzeVsyXSwgc3lbM10pO1xuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDIsIHN6WzBdLCBzelsxXSwgc3pbMl0sIHN6WzNdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQucWZvcm1fY29kZSA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ3Fmb3JtID09PSAwJyk7XG5cblxuICAgICAgLy8gZmlsbCBJSktUb1JBU1xuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDAsIE1SSS5waXhkaW1bMV0sIDAsIDAsIDApO1xuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDEsIDAsIE1SSS5waXhkaW1bMl0sIDAsIDApO1xuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDIsIDAsIDAsIE1SSS5waXhkaW1bM10sIDApO1xuICAgIH1cbiAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDEsIDBdO1xuICB9XG5cbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIHFvZmZzZXQgaXMgUkFTXG4gICAgcmV0dXJuIFtcbiAgICAgIC10aGlzLl9kYXRhU2V0LnFvZmZzZXRfeCxcbiAgICAgIC10aGlzLl9kYXRhU2V0LnFvZmZzZXRfeSxcbiAgICAgIHRoaXMuX2RhdGFTZXQucW9mZnNldF96LFxuICAgIF07XG4gIH1cblxuICBkaW1lbnNpb25JbmRleFZhbHVlcyhmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaW5zdGFuY2VOdW1iZXIoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcbiAgfVxuXG4gIHdpbmRvd0NlbnRlcihmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGNhbGMgbWluIGFuZCBjYWxjIG1heFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgd2luZG93V2lkdGgoZnJhbWVJbmRleCA9IDApIHtcbiAgICAvLyBjYWxjIG1pbiBhbmQgY2FsYyBtYXhcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJlc2NhbGVTbG9wZShmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnNjbF9zbG9wZTtcbiAgfVxuXG4gIHJlc2NhbGVJbnRlcmNlcHQoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zY2xfaW50ZXJjZXB0O1xuICB9XG5cbiAgbWluTWF4UGl4ZWxEYXRhKHBpeGVsRGF0YSA9IFtdKSB7XG4gICAgbGV0IG1pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcbiAgICBsZXQgbnVtUGl4ZWxzID0gcGl4ZWxEYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtUGl4ZWxzOyBpbmRleCsrKSB7XG4gICAgICBsZXQgc3B2ID0gcGl4ZWxEYXRhW2luZGV4XTtcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgc3B2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluTWF4O1xuICB9XG5cbiAgZXh0cmFjdFBpeGVsRGF0YShmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXgpO1xuICAgIC8vIGxldCBidWZmZXIgPSB0aGlzLl9kYXRhU2V0LmltYWdlRGF0YTtcbiAgICAvLyBpZiAodGhpcy5fZGF0YVNldC5jb21wcmVzc2VkKSB7XG4gICAgLy8gbGV0IGJ1ZmZlciA9IHRoaXMuX2RhdGFTZXQucmF3RGF0YVswXTtcbiAgICAvLyB0cnkge1xuICAgIC8vICAgbGV0IGRhdGEgPSBwYWtvLmluZmxhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgLy8gICBidWZmZXIgPSBkYXRhLmJ1ZmZlcjtcbiAgICAvLyB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgLy8gfVxuXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGJ1ZmZlcik7XG4gICAgLy8gfVxuXG4gICAgLy8gaXMgaXQgY29tcHJlc3NlZD9cbiAgICAvLyB5ZXMvbm9cblxuICAgIC8vICAgICB0cnkge1xuICAgIC8vICAgdmFyIHJlc3VsdCA9IHBha28uaW5mbGF0ZShjb21wcmVzc2VkKTtcbiAgICAvLyB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgLy8gfVxuXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMpO1xuICB9XG5cbiAgX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoZnJhbWVJbmRleCA9IDApIHtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDggICAgICAgICAgID0gMjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UMTYgICAgICAgICAgID0gNDtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UMzIgICAgICAgICAgID0gODtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQzMiAgICAgICAgPSAxNjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDY0ICAgICAgPSAzMjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQ2NCAgICAgICAgPSA2NDtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfUkdCMjQgICAgICAgICA9IDEyODtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UOCAgICAgICAgICA9IDI1NjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDE2ICAgICAgICA9IDUxMjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDMyICAgICAgICA9IDc2ODtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UNjQgICAgICAgID0gMTAyNDtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDY0ICAgICAgID0gMTI4MDtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQxMjggICAgID0gMTUzNjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDEyOCAgID0gMTc5MjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDI1NiAgID0gMjA0ODtcblxuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKCk7XG4gICAgbGV0IG51bVBpeGVscyA9XG4gICAgICB0aGlzLnJvd3MoZnJhbWVJbmRleCkgKiB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCkgKiBudW1iZXJPZkNoYW5uZWxzO1xuICAgIC8vIGlmKCAhdGhpcy5yaWdodEhhbmRlZCgpICl7XG4gICAgLy8gICBmcmFtZUluZGV4ID0gdGhpcy5udW1iZXJPZkZyYW1lcygpIC0gMSAtIGZyYW1lSW5kZXg7XG4gICAgLy8gfVxuICAgIGxldCBmcmFtZU9mZnNldCA9IGZyYW1lSW5kZXggKiBudW1QaXhlbHM7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX25pZnRpSW1hZ2U7XG5cbiAgICAvLyB1c2UgYml0cyBhbGxvY2F0ZWQgJiYgcGl4ZWwgcmVwcmVuc2VudGF0aW9uIHRvb1xuICAgIGlmICghdGhpcy5fb3JkZXJlZCAmJiB0aGlzLl9vcmRlcmVkRGF0YSA9PT0gbnVsbCkge1xuICAgICAgLy8gb3JkZXIgdGhlblxuICAgICAgdGhpcy5fcmVvcmRlckRhdGEoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3JkZXJlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIC8vIGp1c3QgYSBzbGljZS4uLlxuICAgICAgcmV0dXJuIHRoaXMuX29yZGVyZWREYXRhLnNsaWNlKGZyYW1lT2Zmc2V0LCBmcmFtZU9mZnNldCArIG51bVBpeGVscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMikge1xuICAgICAgLy8gdW5zaWduZWQgaW50IDggYml0XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAyNTYpIHtcbiAgICAgIC8vIHNpZ25lZCBpbnQgOCBiaXRcbiAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gNTEyKSB7XG4gICAgICAvLyB1bnNpZ25lZCBpbnQgMTYgYml0XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcbiAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA0KSB7XG4gICAgICAvLyBzaWduZWQgaW50IDE2IGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDI7XG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA4KSB7XG4gICAgICAvLyBzaWduZWQgaW50IDMyIGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAxNikge1xuICAgICAgLy8gc2lnbmVkIGZsb2F0IDMyIGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYFVua25vd24gZGF0YSB0eXBlOiBkYXRhdHlwZUNvZGUgOiAke3RoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlfWApO1xuICAgIH1cbiAgfVxuXG4gIF9yZW9yZGVyRGF0YSgpIHtcbiAgICB3aW5kb3cuY29uc29sZS5sb2coJ3JlLW9yZGVyJyk7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcbiAgICBsZXQgbnVtUGl4ZWxzID0gdGhpcy5yb3dzKCkgKiB0aGlzLmNvbHVtbnMoKSAqIG51bWJlck9mQ2hhbm5lbHM7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX25pZnRpSW1hZ2U7XG5cbiAgICBsZXQgdG90YWxOdW1QaXhlbHMgPSBudW1QaXhlbHMgKiB0aGlzLm51bWJlck9mRnJhbWVzKCk7XG4gICAgbGV0IHRtcCA9IG51bGw7XG4gICAgdGhpcy5fb3JkZXJlZERhdGEgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAyKSB7XG4gICAgICAvLyB1bnNpZ25lZCA4IGJpdFxuICAgICAgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG5ldyBVaW50OEFycmF5KHRtcC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDI1Nikge1xuICAgICAgLy8gc2lnbmVkIDggYml0XG4gICAgICB0bXAgPSBuZXcgSW50OEFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xuICAgICAgdGhpcy5fb3JkZXJlZERhdGEgPSBuZXcgSW50OEFycmF5KHRtcC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDUxMikge1xuICAgICAgdG1wID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xuICAgICAgdGhpcy5fb3JkZXJlZERhdGEgPSBuZXcgVWludDE2QXJyYXkodG1wLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gNCkge1xuICAgICAgdG1wID0gbmV3IEludDE2QXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG5ldyBJbnQxNkFycmF5KHRtcC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDE2KSB7XG4gICAgICB0bXAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xuICAgICAgdGhpcy5fb3JkZXJlZERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRtcC5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIHJlLW9yZGVyIHBpeGVscy4uLlxuICAgIGxldCBudW1QaXhlbHMyID0gdG1wLmxlbmd0aCAvIDM7XG4gICAgbGV0IHJnYmFJbmRleCA9IDA7XG4gICAgbGV0IHJJbmRleCA9IDA7XG4gICAgbGV0IGdJbmRleCA9IG51bVBpeGVsczI7XG4gICAgbGV0IGJJbmRleCA9IG51bVBpeGVsczIgKiAyO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QaXhlbHMyOyBpKyspIHtcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhW3JnYmFJbmRleCsrXSA9IHRtcFtySW5kZXgrK107IC8vIHJlZFxuICAgICAgdGhpcy5fb3JkZXJlZERhdGFbcmdiYUluZGV4KytdID0gdG1wW2dJbmRleCsrXTsgLy8gZ3JlZW5cbiAgICAgIHRoaXMuX29yZGVyZWREYXRhW3JnYmFJbmRleCsrXSA9IHRtcFtiSW5kZXgrK107IC8vIGJsdWVcbiAgICB9XG5cbiAgICB0aGlzLl9vcmRlcmVkID0gdHJ1ZTtcbiAgfVxufVxuIiwiLy8gdXNlIG5pZnRpLWpzIGFuZCBqdXN0IHBhcnNlIGhlYWRlci4/Pz9cblxuLy8gU2xpY2VyIHdheSB0byBoYW5kbGUgaW1hZ2VzXG4vLyBzaG91bGQgZm9sbG93IGl0Li4uXG4gLy8gODk3ICAgaWYgKCAodGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gIT0gaWR4U2VyaWVzSW5zdGFuY2VVSUQgJiYgdGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gPj0gMCAmJiBpZHhTZXJpZXNJbnN0YW5jZVVJRCA+PSAwKSB8fFxuIC8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XG4gLy8gODk5ICAgICAgICAodGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSAhPSBpZHhUcmlnZ2VyVGltZSAmJiB0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdID49IDAgJiYgaWR4VHJpZ2dlclRpbWUgPj0gMCkgfHxcbiAvLyA5MDAgICAgICAgICh0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdICE9IGlkeEVjaG9OdW1iZXJzICYmIHRoaXMtPkluZGV4RWNob051bWJlcnNba10gPj0gMCAmJiBpZHhFY2hvTnVtYmVycyA+PSAwKSB8fFxuIC8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XG4gLy8gOTAyICAgICAgICAodGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdICE9IGlkeFNsaWNlTG9jYXRpb24gJiYgdGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdID49IDAgJiYgaWR4U2xpY2VMb2NhdGlvbiA+PSAwKSB8fFxuIC8vIDkwMyAgICAgICAgKHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gIT0gaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgJiYgdGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSA+PSAwICYmIGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ID49IDApIClcbiAvLyA5MDQgICAgIHtcbiAvLyA5MDUgICAgICAgY29udGludWU7XG4gLy8gOTA2ICAgICB9XG5cbi8vIGh0dHA6Ly9icmFpbmRlci5vcmcvMjAxMi8wOS8yMy90aGUtbmlmdGktZmlsZS1mb3JtYXQvXG5cbi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XG5cbmxldCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xubGV0IE5ycmRSZWFkZXIgPSByZXF1aXJlKCducnJkLWpzJyk7XG4vKipcbiAqIEBtb2R1bGUgcGFyc2Vycy9uaWZ0aVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzTmlmdGkgZXh0ZW5kcyBQYXJzZXJzVm9sdW1lIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICAqIEBtZW1iZXJcbiAgICAgICogQHR5cGUge2FycmF5YnVmZmVyfVxuICAgICovXG4gICAgdGhpcy5faWQgPSBpZDtcbiAgICB0aGlzLl9hcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xuICAgIHRoaXMuX3VybCA9IGRhdGEudXJsO1xuICAgIHRoaXMuX2RhdGFTZXQgPSBudWxsO1xuICAgIHRoaXMuX3VucGFja2VkRGF0YSA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fZGF0YVNldCA9IE5ycmRSZWFkZXIucGFyc2UodGhpcy5fYXJyYXlCdWZmZXIpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5fZGF0YVNldCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnb29vcHMuLi4gOignKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZGF0YVNldCk7XG4gIH1cblxuICByaWdodEhhbmRlZCgpIHtcbiAgICBpZiAodGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvXnJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yLykgfHxcbiAgICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvXmxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yLykpIHtcbiAgICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yaWdodEhhbmRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yaWdodEhhbmRlZDtcbiAgfVxuXG4gIHNlcmllc0luc3RhbmNlVUlEKCkge1xuICAgIC8vIHVzZSBmaWxlbmFtZSArIHRpbWVzdGFtcC4uP1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICBudW1iZXJPZkZyYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zaXplc1syXTtcbiAgfVxuXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSAxO1xuICAgIHJldHVybiBudW1iZXJPZkNoYW5uZWxzO1xuICB9XG5cbiAgc29wSW5zdGFuY2VVSUQoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcbiAgfVxuXG4gIHJvd3MoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zaXplc1sxXTtcbiAgfVxuXG4gIGNvbHVtbnMoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zaXplc1swXTtcbiAgfVxuXG4gIHBpeGVsVHlwZShmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIDAgLSBpbnRcbiAgICAvLyAxIC0gZmxvYXRcbiAgICBsZXQgcGl4ZWxUeXBlID0gMDtcbiAgICBpZiAodGhpcy5fZGF0YVNldC50eXBlID09PSAnZmxvYXQnKSB7XG4gICAgICBwaXhlbFR5cGUgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxUeXBlO1xuICB9XG5cbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gMTtcblxuICAgIGlmICh0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdpbnQ4JyB8fFxuICAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQ4JyB8fFxuICAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2NoYXInKSB7XG4gICAgICBiaXRzQWxsb2NhdGVkID0gODtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2ludDE2JyB8fFxuICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAndWludDE2JyB8fFxuICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnc2hvcnQnKSB7XG4gICAgICBiaXRzQWxsb2NhdGVkID0gMTY7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdpbnQzMicgfHxcbiAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQzMicgfHxcbiAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgYml0c0FsbG9jYXRlZCA9IDMyO1xuICAgIH1cblxuICAgIHJldHVybiBiaXRzQWxsb2NhdGVkO1xuICB9XG5cbiAgcGl4ZWxTcGFjaW5nKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IHggPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzBdWzBdLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMV0sXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1swXVsyXSk7XG5cbiAgICBsZXQgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMF0sXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1sxXVsxXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzFdWzJdKTtcblxuICAgIGxldCB6ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1syXVswXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzJdWzFdLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMl1bMl0pO1xuXG4gICAgcmV0dXJuIFt4Lmxlbmd0aCgpLCB5Lmxlbmd0aCgpLCB6Lmxlbmd0aCgpXTtcbiAgfVxuXG4gIHNsaWNlVGhpY2tuZXNzKCkge1xuICAgIC8vIHNob3VsZCBiZSBhIHN0cmluZy4uLlxuICAgIHJldHVybiBudWxsOy8vIHRoaXMuX2RhdGFTZXQucGl4RGltc1szXS50b1N0cmluZygpO1xuICB9XG5cbiAgaW1hZ2VPcmllbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBpbnZlcnRYID0gdGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvcmlnaHQvKSA/IC0xIDogMTtcbiAgICBsZXQgaW52ZXJ0WSA9IHRoaXMuX2RhdGFTZXQuc3BhY2UubWF0Y2goL2FudGVyaW9yLykgPyAtMSA6IDE7XG5cbiAgICBsZXQgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMF0gKiBpbnZlcnRYLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMV0gKiBpbnZlcnRZLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMl0pO1xuICAgIHgubm9ybWFsaXplKCk7XG5cbiAgICBsZXQgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMF0gKiBpbnZlcnRYLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMV0gKiBpbnZlcnRZLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMl0pO1xuICAgIHkubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgeC54LCB4LnksIHgueixcbiAgICAgIHkueCwgeS55LCB5LnosXG4gICAgICBdO1xuICB9XG5cbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlT3JpZ2luWzBdLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZU9yaWdpblsxXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VPcmlnaW5bMl0sXG4gICAgXTtcbiAgfVxuXG4gIGRpbWVuc2lvbkluZGV4VmFsdWVzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpbnN0YW5jZU51bWJlcihmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBmcmFtZUluZGV4O1xuICB9XG5cbiAgd2luZG93Q2VudGVyKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgLy8gY2FsYyBtaW4gYW5kIGNhbGMgbWF4XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB3aW5kb3dXaWR0aChmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGNhbGMgbWluIGFuZCBjYWxjIG1heFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVzY2FsZVNsb3BlKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIDE7Ly8gdGhpcy5fZGF0YVNldC5zY2xfc2xvcGU7XG4gIH1cblxuICByZXNjYWxlSW50ZXJjZXB0KGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIDA7Ly8gdGhpcy5fZGF0YVNldC5zY2xfaW50ZXJjZXB0O1xuICB9XG5cbiAgbWluTWF4UGl4ZWxEYXRhKHBpeGVsRGF0YSA9IFtdKSB7XG4gICAgbGV0IG1pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcbiAgICBsZXQgbnVtUGl4ZWxzID0gcGl4ZWxEYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtUGl4ZWxzOyBpbmRleCsrKSB7XG4gICAgICBsZXQgc3B2ID0gcGl4ZWxEYXRhW2luZGV4XTtcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgc3B2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluTWF4O1xuICB9XG5cbiAgZXh0cmFjdFBpeGVsRGF0YShmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXgpO1xuICB9XG5cbiAgX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5fZGF0YVNldC5idWZmZXI7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcbiAgICBsZXQgbnVtUGl4ZWxzID0gdGhpcy5yb3dzKGZyYW1lSW5kZXgpICogdGhpcy5jb2x1bW5zKGZyYW1lSW5kZXgpICogbnVtYmVyT2ZDaGFubmVscztcbiAgICBpZiAoIXRoaXMucmlnaHRIYW5kZWQoKSkge1xuICAgICAgZnJhbWVJbmRleCA9IHRoaXMubnVtYmVyT2ZGcmFtZXMoKSAtIDEgLSBmcmFtZUluZGV4O1xuICAgIH1cbiAgICBsZXQgZnJhbWVPZmZzZXQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xuXG4gICAgLy8gdW5wYWNrIGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMuX3VucGFja2VkRGF0YSA9PT0gbnVsbCAmJlxuICAgICAgdGhpcy5fZGF0YVNldC5lbmNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICBsZXQgdW5wYWNrZWREYXRhID0gcGFrby5pbmZsYXRlKHRoaXMuX2RhdGFTZXQuYnVmZmVyKTtcbiAgICAgIHRoaXMuX3VucGFja2VkRGF0YSA9IHVucGFja2VkRGF0YS5idWZmZXI7XG4gICAgICBidWZmZXIgPSB0aGlzLl91bnBhY2tlZERhdGE7XG4gICAgfSBlbHNlIGlmKHRoaXMuX2RhdGFTZXQuZW5jb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgYnVmZmVyID0gdGhpcy5fdW5wYWNrZWREYXRhO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2ludDgnIHx8XG4gICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnY2hhcicpIHtcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQ7XG4gICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50OCcpIHtcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQ7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAnaW50MTYnIHx8XG4gICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnc2hvcnQnKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50MTYnKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcbiAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAnaW50MzInKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50MzInKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAnZmxvYXQnKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgcGFyc2Vycy92b2x1bWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc1ZvbHVtZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xuICB9XG5cbiAgcGl4ZWxSZXByZXNlbnRhdGlvbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIG1vZGFsaXR5KCkge1xuICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cblxuICBzZWdtZW50YXRpb25UeXBlKCkge1xuICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cblxuICBzZWdtZW50YXRpb25TZWdtZW50cygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZWZlcmVuY2VkU2VnbWVudE51bWJlcihmcmFtZUluZGV4KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmlnaHRIYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0SGFuZGVkO1xuICB9XG5cbiAgc3BhY2luZ0JldHdlZW5TbGljZXMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBudW1iZXJPZkNoYW5uZWxzKCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgc2xpY2VUaGlja25lc3MoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIGRpbWVuc2lvbkluZGV4VmFsdWVzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpbnN0YW5jZU51bWJlcihmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBmcmFtZUluZGV4O1xuICB9XG5cbiAgd2luZG93Q2VudGVyKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB3aW5kb3dXaWR0aChmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVzY2FsZVNsb3BlKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXNjYWxlSW50ZXJjZXB0KGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBfZGVjb21wcmVzc1VuY29tcHJlc3NlZCgpIHtcblxuICB9XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MzIwNDM5L2hvdy1kby1pLXN3YXAtZW5kaWFuLW5lc3MtYnl0ZS1vcmRlci1vZi1hLXZhcmlhYmxlLWluLWphdmFzY3JpcHRcbiAgX3N3YXAxNih2YWwpIHtcbiAgICByZXR1cm4gKCh2YWwgJiAweEZGKSA8PCA4KVxuICAgICAgfCAoKHZhbCA+PiA4KSAmIDB4RkYpO1xuICB9XG5cbiAgX3N3YXAzMih2YWwpIHtcbiAgICByZXR1cm4gKCh2YWwgJiAweEZGKSA8PCAyNClcbiAgICAgICAgICAgfCAoKHZhbCAmIDB4RkYwMCkgPDwgOClcbiAgICAgICAgICAgfCAoKHZhbCA+PiA4KSAmIDB4RkYwMClcbiAgICAgICAgICAgfCAoKHZhbCA+PiAyNCkgJiAweEZGKTtcbiAgfVxuXG4gIGludmVydCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmFuc2ZlciBzeW50YXggVUlELlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdHJhbnNmZXJTeW50YXhVSUQoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHVkeSBkZXNjaXB0aW9uLlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3R1ZHlEZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ25vIHZhbHVlIHByb3ZpZGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlcmllcyBkZXNjaXB0aW9uLlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc2VyaWVzRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRpZW50IElELlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcGF0aWVudElEKCkge1xuICAgIHJldHVybiAnbm8gdmFsdWUgcHJvdmlkZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGF0aWVudCBuYW1lLlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcGF0aWVudE5hbWUoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRpZW50IGFnZS5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnRBZ2UoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRpZW50IGJpcnRoZGF0ZS5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnRCaXJ0aGRhdGUoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRpZW50IHNleC5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnRTZXgoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cbn1cbiIsImltcG9ydCBTaGFkZXJzQmFzZSBmcm9tICcuLi9zaGFkZXJzLmJhc2UnO1xuXG5jbGFzcyBJbnRlcnNlY3RCb3ggZXh0ZW5kcyBTaGFkZXJzQmFzZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSAnaW50ZXJzZWN0Qm94JztcblxuICAgIC8vIGRlZmF1bHQgcHJvcGVydGllcyBuYW1lc1xuICAgIHRoaXMuX3JheU9yaWdpbiA9ICdyYXlPcmlnaW4nO1xuICAgIHRoaXMuX3JheURpcmVjdGlvbiA9ICdyYXlEaXJlY3Rpb24nO1xuICAgIHRoaXMuX2FhYmJNaW4gPSAnYWFiYk1pbic7XG4gICAgdGhpcy5fYWFiYk1heCA9ICdhYWJiTWF4JztcbiAgICB0aGlzLl90TmVhciA9ICd0TmVhcic7XG4gICAgdGhpcy5fdEZhciA9ICd0RmFyJztcbiAgICB0aGlzLl9pbnRlcnNlY3QgPSAnaW50ZXJzZWN0JztcbiAgfVxuXG4gIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLFxuICAgICAgIHJheU9yaWdpbiA9IHRoaXMuX3JheU9yaWdpbiwgcmF5RGlyZWN0aW9uID0gdGhpcy5fcmF5RGlyZWN0aW9uLFxuICAgICAgIGFhYmJNaW4gPSB0aGlzLl9hYWJiTWluLCBhYWJiTWF4ID0gdGhpcy5fYWFiYk1heCxcbiAgICAgICB0TmVhciA9IHRoaXMuX3ROZWFyLCB0RmFyID0gdGhpcy5fdEZhcixcbiAgICAgICBpbnRlcnNlY3QgPSB0aGlzLl9pbnRlcnNlY3QpIHtcbiAgICB0aGlzLl9iYXNlID0gYmFzZUZyYWdtZW50O1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGUocmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIGFhYmJNaW4sIGFhYmJNYXgsIHROZWFyLCB0RmFyLCBpbnRlcnNlY3QpO1xuICB9XG5cbiAgY29tcHV0ZShyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgYWFiYk1pbiwgYWFiYk1heCwgdE5lYXIsIHRGYXIsIGludGVyc2VjdCkge1xuICAgIHRoaXMuY29tcHV0ZURlZmluaXRpb24oKTtcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke3JheU9yaWdpbn0sICR7cmF5RGlyZWN0aW9ufSwgJHthYWJiTWlufSwgJHthYWJiTWF4fSwgJHt0TmVhcn0sICR7dEZhcn0sICR7aW50ZXJzZWN0fSk7YDtcbiAgfVxuXG5cbiAgY29tcHV0ZURlZmluaXRpb24oKSB7XG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcbnZvaWQgJHt0aGlzLl9uYW1lfSh2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIHZlYzMgYm94TWluLCB2ZWMzIGJveE1heCwgb3V0IGZsb2F0IHROZWFyLCBvdXQgZmxvYXQgdEZhciwgb3V0IGJvb2wgaW50ZXJzZWN0KXtcbiAgLy8gY29tcHV0ZSBpbnRlcnNlY3Rpb24gb2YgcmF5IHdpdGggYWxsIHNpeCBiYm94IHBsYW5lc1xuICB2ZWMzIGludlJheSA9IHZlYzMoMS4pIC8gcmF5RGlyZWN0aW9uO1xuICB2ZWMzIHRCb3QgPSBpbnZSYXkgKiAoYm94TWluIC0gcmF5T3JpZ2luKTtcbiAgdmVjMyB0VG9wID0gaW52UmF5ICogKGJveE1heCAtIHJheU9yaWdpbik7XG4gIC8vIHJlLW9yZGVyIGludGVyc2VjdGlvbnMgdG8gZmluZCBzbWFsbGVzdCBhbmQgbGFyZ2VzdCBvbiBlYWNoIGF4aXNcbiAgdmVjMyB0TWluID0gbWluKHRUb3AsIHRCb3QpO1xuICB2ZWMzIHRNYXggPSBtYXgodFRvcCwgdEJvdCk7XG4gIC8vIGZpbmQgdGhlIGxhcmdlc3QgdE1pbiBhbmQgdGhlIHNtYWxsZXN0IHRNYXhcbiAgZmxvYXQgbGFyZ2VzdF90TWluID0gbWF4KG1heCh0TWluLngsIHRNaW4ueSksIG1heCh0TWluLngsIHRNaW4ueikpO1xuICBmbG9hdCBzbWFsbGVzdF90TWF4ID0gbWluKG1pbih0TWF4LngsIHRNYXgueSksIG1pbih0TWF4LngsIHRNYXgueikpO1xuICB0TmVhciA9IGxhcmdlc3RfdE1pbjtcbiAgdEZhciA9IHNtYWxsZXN0X3RNYXg7XG4gIGludGVyc2VjdCA9IHNtYWxsZXN0X3RNYXggPiBsYXJnZXN0X3RNaW47XG59XG5cbiAgICBgO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IEludGVyc2VjdEJveCgpO1xuIiwiaW1wb3J0IFNoYWRlcnNCYXNlIGZyb20gJy4uL3NoYWRlcnMuYmFzZSc7XG5cbmNsYXNzIFRleHR1cmUzZCBleHRlbmRzIFNoYWRlcnNCYXNlIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9ICd0ZXh0dXJlM2QnO1xuXG4gICAgLy8gZGVmYXVsdCBwcm9wZXJ0aWVzIG5hbWVzXG4gICAgdGhpcy5fZGF0YUNvb3JkaW5hdGVzID0gJ2RhdGFDb29yZGluYXRlcyc7XG4gICAgdGhpcy5fZGF0YVZhbHVlID0gJ2RhdGFWYWx1ZSc7XG4gICAgdGhpcy5fb2Zmc2V0ID0gJ29mZnNldCc7XG4gIH1cblxuICAgIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLCBkYXRhQ29vcmRpbmF0ZXMgPSB0aGlzLl9kYXRhQ29vcmRpbmF0ZXMsIGRhdGFWYWx1ZSA9IHRoaXMuX2RhdGFWYWx1ZSwgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KSB7XG4gICAgdGhpcy5fYmFzZSA9IGJhc2VGcmFnbWVudDtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlKGRhdGFDb29yZGluYXRlcywgZGF0YVZhbHVlLCBvZmZzZXQpO1xuICB9XG5cbiAgY29tcHV0ZShkYXRhQ29vcmRpbmF0ZXMsIGRhdGFWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5jb21wdXRlRGVmaW5pdGlvbigpO1xuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1t0aGlzLl9uYW1lXSA9IHRoaXMuX2RlZmluaXRpb247XG4gICAgcmV0dXJuIGAke3RoaXMuX25hbWV9KCR7ZGF0YUNvb3JkaW5hdGVzfSwgJHtkYXRhVmFsdWV9LCAke29mZnNldH0pO2A7XG4gIH1cblxuXG4gIGNvbXB1dGVEZWZpbml0aW9uKCkge1xuICAgIHRoaXMuX2RlZmluaXRpb24gPSBgXG52b2lkICR7dGhpcy5fbmFtZX0oaW4gaXZlYzMgZGF0YUNvb3JkaW5hdGVzLCBvdXQgdmVjNCBkYXRhVmFsdWUsIG91dCBpbnQgb2Zmc2V0KXtcbiAgICBcbiAgaW50IGluZGV4ID0gZGF0YUNvb3JkaW5hdGVzLnhcbiAgICAgICAgICAgICsgZGF0YUNvb3JkaW5hdGVzLnkgKiB1RGF0YURpbWVuc2lvbnMueFxuICAgICAgICAgICAgKyBkYXRhQ29vcmRpbmF0ZXMueiAqIHVEYXRhRGltZW5zaW9ucy55ICogdURhdGFEaW1lbnNpb25zLng7XG4gIGludCBpbmRleFAgPSBpbnQoaW5kZXgvdVBhY2tlZFBlclBpeGVsKTtcbiAgb2Zmc2V0ID0gaW5kZXggLSAyKmluZGV4UDtcblxuICAvLyBNYXAgZGF0YSBpbmRleCB0byByaWdodCBzYW1wbGVyMkQgdGV4dHVyZVxuICBpbnQgdm94ZWxzUGVyVGV4dHVyZSA9IHVUZXh0dXJlU2l6ZSp1VGV4dHVyZVNpemU7XG4gIGludCB0ZXh0dXJlSW5kZXggPSBpbnQoZmxvb3IoZmxvYXQoaW5kZXhQKSAvIGZsb2F0KHZveGVsc1BlclRleHR1cmUpKSk7XG4gIC8vIG1vZHVsbyBzZWVtcyBpbmNvcnJlY3Qgc29tZXRpbWVzLi4uXG4gIC8vIGludCBpblRleHR1cmVJbmRleCA9IGludChtb2QoZmxvYXQoaW5kZXgpLCBmbG9hdCh0ZXh0dXJlU2l6ZSp0ZXh0dXJlU2l6ZSkpKTtcbiAgaW50IGluVGV4dHVyZUluZGV4ID0gaW5kZXhQIC0gdm94ZWxzUGVyVGV4dHVyZSp0ZXh0dXJlSW5kZXg7XG5cbiAgLy8gR2V0IHJvdyBhbmQgY29sdW1uIGluIHRoZSB0ZXh0dXJlXG4gIGludCBjb2xJbmRleCA9IGludChtb2QoZmxvYXQoaW5UZXh0dXJlSW5kZXgpLCBmbG9hdCh1VGV4dHVyZVNpemUpKSk7XG4gIGludCByb3dJbmRleCA9IGludChmbG9vcihmbG9hdChpblRleHR1cmVJbmRleCkvZmxvYXQodVRleHR1cmVTaXplKSkpO1xuXG4gIC8vIE1hcCByb3cgYW5kIGNvbHVtbiB0byB1dlxuICB2ZWMyIHV2ID0gdmVjMigwLDApO1xuICB1di54ID0gKDAuNSArIGZsb2F0KGNvbEluZGV4KSkgLyBmbG9hdCh1VGV4dHVyZVNpemUpO1xuICB1di55ID0gMS4gLSAoMC41ICsgZmxvYXQocm93SW5kZXgpKSAvIGZsb2F0KHVUZXh0dXJlU2l6ZSk7XG5cbiAgLy9cbiAgaWYodGV4dHVyZUluZGV4ID09IDApeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbMF0sIHV2KTsgfVxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSAxKXtkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbMV0sIHV2KTt9XG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDIpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbMl0sIHV2KTsgfVxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSAzKXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzNdLCB1dik7IH1cbiAgZWxzZSBpZih0ZXh0dXJlSW5kZXggPT0gNCl7IGRhdGFWYWx1ZSA9IHRleHR1cmUyRCh1VGV4dHVyZUNvbnRhaW5lcls0XSwgdXYpOyB9XG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDUpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbNV0sIHV2KTsgfVxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSA2KXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzZdLCB1dik7IH1cblxufVxuICAgIGA7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVGV4dHVyZTNkKCk7XG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcblxuY2xhc3MgVW5wYWNrIGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lID0gJ3VucGFjayc7XG5cbiAgICAvLyBkZWZhdWx0IHByb3BlcnRpZXMgbmFtZXNcbiAgICB0aGlzLl9wYWNrZWREYXRhID0gJ3BhY2tlZERhdGEnO1xuICAgIHRoaXMuX29mZnNldCA9ICdvZmZzZXQnO1xuICAgIHRoaXMuX3VucGFja2VkRGF0YSA9ICd1bnBhY2tlZERhdGEnO1xuXG4gICAgdGhpcy5fYmFzZS5fdW5pZm9ybXMgPXtcbiAgICAgIHVOdW1iZXJPZkNoYW5uZWxzOiB7XG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgfSxcbiAgICAgIHVCaXRzQWxsb2NhdGVkOiB7XG4gICAgICAgIHZhbHVlOiAxNixcbiAgICAgIH0sXG4gICAgICB1UGl4ZWxUeXBlOiB7XG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsIHBhY2tlZERhdGEgPSB0aGlzLl9wYWNrZWREYXRhLCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQsIHVucGFja2VkRGF0YSA9IHRoaXMuX3VucGFja2VkRGF0YSkge1xuICAgIHRoaXMuX2Jhc2UgPSBiYXNlRnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZShwYWNrZWREYXRhLCBvZmZzZXQsIHVucGFja2VkRGF0YSk7XG4gIH1cblxuICBjb21wdXRlKHBhY2tlZERhdGEsIG9mZnNldCwgdW5wYWNrZWREYXRhKSB7XG4gICAgdGhpcy5jb21wdXRlRGVmaW5pdGlvbigpO1xuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1t0aGlzLl9uYW1lXSA9IHRoaXMuX2RlZmluaXRpb247XG4gICAgcmV0dXJuIGAke3RoaXMuX25hbWV9KCR7cGFja2VkRGF0YX0sICR7b2Zmc2V0fSwgJHt1bnBhY2tlZERhdGF9KTtgO1xuICB9XG5cbiAgY29tcHV0ZURlZmluaXRpb24oKSB7XG4gICAgLy8gZnVuIHN0dWZmXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICBpZiAodGhpcy5fYmFzZS5fdW5pZm9ybXMudU51bWJlck9mQ2hhbm5lbHMudmFsdWUgPT09IDEpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fYmFzZS5fdW5pZm9ybXMudUJpdHNBbGxvY2F0ZWQudmFsdWUpIHtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjb250ZW50ID0gdGhpcy51cGFjazgoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrMTYoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrMzIoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrRGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrSWRlbnRpdHkoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZpbml0aW9uID0gYFxudm9pZCAke3RoaXMuX25hbWV9KGluIHZlYzQgcGFja2VkRGF0YSwgaW4gaW50IG9mZnNldCwgb3V0IHZlYzQgdW5wYWNrZWREYXRhKXtcblxuJHtjb250ZW50fVxuXG59ICBcbiAgICBgO1xuICB9XG5cbiAgdXBhY2s4KCkge1xuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUludDgnXSA9IHRoaXMudUludDgoKTtcblxuICAgIHJldHVybiBgXG51SW50OChcbiAgcGFja2VkRGF0YS5yLFxuICB1bnBhY2tlZERhdGEueCk7XG4gICAgYDtcbiAgfVxuXG4gIHVwYWNrMTYoKSB7XG4gICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zWyd1SW50MTYnXSA9IHRoaXMudUludDE2KCk7XG5cbiAgICByZXR1cm4gYFxudUludDE2KFxuICBwYWNrZWREYXRhLnIgKiBmbG9hdCggMSAtIG9mZnNldCkgKyBwYWNrZWREYXRhLmIgKiBmbG9hdChvZmZzZXQpLFxuICBwYWNrZWREYXRhLmcgKiBmbG9hdCggMSAtIG9mZnNldCkgKyBwYWNrZWREYXRhLmEgKiBmbG9hdChvZmZzZXQpLFxuICB1bnBhY2tlZERhdGEueCk7XG4gICAgYDtcbiAgfVxuXG4gIHVwYWNrMzIoKSB7XG4gICAgaWYgKHRoaXMuX2Jhc2UuX3VuaWZvcm1zLnVQaXhlbFR5cGUudmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUludDMyJ10gPSB0aGlzLnVJbnQzMigpO1xuXG4gICAgICByZXR1cm4gYFxudUludDMyKFxuICBwYWNrZWREYXRhLnIsXG4gIHBhY2tlZERhdGEuZyxcbiAgcGFja2VkRGF0YS5iLFxuICBwYWNrZWREYXRhLmEsXG4gIHVucGFja2VkRGF0YS54KTtcbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUZsb2F0MzInXSA9IHRoaXMudUZsb2F0MzIoKTtcblxuICAgICAgcmV0dXJuIGBcbnVGbG9hdDMyKFxuICBwYWNrZWREYXRhLnIsXG4gIHBhY2tlZERhdGEuZyxcbiAgcGFja2VkRGF0YS5iLFxuICBwYWNrZWREYXRhLmEsXG4gIHVucGFja2VkRGF0YS54KTtcbiAgICAgIGA7XG4gICAgfVxuICB9XG5cbiAgdXBhY2tJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gYFxuXG51bnBhY2tlZERhdGEgPSBwYWNrZWREYXRhO1xuXG4gICAgICBgO1xuICB9XG5cbiAgdUludDgoKSB7XG4gICAgcmV0dXJuIGBcbnZvaWQgdUludDgoaW4gZmxvYXQgciwgb3V0IGZsb2F0IHZhbHVlKXtcbiAgdmFsdWUgPSByICogMjU2Ljtcbn1cbiAgICBgO1xuICB9XG5cbiAgdUludDE2KCkge1xuICAgIHJldHVybiBgXG52b2lkIHVJbnQxNihpbiBmbG9hdCByLCBpbiBmbG9hdCBhLCBvdXQgZmxvYXQgdmFsdWUpe1xuICB2YWx1ZSA9IHIgKiAyNTYuICsgYSAqIDY1NTM2Ljtcbn1cbiAgICBgO1xuICB9XG5cbiAgdUludDMyKCkge1xuICAgIHJldHVybiBgXG52b2lkIHVJbnQzMihpbiBmbG9hdCByLCBpbiBmbG9hdCBnLCBpbiBmbG9hdCBiLCBpbiBmbG9hdCBhLCBvdXQgZmxvYXQgdmFsdWUpe1xuICB2YWx1ZSA9IHIgKiAyNTYuICsgZyAqIDY1NTM2LiArIGIgKiAxNjc3NzIxNi4gKyBhICogNDI5NDk2NzI5Ni47XG59XG4gICAgYDtcbiAgfVxuXG4gIHVGbG9hdDMyKCkge1xuICAgIHJldHVybiBgXG52b2lkIHVGbG9hdDMyKGluIGZsb2F0IHIsIGluIGZsb2F0IGcsIGluIGZsb2F0IGIsIGluIGZsb2F0IGEsIG91dCBmbG9hdCB2YWx1ZSl7XG5cbiAgLy8gY3JlYXRlIGFycmF5cyBjb250YWluaW5nIGJpdHMgZm9yIHJnYmEgdmFsdWVzXG4gIC8vIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gIHZhbHVlID0gciAqIDI1NS47XG4gIGludCBieXRlbWVSWzhdO1xuICBieXRlbWVSWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzBdICogMTI4KTtcbiAgYnl0ZW1lUlsxXSA9IGludChmbG9vcih2YWx1ZSAvIDY0LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzFdICogNjQpO1xuICBieXRlbWVSWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbMl0gKiAzMik7XG4gIGJ5dGVtZVJbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lUlszXSAqIDE2KTtcbiAgYnl0ZW1lUls0XSA9IGludChmbG9vcih2YWx1ZSAvIDguKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbNF0gKiA4KTtcbiAgYnl0ZW1lUls1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbNV0gKiA0KTtcbiAgYnl0ZW1lUls2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbNl0gKiAyKTtcbiAgYnl0ZW1lUls3XSA9IGludChmbG9vcih2YWx1ZSkpO1xuXG4gIHZhbHVlID0gZyAqIDI1NS47XG4gIGludCBieXRlbWVHWzhdO1xuICBieXRlbWVHWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzBdICogMTI4KTtcbiAgYnl0ZW1lR1sxXSA9IGludChmbG9vcih2YWx1ZSAvIDY0LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzFdICogNjQpO1xuICBieXRlbWVHWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbMl0gKiAzMik7XG4gIGJ5dGVtZUdbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lR1szXSAqIDE2KTtcbiAgYnl0ZW1lR1s0XSA9IGludChmbG9vcih2YWx1ZSAvIDguKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbNF0gKiA4KTtcbiAgYnl0ZW1lR1s1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbNV0gKiA0KTtcbiAgYnl0ZW1lR1s2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbNl0gKiAyKTtcbiAgYnl0ZW1lR1s3XSA9IGludChmbG9vcih2YWx1ZSkpO1xuXG4gIHZhbHVlID0gYiAqIDI1NS47XG4gIGludCBieXRlbWVCWzhdO1xuICBieXRlbWVCWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzBdICogMTI4KTtcbiAgYnl0ZW1lQlsxXSA9IGludChmbG9vcih2YWx1ZSAvIDY0LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzFdICogNjQpO1xuICBieXRlbWVCWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbMl0gKiAzMik7XG4gIGJ5dGVtZUJbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQlszXSAqIDE2KTtcbiAgYnl0ZW1lQls0XSA9IGludChmbG9vcih2YWx1ZSAvIDguKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbNF0gKiA4KTtcbiAgYnl0ZW1lQls1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbNV0gKiA0KTtcbiAgYnl0ZW1lQls2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbNl0gKiAyKTtcbiAgYnl0ZW1lQls3XSA9IGludChmbG9vcih2YWx1ZSkpO1xuXG4gIHZhbHVlID0gYSAqIDI1NS47XG4gIGludCBieXRlbWVBWzhdO1xuICBieXRlbWVBWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzBdICogMTI4KTtcbiAgYnl0ZW1lQVsxXSA9IGludChmbG9vcih2YWx1ZSAvIDY0LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzFdICogNjQpO1xuICBieXRlbWVBWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbMl0gKiAzMik7XG4gIGJ5dGVtZUFbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQVszXSAqIDE2KTtcbiAgYnl0ZW1lQVs0XSA9IGludChmbG9vcih2YWx1ZSAvIDguKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbNF0gKiA4KTtcbiAgYnl0ZW1lQVs1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbNV0gKiA0KTtcbiAgYnl0ZW1lQVs2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbNl0gKiAyKTtcbiAgYnl0ZW1lQVs3XSA9IGludChmbG9vcih2YWx1ZSkpO1xuXG4gIC8vIGNvbXB1dGUgZmxvYXQzMiB2YWx1ZSBmcm9tIGJpdCBhcnJheXNcblxuICAvLyBzaWduXG4gIGludCBpc3NpZ25lZCA9IDEgLSAyICogYnl0ZW1lUlswXTtcbiAgLy8gICBpc3NpZ25lZCA9IGludChwb3coLTEuLCBmbG9hdChieXRlbWVSWzBdKSkpO1xuXG4gIC8vIGV4cG9uZW50XG4gIGludCBleHBvbmVudCA9IDA7XG5cbiAgZXhwb25lbnQgKz0gYnl0ZW1lUlsxXSAqIGludChwb3coMi4sIDcuKSk7XG4gIGV4cG9uZW50ICs9IGJ5dGVtZVJbMl0gKiBpbnQocG93KDIuLCA2LikpO1xuICBleHBvbmVudCArPSBieXRlbWVSWzNdICogaW50KHBvdygyLiwgNS4pKTtcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUls0XSAqIGludChwb3coMi4sIDQuKSk7XG4gIGV4cG9uZW50ICs9IGJ5dGVtZVJbNV0gKiBpbnQocG93KDIuLCAzLikpO1xuICBleHBvbmVudCArPSBieXRlbWVSWzZdICogaW50KHBvdygyLiwgMi4pKTtcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUls3XSAqIGludChwb3coMi4sIDEuKSk7XG5cbiAgZXhwb25lbnQgKz0gYnl0ZW1lR1swXTtcblxuXG4gIC8vIGZyYWN0aW9uXG4gIGZsb2F0IGZyYWN0aW9uID0gMC47XG5cbiAgZnJhY3Rpb24gPSBmbG9hdChieXRlbWVHWzFdKSAqIHBvdygyLiwgLTEuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1syXSkgKiBwb3coMi4sIC0yLik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUdbM10pICogcG93KDIuLCAtMy4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzRdKSAqIHBvdygyLiwgLTQuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1s1XSkgKiBwb3coMi4sIC01Lik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUdbNl0pICogcG93KDIuLCAtNi4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzddKSAqIHBvdygyLiwgLTcuKTtcblxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzBdKSAqIHBvdygyLiwgLTguKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQlsxXSkgKiBwb3coMi4sIC05Lik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbMl0pICogcG93KDIuLCAtMTAuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQlszXSkgKiBwb3coMi4sIC0xMS4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzRdKSAqIHBvdygyLiwgLTEyLik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbNV0pICogcG93KDIuLCAtMTMuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQls2XSkgKiBwb3coMi4sIC0xNC4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzddKSAqIHBvdygyLiwgLTE1Lik7XG5cbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVswXSkgKiBwb3coMi4sIC0xNi4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzFdKSAqIHBvdygyLiwgLTE3Lik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbMl0pICogcG93KDIuLCAtMTguKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVszXSkgKiBwb3coMi4sIC0xOS4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzRdKSAqIHBvdygyLiwgLTIwLik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbNV0pICogcG93KDIuLCAtMjEuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVs2XSkgKiBwb3coMi4sIC0yMi4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzddKSAqIHBvdygyLiwgLTIzLik7XG5cbiAgdmFsdWUgPSBmbG9hdChpc3NpZ25lZCkgKiBwb3coIDIuLCBmbG9hdChleHBvbmVudCAtIDEyNykpICogKDEuICsgZnJhY3Rpb24pO1xufVxuICAgIGA7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVW5wYWNrKCk7XG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcbmltcG9ydCBVbnBhY2sgZnJvbSAnLi4vaGVscGVycy9zaGFkZXJzLmhlbHBlcnMudW5wYWNrJztcbmltcG9ydCBUZXh0dXJlM2QgZnJvbSAnLi4vaGVscGVycy9zaGFkZXJzLmhlbHBlcnMudGV4dHVyZTNkJztcblxuXG5jbGFzcyBJbnRlcnBvbGF0aW9uSWRlbnRpdHkgZXh0ZW5kcyBTaGFkZXJzQmFzZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSAnaW50ZXJwb2xhdGlvbklkZW50aXR5JztcblxuICAgIC8vIGRlZmF1bHQgcHJvcGVydGllcyBuYW1lc1xuICAgIHRoaXMuX2N1cnJlbnRWb3hlbCA9ICdjdXJyZW50Vm94ZWwnO1xuICAgIHRoaXMuX2RhdGFWYWx1ZSA9ICdkYXRhVmFsdWUnO1xuICB9XG5cbiAgICBhcGkoYmFzZUZyYWdtZW50ID0gdGhpcy5fYmFzZSwgY3VycmVudFZveGVsID0gdGhpcy5fY3VycmVudFZveGVsLCBkYXRhVmFsdWUgPSB0aGlzLl9kYXRhVmFsdWUpIHtcbiAgICB0aGlzLl9iYXNlID0gYmFzZUZyYWdtZW50O1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGUoY3VycmVudFZveGVsLCBkYXRhVmFsdWUpO1xuICB9XG5cbiAgY29tcHV0ZShjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSkge1xuICAgIHRoaXMuY29tcHV0ZURlZmluaXRpb24oKTtcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke2N1cnJlbnRWb3hlbH0sICR7ZGF0YVZhbHVlfSk7YDtcbiAgfVxuXG5cbiAgY29tcHV0ZURlZmluaXRpb24oKSB7XG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcbnZvaWQgJHt0aGlzLl9uYW1lfShpbiB2ZWMzIGN1cnJlbnRWb3hlbCwgb3V0IHZlYzQgZGF0YVZhbHVlKXtcbiAgLy8gbG93ZXIgYm91bmRcbiAgdmVjMyByY3VycmVudFZveGVsID0gdmVjMyhmbG9vcihjdXJyZW50Vm94ZWwueCArIDAuNSApLCBmbG9vcihjdXJyZW50Vm94ZWwueSArIDAuNSApLCBmbG9vcihjdXJyZW50Vm94ZWwueiArIDAuNSApKTtcbiAgaXZlYzMgdm94ZWwgPSBpdmVjMyhpbnQocmN1cnJlbnRWb3hlbC54KSwgaW50KHJjdXJyZW50Vm94ZWwueSksIGludChyY3VycmVudFZveGVsLnopKTtcblxuICB2ZWM0IHRtcCA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xuICBpbnQgb2Zmc2V0ID0gMDtcblxuICAke1RleHR1cmUzZC5hcGkodGhpcy5fYmFzZSwgJ3ZveGVsJywgJ3RtcCcsICdvZmZzZXQnKX1cbiAgJHtVbnBhY2suYXBpKHRoaXMuX2Jhc2UsICd0bXAnLCAnb2Zmc2V0JywgJ2RhdGFWYWx1ZScpfVxufVxuICAgIGA7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgSW50ZXJwb2xhdGlvbklkZW50aXR5KCk7XG4iLCJpbXBvcnQgSW50ZXJwb2xhdGlvbklkZW50aXR5IGZyb20gJy4vc2hhZGVycy5pbnRlcnBvbGF0aW9uLmlkZW50aXR5JztcbmltcG9ydCBJbnRlcnBvbGF0aW9uVHJpbGluZWFyIGZyb20gJy4vc2hhZGVycy5pbnRlcnBvbGF0aW9uLnRyaWxpbmVhcic7XG5cbmZ1bmN0aW9uIHNoYWRlcnNJbnRlcnBvbGF0aW9uKGJhc2VGcmFnbWVudCwgY3VycmVudFZveGVsLCBkYXRhVmFsdWUsIGdyYWRpZW50KSB7XG4gIHN3aXRjaChiYXNlRnJhZ21lbnQuX3VuaWZvcm1zLnVJbnRlcnBvbGF0aW9uLnZhbHVlKSB7XG5cbiAgICBjYXNlIDA6XG4gICAgICAvLyBubyBpbnRlcnBvbGF0aW9uXG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaShiYXNlRnJhZ21lbnQsIGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlKTtcblxuICAgIGNhc2UgMTpcbiAgICAgIC8vIHRyaWxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvblRyaWxpbmVhci5hcGkoYmFzZUZyYWdtZW50LCBjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSwgZ3JhZGllbnQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKGJhc2VGcmFnbWVudCwgY3VycmVudFZveGVsLCBkYXRhVmFsdWUpO1xuXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhZGVyc0ludGVycG9sYXRpb247XG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcbmltcG9ydCBJbnRlcnBvbGF0aW9uSWRlbnRpdHkgZnJvbSAnLi9zaGFkZXJzLmludGVycG9sYXRpb24uaWRlbnRpdHknO1xuXG5jbGFzcyBJbnRlcnBvbGF0aW9uVHJpbGluZWFyIGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lID0gJ2ludGVycG9sYXRpb25UcmlsaW5lYXInO1xuXG4gICAgLy8gZGVmYXVsdCBwcm9wZXJ0aWVzIG5hbWVzXG4gICAgdGhpcy5fY3VycmVudFZveGVsID0gJ2N1cnJlbnRWb3hlbCc7XG4gICAgdGhpcy5fZGF0YVZhbHVlID0gJ2RhdGFWYWx1ZSc7XG4gICAgdGhpcy5fZ3JhZGllbnQgPSAnZ3JhZGllbnQnO1xuICB9XG5cbiAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsIGN1cnJlbnRWb3hlbCA9IHRoaXMuX2N1cnJlbnRWb3hlbCwgZGF0YVZhbHVlID0gdGhpcy5fZGF0YVZhbHVlLCBncmFkaWVudCA9IHRoaXMuX2dyYWRpZW50KSB7XG4gICAgdGhpcy5fYmFzZSA9IGJhc2VGcmFnbWVudDtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlKGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlLCBncmFkaWVudCk7XG4gIH1cblxuICBjb21wdXRlKGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlLCBncmFkaWVudCkge1xuICAgIHRoaXMuY29tcHV0ZURlZmluaXRpb24oKTtcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke2N1cnJlbnRWb3hlbH0sICR7ZGF0YVZhbHVlfSwgJHtncmFkaWVudH0pO2A7XG4gIH1cblxuICBjb21wdXRlRGVmaW5pdGlvbigpIHtcbiAgICB0aGlzLl9kZWZpbml0aW9uID0gYFxudm9pZCAke3RoaXMuX25hbWV9KGluIHZlYzMgY3VycmVudFZveGVsLCBvdXQgdmVjNCBkYXRhVmFsdWUsIG91dCB2ZWMzIGdyYWRpZW50KXtcblxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmlsaW5lYXJfaW50ZXJwb2xhdGlvblxuICB2ZWMzIGxvd2VyX2JvdW5kID0gdmVjMyhmbG9vcihjdXJyZW50Vm94ZWwueCksIGZsb29yKGN1cnJlbnRWb3hlbC55KSwgZmxvb3IoY3VycmVudFZveGVsLnopKTtcbiAgaWYobG93ZXJfYm91bmQueCA8IDAuKXtcbiAgICBsb3dlcl9ib3VuZC54ID0gMC47XG4gIH1cbiAgaWYobG93ZXJfYm91bmQueSA8IDAuKXtcbiAgICBsb3dlcl9ib3VuZC55ID0gMC47XG4gIH1cbiAgaWYobG93ZXJfYm91bmQueiA8IDAuKXtcbiAgICBsb3dlcl9ib3VuZC56ID0gMC47XG4gIH1cbiAgXG4gIHZlYzMgaGlnaGVyX2JvdW5kID0gbG93ZXJfYm91bmQgKyB2ZWMzKDEpO1xuXG4gIGZsb2F0IHhkID0gKCBjdXJyZW50Vm94ZWwueCAtIGxvd2VyX2JvdW5kLnggKSAvICggaGlnaGVyX2JvdW5kLnggLSBsb3dlcl9ib3VuZC54ICk7XG4gIGZsb2F0IHlkID0gKCBjdXJyZW50Vm94ZWwueSAtIGxvd2VyX2JvdW5kLnkgKSAvICggaGlnaGVyX2JvdW5kLnkgLSBsb3dlcl9ib3VuZC55ICk7XG4gIGZsb2F0IHpkID0gKCBjdXJyZW50Vm94ZWwueiAtIGxvd2VyX2JvdW5kLnogKSAvICggaGlnaGVyX2JvdW5kLnogLSBsb3dlcl9ib3VuZC56ICk7XG5cbiAgLy9cbiAgLy8gYzAwXG4gIC8vXG5cbiAgLy9cblxuICB2ZWM0IHYwMDAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgYzAwMCA9IHZlYzMobG93ZXJfYm91bmQueCwgbG93ZXJfYm91bmQueSwgbG93ZXJfYm91bmQueik7XG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzAwMCcsICd2MDAwJyl9XG4gIHZlYzMgZzAwMCA9IHYwMDAuciAqIHZlYzMoLTEuLCAtMS4sIC0xLik7XG5cbiAgLy9cblxuICB2ZWM0IHYxMDAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgYzEwMCA9IHZlYzMoaGlnaGVyX2JvdW5kLngsIGxvd2VyX2JvdW5kLnksIGxvd2VyX2JvdW5kLnopO1xuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MxMDAnLCAndjEwMCcpfVxuICB2ZWMzIGcxMDAgPSB2MTAwLnIgKiB2ZWMzKDEuLCAtMS4sIC0xLik7XG5cbiAgdmVjNCBjMDAgPSB2MDAwICogKCAxLjAgLSB4ZCApICsgdjEwMCAqIHhkO1xuXG4gIC8vXG4gIC8vIGMwMVxuICAvL1xuICB2ZWM0IHYwMDEgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgYzAwMSA9IHZlYzMobG93ZXJfYm91bmQueCwgbG93ZXJfYm91bmQueSwgaGlnaGVyX2JvdW5kLnopO1xuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MwMDEnLCAndjAwMScpfVxuICB2ZWMzIGcwMDEgPSB2MDAxLnIgKiB2ZWMzKC0xLiwgLTEuLCAxLik7XG5cbiAgdmVjNCB2MTAxID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICB2ZWMzIGMxMDEgPSB2ZWMzKGhpZ2hlcl9ib3VuZC54LCBsb3dlcl9ib3VuZC55LCBoaWdoZXJfYm91bmQueik7XG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzEwMScsICd2MTAxJyl9XG4gIHZlYzMgZzEwMSA9IHYxMDEuciAqIHZlYzMoMS4sIC0xLiwgMS4pO1xuXG4gIHZlYzQgYzAxID0gdjAwMSAqICggMS4wIC0geGQgKSArIHYxMDEgKiB4ZDtcblxuICAvL1xuICAvLyBjMTBcbiAgLy9cbiAgdmVjNCB2MDEwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICB2ZWMzIGMwMTAgPSB2ZWMzKGxvd2VyX2JvdW5kLngsIGhpZ2hlcl9ib3VuZC55LCBsb3dlcl9ib3VuZC56KTtcbiAgJHtJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKHRoaXMuX2Jhc2UsICdjMDEwJywgJ3YwMTAnKX1cbiAgdmVjMyBnMDEwID0gdjAxMC5yICogdmVjMygtMS4sIDEuLCAtMS4pO1xuXG4gIHZlYzQgdjExMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgdmVjMyBjMTEwID0gdmVjMyhoaWdoZXJfYm91bmQueCwgaGlnaGVyX2JvdW5kLnksIGxvd2VyX2JvdW5kLnopO1xuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MxMTAnLCAndjExMCcpfVxuICB2ZWMzIGcxMTAgPSB2MTEwLnIgKiB2ZWMzKDEuLCAxLiwgLTEuKTtcblxuICB2ZWM0IGMxMCA9IHYwMTAgKiAoIDEuMCAtIHhkICkgKyB2MTEwICogeGQ7XG5cbiAgLy9cbiAgLy8gYzExXG4gIC8vXG4gIHZlYzQgdjAxMSA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgdmVjMyBjMDExID0gdmVjMyhsb3dlcl9ib3VuZC54LCBoaWdoZXJfYm91bmQueSwgaGlnaGVyX2JvdW5kLnopO1xuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MwMTEnLCAndjAxMScpfVxuICB2ZWMzIGcwMTEgPSB2MDExLnIgKiB2ZWMzKC0xLiwgMS4sIDEuKTtcblxuICB2ZWM0IHYxMTEgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgYzExMSA9IHZlYzMoaGlnaGVyX2JvdW5kLngsIGhpZ2hlcl9ib3VuZC55LCBoaWdoZXJfYm91bmQueik7XG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzExMScsICd2MTExJyl9XG4gIHZlYzMgZzExMSA9IHYxMTEuciAqIHZlYzMoMS4sIDEuLCAxLik7XG5cbiAgdmVjNCBjMTEgPSB2MDExICogKCAxLjAgLSB4ZCApICsgdjExMSAqIHhkO1xuXG4gIC8vIGMwIGFuZCBjMVxuICB2ZWM0IGMwID0gYzAwICogKCAxLjAgLSB5ZCkgKyBjMTAgKiB5ZDtcbiAgdmVjNCBjMSA9IGMwMSAqICggMS4wIC0geWQpICsgYzExICogeWQ7XG5cbiAgLy8gY1xuICB2ZWM0IGMgPSBjMCAqICggMS4wIC0gemQpICsgYzEgKiB6ZDtcbiAgZGF0YVZhbHVlID0gYztcblxuICAvLyBjb21wdXRlIGdyYWRpZW50XG4gIGdyYWRpZW50ID0gZzAwMCArIGcxMDAgKyBnMDEwICsgZzExMCArIGcwMTEgKyBnMTExICsgZzExMCArIGcwMTE7XG4gIC8vIGdyYWRpZW50TWFnbml0dWRlID0gbGVuZ3RoKGdyYWRpZW50KTtcbiAgLy8gLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ybWFsXyhnZW9tZXRyeSkjVHJhbnNmb3JtaW5nX25vcm1hbHNcbiAgLy8gdmVjMyBsb2NhbE5vcm1hbCA9ICgtMS4gLyBncmFkaWVudE1hZ25pdHVkZSkgKiBncmFkaWVudDtcbiAgLy8gbm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbFBpeGVsVG9QYXRpZW50JHt0aGlzLmlkfSAqIGxvY2FsTm9ybWFsKTtcbiAgLy9ub3JtYWwgPSBncmFkaWVudDtcblxufVxuICAgIGA7XG4gIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBJbnRlcnBvbGF0aW9uVHJpbGluZWFyKCk7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzQmFzZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbmFtZSA9ICdzaGFkZXJzQmFzZSc7XG4gICAgdGhpcy5fYmFzZSA9IHtcbiAgICAgIF9mdW5jdGlvbnM6IHt9LFxuICAgICAgX3VuaWZvcm1zOiB7fSxcbiAgICB9O1xuICAgIHRoaXMuX2RlZmluaXRpb24gPSAnJztcbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzRnJhZ21lbnQge1xuXG4gIC8vIHBhc3MgdW5pZm9ybXMgb2JqZWN0XG4gIGNvbnN0cnVjdG9yKHVuaWZvcm1zKSB7XG4gICAgdGhpcy5fdW5pZm9ybXMgPSB1bmlmb3JtcztcbiAgICB0aGlzLl9mdW5jdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9tYWluID0gJyc7XG4gIH1cblxuICBmdW5jdGlvbnMoKSB7XG4gICAgaWYodGhpcy5fbWFpbiA9PT0gJycpIHtcbiAgICAgIC8vIGlmIG1haW4gaXMgZW1wdHksIGZ1bmN0aW9ucyBjYW4gbm90IGhhdmUgYmVlbiBjb21wdXRlZFxuICAgICAgdGhpcy5tYWluKCk7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgIGNvbnRlbnQgKz0gdGhpcy5fZnVuY3Rpb25zW3Byb3BlcnR5XSArICdcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgdW5pZm9ybXMoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl91bmlmb3Jtcykge1xuICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1twcm9wZXJ0eV07XG4gICAgICBjb250ZW50ICs9IGB1bmlmb3JtICR7dW5pZm9ybS50eXBlR0xTTH0gJHtwcm9wZXJ0eX1gO1xuXG4gICAgICBpZih1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gYFske3VuaWZvcm0ubGVuZ3RofV1gO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9ICc7XFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIG1haW4oKSB7XG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XG4gICAgdGhpcy5fbWFpbiA9IGBcblxuICAgIGZsb2F0IGx1bWEgKHZlYzMgcmdiKSB7XG5cdHJldHVybiAocmdiLnIgKyByZ2IuZyArIHJnYi5iKS8zLjA7XG59XG5cbmNvbnN0IGZsb2F0IFQgPSAwLjA0O1xuY29uc3QgZmxvYXQgTSA9IDEuMDtcbmNvbnN0IGZsb2F0IEwgPSAwLjAwMjtcblxudm9pZCBtYWluKHZvaWQpIHtcblxuICB2ZWMyIHRleENvb3JkID0gdmVjMigoKHZQcm9qZWN0ZWRDb29yZHMueCAvIHZQcm9qZWN0ZWRDb29yZHMudykgKyAxLjAgKSAvIDIuMCxcbiAgICAgICAgICAgICAgICAoKHZQcm9qZWN0ZWRDb29yZHMueSAvIHZQcm9qZWN0ZWRDb29yZHMudykgKyAxLjAgKSAvIDIuMCApO1xuXG4gIGZsb2F0IGJvcmRlcldpZHRoID0gdVdpZHRoOyAvLyBpbiBweFxuICBmbG9hdCBzdGVwX3UgPSBib3JkZXJXaWR0aCAqIDEuMCAvIHVDYW52YXNXaWR0aDtcbiAgZmxvYXQgc3RlcF92ID0gYm9yZGVyV2lkdGggKiAxLjAgLyB1Q2FudmFzSGVpZ2h0O1xuICB2ZWM0IGNlbnRlclBpeGVsID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCk7XG5cbiAgdmVjNCByaWdodFBpeGVsICA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKHN0ZXBfdSwgMC4wKSk7XG4gIHZlYzQgYm90dG9tUGl4ZWwgPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMigwLjAsIHN0ZXBfdikpO1xuXG4gIC8vIG5vdyBtYW51YWxseSBjb21wdXRlIHRoZSBkZXJpdmF0aXZlc1xuICBmbG9hdCBfZEZkWCA9IGxlbmd0aChyaWdodFBpeGVsIC0gY2VudGVyUGl4ZWwpIC8gc3RlcF91O1xuICBmbG9hdCBfZEZkWSA9IGxlbmd0aChib3R0b21QaXhlbCAtIGNlbnRlclBpeGVsKSAvIHN0ZXBfdjtcblxuICAvLyBnbF9GcmFnQ29sb3IuciA9IF9kRmRYO1xuICAvLyBnbF9GcmFnQ29sb3IuZyA9IF9kRmRZO1xuICBnbF9GcmFnQ29sb3IuciA9IG1heChtYXgoY2VudGVyUGl4ZWwuciwgcmlnaHRQaXhlbC5yKSwgYm90dG9tUGl4ZWwucik7XG4gIGdsX0ZyYWdDb2xvci5nID0gbWF4KG1heChjZW50ZXJQaXhlbC5nLCByaWdodFBpeGVsLmcpLCBib3R0b21QaXhlbC5nKTtcbiAgZ2xfRnJhZ0NvbG9yLmIgPSBtYXgobWF4KGNlbnRlclBpeGVsLmIsIHJpZ2h0UGl4ZWwuYiksIGJvdHRvbVBpeGVsLmIpO1xuICBnbF9GcmFnQ29sb3IuYSA9IG1heChfZEZkWCwgX2RGZFkpO1xuXG4gIHJldHVybjtcbiAgZmxvYXQgaCA9IDEuL3VDYW52YXNIZWlnaHQ7XG4gIGZsb2F0IHcgPSAxLi91Q2FudmFzV2lkdGg7XG4gIHZlYzQgbls5XTtcbiAgblswXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAtdywgLWgpKTtcbiAgblsxXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKDAuMCwgLWgpKTtcbiAgblsyXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAgdywgLWgpKTtcbiAgblszXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAtdywgMC4wKSk7XG4gIG5bNF0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzKTtcbiAgbls1XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAgdywgMC4wKSk7XG4gIG5bNl0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMiggLXcsIGgpKTtcbiAgbls3XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKDAuMCwgaCkpO1xuICBuWzhdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoICB3LCBoKSk7XG4gIHZlYzQgc29iZWxfaG9yaXpFZGdlID0gblsyXSArICgyLjAqbls1XSkgKyBuWzhdIC0gKG5bMF0gKyAoMi4wKm5bM10pICsgbls2XSk7XG4gIHZlYzQgc29iZWxfdmVydEVkZ2UgID0gblswXSArICgyLjAqblsxXSkgKyBuWzJdIC0gKG5bNl0gKyAoMi4wKm5bN10pICsgbls4XSk7XG4gIHZlYzMgc29iZWwgPSBzcXJ0KChzb2JlbF9ob3JpekVkZ2UucmdiICogc29iZWxfaG9yaXpFZGdlLnJnYikgKyAoc29iZWxfdmVydEVkZ2UucmdiICogc29iZWxfdmVydEVkZ2UucmdiKSk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHNvYmVsLCBtYXgobWF4KHNvYmVsLnIsIHNvYmVsLmcpLCBzb2JlbC5iKSApO1xuXG5cbiAgcmV0dXJuO1xuXG4gIGdsX0ZyYWdDb2xvci5yID0gKHRleENvb3JkICsgdmVjMigwLjAsIHN0ZXBfdikpLnI7XG4gIGdsX0ZyYWdDb2xvci5nID0gKHRleENvb3JkICsgdmVjMihzdGVwX3UsIDAuMCkpLmc7XG4gIGdsX0ZyYWdDb2xvciA9IGNlbnRlclBpeGVsO1xuICBnbF9GcmFnQ29sb3IuciA9IHRleENvb3JkLng7XG4gIC8vIGdsX0ZyYWdDb2xvci5nID0gKHRleENvb3JkICsgdmVjMigwLjAsIHN0ZXBfdikpLng7XG4gIGdsX0ZyYWdDb2xvci5iID0gKHRleENvb3JkICsgdmVjMihzdGVwX3UsIDAuMCkpLng7XG4gIGdsX0ZyYWdDb2xvci5yZyA9ICh0ZXhDb29yZCArIHZlYzIoMC4wLCBzdGVwX3YpKTtcbiAgZ2xfRnJhZ0NvbG9yLmIgPSAwLjtcbiAgcmV0dXJuO1xuICB2ZWMyIHRleENvb3JkU2xvcGUgPSBmd2lkdGgodGV4Q29vcmQpO1xuICB2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMpO1xuICAvLyBkZmR4IHRoYXQgdlByb2plY3RlZFRleHRDb29yZHNcbiAgZmxvYXQgbCA9IGx1bWEgKGNvbG9yMi5yZ2IpIDtcbiAgICBmbG9hdCBsdW1pbmFuY2UgPSBkb3QoY29sb3IyLnJnYix2ZWMzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKTtcblxuICBcdGZsb2F0IHEwID0gZndpZHRoIChsdW1pbmFuY2UpO1xuICAgIGlmKHEwID4gMC4wMSl7XG4gICAgICBxMCA9IDEuMDtcbiAgICB9XG5cdGZsb2F0IHExID0gYWJzIChkRmR4IChsKSk7IFxuXHRmbG9hdCBxMiA9IGFicyAoZEZkeSAobCkpO1xuXG4gIFx0dmVjNCBjdCA9IHZlYzQgKDEuMCwgMS4wLCAxLjAsIDAuMCk7XG5cdHZlYzQgYzAgPSBtaXggKGN0LCB2ZWM0ICgxLjAsIDAuMCwgMC4wLCAxLjApLCBcblx0XHRzbW9vdGhzdGVwIChUICogKDEuMCAtIE0pLCBUICogKDEuMCArIE0pLCBxMCkpO1xuXG5nbF9GcmFnQ29sb3IuciA9IGZ3aWR0aChjb2xvcjIucik7Ly9hYnMoZEZkeChjb2xvcjIuYikpOy8vdGV4Q29vcmQ7Ly9jb2xvcjIucmdiO1xuZ2xfRnJhZ0NvbG9yLmcgPSBmd2lkdGgoY29sb3IyLmcpO1xuZ2xfRnJhZ0NvbG9yLmIgPSBmd2lkdGgoY29sb3IyLmIpO1xuZ2xfRnJhZ0NvbG9yLmEgPSAxLjtcbi8vIGdsX0ZyYWdDb2xvci5hID0gcTA7XG4vLyBnbF9GcmFnQ29sb3IgPSBjb2xvcjI7XG4vL3JldHVybjtcblxuXG4gIC8vVGhlIGJhY2sgcG9zaXRpb24gaXMgdGhlIHdvcmxkIHNwYWNlIHBvc2l0aW9uIHN0b3JlZCBpbiB0aGUgdGV4dHVyZS5cbiAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQpO1xuICBmbG9hdCBsQ29sb3IgPSBsZW5ndGgoY29sb3IucmdiKTtcbiAgZmxvYXQgbWF4Q29sb3IgPSBsZW5ndGgoY29sb3IucmdiKTsvL21heChtYXgoY29sb3IuciwgY29sb3IuZyksIGNvbG9yLmIpO1xuICAvLyBpZihtYXhDb2xvciA+IDAuMSl7XG4gIC8vICAgbWF4Q29sb3IgPSAxLjA7XG4gIC8vIH1cblxuXG5cbiAgLy8gZ2xfRnJhZ0NvbG9yID0gY29sb3I7Ly92ZWM0KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIDEpO1xuICAvLyByZXR1cm47XG4gIC8vIGZsb2F0IHRtcHh4ICA9IGFicyhkRmR4KGxDb2xvcikpO1xuICAvLyBmbG9hdCB0bXB4eSAgPSBhYnMoZEZkeShsQ29sb3IpKTtcbiAgLy8gZmxvYXQgdG1weCA9IG1heCh0bXB4eCx0bXB4eSk7XG5cbiAgLy8gZmxvYXQgdG1weXggID0gYWJzKGRGZHgoY29sb3IueSkpO1xuICAvLyBmbG9hdCB0bXB5eSAgPSBhYnMoZEZkeShjb2xvci55KSk7XG4gIC8vIGZsb2F0IHRtcHkgPSBtYXgodG1weXgsdG1weXkpO1xuXG4gIC8vIGZsb2F0IHRtcHp4ICA9IGFicyhkRmR4KGNvbG9yLnopKTtcbiAgLy8gZmxvYXQgdG1wenkgID0gYWJzKGRGZHkoY29sb3IueikpO1xuICAvLyBmbG9hdCB0bXB6ID0gbWF4KHRtcHp4LHRtcHp5KTtcblxuICAvLyBmbG9hdCB0bXBtYXggPSBtYXgobWF4KHRtcHgsIHRtcHkpLCB0bXB6KTtcbiAgLy8gaWYodG1wbWF4ID4gMC4wMSl7XG4gIC8vICAgdG1wbWF4ID0gMS4wO1xuICAvLyB9XG4gIC8vIGdsX0ZyYWdDb2xvci5yID0gdG1weDsvL3Ntb290aHN0ZXAodG1weC01LiwgdG1weCs1LiwgbENvbG9yKTtcbiAgLy8gZ2xfRnJhZ0NvbG9yLmcgPSB0bXB4O1xuICAvLyBnbF9GcmFnQ29sb3IuYiA9IHRtcHg7XG5cbiAgLy8gdmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZlYzIodGV4Y1gsIHRleGNZKSk7XG5cbiAgLy8gZ2xfRnJhZ0NvbG9yLnIgPSBjb2xvci5yIC0gdGV4Y1g7XG4gIC8vIGdsX0ZyYWdDb2xvci5nID0gY29sb3IuZyAtIHRleGNZO1xuICAvLyBnbF9GcmFnQ29sb3IuYiA9IGNvbG9yLmIgLSBjb2xvcjIuYjtcbiAgLy8gZ2xfRnJhZ0NvbG9yLmEgPSAxLjtcblxuICAvLyBmbG9hdCB0aHJlc2hvbGQgPSAwLjc7XG4gIC8vIGZsb2F0IGFmd2lkdGggPSBsZW5ndGgodmVjMihkRmR4KG1heENvbG9yKSwgZEZkeShtYXhDb2xvcikpKTtcbiAgLy8gZ2xfRnJhZ0NvbG9yLmEgPSBhZndpZHRoO1xuICAvLyBmbG9hdCBvcGFjaXR5ID1cbiAgLy8gICBzbW9vdGhzdGVwKGFmd2lkdGggLSB0aHJlc2hvbGQsIGFmd2lkdGggKyB0aHJlc2hvbGQsIG1heENvbG9yKTtcblxuICAvLyBnbF9GcmFnQ29sb3IuYSA9IG1heENvbG9yO1xuXG4vLyBmbG9hdCBhYWYgPSBmd2lkdGgobWF4Q29sb3IpO1xuLy8gZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKC4wMSwgLjgsIGFhZik7XG4vLyBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgYWxwaGEpO1xuXG4gIC8vIGZsb2F0IGggPSAxLi91Q2FudmFzSGVpZ2h0O1xuICAvLyBmbG9hdCB3ID0gMS4vdUNhbnZhc1dpZHRoO1xuICAvLyB2ZWM0IG5bOV07XG4gIC8vIG5bMF0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMiggLXcsIC1oKSk7XG4gIC8vIG5bMV0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMigwLjAsIC1oKSk7XG4gIC8vIG5bMl0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMiggIHcsIC1oKSk7XG4gIC8vIG5bM10gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMiggLXcsIDAuMCkpO1xuICAvLyBuWzRdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3Jkcyk7XG4gIC8vIG5bNV0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMiggIHcsIDAuMCkpO1xuICAvLyBuWzZdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoIC13LCBoKSk7XG4gIC8vIG5bN10gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMigwLjAsIGgpKTtcbiAgLy8gbls4XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAgdywgaCkpO1xuICAvLyB2ZWM0IHNvYmVsX2hvcml6RWRnZSA9IG5bMl0gKyAoMi4wKm5bNV0pICsgbls4XSAtIChuWzBdICsgKDIuMCpuWzNdKSArIG5bNl0pO1xuICAvLyB2ZWM0IHNvYmVsX3ZlcnRFZGdlICA9IG5bMF0gKyAoMi4wKm5bMV0pICsgblsyXSAtIChuWzZdICsgKDIuMCpuWzddKSArIG5bOF0pO1xuICAvLyB2ZWMzIHNvYmVsID0gc3FydCgoc29iZWxfaG9yaXpFZGdlLnJnYiAqIHNvYmVsX2hvcml6RWRnZS5yZ2IpICsgKHNvYmVsX3ZlcnRFZGdlLnJnYiAqIHNvYmVsX3ZlcnRFZGdlLnJnYikpO1xuICAvLyBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBuWzFdLnJnYiwgMS4wICk7XG4gIC8vIGdsX0ZyYWdDb2xvci5yID0gMS4wO1xuXG4gIHJldHVybjtcbn1cbiAgIGA7XG4gIH1cblxuICBjb21wdXRlKCkge1xuICAgIGxldCBzaGFkZXJJbnRlcnBvbGF0aW9uID0gJyc7XG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5pbmxpbmUoYXJncykgLy90cnVlL2ZhbHNlXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5mdW5jdGlvbnMoYXJncylcblxuICAgIHJldHVybiBgXG4vLyB1bmlmb3Jtc1xuJHt0aGlzLnVuaWZvcm1zKCl9XG5cbi8vIHZhcnlpbmcgKHNob3VsZCBmZXRjaCBpdCBmcm9tIHZlcnRleCBkaXJlY3RseSlcbnZhcnlpbmcgdmVjNCAgICAgIHZQb3M7XG52YXJ5aW5nIHZlYzQgICAgICB2UHJvamVjdGVkQ29vcmRzO1xudmFyeWluZyB2ZWMyICAgICAgdlByb2plY3RlZFRleHRDb29yZHM7XG52YXJ5aW5nIG1hdDQgICAgICB2UHJvamVjdGlvblZpZXdNYXRyaXg7XG5cbi8vIHRhaWxvcmVkIGZ1bmN0aW9uc1xuJHt0aGlzLmZ1bmN0aW9ucygpfVxuXG4vLyBtYWluIGxvb3BcbiR7dGhpcy5fbWFpbn1cbiAgICAgIGA7XG4gICAgfVxuXG59XG4iLCJcbi8qKlxuICogQG1vZHVsZSBzaGFkZXJzL2RhdGFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc1VuaWZvcm0ge1xuICBzdGF0aWMgdW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICd1Q2FudmFzV2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDAuLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndUNhbnZhc0hlaWdodCc6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMC4sXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1V2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDEuLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndVRleHR1cmVGaWxsZWQnOiB7XG4gICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBjb21wdXRlKCkge1xuICAgICAgICByZXR1cm4gYFxudmFyeWluZyB2ZWM0IHZQb3M7XG52YXJ5aW5nIHZlYzQgdlByb2plY3RlZENvb3JkcztcbnZhcnlpbmcgbWF0NCB2UHJvamVjdGlvblZpZXdNYXRyaXg7XG52YXJ5aW5nIHZlYzIgdlByb2plY3RlZFRleHRDb29yZHM7XG5cbi8vXG4vLyBtYWluXG4vL1xudm9pZCBtYWluKCkge1xuXG4gIHZQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xuICB2UHJvamVjdGlvblZpZXdNYXRyaXggPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeDtcbiAgdlByb2plY3RlZENvb3JkcyA9ICBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuICB2UHJvamVjdGVkVGV4dENvb3JkcyA9IHZlYzIoKCh2UHJvamVjdGVkQ29vcmRzLnggLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAsXG4gICAgICAgICAgICAgICAgKCh2UHJvamVjdGVkQ29vcmRzLnkgLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAgKTtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XG5cbn1cbiAgICAgICAgYDtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBzaGFkZXJzSW50ZXJwb2xhdGlvbiBmcm9tICcuL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0ZyYWdtZW50IHtcblxuICAvLyBwYXNzIHVuaWZvcm1zIG9iamVjdFxuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5fZnVuY3Rpb25zID0ge307XG4gICAgdGhpcy5fbWFpbiA9ICcnO1xuICB9XG5cbiAgZnVuY3Rpb25zKCkge1xuICAgIGlmICh0aGlzLl9tYWluID09PSAnJykge1xuICAgICAgLy8gaWYgbWFpbiBpcyBlbXB0eSwgZnVuY3Rpb25zIGNhbiBub3QgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gICAgICB0aGlzLm1haW4oKTtcbiAgICB9XG5cbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX2Z1bmN0aW9ucykge1xuICAgICAgY29udGVudCArPSB0aGlzLl9mdW5jdGlvbnNbcHJvcGVydHldICsgJ1xcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICB1bmlmb3JtcygpIHtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX3VuaWZvcm1zKSB7XG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMuX3VuaWZvcm1zW3Byb3BlcnR5XTtcbiAgICAgIGNvbnRlbnQgKz0gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGVHTFNMfSAke3Byb3BlcnR5fWA7XG5cbiAgICAgIGlmICh1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gYFske3VuaWZvcm0ubGVuZ3RofV1gO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9ICc7XFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIG1haW4oKSB7XG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XG4gICAgdGhpcy5fbWFpbiA9IGBcbnZvaWQgbWFpbih2b2lkKSB7XG5cbiAgLy8gZHJhdyBib3JkZXIgaWYgc2xpY2UgaXMgY3JvcHBlZFxuICAvLyBmbG9hdCB1Qm9yZGVyRGFzaExlbmd0aCA9IDEwLjtcblxuICBpZiggdUNhbnZhc1dpZHRoID4gMC4gJiZcbiAgICAgICgoZ2xfRnJhZ0Nvb3JkLnggPiB1Qm9yZGVyTWFyZ2luICYmIChnbF9GcmFnQ29vcmQueCAtIHVCb3JkZXJNYXJnaW4pIDwgdUJvcmRlcldpZHRoKSB8fFxuICAgICAgIChnbF9GcmFnQ29vcmQueCA8ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyTWFyZ2luKSAmJiAoZ2xfRnJhZ0Nvb3JkLnggKyB1Qm9yZGVyTWFyZ2luKSA+ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyV2lkdGgpICkpKXtcbiAgICBmbG9hdCB2YWx1ZVkgPSBtb2QoZ2xfRnJhZ0Nvb3JkLnksIDIuICogdUJvcmRlckRhc2hMZW5ndGgpO1xuICAgIGlmKCB2YWx1ZVkgPCB1Qm9yZGVyRGFzaExlbmd0aCAmJiBnbF9GcmFnQ29vcmQueSA+IHVCb3JkZXJNYXJnaW4gJiYgZ2xfRnJhZ0Nvb3JkLnkgPCAodUNhbnZhc0hlaWdodCAtIHVCb3JkZXJNYXJnaW4pICl7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVCb3JkZXJDb2xvciwgMS4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmKCB1Q2FudmFzSGVpZ2h0ID4gMC4gJiZcbiAgICAgICgoZ2xfRnJhZ0Nvb3JkLnkgPiB1Qm9yZGVyTWFyZ2luICYmIChnbF9GcmFnQ29vcmQueSAtIHVCb3JkZXJNYXJnaW4pIDwgdUJvcmRlcldpZHRoKSB8fFxuICAgICAgIChnbF9GcmFnQ29vcmQueSA8ICh1Q2FudmFzSGVpZ2h0IC0gdUJvcmRlck1hcmdpbikgJiYgKGdsX0ZyYWdDb29yZC55ICsgdUJvcmRlck1hcmdpbikgPiAodUNhbnZhc0hlaWdodCAtIHVCb3JkZXJXaWR0aCkgKSkpe1xuICAgIGZsb2F0IHZhbHVlWCA9IG1vZChnbF9GcmFnQ29vcmQueCwgMi4gKiB1Qm9yZGVyRGFzaExlbmd0aCk7XG4gICAgaWYoIHZhbHVlWCA8IHVCb3JkZXJEYXNoTGVuZ3RoICYmIGdsX0ZyYWdDb29yZC54ID4gdUJvcmRlck1hcmdpbiAmJiBnbF9GcmFnQ29vcmQueCA8ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyTWFyZ2luKSApe1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Qm9yZGVyQ29sb3IsIDEuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgdGV4dHVyZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBpeGVsXG4gIHZlYzQgZGF0YUNvb3JkaW5hdGVzID0gdVdvcmxkVG9EYXRhICogdlBvcztcbiAgdmVjMyBjdXJyZW50Vm94ZWwgPSB2ZWMzKGRhdGFDb29yZGluYXRlcy54LCBkYXRhQ29vcmRpbmF0ZXMueSwgZGF0YUNvb3JkaW5hdGVzLnopO1xuICB2ZWM0IGRhdGFWYWx1ZSA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xuICB2ZWMzIGdyYWRpZW50ID0gdmVjMygwLiwgMC4sIDAuKTtcbiAgJHtzaGFkZXJzSW50ZXJwb2xhdGlvbih0aGlzLCAnY3VycmVudFZveGVsJywgJ2RhdGFWYWx1ZScsICdncmFkaWVudCcpfVxuXG4gIC8vIGhvdyBkbyB3ZSBkZWFsIHdpbCBtb3JlIHRoYW4gMSBjaGFubmVsP1xuICBpZih1TnVtYmVyT2ZDaGFubmVscyA9PSAxKXtcbiAgICBmbG9hdCBpbnRlbnNpdHkgPSBkYXRhVmFsdWUucjtcblxuICAgIC8vIHJlc2NhbGUvc2xvcGVcbiAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkqdVJlc2NhbGVTbG9wZUludGVyY2VwdFswXSArIHVSZXNjYWxlU2xvcGVJbnRlcmNlcHRbMV07XG5cbiAgICBmbG9hdCB3aW5kb3dNaW4gPSB1V2luZG93Q2VudGVyV2lkdGhbMF0gLSB1V2luZG93Q2VudGVyV2lkdGhbMV0gKiAwLjU7XG4gICAgZmxvYXQgd2luZG93TWF4ID0gdVdpbmRvd0NlbnRlcldpZHRoWzBdICsgdVdpbmRvd0NlbnRlcldpZHRoWzFdICogMC41O1xuICAgIGludGVuc2l0eSA9ICggaW50ZW5zaXR5IC0gd2luZG93TWluICkgLyB1V2luZG93Q2VudGVyV2lkdGhbMV07XG5cbiAgICBkYXRhVmFsdWUuciA9IGRhdGFWYWx1ZS5nID0gZGF0YVZhbHVlLmIgPSBpbnRlbnNpdHk7XG4gICAgZGF0YVZhbHVlLmEgPSAxLjA7XG4gIH1cblxuICAvLyBBcHBseSBMVVQgdGFibGUuLi5cbiAgLy9cbiAgaWYodUx1dCA9PSAxKXtcbiAgICAvLyBzaG91bGQgb3BhY2l0eSBiZSBncmFiYmVkIHRoZXJlP1xuICAgIGRhdGFWYWx1ZSA9IHRleHR1cmUyRCggdVRleHR1cmVMVVQsIHZlYzIoIGRhdGFWYWx1ZS5yICwgMS4wKSApO1xuICB9XG5cbiAgaWYodUludmVydCA9PSAxKXtcbiAgICBkYXRhVmFsdWUgPSB2ZWM0KDEuKSAtIGRhdGFWYWx1ZTtcbiAgICAvLyBob3cgZG8gd2UgZGVhbCB3aXRoIHRoYXQgYW5kIG9wYWNpdHk/XG4gICAgZGF0YVZhbHVlLmEgPSAxLjtcbiAgfVxuXG4gIGdsX0ZyYWdDb2xvciA9IGRhdGFWYWx1ZTtcblxuICAgIC8vIGlmIG9uIGVkZ2UsIGRyYXcgbGluZVxuICAvLyBmbG9hdCB4UG9zID0gZ2xfRnJhZ0Nvb3JkLngvNTEyLjtcbiAgLy8gZmxvYXQgeVBvcyA9IGdsX0ZyYWdDb29yZC55LzUxMi47XG4gIC8vIGlmKCB4UG9zIDwgMC4wNSB8fCB4UG9zID4gLjk1IHx8IHlQb3MgPCAwLjA1IHx8IHlQb3MgPiAuOTUpe1xuICAvLyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoeFBvcywgeVBvcywgMC4sIDEuKTsvL2RhdGFWYWx1ZTtcbiAgLy8gICAvL3JldHVybjtcbiAgLy8gfVxuXG59XG4gICBgO1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uaW5saW5lKGFyZ3MpIC8vdHJ1ZS9mYWxzZVxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXG5cbiAgICByZXR1cm4gYFxuLy8gdW5pZm9ybXNcbiR7dGhpcy51bmlmb3JtcygpfVxuXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xuXG4vLyB0YWlsb3JlZCBmdW5jdGlvbnNcbiR7dGhpcy5mdW5jdGlvbnMoKX1cblxuLy8gbWFpbiBsb29wXG4ke3RoaXMuX21haW59XG4gICAgICBgO1xuICAgIH1cblxufVxuIiwiXG4vKipcbiAqIEBtb2R1bGUgc2hhZGVycy9kYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNVbmlmb3JtIHtcbiAgLyoqXG4gICAqIFNoYWRlcnMgZGF0YSB1bmlmb3Jtc1xuICAgKi9cbiAgc3RhdGljIHVuaWZvcm1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAndVRleHR1cmVTaXplJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VUZXh0dXJlQ29udGFpbmVyJzoge1xuICAgICAgICB0eXBlOiAndHYnLFxuICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgbGVuZ3RoOiA3LFxuICAgICAgfSxcbiAgICAgICd1RGF0YURpbWVuc2lvbnMnOiB7XG4gICAgICAgIHR5cGU6ICdpdicsXG4gICAgICAgIHZhbHVlOiBbMCwgMCwgMF0sXG4gICAgICAgIHR5cGVHTFNMOiAnaXZlYzMnLFxuICAgICAgfSxcbiAgICAgICd1V29ybGRUb0RhdGEnOiB7XG4gICAgICAgIHR5cGU6ICdtNCcsXG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpLFxuICAgICAgICB0eXBlR0xTTDogJ21hdDQnLFxuICAgICAgfSxcbiAgICAgICd1V2luZG93Q2VudGVyV2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmdjEnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICAgIGxlbmd0aDogMixcbiAgICAgIH0sXG4gICAgICAndVJlc2NhbGVTbG9wZUludGVyY2VwdCc6IHtcbiAgICAgICAgdHlwZTogJ2Z2MScsXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgfSxcbiAgICAgICd1TnVtYmVyT2ZDaGFubmVscyc6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1Qml0c0FsbG9jYXRlZCc6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogOCxcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1SW52ZXJ0Jzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VMdXQnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVRleHR1cmVMVVQnOiB7XG4gICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXG4gICAgICB9LFxuICAgICAgJ3VQaXhlbFR5cGUnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVBhY2tlZFBlclBpeGVsJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VJbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VDYW52YXNXaWR0aCc6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMC4sXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1Q2FudmFzSGVpZ2h0Jzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAwLixcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICB9LFxuICAgICAgJ3VCb3JkZXJDb2xvcic6IHtcbiAgICAgICAgdHlwZTogJ3YzJyxcbiAgICAgICAgdmFsdWU6IFsxLjAsIDAuMCwgMC41XSxcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWMzJyxcbiAgICAgIH0sXG4gICAgICAndUJvcmRlcldpZHRoJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAyLixcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICB9LFxuICAgICAgJ3VCb3JkZXJNYXJnaW4nOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDIuLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndUJvcmRlckRhc2hMZW5ndGgnOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDEwLixcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBjb21wdXRlKCkge1xuICAgICAgICByZXR1cm4gYFxudmFyeWluZyB2ZWM0IHZQb3M7XG5cbi8vXG4vLyBtYWluXG4vL1xudm9pZCBtYWluKCkge1xuXG4gIHZQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcblxufVxuICAgICAgICBgO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IENvbnRvdXJVbmlmb3JtIGZyb20gJy4vc2hhZGVycy5jb250b3VyLnVuaWZvcm0nO1xuaW1wb3J0IENvbnRvdXJGcmFnbWVudCBmcm9tICcuL3NoYWRlcnMuY29udG91ci5mcmFnbWVudCc7XG5pbXBvcnQgQ29udG91clZlcnRleCBmcm9tICcuL3NoYWRlcnMuY29udG91ci52ZXJ0ZXgnO1xuXG5pbXBvcnQgRGF0YVVuaWZvcm0gZnJvbSAnLi9zaGFkZXJzLmRhdGEudW5pZm9ybSc7XG5pbXBvcnQgRGF0YUZyYWdtZW50IGZyb20gJy4vc2hhZGVycy5kYXRhLmZyYWdtZW50JztcbmltcG9ydCBEYXRhVmVydGV4IGZyb20gJy4vc2hhZGVycy5kYXRhLnZlcnRleCc7XG5cbmltcG9ydCBWUlVuaWZvcm0gZnJvbSAnLi9zaGFkZXJzLnZyLnVuaWZvcm0nO1xuaW1wb3J0IFZSRnJhZ21lbnQgZnJvbSAnLi9zaGFkZXJzLnZyLmZyYWdtZW50JztcbmltcG9ydCBWUlZlcnRleCBmcm9tICcuL3NoYWRlcnMudnIudmVydGV4JztcblxuaW1wb3J0IExheWVyVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMubGF5ZXIudW5pZm9ybSc7XG5pbXBvcnQgTGF5ZXJGcmFnbWVudCBmcm9tICcuL3NoYWRlcnMubGF5ZXIuZnJhZ21lbnQnO1xuaW1wb3J0IExheWVyVmVydGV4IGZyb20gJy4vc2hhZGVycy5sYXllci52ZXJ0ZXgnO1xuXG5pbXBvcnQgTG9jYWxpemVyVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMubG9jYWxpemVyLnVuaWZvcm0nO1xuaW1wb3J0IExvY2FsaXplckZyYWdtZW50IGZyb20gJy4vc2hhZGVycy5sb2NhbGl6ZXIuZnJhZ21lbnQnO1xuaW1wb3J0IExvY2FsaXplclZlcnRleCBmcm9tICcuL3NoYWRlcnMubG9jYWxpemVyLnZlcnRleCc7XG5cbi8qKlxuICogQG1vZHVsZSBzaGFkZXJzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBDb250b3VyVW5pZm9ybSxcbiAgQ29udG91ckZyYWdtZW50LFxuICBDb250b3VyVmVydGV4LFxuXG4gIERhdGFVbmlmb3JtLFxuICBEYXRhRnJhZ21lbnQsXG4gIERhdGFWZXJ0ZXgsXG5cbiAgVlJVbmlmb3JtLFxuICBWUkZyYWdtZW50LFxuICBWUlZlcnRleCxcblxuICBMYXllclVuaWZvcm0sXG4gIExheWVyRnJhZ21lbnQsXG4gIExheWVyVmVydGV4LFxuXG4gIExvY2FsaXplclVuaWZvcm0sXG4gIExvY2FsaXplckZyYWdtZW50LFxuICBMb2NhbGl6ZXJWZXJ0ZXgsXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0ZyYWdtZW50IHtcblxuICAvLyBwYXNzIHVuaWZvcm1zIG9iamVjdFxuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5fZnVuY3Rpb25zID0ge307XG4gICAgdGhpcy5fbWFpbiA9ICcnO1xuICB9XG5cbiAgZnVuY3Rpb25zKCkge1xuICAgIGlmKHRoaXMuX21haW4gPT09ICcnKSB7XG4gICAgICAvLyBpZiBtYWluIGlzIGVtcHR5LCBmdW5jdGlvbnMgY2FuIG5vdCBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgICAgIHRoaXMubWFpbigpO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fZnVuY3Rpb25zKSB7XG4gICAgICBjb250ZW50ICs9IHRoaXMuX2Z1bmN0aW9uc1twcm9wZXJ0eV0gKyAnXFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIHVuaWZvcm1zKCkge1xuICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fdW5pZm9ybXMpIHtcbiAgICAgIGxldCB1bmlmb3JtID0gdGhpcy5fdW5pZm9ybXNbcHJvcGVydHldO1xuICAgICAgY29udGVudCArPSBgdW5pZm9ybSAke3VuaWZvcm0udHlwZUdMU0x9ICR7cHJvcGVydHl9YDtcblxuICAgICAgaWYodW5pZm9ybSAmJiB1bmlmb3JtLmxlbmd0aCkge1xuICAgICAgICBjb250ZW50ICs9IGBbJHt1bmlmb3JtLmxlbmd0aH1dYDtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSAnO1xcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBtYWluKCkge1xuICAgIC8vIG5lZWQgdG8gcHJlLWNhbGwgbWFpbiB0byBmaWxsIHVwIHRoZSBmdW5jdGlvbnMgbGlzdFxuICAgIHRoaXMuX21haW4gPSBgXG52b2lkIG1haW4odm9pZCkge1xuXG4gIHZlYzIgdGV4YyA9IHZlYzIoKCh2UHJvamVjdGVkQ29vcmRzLnggLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAsXG4gICAgICAgICAgICAgICAgKCh2UHJvamVjdGVkQ29vcmRzLnkgLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAgKTtcblxuICAvLyBqdXN0IHNpbGVuY2Ugd2FybmluZyBmb3JcbiAgdmVjNCBkdW1teSA9IHZQb3M7XG5cbiAgLy9UaGUgYmFjayBwb3NpdGlvbiBpcyB0aGUgd29ybGQgc3BhY2UgcG9zaXRpb24gc3RvcmVkIGluIHRoZSB0ZXh0dXJlLlxuICB2ZWM0IGJhc2VDb2xvcjAgPSB0ZXh0dXJlMkQodVRleHR1cmVCYWNrVGVzdDAsIHRleGMpO1xuICB2ZWM0IGJhc2VDb2xvcjEgPSB0ZXh0dXJlMkQodVRleHR1cmVCYWNrVGVzdDEsIHRleGMpO1xuXG4gIGlmKCB1VHJhY2tNb3VzZSA9PSAxICl7XG5cbiAgICAgIGlmKCB2UHJvamVjdGVkQ29vcmRzLnggPCB1TW91c2UueCApe1xuXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGJhc2VDb2xvcjA7XG5cbiAgICAgIH1cbiAgICAgIGVsc2V7XG5cbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KCBiYXNlQ29sb3IwLCBiYXNlQ29sb3IxLCB1T3BhY2l0eTEgKTtcblxuICAgICAgfVxuXG4gIH1cbiAgZWxzZXtcblxuICAgIGlmKCB1VHlwZTEgPT0gMCApe1xuXG4gICAgICAvL21lcmdlIGFuIGltYWdlIGludG9cbiAgICAgIGdsX0ZyYWdDb2xvciA9IG1peCggYmFzZUNvbG9yMCwgYmFzZUNvbG9yMSwgdU9wYWNpdHkxICk7XG5cbiAgICB9XG4gICAgZWxzZXtcblxuICAgICAgZmxvYXQgb3BhY2l0eSA9IGJhc2VDb2xvcjEuYTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IG1peCggYmFzZUNvbG9yMCwgYmFzZUNvbG9yMSwgb3BhY2l0eSAqIHVPcGFjaXR5MSApO1xuXG4gICAgfVxuXG4gIH1cblxuICByZXR1cm47XG59XG4gICBgO1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uaW5saW5lKGFyZ3MpIC8vdHJ1ZS9mYWxzZVxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXG5cbiAgICByZXR1cm4gYFxuLy8gdW5pZm9ybXNcbiR7dGhpcy51bmlmb3JtcygpfVxuXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xudmFyeWluZyB2ZWM0ICAgICAgdlByb2plY3RlZENvb3JkcztcblxuLy8gdGFpbG9yZWQgZnVuY3Rpb25zXG4ke3RoaXMuZnVuY3Rpb25zKCl9XG5cbi8vIG1haW4gbG9vcFxuJHt0aGlzLl9tYWlufVxuICAgICAgYDtcbiAgICB9XG5cbn1cbiIsIlxuLyoqXG4gKiBAbW9kdWxlIHNoYWRlcnMvZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzVW5pZm9ybSB7XG4gIHN0YXRpYyB1bmlmb3JtcygpIHtcbiAgICByZXR1cm4ge1xuICAgICd1VGV4dHVyZUJhY2tUZXN0MCc6IHtcbiAgICAgICAgdHlwZTogJ3QnLFxuICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcbiAgICAgIH0sXG4gICAgICAndVRleHR1cmVCYWNrVGVzdDEnOiB7XG4gICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXG4gICAgICB9LFxuICAgICAgJ3VPcGFjaXR5MCc6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMS4wLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndU9wYWNpdHkxJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAxLjAsXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1VHlwZTAnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVR5cGUxJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VUcmFja01vdXNlJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VNb3VzZSc6IHtcbiAgICAgICAgdHlwZTogJ3YyJyxcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgICAgIHR5cGVHTFNMOiAndmVjMicsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBjb21wdXRlKCkge1xuICAgICAgICByZXR1cm4gYFxudmFyeWluZyB2ZWM0IHZQb3M7XG52YXJ5aW5nIHZlYzQgdlByb2plY3RlZENvb3JkcztcblxuLy9cbi8vIG1haW5cbi8vXG52b2lkIG1haW4oKSB7XG5cbiAgdlBvcyA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XG4gIHZQcm9qZWN0ZWRDb29yZHMgPSAgcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XG5cbn1cbiAgICAgICAgYDtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBzaGFkZXJzSW50ZXJwb2xhdGlvbiBmcm9tICcuL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uJztcblxuLyoqXG4gKiBMb2NhbGl6ZXIgZnJhZ21lbnQgc2hhZGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcblxuICAvKipcbiAgICogXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5fZnVuY3Rpb25zID0ge307XG4gICAgdGhpcy5fbWFpbiA9ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgZnVuY3Rpb25zKCkge1xuICAgIGlmKHRoaXMuX21haW4gPT09ICcnKSB7XG4gICAgICAvLyBpZiBtYWluIGlzIGVtcHR5LCBmdW5jdGlvbnMgY2FuIG5vdCBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgICAgIHRoaXMubWFpbigpO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgZm9yKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgIGNvbnRlbnQgKz0gdGhpcy5fZnVuY3Rpb25zW3Byb3BlcnR5XSArICdcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgdW5pZm9ybXMoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl91bmlmb3Jtcykge1xuICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1twcm9wZXJ0eV07XG4gICAgICBjb250ZW50ICs9IGB1bmlmb3JtICR7dW5pZm9ybS50eXBlR0xTTH0gJHtwcm9wZXJ0eX1gO1xuXG4gICAgICBpZih1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gYFske3VuaWZvcm0ubGVuZ3RofV1gO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9ICc7XFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIG1haW4oKSB7XG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XG4gICAgdGhpcy5fbWFpbiA9IGBcbnZvaWQgaW50ZXJzZWN0aW9uUHJvamVjdGlvbihcbiAgaW4gdmVjNCBwbGFuZSxcbiAgaW4gdmVjNCBzbGljZSxcbiAgb3V0IHZlYzMgaW50ZXJzZWN0aW9uUHJvamVjdGlvbil7XG5cbiAgICAgIHZlYzMgaW50ZXJzZWN0aW9uRGlyZWN0aW9uID0gbm9ybWFsaXplKGNyb3NzKHBsYW5lLnh5eiwgc2xpY2UueHl6KSk7XG4gICAgICB2ZWMzIGludGVyc2VjdGlvblBvaW50ID0gXG4gICAgICAgIGNyb3NzKGludGVyc2VjdGlvbkRpcmVjdGlvbixzbGljZS54eXopICogcGxhbmUudyArXG4gICAgICAgIGNyb3NzKHBsYW5lLnh5eiwgaW50ZXJzZWN0aW9uRGlyZWN0aW9uKSAqIHNsaWNlLnc7XG5cbiAgICAgIGludGVyc2VjdGlvblByb2plY3Rpb24gPVxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC54eXogK1xuICAgICAgICAoZG90KHZQb3MueHl6IC0gaW50ZXJzZWN0aW9uUG9pbnQsIGludGVyc2VjdGlvbkRpcmVjdGlvbilcbiAgICAgICAgICAqIGludGVyc2VjdGlvbkRpcmVjdGlvbik7XG5cbn1cblxudm9pZCBtYWluKHZvaWQpIHtcbiAgICAgIHZlYzQgYzEgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcbiAgICAgIHZlYzQgYzIgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcbiAgICAgIHZlYzQgYzMgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcblxuICAgICAgLy8gbG9jYWxpemVyICMxXG4gICAgICAvLyBtdXN0IGJlIG5vcm1hbGl6ZWQhXG4gICAgICBpZihsZW5ndGgodVBsYW5lMS54eXopID4gMC41KSB7XG4gICAgICAgIHZlYzMgcHJvamVjdGlvbjEgPSB2ZWMzKDEuKTtcbiAgICAgICAgaW50ZXJzZWN0aW9uUHJvamVjdGlvbihcbiAgICAgICAgICB1UGxhbmUxLFxuICAgICAgICAgIHVTbGljZSxcbiAgICAgICAgICBwcm9qZWN0aW9uMVxuICAgICAgICApO1xuXG4gICAgICAgIHZlYzQgcHJvakludGVyMSA9ICh2UHJvamVjdGlvblZpZXdNYXRyaXggKiB2ZWM0KHByb2plY3Rpb24xLCAxLikpO1xuICAgICAgICB2ZWMzIG5kYzEgPSBwcm9qSW50ZXIxLnh5eiAvIHByb2pJbnRlcjEudztcbiAgICAgICAgdmVjMiBzY3JlZW5TcGFjZTEgPSAobmRjMS54eSAqIC41ICsgLjUpICogdmVjMih1Q2FudmFzV2lkdGgsIHVDYW52YXNIZWlnaHQpO1xuXG4gICAgICAgIGZsb2F0IGQxID0gZGlzdGFuY2UoZ2xfRnJhZ0Nvb3JkLnh5LCBzY3JlZW5TcGFjZTEueHkpO1xuICAgICAgICBjMSA9IHZlYzQodVBsYW5lQ29sb3IxLCAxLiAtIHNtb290aHN0ZXAoLjUsIC43LCBkMSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2NhbGl6ZXIgIzJcbiAgICAgIGlmKGxlbmd0aCh1UGxhbmUyLnh5eikgPiAwLjUpIHtcbiAgICAgICAgdmVjMyBwcm9qZWN0aW9uMiA9IHZlYzMoMS4pO1xuICAgICAgICBpbnRlcnNlY3Rpb25Qcm9qZWN0aW9uKFxuICAgICAgICAgIHVQbGFuZTIsXG4gICAgICAgICAgdVNsaWNlLFxuICAgICAgICAgIHByb2plY3Rpb24yXG4gICAgICAgICk7XG5cbiAgICAgICAgdmVjNCBwcm9qSW50ZXIyID0gKHZQcm9qZWN0aW9uVmlld01hdHJpeCAqIHZlYzQocHJvamVjdGlvbjIsIDEuKSk7XG4gICAgICAgIHZlYzMgbmRjMiA9IHByb2pJbnRlcjIueHl6IC8gcHJvakludGVyMi53O1xuICAgICAgICB2ZWMyIHNjcmVlblNwYWNlMiA9IChuZGMyLnh5ICogLjUgKyAuNSkgKiB2ZWMyKHVDYW52YXNXaWR0aCwgdUNhbnZhc0hlaWdodCk7XG5cbiAgICAgICAgZmxvYXQgZDIgPSBkaXN0YW5jZShnbF9GcmFnQ29vcmQueHksIHNjcmVlblNwYWNlMi54eSk7XG4gICAgICAgIGMyID0gdmVjNCh1UGxhbmVDb2xvcjIsIDEuIC0gc21vb3Roc3RlcCguNSwgLjcsIGQyKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvY2FsaXplciAjM1xuICAgICAgaWYobGVuZ3RoKHVQbGFuZTMueHl6KSA+IDAuNSkge1xuICAgICAgICB2ZWMzIHByb2plY3Rpb24zID0gdmVjMygxLik7XG4gICAgICAgIGludGVyc2VjdGlvblByb2plY3Rpb24oXG4gICAgICAgICAgdVBsYW5lMyxcbiAgICAgICAgICB1U2xpY2UsXG4gICAgICAgICAgcHJvamVjdGlvbjNcbiAgICAgICAgKTtcblxuICAgICAgICB2ZWM0IHByb2pJbnRlcjMgPSAodlByb2plY3Rpb25WaWV3TWF0cml4ICogdmVjNChwcm9qZWN0aW9uMywgMS4pKTtcbiAgICAgICAgdmVjMyBuZGMzID0gcHJvakludGVyMy54eXogLyBwcm9qSW50ZXIzLnc7XG4gICAgICAgIHZlYzIgc2NyZWVuU3BhY2UzID0gKG5kYzMueHkgKiAuNSArIC41KSAqIHZlYzIodUNhbnZhc1dpZHRoLCB1Q2FudmFzSGVpZ2h0KTtcblxuICAgICAgICBmbG9hdCBkMyA9IGRpc3RhbmNlKGdsX0ZyYWdDb29yZC54eSwgc2NyZWVuU3BhY2UzLnh5KTtcbiAgICAgICAgYzMgPSB2ZWM0KHVQbGFuZUNvbG9yMywgMS4gLSBzbW9vdGhzdGVwKC41LCAuNywgZDMpKTtcbiAgICAgIH1cblxuICAgICAgdmVjMyBjb2xvck1peCA9IGMxLnh5eipjMS53ICsgYzIueHl6KmMyLncgKyBjMy54eXoqYzMudztcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3JNaXgsIG1heChtYXgoYzEudywgYzIudyksYzMudykpO1xufVxuICAgYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIGNvbXB1dGUoKSB7XG4gICAgbGV0IHNoYWRlckludGVycG9sYXRpb24gPSAnJztcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmlubGluZShhcmdzKSAvL3RydWUvZmFsc2VcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmZ1bmN0aW9ucyhhcmdzKVxuXG4gICAgcmV0dXJuIGBcbi8vIHVuaWZvcm1zXG4ke3RoaXMudW5pZm9ybXMoKX1cblxuLy8gdmFyeWluZyAoc2hvdWxkIGZldGNoIGl0IGZyb20gdmVydGV4IGRpcmVjdGx5KVxudmFyeWluZyB2ZWM0IHZQb3M7XG52YXJ5aW5nIG1hdDQgdlByb2plY3Rpb25WaWV3TWF0cml4O1xuXG4vLyB0YWlsb3JlZCBmdW5jdGlvbnNcbiR7dGhpcy5mdW5jdGlvbnMoKX1cblxuLy8gbWFpbiBsb29wXG4ke3RoaXMuX21haW59XG4gICAgICBgO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIHNoYWRlcnMvbG9jYWxpemVyL3VuaWZvcm1zXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICAvKipcbiAgICogU2hhZGVycyBkYXRhIHVuaWZvcm1zXG4gICAqL1xuICBzdGF0aWMgdW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICd1Q2FudmFzV2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDAuLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndUNhbnZhc0hlaWdodCc6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMC4sXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1U2xpY2UnOiB7XG4gICAgICAgIHR5cGU6ICd2NCcsXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWM0JyxcbiAgICAgIH0sXG4gICAgICAndVBsYW5lMSc6IHtcbiAgICAgICAgdHlwZTogJ3Y0JyxcbiAgICAgICAgdmFsdWU6IFswLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzQnLFxuICAgICAgfSxcbiAgICAgICd1UGxhbmVDb2xvcjEnOiB7XG4gICAgICAgIHR5cGU6ICd2MycsXG4gICAgICAgIHZhbHVlOiBbMS4wLCAxLjAsIDAuMF0sXG4gICAgICAgIHR5cGVHTFNMOiAndmVjMycsXG4gICAgICB9LFxuICAgICAgJ3VQbGFuZTInOiB7XG4gICAgICAgIHR5cGU6ICd2NCcsXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWM0JyxcbiAgICAgIH0sXG4gICAgICAndVBsYW5lQ29sb3IyJzoge1xuICAgICAgICB0eXBlOiAndjMnLFxuICAgICAgICB2YWx1ZTogWzEuMCwgMS4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzMnLFxuICAgICAgfSxcbiAgICAgICd1UGxhbmUzJzoge1xuICAgICAgICB0eXBlOiAndjQnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMF0sXG4gICAgICAgIHR5cGVHTFNMOiAndmVjNCcsXG4gICAgICB9LFxuICAgICAgJ3VQbGFuZUNvbG9yMyc6IHtcbiAgICAgICAgdHlwZTogJ3YzJyxcbiAgICAgICAgdmFsdWU6IFsxLjAsIDEuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWMzJyxcbiAgICAgIH0sXG5cbiAgICB9O1xuICB9XG59XG4iLCIvKipcbiAqIFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKi9cbiAgICBjb21wdXRlKCkge1xuICAgICAgICByZXR1cm4gYFxudmFyeWluZyB2ZWM0IHZQb3M7XG52YXJ5aW5nIG1hdDQgdlByb2plY3Rpb25WaWV3TWF0cml4O1xuXG4vL1xuLy8gbWFpblxuLy9cbnZvaWQgbWFpbigpIHtcblxuICB2UG9zID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcbiAgdlByb2plY3Rpb25WaWV3TWF0cml4ID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXg7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xuXG59XG4gICAgICAgIGA7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgc2hhZGVyc0ludGVycG9sYXRpb24gZnJvbSAnLi9pbnRlcnBvbGF0aW9uL3NoYWRlcnMuaW50ZXJwb2xhdGlvbic7XG5pbXBvcnQgc2hhZGVyc0ludGVyc2VjdEJveCBmcm9tICcuL2hlbHBlcnMvc2hhZGVycy5oZWxwZXJzLmludGVyc2VjdEJveCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNGcmFnbWVudCB7XG5cbiAgLy8gcGFzcyB1bmlmb3JtcyBvYmplY3RcbiAgY29uc3RydWN0b3IodW5pZm9ybXMpIHtcbiAgICB0aGlzLl91bmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgIHRoaXMuX2Z1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMuX21haW4gPSAnJztcbiAgfVxuXG4gIGZ1bmN0aW9ucygpIHtcbiAgICBpZih0aGlzLl9tYWluID09PSAnJykge1xuICAgICAgLy8gaWYgbWFpbiBpcyBlbXB0eSwgZnVuY3Rpb25zIGNhbiBub3QgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gICAgICB0aGlzLm1haW4oKTtcbiAgICB9XG5cbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX2Z1bmN0aW9ucykge1xuICAgICAgY29udGVudCArPSB0aGlzLl9mdW5jdGlvbnNbcHJvcGVydHldICsgJ1xcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICB1bmlmb3JtcygpIHtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX3VuaWZvcm1zKSB7XG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMuX3VuaWZvcm1zW3Byb3BlcnR5XTtcbiAgICAgIGNvbnRlbnQgKz0gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGVHTFNMfSAke3Byb3BlcnR5fWA7XG5cbiAgICAgIGlmKHVuaWZvcm0gJiYgdW5pZm9ybS5sZW5ndGgpIHtcbiAgICAgICAgY29udGVudCArPSBgWyR7dW5pZm9ybS5sZW5ndGh9XWA7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gJztcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgbWFpbigpIHtcbiAgICAvLyBuZWVkIHRvIHByZS1jYWxsIG1haW4gdG8gZmlsbCB1cCB0aGUgZnVuY3Rpb25zIGxpc3RcbiAgICB0aGlzLl9tYWluID0gYFxudm9pZCBnZXRJbnRlbnNpdHkoaW4gdmVjMyBkYXRhQ29vcmRpbmF0ZXMsIG91dCBmbG9hdCBpbnRlbnNpdHksIG91dCB2ZWMzIGdyYWRpZW50KXtcblxuICB2ZWM0IGRhdGFWYWx1ZSA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xuICAke3NoYWRlcnNJbnRlcnBvbGF0aW9uKHRoaXMsICdkYXRhQ29vcmRpbmF0ZXMnLCAnZGF0YVZhbHVlJywgJ2dyYWRpZW50Jyl9XG5cbiAgaW50ZW5zaXR5ID0gZGF0YVZhbHVlLnI7XG5cbiAgLy8gcmVzY2FsZS9zbG9wZVxuICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkqdVJlc2NhbGVTbG9wZUludGVyY2VwdFswXSArIHVSZXNjYWxlU2xvcGVJbnRlcmNlcHRbMV07XG4gIC8vIHdpbmRvdyBsZXZlbFxuICBmbG9hdCB3aW5kb3dNaW4gPSB1V2luZG93Q2VudGVyV2lkdGhbMF0gLSB1V2luZG93Q2VudGVyV2lkdGhbMV0gKiAwLjU7XG4gIGludGVuc2l0eSA9ICggaW50ZW5zaXR5IC0gd2luZG93TWluICkgLyB1V2luZG93Q2VudGVyV2lkdGhbMV07XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGNvbnN0IGludCBtYXhTdGVwcyA9IDEwMjQ7XG5cbiAgLy8gdGhlIHJheVxuICB2ZWMzIHJheU9yaWdpbiA9IGNhbWVyYVBvc2l0aW9uO1xuICB2ZWMzIHJheURpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2UG9zLnh5eiAtIHJheU9yaWdpbik7XG5cbiAgLy8gdGhlIEF4ZS1BbGlnbmVkIEItQm94XG4gIHZlYzMgQUFCQk1pbiA9IHZlYzModVdvcmxkQkJveFswXSwgdVdvcmxkQkJveFsyXSwgdVdvcmxkQkJveFs0XSk7XG4gIHZlYzMgQUFCQk1heCA9IHZlYzModVdvcmxkQkJveFsxXSwgdVdvcmxkQkJveFszXSwgdVdvcmxkQkJveFs1XSk7XG5cbiAgLy8gSW50ZXJzZWN0aW9uIHJheS9iYm94XG4gIGZsb2F0IHROZWFyLCB0RmFyO1xuICBib29sIGludGVyc2VjdCA9IGZhbHNlO1xuICAke3NoYWRlcnNJbnRlcnNlY3RCb3guYXBpKHRoaXMsICdyYXlPcmlnaW4nLCAncmF5RGlyZWN0aW9uJywgJ0FBQkJNaW4nLCAnQUFCQk1heCcsICd0TmVhcicsICd0RmFyJywgJ2ludGVyc2VjdCcpfVxuICBpZiAodE5lYXIgPCAwLjApIHROZWFyID0gMC4wO1xuXG4gIC8vIGluaXQgdGhlIHJheSBtYXJjaGluZ1xuICBmbG9hdCB0Q3VycmVudCA9IHROZWFyO1xuICBmbG9hdCB0U3RlcCA9ICh0RmFyIC0gdE5lYXIpIC8gZmxvYXQodVN0ZXBzKTtcbiAgdmVjNCBhY2N1bXVsYXRlZENvbG9yID0gdmVjNCgwLjApO1xuICBmbG9hdCBhY2N1bXVsYXRlZEFscGhhID0gMC4wO1xuXG4gIGZvcihpbnQgcmF5U3RlcCA9IDA7IHJheVN0ZXAgPCBtYXhTdGVwczsgcmF5U3RlcCsrKXtcbiAgICB2ZWMzIGN1cnJlbnRQb3NpdGlvbiA9IHJheU9yaWdpbiArIHJheURpcmVjdGlvbiAqIHRDdXJyZW50O1xuICAgIC8vIHNvbWUgbm9uLWxpbmVhciBGVU5cbiAgICAvLyBzb21lIG9jY2x1c2lvbiBpc3N1ZSB0byBiZSBmaXhlZFxuICAgIHZlYzMgdHJhbnNmb3JtZWRQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbjsgLy90cmFuc2Zvcm1Qb2ludChjdXJyZW50UG9zaXRpb24sIHVBbXBsaXR1ZGUsIHVGcmVxdWVuY2UpO1xuICAgIC8vIHdvcmxkIHRvIGRhdGEgY29vcmRpbmF0ZXNcbiAgICAvLyByb3VuZGluZyB0cmlja1xuICAgIC8vIGZpcnN0IGNlbnRlciBvZiBmaXJzdCB2b3hlbCBpbiBkYXRhIHNwYWNlIGlzIENFTlRFUkVEIG9uICgwLDAsMClcbiAgICB2ZWM0IGRhdGFDb29yZGluYXRlc1JhdyA9IHVXb3JsZFRvRGF0YSAqIHZlYzQodHJhbnNmb3JtZWRQb3NpdGlvbiwgMS4wKTtcbiAgICB2ZWMzIGN1cnJlbnRWb3hlbCA9IHZlYzMoZGF0YUNvb3JkaW5hdGVzUmF3LngsIGRhdGFDb29yZGluYXRlc1Jhdy55LCBkYXRhQ29vcmRpbmF0ZXNSYXcueik7XG4gICAgZmxvYXQgaW50ZW5zaXR5ID0gMC4wO1xuICAgIHZlYzMgZ3JhZGllbnQgPSB2ZWMzKDAuLCAwLiwgMC4pO1xuICAgIGdldEludGVuc2l0eShjdXJyZW50Vm94ZWwsIGludGVuc2l0eSwgZ3JhZGllbnQpO1xuXG4gICAgdmVjNCBjb2xvclNhbXBsZTtcbiAgICBmbG9hdCBhbHBoYVNhbXBsZTtcbiAgICBpZih1THV0ID09IDEpe1xuICAgICAgdmVjNCBjb2xvckZyb21MVVQgPSB0ZXh0dXJlMkQoIHVUZXh0dXJlTFVULCB2ZWMyKCBpbnRlbnNpdHksIDEuMCkgKTtcbiAgICAgIC8vIDI1NiBjb2xvcnNcbiAgICAgIGNvbG9yU2FtcGxlID0gY29sb3JGcm9tTFVUO1xuICAgICAgYWxwaGFTYW1wbGUgPSBjb2xvckZyb21MVVQuYTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgIGFscGhhU2FtcGxlID0gaW50ZW5zaXR5O1xuICAgICAgY29sb3JTYW1wbGUuciA9IGNvbG9yU2FtcGxlLmcgPSBjb2xvclNhbXBsZS5iID0gaW50ZW5zaXR5ICogYWxwaGFTYW1wbGU7XG4gICAgfVxuXG4gICAgYWxwaGFTYW1wbGUgPSBhbHBoYVNhbXBsZSAqIHVBbHBoYUNvcnJlY3Rpb247XG4gICAgYWxwaGFTYW1wbGUgKj0gKDEuMCAtIGFjY3VtdWxhdGVkQWxwaGEpO1xuXG4gICAgYWNjdW11bGF0ZWRDb2xvciArPSBhbHBoYVNhbXBsZSAqIGNvbG9yU2FtcGxlO1xuICAgIGFjY3VtdWxhdGVkQWxwaGEgKz0gYWxwaGFTYW1wbGU7XG5cbiAgICB0Q3VycmVudCArPSB0U3RlcDtcblxuICAgIGlmKHRDdXJyZW50ID4gdEZhciB8fCBhY2N1bXVsYXRlZEFscGhhID49IDEuMCApIGJyZWFrO1xuICB9XG5cbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChhY2N1bXVsYXRlZENvbG9yLnh5eiwgYWNjdW11bGF0ZWRBbHBoYSk7XG59XG4gICBgO1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uaW5saW5lKGFyZ3MpIC8vdHJ1ZS9mYWxzZVxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXG5cbiAgICByZXR1cm4gYFxuLy8gdW5pZm9ybXNcbiR7dGhpcy51bmlmb3JtcygpfVxuXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xuXG4vLyB0YWlsb3JlZCBmdW5jdGlvbnNcbiR7dGhpcy5mdW5jdGlvbnMoKX1cblxuLy8gbWFpbiBsb29wXG4ke3RoaXMuX21haW59XG4gICAgICBgO1xuICAgIH1cblxufVxuIiwiXG4vKipcbiAqIEBtb2R1bGUgc2hhZGVycy9kYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNVbmlmb3JtIHtcbiAgc3RhdGljIHVuaWZvcm1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAndVRleHR1cmVTaXplJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VUZXh0dXJlQ29udGFpbmVyJzoge1xuICAgICAgICB0eXBlOiAndHYnLFxuICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgbGVuZ3RoOiA3LFxuICAgICAgfSxcbiAgICAgICd1RGF0YURpbWVuc2lvbnMnOiB7XG4gICAgICAgIHR5cGU6ICdpdicsXG4gICAgICAgIHZhbHVlOiBbMCwgMCwgMF0sXG4gICAgICAgIHR5cGVHTFNMOiAnaXZlYzMnLFxuICAgICAgfSxcbiAgICAgICd1V29ybGRUb0RhdGEnOiB7XG4gICAgICAgIHR5cGU6ICdtNCcsXG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpLFxuICAgICAgICB0eXBlR0xTTDogJ21hdDQnLFxuICAgICAgfSxcbiAgICAgICd1V2luZG93Q2VudGVyV2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmdjEnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICAgIGxlbmd0aDogMixcbiAgICAgIH0sXG4gICAgICAndVJlc2NhbGVTbG9wZUludGVyY2VwdCc6IHtcbiAgICAgICAgdHlwZTogJ2Z2MScsXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgfSxcbiAgICAgICd1TnVtYmVyT2ZDaGFubmVscyc6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1Qml0c0FsbG9jYXRlZCc6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogOCxcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1SW52ZXJ0Jzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VMdXQnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVRleHR1cmVMVVQnOiB7XG4gICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXG4gICAgICB9LFxuICAgICAgJ3VQaXhlbFR5cGUnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVBhY2tlZFBlclBpeGVsJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VJbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VXb3JsZEJCb3gnOiB7XG4gICAgICAgIHR5cGU6ICdmdjEnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgICAgbGVuZ3RoOiA2LFxuICAgICAgfSxcbiAgICAgICd1U3RlcHMnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDI1NixcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1QWxwaGFDb3JyZWN0aW9uJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAwLjUsXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1RnJlcXVlbmNlJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1QW1wbGl0dWRlJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzVmVydGV4IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgfVxuXG4gICAgY29tcHV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGBcbnZhcnlpbmcgdmVjNCB2UG9zO1xuXG4vL1xuLy8gbWFpblxuLy9cbnZvaWQgbWFpbigpIHtcblxuICB2UG9zID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XG5cbn1cbiAgICAgICAgYDtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XG5pbXBvcnQgV2lkZ2V0c0hhbmRsZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuaGFuZGxlJztcblxuLyoqXG4gKiBAbW9kdWxlIHdpZGdldHMvaGFuZGxlXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpZGdldHNBbm5vdGF0aW9uIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKHRhcmdldE1lc2gsIGNvbnRyb2xzLCBjYW1lcmEsIGNvbnRhaW5lcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXG4gICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgaWYodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb247XG4gICAgfVxuXG4gICAgLy8gbWVzaCBzdHVmZlxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICAvLyBkb20gc3R1ZmZcbiAgICB0aGlzLl9saW5lID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgdGhpcy5fY29uZSA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWx0ZXh0ID0gbnVsbDtcblxuICAgIC8vYm9vbGVhbnNcbiAgICB0aGlzLl9hbHJlYWR5Y3JlYXRlZCA9IG51bGw7IC8vYm9vbCB0aGF0IHR1cm5zIHRydWUgd2hlbiB0aGUgdXNlciBlbnRlciB0aGUgbmFtZSBvZiB0aGUgbGFiZWxcbiAgICB0aGlzLl9tb3ZpbmdsYWJlbCA9IG51bGw7IC8vYm9vbCB0aGF0IHR1cm5zIHRydWUgd2hlbiB0aGUgbGFiZWwgaXMgbW92aW5nIHdpdGggdGhlIG1vdXNlXG4gICAgdGhpcy5fbGFiZWxtb3ZlZCA9IGZhbHNlOyAvL2Jvb2wgdGhhdCB0dXJucyB0cnVlIG9uY2UgdGhlIGxhYmVsIGlzIG1vdmVkIGJ5IHRoZSB1c2VyIChhdCBsZWFzdCBvbmNlKVxuXG4gICAgdGhpcy5fbGFiZWxob3ZlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2hvdmVyZWQgPSB0cnVlO1xuXG4gICAgLy92YXJcbiAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueCA9IG51bGw7IC8vcG9zaXRpb24gb2YgbGFiZWwgKHRvcCBsZWZ0IGNvcm5lcilcbiAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueSA9IG51bGw7IC8vcG9zaXRpb24gb2YgbGFiZWwgKHRvcCBsZWZ0IGNvcm5lcilcbiAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHggPSAwOyAvL2RpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSBwb3NpdGlvbiBpbiB0aGUgbGFiZWwgYW5kIHBvc2l0aW9uIG9mIGxhYmVsICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx5ID0gMDsgLy9kaWZmZXJlbmNlIGJldHdlZW4gbW91c2UgcG9zaXRpb24gaW4gdGhlIGxhYmVsIGFuZCBwb3NpdGlvbiBvZiBsYWJlbCAodG9wIGxlZnQgY29ybmVyKVxuXG4gICAgLy8gYWRkIGhhbmRsZXNcbiAgICB0aGlzLl9oYW5kbGVzID0gW107XG5cbiAgICBzZWxmID0gdGhpcztcblxuICAgIC8vIGZpcnN0IGhhbmRsZVxuICAgIGxldCBmaXJzdEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgZmlyc3RIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xuXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKGZpcnN0SGFuZGxlKTtcblxuICAgIGxldCBzZWNvbmRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgIHNlY29uZEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcbiAgICBzZWNvbmRIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgLy8gYWN0aXZlIGFuZCB0cmFja2luZyBtaWdodCBiZSByZWR1bmRhbnRcbiAgICBzZWNvbmRIYW5kbGUuYWN0aXZlID0gdHJ1ZTtcbiAgICBzZWNvbmRIYW5kbGUudHJhY2tpbmcgPSB0cnVlO1xuICAgIHRoaXMuYWRkKHNlY29uZEhhbmRsZSk7XG5cbiAgICB0aGlzLl9oYW5kbGVzLnB1c2goc2Vjb25kSGFuZGxlKTtcblxuICAgIC8vIENyZWF0ZSBhbm5vdGF0aW9uXG5cbiAgICB0aGlzLmNyZWF0ZSgpO1xuXG4gICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Ib3ZlcmxhYmVsID0gdGhpcy5vbkhvdmVybGFiZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm5vdG9uSG92ZXJsYWJlbCA9IHRoaXMubm90b25Ib3ZlcmxhYmVsLmJpbmQodGhpcyk7ICBcbiAgICB0aGlzLmNoYW5nZWxhYmVsdGV4dCA9IHRoaXMuY2hhbmdlbGFiZWx0ZXh0LmJpbmQodGhpcyk7IFxuICAgIHRoaXMubW92ZWxhYmVsID0gdGhpcy5tb3ZlbGFiZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm5vdG1vdmVsYWJlbCA9IHRoaXMubm90bW92ZWxhYmVsLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2xhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXJsYWJlbCk7XG4gICAgdGhpcy5fbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMubm90b25Ib3ZlcmxhYmVsKTtcbiAgICB0aGlzLl9sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuY2hhbmdlbGFiZWx0ZXh0KTtcbiAgICB0aGlzLl9sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdmVsYWJlbCk7XG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm5vdG1vdmVsYWJlbCk7XG5cbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG4gIH1cblxuICBtb3ZlbGFiZWwoKSB7IC8vZnVuY3Rpb24gY2FsbGVkIHdoZW4gbW91c2Vkb3duXG4gICAgaWYgKHRoaXMuX2xhYmVsaG92ZXJlZCA9IHRydWUpeyAvL2lmIGxhYmVsIGhvYmVyZWQgd2Ugd2lsbCBtb3ZlIHRoZSBsYWJlbFxuICAgICAgICB0aGlzLl9tb3ZpbmdsYWJlbCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xhYmVsbW92ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbW91c2V5ID0gIC0gKC1ldmVudC5jbGllbnRZICsgdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCk7XG4gICAgICAgIGxldCBtb3VzZXggPSBldmVudC5jbGllbnRYO1xuICAgICAgICAvL2NhbGN1bGF0ZSBkaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbCAoZGlmZmVyZW5jZSBiZXR3ZWVuIHJlZiBwb3NpdGlvbiBvZiB0aGUgbGFiZWwgKHRvcC1sZWZ0IGNvcm5lcikgYW5kIG1vdXNlIHBvc2l0aW9uIGluIHRoZSBsYWJlbClcbiAgICAgICAgdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx4ID0gTWF0aC5hYnMoTWF0aC5hYnMobW91c2V4KSAtIE1hdGguYWJzKHRoaXMuX2xhYmVscG9zaXRpb254KSk7XG4gICAgICAgIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseSA9IE1hdGguYWJzKE1hdGguYWJzKG1vdXNleSkgLSBNYXRoLmFicyh0aGlzLl9sYWJlbHBvc2l0aW9ueSkpO1xuICAgIH1cbiAgfVxuXG4gIG5vdG1vdmVsYWJlbCgpIHsgLy90aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIG1vdXNldXBcbiAgICB0aGlzLl9tb3ZpbmdsYWJlbCA9IGZhbHNlO1xuICAgIHRoaXMuX2hhbmRsZXNbMF0uX2NvbnRyb2xzLmVuYWJsZWQgPSB0cnVlOyAvL21vdmUgdGhlIGNhbWVyYSB3aGVuIG1vdXNlZG93biBhbmQgbW91c2Vkb3duIGFnYWluXG4gICAgdGhpcy5faGFuZGxlc1sxXS5fY29udHJvbHMuZW5hYmxlZCA9IHRydWU7IFxuICAgIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseCA9IDA7IC8vcmVzdGFydCB0aGUgdmFsdWUgb2YgZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWwuIE5lY2Vzc2FyeT9cbiAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHkgPSAwO1xuICB9XG5cbiAgb25Ib3ZlcmxhYmVsKCkgeyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gbW91c2UgZW50ZXJzIHRoZSBsYWJlbCB3aXRoIFwibW91c2VlbnRlclwiIGV2ZW50XG4gICAgdGhpcy5fbGFiZWxob3ZlcmVkID0gdHJ1ZTtcbiAgfVxuIFxuICBub3RvbkhvdmVybGFiZWwoKSB7IC8vdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBtb3VzZSBsZWF2ZXMgdGhlIGxhYmVsIHdpdGggXCJtb3VzZWxlYXZlXCIgZXZlbnRcbiAgICB0aGlzLl9sYWJlbGhvdmVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIG9uTW92ZShldnQpIHtcblxuICAgIGlmICh0aGlzLl9tb3ZpbmdsYWJlbCA9PSB0cnVlKXtcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS5fY29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLl9jb250cm9scy5lbmFibGVkID0gZmFsc2U7IFxuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5faGFuZGxlc1swXS5vbk1vdmUoZXZ0KTtcbiAgICB0aGlzLl9oYW5kbGVzWzFdLm9uTW92ZShldnQpO1xuXG4gICAgdGhpcy5faG92ZXJlZCA9IHRoaXMuX2hhbmRsZXNbMF0uaG92ZXJlZCB8fCB0aGlzLl9oYW5kbGVzWzFdLmhvdmVyZWQgfHwgdGhpcy5fbGFiZWxob3ZlcmVkO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICB9XG5cblxuICBvblN0YXJ0KGV2dCkge1xuXG4gICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faGFuZGxlc1swXS5vblN0YXJ0KGV2dCk7XG4gICAgdGhpcy5faGFuZGxlc1sxXS5vblN0YXJ0KGV2dCk7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuXG4gIHNldGxhYmVsdGV4dCgpIHtcbiAgICB0aGlzLl9sYWJlbHRleHQgPSBwcm9tcHQoXCJQbGVhc2UgZW50ZXIgdGhlIG5hbWUgb2YgdGhlIGxhYmVsXCIsIFwiXCIpOyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY3JlYXRlcyBhIG5ldyBhcnJvd1xuICAgIGlmICh0eXBlb2YgdGhpcy5fbGFiZWx0ZXh0ID09ICdzdHJpbmcnKXsgLy9hdm9pZCBlcnJvclxuICAgICAgICBpZiAodGhpcy5fbGFiZWx0ZXh0Lmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICcnOyAvL2luIGNzcyBhbiBlbXB0eSBzdHJpbmcgaXMgdXNlZCB0byByZXZlcnQgZGlzcGxheT1ub25lLiBTaG93IHRoZSBsYWJlbCBvbmNlIHdlIGtub3cgdGhlIGNvbnRlbnRcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWwgb25jZSB3ZSBrbm93IHRoZSBjb250ZW50XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxuICAgICAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlbGFiZWx0ZXh0KCkgeyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZG9lcyBkb3VibGUgY2xpY2sgaW4gdGhlIGxhYmVsXG4gICAgdGhpcy5fbGFiZWx0ZXh0ID0gcHJvbXB0KFwiUGxlYXNlIGVudGVyIG5ldyBuYW1lIG9mIHRoZSBsYWJlbFwiLCB0aGlzLl9sYWJlbC5pbm5lckhUTUwpO1xuICAgIGlmICh0eXBlb2YgdGhpcy5fbGFiZWx0ZXh0ID09ICdzdHJpbmcnKXsgLy9hdm9pZCBlcnJvclxuICAgICAgICBpZiAodGhpcy5fbGFiZWx0ZXh0Lmxlbmd0aCA+IDApeyBcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLmlubmVySFRNTCA9IHRoaXMuX2xhYmVsdGV4dDtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWxcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWxcbiAgICAgICAgfWVsc2V7IC8vIGlmIHRoZSBsZW5ndGggaXMgMCB0aGUgdXNlciBwcmVzc2VkIENhbmNlbFxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxuICAgICAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25FbmQoZXZ0KSB7XG4gICAgLy8gRmlyc3QgSGFuZGxlXG4gICAgdGhpcy5faGFuZGxlc1swXS5vbkVuZChldnQpO1xuXG4gICAgLy8gU2Vjb25kIEhhbmRsZVxuICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0ub25FbmQoZXZ0KTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fYWxyZWFkeWNyZWF0ZWQgIT0gdHJ1ZSl7XG4gICAgICB0aGlzLnNldGxhYmVsdGV4dCgpO1xuICAgICAgc2VsZi5fYWxyZWFkeWNyZWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFN0YXRlIG9mIGFubm90YXRpb24gd2lkZ2V0XG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcy5faGFuZGxlc1swXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1sxXS5hY3RpdmU7XG4gICAgdGhpcy51cGRhdGUoKTtcblxuICB9XG5cblxuICBjcmVhdGUoKSB7XG4gICAgdGhpcy5jcmVhdGVNZXNoKCk7XG4gICAgdGhpcy5jcmVhdGVET00oKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XG5cbiAgICAvLyBtZXNoIHN0dWZmXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcbiAgICB0aGlzLnVwZGF0ZU1lc2hQb3NpdGlvbigpO1xuXG4gICAgLy8gRE9NIHN0dWZmXG4gICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgfVxuXG4gIGNyZWF0ZU1lc2goKSB7XG4gICAgLy8gZ2VvbWV0cnlcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uKTtcbiAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbik7XG5cbiAgICAvLyBtYXRlcmlhbFxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcblxuICAgIC8vIG1lc2hcbiAgICB0aGlzLl9tZXNobGluZSA9IG5ldyBUSFJFRS5MaW5lKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgdGhpcy5fbWVzaGxpbmUudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvLyBhZGQgaXQhXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaGxpbmUpO1xuXG4gICAgLy9jcmVhdGUgY29uZSBhbmQgYWRkIGl0XG4gICAgdGhpcy5fY29uZWdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDIsIDEwICk7XG4gICAgdGhpcy5fY29uZWdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLTUsIDAgKTtcbiAgICB0aGlzLl9jb25lZ2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xuICAgIHRoaXMuX2NvbmUgPSBuZXcgVEhSRUUuTWVzaCggdGhpcy5fY29uZWdlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCApO1xuICAgIHRoaXMuX2NvbmUudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5hZGQodGhpcy5fY29uZSk7XG5cbiAgfVxuXG4gIHVwZGF0ZU1lc2hDb2xvcigpIHtcbiAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVNZXNoUG9zaXRpb24oKSB7XG4gICAgaWYodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRE9NKCkge1xuICAgIC8vIGFkZCBsaW5lIVxuICAgIHRoaXMuX2xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xuICAgIHRoaXMuX2xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2xpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgdGhpcy5fbGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XG4gICAgdGhpcy5fbGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JzsvLzJcbiAgICB0aGlzLl9saW5lLnN0eWxlLndpZHRoID0gJzNweCc7Ly8zXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xpbmUpO1xuXG4gICAgLy8gYWRkIGRhc2ggbGluZVxuICAgIHRoaXMuX2Rhc2hsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGFzaGxpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkYXNobGluZScpO1xuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyVG9wID0gJzIuNXB4IGRhc2hlZCAjRjlGOUY5JztcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9ICc1MCUnO1xuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Rhc2hsaW5lKTtcblxuICAgIC8vIGFkZCBsYWJlbCFcbiAgICB0aGlzLl9sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnV1aWQpO1xuICAgIHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGFiZWwnKTtcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICNGOUY5RjknO1xuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcbiAgICAvLyB0aGlzLl9sYWJlbC5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgdGhpcy5fbGFiZWwuc3R5bGUuY29sb3IgPSAnIzM1MzUzNSc7XG4gICAgdGhpcy5fbGFiZWwuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xuICAgIHRoaXMuX2xhYmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICB0aGlzLl9sYWJlbC5pbm5lckhUTUwgPSAnSGVsbG8sIHdvcmxkISc7XG4gICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGFiZWwpO1xuXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xuICB9XG5cblxuICB1cGRhdGVET01Qb3NpdGlvbigpIHtcblxuICAgIGNvbnNvbGUubG9nKCdmdW5jdGlvbiB1cGRhdGVET01Qb3NpdGlvbicpO1xuICAgIC8vIHVwZGF0ZSBhbm5vdGF0aW9uIGxpbmVzIGFuZCB0ZXh0IVxuICAgIGxldCB4MSA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueDtcbiAgICBsZXQgeTEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgbGV0IHgyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54O1xuICAgIGxldCB5MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueTtcblxuICAgIGxldCB4MCA9IHgxICsgKHgyIC0geDEpLzI7XG4gICAgbGV0IHkwID0geTEgKyAoeTIgLSB5MSkvMjtcblxuICAgIGxldCBsZW5ndGggPSBNYXRoLnNxcnQoKHgxLXgyKSooeDEteDIpICsgKHkxLXkyKSooeTEteTIpKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTsgLy9yZXN1bHQgaW4gZGVnXG5cbiAgICBsZXQgcG9zWSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgIC8vIHVwZGF0ZSBsaW5lXG4gICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCR7cG9zWX1weCwgMClgO1xuICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xuXG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aCArICdweCc7XG5cblxuICAgIC8vIHVwZGF0ZSBsYWJlbCBwb3NpdGlvblxuICAgIHZhciBtb3VzZXggPSAwO1xuICAgIHZhciBtb3VzZXkgPSAwO1xuXG4gICAgbGV0IHBvc1kwO1xuXG4gICAgcG9zWTAgPSB5MCAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0aGlzLl9sYWJlbC5vZmZzZXRIZWlnaHQvMjtcbiAgICB4MCAtPSB0aGlzLl9sYWJlbC5vZmZzZXRXaWR0aC8yO1xuXG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG5cbiAgICBpZiAodGhpcy5fbGFiZWxtb3ZlZCA9PSBmYWxzZSl7IC8vaWYgdGhlIHVzZXIgaGFzbnQgbW92ZWQgdGhlIGxhYmVsLCB0aGUgcG9zaXRpb24gaXMgZGVmaW5lZCBieSB0aGUgcG9zaXRpb24gb2YgdGhlIGFycm93XG4gICAgICAgIGxldCB0cmFuc2Zvcm0yID0gYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MCl9cHgsJHtNYXRoLnJvdW5kKHBvc1kwKX1weCwgMClgO1xuICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0yO1xuICAgICAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueCA9IE1hdGgucm91bmQoeDApO1xuICAgICAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueSA9IE1hdGgucm91bmQocG9zWTApO1xuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuX21vdmluZ2xhYmVsKSB7IC8vaWYgdGhlIHVzZXIgaGFzIG1vdmVkIHRoZSBsYWJlbCwgdGhlIHBvc2l0aW9uIGlzIGRlZmluZWQgYnkgdGhlIG1vdXNlXG4gICAgICAgIG1vdXNleCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIG1vdXNleSA9ICAtKC1ldmVudC5jbGllbnRZICsgdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCk7XG4gICAgICAgIHRoaXMuX2xhYmVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke21vdXNleCAtIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseH1weCwke21vdXNleSAtIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseX1weCwgMClgOyBcbiAgICAgICAgLy93ZSB1c2UgZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWwgdG8gY2hlY2sgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGluIHRoZSBsYWJlbCBhbmQgdGhlIHJlZmVyZW5jZSBwb3NpdGlvbiBvZiB0aGUgbGFiZWwgKHRvcC1sZWZ0IGNvcm5lcilcbiAgICAgICAgdGhpcy5fbGFiZWxwb3NpdGlvbnggPSBtb3VzZXggLSB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHg7XG4gICAgICAgIHRoaXMuX2xhYmVscG9zaXRpb255ID0gbW91c2V5IC0gdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx5O1xuICAgIH1cblxuICAgIC8vdXBkYXRlIGNvbmVcbiAgICBsZXQgdzAgPSB0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb247XG4gICAgbGV0IHcxID0gdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uO1xuXG4gICAgLy9wb3NpdGlvbiBhbmQgcm90YXRpb24gb2YgY29uZVxuICAgIHRoaXMuX2NvbmUucG9zaXRpb24uc2V0KHcxLngsdzEueSx3MS56KTtcbiAgICB0aGlzLl9jb25lLmxvb2tBdCh3MCk7XG5cbiAgICAvLyB1cGRhdGUgZGFzaCBsaW5lXG5cbiAgICAvL2NhbGN1bGF0ZSB0aGUgcGxhY2UgaW4gdGhlIGxhYmVsOiBjZW50ZXIgb2YgdGhlIGxhYmVsXG4gICAgeDEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLng7XG4gICAgeTEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgeDIgPSB0aGlzLl9sYWJlbHBvc2l0aW9ueDtcbiAgICB5MiA9IHRoaXMuX2xhYmVscG9zaXRpb255ICsgdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDsgLy9yZXZlcnQgdGhlIG9wZXJhdGlvbiBpbiAnbW91c2V5JyB0byBnZXQgdGhlIHByZXZpb3VzIGV2ZW50WVxuXG4gICAgLy9nZXQgdGhlIHNpemUgb2YgdGhlIGxhYmVsIHNvIHdlIGNhbiBwbGFjZSB0aGUgZGFzaGVkIGxpbmUgaW4gdGhlIGNlbnRlciBvZiBpdFxuICAgIHZhciBsYWJlbGhlaWdodCA9IHRoaXMuX2xhYmVsLm9mZnNldEhlaWdodDtcbiAgICB2YXIgbGFiZWx3aWR0aCA9IHRoaXMuX2xhYmVsLm9mZnNldFdpZHRoO1xuXG4gICAgdmFyIGNlbnRlcmxhYmVseCA9IDA7XG4gICAgdmFyIGNlbnRlcmxhYmVseSA9IDA7XG5cbiAgICBpZiAoaXNGaW5pdGUobGFiZWx3aWR0aCkgJiYgaXNGaW5pdGUobGFiZWxoZWlnaHQpKXsgLy9pZiB0aGUgZXh0cmFjdGlvbiBoYXMgYmVlbiBzdWNjZXNmdWxsLCB3ZSBjYWxjdWxhdGUgdGhlIGNlbnRlciBvZiB0aGUgbGFiZWwgd2l0aCB0b3RhbCBzaXplXG4gICAgICAgIGNlbnRlcmxhYmVseCA9IGxhYmVsd2lkdGgvMjtcbiAgICAgICAgY2VudGVybGFiZWx5ID0gbGFiZWxoZWlnaHQvMjtcbiAgICB9XG5cbiAgICB4MiArPSBjZW50ZXJsYWJlbHg7XG4gICAgeTIgKz0gY2VudGVybGFiZWx5O1xuXG4gICAgLy9jYWxjdWxhdGUgdGhlIHBsYWNlIGluIHRoZSBhcnJvdzogY2xvc2VzdCBwYXJ0IG9mIHRoZSBsaW5lIHRvIHBsYWNlIHRoZSBkYXNoZWQgbGluZVxuICAgIHZhciB4MV90YWlsID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54OyAvL2ZpcnN0IHBvc2l0aW9uOiB0YWlsIG9mIGFycm93XG4gICAgdmFyIHkxX3RhaWwgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgdmFyIHgxX2JvZHkgPSAodGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54ICsgdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54KS8yOyAvL3NlY29uZCBwb3NpdGlvbjogY2VudGVyIG9mIGFycm93XG4gICAgdmFyIHkxX2JvZHkgPSAodGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55ICsgdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi55KS8yO1xuICAgIHZhciB4MV9ub3NlID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54OyAvL3RoaXJkIHBvc2l0aW9uOiBwZWFrIG9mIGFycm93XG4gICAgdmFyIHkxX25vc2UgPSB0aGlzLl9oYW5kbGVzWzFdLnNjcmVlblBvc2l0aW9uLnk7XG5cbiAgICAvL2NhbGN1bGF0ZSBhbGwgdGhlIGxlbmd0aHMgdG8gdGhlIGxhYmVsLCBzbyB3ZSBjYW4gY2hvb3NlIHRoZSBtaW5cbiAgICB2YXIgbGVuZ3RodGFpbGxhYmVsID0gTWF0aC5zcXJ0KCh4MV90YWlsLXgyKSooeDFfdGFpbC14MikgKyAoeTFfdGFpbC15MikqKHkxX3RhaWwteTIpKTtcbiAgICB2YXIgbGVuZ3RoYm9keWxhYmVsID0gTWF0aC5zcXJ0KCh4MV9ib2R5LXgyKSooeDFfYm9keS14MikgKyAoeTFfYm9keS15MikqKHkxX2JvZHkteTIpKTtcbiAgICB2YXIgbGVuZ3Robm9zZWxhYmVsID0gTWF0aC5zcXJ0KCh4MV9ub3NlLXgyKSooeDFfbm9zZS14MikgKyAoeTFfbm9zZS15MikqKHkxX25vc2UteTIpKTtcblxuICAgIHZhciBsZW5ndGhzID0gW2xlbmd0aHRhaWxsYWJlbCwgbGVuZ3RoYm9keWxhYmVsLCBsZW5ndGhub3NlbGFiZWxdO1xuICAgIHZhciBtaW5sZW5ndGggPSBNYXRoLm1pbihsZW5ndGh0YWlsbGFiZWwsIGxlbmd0aGJvZHlsYWJlbCwgbGVuZ3Robm9zZWxhYmVsKTtcbiAgICB2YXIgbWlubGVuZ3RoaW5kZXggPSBsZW5ndGhzLmluZGV4T2YobWlubGVuZ3RoKTtcblxuICAgIGlmIChtaW5sZW5ndGhpbmRleCA9PSAwKXtcbiAgICAgICAgeDEgPSB4MV90YWlsO1xuICAgICAgICB5MSA9IHkxX3RhaWw7XG4gICAgfVxuICAgIGlmIChtaW5sZW5ndGhpbmRleCA9PSAxKXtcbiAgICAgICAgeDEgPSB4MV9ib2R5O1xuICAgICAgICB5MSA9IHkxX2JvZHk7XG4gICAgfVxuICAgIGlmIChtaW5sZW5ndGhpbmRleCA9PSAyKXtcbiAgICAgICAgeDEgPSB4MV9ub3NlO1xuICAgICAgICB5MSA9IHkxX25vc2U7XG4gICAgfVxuXG4gICAgLy8gT25jZSB3ZSBmb3VuZCB0aGUgY2xvc2VzdCBwb2ludCB0byB0aGUgbGFiZWwsIHdlIGNyZWF0ZSB0aGUgZGFzaGVkIGxpbmUgZnJvbSB0aGF0IHBvaW50XG4gICAgbGV0IGxlbmd0aGRhc2hsaW5lID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XG4gICAgbGV0IGFuZ2xlZGFzaGxpbmUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTsgLy9yZXN1bHQgaW4gZGVnXG5cbiAgICBsZXQgcG9zWWRhc2hsaW5lID0geTEgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgLy8gdXBkYXRlIGRhc2hlZCBsaW5lXG4gICAgbGV0IHRyYW5zZm9ybWRhc2hsaW5lID0gYHRyYW5zbGF0ZTNEKCR7eDF9cHgsJHtwb3NZZGFzaGxpbmV9cHgsIDApYDtcbiAgICB0cmFuc2Zvcm1kYXNobGluZSArPSBgIHJvdGF0ZSgke2FuZ2xlZGFzaGxpbmV9ZGVnKWA7XG5cbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1kYXNobGluZTtcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aGRhc2hsaW5lICsgJ3B4JztcbiAgfVxuXG4gIHVwZGF0ZURPTUNvbG9yKCkge1xuICAgIHRoaXMuX2xpbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5ib3JkZXJUb3AgPSAnMi41cHggZGFzaGVkICcgKyBgJHt0aGlzLl9jb2xvcn1gO1xuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgfVxuXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xuICAgIHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxufVxuIiwiLyoqXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzQmFzZSBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAvLyBpbml0IFRIUkVFIE9iamVjdCAzRFxuICAgIHN1cGVyKCk7XG5cbiAgICAvLyBpcyB3aWRnZXQgZW5hYmxlZD9cbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8vIFNUQVRFLCBFTlVNIG1pZ2h0IGJlIGJldHRlclxuICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5faG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIC8vIHRob3MuX3N0YXRlID0gJ1NFTEVDVEVEJztcblxuICAgIHRoaXMuX2NvbG9ycyA9IHtcbiAgICAgIGRlZmF1bHQ6ICcjMDBCMEZGJyxcbiAgICAgIGFjdGl2ZTogJyNGRkVCM0InLFxuICAgICAgaG92ZXI6ICcjRjUwMDU3JyxcbiAgICAgIHNlbGVjdDogJyM3NkZGMDMnLFxuICAgIH07XG4gICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuZGVmYXVsdDtcblxuICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcbiAgICAvLyBjYW4gbm90IGNhbGwgaXQgdmlzaWJsZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aXRoIFRIUkVFLk9iamVjdDNEXG4gICAgdGhpcy5fZGlzcGxheWVkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IGJveCA9IHRoaXMuX2NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID1cbiAgICAgIHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2NFbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcblxuICAgIGNvbnN0IGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICAgIGNvbnN0IGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuXG4gICAgY29uc3QgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcbiAgICBjb25zdCBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICAgIHRoaXMuX29mZnNldHMgPSB7XG4gICAgICB0b3A6IE1hdGgucm91bmQodG9wKSxcbiAgICAgIGxlZnQ6IE1hdGgucm91bmQobGVmdCksXG4gICAgfTtcbiAgfVxuXG4gIG9mZnNldENoYW5nZWQoKSB7XG4gICAgdGhpcy5pbml0T2Zmc2V0cygpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXRNb3VzZU9mZnNldHMoZXZlbnQsIGNvbnRhaW5lcikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoZXZlbnQuY2xpZW50WCAtIHRoaXMuX29mZnNldHMubGVmdCkgLyBjb250YWluZXIub2Zmc2V0V2lkdGggKiAyIC0gMSxcbiAgICAgIHk6IC0oKGV2ZW50LmNsaWVudFkgLSB0aGlzLl9vZmZzZXRzLnRvcCkgLyBjb250YWluZXIub2Zmc2V0SGVpZ2h0KVxuICAgICAgICAqIDIgKyAxLFxuICAgICAgc2NyZWVuWDogZXZlbnQuY2xpZW50WCAtIHRoaXMuX29mZnNldHMubGVmdCxcbiAgICAgIHNjcmVlblk6IGV2ZW50LmNsaWVudFkgLSB0aGlzLl9vZmZzZXRzLnRvcCxcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIHRvIGJlIG92ZXJsb2FkZWRcbiAgICB3aW5kb3cuY29uc29sZS5sb2coJ3VwZGF0ZSgpIHNob3VsZCBiZSBvdmVybG9hZGVkIScpO1xuICB9XG5cbiAgZnJlZSgpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICB9XG5cbiAgdXBkYXRlQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuYWN0aXZlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faG92ZXJlZCkge1xuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuaG92ZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuc2VsZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb2xvciA9IHRoaXMuX2NvbG9ycy5kZWZhdWx0O1xuICAgIH1cbiAgfVxuXG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICB9XG5cbiAgc2V0IGVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGVkO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICB9XG5cbiAgc2V0IHNlbGVjdGVkKHNlbGVjdGVkKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGhvdmVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvdmVyZWQ7XG4gIH1cblxuICBzZXQgaG92ZXJlZChob3ZlcmVkKSB7XG4gICAgdGhpcy5faG92ZXJlZCA9IGhvdmVyZWQ7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBkcmFnZ2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmFnZ2VkO1xuICB9XG5cbiAgc2V0IGRyYWdnZWQoZHJhZ2dlZCkge1xuICAgIHRoaXMuX2RyYWdnZWQgPSBkcmFnZ2VkO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgZGlzcGxheWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5ZWQ7XG4gIH1cblxuICBzZXQgZGlzcGxheWVkKGRpc3BsYXllZCkge1xuICAgIHRoaXMuX2Rpc3BsYXllZCA9IGRpc3BsYXllZDtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgc2V0IGFjdGl2ZShhY3RpdmUpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gIH1cblxuICBzZXQgY29sb3IoY29sb3IpIHtcbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxufVxuIiwiaW1wb3J0IFdpZGdldHNCYXNlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5iYXNlJztcbmltcG9ydCBXaWRnZXRzSGFuZGxlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5oYW5kbGUnO1xuXG4vKipcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c0JpUnVsZXIgZXh0ZW5kcyBXaWRnZXRzQmFzZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5pdE9ydGhvID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIGlmKHRoaXMuX3RhcmdldE1lc2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB0aGlzLl90YXJnZXRNZXNoLnBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVzaCBzdHVmZlxuICAgICAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICAgICAgLy8gZG9tIHN0dWZmXG4gICAgICAgIHRoaXMuX2xpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgLy8gYWRkIGhhbmRsZXNcbiAgICAgICAgdGhpcy5faGFuZGxlcyA9IFtdO1xuXG4gICAgICAgIC8vIGZpcnN0IGhhbmRsZVxuICAgICAgICBsZXQgZmlyc3RIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBmaXJzdEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcbiAgICAgICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKGZpcnN0SGFuZGxlKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goZmlyc3RIYW5kbGUpO1xuXG4gICAgICAgIGxldCBzZWNvbmRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBzZWNvbmRIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgICAgIHNlY29uZEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgLy8gYWN0aXZlIGFuZCB0cmFja2luZyBtaWdodCBiZSByZWR1bmRhbnRcbiAgICAgICAgc2Vjb25kSGFuZGxlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHNlY29uZEhhbmRsZS50cmFja2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNlY29uZEhhbmRsZSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcy5wdXNoKHNlY29uZEhhbmRsZSk7XG5cbiAgICAgICAgLy8gdGhpcmQgaGFuZGxlXG4gICAgICAgIGxldCB0aGlyZEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXJkSGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlyZEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQodGhpcmRIYW5kbGUpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaCh0aGlyZEhhbmRsZSk7XG5cbiAgICAgICAgLy8gZm91cnRoIGhhbmRsZVxuICAgICAgICBsZXQgZm91cnRoSGFuZGxlID0gbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgZm91cnRoSGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICBmb3VydGhIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKGZvdXJ0aEhhbmRsZSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcy5wdXNoKGZvdXJ0aEhhbmRsZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJ1bGVyXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG5cbiAgICAgICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9zbGljZSA9IG51bGw7XG4gICAgfVxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGV2dCkge1xuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLm9uTW92ZShldnQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLm9uTW92ZShldnQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLm9uTW92ZShldnQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLm9uTW92ZShldnQpO1xuXG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9oYW5kbGVzWzBdLmhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1sxXS5ob3ZlcmVkIHx8IHRoaXMuX2hhbmRsZXNbMl0uaG92ZXJlZCB8fCB0aGlzLl9oYW5kbGVzWzNdLmhvdmVyZWQ7XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBvblN0YXJ0KGV2dCkge1xuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS5vblN0YXJ0KGV2dCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMV0ub25TdGFydChldnQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLm9uU3RhcnQoZXZ0KTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS5vblN0YXJ0KGV2dCk7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5faGFuZGxlc1swXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1sxXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1syXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1szXS5hY3RpdmU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgb25FbmQoZXZ0KSB7XG4gICAgICAgIC8vIEZpcnN0IEhhbmRsZVxuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLm9uRW5kKGV2dCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMl0ub25FbmQoZXZ0KTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS5vbkVuZChldnQpO1xuXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzKTtcblxuICAgICAgICAvLyBTZWNvbmQgSGFuZGxlXG4gICAgICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbMV0ub25FbmQoZXZ0KTtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1sxXS50cmFja2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhdGUgb2YgcnVsZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2hhbmRsZXNbMF0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMV0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMl0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbM10uYWN0aXZlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVNZXNoKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gICAgfVxuXG4gICAgaGlkZURPTSgpIHtcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5oaWRlRE9NKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHNob3dET00oKSB7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5zaG93RE9NKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgfVxuXG4gICAgaGlkZU1lc2goKXtcbiAgICAgICAgdGhpcy5fbWVzaC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21lc2gyLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMV0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2hvd01lc2goKSB7XG4gICAgICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX21lc2gyLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLnZpc2libGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuc2hvd0RPTSgpO1xuICAgICAgICB0aGlzLnNob3dNZXNoKCk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5oaWRlRE9NKCk7XG4gICAgICAgIHRoaXMuaGlkZU1lc2goKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcblxuICAgICAgICAvLyBtZXNoIHN0dWZmXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTWVzaFBvc2l0aW9uKCk7XG5cbiAgICAgICAgLy8gRE9NIHN0dWZmXG4gICAgICAgIHRoaXMudXBkYXRlRE9NUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xuICAgIH1cblxuICAgIGNyZWF0ZU1lc2goKSB7XG4gICAgICAgIC8vIGdlb21ldHJ5XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24pO1xuXG4gICAgICAgIC8vIGdlb21ldHJ5XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5MiA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICB0aGlzLl9nZW9tZXRyeTIudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9nZW9tZXRyeTIudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24pO1xuXG4gICAgICAgIC8vIG1hdGVyaWFsXG4gICAgICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XG4gICAgICAgIHRoaXMuX21hdGVyaWFsMiA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuXG4gICAgICAgIC8vIG1lc2hcbiAgICAgICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5MaW5lKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX21lc2gyID0gbmV3IFRIUkVFLkxpbmUodGhpcy5fZ2VvbWV0cnkyLCB0aGlzLl9tYXRlcmlhbDIpO1xuICAgICAgICB0aGlzLl9tZXNoMi52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAvLyBhZGQgaXQhXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLl9tZXNoMik7XG4gICAgfVxuXG4gICAgdXBkYXRlTWVzaENvbG9yKCkge1xuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbDIpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsMi5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlTWVzaFBvc2l0aW9uKCkge1xuICAgICAgICBpZih0aGlzLl9nZW9tZXRyeSkge1xuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9nZW9tZXRyeTIpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5Mi52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlRE9NKCkge1xuICAgICAgICAvLyBhZGQgbGluZSFcbiAgICAgICAgdGhpcy5fbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSAnM3B4JztcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xpbmUpO1xuXG4gICAgICAgIC8vIGFkZCBkaXN0YW5jZSFcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkaXN0YW5jZScpO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkJztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xuICAgICAgICAvLyB0aGlzLl9kaXN0YW5jZS5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmNvbG9yID0gJyMzNTM1MzUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5wYWRkaW5nID0gJzRweCc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLmlubmVySFRNTCA9ICdIZWxsbywgd29ybGQhJztcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Rpc3RhbmNlKTtcblxuICAgICAgICAvLyBhZGQgbGluZSFcbiAgICAgICAgdGhpcy5fbGluZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fbGluZTIuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsaW5lJyk7XG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLndpZHRoID0gJzNweCc7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9saW5lMik7XG5cbiAgICAgICAgLy8gYWRkIGRpc3RhbmNlIVxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgZGlzdGFuY2UnKTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcbiAgICAgICAgLy8gdGhpcy5fZGlzdGFuY2UyLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLmNvbG9yID0gJyMzNTM1MzUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5pbm5lckhUTUwgPSAnSGVsbG8sIHdvcmxkISc7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kaXN0YW5jZTIpO1xuXG4gICAgICAgIC8vIGFkZCBkYXNoIGxpbmVcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkYXNobGluZScpO1xuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyVG9wID0gJzIuNXB4IGRhc2hlZCAjRjlGOUY5JztcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmhlaWdodCA9ICcxcHgnO1xuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9ICc1MCUnO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGFzaGxpbmUpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVET01Qb3NpdGlvbigpIHtcbiAgICAgICAgLy8gdXBkYXRlIHJ1bGVycyBsaW5lcyBhbmQgdGV4dCFcbiAgICAgICAgbGV0IHgxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54O1xuICAgICAgICBsZXQgeTEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgICAgIGxldCB4MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueDtcbiAgICAgICAgbGV0IHkyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi55O1xuXG4gICAgICAgIC8vbGV0IHgwID0geDEgKyAoeDIgLSB4MSkvMjtcbiAgICAgICAgLy9sZXQgeTAgPSB5MSArICh5MiAtIHkxKS8yO1xuICAgICAgICBsZXQgeDAgPSB4MjtcbiAgICAgICAgbGV0IHkwID0geTI7XG5cbiAgICAgICAgaWYgKHkxID49IHkyKSB7XG4gICAgICAgICAgICB5MCA9IHkyIC0gMzA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MCA9IHkyICsgMzA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XG4gICAgICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiAxODAgLyBNYXRoLlBJO1xuXG4gICAgICAgIGxldCBwb3NZID0geTEgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIC8vIHVwZGF0ZSBsaW5lXG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM0QoJHt4MX1weCwke3Bvc1l9cHgsIDApYDtcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XG5cbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSBsZW5ndGg7XG5cbiAgICAgICAgLy8gdXBkYXRlIGRpc3RhbmNlXG4gICAgICAgIGxldCB3MCA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbjtcbiAgICAgICAgbGV0IHcxID0gdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uO1xuXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLmlubmVySFRNTCA9IGAke01hdGguc3FydCgodzAueC13MS54KSoodzAueC13MS54KSArICh3MC55LXcxLnkpKih3MC55LXcxLnkpICsgKHcwLnotdzEueikqKHcwLnotdzEueikpLnRvRml4ZWQoMil9IG1tYDtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VWYWx1ZSA9IE1hdGguc3FydCgodzAueC13MS54KSoodzAueC13MS54KSArICh3MC55LXcxLnkpKih3MC55LXcxLnkpICsgKHcwLnotdzEueikqKHcwLnotdzEueikpLnRvRml4ZWQoMik7XG4gICAgICAgIGxldCBwb3NZMCA9IHkwIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCAtIHRoaXMuX2Rpc3RhbmNlLm9mZnNldEhlaWdodC8yO1xuICAgICAgICB4MCAtPSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRXaWR0aC8yO1xuXG4gICAgICAgIGxldCB0cmFuc2Zvcm0yID0gYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MCl9cHgsJHtNYXRoLnJvdW5kKHBvc1kwKX1weCwgMClgO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0yO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBydWxlcnMgbGluZXMgMiBhbmQgdGV4dCFcbiAgICAgICAgbGV0IHgzID0gdGhpcy5faGFuZGxlc1syXS5zY3JlZW5Qb3NpdGlvbi54O1xuICAgICAgICBsZXQgeTMgPSB0aGlzLl9oYW5kbGVzWzJdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgICAgIGxldCB4NCA9IHRoaXMuX2hhbmRsZXNbM10uc2NyZWVuUG9zaXRpb24ueDtcbiAgICAgICAgbGV0IHk0ID0gdGhpcy5faGFuZGxlc1szXS5zY3JlZW5Qb3NpdGlvbi55O1xuXG4gICAgICAgIC8vbGV0IHgwID0geDEgKyAoeDIgLSB4MSkvMjtcbiAgICAgICAgLy9sZXQgeTAgPSB5MSArICh5MiAtIHkxKS8yO1xuICAgICAgICBsZXQgeDAyID0geDQ7XG4gICAgICAgIGxldCB5MDIgPSB5NDtcblxuICAgICAgICBpZiAoeTMgPj0geTQpIHtcbiAgICAgICAgICAgIHkwMiA9IHk0IC0gMzA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MDIgPSB5NCArIDMwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4My14NCkqKHgzLXg0KSArICh5My15NCkqKHkzLXk0KSk7XG4gICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAqIDE4MCAvIE1hdGguUEk7XG5cbiAgICAgICAgcG9zWSA9IHkzIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvLyB1cGRhdGUgbGluZVxuICAgICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM0QoJHt4M31weCwke3Bvc1l9cHgsIDApYDtcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XG5cbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS53aWR0aCA9IGxlbmd0aDtcblxuICAgICAgICAvLyB1cGRhdGUgZGlzdGFuY2VcbiAgICAgICAgbGV0IHcwMiA9IHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbjtcbiAgICAgICAgbGV0IHcxMiA9IHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbjtcblxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuaW5uZXJIVE1MID0gYCR7TWF0aC5zcXJ0KCh3MDIueC13MTIueCkqKHcwMi54LXcxMi54KSArICh3MDIueS13MTIueSkqKHcwMi55LXcxMi55KSArICh3MDIuei13MTIueikqKHcwMi56LXcxMi56KSkudG9GaXhlZCgyKX0gbW1gO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTJWYWx1ZSA9IE1hdGguc3FydCgodzAyLngtdzEyLngpKih3MDIueC13MTIueCkgKyAodzAyLnktdzEyLnkpKih3MDIueS13MTIueSkgKyAodzAyLnotdzEyLnopKih3MDIuei13MTIueikpLnRvRml4ZWQoMik7XG4gICAgICAgIGxldCBwb3NZMDIgPSB5MDIgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gdGhpcy5fZGlzdGFuY2UyLm9mZnNldEhlaWdodC8yO1xuICAgICAgICB4MDIgLT0gdGhpcy5fZGlzdGFuY2UyLm9mZnNldFdpZHRoLzI7XG5cbiAgICAgICAgdHJhbnNmb3JtMiA9IGB0cmFuc2xhdGUzRCgke01hdGgucm91bmQoeDAyKX1weCwke01hdGgucm91bmQocG9zWTAyKX1weCwgMClgO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtMjtcblxuICAgICAgICAvLyB1cGRhdGUgZGFzaCBsaW5lXG5cbiAgICAgICAgbGV0IGwxY2VudGVyID0gdGhpcy5nZXRQb2ludEluQmV0d2VlbkJ5UGVyYyh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24sIHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbiwgMC41KTtcbiAgICAgICAgbGV0IGwyY2VudGVyID0gdGhpcy5nZXRQb2ludEluQmV0d2VlbkJ5UGVyYyh0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24sIHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbiwgMC41KTtcblxuICAgICAgICBsZXQgc2NyZWVuMSA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRUb1NjcmVlbihsMWNlbnRlciwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBsZXQgc2NyZWVuMiA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRUb1NjcmVlbihsMmNlbnRlciwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgICAgIHgxID0gc2NyZWVuMS54O1xuICAgICAgICB5MSA9IHNjcmVlbjEueTtcbiAgICAgICAgeDIgPSBzY3JlZW4yLng7XG4gICAgICAgIHkyID0gc2NyZWVuMi55O1xuXG4gICAgICAgIGxlbmd0aCA9IE1hdGguc3FydCgoeDEteDIpKih4MS14MikgKyAoeTEteTIpKih5MS15MikpO1xuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiAxODAgLyBNYXRoLlBJO1xuXG4gICAgICAgIHBvc1kgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy8gdXBkYXRlIGxpbmVcbiAgICAgICAgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNEKCR7eDF9cHgsJHtwb3NZfXB4LCAwKWA7XG4gICAgICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xuXG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUud2lkdGggPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgdXBkYXRlRE9NQ29sb3IoKSB7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xuXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5zdHlsZS5ib3JkZXJDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XG4gICAgfVxuXG4gICAgZ2V0UG9pbnRJbkJldHdlZW5CeVBlcmMocG9pbnRBLCBwb2ludEIsIHBlcmNlbnRhZ2UpIHtcblxuICAgICAgICB2YXIgZGlyID0gcG9pbnRCLmNsb25lKCkuc3ViKHBvaW50QSk7XG4gICAgICAgIHZhciBsZW4gPSBkaXIubGVuZ3RoKCk7XG4gICAgICAgIGRpciA9IGRpci5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW4qcGVyY2VudGFnZSk7XG4gICAgICAgIHJldHVybiBwb2ludEEuY2xvbmUoKS5hZGQoZGlyKTtcblxuICAgIH1cblxuICAgIGluaXRPcnRobyAoKSB7XG4gICAgICAgIHRoaXMuX2luaXRPcnRobyA9IHRydWU7XG5cbiAgICAgICAgbGV0IHBjZW50ZXIgPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uLCAwLjUpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24gPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uLCAwLjI1KTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS53b3JsZFBvc2l0aW9uID0gdGhpcy5nZXRQb2ludEluQmV0d2VlbkJ5UGVyYyh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24sIHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbiwgMC43NSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnggPSBwY2VudGVyLnggLSBNYXRoLnNxcnQoKHBjZW50ZXIueSAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi55KSoocGNlbnRlci55IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkpKTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkgPSBwY2VudGVyLnkgKyBNYXRoLnNxcnQoKHBjZW50ZXIueCAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi54KSoocGNlbnRlci54IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLngpKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24ueCA9IHBjZW50ZXIueCArIE1hdGguc3FydCgocGNlbnRlci55IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkpKihwY2VudGVyLnkgLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueSkpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24ueSA9IHBjZW50ZXIueSAtIE1hdGguc3FydCgocGNlbnRlci54IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLngpKihwY2VudGVyLnggLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueCkpO1xuICAgIH1cblxuICAgIGdldCB3b3JsZFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHNob3Rlc3REaXN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5fZGlzdGFuY2VWYWx1ZSA8IHRoaXMuX2Rpc3RhbmNlMlZhbHVlKSA/IHRoaXMuX2Rpc3RhbmNlVmFsdWUgOiB0aGlzLl9kaXN0YW5jZTJWYWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IGxvbmdlc3REaXN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5fZGlzdGFuY2VWYWx1ZSA+IHRoaXMuX2Rpc3RhbmNlMlZhbHVlKSA/IHRoaXMuX2Rpc3RhbmNlVmFsdWUgOiB0aGlzLl9kaXN0YW5jZTJWYWx1ZSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgV2lkZ2V0c0Jhc2UgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmJhc2UnO1xuaW1wb3J0IENvcmVJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcblxuXG4vKipcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c0hhbmRsZSBleHRlbmRzIFdpZGdldHNCYXNlIHtcblxuICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcbiAgICBzdXBlcihjb250YWluZXIpO1xuXG4gICAgdGhpcy5fdGFyZ2V0TWVzaCA9IHRhcmdldE1lc2g7XG4gICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcbiAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XG5cbiAgICAvLyBpZiBubyB0YXJnZXQgbWVzaCwgdXNlIHBsYW5lIGZvciBGUkVFIGRyYWdnaW5nLlxuICAgIHRoaXMuX3BsYW5lID0ge1xuICAgICAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgZGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgIH07XG4gICAgdGhpcy5fb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLl9yYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCk7XG5cbiAgICB0aGlzLl90cmFja2luZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fbW91c2UgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgICAvLyB3b3JsZCAoTFBTKSBwb3NpdGlvbiBvZiB0aGlzIGhhbmRsZVxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgLy8gc2NyZWVuIHBvc2l0aW9uIG9mIHRoaXMgaGFuZGxlXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgLy8gbWVzaCBzdHVmZlxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG4gICAgdGhpcy5fbWVzaERpc3BsYXllZCA9IHRydWU7XG4gICAgdGhpcy5fbWVzaEhvdmVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9tZXNoU3R5bGUgPSAnc3BoZXJlJzsgLy8gY3ViZSwgZXRjLlxuXG4gICAgLy8gZG9tIHN0dWZmXG4gICAgdGhpcy5fZG9tID0gbnVsbDtcbiAgICB0aGlzLl9kb21EaXNwbGF5ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2RvbUhvdmVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kb21TdHlsZSA9ICdjaXJjbGUnOyAvLyBzcXVhcmUsIHRyaWFuZ2xlXG5cbiAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID1cbiAgICAgIHRoaXMud29ybGRUb1NjcmVlbih0aGlzLl93b3JsZFBvc2l0aW9uLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAvLyBjcmVhdGUgaGFuZGxlXG4gICAgdGhpcy5jcmVhdGUoKTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKCk7XG5cbiAgICAvLyBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkhvdmVyID0gdGhpcy5vbkhvdmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkVuZENvbnRyb2wgPSB0aGlzLm9uRW5kQ29udHJvbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2RvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkhvdmVyKTtcbiAgICB0aGlzLl9kb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Ib3Zlcik7XG5cbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG5cbiAgICB0aGlzLl9jb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLm9uRW5kQ29udHJvbCk7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Ib3Zlcik7XG4gICAgdGhpcy5fZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uSG92ZXIpO1xuXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xuXG4gICAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xuICB9XG5cbiAgY3JlYXRlKCkge1xuICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xuICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gIH1cblxuICBvblN0YXJ0KGV2dCkge1xuICAgIGNvbnNvbGUubG9nKGV2dCk7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuZ2V0TW91c2VPZmZzZXRzKGV2dCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9tb3VzZS5zZXQob2Zmc2V0cy54LCBvZmZzZXRzLnkpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuX21vdXNlKTtcblxuICAgIC8vIHVwZGF0ZSByYXljYXN0ZXJcbiAgICB0aGlzLl9yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLl9tb3VzZSwgdGhpcy5fY2FtZXJhKTtcbiAgICB0aGlzLl9yYXljYXN0ZXIucmF5LnBvc2l0aW9uID0gdGhpcy5fcmF5Y2FzdGVyLnJheS5vcmlnaW47XG5cbiAgICBpZiAodGhpcy5faG92ZXJlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX3RhcmdldE1lc2gpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdHNUYXJnZXQgPVxuICAgICAgICAgIHRoaXMuX3JheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QodGhpcy5fdGFyZ2V0TWVzaCk7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzVGFyZ2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQuY29weShpbnRlcnNlY3RzVGFyZ2V0WzBdLnBvaW50KS5zdWIodGhpcy5fd29ybGRQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYW5lLnBvc2l0aW9uLmNvcHkodGhpcy5fd29ybGRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XG4gICAgICAgICAgQ29yZUludGVyc2VjdGlvbnMucmF5UGxhbmUodGhpcy5fcmF5Y2FzdGVyLnJheSwgdGhpcy5fcGxhbmUpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkoaW50ZXJzZWN0aW9uKS5zdWIodGhpcy5fcGxhbmUucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgb25FbmQoZXZ0KSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gc3RheSBhY3RpdmUgYW5kIGtlZXAgY29udHJvbHMgZGlzYWJsZWRcbiAgICBpZiAodGhpcy5fdHJhY2tpbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1bnNlbGVjdCBpZiBnbyB1cCB3aXRob3V0IG1vdmluZ1xuICAgIGlmICghdGhpcy5fZHJhZ2dlZCAmJiB0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIGNoYW5nZSBzdGF0ZSBpZiB3YXMgbm90IGRyYWdnaW5nXG4gICAgICB0aGlzLl9zZWxlY3RlZCA9ICF0aGlzLl9zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fY29udHJvbHMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25FbmRDb250cm9sKCkge1xuICAgIGlmICghdGhpcy5fbGFzdEV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqXG4gICAqL1xuICBvbk1vdmUoZXZ0KSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuZ2V0TW91c2VPZmZzZXRzKGV2dCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9tb3VzZS5zZXQob2Zmc2V0cy54LCBvZmZzZXRzLnkpO1xuXG4gICAgLy8gdXBkYXRlIHJheWNhc3RlclxuICAgIC8vIHNldCByYXkucG9zaXRpb24gdG8gc2F0aXNmeSBDb3JlSW50ZXJzZWN0aW9uczo6cmF5UGxhbmUgQVBJXG4gICAgdGhpcy5fcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5fbW91c2UsIHRoaXMuX2NhbWVyYSk7XG4gICAgdGhpcy5fcmF5Y2FzdGVyLnJheS5wb3NpdGlvbiA9IHRoaXMuX3JheWNhc3Rlci5yYXkub3JpZ2luO1xuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fZHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3RzVGFyZ2V0ID1cbiAgICAgICAgICB0aGlzLl9yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KHRoaXMuX3RhcmdldE1lc2gpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0c1RhcmdldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KGludGVyc2VjdHNUYXJnZXRbMF0ucG9pbnQuc3ViKHRoaXMuX29mZnNldCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fcGxhbmUuZGlyZWN0aW9uLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgLy8gZnJlZSBtb2RlIXRoaXMuX3RhcmdldE1lc2hcbiAgICAgICAgICB0aGlzLl9wbGFuZS5wb3NpdGlvbi5jb3B5KHRoaXMuX3dvcmxkUG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcbiAgICAgICAgIH1cblxuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID1cbiAgICAgICAgICBDb3JlSW50ZXJzZWN0aW9ucy5yYXlQbGFuZSh0aGlzLl9yYXljYXN0ZXIucmF5LCB0aGlzLl9wbGFuZSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkoaW50ZXJzZWN0aW9uLnN1Yih0aGlzLl9vZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uSG92ZXIobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIG9uSG92ZXIoZXZ0KSB7XG4gICAgaWYgKGV2dCkge1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmhvdmVyRG9tKGV2dCk7XG4gICAgfVxuXG4gICAgdGhpcy5ob3Zlck1lc2goKTtcblxuICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9tZXNoSG92ZXJlZCB8fCB0aGlzLl9kb21Ib3ZlcmVkO1xuICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSB0aGlzLl9ob3ZlcmVkID8gJ3BvaW50ZXInIDogJ2RlZmF1bHQnO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIGdlbmVyYWwgdXBkYXRlXG4gICAgdGhpcy51cGRhdGVDb2xvcigpO1xuXG4gICAgLy8gdXBkYXRlIHNjcmVlbiBwb3NpdGlvbiBvZiBoYW5kbGVcbiAgICB0aGlzLl9zY3JlZW5Qb3NpdGlvbiA9XG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW4odGhpcy5fd29ybGRQb3NpdGlvbiwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgLy8gbWVzaCBzdHVmZlxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XG4gICAgdGhpcy51cGRhdGVNZXNoUG9zaXRpb24oKTtcblxuICAgIC8vIERPTSBzdHVmZlxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB0aGlzLnVwZGF0ZURPTVBvc2l0aW9uKCk7XG4gIH1cblxuICAvL1xuICB1cGRhdGVNZXNoQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5fbWVzaC5wb3NpdGlvbi54ID0gdGhpcy5fd29ybGRQb3NpdGlvbi54O1xuICAgICAgdGhpcy5fbWVzaC5wb3NpdGlvbi55ID0gdGhpcy5fd29ybGRQb3NpdGlvbi55O1xuICAgICAgdGhpcy5fbWVzaC5wb3NpdGlvbi56ID0gdGhpcy5fd29ybGRQb3NpdGlvbi56O1xuICAgIH1cbiAgfVxuXG4gIGhvdmVyTWVzaCgpIHtcbiAgICAvLyBjaGVjayByYXljYXN0IGludGVyc2VjdGlvbiwgZG8gd2Ugd2FudCB0byBob3ZlciBvbiBtZXNoIG9yIGp1c3QgY3NzP1xuICAgIGxldCBpbnRlcnNlY3RzSGFuZGxlID0gdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl9tZXNoKTtcbiAgICB0aGlzLl9tZXNoSG92ZXJlZCA9IChpbnRlcnNlY3RzSGFuZGxlLmxlbmd0aCA+IDApO1xuICB9XG5cbiAgaG92ZXJEb20oZXZ0KSB7XG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IChldnQudHlwZSA9PT0gJ21vdXNlZW50ZXInKTtcbiAgfVxuXG4gIHdvcmxkVG9TY3JlZW4od29ybGRDb29yZGluYXRlLCBjYW1lcmEsIGNhbnZhcykge1xuICAgIGxldCBzY3JlZW5Db29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZS5jbG9uZSgpO1xuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnByb2plY3QoY2FtZXJhKTtcblxuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnggPVxuICAgICAgTWF0aC5yb3VuZCgoc2NyZWVuQ29vcmRpbmF0ZXMueCArIDEpICogY2FudmFzLm9mZnNldFdpZHRoIC8gMik7XG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueSA9XG4gICAgICBNYXRoLnJvdW5kKCgtc2NyZWVuQ29vcmRpbmF0ZXMueSArIDEpICogY2FudmFzLm9mZnNldEhlaWdodCAvIDIpO1xuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnogPSAwO1xuXG4gICAgcmV0dXJuIHNjcmVlbkNvb3JkaW5hdGVzO1xuICB9XG5cbiAgY3JlYXRlTWVzaCgpIHtcbiAgICAvLyBnZW9tZXRyeVxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEsIDE2LCAxNik7XG5cbiAgICAvLyBtYXRlcmlhbFxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgICB3aXJlZnJhbWVMaW5ld2lkdGg6IDIsXG4gICAgICB9KTtcblxuICAgIC8vIG1lc2hcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcbiAgICB0aGlzLl9tZXNoLnBvc2l0aW9uLnggPSB0aGlzLl93b3JsZFBvc2l0aW9uLng7XG4gICAgdGhpcy5fbWVzaC5wb3NpdGlvbi55ID0gdGhpcy5fd29ybGRQb3NpdGlvbi55O1xuICAgIHRoaXMuX21lc2gucG9zaXRpb24ueiA9IHRoaXMuX3dvcmxkUG9zaXRpb24uejtcbiAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0cnVlO1xuXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcblxuICAgIC8vIGFkZCBpdCFcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcbiAgfVxuXG5cbiAgY3JlYXRlRE9NKCkge1xuICAgIC8vIGRvbVxuICAgIHRoaXMuX2RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RvbS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy51dWlkKTtcbiAgICB0aGlzLl9kb20uc2V0QXR0cmlidXRlKCdjbGFzcycsICdBTUkgV2lkZ2V0IEhhbmRsZScpO1xuICAgIHRoaXMuX2RvbS5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkJztcbiAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xuICAgIHRoaXMuX2RvbS5zdHlsZS5jb2xvciA9ICcjRjlGOUY5JztcbiAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2RvbS5zdHlsZS53aWR0aCA9ICcxMnB4JztcbiAgICB0aGlzLl9kb20uc3R5bGUuaGVpZ2h0ID0gJzEycHgnO1xuICAgIHRoaXMuX2RvbS5zdHlsZS5tYXJnaW4gPSAnLTZweCc7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc1MCUnO1xuICAgIHRoaXMuX2RvbS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcblxuICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5fZG9tLnN0eWxlLnRyYW5zZm9ybSA9XG4gICAgICBgdHJhbnNsYXRlM0QoJHt0aGlzLl9zY3JlZW5Qb3NpdGlvbi54fXB4LCAke3Bvc1l9cHgsIDApYDtcblxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcblxuICAgIC8vIGFkZCBpdCFcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZG9tKTtcbiAgfVxuXG4gIHVwZGF0ZURPTVBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLl9kb20pIHtcbiAgICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLl9kb20uc3R5bGUudHJhbnNmb3JtID1cbiAgICAgICAgYHRyYW5zbGF0ZTNEKCR7dGhpcy5fc2NyZWVuUG9zaXRpb24ueH1weCwgJHtwb3NZfXB4LCAwKWA7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRE9NQ29sb3IoKSB7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgfVxuXG4gIGZyZWUoKSB7XG4gICAgLy8gdGhyZWVqcyBzdHVmZlxuXG4gICAgLy8gZG9tXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSk7XG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICBzdXBlci5mcmVlKCk7XG4gIH1cblxuICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XG4gICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KHdvcmxkUG9zaXRpb24pO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgc2V0IHNjcmVlblBvc2l0aW9uKHNjcmVlblBvc2l0aW9uKSB7XG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPSBzY3JlZW5Qb3NpdGlvbjtcbiAgfVxuXG4gIGdldCBzY3JlZW5Qb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuUG9zaXRpb247XG4gIH1cblxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICBzZXQgYWN0aXZlKGFjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAvLyB0aGlzLl90cmFja2luZyA9IHRoaXMuX2FjdGl2ZTtcbiAgICB0aGlzLl9jb250cm9scy5lbmFibGVkID0gIXRoaXMuX2FjdGl2ZTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgdHJhY2tpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNraW5nO1xuICB9XG5cbiAgc2V0IHRyYWNraW5nKHRyYWNraW5nKSB7XG4gICAgdGhpcy5fdHJhY2tpbmcgPSB0cmFja2luZztcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgaGlkZURPTSgpIHtcbiAgICB0aGlzLl9kb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG4gIHNob3dET00oKSB7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgfVxuXG4gIGhpZGVNZXNoKCkge1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgc2hvd01lc2goKSB7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy5zaG93RE9NKCk7XG4gICAgdGhpcy5zaG93TWVzaCgpO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmhpZGVET00oKTtcbiAgICB0aGlzLmhpZGVNZXNoKCk7XG4gIH1cbn1cbiIsImltcG9ydCBBbm5vdGF0aW9uIGZyb20gJy4vd2lkZ2V0cy5hbm5vdGF0aW9uJztcbmltcG9ydCBCaVJ1bGVyIGZyb20gJy4vd2lkZ2V0cy5iaXJ1bGVyJztcbmltcG9ydCBIYW5kbGUgZnJvbSAnLi93aWRnZXRzLmhhbmRsZSc7XG5pbXBvcnQgUm9pIGZyb20gJy4vd2lkZ2V0cy5yb2knO1xuaW1wb3J0IFJ1bGVyIGZyb20gJy4vd2lkZ2V0cy5ydWxlcic7XG5pbXBvcnQgVm94ZWxQcm9iZSBmcm9tICcuL3dpZGdldHMudm94ZWxQcm9iZSc7XG5cbi8qKlxuICogQG1vZHVsZSB3aWRnZXRzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIEFubm90YXRpb24sXG4gICAgQmlSdWxlcixcblx0SGFuZGxlLFxuICAgIFJvaSxcbiAgICBSdWxlcixcbiAgICBWb3hlbFByb2JlLFxufTtcbiIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XG5pbXBvcnQgV2lkZ2V0c0hhbmRsZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuaGFuZGxlJztcblxuLyoqXG4gKiBAbW9kdWxlIHdpZGdldHMvaGFuZGxlXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpZGdldHNSb2kgZXh0ZW5kcyBXaWRnZXRzQmFzZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5pdCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBpZih0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gdGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1lc2ggc3R1ZmZcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xuXG4gICAgICAgIC8vIGRvbSBzdHVmZlxuICAgICAgICB0aGlzLl9saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9hcmVhID0gbnVsbDtcblxuICAgICAgICAvLyBhZGQgaGFuZGxlc1xuICAgICAgICB0aGlzLl9oYW5kbGVzID0gW107XG5cbiAgICAgICAgLy8gZmlyc3QgaGFuZGxlXG4gICAgICAgIGxldCBmaXJzdEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGZpcnN0SGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICBmaXJzdEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaChmaXJzdEhhbmRsZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJ1bGVyXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG5cbiAgICAgICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9zbGljZSA9IG51bGw7XG4gICAgfVxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGV2dCkge1xuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgbGV0IG51bUhhbmRsZXMgPSAgdGhpcy5faGFuZGxlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICF0aGlzLl9pbml0KSB7XG4gICAgICAgICAgICBsZXQgbGFzdEhhbmRsZSA9IHRoaXMuX2hhbmRsZXNbbnVtSGFuZGxlcy0xXTtcbiAgICAgICAgICAgIGxhc3RIYW5kbGUuaG92ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGFzdEhhbmRsZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxhc3RIYW5kbGUudHJhY2tpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGV0IG5leHRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgbmV4dEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcbiAgICAgICAgICAgIG5leHRIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBuZXh0SGFuZGxlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBuZXh0SGFuZGxlLnRyYWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKG5leHRIYW5kbGUpO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2gobmV4dEhhbmRsZSk7XG5cbiAgICAgICAgICAgIGxldCBuZXdMaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBuZXdMaW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLmhlaWdodCA9ICcycHgnO1xuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS53aWR0aCA9ICczcHgnO1xuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XG5cbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3TGluZSk7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQobmV3TGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaG92ZXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLm9uTW92ZShldnQpO1xuICAgICAgICAgICAgaG92ZXJlZCA9IGhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1tpbmRleF0uaG92ZXJlZFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faG92ZXJlZCA9IGhvdmVyZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmIG51bUhhbmRsZXMgPiAyKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hQb3BIYW5kbGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgb25TdGFydChldnQpIHtcbiAgICAgICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBhY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5vblN0YXJ0KGV2dCk7XG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5faGFuZGxlc1tpbmRleF0uYWN0aXZlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgb25FbmQoZXZ0KSB7XG4gICAgICAgIC8vIEZpcnN0IEhhbmRsZVxuICAgICAgICB2YXIgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMuc2xpY2UoMCwgdGhpcy5faGFuZGxlcy5sZW5ndGgtMikpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLm9uRW5kKGV2dCk7XG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5faGFuZGxlc1tpbmRleF0uYWN0aXZlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWNvbmQgSGFuZGxlXG4gICAgICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0udHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0ub25FbmQoZXZ0KTtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0xXS50cmFja2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYWN0aXZlID0gYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0uYWN0aXZlXG4gICAgICAgIC8vIFN0YXRlIG9mIHJ1bGVyIHdpZGdldFxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG5cbiAgICAgICAgbGV0IG5ld0xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbmV3TGluZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGxpbmUnKTtcbiAgICAgICAgbmV3TGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5ld0xpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIG5ld0xpbmUuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xuICAgICAgICBuZXdMaW5lLnN0eWxlLmhlaWdodCA9ICcycHgnO1xuICAgICAgICBuZXdMaW5lLnN0eWxlLndpZHRoID0gJzNweCc7XG4gICAgICAgIG5ld0xpbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xuXG4gICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3TGluZSk7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdMaW5lKTtcblxuICAgICAgICB0aGlzLl9pbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xuICAgIH1cblxuICAgIGhpZGVET00oKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLmhpZGVET00oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2xpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lc1tpbmRleF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3dET00oKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLnNob3dET00oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2xpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lc1tpbmRleF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGlkZU1lc2goKXtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2hvd01lc2goKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5zaG93RE9NKCk7XG4gICAgICAgIHRoaXMuc2hvd01lc2goKTtcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLmhpZGVET00oKTtcbiAgICAgICAgdGhpcy5oaWRlTWVzaCgpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb2xvcigpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVzaCBzdHVmZlxuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hQb3NpdGlvbigpO1xuXG4gICAgICAgIC8vIERPTSBzdHVmZlxuICAgICAgICB0aGlzLnVwZGF0ZURPTVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB9XG5cbiAgICBjcmVhdGVNZXNoKCkge1xuICAgICAgICAvLyBnZW9tZXRyeVxuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbaW5kZXhdLndvcmxkUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF0ZXJpYWxcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICAgICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcblxuICAgICAgICAvLyBtZXNoXG4gICAgICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIGFkZCBpdCFcbiAgICAgICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XG4gICAgfVxuXG4gICAgdXBkYXRlTWVzaENvbG9yKCkge1xuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVET00oKSB7XG4gICAgICAgIC8vIGFkZCBsaW5lIVxuICAgICAgICB0aGlzLl9saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2xpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsaW5lJyk7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JztcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9ICczcHgnO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGluZSk7XG5cbiAgICAgICAgLy8gYWRkIGRpc3RhbmNlIVxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGRpc3RhbmNlJyk7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlciA9ICcycHggc29saWQnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XG4gICAgICAgIC8vIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuY29sb3IgPSAnIzM1MzUzNSc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnBhZGRpbmcgPSAnNHB4JztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UuaW5uZXJIVE1MID0gJ0hlbGxvLCB3b3JsZCEnO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGlzdGFuY2UpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB9XG5cbiAgICBpc1BvaW50T25MaW5lIChwb2ludEEsIHBvaW50QiwgcG9pbnRUb0NoZWNrKSB7XG4gICAgICAgIHZhciBjID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgYy5jcm9zc1ZlY3RvcnMocG9pbnRBLmNsb25lKCkuc3ViKHBvaW50VG9DaGVjayksIHBvaW50Qi5jbG9uZSgpLnN1Yihwb2ludFRvQ2hlY2spKTtcbiAgICAgICAgcmV0dXJuICFjLmxlbmd0aCgpO1xuICAgIH1cblxuICAgIHB1c2hQb3BIYW5kbGUgKCkge1xuICAgICAgICBsZXQgaGFuZGxlMCA9IHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtM107XG4gICAgICAgIGxldCBoYW5kbGUxID0gdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0yXTtcbiAgICAgICAgbGV0IG5ld2hhbmRsZSA9IHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV07XG5cbiAgICAgICAgdmFyIGlzT25MaW5lID0gdGhpcy5pc1BvaW50T25MaW5lKGhhbmRsZTAud29ybGRQb3NpdGlvbiwgaGFuZGxlMS53b3JsZFBvc2l0aW9uLCBuZXdoYW5kbGUud29ybGRQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGlzT25MaW5lKSB7XG4gICAgICAgICAgICBoYW5kbGUxLl9kb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGhhbmRsZTEpO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTJdID0gbmV3aGFuZGxlO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcy5wb3AoKTtcblxuICAgICAgICAgICAgbGV0IHRlbXBMaW5lID0gdGhpcy5fbGluZXMucG9wKCk7XG4gICAgICAgICAgICB0ZW1wTGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRlbXBMaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc09uTGluZTtcbiAgICB9XG5cbiAgICB1cGRhdGVMaW5lRE9NIChsaW5lSW5kZXgsIGhhbmRsZTBJbmRleCwgaGFuZGxlMUluZGV4KSB7XG4gICAgICAgIC8vIHVwZGF0ZSBydWxlcnMgbGluZXMgYW5kIHRleHQhXG4gICAgICAgIGxldCB4MSA9IHRoaXMuX2hhbmRsZXNbaGFuZGxlMEluZGV4XS5zY3JlZW5Qb3NpdGlvbi54O1xuICAgICAgICBsZXQgeTEgPSB0aGlzLl9oYW5kbGVzW2hhbmRsZTBJbmRleF0uc2NyZWVuUG9zaXRpb24ueTtcbiAgICAgICAgbGV0IHgyID0gdGhpcy5faGFuZGxlc1toYW5kbGUxSW5kZXhdLnNjcmVlblBvc2l0aW9uLng7XG4gICAgICAgIGxldCB5MiA9IHRoaXMuX2hhbmRsZXNbaGFuZGxlMUluZGV4XS5zY3JlZW5Qb3NpdGlvbi55O1xuXG4gICAgICAgIGxldCB4MCA9IHgyO1xuICAgICAgICBsZXQgeTAgPSB5MjtcblxuICAgICAgICBpZiAoeTEgPj0geTIpIHtcbiAgICAgICAgICAgIHkwID0geTIgLSAzMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkwID0geTIgKyAzMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW5ndGggPSBNYXRoLnNxcnQoKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpKTtcbiAgICAgICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEk7XG5cbiAgICAgICAgbGV0IHBvc1kgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy8gdXBkYXRlIGxpbmVcbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCAke3Bvc1l9cHgsIDApYDtcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XG5cbiAgICAgICAgLy90aGlzLl9saW5lc1tsaW5lSW5kZXhdLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgdGhpcy5fbGluZXNbbGluZUluZGV4XS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIHRoaXMuX2xpbmVzW2xpbmVJbmRleF0uc3R5bGUud2lkdGggPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9saW5lcykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZURPTShpbmRleCwgaW5kZXgsIHBhcnNlSW50KGluZGV4KSArIDEgPT0gdGhpcy5faGFuZGxlcy5sZW5ndGggPyAwIDogcGFyc2VJbnQoaW5kZXgpICsgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZURPTUNvbG9yKCkge1xuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgICB9XG5cbiAgICBnZXRQb2ludEluQmV0d2VlbkJ5UGVyYyhwb2ludEEsIHBvaW50QiwgcGVyY2VudGFnZSkge1xuXG4gICAgICAgIHZhciBkaXIgPSBwb2ludEIuY2xvbmUoKS5zdWIocG9pbnRBKTtcbiAgICAgICAgdmFyIGxlbiA9IGRpci5sZW5ndGgoKTtcbiAgICAgICAgZGlyID0gZGlyLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbipwZXJjZW50YWdlKTtcbiAgICAgICAgcmV0dXJuIHBvaW50QS5jbG9uZSgpLmFkZChkaXIpO1xuXG4gICAgfVxuXG4gICAgZ2V0IHdvcmxkUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHNldCB3b3JsZFBvc2l0aW9uKHdvcmxkUG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5faGFuZGxlcykge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0uX3dvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG59IiwiaW1wb3J0IFdpZGdldHNCYXNlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5iYXNlJztcbmltcG9ydCBXaWRnZXRzSGFuZGxlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5oYW5kbGUnO1xuXG4vKipcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c1J1bGVyIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKHRhcmdldE1lc2gsIGNvbnRyb2xzLCBjYW1lcmEsIGNvbnRhaW5lcikge1xuICAgIHN1cGVyKGNvbnRhaW5lcik7XG5cbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcblxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gdGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvLyBtZXNoIHN0dWZmXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcblxuICAgIC8vIGRvbSBzdHVmZlxuICAgIHRoaXMuX2xpbmUgPSBudWxsO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gbnVsbDtcblxuICAgIC8vIGFkZCBoYW5kbGVzXG4gICAgdGhpcy5faGFuZGxlcyA9IFtdO1xuXG4gICAgLy8gZmlyc3QgaGFuZGxlXG4gICAgbGV0IGZpcnN0SGFuZGxlID1cbiAgICAgIG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgZmlyc3RIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xuXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKGZpcnN0SGFuZGxlKTtcblxuICAgIGxldCBzZWNvbmRIYW5kbGUgPVxuICAgICAgbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICBzZWNvbmRIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgc2Vjb25kSGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xuICAgIC8vIGFjdGl2ZSBhbmQgdHJhY2tpbmcgbWlnaHQgYmUgcmVkdW5kYW50XG4gICAgc2Vjb25kSGFuZGxlLmFjdGl2ZSA9IHRydWU7XG4gICAgc2Vjb25kSGFuZGxlLnRyYWNraW5nID0gdHJ1ZTtcbiAgICB0aGlzLmFkZChzZWNvbmRIYW5kbGUpO1xuXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKHNlY29uZEhhbmRsZSk7XG5cbiAgICAvLyBDcmVhdGUgcnVsZXJcbiAgICB0aGlzLmNyZWF0ZSgpO1xuICAgIHRoaXMuaW5pdE9mZnNldHMoKTtcblxuICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uRW5kQ29udHJvbCA9IHRoaXMub25FbmRDb250cm9sLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xuXG4gICAgdGhpcy5fY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xuICB9XG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xuXG4gICAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xuICB9XG5cbiAgb25Nb3ZlKGV2dCkge1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2hhbmRsZXNbMF0ub25Nb3ZlKGV2dCk7XG4gICAgdGhpcy5faGFuZGxlc1sxXS5vbk1vdmUoZXZ0KTtcblxuICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9oYW5kbGVzWzBdLmhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1sxXS5ob3ZlcmVkO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBvblN0YXJ0KGV2dCkge1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9oYW5kbGVzWzBdLm9uU3RhcnQoZXZ0KTtcbiAgICB0aGlzLl9oYW5kbGVzWzFdLm9uU3RhcnQoZXZ0KTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2hhbmRsZXNbMF0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMV0uYWN0aXZlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBvbkVuZChldnQpIHtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XG4gICAgLy8gRmlyc3QgSGFuZGxlXG4gICAgdGhpcy5faGFuZGxlc1swXS5vbkVuZChldnQpO1xuXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMpO1xuXG4gICAgLy8gU2Vjb25kIEhhbmRsZVxuICAgIGlmICh0aGlzLl9kcmFnZ2VkIHx8ICF0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nKSB7XG4gICAgICB0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9oYW5kbGVzWzFdLm9uRW5kKGV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTdGF0ZSBvZiBydWxlciB3aWRnZXRcbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25FbmRDb250cm9sKCkge1xuICAgIGlmICghdGhpcy5fbGFzdEV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlKCkge1xuICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xuICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gIH1cblxuICBoaWRlRE9NKCkge1xuICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLmhpZGVET00oKTtcbiAgICB9XG4gIH1cblxuICBzaG93RE9NKCkge1xuICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5zaG93RE9NKCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZU1lc2goKSB7XG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gIH1cblxuICBzaG93TWVzaCgpIHtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnNob3dET00oKTtcbiAgICB0aGlzLnNob3dNZXNoKCk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMuaGlkZURPTSgpO1xuICAgIHRoaXMuaGlkZU1lc2goKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XG5cbiAgICAvLyB1cGRhdGUgaGFuZGxlc1xuICAgIHRoaXMuX2hhbmRsZXNbMF0udXBkYXRlKCk7XG4gICAgdGhpcy5faGFuZGxlc1sxXS51cGRhdGUoKTtcblxuICAgIC8vIG1lc2ggc3R1ZmZcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuICAgIHRoaXMudXBkYXRlTWVzaFBvc2l0aW9uKCk7XG5cbiAgICAvLyBET00gc3R1ZmZcbiAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XG4gICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xuICB9XG5cbiAgY3JlYXRlTWVzaCgpIHtcbiAgICAvLyBnZW9tZXRyeVxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24pO1xuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uKTtcblxuICAgIC8vIG1hdGVyaWFsXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuXG4gICAgLy8gbWVzaFxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvLyBhZGQgaXQhXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XG4gIH1cblxuICB1cGRhdGVNZXNoQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRE9NKCkge1xuICAgIC8vIGFkZCBsaW5lIVxuICAgIHRoaXMuX2xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnV1aWQpO1xuICAgIHRoaXMuX2xpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdBTUkgV2lkZ2V0IFJ1bGVyJyk7XG4gICAgdGhpcy5fbGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICB0aGlzLl9saW5lLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcbiAgICB0aGlzLl9saW5lLnN0eWxlLmhlaWdodCA9ICcycHgnO1xuICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSAnM3B4JztcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGluZSk7XG5cbiAgICAvLyBhZGQgZGlzdGFuY2UhXG4gICAgdGhpcy5fZGlzdGFuY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kaXN0YW5jZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGRpc3RhbmNlJyk7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCc7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xuICAgIC8vIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5jb2xvciA9ICcjMzUzNTM1JztcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5wYWRkaW5nID0gJzRweCc7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xuICAgIHRoaXMuX2Rpc3RhbmNlLmlubmVySFRNTCA9ICdIZWxsbywgd29ybGQhJztcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGlzdGFuY2UpO1xuXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xuICB9XG5cbiAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XG4gICAgLy8gdXBkYXRlIHJ1bGVycyBsaW5lcyBhbmQgdGV4dCFcbiAgICBsZXQgeDEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLng7XG4gICAgbGV0IHkxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55O1xuICAgIGxldCB4MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueDtcbiAgICBsZXQgeTIgPSB0aGlzLl9oYW5kbGVzWzFdLnNjcmVlblBvc2l0aW9uLnk7XG5cbiAgICAvL2xldCB4MCA9IHgxICsgKHgyIC0geDEpLzI7XG4gICAgLy9sZXQgeTAgPSB5MSArICh5MiAtIHkxKS8yO1xuICAgIGxldCB4MCA9IHgyO1xuICAgIGxldCB5MCA9IHkyO1xuXG4gICAgaWYgKHkxID49IHkyKSB7XG4gICAgICB5MCA9IHkyIC0gMzA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkwID0geTIgKyAzMDtcbiAgICB9XG5cbiAgICBsZXQgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEk7XG5cbiAgICBsZXQgcG9zWSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgIC8vIHVwZGF0ZSBsaW5lXG4gICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCR7cG9zWX1weCwgMClgO1xuICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xuXG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aDtcblxuICAgIC8vIHVwZGF0ZSBkaXN0YW5jZVxuICAgIGxldCB3MCA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbjtcbiAgICBsZXQgdzEgPSB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb247XG5cbiAgICB0aGlzLl9kaXN0YW5jZS5pbm5lckhUTUwgPVxuICAgICAgYCR7XG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAodzAueC13MS54KSoodzAueC13MS54KSArXG4gICAgICAgICAgKHcwLnktdzEueSkqKHcwLnktdzEueSkgK1xuICAgICAgICAgICh3MC56LXcxLnopKih3MC56LXcxLnopXG4gICAgICAgICkudG9GaXhlZCgyKX0gbW1gO1xuICAgIGxldCBwb3NZMCA9XG4gICAgICB5MCAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRIZWlnaHQvMjtcbiAgICB4MCAtPSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRXaWR0aC8yO1xuXG4gICAgbGV0IHRyYW5zZm9ybTIgPVxuICAgICAgYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MCl9cHgsJHtNYXRoLnJvdW5kKHBvc1kwKX1weCwgMClgO1xuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTI7XG4gIH1cblxuICB1cGRhdGVET01Db2xvcigpIHtcbiAgICB0aGlzLl9saW5lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xuICB9XG5cbiAgZnJlZSgpIHtcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG5cbiAgICB0aGlzLl9oYW5kbGVzLmZvckVhY2goKGgpID0+IHtcbiAgICAgIGguZnJlZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faGFuZGxlcyA9IFtdO1xuXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2xpbmUpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9kaXN0YW5jZSk7XG5cbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9tZXNoKTtcblxuICAgIHN1cGVyLmZyZWUoKTtcbiAgfVxuXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xuICAgIHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxufVxuIiwiXG5pbXBvcnQgV2lkZ2V0c0Jhc2UgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmJhc2UnO1xuaW1wb3J0IEdlb21ldHJpZXNWb3hlbCBmcm9tICcuLi9nZW9tZXRyaWVzL2dlb21ldHJpZXMudm94ZWwnO1xuaW1wb3J0IE1vZGVsc1N0YWNrIGZyb20gJy4uL21vZGVscy9tb2RlbHMuc3RhY2snO1xuaW1wb3J0IE1vZGVsc1ZveGVsIGZyb20gJy4uL21vZGVscy9tb2RlbHMudm94ZWwnO1xuaW1wb3J0IENvcmVJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcblxuLyoqXG4gKiBAbW9kdWxlIHdpZGdldHMvdm94ZWxQcm9iZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpZGdldHNWb3hlbFByb2JlIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xuICBjb25zdHJ1Y3RvcihzdGFjaywgdGFyZ2V0TWVzaCwgY29udHJvbHMsIGNhbWVyYSwgY29udGFpbmVyKSB7XG4gICAgc3VwZXIoY29udGFpbmVyKTtcblxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG5cbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcblxuICAgIC8vIGlmIG5vIHRhcmdldCBtZXNoLCB1c2UgcGxhbmUgZm9yIEZSRUUgZHJhZ2dpbmcuXG4gICAgdGhpcy5fcGxhbmUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgfTtcblxuICAgIHRoaXMuX29mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5fcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuXG4gICAgdGhpcy5fdHJhY2tpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX21vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgLy8gd29ybGQgKExQUykgcG9zaXRpb24gb2YgdGhlIGNlbnRlclxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgLy8gc2NyZWVuIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXJcbiAgICB0aGlzLl9zY3JlZW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAvLyBtZXNoIHN0dWZmXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoRGlzcGxheWVkID0gdHJ1ZTtcbiAgICB0aGlzLl9tZXNoSG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX21lc2hTdHlsZSA9ICdzcGhlcmUnOyAvLyBjdWJlLCBldGMuXG5cbiAgICAvLyBkb20gc3R1ZmZcbiAgICB0aGlzLl9kb20gPSBudWxsO1xuICAgIHRoaXMuX2RvbURpc3BsYXllZCA9IHRydWU7XG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RvbVN0eWxlID0gJ2NpcmNsZSc7IC8vIHNxdWFyZSwgdHJpYW5nbGVcblxuICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkodGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPVxuICAgICAgdGhpcy53b3JsZFRvU2NyZWVuKHRoaXMuX3dvcmxkUG9zaXRpb24sIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcblxuICAgIC8vIGNyZWF0ZSBoYW5kbGVcbiAgICB0aGlzLmNyZWF0ZSgpO1xuICAgIHRoaXMuaW5pdE9mZnNldHMoKTtcblxuICAgIC8vIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uSG92ZXIgPSB0aGlzLm9uSG92ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uRW5kQ29udHJvbCA9IHRoaXMub25FbmRDb250cm9sLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXIpO1xuICAgIHRoaXMuX2RvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbkhvdmVyKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcblxuICAgIHRoaXMuX2NvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIHRoaXMub25FbmRDb250cm9sKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2RvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkhvdmVyKTtcbiAgICB0aGlzLl9kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Ib3Zlcik7XG5cbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG5cbiAgICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLm9uRW5kQ29udHJvbCk7XG4gIH1cblxuICBvblN0YXJ0KGV2dCkge1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLmdldE1vdXNlT2Zmc2V0cyhldnQsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgdGhpcy5fbW91c2Uuc2V0KG9mZnNldHMueCwgb2Zmc2V0cy55KTtcblxuICAgIC8vIHVwZGF0ZSByYXljYXN0ZXJcbiAgICB0aGlzLl9yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLl9tb3VzZSwgdGhpcy5fY2FtZXJhKTtcbiAgICB0aGlzLl9yYXljYXN0ZXIucmF5LnBvc2l0aW9uID0gdGhpcy5fcmF5Y2FzdGVyLnJheS5vcmlnaW47XG5cbiAgICBpZiAodGhpcy5faG92ZXJlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX3RhcmdldE1lc2gpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdHNUYXJnZXQgPVxuICAgICAgICAgIHRoaXMuX3JheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QodGhpcy5fdGFyZ2V0TWVzaCk7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzVGFyZ2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQuY29weShpbnRlcnNlY3RzVGFyZ2V0WzBdLnBvaW50KS5zdWIodGhpcy5fd29ybGRQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYW5lLnBvc2l0aW9uLmNvcHkodGhpcy5fd29ybGRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XG4gICAgICAgICAgQ29yZUludGVyc2VjdGlvbnMucmF5UGxhbmUodGhpcy5fcmF5Y2FzdGVyLnJheSwgdGhpcy5fcGxhbmUpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkoaW50ZXJzZWN0aW9uKS5zdWIodGhpcy5fcGxhbmUucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgb25FbmQoZXZ0KSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gc3RheSBhY3RpdmUgYW5kIGtlZXAgY29udHJvbHMgZGlzYWJsZWRcbiAgICBpZiAodGhpcy5fdHJhY2tpbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1bnNlbGVjdCBpZiBnbyB1cCB3aXRob3V0IG1vdmluZ1xuICAgIGlmICghdGhpcy5fZHJhZ2dlZCAmJiB0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIGNoYW5nZSBzdGF0ZSBpZiB3YXMgbm90IGRyYWdnaW5nXG4gICAgICB0aGlzLl9zZWxlY3RlZCA9ICF0aGlzLl9zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fY29udHJvbHMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25FbmRDb250cm9sKCkge1xuICAgIGlmICghdGhpcy5fbGFzdEV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Nb3ZlKGV2dCkge1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLmdldE1vdXNlT2Zmc2V0cyhldnQsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgdGhpcy5fbW91c2Uuc2V0KG9mZnNldHMueCwgb2Zmc2V0cy55KTtcblxuICAgIC8vIHVwZGF0ZSByYXljYXN0ZXJcbiAgICAvLyBzZXQgcmF5LnBvc2l0aW9uIHRvIHNhdGlzZnkgQ29yZUludGVyc2VjdGlvbnM6OnJheVBsYW5lIEFQSVxuICAgIHRoaXMuX3JheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHRoaXMuX21vdXNlLCB0aGlzLl9jYW1lcmEpO1xuICAgIHRoaXMuX3JheWNhc3Rlci5yYXkucG9zaXRpb24gPSB0aGlzLl9yYXljYXN0ZXIucmF5Lm9yaWdpbjtcblxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2RyYWdnZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgaW50ZXJzZWN0c1RhcmdldCA9XG4gICAgICAgICAgdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl90YXJnZXRNZXNoKTtcbiAgICAgICAgaWYgKGludGVyc2VjdHNUYXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weShpbnRlcnNlY3RzVGFyZ2V0WzBdLnBvaW50LnN1Yih0aGlzLl9vZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgIC8vIGZyZWUgbW9kZSF0aGlzLl90YXJnZXRNZXNoXG4gICAgICAgICAgdGhpcy5fcGxhbmUucG9zaXRpb24uY29weSh0aGlzLl93b3JsZFBvc2l0aW9uKTtcbiAgICAgICAgICB0aGlzLl9wbGFuZS5kaXJlY3Rpb24uY29weSh0aGlzLl9jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oKSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XG4gICAgICAgICAgQ29yZUludGVyc2VjdGlvbnMucmF5UGxhbmUodGhpcy5fcmF5Y2FzdGVyLnJheSwgdGhpcy5fcGxhbmUpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KGludGVyc2VjdGlvbi5zdWIodGhpcy5fb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkhvdmVyKG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBvbkhvdmVyKGV2dCkge1xuICAgIGlmIChldnQpIHtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5ob3ZlckRvbShldnQpO1xuICAgIH1cblxuICAgIHRoaXMuaG92ZXJNZXNoKCk7XG5cbiAgICB0aGlzLl9ob3ZlcmVkID0gdGhpcy5fbWVzaEhvdmVyZWQgfHwgdGhpcy5fZG9tSG92ZXJlZDtcbiAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gdGhpcy5faG92ZXJlZCA/ICdwb2ludGVyJyA6ICdkZWZhdWx0JztcbiAgfVxuXG4gIGhvdmVyTWVzaCgpIHtcbiAgICAvLyBjaGVjayByYXljYXN0IGludGVyc2VjdGlvbiwgZG8gd2Ugd2FudCB0byBob3ZlciBvbiBtZXNoIG9yIGp1c3QgY3NzP1xuICAgIGxldCBpbnRlcnNlY3RzSGFuZGxlID0gdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl9tZXNoKTtcbiAgICB0aGlzLl9tZXNoSG92ZXJlZCA9IChpbnRlcnNlY3RzSGFuZGxlLmxlbmd0aCA+IDApO1xuICB9XG5cbiAgaG92ZXJEb20oZXZ0KSB7XG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IChldnQudHlwZSA9PT0gJ21vdXNlZW50ZXInKTtcbiAgfVxuXG4gIHdvcmxkVG9TY3JlZW4od29ybGRDb29yZGluYXRlLCBjYW1lcmEsIGNhbnZhcykge1xuICAgIGxldCBzY3JlZW5Db29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZS5jbG9uZSgpO1xuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnByb2plY3QoY2FtZXJhKTtcblxuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnggPVxuICAgICAgTWF0aC5yb3VuZCgoc2NyZWVuQ29vcmRpbmF0ZXMueCArIDEpICogY2FudmFzLm9mZnNldFdpZHRoIC8gMik7XG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueSA9XG4gICAgICBNYXRoLnJvdW5kKCgtc2NyZWVuQ29vcmRpbmF0ZXMueSArIDEpICogY2FudmFzLm9mZnNldEhlaWdodCAvIDIpO1xuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnogPSAwO1xuXG4gICAgcmV0dXJuIHNjcmVlbkNvb3JkaW5hdGVzO1xuICB9XG5cbiAgY3JlYXRlKCkge1xuICAgIHRoaXMuY3JlYXRlVm94ZWwoKTtcbiAgICB0aGlzLmNyZWF0ZU1lc2goKTtcbiAgICB0aGlzLmNyZWF0ZURPTSgpO1xuICB9XG5cbiAgY3JlYXRlVm94ZWwoKSB7XG4gICAgdGhpcy5fdm94ZWwgPSBuZXcgTW9kZWxzVm94ZWwoKTtcbiAgICB0aGlzLl92b3hlbC5pZCA9IHRoaXMuaWQ7XG4gICAgdGhpcy5fdm94ZWwud29ybGRDb29yZGluYXRlcyA9IHRoaXMuX3dvcmxkQ29vcmRpbmF0ZXM7XG4gIH1cblxuICBjcmVhdGVNZXNoKCkge1xuICAgIGNvbnN0IGRhdGFDb29yZGluYXRlcyA9IE1vZGVsc1N0YWNrLndvcmxkVG9EYXRhKFxuICAgICAgdGhpcy5fc3RhY2ssXG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uKTtcblxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNWb3hlbChkYXRhQ29vcmRpbmF0ZXMpO1xuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgICB3aXJlZnJhbWVMaW5ld2lkdGg6IDEsXG4gICAgICB9KTtcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcbiAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX3N0YWNrLmlqazJMUFMpO1xuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XG4gIH1cblxuICB1cGRhdGVNZXNoQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZURPTSgpIHtcbiAgICAvLyBkb21cbiAgICB0aGlzLl9kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kb20uc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMudXVpZCk7XG4gICAgdGhpcy5fZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnQU1JIFdpZGdldCBWb3hlbFByb2JlJyk7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlciA9ICcycHggc29saWQgIzAwMCc7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2IoMjQ5LCAyNDksIDI0OSknO1xuICAgIHRoaXMuX2RvbS5zdHlsZS5jb2xvciA9ICcjMjEyMTIxJztcbiAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2RvbS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMHB4IDEwMCUgMHB4JztcblxuICAgIC8vIG1lYXN1cmVuZW50c1xuICAgIGxldCBtZWFzdXJlbWVudHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvLyBMUFNcbiAgICBsZXQgbHBzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbHBzQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAnbHBzUG9zaXRpb24nKTtcbiAgICBtZWFzdXJlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQobHBzQ29udGFpbmVyKTtcbiAgICAvLyBJSktcbiAgICBsZXQgaWprQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWprQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAnaWprUG9zaXRpb24nKTtcbiAgICBtZWFzdXJlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQoaWprQ29udGFpbmVyKTtcbiAgICAvLyBWYWx1ZVxuICAgIGxldCB2YWx1ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhbHVlQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAndmFsdWUnKTtcbiAgICBtZWFzdXJlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQodmFsdWVDb250YWluZXIpO1xuXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xuICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZChtZWFzdXJlbWVudHNDb250YWluZXIpO1xuXG4gICAgLy8gYWRkIGl0IVxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kb20pO1xuICB9XG5cbiAgdXBkYXRlRE9NQ29udGVudCgpIHtcbiAgICBjb25zdCByYXNDb250YWluZXIgPSB0aGlzLl9kb20ucXVlcnlTZWxlY3RvcignI2xwc1Bvc2l0aW9uJyk7XG4gICAgcmFzQ29udGFpbmVyLmlubmVySFRNTCA9IGBMUFM6IFxuICAgICAgJHt0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzLngudG9GaXhlZCgyKX0gOlxuICAgICAgJHt0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzLnkudG9GaXhlZCgyKX0gOlxuICAgICAgJHt0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzLnoudG9GaXhlZCgyKX1gO1xuXG4gICAgY29uc3QgaWprQ29udGFpbmVyID0gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IoJyNpamtQb3NpdGlvbicpO1xuICAgIGlqa0NvbnRhaW5lci5pbm5lckhUTUwgPSBgSUpLOiBcbiAgICAgICR7dGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzLnh9IDpcbiAgICAgICR7dGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzLnl9IDpcbiAgICAgICR7dGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzLnp9YDtcblxuICAgIGNvbnN0IHZhbHVlQ29udGFpbmVyID0gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IoJyN2YWx1ZScpO1xuICAgIHZhbHVlQ29udGFpbmVyLmlubmVySFRNTCA9IGBWYWx1ZTogJHt0aGlzLl92b3hlbC52YWx1ZX1gO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIGdlbmVyYWwgdXBkYXRlXG4gICAgdGhpcy51cGRhdGVDb2xvcigpO1xuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID1cbiAgICAgIHRoaXMud29ybGRUb1NjcmVlbih0aGlzLl93b3JsZFBvc2l0aW9uLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAvLyBzZXQgZGF0YSBjb29yZGluYXRlcyAmJiB2YWx1ZVxuICAgIHRoaXMudXBkYXRlVm94ZWwodGhpcy5fd29ybGRQb3NpdGlvbik7XG5cbiAgICAvLyB1cGRhdGUgbWVzaCBwb3NpdGlvblxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XG4gICAgaWYgKHRoaXMuX21lc2ggJiYgdGhpcy5fbWVzaC5nZW9tZXRyeSkge1xuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5sb2NhdGlvbiA9IHRoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcztcbiAgICAgIHRoaXMuX21lc2gudXBkYXRlTWF0cml4KCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGRvbVxuICAgIHRoaXMudXBkYXRlRE9NQ29udGVudCgpO1xuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB0aGlzLnVwZGF0ZURPTVBvc2l0aW9uKCk7XG4gIH1cblxuXG4gIHVwZGF0ZVZveGVsKHdvcmxkQ29vcmRpbmF0ZXMpIHtcbiAgICAvLyB1cGRhdGUgd29ybGQgY29vcmRpbmF0ZXNcbiAgICB0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzID0gd29ybGRDb29yZGluYXRlcztcblxuICAgIC8vIHVwZGF0ZSBkYXRhIGNvb3JkaW5hdGVzXG4gICAgdGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzID0gTW9kZWxzU3RhY2sud29ybGRUb0RhdGEoXG4gICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayxcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3ZveGVsLndvcmxkQ29vcmRpbmF0ZXMpO1xuXG4gICAgLy8gdXBkYXRlIHZhbHVlXG4gICAgbGV0IHZhbHVlID0gTW9kZWxzU3RhY2sudmFsdWUoXG4gICAgICB0aGlzLl9zdGFjayxcbiAgICAgIHRoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcyk7XG5cbiAgICB0aGlzLl92b3hlbC52YWx1ZSA9IE1vZGVsc1N0YWNrLnZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0KFxuICAgICAgdmFsdWUsXG4gICAgICB0aGlzLl9zdGFjay5yZXNjYWxlU2xvcGUsXG4gICAgICB0aGlzLl9zdGFjay5yZXNjYWxlSW50ZXJjZXB0KTtcbiAgfVxuXG4gIHVwZGF0ZURPTVBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLl9kb20pIHtcbiAgICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLl9kb20uc3R5bGUudHJhbnNmb3JtID1cbiAgICAgICAgYHRyYW5zbGF0ZTNEKCR7dGhpcy5fc2NyZWVuUG9zaXRpb24ueH1weCwgJHtwb3NZfXB4LCAwKWA7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRE9NQ29sb3IoKSB7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgfVxuXG4gIGZyZWUoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyLlxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwSGFuZGxlciwgZmFsc2UpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5cbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICB0aGlzLl9jb250YWluZXIuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdXNlTW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICB0aGlzLl9jb250YWluZXIuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3VzZU1vdmVIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICB0aGlzLl92b3hlbC5yZW1vdmVUZXN0KCk7XG4gICAgdGhpcy5yZW1vdmUodGhpcy5fdm94ZWwpO1xuICAgIHRoaXMuX3ZveGVsID0gbnVsbDtcblxuICAgIHN1cGVyLmZyZWUoKTtcbiAgfVxuXG4gIGhvdmVyVm94ZWwobW91c2VTY3JlZW5Db29yZGluYXRlcywgY3VycmVudERhdGFDb29yZGluYXRlcykge1xuICAgIC8vIHVwZGF0ZSBkaXN0YW5jZSBtb3VzZS90aGlzLl92b3hlbFxuICAgIGxldCBkeCA9XG4gICAgICBtb3VzZVNjcmVlbkNvb3JkaW5hdGVzLnNjcmVlblggLSB0aGlzLl92b3hlbC52b3hlbC5zY3JlZW5Db29yZGluYXRlcy54O1xuICAgIGxldCBkeSA9XG4gICAgICBtb3VzZVNjcmVlbkNvb3JkaW5hdGVzLnNjcmVlblkgLSB0aGlzLl92b3hlbC52b3hlbC5zY3JlZW5Db29yZGluYXRlcy55O1xuICAgIGxldCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgdGhpcy5fdm94ZWwuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBpZiAoZGlzdGFuY2UgPj0gMCAmJiBkaXN0YW5jZSA8IDEwKSB7XG4gICAgICB0aGlzLl9ob3ZlciA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hvdmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weSh3b3JsZFBvc2l0aW9uKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgc2V0IGRlZmF1bHRDb2xvcihkZWZhdWx0Q29sb3IpIHtcbiAgICB0aGlzLl9kZWZhdWx0Q29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBkZWZhdWx0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRDb2xvcjtcbiAgfVxuXG4gIHNldCBhY3RpdmVDb2xvcihhY3RpdmVDb2xvcikge1xuICAgIHRoaXMuX2FjdGl2ZUNvbG9yID0gYWN0aXZlQ29sb3I7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBhY3RpdmVDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlQ29sb3I7XG4gIH1cblxuICBzZXQgaG92ZXJDb2xvcihob3ZlckNvbG9yKSB7XG4gICAgdGhpcy5faG92ZXJDb2xvciA9IGhvdmVyQ29sb3I7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBob3ZlckNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3ZlckNvbG9yO1xuICB9XG5cbiAgc2V0IHNlbGVjdGVkQ29sb3Ioc2VsZWN0ZWRDb2xvcikge1xuICAgIHRoaXMuX3NlbGVjdGVkQ29sb3IgPSBzZWxlY3RlZENvbG9yO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRDb2xvcjtcbiAgfVxuXG4gIHNldCBzaG93Vm94ZWwoc2hvd1ZveGVsKSB7XG4gICAgdGhpcy5fc2hvd1ZveGVsID0gc2hvd1ZveGVsO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgc2hvd1ZveGVsKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93Vm94ZWw7XG4gIH1cblxuICBzZXQgc2hvd0RvbVNWRyhzaG93RG9tU1ZHKSB7XG4gICAgdGhpcy5fc2hvd0RvbVNWRyA9IHNob3dEb21TVkc7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBzaG93RG9tU1ZHKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93RG9tU1ZHO1xuICB9XG5cbiAgc2V0IHNob3dEb21NZWFzdXJlbWVudHMoc2hvd0RvbU1lYXN1cmVtZW50cykge1xuICAgIHRoaXMuX3Nob3dEb21NZWFzdXJlbWVudHMgPSBzaG93RG9tTWVhc3VyZW1lbnRzO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgc2hvd0RvbU1lYXN1cmVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvd0RvbU1lYXN1cmVtZW50cztcbiAgfVxufVxuIl19
